                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwWritten;
    while(!(bRes = WriteFile(hFile, pBuffer, dwBufferLen, &dwWritten, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nWriteFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
        else
            return ERROR_SUCCESS;
    }
}

long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51WriteToFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwWritten;
        if(!GetOverlappedResult(hFile, &ov, &dwWritten, TRUE))
            return GetLastError();
    
        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}
    
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    long lRes;

    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwRead;
    while(!(bRes = ReadFile(hFile, pBuffer, dwBufferLen, &dwRead, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nReadFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        if(GetLastError() == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            if(lRes == ERROR_HANDLE_EOF)
                lRes = ERROR_SUCCESS;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        return ERROR_SUCCESS;
    }
}

long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51ReadFromFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwRead = 0;
        if(!GetOverlappedResult(hFile, &ov, &dwRead, TRUE))
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            if(lRes == ERROR_HANDLE_EOF)
                lRes = ERROR_SUCCESS;
            return lRes;
        }
    }

    return ERROR_SUCCESS;
}
    
    

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath, bool bAbortOnFiles);
long A51RemoveDirectory(LPCWSTR wszFullPath, bool bAbortOnFiles)
{
    long lRes = RemoveDirectoryRecursive(wszFullPath, bAbortOnFiles);
    if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;
    else
        return lRes;
}

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath, bool bAbortOnFiles)
{
    long lRes;

    //
    // Try removing it right away
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        long lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes != ERROR_DIR_NOT_EMPTY && lRes != ERROR_SHARING_VIOLATION)
            return lRes;
    }
    else 
        return ERROR_SUCCESS;

    //
    // Not empty (or at least we are not sure it is empty) --- enumerate 
    // everything
    //

    CFileName wszMap;
	if (wszMap == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszMap, wszDirectoryPath);
    wcscat(wszMap, L"\\*");

    CFileName wszChild;
	if (wszChild == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszChild, wszDirectoryPath);
    wcscat(wszChild, L"\\");
    long lChildLen = wcslen(wszChild);

    WIN32_FIND_DATAW fd;
    HANDLE hSearch = FindFirstFileW(wszMap, &fd);
    if(hSearch == INVALID_HANDLE_VALUE)
        return ERROR_DIR_NOT_EMPTY;

    do
    {
        if(fd.cFileName[0] == L'.')
            continue;

        if((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            if(bAbortOnFiles)
            {
                // There is a file --- give up
                FindClose(hSearch);
                return ERROR_DIR_NOT_EMPTY;
            }
            else
            {
                wcscpy(wszChild + lChildLen, fd.cFileName);
                if(!DeleteFileW(wszChild))
                {
                    FindClose(hSearch);
                    return GetLastError();
                }
            }
        }
        else
        {
            wcscpy(wszChild + lChildLen, fd.cFileName);
            lRes = RemoveDirectoryRecursive(wszChild, bAbortOnFiles);
            if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
            {
                FindClose(hSearch);
                return lRes;
            }
        }
    }
    while(FindNextFileW(hSearch, &fd));

    FindClose(hSearch);
            
    //
    // And try again
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        long lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes == ERROR_SHARING_VIOLATION)
            return ERROR_SUCCESS;
        else 
            return lRes;
    }

    return ERROR_SUCCESS;
}
    
CRITICAL_SECTION g_csLog;
char* g_szText = NULL;
long g_lTextLen = 0;
WCHAR g_wszLogFilename[MAX_PATH] = L"";
void A51Trace(LPCSTR szFormat, ...)
{
    if((g_wszLogFilename[0] == 0) || (g_szText == NULL))
    {
        InitializeCriticalSection(&g_csLog);

		delete g_szText;
		g_wszLogFilename[0] = 0;
		g_szText = NULL;

		HKEY hKey;
		long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
						0, KEY_READ, &hKey);
		if(lRes)
		{
			wcscpy(g_wszLogFilename, L"c:\\a51.log");
		}
		else
		{
			DWORD dwLen = MAX_PATH;
			CFileName wszTmp;
			if (wszTmp == 0)
			{
				wcscpy(g_wszLogFilename, L"c:\\a51.log");
				RegCloseKey(hKey);
			}
			else
			{
				lRes = RegQueryValueExW(hKey, L"Logging Directory", NULL, NULL, 
							(LPBYTE)(wchar_t*)wszTmp, &dwLen);
				RegCloseKey(hKey);
				if(lRes)
				{
					wcscpy(g_wszLogFilename, L"c:\\a51.log");
				}
				else
				{
					if (ExpandEnvironmentStringsW(wszTmp,g_wszLogFilename,MAX_PATH) == 0)
					{
						wcscpy(g_wszLogFilename, L"c:\\a51.log");
					}
					else
					{
						if (g_wszLogFilename[wcslen(g_wszLogFilename)] == L'\\')
						{
							wcscat(g_wszLogFilename, L"a51.log");
						}
						else
						{
							wcscat(g_wszLogFilename, L"\\a51.log");
						}
					}
				}
			}
		}
        
        g_szText = new char[3000000];
		if (g_szText == NULL)
			return;
    }

    EnterCriticalSection(&g_csLog);
    
    char szBuffer[256];
    va_list argptr;
    va_start(argptr, szFormat);
    vsprintf(szBuffer, szFormat, argptr);
    long lLen = strlen(szBuffer);
    if(g_lTextLen + lLen > 2900000)
        A51TraceFlush();

    strcpy(g_szText + g_lTextLen, szBuffer);
    g_lTextLen += lLen;

    LeaveCriticalSection(&g_csLog);
}

void A51TraceFlush()
{
	FILE* fLog = NULL;
	fLog = _wfopen(g_wszLogFilename, L"a");
    if(fLog)
    {
        fwrite(g_szText, 1, g_lTextLen, fLog);
        g_lTextLen = 0;
//      fflush(fLog);
		fclose(fLog);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\btr.cpp ===
//***************************************************************************
//
//  BTR.CPP
//
//  WMI disk-based B-tree implementation for repository index
//
//  raymcc  15-Oct-00    Prepared for Whistler Beta 2 to reduce file count
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <reposit.h>
#include <stdlib.h>
#include <arena.h>
#include <math.h>
#include <btr.h>

#define MAX_WORD_VALUE          0xFFFF
#define MAX_TOKENS_PER_KEY      32
#define MAX_FLUSH_INTERVAL      4000

//#define MAX_PAGE_HISTORY        1024

/*

Notes:

 (a) Modify allocators to special case for page-size
 (b) Modify WriteIdxPage to not rewrite if no deltas
 (c) ERROR_PATH_NOT_FOUND if starting enum has no presence; GPF presently
 (d) Do a history of page hits and see if caching would be helpful

*/

//static WORD History[MAX_PAGE_HISTORY] = {0};

LONG g_lAllocs = 0;

//***************************************************************************
//
//  _BtrMemAlloc
//
//***************************************************************************
// ok
LPVOID WINAPI _BtrMemAlloc(
    SIZE_T dwBytes  // number of bytes to allocate
    )
{
    // Lookaside for items of page size, default array size, default
    // string pool size
    g_lAllocs++;
    return HeapAlloc(CWin32DefaultArena::GetArenaHeap(), HEAP_ZERO_MEMORY, dwBytes);
}

//***************************************************************************
//
//  _BtrMemReAlloc
//
//***************************************************************************
// ok
LPVOID WINAPI _BtrMemReAlloc(
    LPVOID pOriginal,
    DWORD dwNewBytes
    )
{
    return HeapReAlloc(CWin32DefaultArena::GetArenaHeap(), HEAP_ZERO_MEMORY, pOriginal, dwNewBytes);
}

//***************************************************************************
//
//  _BtrMemFree
//
//***************************************************************************
// ok
BOOL WINAPI _BtrMemFree(LPVOID pMem)
{
    if (pMem == 0)
        return TRUE;
    g_lAllocs--;
    return HeapFree(CWin32DefaultArena::GetArenaHeap(), 0, pMem);
}




//***************************************************************************
//
//  CPageSource::CPageSource
//
//***************************************************************************
// ok
CPageSource::CPageSource()
{
    m_dwPageSize = 0;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwTotalPages = 0;
    m_dwLogicalRoot = 0;
    m_dwNextFreePage = 0;
    m_dwLastFlushTime = GetCurrentTime();
}

//***************************************************************************
//
//  CPageSource::CPageSource
//
//***************************************************************************
//  ok
CPageSource::~CPageSource()
{
}


//***************************************************************************
//
//  CPageSource::Shutdown
//
//***************************************************************************
//  ok
DWORD CPageSource::Shutdown(DWORD dwShutDownFlags)
{
#ifdef A51_STAGE_BELOW_INDEX
#else
    CloseHandle(m_hFile);
#endif

    m_dwPageSize = 0;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwTotalPages = 0;
    m_dwLogicalRoot = 0;
    m_dwNextFreePage = 0;

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::WriteAdminPage
//
//  Rewrites the admin page.  There is no need to update the pagesize,
//  version, etc.
//
//***************************************************************************
//  ok
DWORD CPageSource::WriteAdminPage()
{
    LPDWORD pPageZero = 0;
    DWORD dwRes = GetPage(0, (LPVOID *) &pPageZero);
    if (dwRes)
        return dwRes;

    pPageZero[OFFSET_LOGICAL_ROOT] = m_dwLogicalRoot;
    pPageZero[OFFSET_TOTAL_PAGES] = m_dwTotalPages;
    pPageZero[OFFSET_FREE_LIST_ROOT] = m_dwNextFreePage;

    dwRes = PutPage(pPageZero, PAGE_TYPE_ADMIN);
    _BtrMemFree(pPageZero);
    return dwRes;
}

//***************************************************************************
//
//  CPageSource::SetRootPage
//
//***************************************************************************
//
DWORD CPageSource::SetRootPage(DWORD dwNewRoot)
{
    m_dwLogicalRoot = dwNewRoot;
    return WriteAdminPage();
}


//***************************************************************************
//
//  CPageSource::Init
//
//  The real "constructor" which opens the file
//
//***************************************************************************
// ok
DWORD CPageSource::Init(
    DWORD dwPageSize,
    LPWSTR pszFilename
#ifdef A51_STAGE_BELOW_INDEX
    , CAbstractFileSource* pSource
#endif
    )
{
    DWORD dwLastError = 0;

    m_dwPageSize = dwPageSize;
    DWORD dwFileFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;

    m_hFile = CreateFileW(pszFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0,
        OPEN_EXISTING, dwFileFlags, 0);
    dwLastError = GetLastError();

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        if (dwLastError != ERROR_FILE_NOT_FOUND)
            return dwLastError;

        // If here, we have to create a new file.
        m_hFile = CreateFileW(pszFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0,
            CREATE_ALWAYS, dwFileFlags, 0);

        if (m_hFile == INVALID_HANDLE_VALUE)
            return GetLastError();

#ifdef A51_STAGE_BELOW_INDEX
        long lRes = pSource->Register(m_hFile, A51_INDEX_FILE_ID, true,
                                        &m_pFile);
        if(lRes != ERROR_SUCCESS)
        {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
            return lRes;
        }
#endif

        // Set up initial two pages
        Setup();
    }
    else
    {
        // File exists. Verify that the file is an integral number of pages based
        // on the specified page size.
        DWORD dwLen = SetFilePointer(m_hFile, 0, 0, FILE_END);
        if (dwLen % dwPageSize != 0)
        {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
            return ERROR_BAD_FORMAT;
        }

#ifdef A51_STAGE_BELOW_INDEX
        long lRes = pSource->Register(m_hFile, A51_INDEX_FILE_ID, true,
                                        &m_pFile);
        if(lRes != ERROR_SUCCESS)
        {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
            return lRes;
        }
#endif
    }


    return ReadAdminPage();
}


//***************************************************************************
//
//  CPageSource::ReadAdminPage
//
//***************************************************************************
// ok
DWORD CPageSource::ReadAdminPage()
{
    LPDWORD pPageZero = 0;
    DWORD dwRes = 0;

    dwRes = GetPage(0, (LPVOID *) &pPageZero);
    if (dwRes)
        return dwRes;

    // Grab useful info from these amazing admin pages...

    m_dwLogicalRoot = pPageZero[OFFSET_LOGICAL_ROOT];
    m_dwTotalPages = pPageZero[OFFSET_TOTAL_PAGES];
    m_dwNextFreePage = pPageZero[OFFSET_FREE_LIST_ROOT];

    if (m_dwPageSize != pPageZero[OFFSET_PAGE_SIZE])
        dwRes = ERROR_BAD_FORMAT;
    else if (pPageZero[OFFSET_IMPL_VERSION] != const_CurrentVersion)
        dwRes = ERROR_BAD_FORMAT;
    else
        dwRes = NO_ERROR;

    _BtrMemFree(pPageZero);

    return dwRes;
}


//***************************************************************************
//
//  CPageSource::Setup
//
//  Sets up the 0th page (Admin page)
//
//***************************************************************************
// ok
DWORD CPageSource::Setup()
{
    DWORD dwRes;

    // First two pages, admin & free list root

    LPDWORD pPageZero = (LPDWORD) _BtrMemAlloc(m_dwPageSize);

    if (pPageZero == 0)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    memset(pPageZero, 0, m_dwPageSize);

    // Map the page

    pPageZero[OFFSET_PAGE_TYPE] = PAGE_TYPE_ADMIN;
    pPageZero[OFFSET_PAGE_ID] = 0;
    pPageZero[OFFSET_NEXT_PAGE] = 0;

    pPageZero[OFFSET_LOGICAL_ROOT] = 0;
    pPageZero[OFFSET_FREE_LIST_ROOT] = 0;
    pPageZero[OFFSET_TOTAL_PAGES] = 1;
    pPageZero[OFFSET_PAGE_SIZE] = m_dwPageSize;
    pPageZero[OFFSET_IMPL_VERSION]   = const_CurrentVersion;

    // Write it out

    dwRes = PutPage(pPageZero, PAGE_TYPE_ADMIN);
    if (dwRes)
        goto Exit;

    m_dwTotalPages = 1;

Exit:
    _BtrMemFree(pPageZero);

    return dwRes;
}


//***************************************************************************
//
//  CPageSource::Dump
//
//  Debug helper
//
//***************************************************************************
// ok
void CPageSource::Dump(FILE *f)
{
    SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);
    LPDWORD pPage = (LPDWORD) new BYTE[m_dwPageSize];
    DWORD dwPage = 0;
    DWORD dwTotalKeys = 0;

    fprintf(f, "---BEGIN PAGE SOURCE DUMP---\n");
    fprintf(f, "In memory part:\n");
    fprintf(f, "  m_dwPageSize = %d (0x%X)\n", m_dwPageSize, m_dwPageSize);
    fprintf(f, "  m_hFile = 0x%p\n", m_hFile);
    fprintf(f, "  m_dwNextFreePage = %d\n", m_dwNextFreePage);
    fprintf(f, "  m_dwTotalPages = %d\n", m_dwTotalPages);
    fprintf(f, "  m_dwLogicalRoot = %d\n", m_dwLogicalRoot);
    fprintf(f, "---\n");

    DWORD dwTotalFree = 0;
    DWORD dwOffs = 0;

    while (1)
    {
        DWORD dwRead = 0;
        BOOL bRes = ReadFile(m_hFile, pPage, m_dwPageSize, &dwRead, 0);
        if (dwRead != m_dwPageSize)
            break;

        fprintf(f, "Dump of page %d:\n", dwPage++);
        fprintf(f, "  Page type = 0x%X", pPage[OFFSET_PAGE_TYPE]);

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_IMPOSSIBLE)
            fprintf(f, "   PAGE_TYPE_IMPOSSIBLE\n");

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_DELETED)
        {
            fprintf(f, "   PAGE_TYPE_DELETED\n");
            fprintf(f, "     <page num check = %d>\n", pPage[1]);
            fprintf(f, "     <next free page = %d>\n", pPage[2]);
            dwTotalFree++;
        }

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_ACTIVE)
        {
            fprintf(f, "   PAGE_TYPE_ACTIVE\n");
            fprintf(f, "     <page num check = %d>\n", pPage[1]);

            SIdxKeyTable *pKT = 0;
            DWORD dwKeys = 0;
            DWORD dwRes = SIdxKeyTable::Create(pPage, &pKT);
            if (dwRes == 0)
            {
                pKT->Dump(f, &dwKeys);
                pKT->Release();
                dwTotalKeys += dwKeys;
            }
            else
            {
                fprintf(f,  "<INVALID Page Decode>\n");
            }
        }

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_ADMIN)
        {
            fprintf(f, "   PAGE_TYPE_ADMIN\n");
            fprintf(f, "     Page Num           = %d\n", pPage[1]);
            fprintf(f, "     Next Page          = %d\n", pPage[2]);
            fprintf(f, "     Logical Root       = %d\n", pPage[3]);
            fprintf(f, "     Free List Root     = %d\n", pPage[4]);
            fprintf(f, "     Total Pages        = %d\n", pPage[5]);
            fprintf(f, "     Page Size          = %d (0x%X)\n", pPage[6], pPage[6]);
            fprintf(f, "     Impl Version       = 0x%X\n", pPage[7]);
        }
    }

    delete [] pPage;

    fprintf(f, "Total free pages detected by scan = %d\n", dwTotalFree);
    fprintf(f, "Total active keys = %d\n", dwTotalKeys);
    fprintf(f, "---END PAGE DUMP---\n");
}

//***************************************************************************
//
//  CPageSource::GetPage
//
//  Reads an existing page; does not support seeking beyond end-of-file
//
//***************************************************************************
//  ok
DWORD CPageSource::GetPage(
    DWORD dwPage,
    LPVOID *pPage
    )
{
    DWORD dwRes;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

    // Allocate some memory

    LPVOID pMem = _BtrMemAlloc(m_dwPageSize);
    if (!pMem)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Where is this page hiding?

    DWORD dwOffs = dwPage * m_dwPageSize;
    DWORD dwRead = 0;

#ifdef A51_STAGE_BELOW_INDEX

    long lRes = m_pFile->Read(dwOffs, pMem, m_dwPageSize, &dwRead);
    if (lRes != ERROR_SUCCESS)
    {
        _BtrMemFree(pMem);
        return lRes;
    }

#else

    dwRes = SetFilePointer(m_hFile, dwOffs, 0, FILE_BEGIN);
    if (dwRes != dwOffs)
    {
        _BtrMemFree(pMem);
        return GetLastError();
    }

    // Too late; the page cannot escape us

    BOOL bRes = ReadFile(m_hFile, pMem, m_dwPageSize, &dwRead, 0);


    if (!bRes || dwRead != m_dwPageSize)
    {
        _BtrMemFree(pMem);
        return GetLastError();
    }

#endif

    // Maybe this is a bogus page trying to pretend it is real
    // Check the signature

    *pPage = pMem;
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::PutPage
//
//  Always rewrites; the file extent was grown when the page was allocated
//  with NewPage, so the page already exists and the write should not fail
//
//***************************************************************************
//  ok
DWORD CPageSource::PutPage(
    LPVOID pPage,
    DWORD dwType
    )
{
    // Force the page to confess its identity

    DWORD *pdwHeader = LPDWORD(pPage);
    DWORD dwPageId = pdwHeader[OFFSET_PAGE_ID];
    pdwHeader[OFFSET_PAGE_TYPE] = dwType;

    // Where is it on the disk, we ask ourselves

    DWORD dwOffset = m_dwPageSize * dwPageId;
    DWORD dwWritten = 0;

#ifdef A51_STAGE_BELOW_INDEX

    long lRes = m_pFile->Write(dwOffset, pPage, m_dwPageSize, &dwWritten);
    if(lRes != ERROR_SUCCESS)
        return lRes;
#else

    DWORD dwRes = SetFilePointer(m_hFile, dwOffset, 0, FILE_BEGIN);
    if (dwRes != dwOffset)
        return GetLastError();

    // Commit the page to the disk

    BOOL bRes = WriteFile(m_hFile, pPage, m_dwPageSize, &dwWritten, 0);

    if (bRes == FALSE)
        return GetLastError();
#endif

    // We're happy.  But wait!  Have we flushed this thing lately?
    // It would be a shame if the file buffers were much more enlightened
    // about the future than the disk itself.
    // ===================================================================

    DWORD dwNow = GetCurrentTime();
    if (dwNow - m_dwLastFlushTime > MAX_FLUSH_INTERVAL)
    {
        Flush();
        m_dwLastFlushTime = dwNow;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::NewPage
//
//  Allocates a new page, preferring the free list
//
//***************************************************************************
//  ok
DWORD CPageSource::NewPage(LPVOID *pRetPage)
{
    DWORD dwRes;

    if (pRetPage == 0)
        return ERROR_INVALID_PARAMETER;
    *pRetPage = 0;

    // Try to reuse a page from the "free list".  Fast, fun, efficient.
    // ================================================================

    if (m_dwNextFreePage)
    {
        LPDWORD pPage = 0;
        DWORD dwPage = m_dwNextFreePage;
        dwRes = GetPage(m_dwNextFreePage, (LPVOID *) &pPage);
        if (dwRes)
            return dwRes;
        m_dwNextFreePage = pPage[OFFSET_NEXT_PAGE];
        dwRes = WriteAdminPage();  // Update free list
        if (dwRes)
            return dwRes;
        memset(pPage, 0, m_dwPageSize);
        pPage[OFFSET_PAGE_ID] = dwPage;
        *pRetPage = pPage;
        return NO_ERROR;
    }

    // Well, I guess there weren't any free pages left.  Oh, well.  Make a new one.
    // Move to the end of the file
    // ============================================================================

    DWORD dwCurrentExtent = m_dwTotalPages * m_dwPageSize;
    DWORD dwNewExtent = dwCurrentExtent + m_dwPageSize;

    dwRes = SetFilePointer(m_hFile, dwNewExtent, 0, FILE_BEGIN);
    if (dwRes != dwNewExtent)
    {
        // Must be out of disk space.  We're unhappy.
        return GetLastError();
    }

    // Ahh... How are little file has grown.  Now manufacture some
    // nonsensical memory with nothing in it and assign the page number & signatures.
    // ==============================================================================

    LPDWORD pNewPage = (LPDWORD) _BtrMemAlloc(m_dwPageSize);
    if (pNewPage == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memset(pNewPage, 0, m_dwPageSize);
    pNewPage[OFFSET_PAGE_ID] = m_dwTotalPages++;
    *pRetPage = pNewPage;

    return WriteAdminPage();
}

//***************************************************************************
//
//  CPageSource::FreePage
//
//  Called to delete or free a page.  If the last page is the one
//  being freed, then the file is truncated.
//
//***************************************************************************
//  ok
DWORD CPageSource::FreePage(
    LPVOID pPage
    )
{
    BOOL bRes;
    DWORD dwRes;

    LPDWORD pCast = LPDWORD(pPage);
    DWORD dwPageId = pCast[OFFSET_PAGE_ID];

    if (dwPageId == 0 || m_dwLogicalRoot == dwPageId)
    {
        DebugBreak();
        // Oops. Tried to delete the admin page or active root
        return ERROR_INVALID_PARAMETER;
    }

    // See if page is the last one.  If so, simply truncate the
    // file and don't add to the free list.
    // ========================================================
#ifdef DONT_DO_THIS_ANY_MORE
    if (dwPageId == m_dwTotalPages - 1)
    {
        m_dwTotalPages--;
        DWORD dwTarget = dwPageId * m_dwPageSize;
        dwRes = SetFilePointer(m_hFile, dwTarget, 0, FILE_BEGIN);
        if (dwRes != dwTarget)
            return GetLastError();
        bRes = SetEndOfFile(m_hFile);
        if (!bRes)
            return GetLastError();
        return WriteAdminPage();
    }
#endif

    // Otherwise, it goes onto the good ol' free list.
    // ===============================================

    pCast[OFFSET_NEXT_PAGE] = m_dwNextFreePage;
    m_dwNextFreePage = dwPageId;

    dwRes = PutPage(pPage, PAGE_TYPE_DELETED);
    if (dwRes)
        return dwRes;

    dwRes = WriteAdminPage();

    return dwRes;
}

//***************************************************************************
//
//  CPageSource::FreePage
//
//***************************************************************************
//
DWORD CPageSource::FreePage(
    DWORD dwId
    )
{
    LPDWORD pFakePage = (LPDWORD) _BtrMemAlloc(m_dwPageSize);
    if (pFakePage == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    pFakePage[OFFSET_PAGE_TYPE] = PAGE_TYPE_ACTIVE;
    pFakePage[OFFSET_PAGE_ID] = dwId;

    DWORD dwRes = FreePage(pFakePage);
    _BtrMemFree(pFakePage);
    return dwRes;
}

//***************************************************************************
//
//  SIdxKeyTable::GetRequiredPageMemory
//
//  Returns the amount of memory required to store this object in a
//  linear page
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::GetRequiredPageMemory()
{
    DWORD dwTotal = m_pStrPool->GetRequiredPageMemory();

    // Size of the key lookup table & its sizing DWORD, and
    // add in the child page & user data

    dwTotal += sizeof(DWORD) + sizeof(WORD) * m_dwNumKeys;
    dwTotal += sizeof(DWORD) + sizeof(DWORD) * m_dwNumKeys;     // User data
    dwTotal += sizeof(DWORD) + sizeof(DWORD) * (m_dwNumKeys+1); // Child pages

    // Add in the key encoding table

    dwTotal += sizeof(WORD) + sizeof(WORD) * m_dwKeyCodesUsed;

    // Add in per page overhead
    //
    // Signature, Page Id, Next Page, Parent Page
    dwTotal += sizeof(DWORD) * 4;

    // (NOTE A): Add some safety margin...
    dwTotal += sizeof(DWORD) * 2;

    return dwTotal;
}

//***************************************************************************
//
//  SIdxKeyTable::StealKeyFromSibling
//
//  Transfers a key from the sibling via the parent in a sort of rotation:
//
//          10
//     1  2    12  13 14
//
//  Where <this> is node (1,2) and sibling is (12,13).  A single rotation
//  moves 10 into (1,2) and grabs 12 from the sibling to replace it,
//
//           12
//    1 2 10     13 14
//
//  We repeat this until minimum load of <this> is above const_MinimumLoad.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::StealKeyFromSibling(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pSibling
    )
{
    DWORD dwData, dwChild;
    WORD wID;
    LPSTR pszKey = 0;

    DWORD dwSiblingId = pSibling->GetPageId();
    DWORD dwThisId = GetPageId();


    for (WORD i = 0; i < WORD(pParent->GetNumKeys()); i++)
    {
        DWORD dwChildA = pParent->GetChildPage(i);
        DWORD dwChildB = pParent->GetChildPage(i+1);

        if (dwChildA == dwThisId && dwChildB == dwSiblingId)
        {
            pParent->GetKeyAt(i, &pszKey);
            dwData = pParent->GetUserData(i);

            FindKey(pszKey, &wID);
            AddKey(pszKey, wID, dwData);

            pParent->RemoveKey(i);
            _BtrMemFree(pszKey);

            pSibling->GetKeyAt(0, &pszKey);
            dwData = pSibling->GetUserData(0);
            dwChild = pSibling->GetChildPage(0);
            pSibling->RemoveKey(0);

            SetChildPage(wID+1, dwChild);

            pParent->AddKey(pszKey, i, dwData);
            pParent->SetChildPage(i, dwThisId);
            pParent->SetChildPage(i+1, dwSiblingId);
            _BtrMemFree(pszKey);
            break;
        }
        else if (dwChildA == dwSiblingId && dwChildB == dwThisId)
        {
            pParent->GetKeyAt(i, &pszKey);
            dwData = pParent->GetUserData(i);

            FindKey(pszKey, &wID);
            AddKey(pszKey, wID, dwData);

            pParent->RemoveKey(i);
            _BtrMemFree(pszKey);

            WORD wSibId = (WORD) pSibling->GetNumKeys() - 1;
            pSibling->GetKeyAt(wSibId, &pszKey);
            dwData = pSibling->GetUserData(wSibId);
            dwChild = pSibling->GetChildPage(wSibId+1);
            pSibling->RemoveKey(wSibId);

            SetChildPage(wID, dwChild);

            pParent->AddKey(pszKey, i, dwData);
            pParent->SetChildPage(i, dwSiblingId);
            pParent->SetChildPage(i+1, dwThisId);
            _BtrMemFree(pszKey);
            break;
        }
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::Collapse
//
//  Collapses the contents of a node and its sibling into just one
//  node and adjusts the parent.
//
//  Precondition:  The two siblings can be successfully collapsed
//  into a single node, accomodate a key migrated from the parent
//  and still safely fit into a single node.  Page sizes are not
//  checked here.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Collapse(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pDoomedSibling
    )
{
    WORD wId;
    DWORD dwRes;
    LPSTR pszKey = 0;
    DWORD dwData;
    DWORD dwChild;
    BOOL bExtra;

    DWORD dwSiblingId = pDoomedSibling->GetPageId();
    DWORD dwThisId = GetPageId();

    // Locate the node in the parent which points to the two
    // siblings.  Since we don't know which sibling this is,
    // we have to take into account the two possibilites.
    // Is <this> the right side or the left?
    //
    //              10  20  30  40
    //             |   |   |   |  |
    //             x  Sib This x  x
    //
    //        vs.
    //              10  20  30 40
    //             |   |   |  |  |
    //            x  This Sib x  x
    //
    //  We then migrate the key down into the current node
    //  and remove it from the parent.  We steal the first
    //
    // ======================================================

    for (WORD i = 0; i < WORD(pParent->GetNumKeys()); i++)
    {
        DWORD dwChildA = pParent->GetChildPage(i);
        DWORD dwChildB = pParent->GetChildPage(i+1);

        if (dwChildA == dwSiblingId && dwChildB == dwThisId)
        {
            pParent->GetKeyAt(i, &pszKey);
            dwData = pParent->GetUserData(i);
            pParent->RemoveKey(i);
            pParent->SetChildPage(i, dwThisId);
            dwChild = pDoomedSibling->GetLastChildPage();
            AddKey(pszKey, 0, dwData);
            SetChildPage(0, dwChild);
            _BtrMemFree(pszKey);
            bExtra = FALSE;
            break;
        }
        else if (dwChildA == dwThisId && dwChildB == dwSiblingId)
        {
            pParent->GetKeyAt(i, &pszKey);
            dwData = pParent->GetUserData(i);
            pParent->RemoveKey(i);
            pParent->SetChildPage(i, dwThisId);
            FindKey(pszKey, &wId);
            AddKey(pszKey, wId, dwData);
            _BtrMemFree(pszKey);
            bExtra = TRUE;
            break;
        }
    }

    // Move all info from sibling into the current node.
    // ==================================================

    DWORD dwNumSibKeys = pDoomedSibling->GetNumKeys();

    for (WORD i = 0; i < WORD(dwNumSibKeys); i++)
    {
        LPSTR pKeyStr = 0;
        dwRes = pDoomedSibling->GetKeyAt(i, &pKeyStr);
        if (dwRes)
            return dwRes;

        DWORD dwUserData = pDoomedSibling->GetUserData(i);

        dwRes = FindKey(pKeyStr, &wId);
        if (dwRes != ERROR_NOT_FOUND)
        {
            _BtrMemFree(pKeyStr);
            return ERROR_BAD_FORMAT;
        }

        dwRes = AddKey(pKeyStr, wId, dwUserData);

        dwChild = pDoomedSibling->GetChildPage(i);
        SetChildPage(wId, dwChild);
        _BtrMemFree(pKeyStr);
    }

    if (bExtra)
        SetChildPage(WORD(GetNumKeys()), pDoomedSibling->GetLastChildPage());

    pDoomedSibling->ZapPage();

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::GetRightSiblingOf
//  SIdxKeyTable::GetRightSiblingOf
//
//  Searches the child page pointers and returns the sibling of the
//  specified page.  A return value of zero indicates there was not
//  sibling of the specified value in the direction requested.
//
//***************************************************************************
//
DWORD SIdxKeyTable::GetRightSiblingOf(
    DWORD dwId
    )
{
    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (m_pdwChildPageMap[i] == dwId)
            return m_pdwChildPageMap[i+1];
    }

    return 0;
}

DWORD SIdxKeyTable::GetLeftSiblingOf(
    DWORD dwId
    )
{
    for (DWORD i = 1; i < m_dwNumKeys+1; i++)
    {
        if (m_pdwChildPageMap[i] == dwId)
            return m_pdwChildPageMap[i-1];
    }

    return 0;

}


//***************************************************************************
//
//  SIdxKeyTable::Redist
//
//  Used when inserting and performing a node split.
//  Precondition:
//  (a) The current node is oversized
//  (b) <pParent> is ready to receive the new median key
//  (c) <pNewSibling> is completely empty and refers to the lesser node (left)
//  (d) All pages have assigned numbers
//
//  We move the nodes from <this> into the <pNewSibling> until both
//  are approximately half full.  The median key is moved into the parent.
//  May fail if <pNewSibling> cannot allocate memory for the new stuff.
//
//  If any errors occur, the entire sequence should be considered as failed
//  and the pages invalid.
//
//***************************************************************************
//
DWORD SIdxKeyTable::Redist(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pNewSibling
    )
{
    DWORD dwRes;
    WORD wID;

    if (pParent == 0 || pNewSibling == 0)
        return ERROR_INVALID_PARAMETER;

    if (m_dwNumKeys < 3)
    {
        return ERROR_INVALID_DATA;
    }

    // Find median key info and put it into parent.

    DWORD dwToTransfer = m_dwNumKeys / 2;

    while (dwToTransfer--)
    {
        // Get 0th key

        LPSTR pStr = 0;
        dwRes = GetKeyAt(0, &pStr);
        if (dwRes)
            return dwRes;

        DWORD dwUserData = GetUserData(0);

        // Move stuff into younger sibling

        dwRes = pNewSibling->FindKey(pStr, &wID);
        if (dwRes != ERROR_NOT_FOUND)
        {
            _BtrMemFree(pStr);
            return dwRes;
        }

        dwRes = pNewSibling->AddKey(pStr, wID, dwUserData);
        _BtrMemFree(pStr);

        if (dwRes)
            return dwRes;

        DWORD dwChildPage = GetChildPage(0);
        pNewSibling->SetChildPage(wID, dwChildPage);
        RemoveKey(0);
    }

    pNewSibling->SetChildPage(WORD(pNewSibling->GetNumKeys()), GetChildPage(0));

    // Next key is the median key, which migrates to the parent.

    LPSTR pStr = 0;
    dwRes = GetKeyAt(0, &pStr);
    if (dwRes)
        return dwRes;
    DWORD dwUserData = GetUserData(0);

    dwRes = pParent->FindKey(pStr, &wID);
    if (dwRes != ERROR_NOT_FOUND)
    {
        _BtrMemFree(pStr);
        return dwRes;
    }

    dwRes = pParent->AddKey(pStr, wID, dwUserData);
    _BtrMemFree(pStr);

    if (dwRes)
        return dwRes;

    RemoveKey(0);

    // Patch in the various page pointers

    pParent->SetChildPage(wID, pNewSibling->GetPageId());
    pParent->SetChildPage(wID+1, GetPageId());

    // Everything else is already okay

    return NO_ERROR;
}


//***************************************************************************
//
//  SIdxKeyTable::SIdxKeyTable
//
//***************************************************************************
//  ok
SIdxKeyTable::SIdxKeyTable()
{
    m_dwRefCount = 0;
    m_dwPageId = 0;
    m_dwParentPageId = 0;

    m_dwNumKeys = 0;                // Num keys
    m_pwKeyLookup = 0;              // Offset of key into key-lookup-table
    m_dwKeyLookupTotalSize = 0;     // Elements in array
    m_pwKeyCodes = 0;               // Key encoding table
    m_dwKeyCodesTotalSize = 0;      // Total elements in array
    m_dwKeyCodesUsed = 0;           // Elements used
    m_pStrPool = 0;                 // The pool associated with this key table

    m_pdwUserData = 0;              // Stores user DWORDs for each key
    m_pdwChildPageMap = 0;          // Stores the child page map (num keys + 1)
}

//***************************************************************************
//
//***************************************************************************
//
DWORD SIdxKeyTable::Clone(
    OUT SIdxKeyTable **pRetCopy
    )
{
    SIdxKeyTable *pCopy = new SIdxKeyTable;
    if (!pCopy)
        return ERROR_NOT_ENOUGH_MEMORY;

    pCopy->m_dwRefCount = 1;
    pCopy->m_dwPageId = m_dwPageId;
    pCopy->m_dwParentPageId = m_dwParentPageId;
    pCopy->m_dwNumKeys = m_dwNumKeys;

    pCopy->m_pwKeyLookup = (WORD *)_BtrMemAlloc(sizeof(WORD) * m_dwKeyLookupTotalSize);
    if (pCopy->m_pwKeyLookup == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pwKeyLookup, m_pwKeyLookup, sizeof(WORD) * m_dwKeyLookupTotalSize);
    pCopy->m_dwKeyLookupTotalSize = m_dwKeyLookupTotalSize;

    pCopy->m_pdwUserData = (DWORD *)_BtrMemAlloc(sizeof(DWORD) * m_dwKeyLookupTotalSize);
    if (pCopy->m_pdwUserData == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pdwUserData, m_pdwUserData, sizeof(DWORD) * m_dwKeyLookupTotalSize);

    pCopy->m_pdwChildPageMap = (DWORD *) _BtrMemAlloc(sizeof(DWORD) * (m_dwKeyLookupTotalSize+1));
    if (pCopy->m_pdwChildPageMap == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pdwChildPageMap, m_pdwChildPageMap, sizeof(DWORD) * (m_dwKeyLookupTotalSize+1));

    pCopy->m_dwKeyCodesTotalSize = m_dwKeyCodesTotalSize;
    pCopy->m_pwKeyCodes = (WORD *) _BtrMemAlloc(sizeof(WORD) * m_dwKeyCodesTotalSize);
    if (pCopy->m_pwKeyCodes == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pwKeyCodes, m_pwKeyCodes, sizeof(WORD)* m_dwKeyCodesTotalSize);
    pCopy->m_dwKeyCodesUsed = m_dwKeyCodesUsed;

    m_pStrPool->Clone(&pCopy->m_pStrPool);

    *pRetCopy = pCopy;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::~SIdxKeyTable
//
//***************************************************************************
//
SIdxKeyTable::~SIdxKeyTable()
{
    if (m_pwKeyCodes)
        _BtrMemFree(m_pwKeyCodes);
    if (m_pwKeyLookup)
        _BtrMemFree(m_pwKeyLookup);
    if (m_pdwUserData)
        _BtrMemFree(m_pdwUserData);
    if (m_pdwChildPageMap)
        _BtrMemFree(m_pdwChildPageMap);
    if (m_pStrPool)
        delete m_pStrPool;
}

//***************************************************************************
//
//  SIdxKeyTable::GetKeyAt
//
//  Precondition: <wID> is correct
//  The only real case of failure is that the return string cannot be allocated.
//
//  Return values:
//      NO_ERROR
//      ERROR_NOT_ENOUGH_MEMORY
//      ERROR_INVALID_PARAMETER
//
//***************************************************************************
//  tested
DWORD SIdxKeyTable::GetKeyAt(
    WORD wID,
    LPSTR *pszKey
    )
{
    if (wID >= m_dwNumKeys || pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    WORD wStartOffs = m_pwKeyLookup[wID];
    WORD wNumTokens = m_pwKeyCodes[wStartOffs];

    LPSTR Strings[MAX_TOKENS_PER_KEY];
    DWORD dwTotalLengths = 0;

    for (DWORD i = 0; i < DWORD(wNumTokens); i++)
    {
        Strings[i] = m_pStrPool->GetStrById(m_pwKeyCodes[wStartOffs+1+i]);
        dwTotalLengths += strlen(Strings[i]);
    }

    LPSTR pszFinalStr = (LPSTR) _BtrMemAlloc(dwTotalLengths + 1 + wNumTokens);
    if (!pszFinalStr)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pszFinalStr = 0;

    for (DWORD i = 0; i < DWORD(wNumTokens); i++)
    {
        if (i > 0)
            strcat(pszFinalStr, "\\");
        strcat(pszFinalStr, Strings[i]);
    }

    *pszKey = pszFinalStr;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::FindStr
//
//  Finds a string in the pool, if present and returns the assigned
//  offset.  Uses a binary search.
//
//  Return codes:
//      NO_ERROR            The string was found
//      ERROR_NOT_FOND
//
//***************************************************************************
// tested
DWORD SIdxStringPool::FindStr(
    IN  LPSTR pszSearchKey,
    OUT WORD *pwStringNumber,
    OUT WORD *pwPoolOffset
    )
{
    if (m_dwNumStrings == 0)
    {
        *pwStringNumber = 0;
        return ERROR_NOT_FOUND;
    }

    // Binary search current node for key match.
    // =========================================

    int nPosition = 0;
    int l = 0, u = int(m_dwNumStrings) - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        // m is the current key to consider 0...n-1

        LPSTR pszCandidateKeyStr = m_pStringPool+m_pwOffsets[m];
        int nRes = strcmp(pszSearchKey, pszCandidateKeyStr);

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Populate the key unit.
            // ================================================
            if (pwStringNumber)
                *pwStringNumber = WORD(m);
            if (pwPoolOffset)
                *pwPoolOffset = m_pwOffsets[m];
            return NO_ERROR;
        }
    }

    // Not found, if here.  We record where the key should have been
    // and tell the user the unhappy news.
    // ==============================================================

    *pwStringNumber = WORD(short(nPosition));  // The key would have been 'here'
    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
//
DWORD SIdxStringPool::Clone(
    SIdxStringPool **pRetCopy
    )
{
    SIdxStringPool *pCopy = new SIdxStringPool;
    if (pCopy == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    pCopy->m_dwNumStrings = m_dwNumStrings;
    pCopy->m_pwOffsets = (WORD *) _BtrMemAlloc(sizeof(WORD)*m_dwOffsetsSize);
    if (pCopy->m_pwOffsets == 0)
        return ERROR_NOT_ENOUGH_MEMORY;
    memcpy(pCopy->m_pwOffsets, m_pwOffsets, sizeof(WORD)*m_dwOffsetsSize);

    pCopy->m_dwOffsetsSize = m_dwOffsetsSize;

    pCopy->m_pStringPool = (LPSTR) _BtrMemAlloc(m_dwPoolTotalSize);
    if (pCopy->m_pStringPool == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pStringPool, m_pStringPool, m_dwPoolTotalSize);
    pCopy->m_dwPoolTotalSize = m_dwPoolTotalSize;

    pCopy->m_dwPoolUsed = m_dwPoolUsed;

    *pRetCopy = pCopy;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::DeleteStr
//
//  Removes a string from the pool and pool index.
//  Precondition:  <wStringNum> is known to be valid by virtue of a prior
//  call to <FindStr>.
//
//  Return values:
//  NO_ERROR            <Cannot fail if precondition is met>.
//
//***************************************************************************
//
DWORD SIdxStringPool::DeleteStr(
    WORD wStringNum,
    int *pnAdjuster
    )
{
    if (pnAdjuster)
        *pnAdjuster = 0;

    // Find the address of the string to be removed.
    // =============================================

    DWORD dwTargetOffs = m_pwOffsets[wStringNum];
    LPSTR pszDoomed = m_pStringPool+dwTargetOffs;
    DWORD dwDoomedStrLen = strlen(pszDoomed) + 1;

    // Copy all subsequent strings over the top and shorten the heap.
    // Special case if this already the last string
    // ==============================================================
    DWORD dwStrBytesToMove = DWORD(m_pStringPool+m_dwPoolUsed - pszDoomed - dwDoomedStrLen);

    if (dwStrBytesToMove)
        memmove(pszDoomed, pszDoomed+dwDoomedStrLen, dwStrBytesToMove);

    m_dwPoolUsed -= dwDoomedStrLen;

    // Remove this entry from the array.
    // =================================

    DWORD dwArrayElsToMove = m_dwNumStrings - wStringNum - 1;
    if (dwArrayElsToMove)
    {
        memmove(m_pwOffsets+wStringNum, m_pwOffsets+wStringNum+1, dwArrayElsToMove * sizeof(WORD));
        if (pnAdjuster)
            *pnAdjuster = -1;
    }
    m_dwNumStrings--;

    // For all remaining elements, adjust offsets that were affected.
    // ==============================================================
    for (DWORD dwTrace = 0; dwTrace < m_dwNumStrings; dwTrace++)
    {
        if (m_pwOffsets[dwTrace] > dwTargetOffs)
            m_pwOffsets[dwTrace] -= WORD(dwDoomedStrLen);
    }

    // Adjust sizes.
    // =============
    return NO_ERROR;
}


//***************************************************************************
//
//  SIdxStringPool::AddStr
//
//  Adds a string to the pool. Assumes it is known prior to the call that
//  the string isn't present.
//
//  Parameters:
//    pszString           The string to add
//    pwAssignedOffset    Returns the offset code assigned to the string
//  Return values:
//    NO_ERROR
//    ERROR_NOT_ENOUGH_MEMORY
//
//***************************************************************************
// ok
DWORD SIdxStringPool::AddStr(
    LPSTR pszString,
    WORD  wInsertPos,
    int *pnAdjuster
    )
{
    if (pnAdjuster)
        *pnAdjuster = 0;

    // Precondition: String doesn't exist in the table

    // Determine if the pool is too small for another string.
    // If so, extend it.
    // ======================================================

    DWORD dwRequired = strlen(pszString)+1;
    DWORD dwPoolFree = m_dwPoolTotalSize - m_dwPoolUsed;

    if (m_dwPoolUsed + dwRequired - 1 > MAX_WORD_VALUE)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (dwRequired > dwPoolFree)
    {
        // Try to grow the pool
        // ====================
        LPVOID pTemp = _BtrMemReAlloc(m_pStringPool, m_dwPoolTotalSize * 2);
        if (!pTemp) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        m_dwPoolTotalSize *= 2;
        m_pStringPool = (LPSTR) pTemp;
    }

    // If array too small, reallocate to larger one
    // ============================================

    if (m_dwNumStrings == m_dwOffsetsSize)
    {
        // Realloc; double current size
        LPVOID pTemp = _BtrMemReAlloc(m_pwOffsets, m_dwOffsetsSize * sizeof(WORD) * 2);
        if (!pTemp)
            return ERROR_NOT_ENOUGH_MEMORY;
        m_dwOffsetsSize *= 2;
        m_pwOffsets = PWORD(pTemp);
    }

    // If here, no problem. We have enough space for everything.
    // =========================================================

    LPSTR pszInsertAddr = m_pStringPool+m_dwPoolUsed;
    DWORD dwInsertOffs = m_dwPoolUsed;
    strcpy(pszInsertAddr, pszString);
    m_dwPoolUsed += dwRequired;

    // If here, there is enough room.
    // ==============================

    DWORD dwToBeMoved = m_dwNumStrings - wInsertPos;

    if (dwToBeMoved)
    {
        memmove(&m_pwOffsets[wInsertPos+1], &m_pwOffsets[wInsertPos], sizeof(WORD)*dwToBeMoved);
        if (pnAdjuster)
            *pnAdjuster = 1;
    }

    m_pwOffsets[wInsertPos] = WORD(dwInsertOffs);
    m_dwNumStrings++;

    return NO_ERROR;
}


//***************************************************************************
//
//  ParseIntoTokens
//
//  Parses a slash separated string into separate tokens in preparation
//  for encoding into the string pool.  Call FreeStringArray on the output
//  when no longer needed.
//
//  No more than MAX_TOKEN_PER_KEY are supported.  This means that
//  if backslashes are used, no more than MAX_TOKEN_PER_KEY units can
//  be parsed out.
//
//  Returns:
//    ERROR_INVALID_PARAMETER
//    ERROR_NOT_ENOUGH_MEMORY
//    NO_ERROR
//
//***************************************************************************
//  ok
DWORD ParseIntoTokens(
    IN  LPSTR pszSource,
    OUT DWORD *pdwTokenCount,
    OUT LPSTR **pszTokens
    )
{
    LPSTR Strings[MAX_TOKENS_PER_KEY];
    DWORD dwParseCount = 0, i = 0;
    DWORD dwSourceLen = strlen(pszSource);
    LPSTR *pszRetStr = 0;
    DWORD dwRet;

    if (pszSource == 0 || *pszSource == 0)
        return ERROR_INVALID_PARAMETER;

    LPSTR pszTempBuf = (LPSTR) _BtrMemAlloc(dwSourceLen+1);
    if (!pszTempBuf)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPSTR pszTracer = pszTempBuf;

    for (;;)
    {
        *pszTracer = *pszSource;
        if (*pszTracer == '\\' || *pszTracer == 0)
        {
            *pszTracer = 0;   // Replace with null terminator

            LPSTR pszTemp2 = (LPSTR) _BtrMemAlloc(strlen(pszTempBuf)+1);
            if (pszTemp2 == 0)
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            if (dwParseCount == MAX_TOKENS_PER_KEY)
            {
                _BtrMemFree(pszTemp2);
                dwRet = ERROR_INVALID_DATA;
                goto Error;
            }

            strcpy(pszTemp2, pszTempBuf);
            Strings[dwParseCount++] = pszTemp2;
            pszTracer = pszTempBuf;
            pszTracer--;
        }

        if (*pszSource == 0)
            break;

        pszTracer++;
        pszSource++;
    }

    // If here, we at least parsed one string.
    // =======================================
    pszRetStr = (LPSTR *) _BtrMemAlloc(sizeof(LPSTR) * dwParseCount);
    if (pszRetStr == 0)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    memcpy(pszRetStr, Strings, sizeof(LPSTR) * dwParseCount);
    *pdwTokenCount = dwParseCount;
    *pszTokens = pszRetStr;

    _BtrMemFree(pszTempBuf);

    return NO_ERROR;

Error:
    for (i = 0; i < dwParseCount; i++)
        _BtrMemFree(Strings[i]);
    *pdwTokenCount = 0;

    _BtrMemFree(pszTempBuf);

    return dwRet;
}


//***************************************************************************
//
//  FreeTokenArray
//
//  Cleans up the array returned by ParseIntoTokens.
//
//***************************************************************************
//  ok
void FreeTokenArray(
    DWORD dwCount,
    LPSTR *pszStrings
    )
{
    for (DWORD i = 0; i < dwCount; i++)
        _BtrMemFree(pszStrings[i]);
    _BtrMemFree(pszStrings);
}


//***************************************************************************
//
//  SIdxKeyTable::ZapPage
//
//  Empties the page completely of all keys, codes, strings
//
//***************************************************************************
//  ok
void SIdxKeyTable::ZapPage()
{
    m_pStrPool->Empty();
    m_dwKeyCodesUsed = 0;
    m_dwNumKeys = 0;
}

//***************************************************************************
//
//  SIdxKeyTable::MapFromPage
//
//  CAUTION!!!
//  The placement of DWORDs and WORDs is arranged to avoid 64-bit
//  alignment faults.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::MapFromPage(LPVOID pSrc)
{
    if (pSrc == 0)
        return ERROR_INVALID_PARAMETER;

    // Header
    //
    // DWORD[0]  Signature
    // DWORD[1]  Page number
    // DWORD[2]  Next Page (always zero)
    // ==================================\

    LPDWORD pDWCast = (LPDWORD) pSrc;

    if (*pDWCast++ != CPageSource::PAGE_TYPE_ACTIVE)
    {
        return ERROR_BAD_FORMAT;
    }
    m_dwPageId = *pDWCast++;
    pDWCast++;  // Skip the 'next page' field

    // Key lookup table info
    //
    // DWORD[0]    Parent Page
    // DWORD[1]    Num Keys = n
    // DWORD[n]    User Data
    // DWORD[n+1]  Child Page Map
    // WORD[n]     Key encoding offsets array
    // ======================================

    m_dwParentPageId = *pDWCast++;
    m_dwNumKeys = *pDWCast++;

    // Decide the allocation sizes and build the arrays
    // ================================================

    if (m_dwNumKeys <= const_DefaultArray)
        m_dwKeyLookupTotalSize = const_DefaultArray;
    else
        m_dwKeyLookupTotalSize = m_dwNumKeys;

    m_pdwUserData = (DWORD*) _BtrMemAlloc(m_dwKeyLookupTotalSize * sizeof(DWORD));
    m_pdwChildPageMap = (DWORD*) _BtrMemAlloc((m_dwKeyLookupTotalSize+1) * sizeof(DWORD));
    m_pwKeyLookup = (WORD*) _BtrMemAlloc(m_dwKeyLookupTotalSize * sizeof(WORD));

    if (m_pdwUserData == 0 || m_pdwChildPageMap == 0 || m_pwKeyLookup == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Copy the page info into the arrays
    // ==================================

    memcpy(m_pdwUserData, pDWCast, sizeof(DWORD) * m_dwNumKeys);
    pDWCast += m_dwNumKeys;
    memcpy(m_pdwChildPageMap, pDWCast, sizeof(DWORD) * (m_dwNumKeys+1));
    pDWCast += m_dwNumKeys + 1;
    memcpy(m_pwKeyLookup, pDWCast, sizeof(WORD) * m_dwNumKeys);
    LPWORD pWCast = LPWORD(pDWCast);
    pWCast += m_dwNumKeys;

    // Key encoding table info
    //
    // WORD[0]  Num key codes = n
    // WORD[n]  Key codes
    // ===========================

    m_dwKeyCodesUsed = (DWORD) *pWCast++;

    if (m_dwKeyCodesUsed <= const_DefaultKeyCodeArray)
        m_dwKeyCodesTotalSize = const_DefaultKeyCodeArray;
    else
        m_dwKeyCodesTotalSize = m_dwKeyCodesUsed;

    m_pwKeyCodes = (WORD*) _BtrMemAlloc(m_dwKeyCodesTotalSize * sizeof(WORD));
    if (!m_pwKeyCodes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(m_pwKeyCodes, pWCast, sizeof(WORD) * m_dwKeyCodesUsed);
    pWCast += m_dwKeyCodesUsed;

    // String pool
    //
    // WORD[0] Num strings = n
    // WORD[n] Offsets
    //
    // WORD[0] String pool size = n
    // BYTE[n] String pool
    // =============================

    m_pStrPool = new SIdxStringPool;
    if (!m_pStrPool)
        return ERROR_NOT_ENOUGH_MEMORY;

    m_pStrPool->m_dwNumStrings = (DWORD) *pWCast++;
    if (m_pStrPool->m_dwNumStrings <= const_DefaultArray)
        m_pStrPool->m_dwOffsetsSize = const_DefaultArray;
    else
        m_pStrPool->m_dwOffsetsSize = m_pStrPool->m_dwNumStrings;

    m_pStrPool->m_pwOffsets = (WORD *) _BtrMemAlloc(sizeof(WORD)* m_pStrPool->m_dwOffsetsSize);
    if (m_pStrPool->m_pwOffsets == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(m_pStrPool->m_pwOffsets, pWCast, sizeof(WORD)*m_pStrPool->m_dwNumStrings);
    pWCast += m_pStrPool->m_dwNumStrings;

    // String pool setup
    // =================

    m_pStrPool->m_dwPoolUsed = *pWCast++;
    LPSTR pszCast = LPSTR(pWCast);

    if (m_pStrPool->m_dwPoolUsed <= SIdxStringPool::const_DefaultPoolSize)
        m_pStrPool->m_dwPoolTotalSize = SIdxStringPool::const_DefaultPoolSize;
    else
        m_pStrPool->m_dwPoolTotalSize = m_pStrPool->m_dwPoolUsed;

    m_pStrPool->m_pStringPool = (LPSTR) _BtrMemAlloc(m_pStrPool->m_dwPoolTotalSize);
    if (m_pStrPool->m_pStringPool == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(m_pStrPool->m_pStringPool, pszCast, m_pStrPool->m_dwPoolUsed);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::MapToPage
//
//  Copies the info to a linear page.  Precondition: the page must
//  be large enough by validating using a prior test to GetRequiredPageMemory.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::MapToPage(LPVOID pDest)
{
    if (pDest == 0)
        return ERROR_INVALID_PARAMETER;

    // Header
    //
    // DWORD[0]  Signature
    // DWORD[1]  Page number
    // DWORD[2]  Next Page (always zero)
    // ==================================\

    LPDWORD pDWCast = (LPDWORD) pDest;
    *pDWCast++ = CPageSource::PAGE_TYPE_ACTIVE;
    *pDWCast++ = m_dwPageId;
    *pDWCast++ = 0;  // Unused 'next page' field

    // Key lookup table info
    //
    // DWORD[0]    Parent Page
    // DWORD[1]    Num Keys = n
    // DWORD[n]    User Data
    // DWORD[n+1]  Child Page Map
    // WORD[n]     Key encoding offsets array
    // ======================================

    *pDWCast++ = m_dwParentPageId;
    *pDWCast++ = m_dwNumKeys;

    // Decide the allocation sizes and build the arrays
    // ================================================

    memcpy(pDWCast, m_pdwUserData, sizeof(DWORD) * m_dwNumKeys);
    pDWCast += m_dwNumKeys;
    memcpy(pDWCast, m_pdwChildPageMap, sizeof(DWORD) * (m_dwNumKeys+1));
    pDWCast += m_dwNumKeys + 1;
    memcpy(pDWCast, m_pwKeyLookup, sizeof(WORD) * m_dwNumKeys);
    LPWORD pWCast = LPWORD(pDWCast);
    pWCast += m_dwNumKeys;

    // Key encoding table info
    //
    // WORD[0]  Num key codes = n
    // WORD[n]  Key codes
    // ===========================

    *pWCast++ = WORD(m_dwKeyCodesUsed);
    memcpy(pWCast, m_pwKeyCodes, sizeof(WORD) * m_dwKeyCodesUsed);
    pWCast += m_dwKeyCodesUsed;

    // String pool
    //
    // WORD[0] Num strings = n
    // WORD[n] Offsets
    //
    // WORD[0] String pool size = n
    // BYTE[n] String pool
    // =============================

    *pWCast++ = WORD(m_pStrPool->m_dwNumStrings);
    memcpy(pWCast, m_pStrPool->m_pwOffsets, sizeof(WORD)*m_pStrPool->m_dwNumStrings);
    pWCast += m_pStrPool->m_dwNumStrings;

    *pWCast++ = WORD(m_pStrPool->m_dwPoolUsed);
    LPSTR pszCast = LPSTR(pWCast);
    memcpy(pszCast, m_pStrPool->m_pStringPool, m_pStrPool->m_dwPoolUsed);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::Create
//
//  Does a default create
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Create(
    DWORD dwPageId,
    OUT SIdxKeyTable **pNewInst
    )
{
    SIdxKeyTable *p = new SIdxKeyTable;
    if (!p)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Set up default string pool, arrays, etc.
    // ========================================

    p->m_dwPageId = dwPageId;
    p->m_dwNumKeys = 0;
    p->m_pwKeyLookup = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_dwKeyLookupTotalSize = const_DefaultArray;
    p->m_pwKeyCodes = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_dwKeyCodesTotalSize = const_DefaultArray;
    p->m_dwKeyCodesUsed = 0;

    p->m_pdwUserData = (DWORD*) _BtrMemAlloc(const_DefaultArray * sizeof(DWORD));
    p->m_pdwChildPageMap = (DWORD*) _BtrMemAlloc((const_DefaultArray+1) * sizeof(DWORD));

    // Set up string pool.
    // ===================
    p->m_pStrPool = new SIdxStringPool;

    p->m_pStrPool->m_pwOffsets = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_pStrPool->m_dwOffsetsSize = const_DefaultArray;

    p->m_pStrPool->m_pStringPool = (LPSTR) _BtrMemAlloc(SIdxStringPool::const_DefaultPoolSize);
    p->m_pStrPool->m_dwPoolTotalSize = SIdxStringPool::const_DefaultPoolSize;

    // Check all pointers.  If any are null, error out.
    // ================================================

    if (
       p->m_pwKeyLookup == NULL ||
       p->m_pwKeyCodes == NULL  ||
       p->m_pdwUserData == NULL ||
       p->m_pdwChildPageMap == NULL ||
       p->m_pStrPool == NULL ||
       p->m_pStrPool->m_pwOffsets == NULL ||
       p->m_pStrPool->m_pStringPool == NULL
       )
    {
        delete p;
        *pNewInst = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Return good object to caller.
    // =============================

    p->AddRef();
    *pNewInst = p;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::~SIdxStringPool
//
//***************************************************************************
//  ok
SIdxStringPool::~SIdxStringPool()
{
    if (m_pwOffsets)
        _BtrMemFree(m_pwOffsets);
    m_pwOffsets = 0;
    if (m_pStringPool)
        _BtrMemFree(m_pStringPool);           // Pointer to string pool
    m_pStringPool = 0;
}

//***************************************************************************
//
//  SIdxKeyTable::Create
//
//  Does a default create
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Create(
    IN  LPVOID pPage,
    OUT SIdxKeyTable **pNewInst
    )
{
    SIdxKeyTable *p = new SIdxKeyTable;
    if (!p)
        return ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwRes = p->MapFromPage(pPage);
    if (dwRes)
    {
        *pNewInst = 0;
        return dwRes;
    }
    p->AddRef();
    *pNewInst = p;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::AddRef
//
//***************************************************************************
// ok
DWORD SIdxKeyTable::AddRef()
{
    InterlockedIncrement((LONG *) &m_dwRefCount);
    return m_dwRefCount;
}

//***************************************************************************
//
//  SIdxKeyTable::Release
//
//***************************************************************************
// ok
DWORD SIdxKeyTable::Release()
{
    DWORD dwNewCount = InterlockedDecrement((LONG *) &m_dwRefCount);
    if (0 != dwNewCount)
        return dwNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SIdxKeyTable::Cleanup
//
//  Does a consistency check of the key encoding table and cleans up the
//  string pool if any strings aren't being referenced.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Cleanup()
{
    // See if all string pool codes are used in key code table.
    // If not, remove the string pool code.
    // =======================================================

    DWORD dwLastId = m_pStrPool->GetLastId();
    BOOL *pCheck = (BOOL*) _BtrMemAlloc(sizeof(BOOL) * dwLastId);
    if (!pCheck)
        return ERROR_NOT_ENOUGH_MEMORY;

    while (1)
    {
        if (m_pStrPool->GetNumStrings() == 0 || m_dwKeyCodesUsed == 0 || m_dwNumKeys == 0)
        {
            ZapPage();
            break;
        }

        dwLastId = m_pStrPool->GetLastId();
        memset(pCheck, 0, sizeof(BOOL)*dwLastId);   // Mark all codes as 'unused'

        // Move through all key codes.  If we delete a key encoding, there
        // may be a code in the string pool not used by the encoding.
        // What we have to do is set the pCheck array to TRUE for each
        // code encountered.  If any have FALSE when we are done, we have
        // an unused code.

        WORD wCurrentSequence = 0;
        for (DWORD i = 0; i < m_dwKeyCodesUsed; i++)
        {
            if (wCurrentSequence == 0)  // Skip the length WORD
            {
                wCurrentSequence = m_pwKeyCodes[i];
                continue;
            }
            else                        // A string pool code
                pCheck[m_pwKeyCodes[i]] = TRUE;
            wCurrentSequence--;
        }

        // Now the pCheck array contains deep within its psyche
        // the knowledge of whether or not all string pool codes
        // were used TRUE for referenced ones, FALSE for those
        // not referenced. Let's look through it and see!

        DWORD dwUsed = 0, dwUnused = 0;

        for (i = 0; i < dwLastId; i++)
        {
            if (pCheck[i] == FALSE)
            {
                dwUnused++;
                // Yikes! A lonely, unused string code.  Let's be merciful
                // and zap it before it knows the difference.
                // =======================================================
                int nAdj = 0;
                m_pStrPool->DeleteStr(WORD(i), &nAdj);
                AdjustKeyCodes(WORD(i), nAdj);
                break;
            }
            else
                dwUsed++;
        }

        if (dwUnused == 0)
            break;
    }

    _BtrMemFree(pCheck);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::AdjustKeyCodes
//
//***************************************************************************
//  ok
void SIdxKeyTable::AdjustKeyCodes(
    WORD wID,
    int nAdjustment
    )
{
    // Adjust all key codes starting with wID by the amount of the
    // adjustment, skipping length bytes.
    // =============================================================

    WORD wCurrentSequence = 0;
    for (DWORD i = 0; i < m_dwKeyCodesUsed; i++)
    {
        if (wCurrentSequence == 0)
        {
            wCurrentSequence = m_pwKeyCodes[i];
            continue;
        }
        else
        {
            if (m_pwKeyCodes[i] >= wID)
                m_pwKeyCodes[i] = m_pwKeyCodes[i] + nAdjustment;
        }
        wCurrentSequence--;
    }
}

//***************************************************************************
//
//  SIdxKeyTable::AddKey
//
//  Adds a string to the table at position <wID>.  Assumes FindString
//  was called first to get the correct location.
//
//  Precondition:  <pszStr> is valid, and <wID> is correct.
//
//  Return codes:
//
//  ERROR_OUT_OF_MEMORY
//  NO_ERROR
//  ERROR_INVALID_PARAMETER     // Too many slashes in key
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::AddKey(
    LPSTR pszStr,
    WORD wKeyID,
    DWORD dwUserData
    )
{
    DWORD dwRes, dwRet;
    LPVOID pTemp = 0;
    LPSTR pszTemp = 0;
    DWORD dwLen, i;
    DWORD dwTokenCount = 0;
    WORD *pwTokenIDs = 0;
    DWORD dwNumNewTokens = 0;
    LPSTR *pszStrings = 0;
    DWORD dwToBeMoved;
    DWORD dwStartingOffset;

    // Set up some temp working arrays.
    // ================================
    if (!pszStr)
        return ERROR_INVALID_PARAMETER;
    dwLen = strlen(pszStr);
    if (dwLen == 0)
        return ERROR_INVALID_PARAMETER;

    pszTemp = (LPSTR) _BtrMemAlloc(dwLen+1);
    if (!pszTemp)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Ensure there is enough room.
    // ============================

    if (m_dwKeyLookupTotalSize == m_dwNumKeys)
    {
        // Expand the array.

        DWORD dwNewSize = m_dwKeyLookupTotalSize * 2;
        pTemp = _BtrMemReAlloc(m_pwKeyLookup, dwNewSize * sizeof(WORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_dwKeyLookupTotalSize = dwNewSize;
        m_pwKeyLookup = PWORD(pTemp);

        // Expand user data.

        pTemp = _BtrMemReAlloc(m_pdwUserData, dwNewSize * sizeof(DWORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pdwUserData = (DWORD *) pTemp;

        // Expand child page map.

        pTemp = _BtrMemReAlloc(m_pdwChildPageMap, (dwNewSize + 1) * sizeof(DWORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pdwChildPageMap = (DWORD *) pTemp;
    }

    // Parse the string into backslash separated tokens.
    // =================================================

    dwRes = ParseIntoTokens(pszStr, &dwTokenCount, &pszStrings);
    if (dwRes)
    {
        dwRet = dwRes;
        goto Exit;
    }

    // Allocate an array to hold the IDs of the tokens in the string.
    // ==============================================================

    pwTokenIDs = (WORD *) _BtrMemAlloc(sizeof(WORD) * dwTokenCount);
    if (pwTokenIDs == 0)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Work through the tokens and add them to the pool & key encoding table.
    // =============================================================

    for (i = 0; i < dwTokenCount; i++)
    {
        LPSTR pszTok = pszStrings[i];

        // See if token exists, if not add it.
        // ===================================
        WORD wID = 0;
        dwRes = m_pStrPool->FindStr(pszTok, &wID, 0);

        if (dwRes == NO_ERROR)
        {
            // Found it
            pwTokenIDs[dwNumNewTokens++] = wID;
        }
        else if (dwRes == ERROR_NOT_FOUND)
        {
            int nAdjustment = 0;
            dwRes = m_pStrPool->AddStr(pszTok, wID, &nAdjustment);
            if (dwRes)
            {
                dwRet = dwRes;
                goto Exit;
            }
            // Adjust string IDs because of the addition.
            // All existing ones with the same ID or higher
            // must be adjusted upwards.
            if (nAdjustment)
            {
                AdjustKeyCodes(wID, nAdjustment);
                for (DWORD i2 = 0; i2 < dwNumNewTokens; i2++)
                {
                    if (pwTokenIDs[i2] >= wID)
                        pwTokenIDs[i2] = pwTokenIDs[i2] + nAdjustment;
                }
            }

            // Adjust current tokens to accomodate new
            pwTokenIDs[dwNumNewTokens++] = wID;
        }
        else
        {
            dwRet = dwRes;
            goto Exit;
        }
    }

    // Now we know the encodings.  Add them to the key encoding table.
    // First make sure that there is enough room in the table.
    // ===============================================================

    if (m_dwKeyCodesTotalSize - m_dwKeyCodesUsed < dwNumNewTokens + 1)
    {
        DWORD dwNewSize = m_dwKeyCodesTotalSize * 2 + dwNumNewTokens + 1;
        PWORD pTemp = (PWORD) _BtrMemReAlloc(m_pwKeyCodes, dwNewSize * sizeof(WORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pwKeyCodes = pTemp;
        m_dwKeyCodesTotalSize = dwNewSize;
    }

    dwStartingOffset = m_dwKeyCodesUsed;

    m_pwKeyCodes[m_dwKeyCodesUsed++] = (WORD) dwNumNewTokens;  // First WORD is count of tokens

    for (i = 0; i < dwNumNewTokens; i++)                    // Encoded tokens
        m_pwKeyCodes[m_dwKeyCodesUsed++] = pwTokenIDs[i];

    // Now, add in the new key lookup by inserting it into the array.
    // ==============================================================

    dwToBeMoved = m_dwNumKeys - wKeyID;

    if (dwToBeMoved)
    {
        memmove(&m_pwKeyLookup[wKeyID+1], &m_pwKeyLookup[wKeyID], sizeof(WORD)*dwToBeMoved);
        memmove(&m_pdwUserData[wKeyID+1], &m_pdwUserData[wKeyID], sizeof(DWORD)*dwToBeMoved);
        memmove(&m_pdwChildPageMap[wKeyID+1], &m_pdwChildPageMap[wKeyID], (sizeof(DWORD))*(dwToBeMoved+1));
    }

    m_pwKeyLookup[wKeyID] = (WORD) dwStartingOffset;
    m_pdwUserData[wKeyID] = dwUserData;
    m_dwNumKeys++;

    dwRet = NO_ERROR;

    // Cleanup code.
    // =============

Exit:
    if (pszTemp)
        _BtrMemFree(pszTemp);
    FreeTokenArray(dwTokenCount, pszStrings);
    if (pwTokenIDs)
        _BtrMemFree(pwTokenIDs);

    return dwRet;
}

//***************************************************************************
//
//  SIdxKeyTable::RemoveKey
//
//  Precondition: <wID> is the valid target
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::RemoveKey(
    WORD wID
    )
{
    // Find the key code sequence and remove it.
    // =========================================

    WORD wKeyCodeStart = m_pwKeyLookup[wID];
    DWORD dwToBeMoved = m_dwNumKeys - DWORD(wID) - 1;
    if (dwToBeMoved)
    {
        memmove(&m_pwKeyLookup[wID], &m_pwKeyLookup[wID+1], sizeof(WORD)*dwToBeMoved);
        memmove(&m_pdwUserData[wID], &m_pdwUserData[wID+1], sizeof(DWORD)*dwToBeMoved);
        memmove(&m_pdwChildPageMap[wID], &m_pdwChildPageMap[wID+1], sizeof(DWORD)*(dwToBeMoved+1));
    }
    m_dwNumKeys--;

    // Zap the key encoding table to remove references to this key.
    // ============================================================

    WORD wCount = m_pwKeyCodes[wKeyCodeStart]+1;
    dwToBeMoved = m_dwKeyCodesUsed - (wKeyCodeStart + wCount);
    if (dwToBeMoved)
        memmove(&m_pwKeyCodes[wKeyCodeStart], &m_pwKeyCodes[wKeyCodeStart + wCount], sizeof(WORD)*dwToBeMoved);
    m_dwKeyCodesUsed -= wCount;

    // Adjust all zapped key codes referenced by key lookup table.
    // ===========================================================
    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (m_pwKeyLookup[i] >= wKeyCodeStart)
            m_pwKeyLookup[i] -= wCount;
    }

    // Now check the string pool & key encoding table for
    // unreferenced strings thanks to the above tricks
    // and clean up the mess left behind!!
    // ==================================================

    return Cleanup();
}


//***************************************************************************
//
//  Compares the literal string in <pszSearchKey> against the encoded
//  string at <nID>.  Returns the same value as strcmp().
//
//  This is done by decoding the compressed string, token by token, and
//  comparing each character to that in the search string.
//
//***************************************************************************
//  ok
int SIdxKeyTable::KeyStrCompare(
    LPSTR pszSearchKey,
    WORD wID
    )
{
    LPSTR pszTrace = pszSearchKey;
    WORD dwEncodingOffs = m_pwKeyLookup[wID];
    WORD wNumTokens = m_pwKeyCodes[dwEncodingOffs];
    WORD wStrId = m_pwKeyCodes[++dwEncodingOffs];
    LPSTR pszDecoded = m_pStrPool->GetStrById(wStrId);
    wNumTokens--;
    int nRes;

    while (1)
    {
        int nTraceChar = *pszTrace++;
        int nCodedChar = *pszDecoded++;
        if (nCodedChar == 0 && wNumTokens)
        {
            pszDecoded = m_pStrPool->GetStrById(m_pwKeyCodes[++dwEncodingOffs]);
            wNumTokens--;
            nCodedChar = '\\';
        }
        nRes = nTraceChar - nCodedChar;
        if (nRes || (nTraceChar == 0 && nCodedChar == 0))
            return nRes;
    }

    // Identical strings
    return 0;
}


//***************************************************************************
//
//  SIdxKeyTable::FindKey
//
//  Finds the key in the key table, if present.  If not, returns
//  ERROR_NOT_FOUND and <pID> set to the point where it would be if
//  later inserted.
//
//  Return values:
//      ERROR_NOT_FOUND
//      NO_ERROR
//
//***************************************************************************
// ready for test
DWORD SIdxKeyTable::FindKey(
    LPSTR pszSearchKey,
    WORD *pID
    )
{
    if (pszSearchKey == 0 || *pszSearchKey == 0 || pID == 0)
        return ERROR_INVALID_PARAMETER;

    // Binary search the key table.
    // ============================

    if (m_dwNumKeys == 0)
    {
        *pID = 0;
        return ERROR_NOT_FOUND;
    }

    int nPosition = 0;
    int l = 0, u = int(m_dwNumKeys) - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;
        int nRes;

        // m is the current key to consider 0...n-1

        try
        {
            nRes = KeyStrCompare(pszSearchKey, WORD(m));
        }
        catch(...)
        {
            DebugBreak();
            nRes = KeyStrCompare(pszSearchKey, WORD(m));
        }

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Populate the key unit.
            // ================================================

            *pID = WORD(m);
            return NO_ERROR;
        }
    }


    // Not found, if here.  We record where the key should have been
    // and tell the user the unhappy news.
    // ==============================================================

    *pID = WORD(nPosition);  // The key would have been 'here'
    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
// untested
DWORD SIdxKeyTable::Dump(FILE *f, DWORD *pdwKeys)
{
    fprintf(f, "\t|---Begin Key Table Dump---\n");

    fprintf(f, "\t| m_dwPageId              = %d (0x%X)\n", m_dwPageId, m_dwPageId);
    fprintf(f, "\t| m_dwParentPageId        = %d\n", m_dwParentPageId);
    fprintf(f, "\t| m_dwNumKeys             = %d\n", m_dwNumKeys);
    fprintf(f, "\t| m_pwKeyLookup           = 0x%p\n", m_pwKeyLookup);
    fprintf(f, "\t| m_dwKeyLookupTotalSize  = %d\n", m_dwKeyLookupTotalSize);
    fprintf(f, "\t| m_pwKeyCodes            = 0x%p\n", m_pwKeyCodes);
    fprintf(f, "\t| m_dwKeyCodesTotalSize   = %d\n", m_dwKeyCodesTotalSize);
    fprintf(f, "\t| m_dwKeyCodesUsed        = %d\n", m_dwKeyCodesUsed);
    fprintf(f, "\t| Required Page Memory    = %d\n", GetRequiredPageMemory());

    fprintf(f, "\t| --Key Lookup Table\n");

    if (pdwKeys)
        *pdwKeys = m_dwNumKeys;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        fprintf(f, "\t|  *  Left Child Page ------------------------> %d\n", m_pdwChildPageMap[i]);
        fprintf(f, "\t| KeyID[%d] = offset %d\n", i, m_pwKeyLookup[i]);
        fprintf(f, "\t|   User Data=%d\n", m_pdwUserData[i]);

        WORD wKeyEncodingOffset = m_pwKeyLookup[i];
        WORD wEncodingUnits = m_pwKeyCodes[wKeyEncodingOffset];

        int nPass = 0;
        fprintf(f, "\t  | Key=");

        for (DWORD i2 = 0; i2 < DWORD(wEncodingUnits); i2++)
        {
            WORD wCode = m_pwKeyCodes[wKeyEncodingOffset + 1 + i2];
            if (nPass)
                fprintf(f, "\\");
            fprintf(f,   "%s", m_pStrPool->GetStrById(wCode));
            nPass++;
        }

        fprintf(f, "\n");
        fprintf(f, "\t|  Num encoding units = %d\n", wEncodingUnits);

        for (DWORD i2 = 0; i2 < DWORD(wEncodingUnits); i2++)
        {
            WORD wCode = m_pwKeyCodes[wKeyEncodingOffset + 1 + i2];
            fprintf(f,   "\t  | KeyCode = %d\n", wCode);
        }
    }

    fprintf(f, "\t|   * Rightmost child page -------------------> %d\n", m_pdwChildPageMap[i]);
    fprintf(f, "\t|---\n");

#ifdef EXTENDED_STRING_TABLE_DUMP
    fprintf(f, "\t|---Key Encoding Table\n");

    WORD wCurrentSequence = 0;
    for (i = 0; i < m_dwKeyCodesUsed; i++)
    {
        if (wCurrentSequence == 0)
        {
            wCurrentSequence = m_pwKeyCodes[i];
            fprintf(f, "\t| KeyCode[%d] = %d <count>\n", i, m_pwKeyCodes[i]);
            continue;
        }
        else
            fprintf(f, "\t| KeyCode[%d] = %d <%s>\n", i, m_pwKeyCodes[i],
                m_pStrPool->GetStrById(m_pwKeyCodes[i]));
        wCurrentSequence--;
    }

    fprintf(f, "\t|---End Key Encoding Table---\n");
    m_pStrPool->Dump(f);
#endif
    return 0;
}



//***************************************************************************
//
//  SIdxStringPool::Dump
//
//  Dumps the string pool
//
//***************************************************************************
// tested
DWORD SIdxStringPool::Dump(FILE *f)
{
    try
    {
    fprintf(f, "\t\t|| ---String Pool Dump---\n");
    fprintf(f, "\t\t|| m_dwNumStrings    = %d\n", m_dwNumStrings);
    fprintf(f, "\t\t|| m_pwOffsets       = 0x%p\n", m_pwOffsets);
    fprintf(f, "\t\t|| m_dwOffsetsSize   = %d\n",  m_dwOffsetsSize);
    fprintf(f, "\t\t|| m_pStringPool     = 0x%p\n", m_pStringPool);
    fprintf(f, "\t\t|| m_dwPoolTotalSize = %d\n", m_dwPoolTotalSize);
    fprintf(f, "\t\t|| m_dwPoolUsed      = %d\n", m_dwPoolUsed);

    fprintf(f, "\t\t|| --Contents of offsets array--\n");

    for (DWORD ix = 0; ix < m_dwNumStrings; ix++)
    {
        fprintf(f, "\t\t|| String[%d] = offset %d  Value=<%s>\n",
            ix, m_pwOffsets[ix], m_pStringPool+m_pwOffsets[ix]);
    }

#ifdef EXTENDED_STRING_TABLE_DUMP
    fprintf(f, "\t\t|| --String table--\n");

    for (ix = 0; ix < m_dwPoolTotalSize; ix += 20)
    {
        fprintf(f, "\t\t || %4d ", ix);

        for (int nSubcount = 0; nSubcount < 20; nSubcount++)
        {
            if (nSubcount + ix >= m_dwPoolTotalSize)
                continue;

            char c = m_pStringPool[ix+nSubcount];
            fprintf(f, "%02x ", c);
        }

        for (int nSubcount = 0; nSubcount < 20; nSubcount++)
        {
            if (nSubcount + ix >= m_dwPoolTotalSize)
                continue;

            char c = m_pStringPool[ix+nSubcount];
            if (c < 32)
            {
                c = '.';
            }
            fprintf(f, "%c ", c);
        }

        fprintf(f, "\n");
    }
#endif

    fprintf(f, "\t\t|| ---End of String Pool Dump\n");
    }
    catch(...)
    {
        printf("Exception during dump\n");
    }
    return 0;
}


//***************************************************************************
//
//  CBTree::Init
//
//***************************************************************************
//
DWORD CBTree::Init(
    CPageSource *pSrc
    )
{
    DWORD dwRes;

    if (pSrc == 0)
        return ERROR_INVALID_PARAMETER;

    // Read the logical root page, if any.  If the index is just
    // being created, create the root index page.

    m_pSrc = pSrc;
    m_pRoot = 0;

    DWORD dwRoot = m_pSrc->GetRootPage();
    if (dwRoot == 0)
    {
        LPDWORD pNewPage = 0;

        dwRes = m_pSrc->NewPage((LPVOID *) &pNewPage);
        if (dwRes)
            return dwRes;

        DWORD dwPageNum = pNewPage[CPageSource::OFFSET_PAGE_ID];
        _BtrMemFree(pNewPage);
        dwRes = SIdxKeyTable::Create(dwPageNum, &m_pRoot);
        if (dwRes)
            return dwRes;

        m_pSrc->SetRootPage(dwPageNum);
        dwRes = WriteIdxPage(m_pRoot);
    }
    else
    {
        // Retrieve existing root
        LPVOID pPage = 0;
        dwRes = m_pSrc->GetPage(dwRoot, &pPage);
        if (dwRes)
            return dwRes;

        dwRes = SIdxKeyTable::Create(pPage, &m_pRoot);
        _BtrMemFree(pPage);
        if (dwRes)
            return dwRes;
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::CBTree
//
//***************************************************************************
//
CBTree::CBTree()
{
    m_pSrc = 0;
    m_pRoot = 0;
    m_lGeneration = 0;
    InitializeCriticalSection(&m_cs);

    CBTreeIterator *m_pIterators;
    DWORD m_dwActiveIterators;
    DWORD m_dwIteratorsArraySize;

    m_pIterators = 0;
    m_dwActiveIterators = 0;
    m_dwIteratorsArraySize = 0;
}

//***************************************************************************
//
//  CBTree::~CBTree
//
//***************************************************************************
//
CBTree::~CBTree()
{
    if (m_pSrc || m_pRoot)
    {
        Shutdown(WMIDB_SHUTDOWN_NET_STOP);
    }

    DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  CBTree::Shutdown
//
//***************************************************************************
//
DWORD CBTree::Shutdown(DWORD dwShutDownFlags)
{
    DWORD dwRes;
    
    if (m_pRoot)
    {
        m_pRoot->Release();
        m_pRoot = 0;
    }
    if (m_pSrc)
    {
        dwRes = m_pSrc->Shutdown(dwShutDownFlags);
        m_pSrc = 0;
        return dwRes;
    }

    return ERROR_INVALID_FUNCTION;
}

//***************************************************************************
//
//  CBTree::InsertKey
//
//  Inserts the key+data into the tree.  Most of the work is done
//  in InsertPhase2().
//
//***************************************************************************
//   ok

DWORD CBTree::InsertKey(
    IN LPSTR pszKey,
    DWORD dwValue
    )
{
    WORD wID;
    DWORD dwRes;
    SIdxKeyTable *pIdx = 0;
    LONG  StackPtr = -1;
    DWORD Stack[CBTreeIterator::const_MaxStack];

    if (pszKey == 0 || *pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    dwRes = Search(pszKey, &pIdx, &wID, Stack, StackPtr);
    if (dwRes == 0)
    {
        // Ooops.  Aleady exists.  We can't insert it.
        // ===========================================
        pIdx->Release();
        return ERROR_ALREADY_EXISTS;
    }

    if (dwRes != ERROR_NOT_FOUND)
        return dwRes;

    // If here, we can indeed add it.
    // ==============================

    dwRes = InsertPhase2(pIdx, wID, pszKey, dwValue, Stack, StackPtr);
    pIdx->Release();

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ComputeLoad
//
//***************************************************************************
//
DWORD CBTree::ComputeLoad(
    SIdxKeyTable *pKT
    )
{
    DWORD  dwMem = pKT->GetRequiredPageMemory();
    DWORD  dwLoad = dwMem * 100 / m_pSrc->GetPageSize();
    return dwLoad;
}

//***************************************************************************
//
//  CBTree::Search
//
//  The actual search occurs here.  Descends through the page mechanism.
//
//  Returns:
//  NO_ERROR    <pPage> is assigned, and <pwID> points to the key.
//
//  ERROR_NOT_FOUND <pPage> is assigned to where the insert should occur,
//                  at <pwID> in that page.
//
//  Other errors don't assign the OUT parameters.
//
//  Note: caller must release <pRetIdx> using Release() when it is returned
//  whether with an error code or not.
//
//***************************************************************************
//  ok
DWORD CBTree::Search(
    IN  LPSTR pszKey,
    OUT SIdxKeyTable **pRetIdx,
    OUT WORD *pwID,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    DWORD dwRes, dwChildPage, dwPage;

    if (pszKey == 0 || *pszKey == 0 || pwID == 0 || pRetIdx == 0)
        return ERROR_INVALID_PARAMETER;
    *pRetIdx = 0;

    SIdxKeyTable *pIdx = m_pRoot;
    pIdx->AddRef();
    Stack[++StackPtr] = 0;

    while (1)
    {
        dwRes = pIdx->FindKey(pszKey, pwID);
        if (dwRes == 0)
        {
            // Found it

            *pRetIdx = pIdx;
            return NO_ERROR;
        }

        // Otherwise, we have to try to descend to a child page.
        // =====================================================
        dwPage = pIdx->GetPageId();
        dwChildPage = pIdx->GetChildPage(*pwID);
        if (dwChildPage == 0)
            break;

        pIdx->Release();
        pIdx = 0;
        Stack[++StackPtr] = dwPage;

        dwRes = ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
    }

    *pRetIdx = pIdx;

    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//  CBTree::InsertPhase2
//
//  On entry, assumes that we have identified the page into which
//  the insert must physically occur.   This does the split + migrate
//  logical to keep the tree in balance.
//
//  Algorithm:  Add key to page.  If it does not overflow, we are done.
//  If overflow occurs, allocate a new sibling page which will acquire
//  half the keys from the current page.   This sibling will be treated
//  as lexically smaller in all cases.  The median key is migrated
//  up to the parent with pointers to both the new sibing page and
//  the current page.
//  The parent may also overflow.  If so, the algorithm repeats.
//  If an overflow occurs and there is no parent node (we are at the root)
//  a new root node is allocated and the median key migrated into it.
//
//***************************************************************************
// ok
DWORD CBTree::InsertPhase2(
    SIdxKeyTable *pCurrent,
    WORD wID,
    LPSTR pszKey,
    DWORD dwValue,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    DWORD dwRes;

    // If non-NULL, used for a primary insert.
    // If NULL, skip this, under the assumption the
    // node is already up-to-date and merely requires
    // the up-recursive split & migrate treatment.
    // ==============================================

    if (pszKey)
    {
        dwRes = pCurrent->AddKey(pszKey, wID, dwValue);
        if (dwRes)
            return dwRes;    // Failed
    }

    pCurrent->AddRef();                       // Makes following loop consistent
    SIdxKeyTable *pSibling = 0;
    SIdxKeyTable *pParent = 0;

    // The class B-tree split+migration loop.
    // ======================================

    for (;;)
    {
        // Check the current node where we added the key.
        // If it isn't too big, we're done.
        // ==============================================

        dwRes = pCurrent->GetRequiredPageMemory();
        if (dwRes <= m_pSrc->GetPageSize())
        {
            dwRes = WriteIdxPage(pCurrent);
            break;
        }

        // If here, it ain't gonna fit.  We have to split the page.
        // Allocate a new page (Sibling) and get the parent page, which
        // will receive the median key.
        // ============================================================

        DWORD dwParent = Stack[StackPtr--];
        if (dwParent == 0)
        {
            // Allocate a new page to become the parent.
            LPDWORD pParentPg = 0;
            dwRes = m_pSrc->NewPage((LPVOID *) &pParentPg);
            if (dwRes)
                break;

            DWORD dwNewParent = pParentPg[CPageSource::OFFSET_PAGE_ID];
            _BtrMemFree(pParentPg);

            dwRes = SIdxKeyTable::Create(dwNewParent, &pParent);
            if (dwRes)
                break;
            dwRes = m_pSrc->SetRootPage(dwNewParent);
            if (dwRes)
                break;

            m_pRoot->Release();    // Replace old root
            m_pRoot = pParent;
            m_pRoot->AddRef();
        }
        else
        {
            if (dwParent == m_pRoot->GetPageId())
            {
                pParent = m_pRoot;
                pParent->AddRef();
            }
            else
            {
                dwRes = ReadIdxPage(dwParent, &pParent);
                if (dwRes)
                    break;
            }
        }

        // Allocate a new sibling in any case to hold half the keys
        // ========================================================

        LPDWORD pSibPg = 0;
        dwRes = m_pSrc->NewPage((LPVOID *) &pSibPg);
        if (dwRes)
            break;

        DWORD dwNewSib = pSibPg[CPageSource::OFFSET_PAGE_ID];
        _BtrMemFree(pSibPg);

        dwRes = SIdxKeyTable::Create(dwNewSib, &pSibling);
        if (dwRes)
            break;

        dwRes = pCurrent->Redist(pParent, pSibling);
        if (dwRes)
            break;

        dwRes = WriteIdxPage(pCurrent);
        dwRes |= WriteIdxPage(pSibling);

        pCurrent->Release();
        pCurrent = 0;
        pSibling->Release();
        pSibling = 0;

        if (dwRes)
            break;

        pCurrent = pParent;
        pParent = 0;
    }

    ReleaseIfNotNULL(pParent);
    ReleaseIfNotNULL(pCurrent);
    ReleaseIfNotNULL(pSibling);

    return dwRes;
}


//***************************************************************************
//
//  CBTree::WriteIdxPage
//
//  Writes the object to the physical page it is assigned to.
//  If the page ID is zero, then it is considered invalid.  Further,
//  while is it correct to precheck the page size, this function does
//  validate with regard to sizes, etc.
//
//***************************************************************************
//
DWORD CBTree::WriteIdxPage(
    SIdxKeyTable *pIdx
    )
{
    DWORD dwRes;
    DWORD dwPageSize = m_pSrc->GetPageSize();
    DWORD dwMem = pIdx->GetRequiredPageMemory();
    if (dwMem > dwPageSize)
        return ERROR_INVALID_PARAMETER;

    LPVOID pMem = _BtrMemAlloc(dwPageSize);
    if (pMem == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    dwRes =  pIdx->MapToPage(pMem);
    if (dwRes)
    {
        _BtrMemFree(pMem);
        return dwRes;
    }

    dwRes = m_pSrc->PutPage(pMem, CPageSource::PAGE_TYPE_ACTIVE);
    _BtrMemFree(pMem);

    InterlockedIncrement(&m_lGeneration);

    // Check for a root update.
    // ========================

    if (m_pRoot != pIdx && m_pRoot->GetPageId() == pIdx->GetPageId())
    {
        m_pRoot->Release();
        m_pRoot = pIdx;
        m_pRoot->AddRef();

        if (m_pSrc->GetRootPage() != m_pRoot->GetPageId())
           dwRes = m_pSrc->SetRootPage(m_pRoot->GetPageId());
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ReadIdxPage
//
//***************************************************************************
//
DWORD CBTree::ReadIdxPage(
    DWORD dwPage,
    SIdxKeyTable **pIdx
    )
{
    DWORD dwRes;
    LPVOID pPage = 0;
    SIdxKeyTable *p = 0;
    if (pIdx == 0)
        return ERROR_INVALID_PARAMETER;
    *pIdx = 0;

//    if (dwPage < MAX_PAGE_HISTORY)      // May remove if studies show no caching possible
//        ++History[dwPage];

    dwRes = m_pSrc->GetPage(dwPage, &pPage);
    if (dwRes)
        return dwRes;

    dwRes = SIdxKeyTable::Create(pPage, &p);
    if (dwRes)
    {
        _BtrMemFree(pPage);
        return dwRes;
    }

    _BtrMemFree(pPage);
    if (dwRes)
        return dwRes;

    *pIdx = p;
    return dwRes;
}

//***************************************************************************
//
//  CBTree::FindKey
//
//  Does a simple search of a key, returning the user data, if requested.
//
//  Typical Return values
//      NO_ERROR
//      ERROR_NOT_FOUND
//
//***************************************************************************
//  ok

DWORD CBTree::FindKey(
    IN LPSTR pszKey,
    DWORD *pdwData
    )
{
    WORD wID;
    DWORD dwRes;
    SIdxKeyTable *pIdx = 0;
    LONG  StackPtr = -1;
    DWORD Stack[CBTreeIterator::const_MaxStack];

    if (pszKey == 0 || *pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    // Search high and low, hoping against hope...
    // ===========================================

    dwRes = Search(pszKey, &pIdx, &wID, Stack, StackPtr);
    if (dwRes == 0 && pdwData)
    {
        *pdwData = pIdx->GetUserData(wID);
    }

    // If here, we can indeed add it.
    // ==============================

    ReleaseIfNotNULL(pIdx);
    return dwRes;
}


//***************************************************************************
//
//  CBTree::DeleteKey
//
//***************************************************************************
//
DWORD CBTree::DeleteKey(
    IN LPSTR pszKey
    )
{
    DWORD dwRes;
    LONG  StackPtr = -1;
    DWORD Stack[CBTreeIterator::const_MaxStack];
    SIdxKeyTable *pIdx = 0;
    WORD wId;
    DWORD dwLoad;

    // Find it
    // =======
    dwRes = Search(pszKey, &pIdx, &wId, Stack, StackPtr);
    if (dwRes)
        return dwRes;

    // Delete key from from page
    // ==========================

    if (pIdx->IsLeaf())
    {
        // A leaf node.  Remove the key.
        // =============================
        dwRes = pIdx->RemoveKey(wId);

        // Now, check the load and see if it has dropped below 30%.
        // Of course, if we are at the root node and it is a leaf,
        // we have to pretty much let it go as is...
        // ========================================================
        dwLoad = ComputeLoad(pIdx);
        if (dwLoad > const_MinimumLoad ||
            pIdx->GetPageId() == m_pRoot->GetPageId())
        {
            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
            return dwRes;
        }
    }
    else
    {
        // An internal node, so we have to find the successor.
        // Since this call may alter the shape of the tree quite
        // a bit (the successor may overflow the affected node),
        // we have to relocate the successor.
        // ====================================================
        LPSTR pszSuccessor = 0;
        BOOL bUnderflow = FALSE;
        dwRes = ReplaceBySuccessor(pIdx, wId, &pszSuccessor, &bUnderflow, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        dwRes = InsertPhase2(pIdx, 0, 0, 0, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        pIdx->Release();
        pIdx = 0;
        StackPtr = -1;

        if (bUnderflow == FALSE)
        {
            _BtrMemFree(pszSuccessor);
            return NO_ERROR;
        }

        // If here, the node we extracted the successor from was reduced
        // to poverty and underflowed.  We have to find it again and
        // execute the underflow repair loop.
        // =============================================================

        dwRes = Search(pszSuccessor, &pIdx, &wId, Stack, StackPtr);
        _BtrMemFree(pszSuccessor);
        if (dwRes)
            return dwRes;

        SIdxKeyTable *pSuccessor = 0;
        dwRes = FindSuccessorNode(pIdx, wId, &pSuccessor, 0, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        pIdx->Release();
        pIdx = pSuccessor;
    }

    // UNDERFLOW REPAIR Loop.
    // At this point <pIdx> points to the deepest affected node.
    // We need to start working back up the tree and repairing
    // the damage.  Nodes which have reached zero in size are
    // quite a pain.  But they aren't half as bad as nodes which claim
    // they can recombine with a sibling but really can't.  So,
    // we either do nothing (the node has enough stuff to be useful),
    // collapse with a sibling node or borrow some keys from a sibling
    // to ensure all nodes meet the minimum load requirement.
    // ===============================================================

    SIdxKeyTable *pSibling = 0;
    SIdxKeyTable *pParent = 0;

    for (;;)
    {
        DWORD dwParentId = Stack[StackPtr--];
        DWORD dwThisId = pIdx->GetPageId();

        dwLoad = ComputeLoad(pIdx);
        if (dwLoad > const_MinimumLoad || dwParentId == 0)
        {
            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
            break;
        }

        // If here the node is getting small.  We must collapsed this
        // node with a sibling.

        // collapse this node and a sibling

        dwRes = ReadIdxPage(dwParentId, &pParent);

        // Locate a sibling and see if the sibling and the current node
        // can be collapsed with leftover space.
        // =============================================================

        DWORD dwLeftSibling = pParent->GetLeftSiblingOf(pIdx->GetPageId());
        DWORD dwRightSibling = pParent->GetRightSiblingOf(pIdx->GetPageId());
        DWORD dwSiblingId = 0;

        if (dwLeftSibling)
        {
            dwRes = ReadIdxPage(dwLeftSibling, &pSibling);
            dwSiblingId = pSibling->GetPageId();
        }
        else
        {
            dwRes = ReadIdxPage(dwRightSibling, &pSibling);
            dwSiblingId = pSibling->GetPageId();
        }

        // If here, the node is 'underloaded'.  Now we have to
        // get the parent and the sibling and collapsed them.
        // ===================================================

        SIdxKeyTable *pCopy = 0;
        pIdx->Clone(&pCopy);
        dwRes = pIdx->Collapse(pParent, pSibling);

        // Now we have a different sort of problem, possibly.
        // If the collapsed node is too big, we have to try
        // a different strategy.
        // ===================================================

        if (pIdx->GetRequiredPageMemory() > m_pSrc->GetPageSize())
        {
            pIdx->Release();
            pParent->Release();
            pSibling->Release();
            pIdx = pParent = pSibling = 0;

            // Reread the pages.
            // =================
            pIdx = pCopy;
            dwRes = ReadIdxPage(dwParentId, &pParent);
            dwRes = ReadIdxPage(dwSiblingId, &pSibling);

            // Transfer a key or two from sibling via parent.
            // This doesn't change the tree shape, but the
            // parent may overflow.
            // ==============================================
            do
            {
                dwRes = pIdx->StealKeyFromSibling(pParent, pSibling);
                dwLoad = ComputeLoad(pIdx);
            }   while (dwLoad < const_MinimumLoad);

            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
            dwRes = WriteIdxPage(pSibling);
            pSibling->Release();
            dwRes = InsertPhase2(pParent, 0, 0, 0, Stack, StackPtr);
            pParent->Release();
            break;
        }
        else  // The collapse worked; we can free the sibling page
        {
            pCopy->Release();
            dwRes = m_pSrc->FreePage(pSibling->GetPageId());
            pSibling->Release();
        }

        // If here, the collapse worked.
        // =============================

        dwRes = WriteIdxPage(pIdx);
        if (dwRes)
        {
            pIdx->Release();
            break;
        }

        if (pParent->GetNumKeys() == 0)
        {
            // We have replaced the root. Note
            // that we transfer the ref count of pIdx to m_pRoot.
            DWORD dwOldRootId = m_pRoot->GetPageId();
            m_pRoot->Release();
            m_pRoot = pIdx;

            // Even though we wrote <pIdx> a few lines back,
            // a rewrite is required to update internal stuff
            // because this has become the new root.
            // ==============================================
            m_pSrc->SetRootPage(m_pRoot->GetPageId());
            dwRes = WriteIdxPage(m_pRoot);
            m_pSrc->FreePage(dwOldRootId);
            pParent->Release();
            break;
        }

        pIdx->Release();
        pIdx = pParent;
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ReplaceBySuccessor
//
//  Removes the wId key in the <pIdx> node, and replaces it with the
//  successor.
//
//  Precondition: <pIdx> is an internal (non-leaf) node.
//
//  Side-effects:  <pIdx> may be overflowed and require the InsertPhase2
//  treatment.  The node from which the successor is extracted is
//  written, but may have been reduced to zero keys.
//
//***************************************************************************
//
DWORD CBTree::ReplaceBySuccessor(
    IN SIdxKeyTable *pIdx,
    IN WORD wId,
    OUT LPSTR *pszSuccessorKey,
    OUT BOOL *pbUnderflowDetected,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    SIdxKeyTable *pTemp = 0;
    DWORD dwRes;
    DWORD dwPredecessorChild;

    dwRes = FindSuccessorNode(pIdx, wId, &pTemp, &dwPredecessorChild, Stack, StackPtr);
    if (dwRes || pTemp == 0)
        return dwRes;

    LPSTR pszKey = 0;
    pTemp->GetKeyAt(0, &pszKey);
    DWORD dwUserData = pTemp->GetUserData(0);
    pTemp->RemoveKey(0);
    if (ComputeLoad(pTemp) < const_MinimumLoad)
        *pbUnderflowDetected = TRUE;
    dwRes = WriteIdxPage(pTemp);
    pTemp->Release();

    pIdx->RemoveKey(wId);
    pIdx->AddKey(pszKey, wId, dwUserData);
    pIdx->SetChildPage(wId, dwPredecessorChild);

    *pszSuccessorKey = pszKey;
    StackPtr--;
    return dwRes;
}

//***************************************************************************
//
//  CBTree::FindSuccessorNode
//
//  Read-only. Finds the node containing the successor to the specified key.
//
//***************************************************************************
//
DWORD CBTree::FindSuccessorNode(
    IN SIdxKeyTable *pIdx,
    IN WORD wId,
    OUT SIdxKeyTable **pSuccessor,
    OUT DWORD *pdwPredecessorChild,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    SIdxKeyTable *pTemp = 0;
    DWORD dwRes;
    DWORD dwSuccessorChild, dwPredecessorChild;

    dwPredecessorChild = pIdx->GetChildPage(wId);
    dwSuccessorChild = pIdx->GetChildPage(wId+1);

    Stack[++StackPtr] = pIdx->GetPageId();

    // From this point on, take leftmost children until
    // we reach a leaf node.  The leftmost key in the
    // leftmost node is always the successor, thanks to the
    // astonishing properties of the BTree.  Nice and easy, huh?
    // =========================================================

    while (dwSuccessorChild)
    {
        Stack[++StackPtr] = dwSuccessorChild;
        if (pTemp)
            pTemp->Release();
        dwRes = ReadIdxPage(dwSuccessorChild, &pTemp);
        dwSuccessorChild = pTemp->GetChildPage(0);
    }

    StackPtr--;     // Pop the element we are returning in <*pSuccessor>

    *pSuccessor = pTemp;
    if (pdwPredecessorChild)
        *pdwPredecessorChild = dwPredecessorChild;

    return dwRes;
}



//***************************************************************************
//
//   CBTree::BeginEnum
//
//***************************************************************************
//
DWORD CBTree::BeginEnum(
    LPSTR pszStartKey,
    OUT CBTreeIterator **pIterator
    )
{
    CBTreeIterator *pIt = new CBTreeIterator;
    if (pIt == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    DWORD dwRes = pIt->Init(this, pszStartKey);
    if (dwRes)
    {
        pIt->Release();
        return dwRes;
    }

    *pIterator = pIt;
    return NO_ERROR;
}


//***************************************************************************
//
//   CBTree::Dump
//
//***************************************************************************
//
void CBTree::Dump(FILE *f)
{
    m_pSrc->Dump(f);
}


//***************************************************************************
//
//***************************************************************************
//
DWORD CBTree::InvalidateCache()
{
    m_pRoot->Release();
    DWORD dwRootPage = m_pSrc->GetRootPage();
    DWORD dwRes = ReadIdxPage(dwRootPage, &m_pRoot);
    return dwRes;
}

//***************************************************************************
//
//  CBTreeIterator::Init
//
//***************************************************************************
//
DWORD CBTreeIterator::Init(
    IN CBTree *pTree,
    IN LPSTR pszStartKey
    )
{
    if (pTree == 0)
        return ERROR_INVALID_PARAMETER;
    m_pTree = pTree;

    // Special case of enumerating everything.  Probably not useful
    // for WMI, but great for testing & debugging (I think).
    // ============================================================

    if (pszStartKey == 0)
    {
        Push(0, 0); // Sentinel value in stack

        SIdxKeyTable *pRoot = pTree->m_pRoot;
        pRoot->AddRef();
        Push(pRoot, 0);

        DWORD dwChildPage = Peek()->GetChildPage(0);

        while (dwChildPage)
        {
            SIdxKeyTable *pIdx = 0;
            DWORD dwRes = m_pTree->ReadIdxPage(dwChildPage, &pIdx);
            if (dwRes)
                return dwRes;
            if (StackFull())
            {
                pIdx->Release();
                return ERROR_INSUFFICIENT_BUFFER;
            }
            Push(pIdx, 0);
            dwChildPage = pIdx->GetChildPage(0);
        }
        return NO_ERROR;
    }

    // If here, a matching string was specified.
    // This is the typical case.
    // =========================================

    Push(0, 0); // Sentinel value in stack

    WORD wId;
    DWORD dwRes, dwChildPage;
    SIdxKeyTable *pIdx = pTree->m_pRoot;
    pIdx->AddRef();

    while (1)
    {
        dwRes = pIdx->FindKey(pszStartKey, &wId);
        if (dwRes == 0)
        {
            // Found it
            Push(pIdx, wId);
            return NO_ERROR;
        }

        // Otherwise, we have to try to descend to a child page.
        // =====================================================
        dwChildPage = pIdx->GetChildPage(wId);
        if (dwChildPage == 0)
            break;

        Push(pIdx, wId);
        pIdx = 0;
        dwRes = pTree->ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
    }

    Push(pIdx, wId);

    while (Peek() && PeekId() == WORD(Peek()->GetNumKeys()))
        Pop();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Next
//
//  On entry:
//  <wID> is the key to visit in the current node (top-of-stack).
//  The call sets up the successor before leaving.  If there is no successor,
//  the top of stack is left at NULL and ERROR_NO_MORE_ITEMS is returned.
//
//  Returns ERROR_NO_MORE_ITEMS when the iteration is complete.
//
//***************************************************************************
//
DWORD CBTreeIterator::Next(
    LPSTR *ppszStr,
    DWORD *pdwData
    )
{
    DWORD dwRes;

    if (ppszStr == 0)
        return ERROR_INVALID_PARAMETER;
    *ppszStr = 0;

    if (Peek() == 0)
        return ERROR_NO_MORE_ITEMS;

    // Get the item for the caller.
    // ============================

    dwRes = Peek()->GetKeyAt(PeekId(), ppszStr);
    if (dwRes)
        return dwRes;
    if (pdwData)
        *pdwData = Peek()->GetUserData(PeekId());
    IncStackId();

    // Now find the successor.
    // =======================

    DWORD dwChildPage = Peek()->GetChildPage(PeekId());

    while (dwChildPage)
    {
        SIdxKeyTable *pIdx = 0;
        dwRes = m_pTree->ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
        if (StackFull())
        {
            pIdx->Release();
            return ERROR_INSUFFICIENT_BUFFER;
        }
        Push(pIdx, 0);
        dwChildPage = pIdx->GetChildPage(0);
    }

    // If here, we are at a leaf node.
    // ===============================

    while (Peek() && PeekId() == WORD(Peek()->GetNumKeys()))
        Pop();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Release
//
//***************************************************************************
//
DWORD CBTreeIterator::Release()
{
    delete this;
    return 0;
}

//***************************************************************************
//
//  CBTreeIterator::~CBTreeIterator
//
//***************************************************************************
//
CBTreeIterator::~CBTreeIterator()
{
    // Cleanup any leftover stack
    while (m_lStackPointer > -1)
        Pop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\btr.h ===
//***************************************************************************
//
//  (c) 2000 Microsoft Corp.  All Rights Reserved.
//
//  BTR.H
//
//  Repository B-tree classes
//
//  raymcc  15-Oct-00       First version
//
//***************************************************************************

#ifndef _BTR_H_
#define _BTR_H_

#include "absfile.h"

#define A51_INDEX_FILE_ID 2

LPVOID WINAPI _BtrMemAlloc(
    SIZE_T dwBytes  // number of bytes to allocate
    );

LPVOID WINAPI _BtrMemReAlloc(
    LPVOID pOriginal,
    DWORD dwNewBytes
    );

BOOL WINAPI _BtrMemFree(LPVOID pMem);

#define ReleaseIfNotNULL(p) if(p) p->Release()

class CPageSource
{
    DWORD  m_dwPageSize;
    HANDLE m_hFile;

    DWORD  m_dwTotalPages;
    DWORD  m_dwLogicalRoot;
    DWORD  m_dwNextFreePage;            // 0==none
    DWORD  m_dwLastFlushTime;

#ifdef A51_STAGE_BELOW_INDEX
    CAbstractFile* m_pFile;
#endif

    // Methods
    DWORD Setup();
    DWORD WriteAdminPage();

public:
    CPageSource();
   ~CPageSource();

    enum { const_DefaultPageSize = 0x2000, const_CurrentVersion = 0x101 };

    enum {
        PAGE_TYPE_IMPOSSIBLE = 0x0,       // Not supposed to happen
        PAGE_TYPE_ACTIVE = 0xACCC,        // Page is active with data
        PAGE_TYPE_DELETED = 0xBADD,       // A deleted page on free list
        PAGE_TYPE_ADMIN = 0xADDD,         // Page zero only

        // All pages
        OFFSET_PAGE_TYPE = 0,             // True for all pages
        OFFSET_PAGE_ID = 1,               // True for all pages
        OFFSET_NEXT_PAGE = 2,             // True for all pages (Page continuator)

        // Admin Page (page zero) only
        OFFSET_LOGICAL_ROOT = 3,          // Root of database
        OFFSET_FREE_LIST_ROOT = 4,        // First free list page
        OFFSET_TOTAL_PAGES = 5,           // Total page in database
        OFFSET_PAGE_SIZE = 6,             // Page size check
        OFFSET_IMPL_VERSION = 7,          // Implementation version
        };


    DWORD Init(
        DWORD dwPageSize,        // 8k default
        LPWSTR pszFilename
#ifdef A51_STAGE_BELOW_INDEX
                , CAbstractFileSource* pSource
#endif
        );

    DWORD Shutdown(DWORD dwShutDownFlags);

    DWORD GetPage(DWORD dwId, LPVOID *pPage);
    DWORD PutPage(LPVOID pPage, DWORD dwType);
    DWORD NewPage(LPVOID *pPage);
    DWORD FreePage(LPVOID pPage);
    DWORD FreePage(DWORD dwId);

    DWORD GetPageSize() { return m_dwPageSize; }

    DWORD SetRootPage(DWORD dwID);
    DWORD GetRootPage() { return m_dwLogicalRoot; }
    void  Flush() { FlushFileBuffers(m_hFile); }
    DWORD ReadAdminPage();

    void  Dump(FILE *);
};

struct SIdxStringPool
{
    DWORD  m_dwNumStrings;          // Number of strings in pool
    WORD  *m_pwOffsets;             // Offsets into pool of strings
    DWORD  m_dwOffsetsSize;         // Number of elements in above array

    LPSTR  m_pStringPool;           // Pointer to string pool
    DWORD  m_dwPoolTotalSize;       // Total size, used+unused
    DWORD  m_dwPoolUsed;            // Offset of first free position

public:
    enum { const_DefaultPoolSize = 0x2200 };

    SIdxStringPool() { memset(this, 0, sizeof(SIdxStringPool)); }
   ~SIdxStringPool();

    DWORD  AddStr(LPSTR pszStr, WORD wInsertPos, int *pnAdjuster);
    DWORD  DeleteStr(WORD wAssignedOffset, int *pnAdjuster);

    DWORD  GetLastId() { return m_dwNumStrings; }

    DWORD FindStr(
        IN  LPSTR pszSearchKey,
        OUT WORD *pwStringNumber,
        OUT WORD *pwPoolOffset
        );

    DWORD  GetNumStrings() { return m_dwNumStrings; }
    DWORD  GetRequiredPageMemory()
        {
        return m_dwPoolUsed + (m_dwNumStrings * sizeof(WORD)) +
        sizeof(m_dwNumStrings) + sizeof(m_dwPoolUsed);
        }

    DWORD  Dump(FILE *f);

    LPSTR  GetStrById(WORD id) { return m_pStringPool+m_pwOffsets[id]; }
    void   Empty() { m_dwNumStrings = 0; m_dwPoolUsed = 0; }
    DWORD  Clone(SIdxStringPool **);
};

class SIdxKeyTable
{
    DWORD m_dwRefCount;                // Ref count

    DWORD m_dwPageId;                  // Page number
    DWORD m_dwParentPageId;            // Parent page id  <For DEBUGGING only>
    DWORD m_dwNumKeys;                 // Num keys
    WORD *m_pwKeyLookup;               // Offset of key into key-encoding-table
    DWORD m_dwKeyLookupTotalSize;      // Elements in array
    DWORD *m_pdwUserData;              // User DWORD with each key
    DWORD *m_pdwChildPageMap;          // Child page pointers n=left ptr, n+1=right pointer

    WORD *m_pwKeyCodes;                // Key encoding table
    DWORD m_dwKeyCodesTotalSize;       // Total elements in array
    DWORD m_dwKeyCodesUsed;            // Elements used
    SIdxStringPool *m_pStrPool;        // The pool associated with this key table

    // Methods

    SIdxKeyTable();
   ~SIdxKeyTable();

public:
    enum { const_DefaultArray = 256,
           const_DefaultKeyCodeArray = 512
         };

    static DWORD Create(DWORD dwPageId, SIdxKeyTable **pNew);
    static DWORD Create(LPVOID pPage, SIdxKeyTable **pNew);

    DWORD AddRef();
    DWORD Release();

    DWORD AddKey(LPSTR pszStr, WORD ID, DWORD dwUserData);
    DWORD RemoveKey(WORD wID);
    DWORD FindKey(LPSTR pszStr, WORD *pID);
    DWORD GetUserData(WORD wID) { return m_pdwUserData[wID]; }

    void  SetChildPage(WORD wID, DWORD dwPage) { m_pdwChildPageMap[wID] = dwPage; }
    DWORD GetChildPage(WORD wID) { return m_pdwChildPageMap[wID]; }
    DWORD GetLastChildPage() { return m_pdwChildPageMap[m_dwNumKeys]; }
    DWORD GetLeftSiblingOf(DWORD dwId);
    DWORD GetRightSiblingOf(DWORD dwId);
    DWORD GetKeyAt(WORD wID, LPSTR *pszKey);    // Use _MemFree
    DWORD GetNumKeys() { return m_dwNumKeys; }
    void  SetStringPool(SIdxStringPool *pPool) { m_pStrPool = pPool; }
    void  FreeMem(LPVOID pMem);

    void AdjustKeyCodes(
        WORD wID,
        int nAdjustment
        );

    int KeyStrCompare(
        LPSTR pszSearchKey,
        WORD wID
        );

    DWORD Cleanup();

    DWORD NumKeys() { return m_dwNumKeys; }
    DWORD GetRequiredPageMemory();
    DWORD Dump(FILE *, DWORD *pdwKeys = 0);
    void  ZapPage();
    DWORD GetPageId() { return m_dwPageId; }

    // Sibling/Parent page helpers

    DWORD GetKeyOverhead(WORD wID); // Returns total bytes required by new key

    BOOL IsLeaf() { return m_pdwChildPageMap[0] == 0; }
    DWORD Redist(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pNewSibling
        );

    DWORD Collapse(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pDoomedSibling
        );

    DWORD StealKeyFromSibling(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pSibling
        );

    DWORD MapFromPage(LPVOID pSrc);
    DWORD MapToPage(LPVOID pMem);

    DWORD Clone(OUT SIdxKeyTable **pCopy);
};

class CBTree;


class CBTreeIterator
{
    friend class CBTree;
    enum {
        const_MaxStack = 1024,
        const_PrefetchSize = 64
        };

    CBTree       *m_pTree;
    SIdxKeyTable *m_Stack[const_MaxStack];
    WORD          m_wStack[const_MaxStack];
    LONG          m_lStackPointer;

    LPSTR        *m_pPrefetchKeys[const_PrefetchSize];
    DWORD         m_dwPrefetchData[const_PrefetchSize];
    DWORD         m_dwPrefetchActive;

   ~CBTreeIterator();

    // Stack helpers
    SIdxKeyTable *Peek() { return m_Stack[m_lStackPointer]; }
    WORD PeekId() { return m_wStack[m_lStackPointer]; }
    void IncStackId() { m_wStack[m_lStackPointer]++; }

    void Pop() {  ReleaseIfNotNULL(m_Stack[m_lStackPointer]); m_lStackPointer--; }
    BOOL StackFull() { return m_lStackPointer == const_MaxStack - 1; }
    void Push(SIdxKeyTable *p, WORD wId) { m_Stack[++m_lStackPointer] = p; m_wStack[m_lStackPointer] = wId; }

    DWORD ZapStack();
    DWORD PurgeKey(LPSTR pszDoomedKey);
    DWORD RebuildStack(LPSTR pszStartKey);
    DWORD ExecPrefetch();

    static DWORD ZapAllStacks();
    static DWORD GlobalPurgeKey(LPSTR pszDoomedKey);

public:

    CBTreeIterator() { m_pTree = 0; m_lStackPointer = -1; }

    DWORD Init(CBTree *pRoot, LPSTR pszStartKey = 0);  // If last parm is null, iterate through all
    DWORD Next(LPSTR *ppszStr, DWORD *pdwData = 0);
    void  FreeString(LPSTR pszStr) { _BtrMemFree(pszStr); }
    DWORD Release();
};

class CBTree
{
    enum { const_DefaultArray = 256 };
    enum { const_MinimumLoad = 33 };

    CPageSource *m_pSrc;
    SIdxKeyTable *m_pRoot;
    friend class CBTreeIterator;

    LONG m_lGeneration;
    CRITICAL_SECTION m_cs;

    CBTreeIterator *m_pIterators;
    DWORD m_dwActiveIterators;
    DWORD m_dwIteratorsArraySize;

    // private methods

    DWORD ReplaceBySuccessor(
        IN SIdxKeyTable *pIdx,
        IN WORD wId,
        OUT LPSTR *pszSuccessorKey,
        OUT BOOL *pbUnderflowDetected,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD FindSuccessorNode(
        IN SIdxKeyTable *pIdx,
        IN WORD wId,
        OUT SIdxKeyTable **pSuccessor,
        OUT DWORD *pdwPredecessorChild,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD ReadIdxPage(
        DWORD dwPage,
        SIdxKeyTable **pIdx
        );

    DWORD WriteIdxPage(
        SIdxKeyTable *pIdx
        );

    DWORD ComputeLoad(
        SIdxKeyTable *pKT
        );

    DWORD InsertPhase2(
        SIdxKeyTable *pCurrent,
        WORD wID,
        LPSTR pszKey,
        DWORD dwValue,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD Search(
        IN  LPSTR pszKey,
        OUT SIdxKeyTable **pRetIdx,
        OUT WORD *pwID,
        DWORD Stack[],
        LONG &StackPtr
        );

public:
    CBTree();
   ~CBTree();

    DWORD Init(CPageSource *pSrc);
    DWORD Shutdown(DWORD dwShutDownFlags);

    DWORD InsertKey(
        IN LPSTR pszKey,
        DWORD dwValue
        );

    DWORD FindKey(
        IN LPSTR pszKey,
        DWORD *pdwData
        );

    DWORD DeleteKey(
        IN LPSTR pszKey
        );

    DWORD BeginEnum(
        LPSTR pszStartKey,
        OUT CBTreeIterator **pIterator
        );

    void Dump(FILE *fp);

    DWORD InvalidateCache();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\creposit.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __CREPOSIT__H_
#define __CREPOSIT__H_

#include <windows.h>
#include <wbemidl.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"

extern CLock g_readWriteLock;
extern bool g_bShuttingDown;
// extern CFileCache* g_FileCache;

/* ===================================================================================
 * A51_REP_FS_VERSION
 * 
 * 1 - Original A51 file-based repository
 * 2 - All Objects stored in single file (Whistler Beta 1)
 * 3 - BTree added
 * 4 - System Class optimisation - put all system classes in __SYSTEMCLASS namespace
 * 5 - Change to system classes in __SYSTEMCLASS namespace - need to propagate change
 *		to all namespaces as there may be instances of these classes.
 * ===================================================================================
 */
#define A51_REP_FS_VERSION_BETA1 2
#define A51_REP_FS_VERSION 5

#define A51_CLASSDEF_FILE_PREFIX L"CD_"

#define A51_CLASSRELATION_DIR_PREFIX L"CR_"
#define A51_CHILDCLASS_FILE_PREFIX L"C_"

#define A51_KEYROOTINST_DIR_PREFIX L"KI_"
#define A51_INSTDEF_FILE_PREFIX L"I_"

#define A51_CLASSINST_DIR_PREFIX L"CI_"
#define A51_INSTLINK_FILE_PREFIX L"IL_"

#define A51_INSTREF_DIR_PREFIX L"IR_"
#define A51_REF_FILE_PREFIX L"R_"

#define A51_SCOPE_DIR_PREFIX L"SC_"

#define A51_SYSTEMCLASS_NS L"__SYSTEMCLASS"

class CGlobals;
extern CGlobals g_Glob;

class CNamespaceHandle;
extern CNamespaceHandle * g_pSystemClassNamespace;

/*
DWORD g_dwOldRepositoryVersion = 0;
DWORD g_dwCurrentRepositoryVersion = 0;
DWORD g_ShutDownFlags = 0;
*/

class CForestCache;
class CGlobals 
{
private:
    BOOL m_bInit;
    CRITICAL_SECTION m_cs;

    _IWmiCoreServices* m_pCoreServices;

    CForestCache m_ForestCache;

    CFileCache m_FileCache;
    
    long    m_lRootDirLen;
    WCHAR   m_wszRootDir[MAX_PATH];    // keep this last: be debugger friendly
public:
    CGlobals():m_bInit(FALSE)
    { 
        InitializeCriticalSection(&m_cs); 
    };
    ~CGlobals()
    { 
        DeleteCriticalSection(&m_cs); 
    };
    HRESULT Initialize();
    HRESULT Deinitialize();
    _IWmiCoreServices * GetCoreSvcs();
    CForestCache * GetForestCache();
    CFileCache   * GetFileCache();
    WCHAR * GetRootDir() {return (WCHAR *)m_wszRootDir;}
    long    GetRootDirLen() {return  m_lRootDirLen;};   
    void    SetRootDirLen(long Len) { m_lRootDirLen = Len;};
    BOOL    IsInit(){ return m_bInit; };
};


HRESULT DoAutoDatabaseRestore();


class CNamespaceHandle;
class CRepository : public CUnkBase<IWmiDbController, &IID_IWmiDbController>
{
private:
	CFlexArray m_aSystemClasses;	//Used for part of the upgrade process.

protected:
    HRESULT Initialize();
	HRESULT UpgradeRepositoryFormatPhase1();
	HRESULT UpgradeRepositoryFormatPhase2();
	HRESULT UpgradeRepositoryFormatPhase3();
	HRESULT GetRepositoryDirectory();
	HRESULT InitializeGlobalVariables();
	HRESULT DeleteSystemClassesFromNamespaces();
	HRESULT InitializeRepositoryVersions();
	HRESULT UpgradeSystemClasses();

public:

    HRESULT STDMETHODCALLTYPE Logon(
          WMIDB_LOGON_TEMPLATE *pLogonParms,
          DWORD dwFlags,
          DWORD dwRequestedHandleType,
         IWmiDbSession **ppSession,
         IWmiDbHandle **ppRootNamespace
        );

    HRESULT STDMETHODCALLTYPE GetLogonTemplate(
           LCID  lLocale,
           DWORD dwFlags,
          WMIDB_LOGON_TEMPLATE **ppLogonTemplate
        );

    HRESULT STDMETHODCALLTYPE FreeLogonTemplate(
         WMIDB_LOGON_TEMPLATE **ppTemplate
        );

    HRESULT STDMETHODCALLTYPE Shutdown(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetCallTimeout(
         DWORD dwMaxTimeout
        );

    HRESULT STDMETHODCALLTYPE SetCacheValue(
         DWORD dwMaxBytes
        );

    HRESULT STDMETHODCALLTYPE FlushCache(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE GetStatistics(
          DWORD  dwParameter,
         DWORD *pdwValue
        );

    HRESULT STDMETHODCALLTYPE Backup(
		LPCWSTR wszBackupFile,
		long lFlags
        );
    
    HRESULT STDMETHODCALLTYPE Restore(
		LPCWSTR wszBackupFile,
		long lFlags
        );

    HRESULT STDMETHODCALLTYPE LockRepository();

    HRESULT STDMETHODCALLTYPE UnlockRepository();

	HRESULT STDMETHODCALLTYPE GetRepositoryVersions(DWORD *pdwOldVersion, DWORD *pdwCurrentVersion);
    
public:
    CRepository(CLifeControl* pControl) : TUnkBase(pControl)
    {
        
    }
    ~CRepository()
    {
    }

    HRESULT GetNamespaceHandle(LPCWSTR wszNamespaceName, 
                                CNamespaceHandle** ppHandle);
};


#endif /*__CREPOSIT__H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\creposit.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"
#include "a51conv.h"
#include "A51Exp.h"
#include "A51Imp.h"


CLock g_readWriteLock;
bool g_bShuttingDown = false;
CNamespaceHandle *g_pSystemClassNamespace = NULL;
DWORD g_dwOldRepositoryVersion = 0;
DWORD g_dwCurrentRepositoryVersion = 0;
DWORD g_ShutDownFlags = 0;

//*****************************************************************************

HRESULT CRepository::Initialize()
{
    HRESULT hRes = WBEM_E_FAILED;

	InitializeRepositoryVersions();

    //
    // Make sure that the version that created the repository is the same
    // as the one we are currently running
    //
	hRes = UpgradeRepositoryFormatPhase1();
    
	//
    // Initialize time index
    //
	if (SUCCEEDED(hRes))
	{
		FILETIME ft;
		GetSystemTimeAsFileTime(&ft);

		g_nCurrentTime = ft.dwLowDateTime + ((__int64)ft.dwHighDateTime << 32);
	}

    //
    // Get the repository directory
    //
	if (SUCCEEDED(hRes))
		hRes = GetRepositoryDirectory();

    //
    // initialze all our global resources
    //
	if (SUCCEEDED(hRes))
		hRes = InitializeGlobalVariables();

    hRes = g_Glob.GetFileCache()->Initialize(g_Glob.GetRootDir());

    //
    // Initialize class cache.  It will read the registry itself to find out
    // its size limitations
    //

	if (SUCCEEDED(hRes))
	{
		hRes = g_Glob.Initialize();
		if(hRes != ERROR_SUCCESS)
		{
			hRes = WBEM_E_FAILED;
		}
	}
    
	//if (SUCCEEDED(hRes))
	//{
	//	hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
	//				CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
	//				(void**)&g_pCoreServices);
	//}

	//Run phase 2 of the repository upgrade
	if (SUCCEEDED(hRes))
	{
		hRes = UpgradeRepositoryFormatPhase2();
	}

	//If we need to create the system class namespace then go ahead and do that...
	if (SUCCEEDED(hRes))
	{
		g_pSystemClassNamespace = new CNamespaceHandle(m_pControl, this);
		if (g_pSystemClassNamespace == NULL)
		{
			hRes = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if (SUCCEEDED(hRes))
	{
		g_pSystemClassNamespace->AddRef();
		hRes = g_pSystemClassNamespace->Initialize(A51_SYSTEMCLASS_NS);
	}

	if (SUCCEEDED(hRes))
	{
		hRes = g_pSystemClassNamespace->CreateSystemClasses(m_aSystemClasses);
	}

	//Run phase 3 of the repository upgrade
	if (SUCCEEDED(hRes))
	{
		hRes = UpgradeRepositoryFormatPhase3();
	}

	if (SUCCEEDED(hRes))
		g_bShuttingDown = false;
	else
	{
		g_Glob.GetFileCache()->Uninitialize(0);

		g_Glob.GetForestCache()->Deinitialize();

		if (g_pSystemClassNamespace)
		{
			delete g_pSystemClassNamespace;
			g_pSystemClassNamespace = NULL;
		}
	}

    return hRes;
}

HRESULT CRepository::InitializeRepositoryVersions()
{
	DWORD dwVal = 0;
	CPersistentConfig cfg;
	cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
	if (dwVal == 0)
		dwVal = A51_REP_FS_VERSION;

	g_dwOldRepositoryVersion = dwVal;
	g_dwCurrentRepositoryVersion = A51_REP_FS_VERSION;

	return WBEM_S_NO_ERROR;
}

HRESULT CRepository::UpgradeRepositoryFormatPhase1()
{
	HRESULT hRes = WBEM_E_DATABASE_VER_MISMATCH;
	CPersistentConfig cfg;
	DWORD dwVal = 0;
	if (!cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal)
         || 
        (dwVal == 2))
	{
		ERRORTRACE((LOG_WBEMCORE, "Repository format upgrade from version 2 to version 3 taking place. Performing file-based to object store upgrade\n"));
        hRes = ConvertA51ToRoswell();
        if(hRes != ERROR_SUCCESS)
        {
            ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
                "due to a failure in repository upgrade from file-based repository to object store\n"));

			return WBEM_E_DATABASE_VER_MISMATCH;
        }

		dwVal = 3;
		cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
	}
	else if (dwVal == 0)
	{
        //
        // First time --- write the right version in
        //
		hRes = WBEM_S_NO_ERROR;

		cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, 
                                    A51_REP_FS_VERSION);
	}
	else if (dwVal > 2)
		hRes = WBEM_S_NO_ERROR;

	if (hRes == WBEM_E_DATABASE_VER_MISMATCH)
    {
        //
        // Unsupported version
        //
    
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
            "due to the detection of an unknown repository version.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
		return WBEM_E_DATABASE_VER_MISMATCH;
    }
	return hRes;
}

HRESULT CRepository::UpgradeRepositoryFormatPhase2()
{
	HRESULT hRes = WBEM_E_DATABASE_VER_MISMATCH;
	CPersistentConfig cfg;
	DWORD dwVal = 0;
	if (!cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal)
         || 
        (dwVal == 3))
	{
		ERRORTRACE((LOG_WBEMCORE, "Repository format upgrade from version 3 to version 4 taking place. Deleting all redundant system classes\n"));

		hRes = DeleteSystemClassesFromNamespaces();
        if(FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
                "due to a failure in repository upgrade while deleting all redundant system classes\n"));

			return WBEM_E_DATABASE_VER_MISMATCH;
        }

		dwVal = 4;
		cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
	}
	else if (dwVal > 3)
		hRes = WBEM_S_NO_ERROR;

	if (hRes == WBEM_E_DATABASE_VER_MISMATCH)
    {
        //
        // Unsupported version
        //
    
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
            "due to the detection of an unknown repository version.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
		return WBEM_E_DATABASE_VER_MISMATCH;
    }
	return hRes;
}

HRESULT CRepository::UpgradeRepositoryFormatPhase3()
{
	HRESULT hRes = WBEM_E_DATABASE_VER_MISMATCH;
	CPersistentConfig cfg;
	DWORD dwVal = 0;
	if (!cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal)
         || 
        (dwVal == 4))
	{
		ERRORTRACE((LOG_WBEMCORE, "Repository format upgrade from version 4 to version 5 taking place. Upgrading some system classes\n"));

		hRes = UpgradeSystemClasses();
		if (FAILED(hRes))
		{
            ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
                "due to a failure in repository upgrade while upgrading system classes\n"));

			return WBEM_E_DATABASE_VER_MISMATCH;
		}
		dwVal = 5;
		cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
	}
	else if (dwVal > 4)
		hRes = WBEM_S_NO_ERROR;

	if (hRes == WBEM_E_DATABASE_VER_MISMATCH)
    {
        //
        // Unsupported version
        //
    
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
            "due to the detection of an unknown repository version.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
		return WBEM_E_DATABASE_VER_MISMATCH;
    }
	return hRes;
}

HRESULT CRepository::GetRepositoryDirectory()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszTmp;
	if (wszTmp == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    DWORD dwLen = wszTmp.Length();
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszRepDir;
	if (wszRepDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepDir,wszTmp.Length()) == 0)
		return WBEM_E_FAILED;


    lRes = EnsureDirectory(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // Append standard postfix --- that is our root
    //
    wcscpy(g_Glob.GetRootDir(), wszRepDir);
    wcscat(g_Glob.GetRootDir(), L"\\FS");
    g_Glob.SetRootDirLen(wcslen(g_Glob.GetRootDir()));

    //
    // Ensure the directory is there
    //

    lRes = EnsureDirectory(g_Glob.GetRootDir());
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    SetFileAttributesW(g_Glob.GetRootDir(), FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);

	return WBEM_S_NO_ERROR;
}

HRESULT CRepository::InitializeGlobalVariables()
{
    //g_Glob.GetFileCache() = new CFileCache;
    //if (g_Glob.GetFileCache() == NULL)
    //{
    //    return WBEM_E_OUT_OF_MEMORY;
    //}
    //g_Glob.GetFileCache()->AddRef();
    
    //g_ForestCache = new CForestCache;
    //if (g_ForestCache ==  NULL)
    //{
	//	g_Glob.GetFileCache()->Release();
	//	g_Glob.GetFileCache() = NULL;
    //   return WBEM_E_OUT_OF_MEMORY;
    //}
    //g_ForestCache->AddRef();

	return WBEM_S_NO_ERROR;
}

HRESULT DoAutoDatabaseRestore()
{
	HRESULT hRes = WBEM_S_NO_ERROR;

    //We may need to do a database restore!
    CFileName wszBackupFile;
	if (wszBackupFile == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    int nLen = g_Glob.GetRootDirLen();
    wcsncpy(wszBackupFile, g_Glob.GetRootDir(), nLen - 3);	// exclude "\FS" from path
    wszBackupFile[nLen - 3] = '\0';
    wcscat(wszBackupFile, L"\\repdrvfs.rec");

    DWORD dwAttributes = GetFileAttributesW(wszBackupFile);
    if (dwAttributes != -1)
    {
		DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
						FILE_ATTRIBUTE_DIRECTORY |
						FILE_ATTRIBUTE_OFFLINE |
						FILE_ATTRIBUTE_REPARSE_POINT |
						FILE_ATTRIBUTE_SPARSE_FILE;

		if (!(dwAttributes & dwMask))
        {
            CRepositoryPackager packager;
	        hRes = packager.UnpackageRepository(wszBackupFile);

            //We are going to ignore the error so if there was a problem we will just
            //load all the standard MOFs.
            if (hRes != WBEM_E_OUT_OF_MEMORY)
                hRes = WBEM_S_NO_ERROR;
        }
    }

	return hRes;
}

HRESULT CRepository::DeleteSystemClassesFromNamespaces()
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CSession* pSession = new CSession(m_pControl);
	if (pSession == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CReleaseMe rm1(pSession);
	pSession->AddRef();

    CNamespaceHandle* pHandle = new CNamespaceHandle(m_pControl, this);
	if (pHandle == NULL)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CReleaseMe rm2(pHandle);
	pHandle->AddRef();

    hRes = pHandle->Initialize(L"root");
	if (FAILED(hRes))
		return hRes;

	CWStringArray aSystemClasses;
	CWStringArray aSystemClassesSuperclass;
    _IWmiObject *Objects[256];
    ULONG uSize = 256;

    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
    CReleaseMe rm(pSvcs);	
	hRes = pSvcs->GetSystemObjects(GET_SYSTEM_STD_OBJECTS, &uSize, Objects);
	if (FAILED(hRes))
		return hRes;

    for (int i = 0; i < uSize; i++)
    {
        IWbemClassObject *pObj = NULL;
        if (SUCCEEDED(hRes))
        {
            hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
            if (SUCCEEDED(hRes))
            {
				VARIANT var;
				VariantInit(&var);
                hRes = pObj->Get(L"__CLASS", 0, &var, NULL, NULL);
				if (SUCCEEDED(hRes) && (V_VT(&var) == VT_BSTR))
				{
					//PCA: Retrieve the object from the root namespace so we can re-add it to the
					//     new __systemclass namespace.
					_IWmiObject *pObj = NULL;
					hRes = pHandle->GetObjectByPath(V_BSTR(&var), 0, IID__IWmiObject, (void**)&pObj);
					if (SUCCEEDED(hRes))
					{
						if (m_aSystemClasses.Add(pObj) != CFlexArray::no_error)
							hRes = WBEM_E_FAILED;
					}
					if (SUCCEEDED(hRes) && (aSystemClasses.Add(V_BSTR(&var)) != CWStringArray::no_error))
						hRes = WBEM_E_FAILED;
				}
				else
					hRes = WBEM_E_FAILED;
				VariantClear(&var);
			}
			if (SUCCEEDED(hRes))
			{
				VARIANT var;
				VariantInit(&var);
                hRes = pObj->Get(L"__SUPERCLASS", 0, &var, NULL, NULL);
				if (SUCCEEDED(hRes) && (V_VT(&var) == VT_BSTR))
				{
					if (aSystemClassesSuperclass.Add(V_BSTR(&var)) != CWStringArray::no_error)
						hRes = WBEM_E_FAILED;
				}
				else if (SUCCEEDED(hRes) && (V_VT(&var) == VT_NULL))
				{
					if (aSystemClassesSuperclass.Add(L"") != CWStringArray::no_error)
						hRes = WBEM_E_FAILED;
				}
				else
					hRes = WBEM_E_FAILED;
				VariantClear(&var);
            }
			if (pObj)
                pObj->Release();
        }
        Objects[i]->Release();
    }

	if (FAILED(hRes))
		return hRes;


	hRes = pSession->BeginWriteTransaction(0);
	if (FAILED(hRes))
		return hRes;

	try
	{
		hRes = pHandle->RecursiveDeleteSystemClasses(aSystemClasses, aSystemClassesSuperclass);
	}
	catch (...)
	{
		hRes = WBEM_E_CRITICAL_ERROR;
	}

	if (FAILED(hRes))
		pSession->AbortTransaction(0);
	else
		pSession->CommitTransaction(0);

	return hRes;
}

HRESULT CRepository::UpgradeSystemClasses()
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	bool bNeedToRestoreOldRepository = false;

	wchar_t *wszExportFilename = new wchar_t[g_Glob.GetRootDirLen() + lstrlenW(L"\\upgrade.exp") + 1];
	if (wszExportFilename == NULL)
		hRes = WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> vdm1(wszExportFilename);

	wchar_t *wszImportFilename = new wchar_t[g_Glob.GetRootDirLen() + lstrlenW(L".bak\\upgrade.exp") + 1];
	if (wszImportFilename  == NULL)
		hRes = WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> vdm2(wszImportFilename );

	wchar_t *wszBackupRepositoryDirectory = new wchar_t[g_Glob.GetRootDirLen() + lstrlenW(L".bak") + 1];
	if (wszBackupRepositoryDirectory == NULL)
		hRes = WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> vdm3(wszBackupRepositoryDirectory);

	if (SUCCEEDED(hRes))
	{
		lstrcpyW(wszExportFilename, g_Glob.GetRootDir());
		lstrcatW(wszExportFilename, L"\\upgrade.exp");
		lstrcpyW(wszImportFilename , g_Glob.GetRootDir());
		lstrcatW(wszImportFilename , L".bak\\upgrade.exp");
		lstrcpyW(wszBackupRepositoryDirectory, g_Glob.GetRootDir());
		lstrcatW(wszBackupRepositoryDirectory, L".bak");
	}

	if (SUCCEEDED(hRes))
	{
		A51Export exporter(m_pControl);

		hRes = exporter.Export(wszExportFilename, 0, this);

	}

	if (SUCCEEDED(hRes))
	{
		//Now need to shutdown the repository...
		g_Glob.GetFileCache()->Uninitialize(0);
		
		g_Glob.GetForestCache()->Deinitialize();
		//g_ForestCache = NULL;
		g_pSystemClassNamespace->Release();
		g_pSystemClassNamespace = NULL;

		//Move it sideways for safe keeping...
		MoveFile(g_Glob.GetRootDir() , wszBackupRepositoryDirectory);

		bNeedToRestoreOldRepository = true;

		//Restart the repository...
		hRes = InitializeGlobalVariables();
		if (SUCCEEDED(hRes))
		{
			hRes = EnsureDirectory(g_Glob.GetRootDir() );
			if(hRes != ERROR_SUCCESS)
				hRes = WBEM_E_FAILED;
		}
		if (SUCCEEDED(hRes))
		{
			hRes = g_Glob.GetFileCache()->Initialize(g_Glob.GetRootDir() );
			if(hRes != ERROR_SUCCESS)
			{
				hRes = WBEM_E_FAILED;
			}
		}
		if (SUCCEEDED(hRes))
		{
			hRes = g_Glob.Initialize();
			if(hRes != ERROR_SUCCESS)
			{
				hRes = WBEM_E_FAILED;
			}
		}
		if (SUCCEEDED(hRes))
		{
			g_pSystemClassNamespace = new CNamespaceHandle(m_pControl, this);
			if (g_pSystemClassNamespace == NULL)
			{
				hRes = WBEM_E_OUT_OF_MEMORY;
			}
		}

		if (SUCCEEDED(hRes))
		{
			g_pSystemClassNamespace->AddRef();
			hRes = g_pSystemClassNamespace->Initialize(A51_SYSTEMCLASS_NS);
		}
		if (SUCCEEDED(hRes))
		{
			//Need to re-create the system class namespace
			hRes = g_pSystemClassNamespace->CreateSystemClasses(m_aSystemClasses);
		}
	}

	if (SUCCEEDED(hRes))
	{
		A51Import importer;

		hRes = importer.Import(wszImportFilename, 0, this);
	}

	if (FAILED(hRes) && bNeedToRestoreOldRepository)
	{
		//Shutdown the repository
		g_Glob.GetFileCache()->Uninitialize(0);
		
		g_Glob.Deinitialize();
		
		if (g_pSystemClassNamespace)
			g_pSystemClassNamespace->Release();
		g_pSystemClassNamespace = NULL;

		//Delete the new directory (if it exists)
		A51RemoveDirectory(g_Glob.GetRootDir() );

		//Restore the old one
		MoveFile(wszBackupRepositoryDirectory, g_Glob.GetRootDir() );

	}
	else if (bNeedToRestoreOldRepository)
	{
		A51RemoveDirectory(wszBackupRepositoryDirectory);
	}

	//Delete the export file as we are done with it
	if (wszExportFilename)
		DeleteFile(wszExportFilename);
	
	return hRes;
}

HRESULT STDMETHODCALLTYPE CRepository::Logon(
      WMIDB_LOGON_TEMPLATE *pLogonParms,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
     IWmiDbSession **ppSession,
     IWmiDbHandle **ppRootNamespace
    )
{
    //If not initialized, initialize all subsystems...
    if (!g_Glob.IsInit())
    {
        HRESULT hres = Initialize();
        if (FAILED(hres))
            return hres;
    }
    
    CSession* pSession = new CSession(m_pControl);
	if (pSession == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pSession->AddRef();
	CReleaseMe rm1(pSession);

    CNamespaceHandle* pHandle = new CNamespaceHandle(m_pControl, this);
	if (pHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pHandle->AddRef();
	CTemplateReleaseMe<CNamespaceHandle> rm2(pHandle);

    HRESULT hres = pHandle->Initialize(L"");
	if(FAILED(hres))
		return hres;

    *ppRootNamespace = pHandle;
	pHandle->AddRef();
    *ppSession = pSession;
	pSession->AddRef();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetLogonTemplate(
       LCID  lLocale,
       DWORD dwFlags,
      WMIDB_LOGON_TEMPLATE **ppLogonTemplate
    )
{
    WMIDB_LOGON_TEMPLATE* lt = (WMIDB_LOGON_TEMPLATE*)CoTaskMemAlloc(sizeof(WMIDB_LOGON_TEMPLATE));

    lt->dwArraySize = 0;
    lt->pParm = NULL;

    *ppLogonTemplate = lt;
    return S_OK;
}
    

HRESULT STDMETHODCALLTYPE CRepository::FreeLogonTemplate(
     WMIDB_LOGON_TEMPLATE **ppTemplate
    )
{
    CoTaskMemFree(*ppTemplate);
    *ppTemplate = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::Shutdown(
     DWORD dwFlags
    )
{
    g_bShuttingDown = true;     
    g_readWriteLock.WriteLock();
     
    g_ShutDownFlags = dwFlags;
        
    if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwFlags)
    {
		if (g_pSystemClassNamespace)
			g_pSystemClassNamespace->Release();
		g_pSystemClassNamespace = NULL;

        g_Glob.GetForestCache()->Deinitialize();
    } 

	g_Glob.GetFileCache()->Uninitialize(dwFlags);


	if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwFlags)
    {        
	    g_Glob.Deinitialize();
	    
        g_readWriteLock.WriteUnlock();
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRepository::SetCallTimeout(
     DWORD dwMaxTimeout
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::SetCacheValue(
     DWORD dwMaxBytes
    )
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);
    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }
    g_Glob.GetForestCache()->SetMaxMemory(dwMaxBytes, dwMaxAge);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::FlushCache(
     DWORD dwFlags
    )

{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetStatistics(
      DWORD  dwParameter,
     DWORD *pdwValue
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetRepositoryVersions(DWORD *pdwOldVersion, 
															 DWORD *pdwCurrentVersion)
{
	*pdwOldVersion = g_dwOldRepositoryVersion;
	*pdwCurrentVersion = g_dwCurrentRepositoryVersion;
	return S_OK;
}

HRESULT CRepository::GetNamespaceHandle(LPCWSTR wszNamespaceName,
                                    RELEASE_ME CNamespaceHandle** ppHandle)
{
    HRESULT hres;

    //
    // No validation --- that would be too hard.  Just create a handle and
    // return
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl, this);
	if (pNewHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wszNamespaceName);
    if(FAILED(hres)) 
        return hres;

    *ppHandle = pNewHandle;
    pNewHandle->AddRef();
    return S_OK;
}

HRESULT CRepository::Backup(LPCWSTR wszBackupFile, long lFlags)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	// params have already been verified by the calling method (CWbemBackupRestore::DoBackup),
	// but do it again just in case things change and this is no longer the case
    if (NULL == wszBackupFile || (lFlags != 0))
        return WBEM_E_INVALID_PARAMETER;

    //We need to lock the database so no one writes to it while we are backing it up
	CAutoReadLock lock(&g_readWriteLock);

    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    //We need to wait for the stage write to flush...
    DWORD dwCount = 0;
	long lFlushStatus = 0;
    while (!g_Glob.GetFileCache()->IsFullyFlushed())
    {
		if (g_Glob.GetFileCache()->GetFlushFailure(&lFlushStatus))
		{
			return lFlushStatus;
		}

        Sleep(100);

        if (++dwCount ==100000)
        {
            //We have a real problem here!  We need to fail the operation.
            hRes = WBEM_E_TIMED_OUT;
            break;
        }
    }

    if (SUCCEEDED(hRes))
    {
	    CRepositoryPackager packager;
	    hRes = packager.PackageRepository(wszBackupFile);
    }

	return hRes;
}
HRESULT CRepository::Restore(LPCWSTR wszBackupFile, long lFlags)
{
    return WBEM_E_NOT_SUPPORTED;
}

HRESULT CRepository::LockRepository()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    //Lock the database so no one writes to it
	g_readWriteLock.ReadLock();

    if (g_bShuttingDown)
	{
		g_readWriteLock.ReadUnlock();
        return WBEM_E_SHUTTING_DOWN;
	}

    //We need to wait for the stage write to flush...
    DWORD dwCount = 0;
	long lFlushStatus = 0;
    while (!g_Glob.GetFileCache()->IsFullyFlushed())
    {
		if (g_Glob.GetFileCache()->GetFlushFailure(&lFlushStatus))
		{
			g_readWriteLock.ReadUnlock();
			return lFlushStatus;
		}

        Sleep(100);

        if (++dwCount == 100000)
        {
            //We have a real problem here!  We need to fail the operation.
            hRes = WBEM_E_TIMED_OUT;
			g_readWriteLock.ReadUnlock();
            break;
        }
    }

	return hRes;
}

HRESULT CRepository::UnlockRepository()
{
	g_readWriteLock.ReadUnlock();

	return WBEM_S_NO_ERROR;
}

//
//
//
//
//////////////////////////////////////////////////////////////////////

CGlobals g_Glob;


HRESULT
CGlobals::Initialize()
{
    CInCritSec ics(&m_cs);
    
    if (m_bInit)
        return S_OK;

    HRESULT hRes;        

	hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
   			CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
				(void**)&m_pCoreServices);
				
	if (SUCCEEDED(hRes))
	{
	    hRes = m_ForestCache.Initialize();
	    if (SUCCEEDED(hRes))
	    {
    	    m_bInit = TRUE;
    	}
    	else
    	{
    	    m_pCoreServices->Release();
    	    m_pCoreServices = NULL;
    	}
	}
    
    return hRes;
}


HRESULT
CGlobals::Deinitialize()
{
    CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return S_OK;

    HRESULT hRes;

    m_pCoreServices->Release();
    m_pCoreServices = NULL;

    hRes = m_ForestCache.Deinitialize();

    m_bInit = FALSE;
    return hRes;
}


_IWmiCoreServices *
CGlobals::GetCoreSvcs()
{
    if (m_pCoreServices)
    {
        m_pCoreServices->AddRef();
    }
    return m_pCoreServices;
}

CForestCache * 
CGlobals::GetForestCache()
{
    return &m_ForestCache;
}

CFileCache *
CGlobals::GetFileCache()
{
    return &m_FileCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\heap.h ===
#ifndef __A51_HEAP__H_
#define __A51_HEAP__H_

#include <lock.h>
#include <absfile.h>

typedef DWORD TOffset;

#define ROSWELL_INVALID_OFFSET -1

struct CRecordInfo
{
    DWORD m_dwIndex;
    TOffset m_nOffset;

    CRecordInfo(DWORD dwIndex, TOffset nOffset) 
        : m_dwIndex(dwIndex), m_nOffset(nOffset)
    {}
};

class CFileHeap
{
public:
    CFileHeap() 
        : m_bInit(FALSE),
           // m_hTimerQueue(NULL), m_hTrimRequest(NULL),
            m_pMainFile(NULL), m_pFreeFile(NULL)
    {}
    virtual ~CFileHeap();

    long Initialize(CAbstractFileSource* pSource, 
                    LPCWSTR wszFileNameBase);
    long Uninitialize();
    long Allocate(DWORD dwLength, TOffset* pnOffset);
    long FreeAllocation(TOffset nOffset, DWORD dwLength);
    long ReadBytes(TOffset nOffset, BYTE* pBuffer, DWORD dwLength);
    long WriteBytes(TOffset nOffset, BYTE* pBuffer, DWORD dwLength);
    long InvalidateCache();

public:
    DWORD GetFileLength();
    long FindNextFree(TOffset nCurrentOffset, TOffset* pnNextFreeOffset,
                        DWORD* pdwNextFreeLength);

protected:
    BOOL m_bInit;
    CCritSec m_cs;

    CAbstractFile* m_pMainFile;
    CAbstractFile* m_pFreeFile;

public:
    typedef std::multimap<DWORD, CRecordInfo> TFreeMap;
    typedef TFreeMap::iterator TFreeIterator;
    typedef TFreeMap::value_type TFreeValue;

    typedef std::map<TOffset, DWORD> TFreeOffsetMap;
    typedef TFreeOffsetMap::iterator TFreeOffsetIterator;
    typedef TFreeOffsetMap::value_type TFreeOffsetValue;

	// for the dump utility
    TFreeOffsetMap& GetFreeOffsetMap() {return m_mapFreeOffset;}

protected:
    TFreeMap m_mapFree;
    TFreeOffsetMap m_mapFreeOffset;
    // HANDLE m_hTimerQueue;
    // HANDLE m_hTrimRequest;


protected:
    DWORD GetFreeListRecordSize();
    TFreeOffsetIterator GetOffsetIteratorFromFree(TFreeIterator itFree);
    TFreeIterator GetFreeIteratorFromOffset(TFreeOffsetIterator itOffset);
    long InsertFreeBlock(TOffset nOffset, DWORD dwLength);
    long EraseFreeBlockByFreeIt(TFreeIterator itFree);
    long EraseFreeBlockByOffsetIt(TFreeOffsetIterator itFreeOffset);
    long EraseFreeBlock(TFreeIterator itFree, TFreeOffsetIterator itOffset);
    long ReplaceFreeBlockByFreeIt(TFreeIterator itFree, TOffset nOffset, 
                                DWORD dwSize);
    long ReplaceFreeBlockByOffsetIt(TFreeOffsetIterator itFreeOffset, 
                                TOffset nOffset, DWORD dwSize);
    long ReplaceFreeBlock(TFreeIterator itFree, TFreeOffsetIterator itOffset,
                                TOffset nOffset, DWORD dwSize);
    long WriteAllocationRecordToDisk(const CRecordInfo& Info, DWORD dwSize);

    long WriteToFreeFile(TOffset nOffset, BYTE* pBuffer, DWORD dwLength);
    long ReadFromFreeFile(TOffset nOffset, BYTE* pBuffer, DWORD dwLength);
    long ReadFreeList();
};

    

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\heap.cpp ===
#include <wbemcomn.h>
#include "a51tools.h"
#include "heap.h"

#define ROSWELL_MAIN_FILE_SUFFIX L".hea"
#define ROSWELL_FREE_FILE_SUFFIX L".fre"
#define ROSWELL_INFINITE_BLOCK_SIZE 0x7FFFFFFF

#define A51_HEAP_MAIN_FILE_INDEX 0
#define A51_HEAP_FREE_FILE_INDEX 1

CFileHeap::~CFileHeap()
{
}


long CFileHeap::Initialize( CAbstractFileSource* pSource,
                            LPCWSTR wszFileNameBase)
{
    CInCritSec ics(&m_cs);
    if (m_bInit)
        return ERROR_SUCCESS;
        
    long lRes;

    //
    // Open both files
    //

    WCHAR wszMainFilePath[MAX_PATH+1];
    wcscpy(wszMainFilePath, wszFileNameBase);
    wcscat(wszMainFilePath, ROSWELL_MAIN_FILE_SUFFIX);

    HANDLE h;
    h = CreateFileW(wszMainFilePath, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
                    FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_OVERLAPPED,
                    NULL);
    if(h == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"Success from failure");
        return lRes;
    }

    lRes = pSource->Register(h, A51_HEAP_MAIN_FILE_INDEX, false, &m_pMainFile);
    if (ERROR_SUCCESS != lRes)
    {
        return lRes;
    }

    WCHAR wszFreeFilePath[MAX_PATH+1];
    wcscpy(wszFreeFilePath, wszFileNameBase);
    wcscat(wszFreeFilePath, ROSWELL_FREE_FILE_SUFFIX);

    h = CreateFileW(wszFreeFilePath, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
                    FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_OVERLAPPED,
                    NULL);
    if(h == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"Success from failure");
        return lRes;
    }

    lRes = pSource->Register(h, A51_HEAP_FREE_FILE_INDEX, false, &m_pFreeFile);
    if (ERROR_SUCCESS != lRes)
    {
        return lRes;
    }


    //
    // Read in the free list
    //
    
    m_bInit = TRUE; // set the status here, otherwise it will fail

    lRes = ReadFreeList();
    if(lRes != ERROR_SUCCESS)
    {
        m_bInit = FALSE;
        return lRes;
    }
    
    return ERROR_SUCCESS;
}

long CFileHeap::Uninitialize()
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return ERROR_SUCCESS;

    if (m_pMainFile)
    {
        delete m_pMainFile;
        m_pMainFile = NULL;
    }
    if (m_pFreeFile)
    {
        delete m_pFreeFile;
        m_pFreeFile = NULL;
    }

    m_mapFree.clear();
    m_mapFreeOffset.clear();


    m_bInit = FALSE;
        
    return ERROR_SUCCESS;
}


//
// this is a private function that uses a critsec, 
// but the public function invalidate cache does not use it
//
long CFileHeap::ReadFreeList()
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;

    long lRes;

    //
    // Clear it out
    //

    m_mapFree.clear();
    m_mapFreeOffset.clear();

    DWORD dwSize;

    //
    // Figure out the size of the free list file
    //

    lRes = m_pFreeFile->GetFileLength(&dwSize);
    
    if(dwSize > 0)
    {
        //
        // Figure out how many records that is
        //
    
        _ASSERT(dwSize % GetFreeListRecordSize() == 0, 
                L"Wrong length of free file");

        int nNumRecords = dwSize / GetFreeListRecordSize();

        //ERRORTRACE((LOG_WBEMCORE, "Rereading %d records\n", nNumRecords));

        BYTE* aBuffer = (BYTE*)TempAlloc(dwSize);
        if(aBuffer == NULL)
            return ERROR_OUTOFMEMORY;
        CTempFreeMe tfm(aBuffer);
    
        lRes = ReadFromFreeFile(0, aBuffer, dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    
        //
        // Insert them all into the map
        //
    
        BYTE* pCurrent = aBuffer;
        for(int i = 0; i < nNumRecords; i++)
        {
            DWORD dwSize;
            TOffset nOffset;
    
            memcpy(&dwSize, pCurrent, sizeof(DWORD));
            memcpy(&nOffset, pCurrent + sizeof(DWORD), sizeof(TOffset));

            //ERRORTRACE((LOG_WBEMCORE, "Offset %d, Size %d\n", nOffset, dwSize));
    
            pCurrent += GetFreeListRecordSize();
    
            try
            {
                m_mapFree.insert(TFreeValue(dwSize, CRecordInfo(i, nOffset)));
                if(dwSize)
                    m_mapFreeOffset.insert(TFreeOffsetValue(nOffset, dwSize));
            }
            catch(...)
            {
                ERRORTRACE((LOG_WBEMCORE, "Crash1\n"));
                return ERROR_OUTOFMEMORY;
            }
        }
    }
    else
    {
        //
        // Populate with an inifinite block   
        //
    
        lRes = InsertFreeBlock(0, ROSWELL_INFINITE_BLOCK_SIZE);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    return ERROR_SUCCESS;
}

long CFileHeap::InvalidateCache()
{
    return ReadFreeList();
}

long CFileHeap::FindNextFree(TOffset nCurrentOffset, TOffset* pnNextFreeOffset,
                        DWORD* pdwNextFreeLength)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;
        
    TFreeOffsetIterator it = m_mapFreeOffset.lower_bound(nCurrentOffset);
    _ASSERT(it != m_mapFreeOffset.end(), L"Missing end-block");

    *pnNextFreeOffset = it->first;
    *pdwNextFreeLength = it->second;

    return ERROR_SUCCESS;
}

DWORD CFileHeap::GetFreeListRecordSize()
{
    return sizeof(DWORD) // size
            + sizeof(TOffset); // offset
}

long CFileHeap::Allocate(DWORD dwLength, TOffset* pnOffset)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;
        
    long lRes;

    //
    // Inform transaction manager that we are doing stuff in this transaction,
    // so that real rollback needs to be performed in case of failure
    //

    m_pMainFile->Touch();

    //
    // Find the smallest number not smaller than dwLength in the map
    //

    TFreeIterator it = m_mapFree.lower_bound(dwLength);

    _ASSERT(it != m_mapFree.end(), L"Missing infinite block");
        
    //
    // Cut it off
    // 

    *pnOffset = it->second.m_nOffset;
    DWORD dwBlockSize = it->first;
    _ASSERT(dwBlockSize >= dwLength, L"Found a smaller block");

    DWORD dwSig = 0;
    lRes = ReadBytes(*pnOffset, (BYTE*)&dwSig, sizeof(DWORD));

    if(lRes != ERROR_SUCCESS)
            return lRes;    

/*
    _ASSERT(dwSig == 0x51515151, L"Mismatched block");


	 ERRORTRACE((LOG_WBEMCORE, "Allocate %d at %d out of %d\n",
 					(int)dwLength, (int)*pnOffset, (int)dwBlockSize));
*/


    //
    // Real block --- remove it and insert a shorter one (unless exact)
    //

    if(dwBlockSize != dwLength)
    {
        lRes = ReplaceFreeBlockByFreeIt(it, *pnOffset + dwLength,
                            dwBlockSize - dwLength);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }
    else
    {
        lRes = EraseFreeBlockByFreeIt(it);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    return ERROR_SUCCESS;
}

long CFileHeap::FreeAllocation(TOffset nOffset, DWORD dwLength)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;    

    long lRes;

    if(dwLength == 0)
        return ERROR_SUCCESS;

    //
    // Inform transaction manager that we are doing stuff in this transaction,
    // so that real rollback needs to be performed in case of failure
    //

    m_pMainFile->Touch();

    //
    // First, see if there is a free block after us
    //

    int nExtraLengthAtEnd = 0;
    TFreeOffsetIterator itAfter = m_mapFreeOffset.lower_bound(nOffset);
	_ASSERT(itAfter != m_mapFreeOffset.end(), L"Missing end-block");
    _ASSERT(itAfter->first != nOffset, L"Found block we are deallocating "
                                            L"in free list");

	// ERRORTRACE((LOG_WBEMCORE, "Free %d at %d\n", (int)dwLength, (int)nOffset));

    //
    // See if it starts at our end
    //

    if(itAfter->first == nOffset + dwLength)
    {
        nExtraLengthAtEnd = itAfter->second;
    }

    //
    // Now, check the block before us
    //

    int nExtraLengthInFront = 0;
    TFreeOffsetIterator itBefore = itAfter;
    if(itBefore != m_mapFreeOffset.begin())
    {
        itBefore--;

        //
        // See if it ends at our start
        //

        if(itBefore->first + itBefore->second == nOffset)
        {
            nExtraLengthInFront = itBefore->second;
        }
    }

    if(nExtraLengthInFront == 0 && nExtraLengthAtEnd == 0)
    {
        //
        // No coalescing.
        //
    
        lRes = InsertFreeBlock(nOffset, dwLength);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }
    else
    {
        //
        // We shall coalesce this block into our neighbor
        //

        if(nExtraLengthInFront && nExtraLengthAtEnd)
        {
            //
            // Coalesce all three
            //

            TOffset nNewOffset = itBefore->first;
            DWORD dwNewLength = itBefore->second + dwLength + itAfter->second;

            lRes = EraseFreeBlockByOffsetIt(itBefore);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            //
            // NOTE: it is very important that we Replace the block that 
            // follows us, since the very last block is special, and we never
            // want to erase it.
            //

            lRes = ReplaceFreeBlockByOffsetIt(itAfter, nNewOffset, dwNewLength);
            if(lRes != ERROR_SUCCESS)
                return lRes;
        }
        else if(nExtraLengthInFront)
        {
            //
            // Collapse into the front block
            //

            TOffset nNewOffset = itBefore->first;
            DWORD dwNewLength = itBefore->second + dwLength;

            lRes = ReplaceFreeBlockByOffsetIt(itBefore, nNewOffset, 
                                                dwNewLength);
            if(lRes != ERROR_SUCCESS)
                return lRes;
        }
        else 
        {
            //
            // Collapse into the back block
            //

            TOffset nNewOffset = nOffset;
            DWORD dwNewLength = itAfter->second + dwLength;

            lRes = ReplaceFreeBlockByOffsetIt(itAfter, nNewOffset, dwNewLength);
            if(lRes != ERROR_SUCCESS)
                return lRes;
        }
    }

    return ERROR_SUCCESS;
}

long CFileHeap::ReadBytes(TOffset nOffset, BYTE* pBuffer, DWORD dwLength)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;
        
    return m_pMainFile->Read(nOffset, pBuffer, dwLength, NULL);
}

long CFileHeap::WriteBytes(TOffset nOffset, BYTE* pBuffer, DWORD dwLength)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;
        
    // ERRORTRACE((LOG_WBEMCORE, "Write %d bytes at %d\n", (int)dwLength, (int)nOffset));
    return m_pMainFile->Write(nOffset, pBuffer, dwLength, NULL);
}

//
//
//  here are the private functions
//  the private finctions are supposed to be called by the public ones
//  that are guarded by a Critical Section
//
///////////////////////////////////////////////////////////////////

long CFileHeap::InsertFreeBlock(TOffset nOffset, DWORD dwLength)
{
    //
    // We need to find an empty record --- they are the ones with 0 length
    //

    DWORD dwIndex;

    TFreeIterator it = m_mapFree.find(0);
    if(it == m_mapFree.end())
    {
        //
        // No free records --- just add one. 
        //
        
        dwIndex = m_mapFree.size();
    }
    else
    {
        dwIndex = it->second.m_dwIndex;
        try
        {
            m_mapFree.erase(it);
        }
        catch(...)
        {
            ERRORTRACE((LOG_WBEMCORE, "Crash2\n"));
            return ERROR_OUTOFMEMORY;
        }
    }

    CRecordInfo Info(dwIndex, nOffset);
    try
    {
        m_mapFree.insert(TFreeValue(dwLength, Info));
        m_mapFreeOffset.insert(TFreeOffsetValue(nOffset, dwLength));
    }
    catch(...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Crash3\n"));
        return ERROR_OUTOFMEMORY;
    }

    return WriteAllocationRecordToDisk(Info, dwLength);
}


CFileHeap::TFreeOffsetIterator CFileHeap::GetOffsetIteratorFromFree(
                                                        TFreeIterator itFree)
{
    return m_mapFreeOffset.find(itFree->second.m_nOffset);
}

CFileHeap::TFreeIterator CFileHeap::GetFreeIteratorFromOffset(
                                                   TFreeOffsetIterator itOffset)
{
    //
    // Can't just look it up --- walk all entries of this size looking for the
    // right offset
    //

    TOffset nOffset = itOffset->first;
    DWORD dwSize = itOffset->second;
    TFreeIterator itFree = m_mapFree.lower_bound(dwSize);
    while(itFree != m_mapFree.end() && itFree->first == dwSize &&
            itFree->second.m_nOffset != nOffset)
    {
        itFree++;
    }

    return itFree;
}

long CFileHeap::EraseFreeBlockByFreeIt(CFileHeap::TFreeIterator itFree)
{
    return EraseFreeBlock(itFree, GetOffsetIteratorFromFree(itFree));
}

long CFileHeap::EraseFreeBlockByOffsetIt(CFileHeap::TFreeOffsetIterator itFreeOffset)
{
    return EraseFreeBlock(GetFreeIteratorFromOffset(itFreeOffset), 
                            itFreeOffset);
}

long CFileHeap::EraseFreeBlock(CFileHeap::TFreeIterator itFree, 
                                CFileHeap::TFreeOffsetIterator itOffset)
{
    _ASSERT(itFree != m_mapFree.end() && itOffset != m_mapFreeOffset.end(),
            L"Erasing a block that's not in one of the maps");

    //
    // Move the block to the free free-block list
    //

    CRecordInfo Info = itFree->second;
    Info.m_nOffset = ROSWELL_INVALID_OFFSET;
    try
    {
        m_mapFree.erase(itFree);
        m_mapFree.insert(TFreeValue(0, Info));
        m_mapFreeOffset.erase(itOffset);
    }
    catch(...)
    {    
        ERRORTRACE((LOG_WBEMCORE, "Crash4\n"));
        return ERROR_OUTOFMEMORY;
    }

    return WriteAllocationRecordToDisk(Info, 0);
}

long CFileHeap::ReplaceFreeBlockByFreeIt(CFileHeap::TFreeIterator itFree, TOffset nOffset, 
                                    DWORD dwSize)
{
    return ReplaceFreeBlock(itFree, GetOffsetIteratorFromFree(itFree),
                            nOffset, dwSize);
}

long CFileHeap::ReplaceFreeBlockByOffsetIt(CFileHeap::TFreeOffsetIterator itFreeOffset, 
                                    TOffset nOffset, DWORD dwSize)
{
    return ReplaceFreeBlock(GetFreeIteratorFromOffset(itFreeOffset), 
                            itFreeOffset, nOffset, dwSize);
}
long CFileHeap::ReplaceFreeBlock(CFileHeap::TFreeIterator itFree, 
                                    CFileHeap::TFreeOffsetIterator itOffset,
                                    TOffset nOffset, DWORD dwSize)
{
    long lRes;

    //
    // Check if the offset we are replacing is the ending offset.
    //

    bool bTruncate = false;
	TFreeOffsetIterator itNext = itOffset;
	itNext++;
    if(itNext == m_mapFreeOffset.end())
    {
        if(nOffset < itOffset->first)
            bTruncate = true;
    }

    //
    // Compute the info block --- old index, new offset
    //

    CRecordInfo Info = itFree->second;
    Info.m_nOffset = nOffset;

    try
    {
        //
        // If the size changed, remove and insert an entry into the by-size
        // map.  Otherwise, just change the info there
        //

        if(itFree->first != dwSize)
        {
            m_mapFree.erase(itFree);
            m_mapFree.insert(TFreeValue(dwSize, Info));
        }
        else
        {
            itFree->second = Info;
        }

        //
        // If the offset changed, remove and insert an entry into the by-offset
        // map.  Otherwise, just change the info there
        //

        if(itOffset->first != nOffset)
        {
            m_mapFreeOffset.erase(itOffset);
            m_mapFreeOffset.insert(TFreeOffsetValue(Info.m_nOffset, dwSize));
        }
        else
        {
            itOffset->second = dwSize;
        }
    }
    catch(...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Crash5\n"));
        return ERROR_OUTOFMEMORY;
    }
    
    if(bTruncate && 0)
    {
        //
        // Truncate the file
        //
        lRes = m_pMainFile->SetFileLength(nOffset);
        if(lRes != ERROR_SUCCESS)
            return lRes;

    }
        
    return WriteAllocationRecordToDisk(Info, dwSize);
}

   


long CFileHeap::WriteAllocationRecordToDisk(const CRecordInfo& Info, 
                                                DWORD dwSize)
{
    BYTE* pBuffer = (BYTE*)TempAlloc(GetFreeListRecordSize());
    if(pBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pBuffer);

    memcpy(pBuffer, &dwSize, sizeof(DWORD));
    memcpy(pBuffer + sizeof(DWORD), &Info.m_nOffset, sizeof(TOffset));

    if(Info.m_nOffset != ROSWELL_INVALID_OFFSET && dwSize >= sizeof(DWORD))
    {
        DWORD dwSig = 0x51515151;
        long lRes = WriteBytes(Info.m_nOffset, (BYTE*)&dwSig, sizeof(DWORD));
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    //
    // Position in the file is identified by the index
    //

    return WriteToFreeFile(GetFreeListRecordSize() * Info.m_dwIndex,
                pBuffer, GetFreeListRecordSize());
}

long CFileHeap::ReadFromFreeFile(TOffset nOffset, BYTE* pBuffer, DWORD dwLength)
{
    return m_pFreeFile->Read(nOffset, pBuffer, dwLength, NULL);
}

long CFileHeap::WriteToFreeFile(TOffset nOffset, BYTE* pBuffer, DWORD dwLength)
{
    return m_pFreeFile->Write(nOffset, pBuffer, dwLength, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\filecach.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_FILECACHE_H_
#define __WMI_A51_FILECACHE_H_

#include "shortstg.h"
#include <set>
#include <string>

extern DWORD g_ShutDownFlags;


#include "objheap.h"
#include "index.h"

class CFileCache
{
protected:
    long m_lRef;
    BOOL m_bInit;
    CCritSec m_cs;

    //CUniquePointerArray<CShortFileStagingFile> m_apStages;
    //CShortFileStagingFile* m_pMainStage;

    CAbstractFileSource m_AbstractSource;
    
    //CFileHeap m_BaseObjHeap;
    //CBtrIndex   m_Index;
    
    CObjectHeap m_ObjectHeap;
    


    DWORD m_dwBaseNameLen;
    WCHAR m_wszBaseName[MAX_PATH+1]; // be debugger friendly, live it last

public:
    class CFileEnumerator
    {
    protected:
        CFileCache* m_pCache;
        WCHAR m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixDirLen;
        int m_nCurrentStage;
        bool m_bUseFiles;
        //void* m_pStageEnumerator;
        HANDLE m_hFileEnum;
        std::set<WString, WSiless> m_setSent;
		DWORD m_dwBaseNameLen;

    public:
        CFileEnumerator(CFileCache* pCache, DWORD dwBaseNameLen)
             : m_pCache(pCache), m_nCurrentStage(-1), //m_pStageEnumerator(NULL),
                            m_hFileEnum(NULL), m_dwBaseNameLen(dwBaseNameLen)
        {}
        ~CFileEnumerator();

        long GetFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, 
                        bool bNeedToContinue);
        long GetFirstFile(WIN32_FIND_DATAW* pfd, bool bNeedToContinue);
        void ComputeCanonicalName(WIN32_FIND_DATAW* pfd, wchar_t *wszFilePath);
        long GetNext(WIN32_FIND_DATAW* pfd, bool bNeedToContinue);
        long GetRawNext(WIN32_FIND_DATAW* pfd, bool bNeedToContinue);
    };
    friend CFileEnumerator;

    class CFindCloseMe
    {
    protected:
        CFileCache* m_pCache;
        void* m_hSearch;
    public:
        CFindCloseMe(CFileCache* pCache, void* hSearch)
            : m_pCache(pCache), m_hSearch(hSearch){}

        ~CFindCloseMe()
        {
            if(m_pCache && m_hSearch) m_pCache->FindClose(m_hSearch);
        }
    };

protected:
    //int GetNumStages() {return m_apStages.GetSize();}
    //INTERNAL CShortFileStagingFile* GetStageFile(int nIndex) {return m_apStages[nIndex];}
    //INTERNAL CShortFileStagingFile* GetMainStagingFile() {return m_pMainStage;}

public:
    CFileCache();
    ~CFileCache();
private:    
    void Clear(DWORD dwShutDownFlags);
public:    
    bool IsFullyFlushed();

    long Initialize(LPCWSTR wszBaseName);
    long Uninitialize(DWORD dwShutDownFlags);
    
private:    
    long InnerInitialize(LPCWSTR wszBaseName);    
    long RepositoryExists(LPCWSTR wszBaseName);
public:    
    long WriteFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer);
    long ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, BYTE** ppBuffer,
                    bool bMustBeThere = false);
    long DeleteFile(LPCWSTR wszFileName);
    long RemoveDirectory(LPCWSTR wszFileName, bool bMustSucceed = true);

    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);

    long FindFirstIdx(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNextIdx(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindCloseIdx(void* pHandle);    

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction();

    CCritSec* GetLock() {return &m_cs;}

    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() {long lRet = InterlockedDecrement(&m_lRef); if (!lRet) delete this;return lRet;}

	bool GetFlushFailure(long* plFlushStatus);

    CObjectHeap* GetObjectHeap() {return &m_ObjectHeap;}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\filecach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <reposit.h>
#include "filecach.h"
#include "creposit.h"

//
// assumes inside m_cs
//
long CFileCache::InnerInitialize(LPCWSTR wszBaseName)
{
    long lRes;

    wcscpy(m_wszBaseName, wszBaseName);
    wcscat(m_wszBaseName, L"\\");
    m_dwBaseNameLen = wcslen(m_wszBaseName);

    //
    // Read the maximum stage-file size from the registry
    //

    HKEY hKey;
    lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxLen;
    lRes = RegQueryValueExW(hKey, L"Max Stage File Size", NULL, NULL,
                (LPBYTE)&dwMaxLen, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxLen = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Stage File Size", 0, REG_DWORD,
                (LPBYTE)&dwMaxLen, sizeof(DWORD));
    }

    dwLen = sizeof(DWORD);
    DWORD dwAbortTransactionLen;
    lRes = RegQueryValueExW(hKey, L"Absolute Max Stage File Size", NULL, NULL,
                (LPBYTE)&dwAbortTransactionLen, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS || dwAbortTransactionLen == dwMaxLen * 10)
    {
        dwAbortTransactionLen = 0x7FFFFFFF;
        lRes = RegSetValueExW(hKey, L"Absolute Max Stage File Size", 0,
                REG_DWORD, (LPBYTE)&dwAbortTransactionLen, sizeof(DWORD));
    }

    if(dwMaxLen == 0)
    {
        //
        // Staged writes are disabled!
        //
    }
    else
    {
        //
        // Create the main staging area
        //

        CFileName wszStagingName;
		if (wszStagingName == NULL)
			return ERROR_OUTOFMEMORY;
        swprintf(wszStagingName, L"%s\\LowStage.dat", wszBaseName);

        lRes = m_AbstractSource.Create(wszStagingName, dwMaxLen, 
                                            dwAbortTransactionLen);
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    CFileName wszObjHeapName;
    if(wszObjHeapName == NULL)
        return ERROR_OUTOFMEMORY;
    swprintf(wszObjHeapName, L"%s\\ObjHeap", wszBaseName);

    lRes = m_ObjectHeap.Initialize(&m_AbstractSource, 
                                   (WCHAR*)wszObjHeapName,
                                   (WCHAR*)wszBaseName,
                                   m_dwBaseNameLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = m_AbstractSource.Start();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

//
// assumes inside m_cs
//
long CFileCache::RepositoryExists(LPCWSTR wszBaseName)
{
    CFileName wszStagingName;
	if (wszStagingName == NULL)
		return ERROR_OUTOFMEMORY;

    swprintf(wszStagingName, L"%s\\LowStage.dat", wszBaseName);

    DWORD dwAttributes = GetFileAttributesW(wszStagingName);
    if (dwAttributes == -1)
        return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}

long CFileCache::Initialize(LPCWSTR wszBaseName)
{
	long lRes;

	CInCritSec ics(&m_cs);
	if (m_bInit)
	    return ERROR_SUCCESS;

    lRes = RepositoryExists(wszBaseName);
	if (ERROR_FILE_NOT_FOUND == lRes)
	{
		//If we have a database restore to do, go ahead and do it...
		lRes = DoAutoDatabaseRestore();
	}
	
    //
    // Initialize file cache.  It will read the registry itself to find out
    // its size limitations
    //
	if (SUCCEEDED(lRes))
	{
		lRes = InnerInitialize(wszBaseName);
		if (ERROR_SUCCESS == lRes)
		{
		    m_bInit = TRUE;
		}
	}

	return lRes;
}

CFileCache::CFileCache()
: m_lRef(1), m_bInit(FALSE)
{
}

CFileCache::~CFileCache()
{
}

void CFileCache::Clear(DWORD dwShutDownFlags)
{    
    m_AbstractSource.Stop(dwShutDownFlags);

    m_ObjectHeap.Uninitialize(dwShutDownFlags);

    //for(int i = 0; i < m_apStages.GetSize(); i++)
    //    m_apStages[i]->Stop(g_ShutDownFlags);

    //if (WMIDB_SHUTDOWN_MACHINE_DOWN != g_ShutDownFlags)
    //{
    //    m_apStages.RemoveAll();
    //}
}

long
CFileCache::Uninitialize(DWORD dwShutDownFlags)
{
    CInCritSec ics(&m_cs);

    if (!m_bInit)
        return 0;

    Clear(dwShutDownFlags);

    m_bInit = FALSE;
    return 0;
}


bool CFileCache::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return false;    

    //for(int i = 0; i < m_apStages.GetSize(); i++)
    //{
    //    if(!m_apStages[i]->IsFullyFlushed())
    //        return false;
    //}
    return true;
}

bool CFileCache::GetFlushFailure(long* plFlushStatus)
{
    CInCritSec ics(&m_cs);

	*plFlushStatus = 0;
    //for(int i = 0; i < m_apStages.GetSize(); i++)
    //{
    //    if(m_apStages[i]->GetFailedBefore())
	//	{
	//		*plFlushStatus = m_apStages[i]->GetStatus();
    //        return true;
	//	}
    //}
    return false;
}

long CFileCache::WriteFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;

    //
    // Write the file into the main staging file
    //

    //if(GetMainStagingFile())
    //{
    //    return GetMainStagingFile()->WriteFile(wszFileName + m_dwBaseNameLen,
    //                                        dwLen, pBuffer);
    //}
    //else
    {
	    return m_ObjectHeap.WriteFile(wszFileName, dwLen, pBuffer);
    }
}

long CFileCache::DeleteFile(LPCWSTR wszFileName)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;
    //
    // Write the file into the main staging file
    //

    //if(GetMainStagingFile())
    //{
    //    return GetMainStagingFile()->DeleteFile(wszFileName + m_dwBaseNameLen);
    //}
    //else
    {
	    return m_ObjectHeap.DeleteFile(wszFileName);
    }

}

long CFileCache::RemoveDirectory(LPCWSTR wszFileName, bool bMustSucceed)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;
    //
    // Write the file into the main staging file
    //

    //if(GetMainStagingFile())
    //{
    //    return GetMainStagingFile()->
    //                RemoveDirectory(wszFileName + m_dwBaseNameLen);
    //}
    //else
    {
        // No need to remove "directories" in the index
        return ERROR_SUCCESS;
    }
}

HRESULT CFileCache::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen,
                                BYTE** ppBuffer, bool bMustBeThere)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;

    long lRes;
    
    //
    // Search all staging files in order
    //

    //for(int i = 0; i < m_apStages.GetSize(); i++)
    //{
    //    lRes = m_apStages[i]->ReadFile(wszFileName + m_dwBaseNameLen, pdwLen,
    //                                    ppBuffer, bMustBeThere);
    //    if(lRes != ERROR_NO_INFORMATION)
    //    {
    //        if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND &&
    //                lRes != ERROR_PATH_NOT_FOUND)
    //        {
    //            ERRORTRACE((LOG_WBEMCORE, "Repository driver cannot read file "
    //                "'%S' from the stage with error code %d\n", wszFileName,
    //                        lRes));
    //        }
    //        return lRes;
    //    }
    //}

    //
    // Not in the staging areas --- get from disk!
    //
    return m_ObjectHeap.ReadFile(wszFileName, pdwLen, ppBuffer);
}


long CFileCache::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;

    //
    // Construct an enumerator
    //

    CFileEnumerator* pEnum = new CFileEnumerator(this, m_dwBaseNameLen);
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
    long lRes = pEnum->GetFirst(wszFilePrefix, pfd, (ppHandle != NULL));
    if(lRes != ERROR_SUCCESS)
    {
        delete pEnum;
        return lRes;
    }

    if(ppHandle)
        *ppHandle = (void*)pEnum;
    else
        delete pEnum;

    return ERROR_SUCCESS;
}

long CFileCache::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;    

    CFileEnumerator* pEnum = (CFileEnumerator*)pHandle;
    return pEnum->GetNext(pfd, true);
}


void CFileCache::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);    

    // do not bail out if un-initialized
    // we always want to free memory via the scoped obejct

    delete (CFileEnumerator*)pHandle;
}

//
//
//  this is a shortcut chain for going straight to the BtrIdx
//
///////////////////////////////////////////////////////////////////////

long CFileCache::FindFirstIdx(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    return m_ObjectHeap.FindFirst(wszFilePrefix, pfd, ppHandle);
}

long CFileCache::FindNextIdx(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    return m_ObjectHeap.FindNext(pHandle, pfd);
}


void CFileCache::FindCloseIdx(void* pHandle)
{
    m_ObjectHeap.FindClose(pHandle);
}



long CFileCache::BeginTransaction()
{
    if (!m_bInit)
        return -1;
        
    //if(GetMainStagingFile())
    //    return GetMainStagingFile()->BeginTransaction();
    //else
        return m_AbstractSource.Begin(NULL);
}

long CFileCache::CommitTransaction()
{
    if (!m_bInit)
        return -1;
        
    A51TRACE(("Committing Transaction!\n"));
    //if(GetMainStagingFile())
    //    return GetMainStagingFile()->CommitTransaction();
    //else
        return m_AbstractSource.Commit(0);
}

long CFileCache::AbortTransaction()
{
    if (!m_bInit)
        return -1;

    A51TRACE(("Aborting Transaction!\n"));
    //if(GetMainStagingFile())
    //    return GetMainStagingFile()->AbortTransaction(NULL);
    //else
    {
        //
        // Actually rollback the staging file
        //

        bool bNonEmpty = false;
        long lRes = m_AbstractSource.Rollback(0, &bNonEmpty);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        if(bNonEmpty)
        {
            //
            // We rolled back a non-empty transaction, which means that the
            // in-memory caches (which already took the transaction into 
            // account) may no longer be valid.  Invalidate all caches
            //

            m_ObjectHeap.InvalidateCache();
            
        }        
        return ERROR_SUCCESS;
    }
}

CFileCache::CFileEnumerator::~CFileEnumerator()
{
    //if(m_pStageEnumerator)
    //    m_pCache->GetStageFile(m_nCurrentStage)->FindClose(m_pStageEnumerator);

    if(m_hFileEnum)
        m_pCache->m_ObjectHeap.FindClose(m_hFileEnum);
}

long CFileCache::CFileEnumerator::GetFirst(LPCWSTR wszPrefix,
                                            WIN32_FIND_DATAW* pfd,
                                            bool bNeedToContinue)
{
    long lRes;

    wcscpy(m_wszPrefix, wszPrefix);

    WCHAR* pwcLastSlash = wcsrchr(m_wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        return E_OUTOFMEMORY;

    m_dwPrefixDirLen = pwcLastSlash - m_wszPrefix;

    //
    // We are going to start with the first staging area
    //

    m_nCurrentStage = 0;
    m_bUseFiles = false;

    //
    // Everything is set up to indicate that we are at the very beginning ---
    // GetNext will retrieve the first
    //

    lRes = GetNext(pfd, bNeedToContinue);

    //
    // One last thing --- absense of files is ERROR_NO_MORE_FILES for GetNext,
    // but ERROR_FILE_NOT_FOUND for GetFirst, so translate
    //

    if(lRes == ERROR_NO_MORE_FILES)
        lRes = ERROR_FILE_NOT_FOUND;

    return lRes;
}

long CFileCache::CFileEnumerator::GetFirstFile(WIN32_FIND_DATAW* pfd,
                                                bool bNeedToContinue)
{
    long lRes;

    m_bUseFiles = true;

    if(bNeedToContinue)
        lRes = m_pCache->FindFirstIdx(m_wszPrefix, pfd, &m_hFileEnum);
    else
        lRes = m_pCache->FindFirstIdx(m_wszPrefix, pfd, NULL);

    A51TRACE(("Actual FindFirstFileW on %S returning %p %d\n",
        wszMask, (void*)m_hFileEnum, lRes));
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_PATH_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else
            return lRes;
    }
    else
        return ERROR_SUCCESS;
}

void CFileCache::CFileEnumerator::ComputeCanonicalName(WIN32_FIND_DATAW* pfd,
                                                    wchar_t *wszFilePath)
{
    wcsncpy(wszFilePath, m_wszPrefix, m_dwPrefixDirLen+1);
    wbem_wcsupr(wszFilePath+m_dwPrefixDirLen+1, pfd->cFileName);
}

long CFileCache::CFileEnumerator::GetNext(WIN32_FIND_DATAW* pfd,
                                            bool bNeedToContinue)
{
    //
    // Need-to-continue optimizations are not possible if staging is used at 
    // this level because even though the caller is only asking for one object,
    // we may need to retrieve more than that from the store since some of the
    // objects in the store may be overriden by the stage file deletions
    //

    //if(m_pCache->GetNumStages() > 0)
    //    bNeedToContinue = true;

    long lRes;

    //
    // Go through the files in the enumerator until we find a new and valid one
    //

    while((lRes = GetRawNext(pfd, bNeedToContinue)) == ERROR_SUCCESS)
    {
        //
        // Compute the full name
        //

        CFileName wszFullName;
		if (wszFullName == NULL)
			return ERROR_OUTOFMEMORY;
        ComputeCanonicalName(pfd, wszFullName);

        //
        // Check if it is already in our map of returned files
        //

        if(m_setSent.find((const wchar_t*)wszFullName) != m_setSent.end())
            continue;

        //
        // Check if this file is deleted
        //

        bool bDeleted = false;
        /*
        for(int i = 0; i < m_nCurrentStage; i++)
        {
			long hres = m_pCache->GetStageFile(i)->IsDeleted(wszFullName + m_dwBaseNameLen);
			if (hres == S_OK)
            {
                bDeleted = true;
                break;
            }
			else if (FAILED(hres))
			{
				return hres;
			}
        }
        */

        if(bDeleted)
            continue;

        //
        // All clear!
        //

        if(!m_bUseFiles)
            m_setSent.insert((const wchar_t*)wszFullName);

        return ERROR_SUCCESS;
    }

    return lRes;
}

long CFileCache::CFileEnumerator::GetRawNext(WIN32_FIND_DATAW* pfd,
                                            bool bNeedToContinue)
{
    long lRes;

    if(m_bUseFiles)
    {
        _ASSERT(bNeedToContinue, L"Continuing without need?");

        //
        // Get the next file
        //
        lRes = m_pCache->FindNextIdx(m_hFileEnum, pfd);
        if(lRes != ERROR_SUCCESS)
        {
            m_pCache->FindCloseIdx(m_hFileEnum);
            m_hFileEnum = NULL;
            return lRes;
        }

        return ERROR_SUCCESS;
    }
    else
    {
        //
        // Check if we even have a stage enumerator
        //

        /*
        if(m_pStageEnumerator)
        {
            _ASSERT(bNeedToContinue, L"Continuing without need?");

            //
            // Get the next file from the same stage
            //

            lRes = m_pCache->GetStageFile(m_nCurrentStage)->
                        FindNext(m_pStageEnumerator, pfd);
            if(lRes != ERROR_NO_MORE_FILES)
                return lRes;

            //
            // Advance to the next one
            //

            m_pCache->GetStageFile(m_nCurrentStage)->
                    FindClose(m_pStageEnumerator);
            m_pStageEnumerator = NULL;
            m_nCurrentStage++;
        }
        else
        {
            //
            // This is our first time --- we are all set up to pick up the first
            // file from the first stage
            //
        }
        */

        while(1)
        {
            //if(m_nCurrentStage >= m_pCache->GetNumStages())
            {
                //
                // Go to files
                //

                lRes = GetFirstFile(pfd, bNeedToContinue);
                if(lRes == ERROR_FILE_NOT_FOUND)
                    return ERROR_NO_MORE_FILES;
                else
                    return lRes;
            }
            /*
            else
            {
                _ASSERT(bNeedToContinue, L"Continuing without need?");

                //
                // Initialize the next stage
                //

                lRes = m_pCache->GetStageFile(m_nCurrentStage)->
                            FindFirst(m_wszPrefix + m_dwBaseNameLen, pfd, &m_pStageEnumerator);
                if(lRes == ERROR_FILE_NOT_FOUND)
                {
                    //
                    // This stage has nothing to contribute --- move along
                    //

                    m_nCurrentStage++;
                    continue;
                }
                else
                    return lRes;
            }
            */
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\hiecache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include "hiecache.h"
#include <malloc.h>
#include <corex.h>

extern bool g_bShuttingDown;

long CHierarchyCache::s_nCaches = 0;

long CClassRecord::s_nRecords = 0;

//
//
//  CClassRecord::CClassRecord
//
////////////////////////////////////////////////////////////////////

CClassRecord::CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash)
    : m_wszClassName(NULL), m_pClassDef(NULL), m_pParent(NULL), 
        m_eIsKeyed(e_KeynessUnknown), m_bTreeComplete(false), 
        m_bChildrenComplete(false),
        m_lLastChildInvalidationIndex(-1), m_pMoreRecentlyUsed(NULL),
        m_pLessRecentlyUsed(NULL), m_lRef(0), m_nStatus(0), m_bSystemClass(false)
{
    m_wszClassName = new WCHAR[wcslen(wszClassName)+1];
	if (m_wszClassName == NULL)
		throw CX_MemoryException();
    wcscpy(m_wszClassName, wszClassName);

    wcscpy(m_wszHash, wszHash);

    m_dwLastUsed = GetTickCount();
	s_nRecords++;
}

CClassRecord::~CClassRecord()
{
    delete [] m_wszClassName;
    if(m_pClassDef)
	{
		if(m_pClassDef->Release() != 0)
		{
			s_nRecords++;
			s_nRecords--;
		}
    }
	s_nRecords--;
}

HRESULT CClassRecord::EnsureChild(CClassRecord* pChild)
{
    A51TRACE(("Make %S child of %S\n", pChild->m_wszClassName,
            m_wszClassName));
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
            return WBEM_S_FALSE;
    }
    
    if(m_apChildren.Add(pChild) < 0)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}

HRESULT CClassRecord::RemoveChild(CClassRecord* pChild)
{
    A51TRACE(("Make %S NOT child of %S\n", 
                    pChild->m_wszClassName, m_wszClassName));
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
        {
            m_apChildren.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }
    
    return WBEM_E_NOT_FOUND;
}
        
//
//
//    CHierarchyCache::CHierarchyCache
//
/////////////////////////////////////////////////////////////////////
    
CHierarchyCache::CHierarchyCache(CForestCache* pForest)
    : m_pForest(pForest), m_lNextInvalidationIndex(0), m_lRef(0),
        m_hresError(S_OK)
{
	s_nCaches++;
}

CHierarchyCache::~CHierarchyCache()
{
    Clear();
	s_nCaches--;
}

void CHierarchyCache::Clear()
{
    CInCritSec ics(&m_cs);
    
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CClassRecord* pRecord = it->second;
        m_pForest->RemoveRecord(pRecord);
        it = m_map.erase(it);
        pRecord->Release();
    }
}

void CHierarchyCache::SetError(HRESULT hresError)
{
    m_hresError = hresError;
}

HRESULT CHierarchyCache::GetError()
{
    return m_hresError;
}

void CHierarchyCache::MakeKey(LPCWSTR wszClassName, LPWSTR wszKey)
{
    // wbem_wcsupr(wszKey, wszClassName);
    A51Hash(wszClassName, wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClass(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    LPWSTR wszKey = (WCHAR*)_alloca(MAX_HASH_LEN*2+2);
    MakeKey(wszClassName, wszKey);

    return FindClassByKey(wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClassByKey(LPCWSTR wszKey)
{
    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
        return NULL;

    return it->second;
}

INTERNAL CClassRecord* CHierarchyCache::EnsureClass(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    LPWSTR wszKey = (WCHAR*)_alloca(MAX_HASH_LEN*2+2);
    MakeKey(wszClassName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        //
        // Create a new record with the name
        //

		try
		{
			CClassRecord* pRecord = new CClassRecord(wszClassName, wszKey);
			if(pRecord == NULL)
				return NULL;

			pRecord->AddRef(); // one for the map
			
			m_map[pRecord->m_wszHash] = pRecord;
			//pRecord->AddRef(); // one for the customer

			return pRecord;
		}
		catch (CX_MemoryException)
		{
			return NULL;
		}
    }
    else
    {
        return it->second;
    }
}


HRESULT CHierarchyCache::AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName,
                                    bool bClone, __int64 nTime, bool bSystemClass)
{
    CInCritSec ics(&m_cs);
    HRESULT hres;

    m_pForest->MarkAsserted(this, wszClassName);

    //
    // If no record is given, find one
    //

    CClassRecord* pRecord = NULL;

    if(wszClassName == NULL)
    {
        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);

        hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_CLASS;

        pRecord = EnsureClass(V_BSTR(&v));
    }
    else
        pRecord = EnsureClass(wszClassName);

    if(pRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Figure out the parent
    //

    A51TRACE(("%p: Asserting %S on %I64d with %I64d\n", 
                    this, pRecord->m_wszClassName, g_nCurrentTime, nTime));

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(SUCCEEDED(hres))
    {
        if(V_VT(&v) == VT_BSTR)
            pRecord->m_pParent = EnsureClass(V_BSTR(&v));
        else
            pRecord->m_pParent = EnsureClass(L"");

        if(pRecord->m_pParent)
            pRecord->m_pParent->EnsureChild(pRecord);
    }
    else
    {
        return hres;
    }
    
    //
    // Check if the class is keyed
    //

    unsigned __int64 i64Flags = 0;
    hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                    &i64Flags);
    if(FAILED(hres))
        return hres;

    if(i64Flags)
    {
        pRecord->m_eIsKeyed = e_Keyed;
    }
    else
    {
        pRecord->m_eIsKeyed = e_NotKeyed;
    }
     
    //
    // Expell whatever definition is there from the cache
    //

    m_pForest->RemoveRecord(pRecord);

    //  
    // Figure out how much space this object will take
    //

    DWORD dwSize;
    hres = pClass->GetObjectMemory(NULL, 0, &dwSize);
    if(hres != WBEM_E_BUFFER_TOO_SMALL)
    {
        if(SUCCEEDED(hres))
            return WBEM_E_CRITICAL_ERROR;
        else
            return hres;
    }

    //
    // Good.  Make room and add to cache
    //

    if(m_pForest->MakeRoom(dwSize))
    {
        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            hres = pClass->Clone(&pObj);
            if(FAILED(hres))
                return hres;

            if(pObj)
            {
                pObj->QueryInterface(IID__IWmiObject, 
                                        (void**)&pRecord->m_pClassDef);
                pObj->Release();
            }
        }
        else
        {   pRecord->m_pClassDef = pClass;
            pClass->AddRef();
        }

        if(nTime)
        {
            pRecord->m_bRead = true;
            pRecord->m_nClassDefCachedTime = nTime;
        }
        else
        {
            pRecord->m_bRead = false;
            pRecord->m_nClassDefCachedTime = g_nCurrentTime++;
        }

        pRecord->m_dwClassDefSize = dwSize;

		pRecord->m_bSystemClass = bSystemClass;
        
        //
        // It is most recently used, of course
        //

        m_pForest->Add(pRecord);
    }
    
    return WBEM_S_NO_ERROR;
    
}

HRESULT CHierarchyCache::InvalidateClass(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = NULL;
    pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
    {
        // 
        // The record is not there --- there is nothing to invalidate.  This
        // is based on the assumption that if a class record is in the 
        // cache, then so are all its parents, which is true at the moment
        // because in order to construct a class we need to retrieve its
        // parents first.
        //

        return WBEM_S_FALSE;
    }

    pRecord->AddRef();
    CTemplateReleaseMe<CClassRecord> rm1(pRecord);

    LONGLONG lThisInvalidationIndex = m_lNextInvalidationIndex++;

    hres = InvalidateClassInternal(pRecord);

    //
    // Clear complete bits in all our parents, since this invalidation
    // means that no current enumeration of children can be trusted. At the same
    // time untie ourselves from the parent!
    //
    
    if(pRecord->m_pParent)
    {
        pRecord->m_pParent->m_bChildrenComplete = false;
        pRecord->m_pParent->m_bTreeComplete = false;
        pRecord->m_pParent->m_lLastChildInvalidationIndex = 
            lThisInvalidationIndex;
        pRecord->m_pParent->RemoveChild(pRecord);

        CClassRecord* pCurrent = pRecord->m_pParent->m_pParent;
        while(pCurrent)
        {
            pCurrent->m_bTreeComplete = false;
            pCurrent = pCurrent->m_pParent;
        }
    }

    return S_OK;
}


HRESULT CHierarchyCache::InvalidateClassInternal(CClassRecord* pRecord)
{
    //
    // Untie from the usage chain
    //

    A51TRACE(("%p: Invalidating %S on %I64d with %d children\n",
                    this, pRecord->m_wszClassName, g_nCurrentTime,
                    pRecord->m_apChildren.GetSize()));
    
    //
    // Remove all its children from the cache
    //

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        InvalidateClassInternal(pRecord->m_apChildren[i]);
    }

    pRecord->m_apChildren.RemoveAll();

    //
    // Count ourselves out of the total memory
    //

    m_pForest->RemoveRecord(pRecord);

    //
    // Remove ourselves from the cache
    //

    m_map.erase(pRecord->m_wszHash);
	pRecord->Release();

    return S_OK;
}

HRESULT CHierarchyCache::DoneWithChildren(LPCWSTR wszClassName, bool bRecursive,
                                LONGLONG lStartIndex, CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    //
    // Find the record if not given
    //

    if(pRecord == NULL)
    {
        pRecord = FindClass(wszClassName);
        if(pRecord == NULL)
        {
            // Big time invalidation must have occurred
            return WBEM_S_FALSE;
        }
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByHash(LPCWSTR wszHash, 
                                bool bRecursive, LONGLONG lStartIndex)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
    {
        // Big time invalidation must have occurred
        return WBEM_S_FALSE;
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex)
{
    //  
    // Check if any child invalidations occurred in this node since we started
    //

    if(lStartIndex < pRecord->m_lLastChildInvalidationIndex)
        return WBEM_S_FALSE;
    else
        pRecord->m_bChildrenComplete = true;
    
    if(bRecursive)
    {
        //
        // We have completed a recursive enumeration --- descend the 
        // hierarchy and mark as complete all the children that have not been
        // modified since the start
        //

        bool bAllValid = true;
        for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
        {
            CClassRecord* pChildRecord = pRecord->m_apChildren[i];
            HRESULT hres = DoneWithChildren(pChildRecord->m_wszClassName, true, 
                                    lStartIndex, pChildRecord);
    
            if(hres != S_OK)
                bAllValid = false;
        }
    
        if(bAllValid)
        {
            //
            // There were no invalidations anywhere in the tree, which makes
            // this record tree-complete
            //

            pRecord->m_bTreeComplete = true;
            return WBEM_S_NO_ERROR;
        }
        else
            return S_FALSE;
    }
    else
        return WBEM_S_NO_ERROR;
}


RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDef(LPCWSTR wszClassName,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    return GetClassDefFromRecord(pRecord, bClone);
}

RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefByHash(LPCWSTR wszHash,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead, bool *pbSystemClass)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
        return NULL;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;
	
	if (pbSystemClass)
		*pbSystemClass = pRecord->m_bSystemClass;

    return GetClassDefFromRecord(pRecord, bClone);
}

// assumes: in m_cs
RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefFromRecord(
                                                CClassRecord* pRecord,
                                                bool bClone)
{
    //
    // Accessing m_pClassDef, so we have to lock the forest
    //

    CInCritSec ics(m_pForest->GetLock());

    if(pRecord->m_pClassDef)
    {
        m_pForest->MakeMostRecentlyUsed(pRecord);

        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            if(FAILED(pRecord->m_pClassDef->Clone(&pObj)))
                return NULL;
            else
            {
                _IWmiObject* pRes = NULL;
                pObj->QueryInterface(IID__IWmiObject, (void**)&pRes);
                pObj->Release();
                return pRes;
            }
        }
        else
        {
            pRecord->m_pClassDef->AddRef();
            return pRecord->m_pClassDef;
        }
    }
    else
        return NULL;
}

HRESULT CHierarchyCache::EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren)
{
    CInCritSec ics(&m_cs);

    //
    // Get the record
    //

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    if(bRecursive && !pRecord->m_bTreeComplete)
        return WBEM_S_FALSE;

    return EnumChildrenInternal(pRecord, bRecursive, awsChildren);
}

HRESULT CHierarchyCache::EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren)
{
    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildren.Add(pChildRecord->m_wszClassName) < 0)
            return WBEM_E_OUT_OF_MEMORY;
        
        if(bRecursive)
        {
            HRESULT hres = EnumChildrenInternal(pChildRecord, bRecursive, 
                                                    awsChildren);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CHierarchyCache::EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys)
{
    CInCritSec ics(&m_cs);

    //
    // Get the record
    //

    CClassRecord* pRecord = FindClassByKey(wszClassKey);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildKeys.Add(pChildRecord->m_wszHash) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

    

    

HRESULT CHierarchyCache::GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

// assumes: in cs
HRESULT CHierarchyCache::GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    *pwszKeyRoot = NULL;

    if(pRecord->m_eIsKeyed == e_NotKeyed)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Go up until an unkeyed record is found.  Keep the previous in pPrev
    //

	CClassRecord* pPrev = pRecord;
    while(pRecord && pRecord->m_eIsKeyed == e_Keyed)
	{
		pPrev = pRecord;
        pRecord = pRecord->m_pParent;
	}

    if(pRecord && pRecord->m_eIsKeyed == e_NotKeyed)
    {
        //
        // Found unkeyed parent --- pPrev is the root
        //

        LPCWSTR wszKeyRoot = pPrev->m_wszClassName;
        DWORD dwLen = (wcslen(wszKeyRoot)+1) * sizeof(WCHAR);
        *pwszKeyRoot = (WCHAR*)TempAlloc(dwLen);
		if (*pwszKeyRoot == NULL)
			return WBEM_E_OUT_OF_MEMORY;
        wcscpy(*pwszKeyRoot, wszKeyRoot);
        return S_OK;
    }
    else
    {
        //
        // No unkeyed parents --- since "" is known to be unkeyed, we had have
        // hit a gap in the cache
        //

        return WBEM_E_NOT_FOUND;
    }
}

HRESULT CHierarchyCache::GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClassByKey(wszKey);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

DELETE_ME LPWSTR CHierarchyCache::GetParent(LPCWSTR wszClassName)
{
    CInCritSec ics(&m_cs);

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pRecord->m_pParent)
    {
        LPCWSTR wszParent = pRecord->m_pParent->m_wszClassName;
        LPWSTR wszCopy = new WCHAR[wcslen(wszParent)+1];
		if (wszCopy == NULL)
			return NULL;
        wcscpy(wszCopy, wszParent);
        return wszCopy;
    }
    else
        return NULL;
}

//
//
//  CForestCache
//
//////////////////////////////////////////////////////////////////////

HRESULT CForestCache::Initialize()
{
    CInCritSec ics(&m_cs);
    
    if (m_bInit)
        return S_OK;

    //
    // Read the size limits from the registry
    //

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxSize;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Size", NULL, NULL, 
                (LPBYTE)&dwMaxSize, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxSize = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Size", 0, REG_DWORD, 
                (LPBYTE)&dwMaxSize, sizeof(DWORD));
    }

    //
    // Read the maximum useful age of an item
    //

    dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }


    //
    // Apply
    //

    SetMaxMemory(dwMaxSize, dwMaxAge);

    //
    // Create a timer queue for flushing
    //

    //m_hTimerQueue = CreateTimerQueue();
    //m_hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    m_bInit = TRUE;

    return WBEM_S_NO_ERROR;
}


bool CForestCache::MakeRoom(DWORD dwSize)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return false;    

    if(dwSize > m_dwMaxMemory)
        return false; // no hope!

    //  
    // Remove records until satisfied. Also, remove all records older than the
    // maximum age
    //

    DWORD dwNow = GetTickCount();

    while(m_pLeastRecentlyUsed && 
            (m_dwTotalMemory + dwSize > m_dwMaxMemory ||
             dwNow - m_pLeastRecentlyUsed->m_dwLastUsed > m_dwMaxAgeMs)
         )
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

bool CForestCache::Flush()
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return false;
    
    while(m_pLeastRecentlyUsed)
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

//
//
//  Test Only Function NOT IN REGULAR CODE
//
///////////////////////////////////////////////////////////////


bool CForestCache::Test()
{
	if(m_pMostRecentlyUsed == NULL)
	{
		if(m_pLeastRecentlyUsed)
			DebugBreak();
		return true;
	}

	if(m_pMostRecentlyUsed->m_pMoreRecentlyUsed)
		DebugBreak();

	CClassRecord* pOne = m_pMostRecentlyUsed;
	CClassRecord* pTwo = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	while(pOne && pOne != pTwo)
	{
		if(pOne->m_pLessRecentlyUsed && pOne->m_pLessRecentlyUsed->m_pMoreRecentlyUsed != pOne)
			DebugBreak();
		if(pOne->m_pClassDef == NULL)
			DebugBreak();

		if(pOne->m_pLessRecentlyUsed == NULL && pOne != m_pLeastRecentlyUsed)
			DebugBreak();
		
		pOne = pOne->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
	}
	if(pOne)
		DebugBreak();
	return true;
}
        
void CForestCache::MakeMostRecentlyUsed(CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);

	//Test();
	Untie(pRecord);

	pRecord->m_pMoreRecentlyUsed = NULL;
	pRecord->m_pLessRecentlyUsed = m_pMostRecentlyUsed;
	if(m_pMostRecentlyUsed)
		m_pMostRecentlyUsed->m_pMoreRecentlyUsed = pRecord;

	m_pMostRecentlyUsed = pRecord;
	if(m_pLeastRecentlyUsed == NULL)
		m_pLeastRecentlyUsed = pRecord;


    pRecord->m_dwLastUsed = GetTickCount();
    pRecord->m_nStatus = 4;
	//Test();

    //
    // Schedule a timer to clean up, if not already there
    //

    if(m_hCurrentTimer == NULL)
    {
        CreateTimerQueueTimer(&m_hCurrentTimer, NULL, //m_hTimerQueue, 
            (WAITORTIMERCALLBACK)&staticTimerCallback, this, m_dwMaxAgeMs,
            m_dwMaxAgeMs, WT_EXECUTEINTIMERTHREAD);
    }
}

void CForestCache::staticTimerCallback(void* pParam, BOOLEAN)
{
    ((CForestCache*)pParam)->TimerCallback();
}
    
void CForestCache::TimerCallback()
{    
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return;

    //
    // Clean up what's stale
    //

    MakeRoom(0);

    //
    // See if we have any more reasons to live
    //

    if(m_pMostRecentlyUsed == NULL)
    {
        DeleteTimerQueueTimer(NULL , m_hCurrentTimer, NULL);
        m_hCurrentTimer = NULL;
    }
}

void CForestCache::Add(CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return;

    MakeMostRecentlyUsed(pRecord);
    m_dwTotalMemory += pRecord->m_dwClassDefSize;
    pRecord->m_nStatus = 3;
}

void CForestCache::RemoveRecord(CClassRecord* pRecord)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return;    

    if(pRecord->m_pClassDef == NULL)
		return;

	Untie(pRecord);

    m_dwTotalMemory -= pRecord->m_dwClassDefSize;

    pRecord->m_pClassDef->Release();
    pRecord->m_pClassDef = NULL;
    pRecord->m_nStatus = 2;
}

//
//
//  helper function, always in m_cs
//
///////////////////////////////////////////////////////

void CForestCache::Untie(CClassRecord* pRecord)
{
	//Test();

    CClassRecord* pPrev = pRecord->m_pLessRecentlyUsed;
    CClassRecord* pNext = pRecord->m_pMoreRecentlyUsed;
    if(pPrev)
        pPrev->m_pMoreRecentlyUsed = pNext;
    if(pNext)
        pNext->m_pLessRecentlyUsed = pPrev;

    if(m_pLeastRecentlyUsed == pRecord)
        m_pLeastRecentlyUsed = m_pLeastRecentlyUsed->m_pMoreRecentlyUsed;

    if(m_pMostRecentlyUsed == pRecord)
        m_pMostRecentlyUsed = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	pRecord->m_pMoreRecentlyUsed = pRecord->m_pLessRecentlyUsed = NULL;
	//Test();
}

void CForestCache::SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs)
{
    m_dwMaxMemory = dwMaxMemory;
    m_dwMaxAgeMs = dwMaxAgeMs;
    
    // 
    // Make room for 0 bytes --- has the effect of clearing all the records
    // above the limit
    //

    MakeRoom(0);
}


CHierarchyCache* CForestCache::GetNamespaceCache(LPCWSTR wszNamespace)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return  NULL;

    //
    // See if you can find one
    //

    TIterator it = m_map.find(wszNamespace);
    if(it != m_map.end())
    {
        it->second->AddRef();
        return it->second;
    }
    else
    {
        //
        // Not there --- create one
        //

        CHierarchyCache* pCache = new CHierarchyCache(this);
        if(pCache == NULL)
            return NULL;
            
        pCache->AddRef();   // this refcount if for the cache
        m_map[wszNamespace] = pCache;
        pCache->AddRef();  // this refcount if for the customers
        return pCache;
    }
}

void CForestCache::ReleaseNamespaceCache(LPCWSTR wszNamespace, 
                                            CHierarchyCache* pCache)
{
    CInCritSec ics(&m_cs);    
    //
    // this is a cleanup function, we always want this to be called
    //
    //if (!m_bInit)
    //    return;    

    //
    // Find it in the map
    //
    TIterator it = m_map.find(wszNamespace);
        
    if (it !=  m_map.end() && (it->second == pCache))
    {
        //
	    // Last ref-count --- remove
	    //
        if( 1 == pCache->Release())
        {
	        m_map.erase(it);
	        pCache->Release(); // this is the last one
        }
    }
    else
    {
        pCache->Release();
    }
}

void CForestCache::BeginTransaction()
{
    m_bAssertedInTransaction = false;
}

bool CForestCache::MarkAsserted(CHierarchyCache* pCache, LPCWSTR wszClassName)
{
    m_bAssertedInTransaction = true;
    return true;
}

void CForestCache::CommitTransaction()
{
    m_bAssertedInTransaction = false;
}

void CForestCache::AbortTransaction()
{
    if(m_bAssertedInTransaction)
        Clear();

    m_bAssertedInTransaction = false;
}

void CForestCache::Clear()
{
    CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return;

    Flush();

    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        it->second->Clear();
        it++;
    }
}

HRESULT
CForestCache::Deinitialize()
{
    CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return S_OK;
    
    if(m_hCurrentTimer)
    {
        DeleteTimerQueueTimer( NULL, m_hCurrentTimer, NULL);
        m_hCurrentTimer = NULL;
    }

    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        it->second->Clear();
        it->second->Release();
        it->second = NULL;        
        it++;
    };

    m_map.erase(m_map.begin(),m_map.end());

    m_bInit = FALSE;
    return S_OK;
}

CForestCache::~CForestCache()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\hiecache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51__HIECACHE__H_
#define __WMI_A51__HIECACHE__H_

//
// NOTE: it is critical that things be marked in the cache while the repository
// lock is held!  Otherwise, invalidation/completion logic will break
//

#include <wbemint.h>
#include <map>
#include <sync.h>
#include "a51tools.h"


class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool> 
{
public:
    bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

typedef enum {e_KeynessUnknown, e_Keyed, e_NotKeyed} EKeyNess;

class CClassRecord
{
protected:
    static long s_nRecords;

    long m_lRef;

    CClassRecord* m_pMoreRecentlyUsed;
    CClassRecord* m_pLessRecentlyUsed;
    
    LPWSTR m_wszClassName;
    WCHAR m_wszHash[MAX_HASH_LEN+1];

    _IWmiObject* m_pClassDef;
    DWORD m_dwClassDefSize;
    
    CClassRecord* m_pParent;
    EKeyNess m_eIsKeyed;
    CPointerArray<CClassRecord> m_apChildren;

    bool m_bTreeComplete;
    bool m_bChildrenComplete;
    LONGLONG m_lLastChildInvalidationIndex;

    DWORD m_dwLastUsed;
    int m_nStatus;
    __int64 m_nClassDefCachedTime;
    bool m_bRead;
	bool m_bSystemClass;

public:
    CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash);
    virtual ~CClassRecord();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}

    HRESULT EnsureChild(CClassRecord* pChild);
    HRESULT RemoveChild(CClassRecord* pChild);

    friend class CHierarchyCache;
    friend class CForestCache;
};

class CForestCache;
class CHierarchyCache
{
protected:

    static long s_nCaches;

    long m_lRef;
    typedef std::map<LPCWSTR, CClassRecord*, wcscless> TMap;
    typedef TMap::iterator TIterator;

    CForestCache* m_pForest;
    CCritSec m_cs;
    TMap m_map;
    LONGLONG m_lNextInvalidationIndex;
    HRESULT m_hresError;

public:
    CHierarchyCache(CForestCache* pForest);
    virtual ~CHierarchyCache();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() { long lRet = InterlockedDecrement(&m_lRef); if (0 == lRet) delete this; return lRet; }

    HRESULT AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName, 
                       bool bClone, __int64 nTime, bool bSystemClass);
    HRESULT InvalidateClass(LPCWSTR wszClassName);

    HRESULT DoneWithChildren(LPCWSTR wszClassName, bool bRecursive, 
                            LONGLONG lStartingIndex, 
                            CClassRecord* pRecord = NULL);
    HRESULT DoneWithChildrenByHash(LPCWSTR wszHash, bool bRecursive,
                                LONGLONG lStartIndex);
    LONGLONG GetLastInvalidationIndex() {return m_lNextInvalidationIndex-1;}

    void SetError(HRESULT hresError);
    HRESULT GetError();

    void Clear();

public:
    RELEASE_ME _IWmiObject* GetClassDef(LPCWSTR wszClassName, 
                                        bool bClone, __int64* pnTime = NULL,
                                        bool* pbRead = NULL);
    HRESULT EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren);
    HRESULT EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys);
    HRESULT GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    DELETE_ME LPWSTR GetParent(LPCWSTR wszClassName);
    RELEASE_ME _IWmiObject* GetClassDefByHash(LPCWSTR wszHash, bool bClone,
                                              __int64* pnTime = NULL,
                                              bool* pbRead = NULL,
											  bool *pbSystemClass = NULL);

protected:
    INTERNAL CClassRecord* FindClass(LPCWSTR wszClassName);
    INTERNAL CClassRecord* FindClassByKey(LPCWSTR wszKey);
    RELEASE_ME _IWmiObject* GetClassDefFromRecord(CClassRecord* pRecord,
                                                bool bClone);
    INTERNAL CClassRecord* EnsureClass(LPCWSTR wszClassName);
    HRESULT EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren);

    HRESULT InvalidateClassInternal(CClassRecord* pRecord);
    HRESULT DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex);
    static void MakeKey(LPCWSTR wszClassName, LPWSTR wszKey);
};

class CForestCache
{
protected:
    CCritSec m_cs;

    CClassRecord* m_pMostRecentlyUsed;
    CClassRecord* m_pLeastRecentlyUsed;
    DWORD m_dwMaxMemory;
    DWORD m_dwMaxAgeMs;
    DWORD m_dwTotalMemory;

    //HANDLE m_hTimerQueue;
    HANDLE m_hCurrentTimer;
    //HANDLE m_hCompletionEvent;
    long m_lRef;
    BOOL m_bInit;

    typedef std::map<WString, CHierarchyCache*, WSiless> TMap;
    typedef TMap::iterator TIterator;

    TMap m_map;
    bool m_bAssertedInTransaction;

public:
    CForestCache() : m_dwMaxMemory(0xFFFFFFFF), m_dwTotalMemory(0),
        m_pMostRecentlyUsed(NULL), m_pLeastRecentlyUsed(NULL),
        m_dwMaxAgeMs(0), m_hCurrentTimer(NULL),
        m_lRef(1), m_bInit(FALSE), m_bAssertedInTransaction(false)
    {
    }

    ~CForestCache();
    HRESULT Initialize();
    HRESULT Deinitialize();    

    void SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs);
    bool MakeRoom(DWORD dwSize);
    bool Flush();
    void MakeMostRecentlyUsed(CClassRecord* pRecord);
    void Add(CClassRecord* pRecord);
    void RemoveRecord(CClassRecord* pRecord);
    void BeginTransaction();
    bool MarkAsserted(CHierarchyCache* pCache, LPCWSTR wszClassName);
    void CommitTransaction();
    void AbortTransaction();

public:
    CHierarchyCache* GetNamespaceCache(LPCWSTR wszNamespace);
    void ReleaseNamespaceCache(LPCWSTR wszNamespace, CHierarchyCache* pCache);
    long AddRef() {  return InterlockedIncrement(&m_lRef);}
    long Release() { long lRet = InterlockedDecrement(&m_lRef);  if (!lRet) delete this; return lRet;}

protected:	
    CCritSec* GetLock() {return &m_cs;}
	bool Test();	
	void Untie(CClassRecord* pRecord);
    void Clear();
    void TimerCallback();
    static void staticTimerCallback(VOID* pParam, BOOLEAN);
    friend class CHierarchyCache;
};
    
    
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\index.cpp ===
//***************************************************************************
//
//  (c) 2000-2001 by Microsoft Corp.  All Rights Reserved.
//
//  INDEX.CPP
//
//  24-Oct-00   raymcc      Integration layer to disk-based B-Tree
//
//***************************************************************************

#include <wbemcomn.h>
#include <reposit.h>
#include "a51tools.h"
#include "index.h"

#include "btr.h"

//***************************************************************************
//
//***************************************************************************
//
//#define DEBUG

static CFlexArray g_aIterators;

class CIteratorBatch
{
    CFlexArray m_aStrings;
    BOOL  m_bDone;
    DWORD m_dwCursor;

public:
    CIteratorBatch();
   ~CIteratorBatch();
    BOOL Purge(LPSTR pszTarget);
    BOOL Add(LPSTR pszSrc);    // Acquires memory
    void SetDone() { m_bDone = TRUE; }
    BOOL Next(LPSTR *pString);
    static DWORD PurgeAll(LPSTR pszDoomed);
};

//***************************************************************************
//
//  CIteratorBatch::PurgeAll
//
//
//  Purges all iterators of a particular string.  This happens when
//  a DeleteKey succeeds while there are outstanding enumerators; we want
//  to remove the key from all enumerators so that deleted objects
//  are not reported.
//
//  This is required because the enumerators do "prefetch" and may
//  have been invoked considerably in advance of the delete
//
//  Assumes prior concurrency control.
//
//***************************************************************************
// ok
DWORD CIteratorBatch::PurgeAll(LPSTR pszDoomed)
{
    DWORD dwTotal = 0;
    for (int i = 0; i < g_aIterators.Size(); i++)
    {
        CIteratorBatch *p = (CIteratorBatch *) g_aIterators[i];
        BOOL bRes = p->Purge(pszDoomed);
        if (bRes)
            dwTotal++;
    }
    return dwTotal;
}

//***************************************************************************
//
//  CIteratorBatch::CIteratorBatch
//
//***************************************************************************
// ok
CIteratorBatch::CIteratorBatch()
{
    m_bDone = FALSE;
    m_dwCursor = 0;
    g_aIterators.Add(this);
}

//***************************************************************************
//
//  CIteratorBatch::Add
//
//  Adds a string to the enumerator.
//
//***************************************************************************
//
BOOL CIteratorBatch::Add(LPSTR pszSrc)
{
    int nRes = m_aStrings.Add(pszSrc);
    if (nRes)
        return FALSE;
    return TRUE;
}


//***************************************************************************
//
//  CIteratorBatch::~CIteratorBatch
//
//  Removes all remaining strings and deallocates them and removes
//  this iterator from the global list.
//
//  Assumes prior concurrency control.
//
//***************************************************************************
//
CIteratorBatch::~CIteratorBatch()
{
    for (int i = 0; i < m_aStrings.Size(); i++)
    {
        _BtrMemFree(m_aStrings[i]);
    }

    for (i = 0; i < g_aIterators.Size(); i++)
    {
        if (g_aIterators[i] == this)
        {
            g_aIterators.RemoveAt(i);
            break;
        }
    }
}

//***************************************************************************
//
//  CIteratorBatch::Purge
//
//  Removes a specific string from the enumerator.  Happens when a concurrent
//  delete succeeds; we have to remove the deleted key from the enumeration
//  for result set coherence.
//
//  Assumes prior concurrency control.
//
//  Returns FALSE if the string was not removed, TRUE if it was.  The
//  return value is mostly a debugging aid.
//
//***************************************************************************
// ok
BOOL CIteratorBatch::Purge(
    LPSTR pszTarget
    )
{
    int nSize = m_aStrings.Size();

    if (nSize == 0)
        return FALSE;

    // First, check the first/last strings against
    // the first character of the target.  We can
    // avoid a lot of strcmp calls if the target
    // is lexcially outside the range of the contents of
    // the enumerator.
    // ==================================================

    LPSTR pszFirst = (LPSTR) m_aStrings[0];
    LPSTR pszLast = (LPSTR) m_aStrings[nSize-1];
    if (*pszTarget > *pszLast)
        return FALSE;
    if (*pszTarget < *pszFirst)
        return FALSE;

    // If here, there is a chance that we have the
    // string in the enumerator. Since all keys are
    // retrieved in lexical order, a simple binary
    // search is all we need.
    // =============================================

    int nPosition = 0;
    int l = 0, u = nSize - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        // m is the current key to consider 0...n-1

        LPSTR pszCandidate = (LPSTR) m_aStrings[m];
        int nRes = strcmp(pszTarget, pszCandidate);

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Zap it and return!
            // ================================================

            _BtrMemFree(pszCandidate);
            m_aStrings.RemoveAt(m);
            return TRUE;
        }
    }

    return FALSE;
}



//***************************************************************************
//
//  CIteratorBatch::Next
//
//  Returns the next string from the enumeration prefetch.
//
//***************************************************************************
//
BOOL CIteratorBatch::Next(LPSTR *pMem)
{
    if (m_aStrings.Size())
    {
        *pMem = (LPSTR) m_aStrings[0];
        m_aStrings.RemoveAt(0);
        return TRUE;
    }
    return FALSE;
}



//***************************************************************************
//
//  CBtrIndex::CBtrIndex
//
//***************************************************************************
//
CBtrIndex::CBtrIndex()
{
    m_dwPrefixLength = 0;
    InitializeCriticalSection(&m_cs);
}


//***************************************************************************
//
//  CBtrIndex::~CBtrIndex
//
//***************************************************************************
//
CBtrIndex::~CBtrIndex()
{
    Shutdown(WMIDB_SHUTDOWN_NET_STOP);
    DeleteCriticalSection(&m_cs);
}

long CBtrIndex::Shutdown(DWORD dwShutDownFlags)
{
    long lRes;

    lRes = bt.Shutdown(dwShutDownFlags);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = ps.Shutdown(dwShutDownFlags);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBtrIndex::Initialize
//
//***************************************************************************
//
long CBtrIndex::Initialize(DWORD dwPrefixLength, LPCWSTR wszRepositoryDir
#ifdef A51_STAGE_BELOW_INDEX
                            , CAbstractFileSource* pSource
#endif
)
{
    // Initialize the files in question and map BTree into it.
    // =======================================================

    wchar_t buf[MAX_PATH];
    wcscpy(buf, wszRepositoryDir);
    wcscat(buf, L"\\index.btr");

    DWORD dwRes = ps.Init(8192, buf
#ifdef A51_STAGE_BELOW_INDEX
                        , pSource
#endif
                        );
    dwRes |= bt.Init(&ps);

    m_dwPrefixLength = dwPrefixLength;

    return long(dwRes);
}


//***************************************************************************
//
//   CBtrIndex::Create
//
//***************************************************************************
//
long CBtrIndex::Create(LPCWSTR wszFileName)
{
    DWORD dwRes;

    if (wszFileName == 0)
        return ERROR_INVALID_PARAMETER;

    wszFileName += m_dwPrefixLength;

    // DEBUG
#ifdef DEBUG
    FILE *f = fopen("c:\\temp\\index.log","at");
    if (f)
    {
        fprintf(f, "Index::Create =<%S>\n", wszFileName);
        fclose(f);
    }
#endif
    // END DEBUG


    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszFileName) + 1];
    if (pAnsi == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPCWSTR pSrc = wszFileName;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    EnterCriticalSection(&m_cs);

    try
    {
        dwRes = bt.InsertKey(pAnsi, 0);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    LeaveCriticalSection(&m_cs);

    delete [] pAnsi;

    if (dwRes == ERROR_ALREADY_EXISTS)
        dwRes = NO_ERROR;

    return long(dwRes);
}

//***************************************************************************
//
//  CBtrIndex::Delete
//
//  Deletes a key from the index
//
//***************************************************************************
//
long CBtrIndex::Delete(LPCWSTR wszFileName)
{
    DWORD dwRes = 0;

    wszFileName += m_dwPrefixLength;

    // DEBUG Code
#ifdef DEBUG
    FILE *f = fopen("c:\\temp\\index.log","at");
    if (f)
    {
        fprintf(f, "Index::Delete =<%S>\n", wszFileName);
        fclose(f);
    }
    // END DEBUG Code
#endif

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszFileName) + 1];
    if (pAnsi == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPCWSTR pSrc = wszFileName;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    EnterCriticalSection(&m_cs);

    try
    {
        dwRes = bt.DeleteKey(pAnsi);
        if (dwRes == 0)
            CIteratorBatch::PurgeAll(pAnsi);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    LeaveCriticalSection(&m_cs);

    delete pAnsi;

    return long(dwRes);
}

//***************************************************************************
//
//  CBtrIndex::CopyStringToWIN32_FIND_DATA
//
//  Does an ANSI to UNICODE convert for the key string.
//
//***************************************************************************
//
BOOL CBtrIndex::CopyStringToWIN32_FIND_DATA(
    LPSTR pszKey,
    WIN32_FIND_DATAW* pfd
    )
{
    LPSTR pszSuffix = pszKey + strlen(pszKey) - 1;
    while (pszSuffix[-1] != '\\' && pszSuffix > pszKey)
    {
        pszSuffix--;
    }

    // If here, a clean match.
    // =======================

    LPWSTR pszDest = pfd->cFileName;
    while (*pszSuffix)
        *pszDest++ = (wchar_t) *pszSuffix++;
    *pszDest = 0;

    return TRUE;
}


//***************************************************************************
//
//  CBtrIndex::FindFirst
//
//  Starts an enumeration
//
//***************************************************************************
//
long CBtrIndex::FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    DWORD dwRes;
    wszPrefix += m_dwPrefixLength;

    if(ppHandle)
        *ppHandle = INVALID_HANDLE_VALUE;

    pfd->cFileName[0] = 0;
    pfd->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    // DEBUG
#ifdef DEBUG
    FILE *f = fopen("c:\\temp\\index.log","at");
    if (f)
    {
        fprintf(f, "Index::FindFirst Request Prefix=<%S>\n", wszPrefix);
        fclose(f);
    }
    // END DEBUG
#endif

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszPrefix) + 1];
    if (pAnsi == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CVectorDeleteMe<char> vdm(pAnsi);

    LPCWSTR pSrc = wszPrefix;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    // Critical-section blocked.
    // =========================

    EnterCriticalSection(&m_cs);

    CBTreeIterator *pIt = new CBTreeIterator;
    if (!pIt)
    {
        LeaveCriticalSection(&m_cs);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    try
    {
        dwRes = pIt->Init(&bt, pAnsi);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    if (dwRes)
    {
        pIt->Release();
        LeaveCriticalSection(&m_cs);
        return ERROR_FILE_NOT_FOUND;
    }

    // Create CIteratorBatch.
    // ======================

    CIteratorBatch *pBatch = new CIteratorBatch;

    if (pBatch == 0)
    {
        pIt->Release();
        LeaveCriticalSection(&m_cs);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Iterate and fill batcher.
    // =========================

    LPSTR pszKey = 0;
    int nMatchLen = strlen(pAnsi);

    for (;;)
    {
        dwRes = pIt->Next(&pszKey);
        
        if (dwRes)
            break;

        // See if prefix matches.

        if (strncmp(pAnsi, pszKey, nMatchLen) != 0)
        {
            pIt->FreeString(pszKey);
            pBatch->SetDone();
            break;
        }
        pBatch->Add(pszKey);
    }

    pIt->Release();

    long lRes = FindNext(pBatch, pfd);

    if (lRes == ERROR_NO_MORE_FILES)
        lRes = ERROR_FILE_NOT_FOUND;

    if (lRes == NO_ERROR)
    {
        if(ppHandle)
        {
            *ppHandle = (LPVOID *) pBatch;
        }
        else
        {
            //
            // Only asked for one --- close handle
            //

            delete pBatch;
        }
    }
    else
    {
        delete pBatch;
    }

    LeaveCriticalSection(&m_cs);

    return lRes;
}

//***************************************************************************
//
//  CBtrIndex::FindNext
//
//  Continues an enumeration.  Reads from the prefetch buffer.
//
//***************************************************************************
//
long CBtrIndex::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    LPSTR pszString = 0;
    BOOL bRes;

    if (pHandle == 0 || pfd == 0 || pHandle == INVALID_HANDLE_VALUE)
        return ERROR_INVALID_PARAMETER;

    EnterCriticalSection(&m_cs);
    CIteratorBatch *pBatch = (CIteratorBatch *) pHandle;
    bRes = pBatch->Next(&pszString);
    LeaveCriticalSection(&m_cs);

    if (bRes == FALSE)
        return ERROR_NO_MORE_FILES;

    CopyStringToWIN32_FIND_DATA(pszString, pfd);
    pfd->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    if (pszString)
       _BtrMemFree(pszString);

#ifdef DEBUG
    FILE *f = fopen("c:\\temp\\index.log","at");
    if (f)
    {
        fprintf(f, "Index::Find Return ------------------> =<%S>\n", pfd->cFileName);
        fclose(f);
    }
#endif

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBtrIndex::FindClose
//
//  Closes an enumeration by deleting the 'hidden' pointer.
//
//***************************************************************************
//  ok
long CBtrIndex::FindClose(void* pHandle)
{
    if (pHandle == 0 || pHandle == INVALID_HANDLE_VALUE)
        return NO_ERROR;

    EnterCriticalSection(&m_cs);
    delete (CIteratorBatch *) pHandle;
    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;
}

long CBtrIndex::InvalidateCache()
{
#ifdef DEBUG
    FILE *f = fopen("c:\\temp\\index.log","at");
    if (f)
    {
        fprintf(f, "*** INVALIDATE CACHE OPERATION\n");
        fclose(f);
    }
#endif

    EnterCriticalSection(&m_cs);

    //
    // Re-read the admin page from disk.  NOTE: this will need changing if more
    // caching is added!
    //

    DWORD dwRes = ps.ReadAdminPage();
    if (dwRes == NO_ERROR)
        dwRes = bt.InvalidateCache();

    LeaveCriticalSection(&m_cs);
    return long(dwRes);
}




/*
tbd:
(1) Multiple reader / single writer lock

(2) Purge improvements: read-ahead

(3) Macro for tracking checkpoint of mem allocs

(4) page cache hit tracker

Mechanical
(5) Mem leak
(6) Realloc crash
(7) Failure during enum init
(8) Substantial delete test; run stress & try to clean up afterwards
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\lock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.CPP

Abstract:

    Implements the generic class for obtaining read and write locks to some 
    resource. 

    See lock.h for all documentation.

    Classes defined:

    CLock

History:

    a-levn  5-Sept-96       Created.
    3/10/97     a-levn      Fully documented

--*/

#include "precomp.h"
#include <stdio.h>
#include "lock.h"
#include <stdio.h>

// debugging.
#define PRINTF

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

CLock::CLock() : m_nReading(0), m_nWriting(0), m_nWaitingToRead(0),
            m_nWaitingToWrite(0)
{
    // Initialize the critical sections
    // ================================

    InitializeCriticalSection(&m_csAll);
    InitializeCriticalSection(&m_csEntering);

    // Create unnamed events for reading and writing
    // =============================================

    m_hCanRead = CreateEvent(NULL, TRUE, TRUE, NULL);
    m_hCanWrite = CreateEvent(NULL, TRUE, TRUE, NULL);
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
CLock::~CLock()
{
    CloseHandle(m_hCanWrite);
    CloseHandle(m_hCanRead);
    DeleteCriticalSection(&m_csAll);
    DeleteCriticalSection(&m_csEntering);
}

BOOL CLock::IsHoldingReadLock()
{
    // Check if this thread already owns this lock
    // ===========================================

    EnterCriticalSection(&m_csAll);
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if(dwThreadId == (DWORD_PTR)m_adwReaders[i])
        {
            LeaveCriticalSection(&m_csAll);
            return TRUE;
        }
    }

    LeaveCriticalSection(&m_csAll);
    return FALSE;
}
    

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
int CLock::ReadLock(DWORD dwTimeout)
{
    PRINTF("%d wants to read\n", GetCurrentThreadId());

    // Check if this thread already owns this lock
    // ===========================================

    EnterCriticalSection(&m_csAll);
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if(dwThreadId == (DWORD_PTR)m_adwReaders[i])
        {
            // We already have it --- add it to the list and return
            // ====================================================

            m_adwReaders.Add((void*)dwThreadId);
            m_nReading++;
            LeaveCriticalSection(&m_csAll);
            return NoError;
        }
    }

    // Don't have it already
    // =====================
        
    LeaveCriticalSection(&m_csAll);

    // Get in line for getting any kind of lock (those unlocking don't go into
    // this line)
    // =======================================================================

    EnterCriticalSection(&m_csEntering);

    // We are the only ones allowed to get any kind of lock now. Wait for the
    // event indicating that reading is enabled to become signaled
    // ======================================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());
    if(m_nWriting != 0)
    {
        int nRes = WaitFor(m_hCanRead, dwTimeout);
        if(nRes != NoError)
        {
            LeaveCriticalSection(&m_csEntering);
            return nRes;
        }
    }

    // Enter inner critical section (unlockers use it too), increment the
    // number of readers and disable writing.
    // ==================================================================

    PRINTF("%d got event\n", GetCurrentThreadId());
    EnterCriticalSection(&m_csAll);
    m_nReading++;
    m_adwReaders.Add((void*)dwThreadId);
    PRINTF("Reset write\n");
    ResetEvent(m_hCanWrite);
    PRINTF("Done\n");

    // Get out of all critical sections and return
    // ===========================================

    LeaveCriticalSection(&m_csAll);
    LeaveCriticalSection(&m_csEntering);
    PRINTF("%d begins to read\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::ReadUnlock()
{
    PRINTF("%d wants to unlock reading\n", GetCurrentThreadId());

    // Enter internal ciritcal section and decrement the number of readers
    // ===================================================================

    EnterCriticalSection(&m_csAll);

    m_nReading--;
    if(m_nReading < 0) return Failed;

    // Remove it from the list of threads
    // ==================================

    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < m_adwReaders.Size(); i++)
    {
        if((DWORD_PTR)m_adwReaders[i] == dwThreadId)
        {
            m_adwReaders.RemoveAt(i);
            break;
        }
    }

    // If all reasders are gone, allow writers in
    // ==========================================

    if(m_nReading == 0)
    {
            PRINTF("%d is the last reader\n", GetCurrentThreadId());
            PRINTF("Set write\n");
            if(!SetEvent(m_hCanWrite))
            {
                    LeaveCriticalSection(&m_csAll);
                    return Failed;
            }
            PRINTF("Done\n");
    }
    else PRINTF("%d sees %d still reading\n", GetCurrentThreadId(), m_nReading);

    // Get out and return
    // ==================

    LeaveCriticalSection(&m_csAll);
    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteLock(DWORD dwTimeout)
{
    PRINTF("%d wants to write\n", GetCurrentThreadId());

    // Get in line for getting any kind of lock. Those unlocking don't use this
    // critical section.
    // ========================================================================

    EnterCriticalSection(&m_csEntering);

    // We are the only ones allowed to get any kind of lock now
    // ========================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());

    // Wait for the event allowing writing to become signaled
    // ======================================================

    int nRes = WaitFor(m_hCanWrite, dwTimeout);
    PRINTF("%d got event\n", GetCurrentThreadId());
    if(nRes != NoError)
    {
            LeaveCriticalSection(&m_csEntering);
            return nRes;
    }

    // Enter internal critical section (unlockers use it too), increment the
    // number of writers (from 0 to 1) and disable both reading and writing
    // from now on.
    // ======================================================================

    EnterCriticalSection(&m_csAll);
    m_nWriting++;
    PRINTF("Reset both\n");
    ResetEvent(m_hCanWrite);
    ResetEvent(m_hCanRead);
    PRINTF("Done\n");

    // Get out and return
    // ==================

    LeaveCriticalSection(&m_csAll);
    LeaveCriticalSection(&m_csEntering);
    PRINTF("%d begins to write\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteUnlock()
{
    PRINTF("%d wants to release writing\n", GetCurrentThreadId());

    // Enter lock determination critical section
    // =========================================

    EnterCriticalSection(&m_csAll);

    m_nWriting--;
    if(m_nWriting < 0) return Failed;

    // Allow readers and writers in
    // ============================

    PRINTF("%d released writing\n", GetCurrentThreadId());

    PRINTF("Set both\n");
    if(!SetEvent(m_hCanRead))
    {
            LeaveCriticalSection(&m_csAll);
            return Failed;
    }
    else if(!SetEvent(m_hCanWrite))
    {
            LeaveCriticalSection(&m_csAll);
            return Failed;
    }
    else
    {
            PRINTF("Done\n");
            LeaveCriticalSection(&m_csAll);
            return NoError;
    }
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::DowngradeLock()
{
    // Enter lock determination critical section
    // =========================================

    EnterCriticalSection(&m_csAll);

    if(!SetEvent(m_hCanRead))
    {
        LeaveCriticalSection(&m_csAll);
        return Failed;
    }

    m_nReading++;

    LeaveCriticalSection(&m_csAll);

    return NoError;
}
    
    
    
//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WaitFor(HANDLE hEvent, DWORD dwTimeout)
{
    DWORD dwRes;
    dwRes = WaitForSingleObject(hEvent, dwTimeout);

    // Analyze the error code and convert to ours
    // ==========================================

    if(dwRes == WAIT_OBJECT_0) return NoError;
    else if(dwRes == WAIT_TIMEOUT) return TimedOut;
    else return Failed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\index.h ===
#ifndef __A51_INDEX__H_
#define __A51_INDEX__H_

#include "heap.h"

#include "btr.h"

class CAbstractIndex
{
public:
    virtual ~CAbstractIndex(){}

    virtual long Create(LPCWSTR wszFileName) = 0;
    virtual long Delete(LPCWSTR wszFileName) = 0;
    virtual long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle) = 0;
    virtual long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd) = 0;
    virtual long FindClose(void* pHandle) = 0;
};


typedef DWORD TDirectoryId;

#define ROSWELL_MAX_COMPONENT_LENGTH 50
#define ROSWELL_MAX_PREFIX_LENGTH ROSWELL_MAX_COMPONENT_LENGTH

struct CFileKey
{
    TDirectoryId m_nDirectoryId;
    char m_szComponentName[ROSWELL_MAX_COMPONENT_LENGTH];
};

struct CFileValue
{
    TDirectoryId m_nId;
    TOffset m_nOffset;
    DWORD m_dwLength;
};

class CFileKeyCompare
{
public:
    bool operator()(const CFileKey& keyFirst, const CFileKey& keySecond) const
    {
        if(keyFirst.m_nDirectoryId != keySecond.m_nDirectoryId)
            return (keyFirst.m_nDirectoryId < keySecond.m_nDirectoryId);
        else
            return (strcmp(keyFirst.m_szComponentName,
                            keySecond.m_szComponentName) < 0);
    }
};

class CIndex : public CAbstractIndex
{
public:
    CFileHeap* m_pHeap;
    CCritSec m_cs;
    DWORD m_dwPrefixLength;
    TDirectoryId m_nNextId;

    typedef std::map<CFileKey, CFileValue, CFileKeyCompare> TDirectoryMap;
    typedef TDirectoryMap::iterator TDirectoryIterator;
    TDirectoryMap m_map;

public:
    CIndex(CFileHeap* pHeap)
        : m_pHeap(pHeap), m_nNextId(1), m_dwPrefixLength(0)
    {}

    long Initialize(DWORD dwPrefixLength);
    long Create(LPCWSTR wszFileName);
    long Delete(LPCWSTR wszFileName);
    long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    long FindClose(void* pHandle);

protected:
    long ConvertInputToAscii(LPCWSTR wszFileName, char* szFileName);
    long CreateRecord(TDirectoryId nParentId, char* szComponentName,
                            TDirectoryId* pnChildId);
    TDirectoryId GetNewDirectoryId();

    friend class CIndexIterator;
};

class CIndexIterator
{
protected:
    CIndex::TDirectoryMap& m_rMap;
    CIndex::TDirectoryIterator m_it;
    TDirectoryId m_nParentId;
    char m_szPrefix[ROSWELL_MAX_PREFIX_LENGTH];
    long m_lPrefixLen;

public:
    CIndexIterator(TDirectoryId nParentId, char* szPrefix,
                    CIndex::TDirectoryIterator it, CIndex::TDirectoryMap& rMap);
    long FindNext(WIN32_FIND_DATAW* pfd);
};

class COldIndex : public CAbstractIndex
{
public:
    COldIndex(CFileHeap* pHeap){}

    long Initialize(bool bNewFile, DWORD dwPrefixLength);
    long Create(LPCWSTR wszFileName);
    long Delete(LPCWSTR wszFileName);
    long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    long FindClose(void* pHandle);
};

class CBtrIndex : public CAbstractIndex
{
    DWORD m_dwPrefixLength;
    CRITICAL_SECTION m_cs;
    CBTree bt;
    CPageSource ps;

    BOOL CopyStringToWIN32_FIND_DATA(
        LPSTR pszSource,
        WIN32_FIND_DATAW* pfd
        );

public:
    CBtrIndex();
   ~CBtrIndex();

    long Shutdown(DWORD dwShutDownFlags);

    long Initialize(DWORD dwPrefixLength, LPCWSTR wszRepositoryDir, 
                    CAbstractFileSource* pSource );
    long Create(LPCWSTR wszFileName);
    long Delete(LPCWSTR wszFileName);
    long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    long FindClose(void* pHandle);

    long InvalidateCache();

    CBTree& GetTree() {return bt;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\repositorypackager.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.h

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#ifndef __REPOSITORYPACKAGER_H_
#define __REPOSITORYPACKAGER_H_

#define PACKAGE_TYPE_NAMESPACE_START	1
#define PACKAGE_TYPE_NAMESPACE_END		2
#define PACKAGE_TYPE_FILE				3
#define PACKAGE_TYPE_END_OF_FILE		4

typedef struct _PACKAGE_HEADER
{
	char szSignature[10];
} PACKAGE_HEADER;

typedef struct _PACKAGE_SPACER
{
	DWORD dwSpacerType;
} PACKAGE_SPACER;

typedef struct _PACKAGER_SPACER_NAMESPACE : _PACKAGE_SPACER
{
	wchar_t wszNamespaceName[MAX_PATH+1];
} PACKAGE_SPACER_NAMESPACE;

typedef struct _PACKAGER_SPACER_FILE : _PACKAGE_SPACER
{
	wchar_t wszFileName[MAX_PATH+1];
	DWORD dwFileSize;
} PACKAGE_SPACER_FILE;

class CRepositoryPackager
{
    wchar_t m_wszFileToProcess[MAX_PATH+1];
private:
	HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	
	HRESULT PackageHeader(HANDLE hFile);
	HRESULT PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);
	HRESULT PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename);
	HRESULT PackageTrailer(HANDLE hFile);
	
	HRESULT UnPackageHeader(HANDLE hFile);
	HRESULT UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory);
	HRESULT UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory);

	HRESULT DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);

public:
	CRepositoryPackager() {}
	~CRepositoryPackager() {}
	
	HRESULT PackageRepository(const wchar_t *wszFilename);
	HRESULT UnpackageRepository(const wchar_t *wszFilename);
	HRESULT DeleteRepository();
};

#endif // __REPOSITORYPACKAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\longstg.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_LONG_STAGE__H_
#define __WMI_A51_LONG_STAGE__H_

#include <queue>
#include <map>
#include <list>
#include <sync.h>
#include "a51tools.h"
#include "stagemgr.h"

#define A51_MAX_FILES 5

class CFileCache;

class CLongFileStagingFile;

struct CFileLocation
{
    int m_nFileId;
    TFileOffset m_lStartOffset;

    CFileLocation() : m_nFileId(0), m_lStartOffset(0)
    {}
    CFileLocation(int nFileId, TFileOffset lStartOffset)
        : m_nFileId(nFileId), m_lStartOffset(lStartOffset)
    {}
};
    
class CLongFileInstruction : public CStageInstruction
{
protected:
    CFileLocation m_Location;

public:
    CLongFileInstruction(CLongFileStagingFile* pFile);
    CLongFileInstruction(CLongFileStagingFile* pFile, int nFileId, 
            TFileOffset lStartOffset);
    virtual ~CLongFileInstruction(){}

    virtual bool IsWrite() = 0;
    virtual void Dump();
protected:
    BYTE* WriteLocation(BYTE* pBuffer);
    DWORD ComputeSpaceForLocation();
    long RecoverLocation(HANDLE hFile);

    friend class CLongFileStagingFile;
};

class CWriteFileInstruction : public CLongFileInstruction
{
protected:
    DWORD m_dwLen;
    __int64 m_lZOrder;
    
    static __int64 mstatic_lNextZOrder;

	bool m_bReuse;

public:
    CWriteFileInstruction(CLongFileStagingFile* pFile)
        : CLongFileInstruction(pFile), m_dwLen(0), 
            m_lZOrder(mstatic_lNextZOrder++), m_bReuse(false)
    {
    }
    CWriteFileInstruction(CLongFileStagingFile* pFile, int nFileId, 
            TFileOffset lStartOffset, DWORD dwLen)
        : CLongFileInstruction(pFile, nFileId, lStartOffset),
            m_dwLen(dwLen), m_lZOrder(mstatic_lNextZOrder++), m_bReuse(false)
    {
    }
    virtual ~CWriteFileInstruction(){}
    bool IsWrite() {return true;}

    virtual void Dump();
    virtual long Execute();
    virtual long RecoverData(HANDLE hFile);

	void MakeTopmost();

	void SetReuseFlag() { m_bReuse = true; }

public:
    long Write(TFileOffset lOffset, BYTE* pBuffer);

    DWORD ComputeNeededSpace();
    void GetEnd(CFileLocation* pLocation);
    long GetData(HANDLE hFile, long lExtraOffset, DWORD dwLen, BYTE* pBuffer);
    TFileOffset ComputeOriginalOffset();

    friend class CLongFileStagingFile;
};

class CSetEndOfFileInstruction : public CLongFileInstruction
{
public:
    CSetEndOfFileInstruction(CLongFileStagingFile* pFile)
        : CLongFileInstruction(pFile)
    {}

    CSetEndOfFileInstruction(CLongFileStagingFile* pFile, int nFileId, 
                                TFileOffset lLength)
        : CLongFileInstruction(pFile, nFileId, lLength)
    {}

    virtual ~CSetEndOfFileInstruction(){}
    bool IsWrite() {return false;}

    virtual long Execute();
    virtual long RecoverData(HANDLE hFile);

public:
    long Write(TFileOffset lOffset);
    DWORD ComputeNeededSpace();

    friend class CLongFileStagingFile;
};

class CLongFileStagingFile : public CExecutableStageManager
{
    class CCompareLocations
    {
    public:
        bool operator()(const CFileLocation& loc1, 
                            const CFileLocation& loc2) const
        {
            if(loc1.m_nFileId != loc2.m_nFileId)
                return (loc1.m_nFileId < loc2.m_nFileId);
            else
                return loc1.m_lStartOffset < loc2.m_lStartOffset;
        }
    };
        
protected:
    typedef std::multimap<CFileLocation, CWriteFileInstruction*, 
                          CCompareLocations, 
                          CPrivateTempAllocator<CWriteFileInstruction*> > TMap;
    typedef TMap::iterator TIterator;
    typedef TMap::value_type TValue;
    TMap m_mapStarts;
    TMap m_mapEnds;

    struct FileInfo
    {
        HANDLE m_h;
        bool m_bSupportsOverwrites;
    } m_aFiles[A51_MAX_FILES];

public:
    CLongFileStagingFile(long lMaxFileSize = 0, 
                            long lAbortTransactionFileSize = 0);
    virtual ~CLongFileStagingFile();

public:
    long Create(LPCWSTR wszStagingFileName);
    long Initialize();
    long Uninitialize(DWORD dwShutDownFlags);

    long RegisterFile(int nFileId, HANDLE hFile, bool bSupportsOverwrites);
    long ReadFile(int nFileId, DWORD dwStartOffset, BYTE* pBuffer, DWORD dwLen,
                    DWORD* pdwRead);
    long WriteFile(int nFileId, DWORD dwStartOffset, BYTE* pBuffer, DWORD dwLen,
                    DWORD* pdwRead);
    long SetFileLength(int nFileId, DWORD dwLen);
    long GetFileLength(int nFileId, DWORD* pdwLength);
    long CloseAllFiles();
    void Dump(FILE* f);
    void FlushDataFiles();

protected:
    virtual long AddInstructionToMap(CStageInstruction* pInst,
                                CStageInstruction** ppUndoInst);
    virtual long RemoveInstructionFromMap(CStageInstruction* pInst);
    virtual long ConstructInstructionFromType(int nType, 
                                CStageInstruction** ppInst);
    virtual bool IsStillCurrent(CStageInstruction* pInst);
    
    bool DoesSupportOverwrites(int nFileId);

    virtual long WriteEmpty();
    bool InjectFailure();

protected: // for instructions
    long WriteToActualFile(int nFileId, TFileOffset lFileOffset, BYTE* pBuffer, 
                            DWORD dwLen);
    long SetEndOfActualFile(int nFileId, TFileOffset lFileLength);

    friend class CWriteFileInstruction;
    friend class CSetEndOfFileInstruction;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <time.h>
#include <a51rep.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

DEFINE_GUID(CLSID_A51Repository, 
0x7998dc37, 0xd3fe, 0x487c, 0xa6, 0x0a, 0x77, 0x01, 0xfc, 0xc7, 0x0c, 0xc6);

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_A51Repository, 
            new CSimpleClassFactory<CRepository>(GetLifeControl()), 
            L"A51 Repository", TRUE);

        return S_OK;
    }

    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\objheap.h ===
#ifndef __A51_OBJHEAP__H_
#define __A51_OBJHEAP__H_

#include "heap.h"
#include "absfile.h"
#include "index.h"

//class CAbstractIndex;


class CObjectHeap
{
protected:
    BOOL      m_bInit;
    CCritSec  m_cs;
    
    CFileHeap m_Heap;
    CBtrIndex m_Index;
    // just to save universal replace
    CFileHeap * m_pHeap;
    CBtrIndex * m_pIndex;


public:
    CObjectHeap() :m_bInit(FALSE),
        m_pHeap(&m_Heap), m_pIndex(&m_Index)
    {}
    virtual ~CObjectHeap(){}

    long Initialize(CAbstractFileSource  * pAbstractSource, 
                    WCHAR * wszObjHeapName,
                    WCHAR * wszBaseName,
                    DWORD dwBaseNameLen);
                    
    long Uninitialize(DWORD dwShutDownFlags);

    void InvalidateCache();
    long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    long FindClose(void* pHandle);
        

    long WriteFile(LPCWSTR wszFilePath, DWORD dwBufferLen, BYTE* pBuffer);
    long DeleteFile(LPCWSTR wszFilePath);
    long ReadFile(LPCWSTR wszFilePath, DWORD* pdwBufferLen, BYTE** ppBuffer);
    // for the dump utility
    CBtrIndex * GetIndex(){ return m_pIndex; };
    CFileHeap * GetFileHeap(){ return m_pHeap; };
    

protected:
    long GetIndexFileName(LPCWSTR wszFilePath, LPWSTR wszIndexFileName);
    long GetFileInfo(LPCWSTR wszFilePath, TOffset* pnOffset, DWORD* pdwLength);
    long ParseInfoFromIndexFile(LPCWSTR wszIndexFileName, 
                                        TOffset* pnOffset, DWORD* pdwLength);
    long CreateIndexFile(LPCWSTR wszFilePath, TOffset nOffset, DWORD dwLength);
    long DeleteIndexFile(LPCWSTR wszFilePath, LPCWSTR wszIndexFileName);
    long CreateZeroLengthFile(LPCWSTR wszFilePath);
    long DeleteZeroLengthFile(LPCWSTR wszFilePath);
    DWORD GetAllocationHeaderLength();
    long WriteAllocation(TOffset nOffset, DWORD dwDataLength, BYTE* pData);
    long ReadAllocation(TOffset nOffset, DWORD dwDataLength, BYTE* pBuffer);
};

    

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\longstg.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include <reposit.h>
#include <sync.h>
#include <malloc.h>
#include "longstg.h"


#define A51_INSTRUCTION_TYPE_WRITEFILE 1
#define A51_INSTRUCTION_TYPE_SETENDOFFILE 2

CTempMemoryManager g_LongFileCacheManager;

__int64 CWriteFileInstruction::mstatic_lNextZOrder = 0;

DWORD g_dwFailureCount = 0;
DWORD g_dwFailureFrequency = 0;
DWORD g_dwLastFailureCheck = 0;
#define FAILURE_INJECTION_CHECK_INTERVAL 10000

CLongFileInstruction::CLongFileInstruction(CLongFileStagingFile* pFile) 
    : CStageInstruction(pFile)
{
}

CLongFileInstruction::CLongFileInstruction(CLongFileStagingFile* pFile, 
                int nFileId, TFileOffset lStartOffset)
    : CStageInstruction(pFile), m_Location(nFileId, lStartOffset)
{
}


DWORD CLongFileInstruction::ComputeSpaceForLocation()
{
    return (sizeof(BYTE) + sizeof(m_Location.m_lStartOffset));
}

long CLongFileInstruction::RecoverLocation(HANDLE hFile)
{
    DWORD dwRead;

    BYTE nFileId;
    if(!ReadFile(hFile, &nFileId, sizeof(BYTE), &dwRead, NULL))
        return GetLastError();

    m_Location.m_nFileId = nFileId;

    if(!ReadFile(hFile, (BYTE*)&m_Location.m_lStartOffset, 
                    sizeof m_Location.m_lStartOffset, &dwRead, NULL))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

BYTE* CLongFileInstruction::WriteLocation(BYTE* pBuffer)
{
    *pBuffer = (BYTE)m_Location.m_nFileId;
    memcpy(pBuffer + 1, (BYTE*)&m_Location.m_lStartOffset, 
            sizeof m_Location.m_lStartOffset);
    return pBuffer + 1 + sizeof m_Location.m_lStartOffset;
}

void CLongFileInstruction::Dump()
{
    ERRORTRACE((LOG_WBEMCORE, "File %d, Start %d, stage offset %d\n",
                    (int)m_Location.m_nFileId, (int)m_Location.m_lStartOffset,
                    (int)m_lStageOffset));
}

void CWriteFileInstruction::Dump()
{
    ERRORTRACE((LOG_WBEMCORE, "File %d, Start %d, Len %d, stage offset %d\n",
                    (int)m_Location.m_nFileId, (int)m_Location.m_lStartOffset,
                    (int)m_dwLen, (int)m_lStageOffset));
}
void CWriteFileInstruction::MakeTopmost()
{
	m_lZOrder = mstatic_lNextZOrder++;
}
DWORD CWriteFileInstruction::ComputeNeededSpace()
{
	if (!m_bReuse)
		return sizeof(BYTE) + // for the type
					ComputeSpaceForLocation() + 
					sizeof(DWORD) + // for the length of data
					m_dwLen + // for the data
					A51_TAIL_SIZE; // for the trailer
	else
		return sizeof(BYTE) + // for the type
					ComputeSpaceForLocation() + 
					sizeof(DWORD) + // for the length of data
					m_dwLen;  // for the data
					//NO TAIL if we are re-using the old write instruction as they are overwritten
					//by next instruction in log
}

TFileOffset CWriteFileInstruction::ComputeOriginalOffset()
{
    return m_lStageOffset - sizeof(BYTE) - ComputeSpaceForLocation() - 
            sizeof(DWORD);
}
                    
long CWriteFileInstruction::Write(TFileOffset lOffset, BYTE* pBuffer)
{
    _ASSERT(m_Location.m_lStartOffset >= 0 && m_Location.m_lStartOffset < 0x70000000, L"");

    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_WRITEFILE;
    pCurrent++;

    //
    // Write location
    //

    pCurrent = WriteLocation(pCurrent);

    //
    // Write the length of the data for the file
    //

    memcpy(pCurrent, (void*)&m_dwLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    //
    // Write the data itself and record its offset
    //

    memcpy(pCurrent, pBuffer, m_dwLen);
    m_lStageOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer - only if this is an original instruction.  In the
	// case of a reused instruction we ignore the tail because it had already
	// (probably) been overwritten
    //

	if (!m_bReuse)
		memset(pCurrent + m_dwLen, 0, sizeof(DWORD));
    
    // 
    // Write it 
    //

    return m_pManager->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace, m_bReuse);
}

long CWriteFileInstruction::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name first
    //

    long lRes = RecoverLocation(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the length of the data from the file
    //

    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&m_dwLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // We do not need to actually read the data from the file --- we keep it
    // there until it is time to flush.  But we do need to skip it.  At the same
    // time, we need to record the position in the file where this data resides
    //

    LARGE_INTEGER liFileLen;
    liFileLen.QuadPart = m_dwLen;
    
    LARGE_INTEGER liNewPosition;
    if(!SetFilePointerEx(hFile, liFileLen, &liNewPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liNewPosition.HighPart == 0, L"Staging file too long!");

    m_lStageOffset = (long)(liNewPosition.QuadPart - m_dwLen);
    return ERROR_SUCCESS;
}

void CWriteFileInstruction::GetEnd(CFileLocation* pLocation)
{
    pLocation->m_nFileId = m_Location.m_nFileId;
    pLocation->m_lStartOffset = m_Location.m_lStartOffset + m_dwLen - 1;
}

long CWriteFileInstruction::GetData(HANDLE hFile, long lExtraOffset, 
                                    DWORD dwLen, BYTE* pBuffer)
{
	//
	// Lock the file
	//

	CInCritSec ics(m_pManager->GetLock());

	_ASSERT(m_pManager->GetFirstFreeOffset() >= m_lStageOffset, 
            L"Instruction points to empty space in stage file");

    long lRes = A51ReadFromFileSync(hFile, m_lStageOffset + lExtraOffset, 
                                    pBuffer, dwLen);
    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    return ERROR_SUCCESS;
}

    
long CWriteFileInstruction::Execute()
{
    long lRes;

    //
    // Read the data from the staging file
    //

    BYTE* pBuffer = (BYTE*)TempAlloc(m_dwLen);
    if(pBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pBuffer);

    lRes = GetData(m_pManager->GetHandle(), 0, m_dwLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = ((CLongFileStagingFile*)m_pManager)->WriteToActualFile(
                    m_Location.m_nFileId, m_Location.m_lStartOffset,
                    pBuffer, m_dwLen);
    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    return ERROR_SUCCESS;
}


DWORD CSetEndOfFileInstruction::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for instruction type
            ComputeSpaceForLocation() + 
            A51_TAIL_SIZE; // for the trailer
}

long CSetEndOfFileInstruction::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write the instruction type
    //
    
    *pCurrent = A51_INSTRUCTION_TYPE_SETENDOFFILE;
    pCurrent++;
    
    //
    // Write the file name
    //

    pCurrent = WriteLocation(pCurrent);
    m_lStageOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pManager->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CSetEndOfFileInstruction::RecoverData(HANDLE hFile)
{
    long lRes = RecoverLocation(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lStageOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CSetEndOfFileInstruction::Execute()
{
    long lRes = ((CLongFileStagingFile*)m_pManager)->SetEndOfActualFile(
                    m_Location.m_nFileId, m_Location.m_lStartOffset);
    return lRes;
}

//
//        CStageManager
//
//              |
//
//    CExecutableStageManager
//
//              |
//
//     CLongFileStagingFile
//
/////////////////////////////////////////////////////////////////////////////

CLongFileStagingFile::CLongFileStagingFile(long lMaxFileSize,
                                                long lAbortTransactionFileSize)
    : CExecutableStageManager(lMaxFileSize, lAbortTransactionFileSize),
        m_mapStarts(TMap::key_compare(), 
                        TMap::allocator_type(&g_LongFileCacheManager)),
        m_mapEnds(TMap::key_compare(), 
                        TMap::allocator_type(&g_LongFileCacheManager))
{
    for(int i = 0; i < A51_MAX_FILES; i++)
        m_aFiles[i].m_h = NULL;
}

CLongFileStagingFile::~CLongFileStagingFile()
{
}

long CLongFileStagingFile::Create(LPCWSTR wszStagingFileName)
{
   return CExecutableStageManager::Create(wszStagingFileName);
};

long CLongFileStagingFile::Initialize()
{
    CInCritSec ics(&m_cs);
    
    return CExecutableStageManager::Start();
};

long CLongFileStagingFile::Uninitialize(DWORD dwShutDownFlags)
{
    
    // do not hold the CritSec here, since the FlusherThread needs it
    
    CExecutableStageManager::Stop(dwShutDownFlags);

    CInCritSec ics(&m_cs);
    
    CloseAllFiles();

    m_mapStarts.clear();
    m_mapEnds.clear();
    
    return ERROR_SUCCESS;
};

long CLongFileStagingFile::RemoveInstructionFromMap(
                                                    CStageInstruction* pRawInst)
{
    CInCritSec ics(&m_cs);

    CLongFileInstruction* pInst = (CLongFileInstruction*)pRawInst;
    if(!pInst->IsWrite())
        return ERROR_SUCCESS;

/*
    ERRORTRACE((LOG_WBEMCORE, "Remove instruction\n"));
    pInst->Dump();
*/

    TIterator it = m_mapStarts.find(pInst->m_Location);
    while(it != m_mapStarts.end() && it->second != pInst)
        it++;

    if(it == m_mapStarts.end())
    {
        return ERROR_FILE_NOT_FOUND;
    }

    it->second->Release();
    m_mapStarts.erase(it);

    CFileLocation Location;
    ((CWriteFileInstruction*)pInst)->GetEnd(&Location);

    it = m_mapEnds.find(Location);
    while(it != m_mapEnds.end() && it->second != pInst)
        it++;

    if(it == m_mapEnds.end())
    {        
        return ERROR_FILE_NOT_FOUND;
    }

    it->second->Release();
    m_mapEnds.erase(it);

    return ERROR_SUCCESS;
}

void CLongFileStagingFile::FlushDataFiles()
{
    CInCritSec ics(&m_cs);
    for(int i = 0; i < A51_MAX_FILES; i++)
    {
        HANDLE h = m_aFiles[i].m_h;
        if(h)
        {
            FlushFileBuffers(h);
        }
    }

}
long CLongFileStagingFile::WriteFile(int nFileId, DWORD dwStartOffset, 
                                BYTE* pBuffer, DWORD dwLen, DWORD* pdwWritten)
{
    CInCritSec ics(&m_cs);
    long lRes;

#ifdef DBG
    if(InjectFailure())
    {
        ERRORTRACE((LOG_WBEMCORE, "FAIL: File %d, offset %d, len %d\n",
                    (int)nFileId, (int)dwStartOffset, (int)dwLen));
        return ERROR_SECTOR_NOT_FOUND;
    }
#endif

    if(pdwWritten)
		*pdwWritten = dwLen;

    if(DoesSupportOverwrites(nFileId))
    {
        //
        // For this file, it is considered efficient to look for another 
        // instruction within the same transaction.  It is guaranteed that 
        // writes within this file never intersect!
        //

        CFileLocation StartLocation;
        StartLocation.m_nFileId = nFileId;
        StartLocation.m_lStartOffset = (TFileOffset)dwStartOffset;
    
        CWriteFileInstruction* pLatestMatch = NULL;

        TIterator itStart = m_mapStarts.lower_bound(StartLocation);
        while(itStart != m_mapStarts.end()
                && itStart->first.m_nFileId == nFileId
                && itStart->first.m_lStartOffset == (TFileOffset)dwStartOffset)
        {
            CWriteFileInstruction* pInst = itStart->second;
            if(pInst->m_dwLen == dwLen && !pInst->IsCommitted())
            {
                //
                // Exact match. Compare to the other matches
                //

                if(pLatestMatch == NULL ||
                    pInst->m_lZOrder > pLatestMatch->m_lZOrder)
                {
                    pLatestMatch = pInst;
                }

            }
    
            itStart++;
        }

        if(pLatestMatch)
        {
            //
            // Exact match. All we need to do is overwrite the original
            // instruction.  Of course, we also need to afjust the hash!!
            //

			pLatestMatch->SetReuseFlag();
            lRes = pLatestMatch->Write(pLatestMatch->ComputeOriginalOffset(), 
                                            pBuffer);
            if(lRes)
                return lRes;

/*
            ERRORTRACE((LOG_WBEMCORE, "Replaced instruction:\n"));
            pLatestMatch->Dump();
*/

            //
            // No need to make sure this instruction comes up in the Z-order!
            // After all, it's already topmost by selection criteria!
            //

            return ERROR_SUCCESS;
        }
    }


    //
    // No match --- add a new instruction
    //

    CWriteFileInstruction* pInst = 
        new CWriteFileInstruction(this, nFileId, dwStartOffset, dwLen);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CLongFileInstruction> rm1(pInst);

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset, pBuffer);
        if(lRes)
            return lRes;
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CLongFileStagingFile::SetFileLength(int nFileId, DWORD dwLen)
{
    CInCritSec ics(&m_cs);
    long lRes;


    CSetEndOfFileInstruction* pInst = 
        new CSetEndOfFileInstruction(this, nFileId, dwLen);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CSetEndOfFileInstruction> rm1(pInst);

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
            return lRes;
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CLongFileStagingFile::AddInstructionToMap(CStageInstruction* pRawInst,
                                            CStageInstruction** ppUndoInst)
{
    CInCritSec ics(&m_cs);

    if(ppUndoInst)
        *ppUndoInst = NULL;

    CLongFileInstruction* pLongInst = (CLongFileInstruction*)pRawInst;
    if(!pLongInst->IsWrite())
        return ERROR_SUCCESS;

    CWriteFileInstruction* pInst = (CWriteFileInstruction*)pLongInst;

/*
    ERRORTRACE((LOG_WBEMCORE, "Add instruction\n"));
    pInst->Dump();
*/

    pInst->AddRef();
    TIterator itStart;

    try
    {
        itStart = m_mapStarts.insert(TValue(pInst->m_Location, pInst));
    }
    catch(...)
    {
        //
        // Put everything back as well as we can
        //

        pInst->Release();
        return ERROR_OUTOFMEMORY;
    }

    pInst->AddRef();

    try
    {
        CFileLocation Location;
        pInst->GetEnd(&Location);

        m_mapEnds.insert(TValue(Location, pInst));
    }
    catch(...)
    {
        //
        // Put everything back as well as we can
        //

        pInst->Release();
        
        m_mapStarts.erase(itStart);

        pInst->Release();
    }
            
    return ERROR_SUCCESS;
}

bool CLongFileStagingFile::IsStillCurrent(CStageInstruction* pRawInst)
{
    CInCritSec ics(&m_cs);

    CLongFileInstruction* pInst = (CLongFileInstruction*)pRawInst;
    if(!pInst->IsWrite())
        return true;

    _ASSERT(m_mapStarts.find(pInst->m_Location) != m_mapStarts.end(),
                L"Why would we be asking about an instruction that is "
                        "not even there?");
    return true;
}

long CLongFileStagingFile::ReadFile(int nFileId, DWORD dwStartOffset, 
                BYTE* pBuffer, DWORD dwLen, DWORD* pdwRead)
{
	if(pdwRead)
		*pdwRead = dwLen;
    long lRes;

    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileLocation StartLocation;
    StartLocation.m_nFileId = nFileId;
    StartLocation.m_lStartOffset = (TFileOffset)dwStartOffset;

    bool bComplete = false;
    CRefedPointerArray<CWriteFileInstruction> apRelevant;

    TIterator itStart = m_mapStarts.lower_bound(StartLocation);
    while(itStart != m_mapStarts.end()
            && itStart->first.m_nFileId == nFileId
            && itStart->first.m_lStartOffset < 
                    (TFileOffset)dwStartOffset + dwLen)
    {
        CWriteFileInstruction* pInst = itStart->second;

		if(pInst->m_Location.m_lStartOffset == dwStartOffset &&
			pInst->m_dwLen >= dwLen)
		{
			bComplete = true;
		}
        apRelevant.Add(pInst);
		itStart++;
    }
        
    TIterator itEnd = m_mapEnds.lower_bound(StartLocation);

    while(itEnd != m_mapEnds.end()
            && itEnd->first.m_nFileId == nFileId
            && itEnd->second->m_Location.m_lStartOffset <  
                (TFileOffset)dwStartOffset)
    {
        CWriteFileInstruction* pInst = itEnd->second;
        if(itEnd->first.m_lStartOffset >= 
                (TFileOffset)dwStartOffset + dwLen - 1)
        {
            //
            // Completely covers us!
            //

            bComplete = true;
        }

        apRelevant.Add(pInst);
		itEnd++;
    }

    if(!bComplete)
    {
        //
        // Read from the real file
        //

        lRes = A51ReadFromFileSync(m_aFiles[nFileId].m_h, dwStartOffset, 
                    pBuffer, dwLen);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    //
    // Now, sort all the instructions by z-order
    //

    int i = 0;
    while(i < apRelevant.GetSize() - 1)
    {
        CWriteFileInstruction* pInst1 = apRelevant[i];
        CWriteFileInstruction* pInst2 = apRelevant[i+1];
        if(pInst1->m_lZOrder > pInst2->m_lZOrder)
        {
            apRelevant.Swap(i, i+1);
            if(i > 0)
                i--;
        }
        else
        {
            i++;
        }
    }

    //
    // Apply them in this order
    //

/*
    if(apRelevant.GetSize() > 0)
    {
        ERRORTRACE((LOG_WBEMCORE, "Using instructions to read %d bytes "
                        "from file %d starting at %d:\n",
                        (int)dwStartOffset, (int)nFileId, (int)dwLen));
    }
*/

    for(i = 0; i < apRelevant.GetSize(); i++)
    {
        CWriteFileInstruction* pInstruction = apRelevant[i];
        // pInstruction->Dump();

        long lIntersectionStart = max(pInstruction->m_Location.m_lStartOffset,
                                        dwStartOffset);

        long lIntersectionEnd = 
            min(pInstruction->m_Location.m_lStartOffset + pInstruction->m_dwLen,
                dwStartOffset + dwLen);
        
        DWORD dwReadLen = (DWORD)(lIntersectionEnd - lIntersectionStart);
        long lInstructionReadOffset = 
                lIntersectionStart - pInstruction->m_Location.m_lStartOffset;

        long lDestinationBufferOffset = lIntersectionStart - dwStartOffset;

        long lRes = pInstruction->GetData(m_hFile, lInstructionReadOffset,
                        dwReadLen, pBuffer + lDestinationBufferOffset);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    return ERROR_SUCCESS;
}

long CLongFileStagingFile::GetFileLength(int nFileId, DWORD* pdwLength)
{
    _ASSERT(pdwLength, L"Invalid parameter");

    *pdwLength = 0;
    long lRes;

    CInCritSec ics(&m_cs);

    //
    // Find the instruction that ends as far as we can see --- that would be
    // the last one in the map of Ends
    //


	CFileLocation Location;
	Location.m_nFileId = nFileId+1;
	Location.m_lStartOffset = 0;

    TIterator itEnd = m_mapEnds.lower_bound(Location);
	if(itEnd != m_mapEnds.begin())
	{
		itEnd--;
		if(itEnd->first.m_nFileId == nFileId)
		{
			*pdwLength = itEnd->first.m_lStartOffset+1;
		}
	}

    //
    // Now, check out the length of the actual file
    //

    BY_HANDLE_FILE_INFORMATION fi;
    if(!GetFileInformationByHandle(m_aFiles[nFileId].m_h, &fi))
    {
        long lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"Success from failure");
        return lRes;
    }
        
    _ASSERT(fi.nFileSizeHigh == 0, L"Free file too long");

    if(fi.nFileSizeLow > *pdwLength)
        *pdwLength = fi.nFileSizeLow;

    return ERROR_SUCCESS;
}

long CLongFileStagingFile::ConstructInstructionFromType(int nType,
                                CStageInstruction** ppInst)
{
    CLongFileInstruction* pInst = NULL;
    switch(nType)
    {
        case A51_INSTRUCTION_TYPE_WRITEFILE:
            pInst = new CWriteFileInstruction(this);
            break;
        case A51_INSTRUCTION_TYPE_SETENDOFFILE:
            pInst = new CSetEndOfFileInstruction(this);
            break;
        default:
			return ERROR_RXACT_INVALID_STATE;
    }

    if(pInst == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pInst->AddRef();
    *ppInst = pInst;
    return ERROR_SUCCESS;
}

long CLongFileStagingFile::WriteToActualFile(int nFileId, 
                            TFileOffset lFileOffset, BYTE* pBuffer, DWORD dwLen)
{
    CInCritSec ics(&m_cs);

    long lRet = A51WriteToFileSync(m_aFiles[nFileId].m_h, lFileOffset, 
                    pBuffer, dwLen);
//    FlushFileBuffers(m_aFiles[nFileId].m_h);
    return lRet;
}

long CLongFileStagingFile::SetEndOfActualFile(int nFileId, 
                                                TFileOffset lFileLength)
{
    CInCritSec ics(&m_cs);

    LARGE_INTEGER liEnd;
    liEnd.QuadPart = lFileLength;

    if(!SetFilePointerEx(m_aFiles[nFileId].m_h, liEnd, NULL, FILE_BEGIN))
        return GetLastError();

    if(!SetEndOfFile(m_aFiles[nFileId].m_h))
        return GetLastError();

    return ERROR_SUCCESS;
}

long CLongFileStagingFile::CloseAllFiles()
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < A51_MAX_FILES; i++)
    {
        if(m_aFiles[i].m_h != NULL)
        {
            CloseHandle(m_aFiles[i].m_h);
        }
        m_aFiles[i].m_h = NULL;
        m_aFiles[i].m_bSupportsOverwrites = false;
    }

    return ERROR_SUCCESS;
}
    
long CLongFileStagingFile::RegisterFile(int nFileId, HANDLE hFile,
                                    bool bSupportsOverwrites)
{
    _ASSERT(nFileId < A51_MAX_FILES, L"File ID is too large");

    if(m_aFiles[nFileId].m_h != NULL)
        CloseHandle(m_aFiles[nFileId].m_h);

    m_aFiles[nFileId].m_h = hFile;
    m_aFiles[nFileId].m_bSupportsOverwrites = bSupportsOverwrites;

    return ERROR_SUCCESS;
}

bool CLongFileStagingFile::DoesSupportOverwrites(int nFileId)
{
    return m_aFiles[nFileId].m_bSupportsOverwrites;
}

long CLongFileStagingFile::WriteEmpty()
{
    _ASSERT(m_mapStarts.size() == 0 && m_mapEnds.size() == 0, L"");
    FlushDataFiles();
    return CExecutableStageManager::WriteEmpty();
}


bool CLongFileStagingFile::InjectFailure()
{
#ifdef A51_INJECT_FAILURE
    if(GetTickCount() > g_dwLastFailureCheck + FAILURE_INJECTION_CHECK_INTERVAL)
    {
        HKEY hKey;
        long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                        0, KEY_READ | KEY_WRITE, &hKey);
        if(lRes)
            return false;
        CRegCloseMe cm(hKey);
    
        DWORD dwLen = sizeof(DWORD);
        lRes = RegQueryValueExW(hKey, L"Failure Frequency", NULL, NULL,
                    (LPBYTE)&g_dwFailureFrequency, &dwLen);
        if(lRes != ERROR_SUCCESS)
            g_dwFailureFrequency = 0;

        g_dwLastFailureCheck = GetTickCount();
    }

    if(g_dwFailureFrequency && ++g_dwFailureCount == g_dwFailureFrequency)
    {
        g_dwFailureCount = 0;
        m_bMustFail = true;
        return true;
    }
    else
    {
        return false;
    }
#else
    return false;
#endif
}

void CLongFileStagingFile::Dump(FILE* f)
{
    fprintf(f, "BEGINS:\n");

    TIterator itStart = m_mapStarts.begin();
    while(itStart != m_mapStarts.end())
    {
        CWriteFileInstruction* pInst = itStart->second;
        fprintf(f, "File %d (%d-%d): instruction %p\n",
            (int)pInst->m_Location.m_nFileId, 
            (int)pInst->m_Location.m_lStartOffset,
            (int)pInst->m_Location.m_lStartOffset + pInst->m_dwLen, 
            pInst);
        itStart++;
    }

    fprintf(f, "IN ORDER:\n");

    int nSize = m_qToWrite.size();
    for(int i = 0; i < nSize; i++)
    {
        CLongFileInstruction* pInstruction = 
             (CLongFileInstruction*)m_qToWrite.front();
        if(pInstruction->IsWrite())
        {
            CWriteFileInstruction* pInst = (CWriteFileInstruction*)pInstruction;
            fprintf(f, "File %d (%d-%d): instruction %p\n",
                (int)pInst->m_Location.m_nFileId, 
                (int)pInst->m_Location.m_lStartOffset,
                (int)pInst->m_Location.m_lStartOffset + pInst->m_dwLen, 
                pInst);
        }
        else
        {
            CSetEndOfFileInstruction* pInst = (CSetEndOfFileInstruction*)pInstruction;
            fprintf(f, "Truncate file %d at %d: instruction %p\n",
                (int)pInst->m_Location.m_nFileId, 
                (int)pInst->m_Location.m_lStartOffset,
                pInst);
        }

        m_qToWrite.pop_front();
        m_qToWrite.push_back(pInstruction);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\objheap.cpp ===
#include <wbemcomn.h>
#include "a51tools.h"
#include "objheap.h"
#include "index.h"

#define ROSWELL_OFFSET_FORMAT_STRING L"%d"
#define ROSWELL_HEAPALLOC_TYPE_BUSY 0xA51A51A5

long CObjectHeap::Initialize(CAbstractFileSource  * pAbstractSource, 
                             WCHAR * wszObjHeapName,
                             WCHAR * wszBaseName,
                             DWORD dwBaseNameLen)
{
    CInCritSec ics(&m_cs);
    if (m_bInit)
        return ERROR_SUCCESS;
        
    long lRes;
    
    lRes = m_Heap.Initialize(pAbstractSource, wszObjHeapName);

    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = m_Index.Initialize(dwBaseNameLen, wszBaseName, pAbstractSource);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_bInit = TRUE;

    return lRes;
}

long CObjectHeap::Uninitialize(DWORD dwShutDownFlags)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return ERROR_SUCCESS;
        
    m_Index.Shutdown(dwShutDownFlags);

    m_Heap.Uninitialize();

    m_bInit = FALSE;

    return ERROR_SUCCESS;
}

void CObjectHeap::InvalidateCache()
{
    m_Index.InvalidateCache();
    m_Heap.InvalidateCache();
}

long CObjectHeap::FindClose(HANDLE hFileEnum)
{
    return m_Index.FindClose(hFileEnum);
}

long CObjectHeap::FindFirst(LPCWSTR wszPrefix, 
                            WIN32_FIND_DATAW* pfd, 
                            void** ppHandle)
{
    return m_Index.FindFirst(wszPrefix,pfd,ppHandle);
}

long CObjectHeap::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    return m_Index.FindNext(pHandle,pfd);
}

long CObjectHeap::GetIndexFileName(LPCWSTR wszFilePath, LPWSTR wszIndexFileName)
{
    WIN32_FIND_DATAW wfd;
    HANDLE hSearch = NULL;

    long lRes = m_pIndex->FindFirst(wszFilePath, &wfd, NULL);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_PATH_NOT_FOUND)
            lRes = ERROR_FILE_NOT_FOUND;
        return lRes;
    }

    // m_pIndex->FindClose(hSearch);
    wcscpy(wszIndexFileName, wfd.cFileName);
    return ERROR_SUCCESS;
}

long CObjectHeap::GetFileInfo(LPCWSTR wszFilePath, TOffset* pnOffset,
                            DWORD* pdwLength)
{
    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ParseInfoFromIndexFile(wszIndexFileName, pnOffset, pdwLength);
}

long CObjectHeap::ParseInfoFromIndexFile(LPCWSTR wszIndexFileName, 
                                        TOffset* pnOffset, DWORD* pdwLength)
{
    WCHAR* pDot = wcschr(wszIndexFileName, L'.');
    if(pDot == NULL)
        return ERROR_INVALID_PARAMETER;

    WCHAR* pwc = pDot+1;
    *pnOffset = 0;
    while(*pwc && *pwc != L'.')
    {
        *pnOffset = (*pnOffset * 10) + (*pwc - '0');
		pwc++;
    }

    if(*pwc != L'.')
        return ERROR_INVALID_PARAMETER;

    pwc++;

    *pdwLength = 0;
    while(*pwc && *pwc != L'.')
    {
        *pdwLength = (*pdwLength * 10) + (*pwc - '0');
		pwc++;
    }

    return ERROR_SUCCESS;
}

long CObjectHeap::CreateIndexFile(LPCWSTR wszFilePath, TOffset nOffset,
                                DWORD dwLength)
{
    //
    // Simply append the numbers to the file path
    //

    CFileName wszIndexFilePath;
    if(wszIndexFilePath == NULL)
        return ERROR_OUTOFMEMORY;

    swprintf(wszIndexFilePath, L"%s." ROSWELL_OFFSET_FORMAT_STRING L".%d",
        wszFilePath, nOffset, dwLength);

    return CreateZeroLengthFile(wszIndexFilePath);
}

long CObjectHeap::DeleteIndexFile(LPCWSTR wszFilePath, LPCWSTR wszIndexFileName)
{
    //
    // Construct the full path to the index file by concatenating the directory 
    // of the original file with the name
    //

    CFileName wszIndexFilePath;
    if(wszIndexFilePath == NULL)
        return ERROR_OUTOFMEMORY;

    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_INVALID_PARAMETER;

    int nPrefixLen = (pwcLastSlash - wszFilePath + 1);
    memcpy(wszIndexFilePath, wszFilePath, nPrefixLen * sizeof(WCHAR));

    wcscpy(wszIndexFilePath + nPrefixLen, wszIndexFileName);
	return DeleteZeroLengthFile(wszIndexFilePath);
}

    

long CObjectHeap::CreateZeroLengthFile(LPCWSTR wszFilePath)
{
    // TBD: use staging file, use more efficient API

	return m_pIndex->Create(wszFilePath);
}

long CObjectHeap::DeleteZeroLengthFile(LPCWSTR wszFilePath)
{
    // TBD: use staging file, use more efficient API

    return m_pIndex->Delete(wszFilePath);
}
    
DWORD CObjectHeap::GetAllocationHeaderLength()
{
    return sizeof(DWORD) // length 
            + sizeof(DWORD); // type
}

long CObjectHeap::WriteAllocation(TOffset nOffset, DWORD dwDataLength,
                                BYTE* pData)
{
    //
    // Prepare a buffer with the complete allocation
    //

    DWORD dwAllocationLength = dwDataLength + GetAllocationHeaderLength();
    BYTE* pAllocation = (BYTE*)TempAlloc(dwAllocationLength);
    if(pAllocation == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pAllocation);

    memcpy(pAllocation, &dwDataLength, sizeof(DWORD));
    DWORD dwType = ROSWELL_HEAPALLOC_TYPE_BUSY;
    memcpy(pAllocation + sizeof(DWORD), &dwType, sizeof(DWORD));

    memcpy(pAllocation + GetAllocationHeaderLength(), pData, dwDataLength);
    
    return m_pHeap->WriteBytes(nOffset, pAllocation, dwAllocationLength);
}

long CObjectHeap::ReadAllocation(TOffset nOffset, DWORD dwDataLength,
                                BYTE* pBuffer)
{
    //
    // Prepare a buffer with the complete allocation
    //

    DWORD dwAllocationLength = dwDataLength + GetAllocationHeaderLength();
    BYTE* pAllocation = (BYTE*)TempAlloc(dwAllocationLength);
    if(pAllocation == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pAllocation);

    long lRes = m_pHeap->ReadBytes(nOffset, pAllocation, dwAllocationLength);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Sanity checks
    //

    _ASSERT(!memcmp(pAllocation, &dwDataLength, sizeof(DWORD)), 
                L"Allocation size in conflict with the index size");

    DWORD dwType = ROSWELL_HEAPALLOC_TYPE_BUSY;
    _ASSERT(!memcmp(pAllocation + sizeof(DWORD), &dwType, sizeof(DWORD)),
                L"Allocation type is not BUSY");

    memcpy(pBuffer, pAllocation + GetAllocationHeaderLength(), dwDataLength);
    return ERROR_SUCCESS;
}
    

long CObjectHeap::WriteFile(LPCWSTR wszFilePath, DWORD dwBufferLen, 
            BYTE* pBuffer)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;

    long lRes;

    if(dwBufferLen == 0)
    {
        //
        // We do not use the heap for 0-length files, we create them directly
        //

        return CreateZeroLengthFile(wszFilePath);
    }

    //
    // Now, check if this file already exists
    //

    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_SUCCESS)
        return lRes;

    if(lRes == ERROR_SUCCESS)
    {
        //
        // Already there.  Check if we can simply update it
        //

        TOffset nOffset;
        DWORD dwOldLength;
        lRes = ParseInfoFromIndexFile(wszIndexFileName, &nOffset, &dwOldLength);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        if(dwOldLength >= dwBufferLen)
        {
            //
            // Enough space in place --- just write the data and update the
            // length
            //

            lRes = WriteAllocation(nOffset, dwBufferLen, pBuffer);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            if(dwOldLength != dwBufferLen)
            {
                //
                // The length has changed --- first of all, mark the rest of 
                // the block as free
                //

                lRes = m_pHeap->FreeAllocation(
                            nOffset + GetAllocationHeaderLength() + dwBufferLen,
                            dwOldLength - dwBufferLen);

                if(lRes != ERROR_SUCCESS)
                    return lRes;

                //
                // Now, delete the old index file and create a new one (the 
                // length has changed
                //

                lRes = DeleteIndexFile(wszFilePath, wszIndexFileName);
                if(lRes != ERROR_SUCCESS)
                    return lRes;

                lRes = CreateIndexFile(wszFilePath, nOffset, dwBufferLen);
                if(lRes != ERROR_SUCCESS)
                    return lRes;
            }

            return ERROR_SUCCESS;
        }
        else
        {
            //
            // Doesn't fit. Erase it
            //

            lRes = m_pHeap->FreeAllocation(nOffset, 
                                    GetAllocationHeaderLength() + dwOldLength);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            lRes = DeleteIndexFile(wszFilePath, wszIndexFileName);
            if(lRes != ERROR_SUCCESS)
                return lRes;
        }
    }

    //
    // Either it wasn't there, or we have cleaned it up.  Insert it now
    //

    TOffset nOffset;
    lRes = m_pHeap->Allocate(dwBufferLen + GetAllocationHeaderLength(), 
                                &nOffset);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = WriteAllocation(nOffset, dwBufferLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = CreateIndexFile(wszFilePath, nOffset, dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    
    return ERROR_SUCCESS;
}

long CObjectHeap::ReadFile(LPCWSTR wszFilePath, DWORD* pdwLength, 
                            BYTE** ppBuffer)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;    

    long lRes;

    //
    // TBD: deal with filepath being the path to the index file instead of the
    // theoretical file path --- this can happen if people FindFirstFile it
    //

    //
    // Find the file
    //

    TOffset nOffset;
    lRes = GetFileInfo(wszFilePath, &nOffset, pdwLength);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the allocation
    //

    *ppBuffer = (BYTE*)TempAlloc(*pdwLength);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    lRes = ReadAllocation(nOffset, *pdwLength, *ppBuffer);
    if(lRes != ERROR_SUCCESS)
    {
        TempFree(*ppBuffer);
        return lRes;
    }

    return ERROR_SUCCESS;
}

long CObjectHeap::DeleteFile(LPCWSTR wszFilePath)
{
    CInCritSec ics(&m_cs);
    if (!m_bInit)
        return -1;    

    //
    // Find the index file
    //

    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Delete the allocation
    //

    TOffset nOffset;
    DWORD dwLength;
    lRes = ParseInfoFromIndexFile(wszIndexFileName, &nOffset, &dwLength);
	if(lRes == ERROR_INVALID_PARAMETER)
	{
		//
		// Not an index file --- must be a zero-length one
		//

		return DeleteZeroLengthFile(wszFilePath);
    }
    
    lRes = m_pHeap->FreeAllocation(nOffset, 
                                    dwLength + GetAllocationHeaderLength());
    if(lRes != ERROR_SUCCESS)
        return lRes;
    
    //
    // Delete the index itself
    //

    lRes = DeleteIndexFile(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\lock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.H

Abstract:

	Generic class for obtaining read and write locks to some resource. 

	See lock.h for all documentation.

	Classes defined:

	CLock

History:

	a-levn  5-Sept-96       Created.
	3/10/97     a-levn      Fully documented

--*/

#ifndef __GATEWAY__LOCK__H_
#define __GATEWAY__LOCK__H_

#include <flexarry.h>

//*****************************************************************************
//
//	class CLock
//
//	Generic class for obtaining read and write locks to some resource. 
//	Simultaneous reads are allowed, but no concurrent writes or concurrent 
//	read and write accesses are.
//
//	NOTE: this class is for in-process sinchronization only!
//
//	Usage: create an instance of this class and share it among the accessing
//	threads.  Threads must call member functions of the same instance to 
//	obtain and release locks.
//
//*****************************************************************************
//
//	ReadLock
//
//	Use this function to request read access to the resource. Access will be
//	granted once no threads are writing on the resource. You must call 
//	ReadUnlock once you are done reading.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	ReadUnlock
//
//	Use this function to release a read lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	ReadUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//	WriteLock
//
//	Use this function to request write access to the resource. Access will be
//	granted once no threads are reading or writing on the resource. You must 
//	call WriteUnlock once you are done writing.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	WriteUnlock
//
//	Use this function to release a write lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	WriteUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//  DowngradeLock
//
//  Use this function to "convert" a Write lock into a Read lock. That is, if
//  you are currently holding a write lock and call DowngradeLock, you will 
//  be holding a read lock with the guarantee that no one wrote anything between
//  the unlock and the lock
//
//  Returns:
//
//      NoError     On Success
//      Failed      On system error or unmatched call
//
//******************************************************************************
class CLock
{
public:
	enum { NoError = 0, TimedOut, Failed };

	int ReadLock(DWORD dwTimeout = INFINITE);
	int ReadUnlock();
	int WriteLock(DWORD dwTimeout = INFINITE);
	int WriteUnlock();
    int DowngradeLock();

	CLock();
	~CLock();

    BOOL IsHoldingReadLock();

protected:
	int WaitFor(HANDLE hEvent, DWORD dwTimeout);

protected:
    CFlexArray m_adwReaders;
	int m_nWriting;
	int m_nReading;
	int m_nWaitingToWrite;
	int m_nWaitingToRead;

	CRITICAL_SECTION m_csEntering;
	CRITICAL_SECTION m_csAll;
	HANDLE m_hCanWrite;
	HANDLE m_hCanRead;
};

class CAutoReadLock
{
public:
	CAutoReadLock(CLock *lock, BOOL bLock = TRUE) : m_lock(lock), m_bLocked(FALSE) { if (bLock) Lock(); }
	~CAutoReadLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->ReadUnlock(); m_bLocked = FALSE; } }
	void Lock()   {if (!m_bLocked) { m_lock->ReadLock()  ; m_bLocked = TRUE; } }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
class CAutoWriteLock
{
public:
	CAutoWriteLock(CLock *lock, BOOL bLock = TRUE) : m_lock(lock), m_bLocked(FALSE) { if (bLock) Lock(); }
	~CAutoWriteLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->WriteUnlock(); m_bLocked = FALSE; } }
	void Lock()   {if (!m_bLocked) { m_lock->WriteLock()  ; m_bLocked = TRUE; } }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\repositorypackager.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.CPP

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "RepositoryPackager.h"

/******************************************************************************
 *
 *	CRepositoryPackager::PackageRepository
 *
 *	Description:
 *		Iterates deeply through the repository directly and packages it up 
 *		into the given file specified by the given parameter.
 *		Repository directory is the one retrieved from the registry.
 *
 *	Parameters:
 *		wszFilename:	Filename we package everything up into
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageRepository(const wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HANDLE hFile = INVALID_HANDLE_VALUE;

    //Store the filename so when package files, we make sure we ignore this file!
    wcscpy(m_wszFileToProcess, wszFilename);

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	//Create a new file to package contents up to...
	if (SUCCEEDED(hres))
	{
		hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	//Write the package header...
	if (SUCCEEDED(hres))
	{
		hres = PackageHeader(hFile);
	}

	if (SUCCEEDED(hres))
	{
		hres = PackageContentsOfDirectory(hFile, wszRepositoryDirectory);
	}

	//Write the end of package marker
	if (SUCCEEDED(hres))
		hres = PackageTrailer(hFile);


	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	//If things failed we should delete the file...
	if (FAILED(hres))
		DeleteFileW(wszFilename);
	return hres;
}


/******************************************************************************
 *
 *	CRepositoryPackager::UnpackageRepository
 *
 *	Description:
 *		Given the filename of a packaged up repository we unpack everything
 *		into the repository directory specified in the registry.  The 
 *		directory should have no files in it before doing this.
 *
 *	Parameters:
 *		wszFilename:	Filename we unpackage everything from
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnpackageRepository(const wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HANDLE hFile = INVALID_HANDLE_VALUE;

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	//open the file for unpacking...
	if (SUCCEEDED(hres))
	{
		hFile = CreateFileW(wszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	//unpack the package header...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageHeader(hFile);
	}

	//unpack the file...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageContentsOfDirectory(hFile, wszRepositoryDirectory);
	}

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	//If things failed we should delete the partially unpacked repository...
	if (FAILED(hres))
		DeleteRepository();

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteRepository
 *
 *	Description:
 *		Delete all files and directories under the repository directory.
 *		The repository directory location is retrieved from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteRepository()
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszRepositoryDirectory);
	}
	
	return hres;
}


/******************************************************************************
 *
 *	CRepositoryPackager::PackageContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to package it into the file specified by the
 *		file handle passed to the method.
 *
 *	Parameters:
 *		hFile:					Handle to the destination file.
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres  = WBEM_S_NO_ERROR;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDirectory(hFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				hres = PackageFile(hFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}

	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageHeader
 *
 *	Description:
 *		Stores the header package in the given file.  This is a footprint
 *		so we can recognise if this really is one of our files when 
 *		we try to decode it.  Also it allows us to version it.
 *
 *	Parameters:
 *		hFile:	File handle to store header in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageHeader(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_HEADER header;
	strcpy(header.szSignature, "FS PKG1.1");	//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

	DWORD dwSize = 0;
	if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		hres = WBEM_E_FAILED;
	
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It stores the namespace
 *		header and footer marker in the file, and also iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	{
		PACKAGE_SPACER_NAMESPACE header;
		header.dwSpacerType = PACKAGE_TYPE_NAMESPACE_START;
		wcscpy(header.wszNamespaceName, wszSubDirectory);
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
			hres = WBEM_E_FAILED;
	}
	
	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = PackageContentsOfDirectory(hFile, wszFullDirectoryName);
	}

	//Now need to write the end of package marker...
	if (SUCCEEDED(hres))
	{
		PACKAGE_SPACER header2;
		header2.dwSpacerType = PACKAGE_TYPE_NAMESPACE_END;
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header2, sizeof(header2), &dwSize, NULL) == 0) || (dwSize != sizeof(header2)))
			hres = WBEM_E_FAILED;
	}

	delete [] wszFullDirectoryName;

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageFile
 *
 *	Description:
 *		This is the code which processes a file.  It stores the file header
 *		and the contents of the file into the destination file whose handle
 *		is passed in.  The file directory and name is passed in.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *		wszParentDirectory:	Full path of parent directory
 *		wszFilename:		Name of file to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
    bool bSkipFile = false; //Sometimes we need to need to skip files!

    //We can skip the mainstage file as it is fully flushed.
    if (_wcsicmp(wszFilename, L"LowStage.dat") == 0)
        return hres;

	PACKAGE_SPACER_FILE header;
	header.dwSpacerType = PACKAGE_TYPE_FILE;
	wcscpy(header.wszFileName, wszFilename);

	WIN32_FILE_ATTRIBUTE_DATA fileAttribs;
	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;

	if (SUCCEEDED(hres))
	{
		wcscpy(wszFullFileName, wszParentDirectory);
		wcscat(wszFullFileName, L"\\");
		wcscat(wszFullFileName, wszFilename);

		if (GetFileAttributesExW(wszFullFileName, GetFileExInfoStandard, &fileAttribs) == 0)
			hres = WBEM_E_FAILED;
		else
		{
			header.dwFileSize = fileAttribs.nFileSizeLow;
		}
	}

    //Make sure we are not packaging the file that is the destination file!
    if (SUCCEEDED(hres))
    {
        if (_wcsicmp(wszFullFileName, m_wszFileToProcess) == 0)
        {
            bSkipFile = true;
        }
    }

	//Write header...
	if (SUCCEEDED(hres) && !bSkipFile)
	{
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
			hres = WBEM_E_FAILED;
	}
	
	//Now need to write actual contents of file to current one... but only if the file is not 0 bytes long...
	if (SUCCEEDED(hres) && (header.dwFileSize != 0) && !bSkipFile)
	{
		HANDLE hFromFile = CreateFileW(wszFullFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFromFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;

		BYTE *pFileBlob = NULL;
		if (SUCCEEDED(hres))
		{
			pFileBlob = new BYTE[header.dwFileSize];
			if (pFileBlob == NULL)
				hres = WBEM_E_OUT_OF_MEMORY;
		}

		if (SUCCEEDED(hres))
		{
			DWORD dwSize = 0;
			if ((ReadFile(hFromFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				hres = WBEM_E_FAILED;
		}

		if (SUCCEEDED(hres))
		{
			DWORD dwSize = 0;
			if ((WriteFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				hres = WBEM_E_FAILED;
		}

		delete pFileBlob;

		if (hFromFile != INVALID_HANDLE_VALUE)
			CloseHandle(hFromFile);
	}

	delete [] wszFullFileName;
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageTrailer
 *
 *	Description:
 *		Writes the end of file marker to the file.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageTrailer(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER trailer;
	trailer.dwSpacerType = PACKAGE_TYPE_END_OF_FILE;

	DWORD dwSize = 0;
	if ((WriteFile(hFile, &trailer, sizeof(trailer), &dwSize, NULL) == 0) || (dwSize != sizeof(trailer)))
		hres = WBEM_E_FAILED;
	
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageHeader
 *
 *	Description:
 *		Unpacks the header package in the given file.  This allows us to recognise
 *		if this really is one of our files. Also it allows us to version it.
 *
 *	Parameters:
 *		hFile:	File handle to unpack header from.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageHeader(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_HEADER header;

    DWORD dwSize = 0;
    if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
    {
		hres = WBEM_E_FAILED;
    }
	else if (strncmp(header.szSignature,"FS PKG1.1", 9) != 0)
    {
		hres = WBEM_E_FAILED;
    }

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageContentsOfDirectory
 *
 *	Description:
 *		Unpack the contents of a namespace/directory.
 *		If a subdirectory is encountered, then it calls UnPackageDirectory to handle it.
 *		If a file is encountered, then it calls UnPackageFile to handle it.
 *		If no errors occur, then it will enventually encounter the end of the namespace,
 *		which will terminate the loop and return control to the calling function.
 *
 *	Parameters:
 *		hFile:					Handle to the file to unpack from
 *		wszRepositoryDirectory:	Directory to write to.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER header;
	DWORD dwSize;

	while (hres == WBEM_S_NO_ERROR)
	{
		// this loop will be exited when we either
		// - successfully process a complete directory/namespace
		// - encounter an error

		dwSize = 0;
		if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		{
			hres = WBEM_E_FAILED;
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_START)
		{
			hres = UnPackageDirectory(hFile, wszRepositoryDirectory);
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_END)
		{
			// done with this directory   
			break;
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_FILE)
		{
			hres = UnPackageFile(hFile, wszRepositoryDirectory);
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_END_OF_FILE)
		{
			// done unpacking
			break;
		}
		else
		{
			hres = WBEM_E_FAILED;
		}
	}

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageDirectory
 *
 *	Description:
 *		Unpack the start of a namespace, then call UnPackageContentsOfDirectory
 *		to handle everything within it.
 *
 *	Parameters:
 *		hFile:				File handle to unpack directory information from.
 *		wszParentDirectory:	Full path of parent directory
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER_NAMESPACE header;

	// read namespace/directory name
	DWORD dwSize = 0;
	DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
	if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
	{
		hres = WBEM_E_FAILED;
	}

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, header.wszNamespaceName);
		}
	}

	// create directory
	if (!CreateDirectoryW(wszFullDirectoryName, NULL))
	{
        if (GetLastError() != ERROR_ALREADY_EXISTS)
		    hres = WBEM_E_FAILED;
	}

	// UnPackage the contents into the new directory...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageContentsOfDirectory(hFile, wszFullDirectoryName);
	}

	delete [] wszFullDirectoryName;
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageFile
 *
 *	Description:
 *		Unpack a file.
 *
 *	Parameters:
 *		hFile:				File handle to unpack file information from.
 *		wszParentDirectory:	Full path of parent directory
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER_FILE header;

	// read file name and size
	DWORD dwSize = 0;
	DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
	if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
	{
		hres = WBEM_E_FAILED;
	}

	//Get full path of new file...
	wchar_t *wszFullFileName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullFileName = new wchar_t[MAX_PATH+1];
		if (wszFullFileName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullFileName, wszParentDirectory);
			wcscat(wszFullFileName, L"\\");
			wcscat(wszFullFileName, header.wszFileName);
		}
	}

	// create the file
	HANDLE hNewFile = INVALID_HANDLE_VALUE;
	if (SUCCEEDED(hres))
	{
		hNewFile = CreateFileW(wszFullFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hNewFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	// read file blob and write to file if size is greater than zero
	if (SUCCEEDED(hres))
	{
		if (header.dwFileSize > 0)
		{
			BYTE* pFileBlob = new BYTE[header.dwFileSize];
			if (pFileBlob == NULL)
				hres = WBEM_E_OUT_OF_MEMORY;

			if (SUCCEEDED(hres))
			{
				dwSize = 0;
				if ((ReadFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				{
					hres = WBEM_E_FAILED;
				}
			}

			// write file
			if (SUCCEEDED(hres))
			{
				dwSize = 0;
				if ((WriteFile(hNewFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
					hres = WBEM_E_FAILED;
			}

			if (pFileBlob)
				delete pFileBlob;
		}
	}

	if (hNewFile != INVALID_HANDLE_VALUE)
		CloseHandle(hNewFile);
	
	if (wszFullFileName)
		delete [] wszFullFileName;

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to delete it.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDeleteDirectory(wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				wcscpy(wszFullFileName, wszRepositoryDirectory);
				wcscat(wszFullFileName, L"\\");
				wcscat(wszFullFileName, findFileData.cFileName);
				if (!DeleteFileW(wszFullFileName))
				{
					hres = WBEM_E_FAILED;
					break;
				}
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}
	
	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageDeleteDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszFullDirectoryName);
	}

	// now that the directory is empty, remove it
	if (!RemoveDirectoryW(wszFullDirectoryName))
		hres = WBEM_E_FAILED;

	delete [] wszFullDirectoryName;

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\shortstg.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include <sync.h>
#include <malloc.h>
#include "shortstg.h"
#include "filecach.h"


#define A51_INSTRUCTION_TYPE_CREATEFILE 1
#define A51_INSTRUCTION_TYPE_DELETEFILE 2
#define A51_INSTRUCTION_TYPE_REMOVEDIRECTORY 3

CTempMemoryManager g_FileCacheManager;

CShortFileInstruction::CShortFileInstruction(CShortFileStagingFile* pFile)
    : CStageInstruction(pFile), m_wszFilePath(NULL)
{
}
    
long CShortFileInstruction::Initialize(LPCWSTR wszFilePath)
{
    int nFilePathLen = wcslen(wszFilePath);
    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager, (nFilePathLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    wcscpy(m_wszFilePath, wszFilePath);

    return ERROR_SUCCESS;
}

CShortFileInstruction::~CShortFileInstruction()
{
    if (m_wszFilePath)
    {
        TempFree(g_FileCacheManager, m_wszFilePath);
    }
}


DWORD CShortFileInstruction::ComputeSpaceForName()
{
    return sizeof(DWORD) + wcslen(m_wszFilePath) * sizeof(WCHAR);
}

BYTE* CShortFileInstruction::WriteFileName(BYTE* pStart)
{
    DWORD dwStringLen = wcslen(m_wszFilePath);
    memcpy(pStart, (void*)&dwStringLen, sizeof(DWORD));
    pStart += sizeof(DWORD);
    memcpy(pStart, m_wszFilePath, dwStringLen * sizeof(WCHAR));

    return pStart + dwStringLen * sizeof(WCHAR);
}

long CShortFileInstruction::RecoverFileName(HANDLE hFile)
{
    _ASSERT(m_wszFilePath == NULL, 
            L"Double initialization of a file instruction!");
    //
    // Read the length
    //

    DWORD dwStringLen = 0;
    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&dwStringLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // Read the file name
    //

    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager,
                                        (dwStringLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    
    if(!ReadFile(hFile, (BYTE*)m_wszFilePath, dwStringLen * sizeof(WCHAR),
                    &dwRead, NULL))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return GetLastError();
    }

    if(dwRead != dwStringLen * sizeof(WCHAR))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return ERROR_HANDLE_EOF;
    }

    m_wszFilePath[dwStringLen] = 0;

    return ERROR_SUCCESS;
}
        
    

void CShortFileInstruction::ComputeFullPath(wchar_t *wszFullPath)
{
    wcscpy(wszFullPath, ((CShortFileStagingFile*)m_pManager)->GetBase());
    wcscat(wszFullPath, m_wszFilePath);
}



CCreateFile::CCreateFile(CShortFileStagingFile* pFile)
    : CShortFileInstruction(pFile), m_dwFileLen(0), m_dwFileStart(0)
{
}

void* CCreateFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CCreateFile));
}

void CCreateFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CCreateFile));
}

long CCreateFile::Initialize(LPCWSTR wszFilePath, DWORD dwFileLen)
{
    long lRes = CShortFileInstruction::Initialize(wszFilePath);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    m_dwFileLen = dwFileLen;
    return ERROR_SUCCESS;
}

DWORD CCreateFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the type
                ComputeSpaceForName() + // for the file name
                sizeof(DWORD) + // for the length of data
                m_dwFileLen + // for the data
                A51_TAIL_SIZE; // for the trailer
}
                    
long CCreateFile::Write(TFileOffset lOffset, BYTE* pBuffer)
{
    if(pBuffer)
        memcpy(&m_dwFileStart, pBuffer, sizeof(DWORD));
    else
        m_dwFileStart = 0;

    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_CREATEFILE;
    pCurrent++;

    // 
    // Write the name of the file
    //

    pCurrent = WriteFileName(pCurrent);
    
    //
    // Write the length of the data for the file
    //

    memcpy(pCurrent, (void*)&m_dwFileLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    //
    // Write the data itself and record its offset
    //

    memcpy(pCurrent, pBuffer, m_dwFileLen);
    m_lStageOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent + m_dwFileLen, 0, sizeof(DWORD));
    
    // 
    // Write it 
    //

    return m_pManager->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CCreateFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name first
    //

    long lRes = CShortFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the length of the data from the file
    //

    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&m_dwFileLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // We do not need to actually read the data from the file --- we keep it
    // there until it is time to flush.  But we do need to skip it.  At the same
    // time, we need to record the position in the file where this data resides
    //

    LARGE_INTEGER liFileLen;
    liFileLen.QuadPart = m_dwFileLen;
    
    LARGE_INTEGER liNewPosition;
    if(!SetFilePointerEx(hFile, liFileLen, &liNewPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liNewPosition.HighPart == 0, L"Staging file too long!");

    m_lStageOffset = (long)(liNewPosition.QuadPart - m_dwFileLen);
    return ERROR_SUCCESS;
}

long CCreateFile::GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer)
{
	//
	// Lock the file
	//

	CInCritSec ics(m_pManager->GetLock());

	_ASSERT(m_pManager->GetFirstFreeOffset() >= m_lStageOffset, 
            L"Instruction points to empty space in stage file");

    if(pdwLen)
        *pdwLen = m_dwFileLen;

    if(ppBuffer == NULL)
        return ERROR_SUCCESS;

    //
    // Allocate the buffer
    //

    *ppBuffer = (BYTE*)TempAlloc(m_dwFileLen);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = A51ReadFromFileSync(hFile, m_lStageOffset, *ppBuffer, m_dwFileLen);
    if(lRes != ERROR_SUCCESS)
    {
        delete *ppBuffer;
        return lRes;
    }

    if(m_dwFileLen && m_dwFileStart && memcmp(*ppBuffer, &m_dwFileStart, sizeof(DWORD)))
    {
        _ASSERT(false, L"Stage file overwritten");
        TempFree(*ppBuffer, m_dwFileLen);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}

    
long CCreateFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    long lRes;

    //
    // Read the data from the staging file
    //

    BYTE* pBuffer = NULL;
    lRes = GetData(m_pManager->GetHandle(), NULL, &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    CTempFreeMe vdm(pBuffer, m_dwFileLen);
    
    return ((CShortFileStagingFile*)m_pManager)->
                WriteActualFile(wszFullPath, m_dwFileLen, pBuffer);
}


CDeleteFile::CDeleteFile(CShortFileStagingFile* pFile)
    : CShortFileInstruction(pFile)
{
}

void* CDeleteFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CDeleteFile));
}

void CDeleteFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CDeleteFile));
}

long CDeleteFile::Initialize(LPCWSTR wszFileName)
{
    return CShortFileInstruction::Initialize(wszFileName);
}

DWORD CDeleteFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CDeleteFile::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write the instruction type
    //
    
    *pCurrent = A51_INSTRUCTION_TYPE_DELETEFILE;
    pCurrent++;
    
    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lStageOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pManager->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CDeleteFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CShortFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lStageOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CDeleteFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Delete the right file
    //

    long lRes = ((CShortFileStagingFile*)m_pManager)->
                    DeleteActualFile(wszFullPath);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
        return lRes;
    else
        return ERROR_SUCCESS;
}


CRemoveDirectory::CRemoveDirectory(CShortFileStagingFile* pFile)
    : CShortFileInstruction(pFile)
{
}

void* CRemoveDirectory::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CRemoveDirectory));
}

void CRemoveDirectory::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CRemoveDirectory));
}

long CRemoveDirectory::Initialize(LPCWSTR wszFileName)
{
    return CShortFileInstruction::Initialize(wszFileName);
}

DWORD CRemoveDirectory::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CRemoveDirectory::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_REMOVEDIRECTORY;
    pCurrent++;

    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lStageOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pManager->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CRemoveDirectory::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CShortFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lStageOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CRemoveDirectory::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Remove the directory
    //

    long lRes = ((CShortFileStagingFile*)m_pManager)->
                    RemoveActualDirectory(wszFullPath);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND &&
        lRes != ERROR_DIR_NOT_EMPTY)
    {
        return lRes;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}



CShortFileStagingFile::CShortFileStagingFile(CFileCache* pCache,
                                                LPCWSTR wszBaseName,
                                                long lMaxFileSize,
                                                long lAbortTransactionFileSize)
    : CExecutableStageManager(lMaxFileSize, lAbortTransactionFileSize),
        m_map(TMap::key_compare(), TMap::allocator_type(&g_FileCacheManager)),
        m_pCache(pCache)
{
    wcscpy(m_wszBaseName, wszBaseName);
}

CShortFileStagingFile::~CShortFileStagingFile()
{
}

void CShortFileStagingFile::ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey)
{
    wbem_wcsupr(wszKey, wszFileName);
}


long CShortFileStagingFile::RemoveInstructionFromMap(
                                                    CStageInstruction* pRawInst)
{
    CInCritSec ics(m_pCache->GetLock());

    CShortFileInstruction* pInst = (CShortFileInstruction*)pRawInst;

    TIterator it = m_map.find(pInst->GetFilePath());
    if(it != m_map.end() && it->second == pInst)
    {
        // 
        // This instruction is currently in the map. Remove it. 
        //

        it->second->Release();
        EraseIterator(it);
    }

    return ERROR_SUCCESS;
}

long CShortFileStagingFile::WriteFile(LPCWSTR wszFileName, DWORD dwLen, 
                                        BYTE* pBuffer)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
	return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CCreateFile* pInst = new CCreateFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CShortFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey, dwLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset, pBuffer);
        if(lRes)
            return lRes;
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CShortFileStagingFile::DeleteFile(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CDeleteFile* pInst = new CDeleteFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CShortFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
            return lRes;
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CShortFileStagingFile::RemoveDirectory(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;

    ComputeKey(wszFileName, wszKey);

    CRemoveDirectory* pInst = new CRemoveDirectory(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CShortFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
        {
            m_cs.Leave();
            return lRes;
        }
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }

    return lRes;
}


// assumes: locked
long CShortFileStagingFile::AddInstructionToMap(CStageInstruction* pRawInst,
                                            CStageInstruction** ppUndoInst)
{
    CInCritSec ics(m_pCache->GetLock());

    if(ppUndoInst)
        *ppUndoInst = NULL;

    CShortFileInstruction* pInst = (CShortFileInstruction*)pRawInst;
    pInst->AddRef();

    TIterator it = m_map.find(pInst->GetFilePath());
    if(it != m_map.end())
	{
        //
        // It is already there.  We need to replace that instruction with our
        // own.  However, if that instruction was committed, we should remember
        // it in case our transaction aborts.
        //
        // The extra quirk here is that we should not be doing this if the 
        // instruction being replaced came from our own transaction.  This is
        // not an empty optimization --- if we do and the transaction aborts,
        // we may end up attempting to execute this one even though its body
        // is in the garbaged area of the staging file
        //

        if(ppUndoInst && it->second->IsCommitted())
        {
            *ppUndoInst = it->second; // transferred ref-count
        }
        else
        {
            it->second->Release();
        }
        EraseIterator(it);
	}

    try
    {
        m_map[pInst->GetFilePath()] = pInst;
    }
    catch(...)
    {
        //
        // Put everything back as well as we can
        //

        if(ppUndoInst && *ppUndoInst)
            *ppUndoInst = NULL;

        pInst->Release();
        return ERROR_OUTOFMEMORY;
    }
            
    return ERROR_SUCCESS;
}

bool CShortFileStagingFile::IsStillCurrent(CStageInstruction* pRawInst)
{
    CShortFileInstruction* pInst = (CShortFileInstruction*)pRawInst;

    TIterator it = m_map.find(pInst->GetFilePath());
    if(it != m_map.end())
    {
        if(it->second == pInst)
        {
            // 
            // This instruction is currently in the map
            //

            return true;
        }
        else if(it->second->IsCommitted())
        {
            //
            // Overriden by a committed instruction --- not current
            //
        
            return false;
        }
        else
        {
            return true;
        }
    }
    else
    {
        _ASSERT(false, L"Why would we be asking about an instruction that is "
                        "not even there?");

        return false;
    }
}

long CShortFileStagingFile::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, 
                                BYTE** ppBuffer, bool bMustBeThere)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return ERROR_NO_INFORMATION;
    }
    else
    {
        CShortFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
        {
            if(bMustBeThere)
            {
                Dump();
                _ASSERT(false, L"Must-be-present file is not there. Dumped");
            }
            return ERROR_FILE_NOT_FOUND;
        }
        else
        {
            long lRes = ((CCreateFile*)pInstruction)->GetData(m_hFile, pdwLen, 
                                                                ppBuffer);
            return lRes;
        }
    }
}

void CShortFileStagingFile::Dump()
{
    FILE* f = fopen("c:\\a.dmp", "a");
    if(f == NULL)
        return;

    fprintf(f, "MAP:\n");
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CShortFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());
        it++;
    }

    fprintf(f, "LIST:\n");

    int nSize = m_qToWrite.size();
    for(int i = 0; i < nSize; i++)
    {
        CShortFileInstruction* pInstruction = (CShortFileInstruction*)m_qToWrite.front();
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());

        m_qToWrite.pop_front();
        m_qToWrite.push_back(pInstruction);
    }

    fclose(f);
}

long CShortFileStagingFile::IsDeleted(LPCWSTR wszFilePath)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePath, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return S_FALSE;
    }
    else
    {
        CShortFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            return S_OK;
        else
            return S_FALSE;
    }
}
    

long CShortFileStagingFile::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);

    //
    // Compute the key for the prefix --- key computation is such that the 
    // keys come in the same lexicographic order as the names, so this will 
    // give us the lower bound for the search
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePrefix, wszKey);

    //
    // Find this spot in the map
    //

    TIterator it = m_map.lower_bound(wszKey);
    if(it == m_map.end())
        return ERROR_FILE_NOT_FOUND;

    //
    // Retrieve the first element
    // 

    CIterationHandle* pHandle = new CIterationHandle(m_map, it, wszKey);
    if(pHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    long lRes = pHandle->GetNext(pfd);
    if(lRes != ERROR_SUCCESS)
    {
        delete pHandle;
        if(lRes == ERROR_NO_MORE_FILES)
            lRes = ERROR_FILE_NOT_FOUND;

        return lRes;
    }

    m_apIterators.Add(pHandle);
    *ppHandle = pHandle;

    return ERROR_SUCCESS;
}

long CShortFileStagingFile::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;

    //
    // Get the thing pointed to by the iterator, unless it is past the end
    //

    return pIterationHandle->GetNext(pfd);
}

void CShortFileStagingFile::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;
    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        if(m_apIterators[i] == pIterationHandle)
        {
            m_apIterators.RemoveAt(i);
            delete pIterationHandle;
            return;
        }
    }


    _ASSERT(false, L"Non-existent iteration handle is closed");
}

long CShortFileStagingFile::ConstructInstructionFromType(int nType,
                                CStageInstruction** ppInst)
{
    CShortFileInstruction* pInst = NULL;
    switch(nType)
    {
        case A51_INSTRUCTION_TYPE_CREATEFILE:
            pInst = new CCreateFile(this);
            break;
        case A51_INSTRUCTION_TYPE_DELETEFILE:
            pInst = new CDeleteFile(this);
            break;
        case A51_INSTRUCTION_TYPE_REMOVEDIRECTORY:
            pInst = new CRemoveDirectory(this);
            break;
        default:
            return ERROR_RXACT_INVALID_STATE;
    }

    if(pInst == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pInst->AddRef();
    *ppInst = pInst;
    return ERROR_SUCCESS;
}

CShortFileStagingFile::TIterator CShortFileStagingFile::EraseIterator(
                                    CShortFileStagingFile::TIterator it)
{
    //
    // In order to safely remove an iterator, we need to make sure that
    // no iteration handle is standing on it
    //

    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        CIterationHandle* pHandle = m_apIterators[i];
        if(pHandle->m_it == it)
        {
            //
            // Advance it to the next position, since this one is dead
            //

            pHandle->m_it++;
        }
    }

    //
    // It is now safe to remove the element
    //
     
    return m_map.erase(it);
}

CShortFileStagingFile::CIterationHandle::CIterationHandle(
                    CShortFileStagingFile::TMap& rMap,
                    const CShortFileStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix)
    : m_rMap(rMap), m_it(rIt)
{
    wcscpy(m_wszPrefix, wszPrefix);
    m_dwPrefixLen = wcslen(wszPrefix);

    //
    // Compute the length of the directory portion of the prefix
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        m_dwPrefixDirLen = 0;
    else
        m_dwPrefixDirLen = pwcLastSlash - wszPrefix + 1;
}

long CShortFileStagingFile::CIterationHandle::GetNext(WIN32_FIND_DATAW* pfd)
{
    //
    // Repeat while we are not at the end of the list or past the prefix
    //

    while(m_it != m_rMap.end() && 
            !wcsncmp(m_it->first, m_wszPrefix, m_dwPrefixLen))
    {
        CShortFileInstruction* pInst = m_it->second;
        
        //
        // Ignore deletioin requests
        //

        if(!m_it->second->IsDeletion())
        {
            //
            // Copy the file name (ignoring dir) into the variable
            //

            wcscpy(pfd->cFileName, 
                    m_it->second->GetFilePath() + m_dwPrefixDirLen);
            pfd->dwFileAttributes = 0;
			m_it++;
            return ERROR_SUCCESS;
        }
		m_it++;
    }

    return ERROR_NO_MORE_FILES;
}

long CShortFileStagingFile::WriteActualFile(LPCWSTR wszFileName, DWORD dwLen, 
                                        BYTE* pBuffer)
{
#ifdef A51_USE_HEAP
    return m_pCache->GetObjectHeap()->WriteFile(wszFileName, dwLen, pBuffer);
#else
    return A51WriteFile(wszFileName, dwLen, pBuffer);
#endif
}

long CShortFileStagingFile::DeleteActualFile(LPCWSTR wszFileName)
{
#ifdef A51_USE_HEAP
    return m_pCache->GetObjectHeap()->DeleteFile(wszFileName);
#else
    return A51DeleteFile(wszFileName);
#endif
}

long CShortFileStagingFile::RemoveActualDirectory(LPCWSTR wszFileName)
{
#ifdef A51_USE_HEAP
    return ERROR_SUCCESS;
#else
    return A51RemoveDirectory(wszFileName);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\stage.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include <sync.h>
#include <malloc.h>
#include "stage.h"
#include "filecach.h"


#define A51_TAIL_SIZE sizeof(DWORD)

#define A51_INSTRUCTION_TYPE_TAIL 0
#define A51_INSTRUCTION_TYPE_CREATEFILE 1
#define A51_INSTRUCTION_TYPE_DELETEFILE 2
#define A51_INSTRUCTION_TYPE_REMOVEDIRECTORY 3
#define A51_INSTRUCTION_TYPE_ENDTRANSACTION 10 

int g_nNumRecords;
int g_nTotalMemory;
int g_nNumRecordsMax = 0;
int g_nTotalMemoryMax = 0;

CTempMemoryManager g_FileCacheManager;

CFileInstruction::CFileInstruction(CRealStagingFile* pFile)
    : m_pFile(pFile), m_lRef(0), m_wszFilePath(NULL), m_lFileOffset(-1),
        m_bCommitted(false)
{
    g_nNumRecords++;
    if(g_nNumRecords > g_nNumRecordsMax)
        g_nNumRecordsMax = g_nNumRecords;
}
    
long CFileInstruction::Initialize(LPCWSTR wszFilePath)
{
    int nFilePathLen = wcslen(wszFilePath);
    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager, (nFilePathLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    wcscpy(m_wszFilePath, wszFilePath);

    g_nTotalMemory += (nFilePathLen+1) * sizeof(WCHAR);
    if(g_nTotalMemory > g_nTotalMemoryMax)
        g_nTotalMemoryMax = g_nTotalMemory;
    
    return ERROR_SUCCESS;
}

CFileInstruction::~CFileInstruction()
{
    g_nNumRecords--;
    if (m_wszFilePath)
    {
        int nFilePathLen = wcslen(m_wszFilePath);
        g_nTotalMemory -= (nFilePathLen+1) * sizeof(WCHAR);
        TempFree(g_FileCacheManager, m_wszFilePath, (nFilePathLen+1)*sizeof(WCHAR));
    }
}


DWORD CFileInstruction::ComputeSpaceForName()
{
    return sizeof(DWORD) + wcslen(m_wszFilePath) * sizeof(WCHAR);
}

BYTE* CFileInstruction::WriteFileName(BYTE* pStart)
{
    DWORD dwStringLen = wcslen(m_wszFilePath);
    memcpy(pStart, (void*)&dwStringLen, sizeof(DWORD));
    pStart += sizeof(DWORD);
    memcpy(pStart, m_wszFilePath, dwStringLen * sizeof(WCHAR));

    return pStart + dwStringLen * sizeof(WCHAR);
}

long CFileInstruction::RecoverFileName(HANDLE hFile)
{
    _ASSERT(m_wszFilePath == NULL, 
            L"Double initialization of a file instruction!");
    //
    // Read the length
    //

    DWORD dwStringLen = 0;
    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&dwStringLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // Read the file name
    //

    m_wszFilePath = (WCHAR*)TempAlloc(g_FileCacheManager,
                                        (dwStringLen+1) * sizeof(WCHAR));
    if(m_wszFilePath == NULL)
        return ERROR_OUTOFMEMORY;
    
    if(!ReadFile(hFile, (BYTE*)m_wszFilePath, dwStringLen * sizeof(WCHAR),
                    &dwRead, NULL))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return GetLastError();
    }

    if(dwRead != dwStringLen * sizeof(WCHAR))
    {
        TempFree(m_wszFilePath, (dwStringLen+1) * sizeof(WCHAR));
        return ERROR_HANDLE_EOF;
    }

    m_wszFilePath[dwStringLen] = 0;

    g_nTotalMemory += (wcslen(m_wszFilePath)+1) * sizeof(WCHAR);
    if(g_nTotalMemory > g_nTotalMemoryMax)
        g_nTotalMemoryMax = g_nTotalMemory;

    return ERROR_SUCCESS;
}
        
    

void CFileInstruction::ComputeFullPath(wchar_t *wszFullPath)
{
    wcscpy(wszFullPath, m_pFile->GetBase());
    wcscat(wszFullPath, m_wszFilePath);
}



CCreateFile::CCreateFile(CRealStagingFile* pFile)
    : CFileInstruction(pFile), m_dwFileLen(0), m_dwFileStart(0)
{
}

void* CCreateFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CCreateFile));
}

void CCreateFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CCreateFile));
}

long CCreateFile::Initialize(LPCWSTR wszFilePath, DWORD dwFileLen)
{
    long lRes = CFileInstruction::Initialize(wszFilePath);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    m_dwFileLen = dwFileLen;
    return ERROR_SUCCESS;
}

DWORD CCreateFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the type
                ComputeSpaceForName() + // for the file name
                sizeof(DWORD) + // for the length of data
                m_dwFileLen + // for the data
                A51_TAIL_SIZE; // for the trailer
}
                    
long CCreateFile::Write(TFileOffset lOffset, BYTE* pBuffer)
{
    if(pBuffer)
        memcpy(&m_dwFileStart, pBuffer, sizeof(DWORD));
    else
        m_dwFileStart = 0;

    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_CREATEFILE;
    pCurrent++;

    // 
    // Write the name of the file
    //

    pCurrent = WriteFileName(pCurrent);
    
    //
    // Write the length of the data for the file
    //

    memcpy(pCurrent, (void*)&m_dwFileLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    //
    // Write the data itself and record its offset
    //

    memcpy(pCurrent, pBuffer, m_dwFileLen);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent + m_dwFileLen, 0, sizeof(DWORD));
    
    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CCreateFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name first
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the length of the data from the file
    //

    DWORD dwRead;

    if(!ReadFile(hFile, (BYTE*)&m_dwFileLen, sizeof(DWORD), &dwRead, NULL))
        return GetLastError();

    if(dwRead != sizeof(DWORD))
        return ERROR_HANDLE_EOF;

    //
    // We do not need to actually read the data from the file --- we keep it
    // there until it is time to flush.  But we do need to skip it.  At the same
    // time, we need to record the position in the file where this data resides
    //

    LARGE_INTEGER liFileLen;
    liFileLen.QuadPart = m_dwFileLen;
    
    LARGE_INTEGER liNewPosition;
    if(!SetFilePointerEx(hFile, liFileLen, &liNewPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liNewPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liNewPosition.QuadPart - m_dwFileLen);
    return ERROR_SUCCESS;
}

long CCreateFile::GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer)
{
	//
	// Lock the file
	//

	CInCritSec ics(m_pFile->GetLock());

	_ASSERT(m_pFile->m_lFirstFreeOffset >= m_lFileOffset, 
            L"Instruction points to empty space in stage file");

    if(pdwLen)
        *pdwLen = m_dwFileLen;

    if(ppBuffer == NULL)
        return ERROR_SUCCESS;

    //
    // Allocate the buffer
    //

    *ppBuffer = (BYTE*)TempAlloc(m_dwFileLen);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = A51ReadFromFileSync(hFile, m_lFileOffset, *ppBuffer, m_dwFileLen);
    if(lRes != ERROR_SUCCESS)
    {
        delete *ppBuffer;
        return lRes;
    }

    if(m_dwFileLen && m_dwFileStart && memcmp(*ppBuffer, &m_dwFileStart, sizeof(DWORD)))
    {
        _ASSERT(false, L"Stage file overwritten");
        TempFree(*ppBuffer, m_dwFileLen);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}

    
long CCreateFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    long lRes;

    //
    // Read the data from the staging file
    //

    BYTE* pBuffer = NULL;
    lRes = GetData(m_pFile->GetHandle(), NULL, &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    CTempFreeMe vdm(pBuffer, m_dwFileLen);
    
    return m_pFile->WriteActualFile(wszFullPath, m_dwFileLen, pBuffer);
}


CDeleteFile::CDeleteFile(CRealStagingFile* pFile)
    : CFileInstruction(pFile)
{
}

void* CDeleteFile::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CDeleteFile));
}

void CDeleteFile::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CDeleteFile));
}

long CDeleteFile::Initialize(LPCWSTR wszFileName)
{
    return CFileInstruction::Initialize(wszFileName);
}

DWORD CDeleteFile::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CDeleteFile::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write the instruction type
    //
    
    *pCurrent = A51_INSTRUCTION_TYPE_DELETEFILE;
    pCurrent++;
    
    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CDeleteFile::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CDeleteFile::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Delete the right file
    //

    long lRes = m_pFile->DeleteActualFile(wszFullPath);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
        return lRes;
    else
        return ERROR_SUCCESS;
}


CRemoveDirectory::CRemoveDirectory(CRealStagingFile* pFile)
    : CFileInstruction(pFile)
{
}

void* CRemoveDirectory::operator new(size_t) 
{
    return TempAlloc(g_FileCacheManager, sizeof(CRemoveDirectory));
}

void CRemoveDirectory::operator delete(void* p) 
{
    return TempFree(g_FileCacheManager, p, sizeof(CRemoveDirectory));
}

long CRemoveDirectory::Initialize(LPCWSTR wszFileName)
{
    return CFileInstruction::Initialize(wszFileName);
}

DWORD CRemoveDirectory::ComputeNeededSpace()
{
    return sizeof(BYTE) + // for the instruction type
            ComputeSpaceForName() + // for the file name
            A51_TAIL_SIZE; // for the trailer
}

long CRemoveDirectory::Write(TFileOffset lOffset)
{
    //
    // Construct an in-memory buffer large enough for the whole thing
    //

    DWORD dwNeededSpace = ComputeNeededSpace();
    BYTE* pWholeBuffer = (BYTE*)TempAlloc(dwNeededSpace);
    if(pWholeBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe vdm(pWholeBuffer, dwNeededSpace);

    BYTE* pCurrent = pWholeBuffer;

    //
    // Write instruction type
    //

    *pCurrent = A51_INSTRUCTION_TYPE_REMOVEDIRECTORY;
    pCurrent++;

    //
    // Write the file name
    //

    pCurrent = WriteFileName(pCurrent);
    m_lFileOffset = lOffset + (pCurrent - pWholeBuffer);

    //
    // Write the trailer
    //

    memset(pCurrent, 0, sizeof(DWORD));

    // 
    // Write it 
    //

    return m_pFile->WriteInstruction(lOffset, pWholeBuffer, dwNeededSpace);
}

long CRemoveDirectory::RecoverData(HANDLE hFile)
{
    //
    // Recover the file name 
    //

    long lRes = CFileInstruction::RecoverFileName(hFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    LARGE_INTEGER liPosition;
    if(!SetFilePointerEx(hFile, liZero, &liPosition, FILE_CURRENT))
        return GetLastError();

    _ASSERT(liPosition.HighPart == 0, L"Staging file too long!");

    m_lFileOffset = (long)(liPosition.QuadPart);
    return ERROR_SUCCESS;
}
    
long CRemoveDirectory::Execute()
{
    //
    // Construct full path
    //

    CFileName wszFullPath;
	if (wszFullPath == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeFullPath(wszFullPath);

    //
    // Remove the directory
    //

    long lRes = m_pFile->RemoveActualDirectory(wszFullPath);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND &&
        lRes != ERROR_DIR_NOT_EMPTY)
    {
        return lRes;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}



CRealStagingFile::CRealStagingFile(CFileCache* pCache,
                                                LPCWSTR wszBaseName,
                                                long lMaxFileSize,
                                                long lAbortTransactionFileSize)
    : m_hFile(NULL), m_lFirstFreeOffset(-1), m_nTransactionIndex(0),
        m_bInTransaction(false), 
        m_map(TMap::key_compare(), TMap::allocator_type(&g_FileCacheManager)),
        m_qTransaction(TQueue::allocator_type(&g_FileCacheManager)),
        m_qToWrite(TQueue::allocator_type(&g_FileCacheManager)),
        m_stReplacedInstructions(TStack::allocator_type(&g_FileCacheManager)),
        m_lMaxFileSize(lMaxFileSize),
        m_lAbortTransactionFileSize(lAbortTransactionFileSize),
        m_bFailedBefore(false), m_lStatus(ERROR_SUCCESS),
        m_pCache(pCache)
{
    wcscpy(m_wszBaseName, wszBaseName);
}

CRealStagingFile::~CRealStagingFile()
{
    CloseHandle(m_hFile);
}

void CRealStagingFile::ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey)
{
    wbem_wcsupr(wszKey, wszFileName);
}

long CRealStagingFile::WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen)
{
    long lRes = A51WriteToFileSync(m_hFile, lStartingOffset, pBuffer,
                                dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Add the data to the currently running transaction hash.  Disregard the
    // trailer since it is going to be overwritten
    //

    MD5::ContinueTransform(pBuffer, dwBufferLen - A51_TAIL_SIZE, 
                            m_TransactionHash);

    return ERROR_SUCCESS;
}
    
long CRealStagingFile::BeginTransaction()
{    
    //
    // Wait for space in the staging file
    //

    long lRes = WaitForSpaceForTransaction();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ProcessBegin();
}

long CRealStagingFile::ProcessBegin()
{
    CInCritSec ics(&m_cs);

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    m_bInTransaction = true;


    return ERROR_SUCCESS;
}

long CRealStagingFile::CommitTransaction()
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;

    //
    // Check if there is even anything to commit
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    //
    // Write transaction trailer "instruction"
    //

    DWORD dwBufferSize = sizeof(BYTE) + // instruction type
                        sizeof m_TransactionHash // transaction hash
                        + A51_TAIL_SIZE; // trailer
    BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferSize);
    if(pBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pBuffer, dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    *(DWORD*)pBuffer = A51_INSTRUCTION_TYPE_ENDTRANSACTION;
    memcpy(pBuffer + sizeof(BYTE), m_TransactionHash, 
            sizeof m_TransactionHash);

    //
    // Write it out
    //

    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, pBuffer, 
                                dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_lFirstFreeOffset += dwBufferSize - A51_TAIL_SIZE;

    return ProcessCommit();
}

long CRealStagingFile::ProcessCommit()
{
    //
    // Now, transfer all instructions from the transaction queue to the main
    // queue for flushing.  Wake up the flushing thread if the main queue is 
    // empty
    //

    if(m_qToWrite.empty() && !m_qTransaction.empty())
        SignalPresense();

    while(!m_qTransaction.empty())
    {
        CFileInstruction* pInst = m_qTransaction.front();
        pInst->SetCommitted();
        m_qToWrite.push(pInst);
        m_qTransaction.pop();
    }

    //
    // Erase the stack of replaced instructions --- they are replaced for good
    //

    while(!m_stReplacedInstructions.empty())
    {
        m_stReplacedInstructions.top()->Release();
        m_stReplacedInstructions.pop();
    }

    //
    // Move transaction start pointer to the next free location
    //

    m_lTransactionStartOffset = m_lFirstFreeOffset;
    m_nTransactionIndex++;

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    return ERROR_SUCCESS;
}

long CRealStagingFile::AbortTransaction()
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;

    //
    // Check if there is even anything to abort
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    ERRORTRACE((LOG_WBEMCORE, "Repository driver aborting transaction!\n"));

    //
    // Reset the first free pointer to the beginning of the transaction
    //

    m_lFirstFreeOffset = m_lTransactionStartOffset;

    //
    // Write termination marker there to simplify recovery.  It might not
    // be flushed, so recovery process does not rely on it, but still.
    //

    BYTE nType = A51_INSTRUCTION_TYPE_TAIL;
    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, &nType, 
                                    sizeof nType);
    // ignore return

    //
    // Discard all instructions in the transaction queue
    //

    while(!m_qTransaction.empty())
    {
        CFileInstruction* pInst = m_qTransaction.front();
        TIterator it = m_map.find(pInst->GetFilePath());
        if(it != m_map.end() && it->second == pInst)
        {
            // 
            // This instruction is currently in the map. Remove it, since
            // it has been cancelled. Of course, it may have replaced something
            // else originally, but that will be fixed shortly when we put back
            // all the replaced instructions
            //

            it->second->Release();
            EraseIterator(it);
        }

        m_qTransaction.front()->Release();
        m_qTransaction.pop();
    }

    //
    // Move all the records we have displaced from the map back into the map
    //

    while(!m_stReplacedInstructions.empty())
    {
        CFileInstruction* pInst = m_stReplacedInstructions.top();
        TIterator it = m_map.find(pInst->GetFilePath());
        if(it != m_map.end())
        {
            //
            // Note: we cannot just replace the pointer, since we are using its
            // member as the key!
            //
    
            it->second->Release();
            EraseIterator(it);
        }
    
        m_map[pInst->GetFilePath()] = pInst;
    
        /* Do not postpend the instruction on the queue, since we would not
            skip it for a non-committed instruction

        //
        // We need to also postpend it onto the flushing queue, since it may
        // have been skipped by the flusher.  Event if it was not, postpending
        // it is no big deal --- we know that nobody had overwritten it in the
        // interleaving time because it was in the map (and therefore current)
        // when we started the transaction
        //

        m_qToWrite.push(pInst);
        pInst->AddRef();
        */

        m_stReplacedInstructions.pop();
    }

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    //
    // Check if the flushing thread caught up with us, but could not reset the
    // staging file because we had some things on the queue.
    //

    if(m_qToWrite.empty() && m_lFirstFreeOffset != sizeof(__int64))
    {
        ERRORTRACE((LOG_WBEMCORE, "Resetting first free offset in abort"));
        WriteEmpty();
    }

    return ERROR_SUCCESS;
}
    

long CRealStagingFile::WriteFile(LPCWSTR wszFileName, DWORD dwLen, 
                                        BYTE* pBuffer)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
	return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CCreateFile* pInst = new CCreateFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey, dwLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset, pBuffer);
        if(lRes)
            return lRes;
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CRealStagingFile::DeleteFile(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    CDeleteFile* pInst = new CDeleteFile(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
            return lRes;
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }
    return lRes;
}

long CRealStagingFile::RemoveDirectory(LPCWSTR wszFileName)
{
    long lRes;
    CFileName wszKey;
    if (wszKey == NULL)
        return ERROR_OUTOFMEMORY;

    ComputeKey(wszFileName, wszKey);

    CRemoveDirectory* pInst = new CRemoveDirectory(this);
    if(pInst == NULL)
        return ERROR_OUTOFMEMORY;
    pInst->AddRef();
    CTemplateReleaseMe<CFileInstruction> rm1(pInst);

    lRes = pInst->Initialize(wszKey);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    DWORD dwSpaceNeeded = pInst->ComputeNeededSpace();

    if(!CanWriteInTransaction(dwSpaceNeeded))
        return ERROR_NOT_ENOUGH_QUOTA;

    {
        CInCritSec ics(&m_cs);

        //
        // Write all the data into the staging area
        //
    
        lRes = pInst->Write(m_lFirstFreeOffset);
        if(lRes)
        {
            m_cs.Leave();
            return lRes;
        }
    
        //
        // Write the new offset into the offset file
        //
    
        m_lFirstFreeOffset += dwSpaceNeeded - A51_TAIL_SIZE;
    
        lRes = AddInstruction(pInst);
    }

    return lRes;
}


// assumes: locked
long CRealStagingFile::AddInstruction(CFileInstruction* pInst)
{
    //
    // Add the instruction to the transaction queue.  It will be moved into 
    // flushable queue when transaction commits
    //

    pInst->AddRef();
    m_qTransaction.push(pInst);

    //
    // Now, add the structure to the map for lookup
    //

    pInst->AddRef();

    TIterator it = m_map.find(pInst->GetFilePath());
    if(it != m_map.end())
	{
        //
        // It is already there.  We need to replace that instruction with our
        // own.  However, if that instruction was committed, we should remember
        // it in case our transaction aborts.
		// Note: we cannot just replace the pointer, since we are using its
		// member as the key!
        //
        // The extra quirk here is that we should not be doing this if the 
        // instruction being replaced came from our own transaction.  This is
        // not an empty optimization --- if we do and the transaction aborts,
        // we may end up attempting to execute this one even though its body
        // is in the garbaged area of the staging file
        //

        if(it->second->IsCommitted())
        {
            m_stReplacedInstructions.push(it->second); // transferred ref-count
        }
        else
        {
            it->second->Release();
        }
        EraseIterator(it);
	}

    m_map[pInst->GetFilePath()] = pInst;

    //
    // Now, if we are not transacted, commit!
    //

    if(!m_bInTransaction)
    {
        long lRes = CommitTransaction();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    return ERROR_SUCCESS;
}

long CRealStagingFile::WaitForSpaceForTransaction()
{
    while(1) // TBD: consider timing out
    {
        {
            CInCritSec ics(&m_cs);

            long lRes = CanStartNewTransaction();
            if(lRes == ERROR_SUCCESS)
                return ERROR_SUCCESS;
            else if(lRes != ERROR_IO_PENDING)
                return lRes;
        }
        Sleep(100);
    }

    // Can't happen for now
    return ERROR_INTERNAL_ERROR;
}

long CRealStagingFile::ReadFile(LPCWSTR wszFileName, DWORD* pdwLen, 
                                BYTE** ppBuffer, bool bMustBeThere)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFileName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return ERROR_NO_INFORMATION;
    }
    else
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
        {
            if(bMustBeThere)
            {
                Dump();
                _ASSERT(false, L"Must-be-present file is not there. Dumped");
            }
            return ERROR_FILE_NOT_FOUND;
        }
        else
        {
            long lRes = ((CCreateFile*)pInstruction)->GetData(m_hFile, pdwLen, 
                                                                ppBuffer);
            return lRes;
        }
    }
}

void CRealStagingFile::Dump()
{
    FILE* f = fopen("c:\\a.dmp", "a");
    fprintf(f, "MAP:\n");
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());
        it++;
    }

    fprintf(f, "LIST:\n");

    int nSize = m_qToWrite.size();
    for(int i = 0; i < nSize; i++)
    {
        CFileInstruction* pInstruction = m_qToWrite.front();
        if(pInstruction->IsDeletion())
            fprintf(f, "Delete ");
        else
            fprintf(f, "Create ");

        fprintf(f, "%S\n", pInstruction->GetFilePath());

        m_qToWrite.pop();
        m_qToWrite.push(pInstruction);
    }

    fclose(f);
}

long CRealStagingFile::IsDeleted(LPCWSTR wszFilePath)
{
    CInCritSec ics(&m_cs);

    // 
    // Search for the file
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePath, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        return S_FALSE;
    }
    else
    {
        CFileInstruction* pInstruction = it->second;
        if(pInstruction->IsDeletion())
            return S_OK;
        else
            return S_FALSE;
    }
}
    

long CRealStagingFile::FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    CInCritSec ics(&m_cs);

    //
    // Compute the key for the prefix --- key computation is such that the 
    // keys come in the same lexicographic order as the names, so this will 
    // give us the lower bound for the search
    //

    CFileName wszKey;
	if (wszKey == NULL)
		return ERROR_OUTOFMEMORY;
    ComputeKey(wszFilePrefix, wszKey);

    //
    // Find this spot in the map
    //

    TIterator it = m_map.lower_bound(wszKey);
    if(it == m_map.end())
        return ERROR_FILE_NOT_FOUND;

    //
    // Retrieve the first element
    // 

    CIterationHandle* pHandle = new CIterationHandle(m_map, it, wszKey);
    if(pHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    long lRes = pHandle->GetNext(pfd);
    if(lRes != ERROR_SUCCESS)
    {
        delete pHandle;
        if(lRes == ERROR_NO_MORE_FILES)
            lRes = ERROR_FILE_NOT_FOUND;

        return lRes;
    }

    m_apIterators.Add(pHandle);
    *ppHandle = pHandle;

    return ERROR_SUCCESS;
}

long CRealStagingFile::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;

    //
    // Get the thing pointed to by the iterator, unless it is past the end
    //

    return pIterationHandle->GetNext(pfd);
}

void CRealStagingFile::FindClose(void* pHandle)
{
    CInCritSec ics(&m_cs);

    //
    // The "handle" is really an iteration handle pointer
    //

    CIterationHandle* pIterationHandle = (CIterationHandle*)pHandle;
    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        if(m_apIterators[i] == pIterationHandle)
        {
            m_apIterators.RemoveAt(i);
            delete pIterationHandle;
            return;
        }
    }


    _ASSERT(false, L"Non-existent iteration handle is closed");
}

int CRealStagingFile::GetStagingFileHeaderSize()
{
    return sizeof(m_nTransactionIndex);
}

bool CRealStagingFile::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);

    return (m_lFirstFreeOffset == GetStagingFileHeaderSize());
}

bool CRealStagingFile::CanWriteInTransaction(DWORD dwNeeded)
{
    if(m_lFirstFreeOffset + dwNeeded > m_lAbortTransactionFileSize)
        return false;
    else
        return true;
}

long CRealStagingFile::CanStartNewTransaction()
{
    //
    // Check if the staging file is currently in trouble --- failing to execute
    // an instruction.  If so, refuse to start this transaction
    //

    if(m_lStatus != ERROR_SUCCESS)
        return m_lStatus;
    if(m_lFirstFreeOffset < m_lMaxFileSize)
        return ERROR_SUCCESS;
    else
        return ERROR_IO_PENDING;
}

void CRealStagingFile::SetMaxFileSize(long lMaxFileSize,
                                            long lAbortTransactionFileSize)
{
    m_lMaxFileSize = lMaxFileSize;
    m_lAbortTransactionFileSize = lAbortTransactionFileSize;
}


long CRealStagingFile::RecoverStage(HANDLE hFile)
{
    long lRes;
    DWORD dwRead;

    //
    // Read the starting transaction index
    //

    if(!::ReadFile(hFile, &m_nTransactionIndex, 
                    sizeof m_nTransactionIndex, &dwRead, NULL))
    {
        return GetLastError();
    }

    if(dwRead == 0)
    {
        // 
        // Empty file.  Write the trailer and we are done
        //

        m_nTransactionIndex = 1;

        lRes = WriteEmpty();
        if(lRes != ERROR_SUCCESS)
            return lRes;
        return lRes;
    }

    m_lFirstFreeOffset = GetStagingFileHeaderSize();

    //
    // Read complete transactions from the file until the end or until a 
    // corruption is found
    //

    lRes = ProcessBegin();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    while((lRes = RecoverTransaction(hFile)) == ERROR_SUCCESS)
    {
        lRes = ProcessCommit();
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = ProcessBegin();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    if(lRes != ERROR_NO_MORE_ITEMS)
    {
        AbortTransaction();
        ERRORTRACE((LOG_WBEMCORE, "Incomplete or invalid transaction is "
            "found in the journal.  It and all subsequent transactions "
            "will be rolled back\n"));
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}
        
BYTE CRealStagingFile::ReadNextInstructionType(HANDLE hFile)
{
    BYTE nType;
    DWORD dwLen;
    if(!::ReadFile(hFile, &nType, sizeof nType, &dwLen, NULL))
        return -1;
    if(dwLen != sizeof nType)
        return -1;
    return nType;
}
    
long CRealStagingFile::RecoverTransaction(HANDLE hFile)
{
    long lRes;

    //
    // Remember the current file position to be able to go back
    //

    LARGE_INTEGER liStart;
    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    if(!SetFilePointerEx(hFile, liZero, &liStart, FILE_CURRENT))
        return GetLastError();

    LARGE_INTEGER liInstructionStart = liStart;

    //
    // Read instructions until the end of transaction or an invalid instruction
    //

    int nNumInstructions = 0;

    BYTE nInstructionType;
    while((nInstructionType = ReadNextInstructionType(hFile)) != 
            A51_INSTRUCTION_TYPE_ENDTRANSACTION)
    {
        //
        // Create an instruction of the appropriate type
        //

        CFileInstruction* pInst = NULL;
        switch(nInstructionType)
        {
            case A51_INSTRUCTION_TYPE_CREATEFILE:
                pInst = new CCreateFile(this);
                break;
            case A51_INSTRUCTION_TYPE_DELETEFILE:
                pInst = new CDeleteFile(this);
                break;
            case A51_INSTRUCTION_TYPE_REMOVEDIRECTORY:
                pInst = new CRemoveDirectory(this);
                break;
            default:
                if(nNumInstructions == 0)
                    return ERROR_NO_MORE_ITEMS;
                else
                    return ERROR_RXACT_INVALID_STATE;
        }

        if(pInst == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pInst->AddRef();
        CTemplateReleaseMe<CFileInstruction> rm1(pInst);
        
        //
        // Get it to read its data from the file
        //

        lRes = pInst->RecoverData(hFile);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = AddInstruction(pInst);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        //
        // Hash its body into the transaction
        //

        LARGE_INTEGER liInstructionEnd;
        if(!SetFilePointerEx(hFile, liZero, &liInstructionEnd, FILE_CURRENT))
            return GetLastError();

        if(!SetFilePointerEx(hFile, liInstructionStart, NULL, FILE_BEGIN))
            return GetLastError();

        DWORD dwBufferLen = (DWORD)(liInstructionEnd.QuadPart - 
                                            liInstructionStart.QuadPart);
        
        BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferLen);
        if(pBuffer == NULL)
            return ERROR_OUTOFMEMORY;
        CTempFreeMe tfm(pBuffer, dwBufferLen);

        DWORD dwSizeRead;
        if(!::ReadFile(hFile, pBuffer, dwBufferLen, &dwSizeRead, NULL))
            return GetLastError();
    
        if(dwSizeRead != dwBufferLen)
            return ERROR_HANDLE_EOF;

        MD5::ContinueTransform(pBuffer, dwBufferLen, m_TransactionHash);

        liInstructionStart = liInstructionEnd;
        nNumInstructions++;
    }

    //
    // Read the hash that the end-of-transaction marker thinks we should have
    // gotten
    //

    BYTE DesiredHash[16];
    DWORD dwSizeRead;
    if(!::ReadFile(hFile, DesiredHash, sizeof DesiredHash, &dwSizeRead, NULL))
        return GetLastError();

    if(dwSizeRead != sizeof DesiredHash)
        return ERROR_HANDLE_EOF; 
    
    //
    // Compare them
    //

    if(memcmp(DesiredHash, m_TransactionHash, sizeof DesiredHash))
        return ERROR_RXACT_INVALID_STATE;

    //
    // Everything checked out --- set member variables for end of transaction
    //

    m_lFirstFreeOffset = (LONG)liInstructionStart.QuadPart;
    return ERROR_SUCCESS;
}

long CRealStagingFile::Create(LPCWSTR wszFileName)
{
    long lRes;

    //
    // Open the file itself
    //

    m_hFile = CreateFileW(wszFileName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 
                FILE_FLAG_OVERLAPPED, 
                NULL);

    if(m_hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    m_hFlushFile = m_hFile;

    m_lFirstFreeOffset = 0;

    //
    // Open a special synchronous handle to the same file for convenience
    //

    HANDLE hRecoveryFile = CreateFileW(wszFileName, 
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 
                NULL);

    if(hRecoveryFile == INVALID_HANDLE_VALUE)
        return GetLastError();
    CCloseMe cm(hRecoveryFile);

    lRes = RecoverStage(hRecoveryFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CRealStagingFile::WriteEmpty()
{
    //
    // Construct a buffer consisting of the transaction index and a 0 for the
    // end-instruction
    //

    DWORD dwBufferSize = sizeof m_nTransactionIndex + A51_TAIL_SIZE;
    BYTE* pBuffer = (BYTE*)_alloca(dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    memcpy(pBuffer, &m_nTransactionIndex, sizeof m_nTransactionIndex);

    long lRes = A51WriteToFileSync(m_hFile, 0, pBuffer, dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Have to flush it to make sure that old instructions are not replayed
    //

    if(!FlushFileBuffers(m_hFile))
        return GetLastError();

    m_lFirstFreeOffset = GetStagingFileHeaderSize();
    m_lTransactionStartOffset = m_lFirstFreeOffset;

    return ERROR_SUCCESS;
}

CRealStagingFile::TIterator CRealStagingFile::EraseIterator(
                                    CRealStagingFile::TIterator it)
{
    //
    // In order to safely remove an iterator, we need to make sure that
    // no iteration handle is standing on it
    //

    for(int i = 0; i < m_apIterators.GetSize(); i++)
    {
        CIterationHandle* pHandle = m_apIterators[i];
        if(pHandle->m_it == it)
        {
            //
            // Advance it to the next position, since this one is dead
            //

            pHandle->m_it++;
        }
    }

    //
    // It is now safe to remove the element
    //
     
    return m_map.erase(it);
}

CRealStagingFile::CIterationHandle::CIterationHandle(
                    CRealStagingFile::TMap& rMap,
                    const CRealStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix)
    : m_rMap(rMap), m_it(rIt)
{
    wcscpy(m_wszPrefix, wszPrefix);
    m_dwPrefixLen = wcslen(wszPrefix);

    //
    // Compute the length of the directory portion of the prefix
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPrefix, L'\\');
    if(pwcLastSlash == NULL)
        m_dwPrefixDirLen = 0;
    else
        m_dwPrefixDirLen = pwcLastSlash - wszPrefix + 1;
}

long CRealStagingFile::CIterationHandle::GetNext(WIN32_FIND_DATAW* pfd)
{
    //
    // Repeat while we are not at the end of the list or past the prefix
    //

    while(m_it != m_rMap.end() && 
            !wcsncmp(m_it->first, m_wszPrefix, m_dwPrefixLen))
    {
        CFileInstruction* pInst = m_it->second;
        
        //
        // Ignore deletioin requests
        //

        if(!m_it->second->IsDeletion())
        {
            //
            // Copy the file name (ignoring dir) into the variable
            //

            wcscpy(pfd->cFileName, 
                    m_it->second->GetFilePath() + m_dwPrefixDirLen);
            pfd->dwFileAttributes = 0;
			m_it++;
            return ERROR_SUCCESS;
        }
		m_it++;
    }

    return ERROR_NO_MORE_FILES;
}

long CRealStagingFile::WriteActualFile(LPCWSTR wszFileName, DWORD dwLen, 
                                        BYTE* pBuffer)
{
#ifdef A51_USE_HEAP
    return m_pCache->GetObjectHeap()->WriteFile(wszFileName, dwLen, pBuffer);
#else
    return A51WriteFile(wszFileName, dwLen, pBuffer);
#endif
}

long CRealStagingFile::DeleteActualFile(LPCWSTR wszFileName)
{
#ifdef A51_USE_HEAP
    return m_pCache->GetObjectHeap()->DeleteFile(wszFileName);
#else
    return A51DeleteFile(wszFileName);
#endif
}

long CRealStagingFile::RemoveActualDirectory(LPCWSTR wszFileName)
{
#ifdef A51_USE_HEAP
    return ERROR_SUCCESS;
#else
    return A51RemoveDirectory(wszFileName);
#endif
}


//******************************************************************************
//******************************************************************************
//                      EXECUTABLE FILE
//******************************************************************************
//******************************************************************************

CExecutableStagingFile::CExecutableStagingFile(CFileCache* pCache, 
                            LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize)
    : CRealStagingFile(pCache, wszBaseName, lMaxFileSize, 
                        lAbortTransactionFileSize),
        m_bExitNow(false), m_hEvent(NULL), m_hThread(NULL)
{
}

CExecutableStagingFile::~CExecutableStagingFile()
{
    m_bExitNow = true;
    SetEvent(m_hEvent);
    WaitForSingleObject(m_hThread, INFINITE);
    CloseHandle(m_hEvent);
    CloseHandle(m_hThread);
}

long CExecutableStagingFile::Create(LPCWSTR wszFileName)
{
    long lRes = CRealStagingFile::Create(wszFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Create a reading thread
    //

    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hEvent == NULL)
        return GetLastError();

    if(!m_qToWrite.empty())
        SignalPresense();

    DWORD dwId;
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)staticFlusher, 
                                (void*)this, 0, &m_dwThreadID);
    if(m_hThread == NULL)
        return GetLastError();

    SetThreadPriority(m_hThread, THREAD_PRIORITY_IDLE);

    return ERROR_SUCCESS;
}


void CExecutableStagingFile::SignalPresense()
{
    SetEvent(m_hEvent);
}

long CExecutableStagingFile::WriteEmpty()
{
    ResetEvent(m_hEvent);

    return CRealStagingFile::WriteEmpty();
}

    
DWORD CExecutableStagingFile::staticFlusher(void* pArg)
{
    // Sleep(20000);
    return ((CExecutableStagingFile*)pArg)->Flusher();
}

DWORD CExecutableStagingFile::Flusher()
{
    while(!m_bExitNow)
    {
        WaitForSingleObject(m_hEvent, INFINITE);
        
        Flush();
    }
    return 0;
}

long CExecutableStagingFile::Flush()
{
    long lRes;

    //
    // Must flash when starting a new transaction
    //

    long lFlushLevel = m_lTransactionStartOffset;

    if(!FlushFileBuffers(m_hFlushFile))
        DebugBreak();

    while(1)
    {
        if(m_bExitNow)
            return ERROR_SUCCESS;

        //
        // Get the next instruction from the queue
        //

        CFileInstruction* pInst = NULL;

        {
            CInCritSec ics(&m_cs);
        
            if(m_qToWrite.empty())
            {
                //
                // Reset generation only if there are no instructions on the
                // transaction queue!
                //

                if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                {
                    WriteEmpty();
                }
                return ERROR_SUCCESS;
            }

            pInst = m_qToWrite.front();

            //  
            // Check if it is in the map.  The reason it might not be there
            // is if it was superceeded by some later instruction over the same 
            // file.  In that case, we should not execute it, but rather simply 
            // skip it.
            //
            
            TIterator it = m_map.find(pInst->GetFilePath()); // Make KEY
            _ASSERT(it != m_map.end(), L"Instruction in queue not in map");

            if(it->second != pInst && it->second->IsCommitted())
            {
				pInst->Release();
                m_qToWrite.pop();
                continue;
            }
        }
            
        //
        // Flush if needed
        //
    
        if(pInst->GetFileOffset() > lFlushLevel)
        {
            lFlushLevel = m_lTransactionStartOffset;

            if(!FlushFileBuffers(m_hFlushFile))
                DebugBreak();
        }

        //
        // Execute it
        //

        lRes = pInst->Execute();
        if(lRes != ERROR_SUCCESS)
        {
            //
            // We cannot continue until we succeed in executing this
            // instruction.  Therefore, we keep it on the queue and keep 
            // re-executing it.  If an instruction fails twice in a row, we 
            // enter a "failed state" and refuse all new transactions until the
            // condition is cleared
            //

            if(m_bFailedBefore)
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver repeatedly failed "
                            "to execute an instruction with error code %d.\n"
                            "Further processing is suspended until the problem "
                            "is corrected\n", lRes));
                m_lStatus = lRes;
            }
            else
            {
                ERRORTRACE((LOG_WBEMCORE, "Repository driver failed "
                            "to execute an instruction with error code %d.\n",
                            lRes));
                m_bFailedBefore = true;
            }

            //
            // Wait a bit before retrying
            //
    
            Sleep(100);
            continue;
        }
        else
        {
            m_bFailedBefore = false;
            m_lStatus = ERROR_SUCCESS;
        }
        
        //  
        // Remove it from the map, if there.  The reason it might not be there
        // is if it was superceeded by some later instruction over the same 
        // file.  We could check this before we executed it, but it wouldn't 
        // help much since the overriding instruction could have come in while
        // we were executing.  Also, there might be issues with instructions
        // constantly overriding each other and us never writing anything 
        // because of that...
        //
            
        {
            //
            // Here, we are going to be removing the instruction from the 
            // map.  We must lock the entire file cache to prevent the reader
            // from missing both the side effects (we executed without locking)
            // and the instruction itself if it is removed before the reader
            // gets a chance to lock the stage in IsDeleted.
            //

            CInCritSec ics(m_pCache->GetLock());
            {
                CInCritSec ics(&m_cs);
    
                TIterator it = m_map.find(pInst->GetFilePath()); // Make KEY
                _ASSERT(it != m_map.end(), L"Instruction in queue not in map");
    
                if(it->second == pInst)
                {
                    EraseIterator(it);
                    pInst->Release();
                }

                //
                // Remove it from the queue
                //

                m_qToWrite.pop();
                pInst->Release();

                if(m_qToWrite.empty())
                {
                    //
                    // Reset generation only if there are no instructions on the
                    // transaction queue!
                    //

                    if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                    {
                        WriteEmpty();
                    }
                    return ERROR_SUCCESS;
                }
            }
        }
    }

    _ASSERT(false, L"Out of an infinite loop!");
    return ERROR_INTERNAL_ERROR;
}
                
//******************************************************************************
//******************************************************************************
//                     PERMANENT FILE
//******************************************************************************
//******************************************************************************

CPermanentStagingFile::CPermanentStagingFile(CFileCache* pCache, 
                                                LPCWSTR wszBaseName)
    : CRealStagingFile(pCache, wszBaseName, 0x7FFFFFFF, 0x7FFFFFFF)
{
}

CPermanentStagingFile::~CPermanentStagingFile()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\stagemgr.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include <sync.h>
#include <malloc.h>
#include <reposit.h>
#include "stagemgr.h"
#include "filecach.h"



#define A51_INSTRUCTION_TYPE_TAIL 0
#define A51_INSTRUCTION_TYPE_ENDTRANSACTION 10 

CTempMemoryManager g_StageManager;

CStageManager::CStageManager(long lMaxFileSize, long lAbortTransactionFileSize)
    : m_hFile(NULL), m_hFlushFile(NULL),
        m_lFirstFreeOffset(-1), m_nTransactionIndex(0),
        m_bInTransaction(false), 
        m_qTransaction(TQueue::allocator_type(&g_StageManager)),
        m_qToWrite(TQueue::allocator_type(&g_StageManager)),
        m_stReplacedInstructions(TStack::allocator_type(&g_StageManager)),
        m_lMaxFileSize(lMaxFileSize),
        m_lAbortTransactionFileSize(lAbortTransactionFileSize),
        m_bFailedBefore(false), m_lStatus(ERROR_SUCCESS),
        m_bMustFail(false), m_bNonEmptyTransaction(false),
		m_lTransactionStartOffset(sizeof(__int64)),
		m_bInit(FALSE)
{
}

CStageManager::~CStageManager()
{
}

long 
CStageManager::_Start()
{    
    // beware, certain values are initialized by ::Create, 
    // called before _Start
        
    m_bInTransaction = false; 
    
    m_bFailedBefore = false;
    m_lStatus = ERROR_SUCCESS;
    m_bMustFail = false;
    m_bNonEmptyTransaction = false;
    
    return ERROR_SUCCESS;
}

long 
CStageManager::_Stop(DWORD dwShutdownFlags)
{
    //
    // you van hold this CritSec, since the flusher threads is out
    //
    CInCritSec ics(&m_cs);
    
    if (m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }

    if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwShutdownFlags)
    {
        m_qToWrite.clear();
        _ASSERT(m_stReplacedInstructions.empty(),"m_stReplacedInstructions.empty()");
        m_qTransaction.clear();
    }
       
    return ERROR_SUCCESS;    
}

long CStageManager::WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen, bool bSkipTailAdjustment)
{
    long lRes = A51WriteToFileSync(m_hFile, lStartingOffset, pBuffer,
                                dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Add the data to the currently running transaction hash.  Disregard the
    // trailer since it is going to be overwritten
    //

	if (bSkipTailAdjustment)
	{
		MD5::ContinueTransform(pBuffer, dwBufferLen, 
								m_TransactionHash);
	}
	else
	{
		MD5::ContinueTransform(pBuffer, dwBufferLen - A51_TAIL_SIZE, 
								m_TransactionHash);
	}

    return ERROR_SUCCESS;
}
    
long CStageManager::BeginTransaction()
{    
    //
    // Wait for space in the staging file
    //

    long lRes = WaitForSpaceForTransaction();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ProcessBegin();
}

long CStageManager::ProcessBegin()
{
    CInCritSec ics(&m_cs);

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    m_bInTransaction = true;


    return ERROR_SUCCESS;
}

long CStageManager::CommitTransaction()
{
    CInCritSec ics(&m_cs);

    _ASSERT(!m_bMustFail, L"Somebody ignored an error!");

    m_bInTransaction = false;
    m_bNonEmptyTransaction = false;

    //
    // Check if there is even anything to commit
    //

    if(m_qTransaction.empty())
        return ERROR_SUCCESS;

    //
    // Write transaction trailer "instruction"
    //

    DWORD dwBufferSize = sizeof(BYTE) + // instruction type
                        sizeof m_TransactionHash // transaction hash
                        + A51_TAIL_SIZE; // trailer
    BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferSize);
    if(pBuffer == NULL)
        return ERROR_OUTOFMEMORY;
    CTempFreeMe tfm(pBuffer, dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    *(DWORD*)pBuffer = A51_INSTRUCTION_TYPE_ENDTRANSACTION;
    memcpy(pBuffer + sizeof(BYTE), m_TransactionHash, 
            sizeof m_TransactionHash);

    //
    // Write it out
    //

    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, pBuffer, 
                                dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_lFirstFreeOffset += dwBufferSize - A51_TAIL_SIZE;

    return ProcessCommit();
}

long CStageManager::ProcessCommit()
{
    //
    // Now, transfer all instructions from the transaction queue to the main
    // queue for flushing.  Wake up the flushing thread if the main queue is 
    // empty
    //

    if(m_qToWrite.empty() && !m_qTransaction.empty())
        SignalPresense();

    while(!m_qTransaction.empty())
    {
        CStageInstruction* pInst = m_qTransaction.front();
        pInst->SetCommitted();
        m_qToWrite.push_back(pInst);
        m_qTransaction.pop_front();
    }

    //
    // Erase the stack of replaced instructions --- they are replaced for good
    //

    while(!m_stReplacedInstructions.empty())
    {
        m_stReplacedInstructions.top()->Release();
        m_stReplacedInstructions.pop();
    }

    //
    // Move transaction start pointer to the next free location
    //

    m_lTransactionStartOffset = m_lFirstFreeOffset;
    m_nTransactionIndex++;

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    return ERROR_SUCCESS;
}

void CStageManager::TouchTransaction()
{
    m_bNonEmptyTransaction = true;
}

long CStageManager::AbortTransaction(bool* pbNonEmpty)
{
    CInCritSec ics(&m_cs);

    m_bInTransaction = false;
    m_bMustFail = false;

    //
    // Check if there is even anything to abort
    //

    if(m_qTransaction.empty() && !m_bNonEmptyTransaction)
    {
        if(pbNonEmpty)
            *pbNonEmpty = false;
        return ERROR_SUCCESS;
    }

    m_bNonEmptyTransaction = false;

    if(pbNonEmpty)
        *pbNonEmpty = true;

    ERRORTRACE((LOG_WBEMCORE, "Repository driver aborting transaction!\n"));

    //
    // Reset the first free pointer to the beginning of the transaction
    //

    m_lFirstFreeOffset = m_lTransactionStartOffset;

    //
    // Write termination marker there to simplify recovery.  It might not
    // be flushed, so recovery process does not rely on it, but still.
    //

    BYTE nType = A51_INSTRUCTION_TYPE_TAIL;
    long lRes = A51WriteToFileSync(m_hFile, m_lFirstFreeOffset, &nType, 
                                    sizeof nType);
    // ignore return

    //
    // Discard all instructions in the transaction queue
    //

    // ERRORTRACE((LOG_WBEMCORE, "Instruction list:\n"));
    while(!m_qTransaction.empty())
    {
        CStageInstruction* pInst = m_qTransaction.front();
        
        RemoveInstructionFromMap(pInst);
        // pInst->Dump();
   
        m_qTransaction.front()->Release();
        m_qTransaction.pop_front();
    }
    // ERRORTRACE((LOG_WBEMCORE, "Replaced list:\n"));

    //
    // Move all the records we have displaced from the map back into the map
    //

    while(!m_stReplacedInstructions.empty())
    {
        CStageInstruction* pInst = m_stReplacedInstructions.top();
        // pInst->Dump();
        lRes = AddInstructionToMap(pInst, NULL); // no undoing...
        if(lRes != ERROR_SUCCESS)
        {
            //
            // Unable to put the old instruction back in the map --- totally
            // hosed
            //

            ReportTotalFailure();
            return ERROR_OUTOFMEMORY;
        }

        m_stReplacedInstructions.pop();
    }
    // ERRORTRACE((LOG_WBEMCORE, "Done\n"));

    //
    // Reset the digest
    //

    MD5::Transform(&m_nTransactionIndex, sizeof m_nTransactionIndex,
                    m_TransactionHash);

    //
    // Check if the flushing thread caught up with us, but could not reset the
    // staging file because we had some things on the queue.
    //

    if(m_qToWrite.empty() && m_lFirstFreeOffset != sizeof(__int64))
    {
        ERRORTRACE((LOG_WBEMCORE, "Resetting first free offset in abort\n"));
        WriteEmpty();
    }

    return ERROR_SUCCESS;
}
    

long CStageManager::AddInstruction(CStageInstruction* pInst)
{
    CInCritSec ics(&m_cs);

    //
    // Add the instruction to the transaction queue.  It will be moved into 
    // flushable queue when transaction commits
    //

    pInst->AddRef();
    try
    {
        m_qTransaction.push_back(pInst);
    }
    catch(...)
    {
        pInst->Release();
        return ERROR_OUTOFMEMORY;
    }

    //
    // Now, add the structure to the map for lookup
    //

    CStageInstruction* pUndoInstruction = NULL;
    long lRes = AddInstructionToMap(pInst, &pUndoInstruction);
    if(lRes != ERROR_SUCCESS)
    {
        m_qTransaction.pop_back();
        pInst->Release();
        return lRes;
    }

    //
    // Remember the undo instruction for abort
    //

	if(pUndoInstruction)
	{
		try
		{
			m_stReplacedInstructions.push(pUndoInstruction);
		}
		catch(...)
		{
			//
			// Try to put it back into the queue, then
			//

			lRes = AddInstructionToMap(pUndoInstruction, NULL);
			if(lRes != ERROR_SUCCESS)
			{
				// Totally busted --- pUndoInstruction is hanging in the air.
				// The only course of action is to totally shut down everything
				//

				ReportTotalFailure();
				return ERROR_OUTOFMEMORY;
			}
        
			m_qTransaction.pop_back();
			pInst->Release();
		}
	}

    if(!m_bInTransaction)
    {
        long lRes = CommitTransaction();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    return ERROR_SUCCESS;
}

long CStageManager::WaitForSpaceForTransaction()
{
    while(1) // TBD: consider timing out
    {
        {
            CInCritSec ics(&m_cs);

            long lRes = CanStartNewTransaction();
            if(lRes == ERROR_SUCCESS)
                return ERROR_SUCCESS;
            else if(lRes != ERROR_IO_PENDING)
                return lRes;
        }
        Sleep(100);
    }

    // Can't happen for now
    return ERROR_INTERNAL_ERROR;
}

int CStageManager::GetStagingFileHeaderSize()
{
    return sizeof(m_nTransactionIndex);
}

bool CStageManager::IsFullyFlushed()
{
    CInCritSec ics(&m_cs);

    return (m_lFirstFreeOffset == GetStagingFileHeaderSize());
}

bool CStageManager::CanWriteInTransaction(DWORD dwNeeded)
{
    if(m_lFirstFreeOffset + dwNeeded > m_lAbortTransactionFileSize)
        return false;
    else
        return true;
}

long CStageManager::CanStartNewTransaction()
{
    //
    // Check if the staging file is currently in trouble --- failing to execute
    // an instruction.  If so, refuse to start this transaction
    //

    if(m_lStatus != ERROR_SUCCESS)
        return m_lStatus;
    if(m_lFirstFreeOffset < m_lMaxFileSize)
        return ERROR_SUCCESS;
    else
        return ERROR_IO_PENDING;
}

void CStageManager::SetMaxFileSize(long lMaxFileSize,
                                            long lAbortTransactionFileSize)
{
    m_lMaxFileSize = lMaxFileSize;
    m_lAbortTransactionFileSize = lAbortTransactionFileSize;
}


long CStageManager::RecoverStage(HANDLE hFile)
{
    long lRes;
    DWORD dwRead;

    //
    // Read the starting transaction index
    //

    if(!::ReadFile(hFile, &m_nTransactionIndex, 
                    sizeof m_nTransactionIndex, &dwRead, NULL))
    {
        return GetLastError();
    }

    if(dwRead == 0)
    {
        // 
        // Empty file.  Write the trailer and we are done
        //

        m_nTransactionIndex = 1;
        
        m_lFirstFreeOffset = sizeof(__int64);

        lRes = WriteEmpty();
        if(lRes != ERROR_SUCCESS)
            return lRes;
        return lRes;
    }

    m_lFirstFreeOffset = GetStagingFileHeaderSize();

    //
    // Read complete transactions from the file until the end or until a 
    // corruption is found
    //

    lRes = ProcessBegin();
    if(lRes != ERROR_SUCCESS)
        return lRes;

    while((lRes = RecoverTransaction(hFile)) == ERROR_SUCCESS)
    {
        lRes = ProcessCommit();
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = ProcessBegin();
        if(lRes != ERROR_SUCCESS)
            return lRes;
    }

    if(lRes != ERROR_NO_MORE_ITEMS)
    {
        AbortTransaction(NULL);
        ERRORTRACE((LOG_WBEMCORE, "Incomplete or invalid transaction is "
            "found in the journal.  It and all subsequent transactions "
            "will be rolled back\n"));
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}
        
BYTE CStageManager::ReadNextInstructionType(HANDLE hFile)
{
    BYTE nType;
    DWORD dwLen;
    if(!::ReadFile(hFile, &nType, sizeof nType, &dwLen, NULL))
        return -1;
    if(dwLen != sizeof nType)
        return -1;
    return nType;
}
    
long CStageManager::RecoverTransaction(HANDLE hFile)
{
    long lRes;

    //
    // Remember the current file position to be able to go back
    //

    LARGE_INTEGER liStart;
    LARGE_INTEGER liZero;
    liZero.QuadPart = 0;
    if(!SetFilePointerEx(hFile, liZero, &liStart, FILE_CURRENT))
        return GetLastError();

    LARGE_INTEGER liInstructionStart = liStart;

    //
    // Read instructions until the end of transaction or an invalid instruction
    //

    int nNumInstructions = 0;

    BYTE nInstructionType;
    while((nInstructionType = ReadNextInstructionType(hFile)) != 
            A51_INSTRUCTION_TYPE_ENDTRANSACTION)
    {
        //
        // Create an instruction of the appropriate type
        //

        CStageInstruction* pInst = NULL;
        lRes = ConstructInstructionFromType(nInstructionType, &pInst);
        if(lRes != ERROR_SUCCESS)
        {
            if(nNumInstructions == 0)
                return ERROR_NO_MORE_ITEMS;
            else
                return lRes;
        }

        CTemplateReleaseMe<CStageInstruction> rm1(pInst);
        
        //
        // Get it to read its data from the file
        //

        lRes = pInst->RecoverData(hFile);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        lRes = AddInstruction(pInst);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        //
        // Hash its body into the transaction
        //

        LARGE_INTEGER liInstructionEnd;
        if(!SetFilePointerEx(hFile, liZero, &liInstructionEnd, FILE_CURRENT))
            return GetLastError();

        if(!SetFilePointerEx(hFile, liInstructionStart, NULL, FILE_BEGIN))
            return GetLastError();

        DWORD dwBufferLen = (DWORD)(liInstructionEnd.QuadPart - 
                                            liInstructionStart.QuadPart);
        
        BYTE* pBuffer = (BYTE*)TempAlloc(dwBufferLen);
        if(pBuffer == NULL)
            return ERROR_OUTOFMEMORY;
        CTempFreeMe tfm(pBuffer, dwBufferLen);

        DWORD dwSizeRead;
        if(!::ReadFile(hFile, pBuffer, dwBufferLen, &dwSizeRead, NULL))
            return GetLastError();
    
        if(dwSizeRead != dwBufferLen)
            return ERROR_HANDLE_EOF;

        MD5::ContinueTransform(pBuffer, dwBufferLen, m_TransactionHash);

        liInstructionStart = liInstructionEnd;
        nNumInstructions++;
    }

    //
    // Read the hash that the end-of-transaction marker thinks we should have
    // gotten
    //

    BYTE DesiredHash[16];
    DWORD dwSizeRead;
    if(!::ReadFile(hFile, DesiredHash, sizeof DesiredHash, &dwSizeRead, NULL))
        return GetLastError();

    if(dwSizeRead != sizeof DesiredHash)
        return ERROR_HANDLE_EOF; 
    
    //
    // Compare them
    //

    if(memcmp(DesiredHash, m_TransactionHash, sizeof DesiredHash))
    {
        ERRORTRACE((LOG_WBEMCORE, "Found mismatched transaction signature in "
            "the log.\n"));
        // return ERROR_RXACT_INVALID_STATE;
    }

    //
    // Everything checked out --- set member variables for end of transaction
    // Note that liInstructionStart is pointing to the beginning of the "next"
    // instruction, which is actually the end-of-transaction instruction, so
    // we need to skip it
    //

    LARGE_INTEGER liTransactionEnd;
    if(!SetFilePointerEx(hFile, liZero, &liTransactionEnd, FILE_CURRENT))
        return GetLastError();

    m_lFirstFreeOffset = (LONG)liTransactionEnd.QuadPart; 
    return ERROR_SUCCESS;
}

long CStageManager::Create(LPCWSTR wszFileName)
{
    long lRes;

    //
    // Open the file itself
    //

    m_hFile = CreateFileW(wszFileName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 
                FILE_FLAG_OVERLAPPED, 
                NULL);

    if(m_hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    if (!DuplicateHandle(GetCurrentProcess(),
                         m_hFile,
                         GetCurrentProcess(),
                         &m_hFlushFile,
                         0,
                         FALSE, 
                         DUPLICATE_SAME_ACCESS))
    {
        return GetLastError();
    };

    m_lFirstFreeOffset = 0;

    //
    // Open a special synchronous handle to the same file for convenience
    //

    HANDLE hRecoveryFile = CreateFileW(wszFileName, 
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 
                NULL);

    if(hRecoveryFile == INVALID_HANDLE_VALUE)
        return GetLastError();
    CCloseMe cm(hRecoveryFile);

    lRes = RecoverStage(hRecoveryFile);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CStageManager::WriteEmpty()
{
    //
    // Construct a buffer consisting of the transaction index and a 0 for the
    // end-instruction
    //

    DWORD dwBufferSize = sizeof m_nTransactionIndex + A51_TAIL_SIZE;
    BYTE* pBuffer = (BYTE*)_alloca(dwBufferSize);

    memset(pBuffer, 0, dwBufferSize);
    memcpy(pBuffer, &m_nTransactionIndex, sizeof m_nTransactionIndex);

    long lRes = A51WriteToFileSync(m_hFile, 0, pBuffer, dwBufferSize);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Have to flush it to make sure that old instructions are not replayed
    //

    if(!FlushFileBuffers(m_hFile))
        return GetLastError();

    m_lFirstFreeOffset = GetStagingFileHeaderSize();
    m_lTransactionStartOffset = m_lFirstFreeOffset;

    return ERROR_SUCCESS;
}


//******************************************************************************
//******************************************************************************
//                      EXECUTABLE FILE
//******************************************************************************
//******************************************************************************

CExecutableStageManager::CExecutableStageManager(
                            long lMaxFileSize, long lAbortTransactionFileSize)
    : CStageManager(lMaxFileSize, lAbortTransactionFileSize),
        m_hEvent(NULL), m_hThread(NULL), m_dwThreadId(0)
{
}

CExecutableStageManager::~CExecutableStageManager()
{
}

long CExecutableStageManager::Stop(DWORD dwShutDownFlags)
{
    {
	    if(!m_bInit)
         return ERROR_SUCCESS;    
         
        CInCritSec ics(&m_cs);

        m_bInit = FALSE;
    }

    SetEvent(m_hEvent);
    if (WMIDB_SHUTDOWN_MACHINE_DOWN == dwShutDownFlags)
    {
        DWORD dwRet = WaitForSingleObject(m_hThread, 3000); // sig
    }
    else
    {
        WaitForSingleObject(m_hThread, INFINITE);    
    }

    //
    // here is logically the palce where the m_cs can be safly acquired
    //
    
    CloseHandle(m_hEvent);
    CloseHandle(m_hThread);

    m_hEvent = NULL;
    m_hThread = NULL;
         
    CStageManager::_Stop(dwShutDownFlags);
    
    return ERROR_SUCCESS;
}


long CExecutableStageManager::Start()
{
    if (m_bInit)
        return ERROR_SUCCESS;

    m_bInit = TRUE;
    CStageManager::_Start();
    
    //
    // Create a reading thread
    //

    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hEvent == NULL)
    {
        m_bInit = FALSE;
        return GetLastError();
    }

    if(!m_qToWrite.empty())
        SignalPresense();

    DWORD dwId;
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)staticFlusher, 
                                (void*)this, 0, &dwId);
    if(m_hThread == NULL)
    {
        m_bInit = FALSE;
        return GetLastError();
    }

    SetThreadPriority(m_hThread, THREAD_PRIORITY_IDLE);

    return ERROR_SUCCESS;
}

long CExecutableStageManager::Create(LPCWSTR wszStagingFileName)
{
    return CStageManager::Create(wszStagingFileName);
}

void CExecutableStageManager::SignalPresense()
{
    SetEvent(m_hEvent);
}

long CExecutableStageManager::WriteEmpty()
{
    ResetEvent(m_hEvent);

    return CStageManager::WriteEmpty();
}

    
DWORD CExecutableStageManager::staticFlusher(void* pArg)
{
    // Sleep(20000);
    return ((CExecutableStageManager*)pArg)->Flusher();
}

DWORD CExecutableStageManager::Flusher()
{
    //
    m_dwThreadId = GetCurrentThreadId();
    HANDLE HandleFlush = m_hFlushFile;
    m_hFlushFile = NULL;
    // set the Global to NULL, this will be closed by the flusher thread
    
    //
    // m_bInit is set to FALSE before calling SetEvent(m_hEvent)
    // 
    //
    while(m_bInit)
    {
        WaitForSingleObject(m_hEvent, INFINITE);
        
        Flush(HandleFlush);
    }

    CloseHandle(HandleFlush);    
    m_dwThreadId = 0;    
    return 0;
}

long CExecutableStageManager::Flush(HANDLE hFlushFile)
{
    long lRes;
    //
    // Must flash when starting a new transaction
    //

    long lFlushLevel = m_lTransactionStartOffset;

    FlushFileBuffers(hFlushFile);

    while(1)
    {
        if(!m_bInit)
            return ERROR_SUCCESS;

        //
        // Get the next instruction from the queue
        //

        CStageInstruction* pInst = NULL;

        {
            CInCritSec ics(&m_cs);
        
            if(m_qToWrite.empty())
            {
                //
                // Reset generation only if there are no instructions on the
                // transaction queue!
                //

                if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                {
                    WriteEmpty();
                }
                return ERROR_SUCCESS;
            }

            pInst = m_qToWrite.front();

            //  
            // Check if it is in the map.  The reason it might not be there
            // is if it was superceeded by some later instruction over the same 
            // file.  In that case, we should not execute it, but rather simply 
            // skip it.
            //
            
            if(!IsStillCurrent(pInst))
            {
				pInst->Release();
                m_qToWrite.pop_front();
                continue;
            }
        }
            
        //
        // Flush if needed
        //
    
        if(pInst->GetStageOffset() > lFlushLevel)
        {
            lFlushLevel = m_lTransactionStartOffset;

            FlushFileBuffers(hFlushFile);
        }

        //
        // Execute it
        //

        lRes = pInst->Execute();
        if(lRes != ERROR_SUCCESS)
        {

            //
            // We cannot continue until we succeed in executing this
            // instruction.  Therefore, we keep it on the queue and keep 
            // re-executing it.  If an instruction fails twice in a row, we 
            // enter a "failed state" and refuse all new transactions until the
            // condition is cleared
            //

            RegisterFailure(lRes);
            continue;
        }
        
        //  
        // Remove it from the map, if there.  The reason it might not be there
        // is if it was superceeded by some later instruction over the same 
        // file.  We already checked this before we executed it, but it doesn't 
        // help much since the overriding instruction could have come in while
        // we were executing.  
        //
            
        lRes = RemoveInstructionFromMap(pInst);
        if(lRes != ERROR_SUCCESS)
        {
            //
            // We cannot continue, or this instruction will be left 
            // pointing to garbage in the file
            //

            RegisterFailure(lRes);
            continue;
        }

        RegisterSuccess();

        {
            CInCritSec ics(&m_cs);

            //
            // Remove it from the queue
            //

            m_qToWrite.pop_front();
            pInst->Release();

            if(m_qToWrite.empty())
            {
                //
                // Reset generation only if there are no instructions on the
                // transaction queue!
                //

                if(m_lTransactionStartOffset == m_lFirstFreeOffset)
                {
                    WriteEmpty();
                }
                return ERROR_SUCCESS;
            }
        }
    }

    _ASSERT(false, L"Out of an infinite loop!");
    return ERROR_INTERNAL_ERROR;
}

void CStageManager::RegisterFailure(long lRes)
{
    if(m_bFailedBefore)
    {
        ERRORTRACE((LOG_WBEMCORE, "Repository driver repeatedly failed "
                    "to execute an instruction with error code %d.\n"
                    "Further processing is suspended until the problem "
                    "is corrected\n", lRes));
        m_lStatus = lRes;
    }
    else
    {
        ERRORTRACE((LOG_WBEMCORE, "Repository driver failed "
                    "to execute an instruction with error code %d.\n",
                    lRes));
        m_bFailedBefore = true;
    }

    //
    // Wait a bit before retrying
    //

    Sleep(100);
}

void CStageManager::RegisterSuccess()
{
    m_bFailedBefore = false;
    m_lStatus = ERROR_SUCCESS;
}

void CStageManager::ReportTotalFailure()
{
    //
    // What to do when in-memory structures cannot be brought to compliance
    // with on-disk data? The only course of action appears to be to shut down
    // the repository and restart...
    //

    ERRORTRACE((LOG_WBEMCORE, "Repository has suffered a complete failure due "
            "to an out-of-memory condition and will have to re-initialize\n"));
}
                
//******************************************************************************
//******************************************************************************
//                     PERMANENT FILE
//******************************************************************************
//******************************************************************************

/*
CPermanentStageManager::CPermanentStageManager()
    : CStageManager(0x7FFFFFFF, 0x7FFFFFFF)
{
}

CPermanentStageManager::~CPermanentStageManager()
{
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\shortstg.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_SHORT_STAGE__H_
#define __WMI_A51_SHORT_STAGE__H_

#include <queue>
#include <map>
#include <list>
#include <sync.h>
#include "a51tools.h"
#include "stagemgr.h"

#define ERROR_NO_INFORMATION -1

class CFileCache;

class CShortFileStagingFile;
class CShortFileInstruction : public CStageInstruction
{
protected:
    WCHAR* m_wszFilePath;

public:
    CShortFileInstruction(CShortFileStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);
    virtual ~CShortFileInstruction();

    LPCWSTR GetFilePath() {return m_wszFilePath;}

    virtual long Execute() = 0;
    virtual long RecoverData(HANDLE hFile) = 0;
    virtual bool IsDeletion() = 0;

protected:
    DWORD ComputeSpaceForName();
    BYTE* WriteFileName(BYTE* pStart);
    long RecoverFileName(HANDLE hFile);
    void ComputeFullPath(wchar_t *wszFullPath);
};

class CCreateFile : public CShortFileInstruction
{
protected:
    DWORD m_dwFileLen;
    DWORD m_dwFileStart;

public:
    CCreateFile(CShortFileStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath, DWORD dwFileLen);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset, BYTE* pBuffer);
    long RecoverData(HANDLE hFile);
    long Execute();

    long GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer);
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CDeleteFile : public CShortFileInstruction
{
public:
    CDeleteFile(CShortFileStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return true;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CRemoveDirectory : public CShortFileInstruction
{
public:
    CRemoveDirectory(CShortFileStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CFileCache;
class CShortFileStagingFile : public CExecutableStageManager
{
    class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool>
    {
    public:
        bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
            {return wcscmp(wcs1, wcs2) < 0;}
    };

protected:
    wchar_t m_wszBaseName[MAX_PATH+1];

    typedef std::map<LPCWSTR, CShortFileInstruction*, wcscless, 
                     CPrivateTempAllocator<CShortFileInstruction*> > TMap;
    typedef TMap::iterator TIterator;
    TMap m_map;

    CFileCache* m_pCache;

public:
    CShortFileStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    virtual ~CShortFileStagingFile();

    void SetMaxFileSize(long lMaxFileSize, long lAbortTransactionFileSize);
    long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere);
    long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer);
    long DeleteFile(LPCWSTR wszFilePath);
    long RemoveDirectory(LPCWSTR wszFilePath);
    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);
    long IsDeleted(LPCWSTR wszFilePath);

    INTERNAL LPCWSTR GetBase() {return m_wszBaseName;}

    long RemoveActualDirectory(LPCWSTR wszFileName);
    long DeleteActualFile(LPCWSTR wszFileName);
    long WriteActualFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer); 

    void Dump();

protected:
    virtual long AddInstructionToMap(CStageInstruction* pInst,
                                CStageInstruction** ppUndoInst);
    virtual long RemoveInstructionFromMap(CStageInstruction* pInst);
    virtual long ConstructInstructionFromType(int nType, 
                                CStageInstruction** ppInst);
    virtual bool IsStillCurrent(CStageInstruction* pInst);

protected:
    void ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey);

    class CIterationHandle
    {
    protected:
        TMap& m_rMap;
        TIterator m_it;
        wchar_t m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixLen;
        DWORD m_dwPrefixDirLen;

    public:
        CIterationHandle(CShortFileStagingFile::TMap& rMap,
                    const CShortFileStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix);

        long GetNext(WIN32_FIND_DATAW* pfd);

        void* operator new(size_t) 
            {return TempAlloc(sizeof(CIterationHandle));}
        void operator delete(void* p) 
            {return TempFree(p, sizeof(CIterationHandle));}

        friend class CShortFileStagingFile;
    };
	friend class CCreateFile;
protected:
    CPointerArray<CIterationHandle> m_apIterators;
    TIterator EraseIterator(TIterator it);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\stage.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_STAGE__H_
#define __WMI_A51_STAGE__H_

#include <queue>
#include <map>
#include <list>
#include <sync.h>
#include "a51tools.h"

#define ERROR_NO_INFORMATION -1


class CFileCache;
class CStagingFile
{
public:
    virtual ~CStagingFile(){}
    virtual long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere) = 0;
    virtual long IsDeleted(LPCWSTR wszFilePath) = 0;
    virtual long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer) = 0;
    virtual long DeleteFile(LPCWSTR wszFilePath) = 0;
    virtual long RemoveDirectory(LPCWSTR wszFilePath) = 0;
    virtual long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle) = 0;
    virtual long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd) = 0;
    virtual void FindClose(void* pHandle) = 0;
    virtual long BeginTransaction() = 0;
    virtual long CommitTransaction() = 0;
    virtual long AbortTransaction() = 0;

    virtual bool IsFullyFlushed() = 0;
    virtual void Dump() = 0;
};

class CRealStagingFile;

class CFileInstruction
{
protected:
    long m_lRef;
    CRealStagingFile* m_pFile;
    WCHAR* m_wszFilePath;
    TFileOffset m_lFileOffset;
    bool m_bCommitted;

public:
    CFileInstruction(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);
    virtual ~CFileInstruction();

    void AddRef() {m_lRef++;}
    void Release() {if(--m_lRef == 0) delete this;}

    LPCWSTR GetFilePath() {return m_wszFilePath;}
    long GetFileOffset() {return m_lFileOffset;}
    void SetCommitted() {m_bCommitted = true;}
    bool IsCommitted() {return m_bCommitted;}

    virtual long Execute() = 0;
    virtual long RecoverData(HANDLE hFile) = 0;
    virtual bool IsDeletion() = 0;

protected:
    DWORD ComputeSpaceForName();
    BYTE* WriteFileName(BYTE* pStart);
    long RecoverFileName(HANDLE hFile);
    void ComputeFullPath(wchar_t *wszFullPath);
};

class CCreateFile : public CFileInstruction
{
protected:
    DWORD m_dwFileLen;
    DWORD m_dwFileStart;

public:
    CCreateFile(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath, DWORD dwFileLen);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset, BYTE* pBuffer);
    long RecoverData(HANDLE hFile);
    long Execute();

    long GetData(HANDLE hFile, DWORD* pdwLen, BYTE** ppBuffer);
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CDeleteFile : public CFileInstruction
{
public:
    CDeleteFile(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return true;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CRemoveDirectory : public CFileInstruction
{
public:
    CRemoveDirectory(CRealStagingFile* pFile);
    long Initialize(LPCWSTR wszFilePath);

    DWORD ComputeNeededSpace();
    long Write(TFileOffset lOffset);
    long RecoverData(HANDLE hFile);
    long Execute();
    virtual bool IsDeletion(){return false;}

    void* operator new(size_t);
    void operator delete(void* p);
};

class CFileCache;
class CRealStagingFile : public CStagingFile
{
    class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool>
    {
    public:
        bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
            {return wcscmp(wcs1, wcs2) < 0;}
    };

protected:
    wchar_t m_wszBaseName[MAX_PATH+1];

    HANDLE m_hFile;
    HANDLE m_hFlushFile;
    long m_lFirstFreeOffset;

    typedef std::map<LPCWSTR, CFileInstruction*, wcscless, 
                     CPrivateTempAllocator<CFileInstruction*> > TMap;
    typedef TMap::iterator TIterator;
    typedef std::queue<CFileInstruction*, std::list<CFileInstruction*, 
                                    CPrivateTempAllocator<CFileInstruction*> > 
              > TQueue;
    typedef std::stack<CFileInstruction*, std::list<CFileInstruction*, 
                                    CPrivateTempAllocator<CFileInstruction*> > 
              > TStack;

    CCritSec m_cs;
    TMap m_map;
    TQueue m_qToWrite;

    TStack m_stReplacedInstructions;
    TQueue m_qTransaction;

    __int64 m_nTransactionIndex;
    long m_lTransactionStartOffset;
    BYTE m_TransactionHash[16];

    bool m_bInTransaction;

    long m_lMaxFileSize;
    long m_lAbortTransactionFileSize;
    CFileCache* m_pCache;

    bool m_bFailedBefore;
    long m_lStatus;

public:
    CRealStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    virtual ~CRealStagingFile();

    virtual long Create(LPCWSTR wszStagingFileName);
    void SetMaxFileSize(long lMaxFileSize, long lAbortTransactionFileSize);
    long ReadFile(LPCWSTR wszFilePath, DWORD* pdwLen,
                            DELETE_ME BYTE** ppBuffer, bool bMustBeThere);
    long WriteFile(LPCWSTR wszFilePath, DWORD dwLen,
                            BYTE* pBuffer);
    long DeleteFile(LPCWSTR wszFilePath);
    long RemoveDirectory(LPCWSTR wszFilePath);
    long FindFirst(LPCWSTR wszFilePrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    void FindClose(void* pHandle);
    long IsDeleted(LPCWSTR wszFilePath);

    bool IsFullyFlushed();

    INTERNAL HANDLE GetHandle() {return m_hFile;}
    INTERNAL HANDLE GetFlushHandle() {return m_hFlushFile;}
    INTERNAL LPCWSTR GetBase() {return m_wszBaseName;}

    long WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen);

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction();
    void Dump();

    long RemoveActualDirectory(LPCWSTR wszFileName);
    long DeleteActualFile(LPCWSTR wszFileName);
    long WriteActualFile(LPCWSTR wszFileName, DWORD dwLen, BYTE* pBuffer); 

protected:
    long WaitForSpaceForTransaction();
    virtual void SignalPresense(){}

    virtual long CanStartNewTransaction();
    virtual bool CanWriteInTransaction(DWORD dwSpaceNeeded);
    long RecoverStage(HANDLE hFile);
    long RecoverTransaction(HANDLE hFile);
    BYTE ReadNextInstructionType(HANDLE hFile);
    virtual long WriteEmpty();

    long ProcessCommit();
    long ProcessBegin();
    INTERNAL CCritSec* GetLock() {return &m_cs;}
    int GetStagingFileHeaderSize();

protected:
    void ComputeKey(LPCWSTR wszFileName, LPWSTR wszKey);
    long AddInstruction(CFileInstruction* pInst);

    class CIterationHandle
    {
    protected:
        TMap& m_rMap;
        TIterator m_it;
        wchar_t m_wszPrefix[MAX_PATH+1];
        DWORD m_dwPrefixLen;
        DWORD m_dwPrefixDirLen;

    public:
        CIterationHandle(CRealStagingFile::TMap& rMap,
                    const CRealStagingFile::TIterator& rIt,
                    LPCWSTR wszPrefix);

        long GetNext(WIN32_FIND_DATAW* pfd);

        void* operator new(size_t) 
            {return TempAlloc(sizeof(CIterationHandle));}
        void operator delete(void* p) 
            {return TempFree(p, sizeof(CIterationHandle));}

        friend class CRealStagingFile;
    };
	friend class CCreateFile;
protected:
    CPointerArray<CIterationHandle> m_apIterators;
    TIterator EraseIterator(TIterator it);
};

class CExecutableStagingFile : public CRealStagingFile
{
protected:
    HANDLE m_hEvent;
    HANDLE m_hThread;
    bool m_bExitNow;
    DWORD m_dwThreadID;

public:
    CExecutableStagingFile(CFileCache* pCache, LPCWSTR wszBaseName, 
                            long lMaxFileSize, long lAbortTransactionFileSize);
    ~CExecutableStagingFile();

    virtual long Create(LPCWSTR wszStagingFileName);

protected:
    static DWORD staticFlusher(void* pArg);

    virtual long WriteEmpty();
    virtual void SignalPresense();
    DWORD Flusher();
    long Flush();
};

class CPermanentStagingFile : public CRealStagingFile
{
public:
    CPermanentStagingFile(CFileCache* pCache, LPCWSTR wszBaseName);
    ~CPermanentStagingFile();
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\dump\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <absfile.h>
#include <objheap.h>
#include <index.h>

bool g_bPause = false;
bool g_bPrintAllKeys = true;
bool g_bPrintAllBlocks = true;

void Pause()
{
    if(g_bPause)
    {
        char ch = (char)getchar();
        if(ch == 'n')
            g_bPause = false;
    }
}

long ParseInfoFromIndexFile(LPCSTR wszIndexFileName, 
                                        DWORD* pnOffset, DWORD* pdwLength)
{
    CHAR* pDot = strchr(wszIndexFileName, L'.');
    if(pDot == NULL)
        return ERROR_INVALID_PARAMETER;

    CHAR* pwc = pDot+1;
    *pnOffset = 0;
    while(*pwc && *pwc != '.')
    {
        *pnOffset = (*pnOffset * 10) + (*pwc - '0');
		pwc++;
    }

    if(*pwc != '.')
        return ERROR_INVALID_PARAMETER;

    pwc++;

    *pdwLength = 0;
    while(*pwc && *pwc != '.')
    {
        *pdwLength = (*pdwLength * 10) + (*pwc - '0');
		pwc++;
    }

    return ERROR_SUCCESS;
}

void __cdecl wmain(int argc, wchar_t** argv)
{
    long lRes;

    if(argc < 2)
    {
        wprintf(L"Usage: %s <repository directory>\n", argv[0]);
        return;
    }

    CFileName wszBaseName;
    wcscpy(wszBaseName, argv[1]);
    wcscat(wszBaseName, L"\\");
    DWORD dwBaseNameLen = wcslen(wszBaseName);

    CFileName wszStagingName;
    swprintf(wszStagingName, L"%sLowStage.dat", wszBaseName);
 
    CAbstractFileSource AbstractSource;
    lRes = AbstractSource.Create(wszStagingName, 0x7FFFFFFF, 0x7FFFFFFF);
    if(lRes != ERROR_SUCCESS)
    {
        printf("Unable to create staging file: %d\n", lRes);
        return;
    }

    CFileName wszObjHeapName;
    swprintf(wszObjHeapName, L"%sObjHeap", wszBaseName);
    

    CObjectHeap ObjectHeap;
	lRes = ObjectHeap.Initialize(&AbstractSource, wszObjHeapName, argv[1], dwBaseNameLen);
    if(lRes != ERROR_SUCCESS)
    {
        printf("Unable to initialize ObjectHeap: %d\n", lRes);
        return;
    }

    lRes = AbstractSource.Start();
    if(lRes != ERROR_SUCCESS)
    {
        printf("Unable to start staging file: %d\n", lRes);
        return;
    }

    AbstractSource.Dump(stdout);

	CBTree& BTree = ObjectHeap.GetIndex()->GetTree();

    CBTreeIterator* pIt = NULL;
    lRes = BTree.BeginEnum(NULL, &pIt);
    if(lRes != ERROR_SUCCESS)
    {
        printf("Unable to enumerate btree: %d\n", lRes);
        return;
    }

    std::map<DWORD, DWORD> mymap;

    char* szKey = NULL;
    DWORD dwTotalKeys = 0;
    while(pIt->Next(&szKey) == 0)
    {
        dwTotalKeys++;

        DWORD nStart, nLen;
        lRes = ParseInfoFromIndexFile(szKey, &nStart, &nLen);
        if(lRes != ERROR_SUCCESS)
        {
            if(strstr(szKey, "\\IL_") == NULL &&
                strstr(szKey, "\\R_") == NULL &&
                strstr(szKey, "\\C_") == NULL)
            {
                printf("Invalid key: %s\n", szKey);
                Pause();
            }
        }
        else
        {
            if(mymap.find(nStart) != mymap.end())
            {
                printf("Offset %d found twice: length %d and %d\n",
                    nStart, mymap[nStart], nLen);
                Pause();
            }

            mymap[nStart] = nLen;
        }

        pIt->FreeString(szKey);
    }

    printf("%d keys in tree, %d pointers\n", dwTotalKeys, (int)mymap.size());
    pIt->Release();

    std::map<DWORD, DWORD>::iterator itKeys;
    std::map<DWORD, DWORD> mapBadOffsets;
    
    itKeys = mymap.begin();

    CFileHeap::TFreeOffsetMap& freemap = ObjectHeap.GetFileHeap()->GetFreeOffsetMap();
    CFileHeap::TFreeOffsetIterator itFree = freemap.begin();

    int nCurrent = 0;
    bool bLastFree = false;
    DWORD dwMissingFreeCount = 0;

    while(itKeys != mymap.end() && itFree != freemap.end())
    {
        if(itKeys->first == itFree->first)
        {
            printf("Offset %d is both free and used!\n", itKeys->first);
            mapBadOffsets[itKeys->first] = 1;
            Pause();
        }

        if(itKeys->first <= itFree->first)
        {
            if(nCurrent != 0 && itKeys->first != nCurrent)
            {
                printf("Hole at offset %d: key at %d, free at %d\n",
                    nCurrent, itKeys->first, itFree->first);
                Pause();
                nCurrent = itKeys->first;
            }

            DWORD adw[2];
            ObjectHeap.GetFileHeap()->ReadBytes(itKeys->first, (BYTE*)adw, 8);

            if(adw[0] != itKeys->second)
            {
                printf("Mismatched length at %d: index has %d, "
                        "heap has %d\n", itKeys->first, itKeys->second,
                        adw[0]);
                mapBadOffsets[itKeys->first] = 1;
                Pause();
            }
            else if(adw[1] != 0xA51A51A5)
            {
                printf("Missing signature from block %d: %d\n",
                        itKeys->first, adw[1]);
                mapBadOffsets[itKeys->first] = 1;
                Pause();
            }
            else if(g_bPrintAllBlocks)
            {
                printf("Used: %d (%d)\n", itKeys->first, itKeys->second);
            }

            nCurrent += itKeys->second + 8;
            itKeys++;
            bLastFree = false;
        }
        else 
        {
            if(nCurrent != 0 && itFree->first != nCurrent)
            {
                printf("Hole at offset %d: key at %d, free at %d\n",
                    nCurrent, itKeys->first, itFree->first);
                Pause();
                nCurrent = itFree->first;
            }

            if(bLastFree)
            {
                printf("Two free blocks in a row: %d (%d)\n", 
                            itFree->first, itFree->second);
                Pause();
            }

            if(itFree->second >= 4)
            {
                DWORD dwSig;
                ObjectHeap.GetFileHeap()->ReadBytes(itFree->first, (BYTE*)&dwSig, 4);
    
                if(dwSig != 0x51515151)
                {
                    printf("Missing free signature from block %d: %d\n",
                            itFree->first, dwSig);
                    Pause();
                    dwMissingFreeCount++;
                }
            }

            if(g_bPrintAllBlocks)
                printf("Free: %d (%d)\n", itFree->first, itFree->second);

            nCurrent += itFree->second;
            itFree++;
            bLastFree = true;
        }
    }

    if(itKeys != mymap.end())
    {
        printf("Last block is used!\n");
        return;
    }

    if(itFree == freemap.end())
    {
        printf("Missing last free block\n");
        return;
    }

    if(g_bPrintAllBlocks)
        printf("Free: %d (%d)\n", itFree->first, itFree->second);
    itFree++;

    if(itFree != freemap.end())
    {
        printf("Two free blocks in the end!");
        return;
    }

    printf("%d missing free signatures out of %d\n", dwMissingFreeCount,
            freemap.size());


    lRes = BTree.BeginEnum(NULL, &pIt);
    if(lRes != ERROR_SUCCESS)
    {
        printf("Unable to enumerate btree: %d\n", lRes);
        return;
    }

    while(pIt->Next(&szKey) == 0)
    {
        DWORD nStart, nLen;
        bool bPrint = false;
        lRes = ParseInfoFromIndexFile(szKey, &nStart, &nLen);
        if(lRes == ERROR_SUCCESS)
        {
            if(mapBadOffsets.find(nStart) != mapBadOffsets.end())
            {
                printf("* ");
                bPrint = true;
            }
        }

        if(bPrint || g_bPrintAllKeys)
            printf("%s\n", szKey);
        pIt->FreeString(szKey);
    }

    pIt->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\stagemgr.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_STAGE__H_
#define __WMI_A51_STAGE__H_

#include <queue>
#include <list>
#include <map>
#include <list>
#include <sync.h>
#include "a51tools.h"

#define A51_TAIL_SIZE sizeof(DWORD)

class CStageManager;
class CStageInstruction
{
protected:
    long m_lRef;
    long m_lStageOffset;
    CStageManager* m_pManager;
    bool m_bCommitted;

public:
    CStageInstruction(CStageManager* pManager) 
        : m_pManager(pManager), m_lRef(0), m_bCommitted(false)
    {}
    virtual ~CStageInstruction(){}

    void AddRef() {m_lRef++;}
    void Release() {if(--m_lRef == 0) delete this;}

    long GetStageOffset() {return m_lStageOffset;}

    void SetCommitted() {m_bCommitted = true;}
    bool IsCommitted() {return m_bCommitted;}
    virtual void Dump(){}

public:
    virtual long Execute() = 0;
    virtual long RecoverData(HANDLE hFile) = 0;
    virtual DWORD ComputeNeededSpace() = 0;
};
    
class CStageManager
{
protected:
    HANDLE m_hFile;
    HANDLE m_hFlushFile;
    long m_lFirstFreeOffset;

    typedef std::list<CStageInstruction*, 
                        CPrivateTempAllocator<CStageInstruction*>
              > TQueue;
    typedef std::stack<CStageInstruction*, std::list<CStageInstruction*, 
                                    CPrivateTempAllocator<CStageInstruction*> > 
              > TStack;

    CCritSec m_cs;
    TQueue m_qToWrite;

    TStack m_stReplacedInstructions;
    TQueue m_qTransaction;

    __int64 m_nTransactionIndex;
    long m_lTransactionStartOffset;
    BYTE m_TransactionHash[16];

    bool m_bInTransaction;

    long m_lMaxFileSize;
    long m_lAbortTransactionFileSize;

    bool m_bFailedBefore;
    long m_lStatus;

    bool m_bMustFail;
    bool m_bNonEmptyTransaction;

protected:
    long Create(LPCWSTR wszStagingFileName);
    long _Start();
    long _Stop(DWORD dwShutdownFlags);    
public:
    BOOL   m_bInit;
    
    CStageManager(long lMaxFileSize, long lAbortTransactionFileSize);
    virtual ~CStageManager();

    void SetMaxFileSize(long lMaxFileSize, long lAbortTransactionFileSize);

    bool IsFullyFlushed();

    long BeginTransaction();
    long CommitTransaction();
    long AbortTransaction(bool* pbNonEmpty);
    void TouchTransaction();

    long AddInstruction(CStageInstruction* pInst);
    void Dump();

    virtual bool GetFailedBefore() {return m_bFailedBefore;}
    virtual long GetStatus() {return m_lStatus;}

public: // for instructions

    INTERNAL HANDLE GetHandle() {return m_hFile;}
    INTERNAL HANDLE GetFlushHandle() {return m_hFlushFile;}
    INTERNAL CCritSec* GetLock() {return &m_cs;}
    long GetFirstFreeOffset() {return m_lFirstFreeOffset;}

    long WriteInstruction(long lStartingOffset, 
                            BYTE* pBuffer, DWORD dwBufferLen,
							bool bSkipTailAdjustment = false);

protected:
    long WaitForSpaceForTransaction();
    virtual void SignalPresense(){}

    virtual long CanStartNewTransaction();
    virtual bool CanWriteInTransaction(DWORD dwSpaceNeeded);
    long RecoverStage(HANDLE hFile);
    long RecoverTransaction(HANDLE hFile);
    BYTE ReadNextInstructionType(HANDLE hFile);
    virtual long WriteEmpty();

    long ProcessCommit();
    long ProcessBegin();
    int GetStagingFileHeaderSize();

    void ReportTotalFailure();
    void RegisterSuccess();
    void RegisterFailure(long lRes);

protected:
    virtual long AddInstructionToMap(CStageInstruction* pInst,
                                CStageInstruction** ppUndoInst) = 0;
    virtual long RemoveInstructionFromMap(CStageInstruction* pInst) = 0;
    virtual long ConstructInstructionFromType(int nType, 
                                CStageInstruction** ppInst) = 0;
    virtual bool IsStillCurrent(CStageInstruction* pInst) = 0;
};

//
//
//
//
/////////////////////////////////////////////////////////

class CExecutableStageManager : public CStageManager
{
protected:
    HANDLE m_hEvent;
    HANDLE m_hThread;
    DWORD  m_dwThreadId;

    long Create(LPCWSTR wszStagingFileName);
    long Start();
    long Stop(DWORD dwShutDownFlags);
    
public:
    CExecutableStageManager(long lMaxFileSize, long lAbortTransactionFileSize);
    virtual ~CExecutableStageManager();


protected:
    static DWORD staticFlusher(void* pArg);

    virtual long WriteEmpty();
    virtual void SignalPresense();
    DWORD Flusher();
    long Flush(HANDLE hFlushFile);
};

//class CPermanentStageManager : public CStageManager
//{
//public:
//    CPermanentStageManager();
//    virtual ~CPermanentStageManager();
//};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\repval\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    main file for repository online validation

History:

    ivanbrug	  02/23/01  Created.

--*/


#include <windows.h>
#include <stdio.h>
#include "repval.h"

int main(int argc, char * argv[])
{

    // TRUE if repository is GOOD
    BOOL Ret = ValidateRepository();
    
    printf("repository validation performed\n");

    // return 0 if repository is good   
    return (Ret)?0:1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\repval\repval.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    repval.h

Abstract:

    prototyped for repository online validation

History:

    ivanbrug	  02/19/01  Created.

--*/

#ifndef __REPVAL_H__
#define __REPVAL_H__


#if 0
#define DBG_PRINTFA( a ) { char pBuff[256]; sprintf a ; OutputDebugStringA(pBuff); }
#else
#define DBG_PRINTFA( a ) { char pBuff[256]; sprintf a ; printf(pBuff); }
#endif


//
//
//  this enum is copyed from btr.h
//
//

    enum {
        PAGE_TYPE_IMPOSSIBLE = 0x0,       // Not supposed to happen
        PAGE_TYPE_ACTIVE = 0xACCC,        // Page is active with data
        PAGE_TYPE_DELETED = 0xBADD,       // A deleted page on free list
        PAGE_TYPE_ADMIN = 0xADDD,         // Page zero only

        // All pages
        OFFSET_PAGE_TYPE = 0,             // True for all pages
        OFFSET_PAGE_ID = 1,               // True for all pages
        OFFSET_NEXT_PAGE = 2,             // True for all pages (Page continuator)

        // Admin Page (page zero) only
        OFFSET_LOGICAL_ROOT = 3,          // Root of database
        OFFSET_FREE_LIST_ROOT = 4,        // First free list page
        OFFSET_TOTAL_PAGES = 5,           // Total page in database
        OFFSET_PAGE_SIZE = 6,             // Page size check
        OFFSET_IMPL_VERSION = 7,          // Implementation version
        };

#define PS_PAGE_SIZE  (8192)

#define MIN_ARRAY_KEYS (256)

#define ROSWELL_HEAPALLOC_TYPE_BUSY 0xA51A51A5
#define ROSWELL_HEAPALLOC_TYPE_FREE 0x51515151

#define INDEX_FILE _T("\\FS\\index.btr")
#define TRANSACTION_FILE _T("\\FS\\LowStage.dat")
#define HEAP_FILE _T("\\FS\\ObjHeap.hea")
#define FREE_FILE _T("\\FS\\ObjHeap.fre")

#define REG_WBEM   _T("Software\\Microsoft\\WBEM\\CIMOM")
#define REG_DIR _T("Repository Directory")


#define A51_INSTRUCTION_TYPE_TAIL 0
#define A51_INSTRUCTION_TYPE_WRITEFILE 1
#define A51_INSTRUCTION_TYPE_SETENDOFFILE 2
#define A51_INSTRUCTION_TYPE_ENDTRANSACTION 10 



//
//
//  those functions read the registry and performs
//  a CreateFile of the main repository files
//
//////////////////////////////////////////////////////////////

LONG GetObjFreHandles(HANDLE * pHandleObj, HANDLE * pHandleFre);
LONG GetPageSourceHandle(HANDLE * pHandle);

//
//
//   Main entry point for repository validation
//
///////////////////////////////////////////////////////////

BOOL ValidateRepository();

#endif /*__REPVAL_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\repval\repval.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    repval.h

Abstract:

    prototyped for repository online validation

History:

    ivanbrug	  02/19/01  Created.

--*/

#include <tchar.h>
#include <comdef.h>
#include <stdio.h>
#include <wbemint.h>
#include <map>
#include "repval.h"

//
//
//  Get file Handles to ObjHeap and Free List
//
//
/////////////////////////////////////////////////

LONG GetObjFreHandles(HANDLE * pHandleObj, HANDLE * pHandleFre)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_WBEM,
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        HANDLE hFileObj = INVALID_HANDLE_VALUE;
        HANDLE hFileFre = INVALID_HANDLE_VALUE;

        TCHAR pPath[MAX_PATH];
        DWORD dwType;
        DWORD dwLen = MAX_PATH;
        lRet = RegQueryValueEx(hKey,
                               REG_DIR,
                               NULL,
                               &dwType,
                               (BYTE*)pPath,
                               &dwLen);
        if (ERROR_SUCCESS == lRet)
        {
            TCHAR pPathExpand[MAX_PATH];
            ExpandEnvironmentStrings(pPath,pPathExpand,MAX_PATH);
            lstrcpy(pPath,pPathExpand);
            // ObjHeap file
            lstrcat(pPathExpand,HEAP_FILE);
            // now the free file
            lstrcat(pPath,FREE_FILE);

            hFileObj = CreateFile(pPathExpand,
                                  GENERIC_READ,
                                  FILE_SHARE_WRITE|FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,NULL);
                                  
            hFileFre = CreateFile(pPath,
                                  GENERIC_READ,
                                  FILE_SHARE_WRITE|FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,NULL);

            if (INVALID_HANDLE_VALUE != hFileObj &&
                INVALID_HANDLE_VALUE != hFileFre)
            {
				*pHandleObj = hFileObj;
				*pHandleFre = hFileFre;
                lRet = ERROR_SUCCESS;
            } 
            else // not both are OK, close both
            {            
	            if (INVALID_HANDLE_VALUE != hFileObj)
    	            CloseHandle(hFileObj);
        	    if (INVALID_HANDLE_VALUE != hFileFre)
            	    CloseHandle(hFileFre);
				lRet = -1; //GetLastError();            	    
            }                        
        }
        else
        {
            DBG_PRINTFA((pBuff,"unable to RegQueryValueEx: %d\n",GetLastError()));
            lRet = GetLastError();
        }    
        RegCloseKey(hKey);
    }
    else
    {
        DBG_PRINTFA((pBuff,"unable to RegOpenKeyEx: %d\n",GetLastError()));
        lRet = GetLastError();
    }

    return lRet;
}

//
//
//  Get file BrtIndex file
//
///////////////////////////////////////////////////////

LONG GetPageSourceHandle(HANDLE * pHandle)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_WBEM,
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        TCHAR pPath[MAX_PATH];
        DWORD dwType;
        DWORD dwLen = MAX_PATH;
        lRet = RegQueryValueEx(hKey,
                               REG_DIR,
                               NULL,
                               &dwType,
                               (BYTE*)pPath,
                               &dwLen);
        if (ERROR_SUCCESS == lRet)
        {
            TCHAR pPath2[MAX_PATH];
            ExpandEnvironmentStrings(pPath,pPath2,MAX_PATH);

            lstrcat(pPath2,INDEX_FILE);
            HANDLE hFile;

            hFile = CreateFile(pPath2,
                               GENERIC_READ,
                               FILE_SHARE_WRITE|FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                *pHandle = hFile;
				return ERROR_SUCCESS;
            }
            else
            {
                printf("CreateFile(%s) %d\n",pPath2,GetLastError());
            }
        }
        else
        {
            printf("unable to RegQueryValueEx: %d\n",GetLastError());
        }    
        RegCloseKey(hKey);
    }
    else
    {
        printf("unable to RegOpenKeyEx: %d\n",GetLastError());
    }

	return GetLastError();
}


//
//  Get the transaction log File Handle
//
///////////////////////////////////////////////////

LONG GetStageFileHandle(HANDLE * pHandle)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_WBEM,
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        TCHAR pPath[MAX_PATH];
        DWORD dwType;
        DWORD dwLen = MAX_PATH;
        lRet = RegQueryValueEx(hKey,
                               REG_DIR,
                               NULL,
                               &dwType,
                               (BYTE*)pPath,
                               &dwLen);
        if (ERROR_SUCCESS == lRet)
        {
            TCHAR pPath2[MAX_PATH];
            ExpandEnvironmentStrings(pPath,pPath2,MAX_PATH);

            lstrcat(pPath2,TRANSACTION_FILE);
            HANDLE hFile;

            hFile = CreateFile(pPath2,
                               GENERIC_READ,
                               FILE_SHARE_WRITE|FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                *pHandle = hFile;
                lRet = ERROR_SUCCESS;
            }
        }
        else
        {
            lRet = GetLastError();
        }    
        RegCloseKey(hKey);
    }
    else
    {
        lRet = GetLastError();
    }

    return lRet;
}


/*
void
DumpFile(HANDLE hFile,DWORD * pPage)
{
    // read the AdminPage
    BOOL bRet;
    DWORD nRead;
    bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    if (bRet && (PS_PAGE_SIZE == nRead))
    {
        printf("    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_LOGICAL_ROOT],
                pPage[OFFSET_FREE_LIST_ROOT],
                pPage[OFFSET_TOTAL_PAGES],
                pPage[OFFSET_PAGE_SIZE],
                pPage[OFFSET_IMPL_VERSION ]);
    }
    else
    {
        printf(" ReadFile %d\n",GetLastError());
    }

    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
        bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

        if (bRet && (PS_PAGE_SIZE == nRead))
        {
            printf("   %02x %08x %08x %08x - P %08x %08x %08x %08x\n",
                i,
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_NEXT_PAGE+1], // Parent
                pPage[OFFSET_NEXT_PAGE+2], // NumKey
                pPage[OFFSET_NEXT_PAGE+2+pPage[OFFSET_NEXT_PAGE+2]], // UserData
                pPage[OFFSET_NEXT_PAGE+2+pPage[OFFSET_NEXT_PAGE+2]+1]); //ChildPageMap
        }
    }
    DWORD dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        printf("    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE));
    }
}
*/

void PrintDWORDS(DWORD * pDW,DWORD nSize)
{
    DWORD i;
    for (i=0;i<(nSize/4);i++)
    {
        DBG_PRINTFA((pBuff,"    %08x  %08x %08x %08x %08x\n",i,
                     pDW[0+i*4],pDW[1+i*4],pDW[2+i*4],pDW[3+i*4]));
    }

    if (nSize%4)
    {
	    DWORD dwPAD[4];
	    memset(dwPAD,0xff,sizeof(dwPAD));
	    memcpy(dwPAD,pDW+i*4,(nSize%4)*sizeof(DWORD));
	    
	    DBG_PRINTFA((pBuff,"    %08x  %08x %08x %08x %08x\n",i,
	                 dwPAD[0],dwPAD[1],dwPAD[2],dwPAD[3]));
    }
}

void PrintWORDS(WORD * pDW,DWORD nSize)
{
    DWORD i;
    for (i=0;i<(nSize/8);i++)
    {
        DBG_PRINTFA((pBuff,"    %08x  %04x %04x %04x %04x %04x %04x %04x %04x\n",i,
                     pDW[0+i*8],pDW[1+i*8],pDW[2+i*8],pDW[3+i*8],
                     pDW[4+i*8],pDW[5+i*8],pDW[6+i*8],pDW[7+i*8]));
    }

    if (nSize%8)
    {
	    WORD dwPAD[8];
	    memset(dwPAD,0xff,sizeof(dwPAD));
	    memcpy(dwPAD,pDW+i*8,(nSize%8)*sizeof(WORD));
	    
	    DBG_PRINTFA((pBuff,"    %08x  %04x %04x %04x %04x %04x %04x %04x %04x\n",i,
	                 dwPAD[0],dwPAD[1],dwPAD[2],dwPAD[3],
	                 dwPAD[4],dwPAD[5],dwPAD[6],dwPAD[7]));
    }
}

/*

void
DumpPage(HANDLE hFile,
         DWORD dwPage,
         DWORD * pPage)
{
    // move to position
    if (INVALID_SET_FILE_POINTER == SetFilePointer(hFile,(dwPage * PS_PAGE_SIZE),NULL,FILE_BEGIN))
    {
        DBG_PRINTFA((pBuff,"    INVALID page %d err: %d\n",dwPage,GetLastError()));
        return;
    }
    
    // read the AdminPage
    BOOL bRet;
    DWORD nRead;
    bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    if (bRet && (PS_PAGE_SIZE == nRead))
    {
        // here we've read the page

        if (0xACCC != pPage[OFFSET_PAGE_TYPE])
        {
            return;
        }
        
        DBG_PRINTFA((pBuff"    SIGN %08x PAGE %08x NEXT %08x\n",
                pPage[OFFSET_PAGE_TYPE],pPage[OFFSET_PAGE_ID],pPage[OFFSET_NEXT_PAGE]));
        pPage+=3;

        DBG_PRINTFA((pBuff"    PAR  %08x NUM  %08x\n",pPage[0],pPage[1]));
        DWORD dwParent = pPage[0];
        DWORD dwNumKey = pPage[1];
        pPage+=2;

        //DWORD dwAlloc = (dwNumKey<=MIN_ARRAY_KEYS)?MIN_ARRAY_KEYS:dwNumKey;

        //DWORD * m_pdwUserData     = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *());
        //DWORD * m_pdwChildPageMap = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *(1+));
        //WORD * m_pwKeyLookup     =  HeapAlloc(GetProcessHeap(),0,sizeof(WORD) * ());

        // dwNumKey   DWORD USER_DATA        
        // dwNumKey+1 DWORD CHILD_PAGE_MAP
        // dwNumKey   WORD  KEY_LOOKUP
        printf("    User Data\n");
        PrintDWORDS(pPage,dwNumKey);

        pPage+=dwNumKey;
        DBG_PRINTFA((pBuff"    Child PageMap\n"));
        PrintDWORDS(pPage,dwNumKey+1);
        
        pPage+=(dwNumKey+1);
        WORD * pKeyLookup = (WORD *)pPage;
        DBG_PRINTFA((pBuff"    Key Lookup\n"));
        PrintWORDS((WORD *)pPage,dwNumKey);

        WORD * pWPage = ((WORD *)pPage + dwNumKey);
        DBG_PRINTFA((pBuff"    KEY CODE %08x\n",*pWPage));

        DWORD dwKeyUsed = *pWPage;
        pWPage++;
        WORD * pKeyCodes = pWPage;
        DBG_PRINTFA((pBuff"    Key Codes\n"));
        PrintWORDS((WORD *)pWPage,dwKeyUsed);

        pWPage += dwKeyUsed;
        DWORD dwNumStrings = *pWPage++; 
        DBG_PRINTFA((pBuff"    NUM STRINGS %08x\n",dwNumStrings));

        WORD * ArrayOffsets = pWPage;
        DBG_PRINTFA((pBuff"    Strings Offsets\n"));
        PrintWORDS((WORD *)pWPage,dwNumStrings);
        
        pWPage += dwNumStrings;
        DWORD dwPoolUsed = *pWPage++;
        DBG_PRINTFA((pBuff"    POOL USED %08x\n",dwPoolUsed));

        //
        DWORD i;
        LPSTR pStrings = (LPSTR)pWPage;

        for (i=0;i<dwNumStrings;i++)
        {
            DBG_PRINTFA((pBuff,"    %08x %04x %s\n",i,ArrayOffsets[i],pStrings+ArrayOffsets[i]));
        }
        //
        // better view
        //
        for (i=0;i<dwNumKey;i++)
        {
            DWORD j;
            WORD NumToken = pKeyCodes[pKeyLookup[i]];
            DBG_PRINTFA((pBuff,"        ( "));
            for (j=0;j<NumToken;j++)
            {
                DBG_PRINTFA((pBuff,"%04x ",pKeyCodes[pKeyLookup[i]+1+j]));
            }
            DBG_PRINTFA((pBuff,")\n")); 

            DBG_PRINTFA((pBuff,"        - ")); 
            for (j=0;j<NumToken;j++)
            {
                //pStrings+ArrayOffsets[i]
                DBG_PRINTFA((pBuff,"%s\\",pStrings+ArrayOffsets[pKeyCodes[pKeyLookup[i]+1+j]]));
            }
            DBG_PRINTFA((pBuff,"\n")); 
        }
    }
    else
    {
        DBG_PRINTFA((pBuff," ReadFile %d\n",GetLastError()));
    }
}

*/

BOOL
VerifyPage(DWORD * pPage,
           BYTE * pObject,
           BYTE * pFree,
           BOOL   bVerbose,
           std::map<DWORD,DWORD> & Map)
{
        BOOL bRet = TRUE;
        // here we've read the page

        if (0xACCC != pPage[OFFSET_PAGE_TYPE])
        {
            if (bVerbose) DBG_PRINTFA((pBuff,"page with SIG %04x\n",pPage[OFFSET_PAGE_TYPE]));
            return TRUE;
        }
        
        if (bVerbose) DBG_PRINTFA((pBuff,"    SIGN %08x PAGE %08x NEXT %08x\n",
                pPage[OFFSET_PAGE_TYPE],pPage[OFFSET_PAGE_ID],pPage[OFFSET_NEXT_PAGE]));
        pPage+=3;

        if (bVerbose) DBG_PRINTFA((pBuff,"    PAR  %08x NUM  %08x\n",pPage[0],pPage[1]));
        DWORD dwParent = pPage[0];
        DWORD dwNumKey = pPage[1];
        pPage+=2;

        //DWORD dwAlloc = (dwNumKey<=MIN_ARRAY_KEYS)?MIN_ARRAY_KEYS:dwNumKey;

        //DWORD * m_pdwUserData     = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *());
        //DWORD * m_pdwChildPageMap = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *(1+));
        //WORD * m_pwKeyLookup     =  HeapAlloc(GetProcessHeap(),0,sizeof(WORD) * ());

        // dwNumKey   DWORD USER_DATA        
        // dwNumKey+1 DWORD CHILD_PAGE_MAP
        // dwNumKey   WORD  KEY_LOOKUP
        if (bVerbose) DBG_PRINTFA((pBuff,"    User Data\n"));
        if (bVerbose) PrintDWORDS(pPage,dwNumKey);

        pPage+=dwNumKey;
        if (bVerbose) DBG_PRINTFA((pBuff,"    Child PageMap\n"));
        if (bVerbose) PrintDWORDS(pPage,dwNumKey+1);
        
        pPage+=(dwNumKey+1);
        WORD * pKeyLookup = (WORD *)pPage;
        if (bVerbose) DBG_PRINTFA((pBuff,"    Key Lookup\n"));
        if (bVerbose) PrintWORDS((WORD *)pPage,dwNumKey);

        WORD * pWPage = ((WORD *)pPage + dwNumKey);
        if (bVerbose) DBG_PRINTFA((pBuff,"    KEY CODE %08x\n",*pWPage));

        DWORD dwKeyUsed = *pWPage;
        pWPage++;
        WORD * pKeyCodes = pWPage;
        if (bVerbose) DBG_PRINTFA((pBuff,"    Key Codes\n"));
        if (bVerbose) PrintWORDS((WORD *)pWPage,dwKeyUsed);

        pWPage += dwKeyUsed;
        DWORD dwNumStrings = *pWPage++; 
        if (bVerbose) printf("    NUM STRINGS %08x\n",dwNumStrings);

        WORD * ArrayOffsets = pWPage;
        if (bVerbose) DBG_PRINTFA((pBuff,"    Strings Offsets\n"));
        if (bVerbose) PrintWORDS((WORD *)pWPage,dwNumStrings);
        
        pWPage += dwNumStrings;
        DWORD dwPoolUsed = *pWPage++;
        if (bVerbose) DBG_PRINTFA((pBuff,"    POOL USED %08x\n",dwPoolUsed));

        //
        DWORD i;
        LPSTR pStrings = (LPSTR)pWPage;

        for (i=0;i<dwNumStrings;i++)
        {
            if (bVerbose) DBG_PRINTFA((pBuff,"    %08x %04x %s\n",i,ArrayOffsets[i],pStrings+ArrayOffsets[i]));
        }
        //
        // better view
        //
        for (i=0;i<dwNumKey;i++)
        {
            DWORD j;
            WORD NumToken = pKeyCodes[pKeyLookup[i]];
            if (bVerbose) DBG_PRINTFA((pBuff,"        ( "));
            for (j=0;j<NumToken;j++)
            {
                if (bVerbose) DBG_PRINTFA((pBuff,"%04x ",pKeyCodes[pKeyLookup[i]+1+j]));
            }
            if (bVerbose) DBG_PRINTFA((pBuff,")\n")); 

            if (bVerbose) DBG_PRINTFA((pBuff,"        - ")); 
            for (j=0;j<NumToken;j++)
            {
                if (bVerbose) DBG_PRINTFA((pBuff,"%s\\",pStrings+ArrayOffsets[pKeyCodes[pKeyLookup[i]+1+j]]));

                char * pCursor;
                char pOffset[64];
                char pSize[64];

                char * pStringFragment = pStrings+ArrayOffsets[pKeyCodes[pKeyLookup[i]+1+j]];
                char * pDot = strchr(pStringFragment,'.');
                if (pDot)
                {
                    pDot++;
                    pCursor = pOffset;
                    while (isdigit(*pDot))
                    {
                        *pCursor = *pDot;
                        pCursor++;
                        pDot++;
                    }
                    *pCursor = 0;
                    pCursor = pSize;                    
                    pDot++;
                    while (isdigit(*pDot))
                    {
                        *pCursor = *pDot;
                        pCursor++;
                        pDot++;
                    }
                    *pCursor = 0;

                    int Offset_ = atoi(pOffset);
                    int Size_   = atoi(pSize);

                    Map[Offset_] = Size_;
                    //printf("O = %x S = %x\n",Offset_,Size_);

                    DWORD UNALIGNED * pDW = (DWORD UNALIGNED *)(pObject+Offset_);
                    DWORD WrittenSize = *pDW;
                    if ((DWORD)Size_ != WrittenSize)
                    {
                        bRet = FALSE;                    
                        DBG_PRINTFA((pBuff,"%s O = %x (S = %x) != (F = %x)\n",pStringFragment,Offset_,Size_,WrittenSize));
                    }
                    pDW++;
                    if (ROSWELL_HEAPALLOC_TYPE_BUSY != *pDW)
                    {
                        bRet = FALSE;
                        DBG_PRINTFA((pBuff,"%s O = %x S = %x Type %08x\n",pStringFragment,Offset_,Size_,*pDW));
                    }
                    // verify next ?
                    //pDW = (DWORD UNALIGNED *)(pObject+Offset_+WrittenSize+8)
                }
            }
            if (bVerbose) DBG_PRINTFA((pBuff,"\n")); 
        }

    return bRet;

}

/*

void
DumpAllPages(HANDLE hFile,DWORD * pPage)
{
    // read the AdminPage
    //BOOL bRet;
    //DWORD nRead;
	//DWORD dwSize;
	HANDLE hFileMap = NULL;
	DWORD * pMapIndex = NULL;

    DWORD dwFileSize = GetFileSize(hFile,NULL);
    hFileMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 dwFileSize,
                                 NULL);
    if (hFileMap)
    {
        pMapIndex = (DWORD *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        printf("MapViewOfFile(hFileMapObj) %d\n",GetLastError());
        goto cleanup;
    };

	pPage = pMapIndex;

    //bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    //if (bRet && (PS_PAGE_SIZE == nRead))
    {
        printf("    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_LOGICAL_ROOT],
                pPage[OFFSET_FREE_LIST_ROOT],
                pPage[OFFSET_TOTAL_PAGES],
                pPage[OFFSET_PAGE_SIZE],
                pPage[OFFSET_IMPL_VERSION ]);
    }
    //else
    //{
    //    printf(" ReadFile %d\n",GetLastError());
    //}

    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
        DumpPage(hFile,i,pPage);
    }
    //DWORD dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        printf("    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE));
    }

cleanup:
    if (pMapIndex)
        UnmapViewOfFile(pMapIndex);
    if (hFileMap)
        CloseHandle(hFileMap);

}

*/

BOOL
VerifyAllPages(HANDLE hFileIdx, 
               HANDLE  hFileObj, 
               HANDLE  hFileFre,
               BOOL    bVerbose,
               std::map<DWORD,DWORD> & Map)
{
    BOOL bRet = TRUE;
	HANDLE hFileMap = NULL;
	DWORD * pMapIndex = NULL;

    DWORD dwFileSize = GetFileSize(hFileIdx,NULL);
    
    if (0 == dwFileSize) // empty file is OK;
    {
        goto cleanup;
    }
    
    hFileMap = CreateFileMapping(hFileIdx,
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 dwFileSize,
                                 NULL);
    if (hFileMap)
    {
        pMapIndex = (DWORD *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        DBG_PRINTFA((pBuff,"MapViewOfFile(hFileMap) %d\n",GetLastError()));
        goto cleanup;
    };

    HANDLE hFileMapObj = NULL;
    HANDLE hFileMapFre = NULL;
    BYTE * pMapObj = NULL;
    BYTE * pMapFre = NULL;
    DWORD dwSizeObj = 0;
    DWORD dwSizeFre = 0;

    dwSizeObj = GetFileSize(hFileObj,NULL);    

    if (0 == dwSizeObj) // empty file is OK;
    {
        goto cleanup;
    }
    
    hFileMapObj = CreateFileMapping(hFileObj,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeObj,
                                    NULL);
    if (hFileMapObj)
    {
        pMapObj = (BYTE *)MapViewOfFile(hFileMapObj,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        DBG_PRINTFA((pBuff,"MapViewOfFile(hFileMapObj) %d\n",GetLastError()));
        goto cleanup;
    };

    dwSizeFre = GetFileSize(hFileFre,NULL);

    if (0 == dwSizeFre) // empty file is OK;
    {
        goto cleanup;
    }
    
    hFileMapFre = CreateFileMapping(hFileFre,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeFre,
                                    NULL);

    if (hFileMapFre)
    {
        pMapFre = (BYTE *)MapViewOfFile(hFileMapFre,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        DBG_PRINTFA((pBuff,"MapViewOfFile(hFileMapFre) %d\n",GetLastError()));
        goto cleanup;
    };

	DWORD * pPage = pMapIndex;


    if (bVerbose) DBG_PRINTFA((pBuff,"    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                         pPage[OFFSET_PAGE_TYPE],
                         pPage[OFFSET_PAGE_ID],
                         pPage[OFFSET_NEXT_PAGE],
                         pPage[OFFSET_LOGICAL_ROOT],
                         pPage[OFFSET_FREE_LIST_ROOT],
                         pPage[OFFSET_TOTAL_PAGES],
                         pPage[OFFSET_PAGE_SIZE],
                         pPage[OFFSET_IMPL_VERSION ]));



    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
		pPage = pPage+(PS_PAGE_SIZE/sizeof(DWORD));
        BOOL bLocalRet = VerifyPage(pPage,pMapObj,pMapFre,bVerbose,Map);
        if (!bLocalRet)
        {
            if (bVerbose) DBG_PRINTFA((pBuff,"page %i\n",i));
            bRet = FALSE;
        }
    }

    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        DBG_PRINTFA((pBuff,"    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE)));
    }


cleanup:
    if (pMapIndex)
        UnmapViewOfFile(pMapIndex);
    if (hFileMap)
        CloseHandle(hFileMap);
    if (pMapFre)
        UnmapViewOfFile(pMapFre);
    if (pMapObj)
        UnmapViewOfFile(pMapObj);
    if (hFileMapObj)
        CloseHandle(hFileMapObj);
    if (hFileMapFre)
        CloseHandle(hFileMapFre);

    return bRet;
}



//
//  Validated the Btr
//
//  returns TRUE if no problem
//
////////////////////////////////////////////////////////

BOOL 
ValidateRep(BOOL bVerbose,std::map<DWORD,DWORD> & Map)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	BOOL bRet = FALSE;
	if (ERROR_SUCCESS == GetPageSourceHandle(&hFile))
	{
	    HANDLE hFileObj = INVALID_HANDLE_VALUE;
		HANDLE hFileFre = INVALID_HANDLE_VALUE;

		if (ERROR_SUCCESS == GetObjFreHandles(&hFileObj,&hFileFre))
		{
		    //DBG_PRINTFA((pBuff,"hFile %x hFileObj %x hFileFre %x\n",hFile,hFileObj,hFileFre));
			bRet = VerifyAllPages(hFile,hFileObj,hFileFre,bVerbose,Map);

			CloseHandle(hFileObj);
			CloseHandle(hFileFre);
		}
        CloseHandle(hFile);
	}
	return bRet;
}


void
ReadTrans(HANDLE hFile)
{
    DWORD nRead;
    LONGLONG TransID;

    ReadFile(hFile,&TransID,sizeof(LONGLONG),&nRead,NULL);

    printf("TransID %I64d\n",TransID);

    BYTE InstrType;
    BYTE FileID;
    LONGLONG FileOffset;
    DWORD   Len;
    BOOL bGoOn = TRUE;
    BYTE pHash[16];

    do 
    {
        ReadFile(hFile,&InstrType,sizeof(InstrType),&nRead,NULL);
        switch (InstrType)
        {
        case A51_INSTRUCTION_TYPE_TAIL:
            printf("TAIL or EndOFTransRecord\n");
            bGoOn = FALSE;        
            break;
        case A51_INSTRUCTION_TYPE_WRITEFILE:
	        ReadFile(hFile,&FileID,sizeof(FileID),&nRead,NULL);
    	    ReadFile(hFile,&FileOffset,sizeof(FileOffset),&nRead,NULL);
        	ReadFile(hFile,&Len,sizeof(Len),&nRead,NULL);        
	        SetFilePointer(hFile,Len,NULL,FILE_CURRENT);
    	    printf("InstrType %02x FileID %02x FileOffset %016I64x Len %08x\n",
        	        InstrType,FileID,FileOffset,Len);
        	break;
        case A51_INSTRUCTION_TYPE_SETENDOFFILE:
	        ReadFile(hFile,&FileID,sizeof(FileID),&nRead,NULL);
    	    ReadFile(hFile,&FileOffset,sizeof(FileOffset),&nRead,NULL);
        	ReadFile(hFile,&Len,sizeof(Len),&nRead,NULL);        
	        SetFilePointer(hFile,Len,NULL,FILE_CURRENT);
    	    printf("InstrType %02x FileID %02x FileOffset %016I64x Len %08x\n",
        	        InstrType,FileID,FileOffset,Len);
        	break;
        
            //printf("SETENDOFFILE unimplemented by debug extension\n");
            //bGoOn = FALSE;
            break;
        case A51_INSTRUCTION_TYPE_ENDTRANSACTION:
            ReadFile(hFile,pHash,sizeof(pHash),&nRead,0);
            printf("InstrType %02x %0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2%0X2\n",
        	        InstrType,
        	        pHash[0],pHash[1],pHash[2],pHash[3],
        	        pHash[4],pHash[5],pHash[5],pHash[7],
        	        pHash[8],pHash[9],pHash[10],pHash[11],
        	        pHash[12],pHash[13],pHash[14],pHash[15]);
            break;
        default:
            printf("Instruction Type %08x unknown\n",InstrType);
            bGoOn = FALSE;
            break;
        }
    } while(NO_ERROR == GetLastError() && bGoOn);
};



//
//  given a sequence of <SIZE,OFFSET>
//  given the offset, retun the size if offset is there
//  otherwise returns 0 for NOT_FOUND
//
DWORD 
FindOffset(DWORD * pSequence,DWORD Size,DWORD dwOffsetToSearch)
{
    DWORD NumRecords = Size/(2*sizeof(DWORD));
    DWORD i;
    DWORD dwSize = 0;
    DWORD dwOffset = 0;
    
    for(i=0;i<NumRecords;i++)
    {
        dwSize   = *pSequence++;
        dwOffset = *pSequence++;
        if (dwOffset == dwOffsetToSearch)
        {
            return dwSize;
        }
    }
    return 0;
}


BOOL
ValidateObjFreReal(HANDLE hFileObj, 
                   HANDLE hFileFre, 
                   BOOL bVerbose, 
                   std::map<DWORD,DWORD> & Map)
{
    BOOL bRet = TRUE;
    HANDLE hFileMapObj = NULL;
    HANDLE hFileMapFre = NULL;
    BYTE * pMapObj = NULL;
    BYTE * pMapFre = NULL;
    DWORD dwSizeObj = 0;
    DWORD dwSizeFre = 0;

    dwSizeObj = GetFileSize(hFileObj,NULL);
    
    if (0 == dwSizeObj)
    {
        bRet =  TRUE;
        goto cleanup;        
    }
    
    hFileMapObj = CreateFileMapping(hFileObj,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeObj,
                                    NULL);
    if (hFileMapObj)
    {
        pMapObj = (BYTE *)MapViewOfFile(hFileMapObj,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        DBG_PRINTFA((pBuff,"MapViewOfFile(hFileMapObj) %d\n",GetLastError()));
        bRet = FALSE;
        goto cleanup;
    };

    dwSizeFre = GetFileSize(hFileFre,NULL);
    hFileMapFre = CreateFileMapping(hFileFre,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeFre,
                                    NULL);

    if (hFileMapFre)
    {
        pMapFre = (BYTE *)MapViewOfFile(hFileMapFre,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        DBG_PRINTFA((pBuff,"MapViewOfFile(hFileMapFre) %d\n",GetLastError()));
        goto cleanup;
    };

    //
    // algorithm:
    // read the <SIZE,SIGNATURE> sequence
    // if there  SIGNATURE == 'QQQQ', than look for the current 
    // offset in the Fre List
    // if block not found, suspect the case of a small block
    // 
    if (pMapFre && pMapObj)
    {
        DWORD UNALIGNED * pdwSize = (DWORD UNALIGNED *)pMapObj;
                
        while ((BYTE *)pdwSize < (pMapObj+dwSizeObj))
        {
            DWORD dwSize;
            DWORD dwSign;
            dwSize = *pdwSize++;
            if ((BYTE *)pdwSize >= (pMapObj+dwSizeObj)) 
            {
                break;
            }
            else
            {
                dwSign = *pdwSize++;
            }
            if (ROSWELL_HEAPALLOC_TYPE_FREE == dwSize)
            {
                pdwSize -= 2;
                DWORD dwOffset = (DWORD)((BYTE *)pdwSize-pMapObj);
                dwSize = FindOffset((DWORD *)pMapFre,dwSizeFre,dwOffset);
                if (dwSize)
                {
                    if (bVerbose) DBG_PRINTFA((pBuff,"free @%08x - %08x -\n",dwOffset,dwSize));
                    pdwSize = (DWORD UNALIGNED *)((BYTE *)pdwSize+dwSize);
                }
                else
                {
                    DBG_PRINTFA((pBuff,"could not find free entry for offset @%08x\n",dwOffset));
                    bRet = FALSE;

	                std::map<DWORD,DWORD>::iterator it = Map.find(dwOffset);

    	            if ( it == Map.end())
        	        {
            	        // this is OK, the index is not pointing there
                	}
                	else
                	{
                	    DBG_PRINTFA((pBuff,"block at offset @%08x FOUND in Index\n",dwOffset));
                	    bRet = FALSE;
                	}

	                // attempt to recover
					//
					// if there is a 'QQQQ' signature followed by a 'A51A51A5'
					// this fragment will loop. Skip next byte
					//

	                BYTE * pByte = (BYTE *)pdwSize;
					pByte+=5;
					//printf("Offset %x\n",(DWORD)pByte-(DWORD)pMapObj);
	                while (pByte < (pMapObj+dwSizeObj))
	                {
	                    DWORD Signature = *((DWORD UNALIGNED *)pByte);
						//printf("Offset %x - %08x\n",(DWORD)pByte-(DWORD)pMapObj,Signature);
	                    if (ROSWELL_HEAPALLOC_TYPE_BUSY == Signature)
	                    {
	                        DBG_PRINTFA((pBuff,"restarting @%08x\n",pByte-pMapObj-4));
	                        pdwSize = (DWORD UNALIGNED *)(pByte-4);
	                        break;
	                    }
	                    else
	                    {
	                        pByte++;
	                    }
	                }
	                if (pByte >= (pMapObj+dwSizeObj)) // end of file
	                {
	                    break;  // main while loop
	                }                                       
                }
            }
            else if(ROSWELL_HEAPALLOC_TYPE_BUSY == dwSign)
            {
                DWORD dwOffset = (DWORD)((BYTE *)pdwSize-pMapObj-(2*sizeof(DWORD)));
                std::map<DWORD,DWORD>::iterator it = Map.find(dwOffset);

                if ( it == Map.end())
                {
                    DBG_PRINTFA((pBuff,"block at offset @%08x not found in Index\n",dwOffset));
                    bRet = FALSE;
                }
            
                if (bVerbose) DBG_PRINTFA((pBuff,"busy @%08x - %08x\n",dwOffset,dwSize));
                pdwSize = (DWORD UNALIGNED *)((BYTE *)pdwSize+dwSize);                
            } 
            else // the signatures do not match 
            {
                pdwSize -= 2;
                DWORD dwOffset = (DWORD)((BYTE *)pdwSize-pMapObj);

                dwSize = FindOffset((DWORD *)pMapFre,dwSizeFre,dwOffset);
                
                if (dwSize)
                {
                    // very small block 
                    if (bVerbose) DBG_PRINTFA((pBuff,"free @%08x - %08x -\n",dwOffset,dwSize));
                    pdwSize = (DWORD UNALIGNED *)((BYTE *)pdwSize+dwSize);                    
                }
                else
                {                
	                DBG_PRINTFA((pBuff,"could not find free entry for offset @%08x\n",(BYTE *)pdwSize-pMapObj));
	                bRet = FALSE;
	                
	                // attempt to recover

	                BYTE * pByte = (BYTE *)pdwSize;
	                while (pByte < (pMapObj+dwSizeObj))
	                {
	                    DWORD Signature = *((DWORD UNALIGNED *)pByte);
	                    if (ROSWELL_HEAPALLOC_TYPE_BUSY == Signature)
	                    {
	                        DBG_PRINTFA((pBuff,"restarting @%08x\n",pByte-pMapObj-4));
	                        pdwSize = (DWORD UNALIGNED *)(pByte-4);
	                        break;
	                    }
	                    else
	                    {
	                        pByte++;
	                    }
	                }
	                if (pByte == (pMapObj+dwSizeObj)) // end of file
	                {
	                    break;            
	                }
                }
            }
        }
        if (bVerbose) DBG_PRINTFA((pBuff,"ended @%08x\n",(BYTE *)pdwSize-pMapObj));
    }

cleanup:
    if (pMapFre)
        UnmapViewOfFile(pMapFre);
    if (pMapObj)
        UnmapViewOfFile(pMapObj);
    if (hFileMapObj)
        CloseHandle(hFileMapObj);
    if (hFileMapFre)
        CloseHandle(hFileMapFre);
        
    return bRet;
};


//
//  Heap File and Free File
//
///////////////////////////////////////////////////

BOOL 
ValidateObjFre(BOOL bVerbose,std::map<DWORD,DWORD> & Map)
{
    HANDLE hFileObj = INVALID_HANDLE_VALUE;
    HANDLE hFileFre = INVALID_HANDLE_VALUE;
    BOOL bRet = FALSE;

	if (ERROR_SUCCESS == GetObjFreHandles(&hFileObj,&hFileFre))
	{
		bRet = ValidateObjFreReal(hFileObj,hFileFre,bVerbose,Map);

		CloseHandle(hFileObj);
	    CloseHandle(hFileFre);
	}
	return bRet;
}

//
//
// main entry point for validation
// returns TRUE if the repository looks OK
//
//////////////////////////////////////////////////

BOOL ValidateRepository()
{
	std::map<DWORD,DWORD> Map;
	BOOL bRet1 = ValidateRep(FALSE,Map);
    BOOL bRet2 = ValidateObjFre(FALSE,Map);	
    //DBG_PRINTFA((pBuff,"%d %d\n",bRet1,bRet2));
    return (bRet1 && bRet2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\secobj\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <windows.h>

#define POLARITY __declspec( dllimport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\ace\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\secobj\secobj.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SECOBJ.CPP

Abstract:

  Implements classes related to A51 security model

  Classes implemented:

      CWmiSecurityCheck    Main class of security model

History:

      07/20/00      marioh    Created.

--*/


#include "precomp.h"
#include <windows.h>
#include <aclapi.h>
#include <winntsec.h>
#include <wbemcli.h>

#include "secobj.h"



//***************************************************************************
//
//***************************************************************************
CWmiSecurityCheck::CWmiSecurityCheck ( )
{
	m_lCount	=1;
	m_pSD		= NULL;
	m_pParent	= NULL;
	InitializeCriticalSection (&m_cs);
}

//***************************************************************************
//
//***************************************************************************
CWmiSecurityCheck::~CWmiSecurityCheck ( )
{
	// free descriptor
	if ( m_pSD != NULL )
		delete m_pSD;
	DeleteCriticalSection (&m_cs);
}


//***************************************************************************
//
//***************************************************************************
LONG CWmiSecurityCheck::AddRef ( )
{
	return InterlockedIncrement ( &m_lCount );
}


//***************************************************************************
//
//***************************************************************************
LONG CWmiSecurityCheck::Release ( )
{
	LONG lCount = InterlockedDecrement ( &m_lCount );
	if ( lCount == 0 )
		delete this;
	return lCount;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiSecurityCheck::SetScopeSD ( PSECURITY_DESCRIPTOR pSD )
{
	HRESULT hRes = S_OK;

	if ( pSD != NULL )
	{
		// Copy the SD for local purposes
		SIZE_T dwSize = GetSecurityDescriptorLength(pSD);							// Get the SD Length
		SECURITY_DESCRIPTOR* piSD = (SECURITY_DESCRIPTOR*) new BYTE[dwSize];		// Allocate mem for SD copy
		ZeroMemory(piSD, dwSize);													// Clear memory
		CopyMemory(piSD, pSD, dwSize);												// Copy the original SD
		m_pSD = new CNtSecurityDescriptor (piSD);									// Initialize new SD wrapper with SD
		if (m_pSD==NULL)
			hRes = WBEM_E_OUT_OF_MEMORY;											// Failed due to out of memory
	}

	return hRes;
}




//***************************************************************************
//
//***************************************************************************
HRESULT CWmiSecurityCheck::SpawnSubscope ( CWmiSecurityCheck** ppSecObj)
{
	HRESULT hRes = S_OK;

	// Initialize new instance of CWmiSecurityCheck
	*ppSecObj = new CWmiSecurityCheck;
	if ( ppSecObj == NULL )														// Failed due to out of memory
		hRes = WBEM_E_OUT_OF_MEMORY;											
	else																		
	{																			
		(*ppSecObj)->m_pParent = this;											// Set the backlink for synthezised SD builds
	}
	return hRes;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiSecurityCheck::AccessCheck ( DWORD dwMask, PSECURITY_DESCRIPTOR pSD)
{
	HRESULT hRes = S_OK;

	// Stub
	
	return hRes;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiSecurityCheck::ComputeEffectiveSD  ( PSECURITY_DESCRIPTOR pSD, DWORD dwSdSize )
{
	HRESULT hRes = S_OK;

	// Stub
	
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\secedit\flexarry.h ===
//***************************************************************************
//
//  (c) 1996-2001 by Microsoft Corp.
//
//  FLEXARRY.H
//
//  CFlexArray and CWStringArray implementation.
//
//  This
//
//  15-Jul-97   raymcc    This implementation is not based on arenas.
//
//***************************************************************************

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class CFlexArray
{
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowBy;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 32, 
        IN int nGrowBy = 32
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    // Gets an element at a particular location.
    // =========================================
    void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void  SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Adds a new element to the end of the array.
    // ===========================================
    int   Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int   Size() const { return m_nSize; }

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    void** GetArrayPtr() { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 32, 
        int nGrowBy = 32
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    wchar_t *GetAt(int nIndex) { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    wchar_t *operator[](int nIndex) { return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    int  Size() { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\ace\bstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\ace\bstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.H

Abstract:

History:

--*/

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor\bstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor\bstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.H

Abstract:

History:

--*/

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\secobj\secobj.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SECOBJ.H

Abstract:

  Defines classes related to A51 security model

  Classes implemented:

      CWmiSecurityCheck    Main class of security model

History:

      07/20/00      marioh    Created.

--*/

#include <winntsec.h>

class CWmiSecurityCheck
{
public:
	CWmiSecurityCheck			( );
	virtual ~CWmiSecurityCheck	( );

	// Object life control
	LONG	AddRef				( );
	LONG	Release				( );


	// Main security related methods
	HRESULT SetScopeSD			( PSECURITY_DESCRIPTOR );
	HRESULT AccessCheck			( DWORD, PSECURITY_DESCRIPTOR );
	HRESULT SpawnSubscope		( CWmiSecurityCheck** );
	HRESULT ComputeEffectiveSD  ( PSECURITY_DESCRIPTOR, DWORD );


protected:
	LONG					m_lCount;					// Ref counting
	CNtSecurityDescriptor*	m_pSD;						// Current security descriptor
	CWmiSecurityCheck*		m_pParent;					// Backlink to previous scope
	CRITICAL_SECTION		m_cs;						// Sync.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\ace\ace.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ACE.CPP

Abstract:

    Security Test Tool

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include <time.h>
#include <wbemidl.h> 
#include <cominit.h>
#include <bstring.h>
#include <corepol.h>
#include <winntsec.h>
SCODE sc;
CNtSecurityDescriptor gSD;
WCHAR wPath[MAX_PATH];

class ReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    ReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~ReleaseMe() {if(m_pUnk) m_pUnk->Release();}
};

bool MoveVariantIntoGlobalSD(VARIANT * pvar)
{
    if(pvar->vt != (VT_ARRAY | VT_UI1))
        return false;
    SAFEARRAY * psa = pvar->parray;
    PSECURITY_DESCRIPTOR pSD;
    sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if(sc != 0)
        return false;
    CNtSecurityDescriptor temp(pSD);
    gSD = temp;
    SafeArrayUnaccessData(psa);
    return true;
}


bool LoadSD(IWbemServices * pServices)
{
    bool bRet = false;
    CBString InstPath(L"__systemsecurity=@");
    CBString MethName(L"GetSD");

    IWbemClassObject * pOutParams = NULL;
    sc = pServices->ExecMethod(InstPath.GetString(),
            MethName.GetString(),
            0,
            NULL, NULL,
            &pOutParams, NULL);
    if(sc == S_OK)
    {
        CBString prop(L"sd");
        VARIANT var;
        VariantInit(&var);
        sc = pOutParams->Get(prop.GetString(), 0, &var, NULL, NULL);
        if(sc == S_OK)
        {
            MoveVariantIntoGlobalSD(&var);
            VariantClear(&var);
            bRet = true;
        }
    }

    return bRet;
}

bool StoreSD(IWbemServices * pSession)
{
    bool bRet = false;

    // Get the class object

    IWbemClassObject * pClass = NULL;
    CBString InstPath(L"__systemsecurity=@");
    CBString ClassPath(L"__systemsecurity");
    sc = pSession->GetObject(ClassPath.GetString(), 0, NULL, &pClass, NULL);
    if(sc != S_OK)
        return false;
    ReleaseMe c(pClass);

    // Get the input parameter class

    CBString MethName(L"SetSD");
    IWbemClassObject * pInClassSig = NULL;
    sc = pClass->GetMethod(MethName.GetString(),0, &pInClassSig, NULL);
    if(sc != S_OK)
        return false;
    ReleaseMe d(pInClassSig);

    // spawn an instance of the input parameter class

    IWbemClassObject * pInArg = NULL;
    pInClassSig->SpawnInstance(0, &pInArg);
    if(sc != S_OK)
        return false;
    ReleaseMe e(pInArg);


    // move the SD into a variant.

    SAFEARRAY FAR* psa;
    SAFEARRAYBOUND rgsabound[1];    rgsabound[0].lLbound = 0;
    long lSize = gSD.GetSize();
    rgsabound[0].cElements = lSize;
    psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
    if(psa == NULL)
        return false;

    char * pData = NULL;
    sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
    if(sc != S_OK)
        return false;

    memcpy(pData, gSD.GetPtr(), lSize);

    SafeArrayUnaccessData(psa);
    VARIANT var;
    var.vt = VT_I4|VT_ARRAY;
    var.parray = psa;

    // put the property

    sc = pInArg->Put(L"SD" , 0, &var, 0);      
    VariantClear(&var);
    if(sc != S_OK)
        return false;

    // Execute the method

    IWbemClassObject * pOutParams = NULL;
    sc = pSession->ExecMethod(InstPath.GetString(),
            MethName.GetString(),
            0,
            NULL, pInArg,
            NULL, NULL);
    if(FAILED(sc))
        printf("\nPut failed, returned 0x%x",sc);

    return bRet;
}


bool AddNTAce(IWbemServices * pSession, WCHAR * wUser, WCHAR * wDomain, 
           WCHAR * wNamespace, long lMask, long lFlags, long lType)
{

    WCHAR wFullName[MAX_PATH];
    wFullName[0] = 0;
    if(wcslen(wDomain) > 1 ||
       (wcslen(wDomain) == 1 && wDomain[0] != L'.'))
    {
        wcscpy(wFullName, wDomain);
        wcscat(wFullName, L"\\");
    }
    wcscat(wFullName, wUser);

    // Read the security descriptor
    
    if(!LoadSD(pSession))
        return false;

    // Add an ace

    CNtAce Ace(
        lMask,
        lType,
        lFlags,
        wFullName,
        0
        );

    if(Ace.GetStatus() != 0)
    {
        printf("\nFAILED!!!!\n");
        return false;
    }
    CNtAcl Acl;
    gSD.GetDacl(Acl);
    Acl.AddAce(&Ace);

    gSD.SetDacl(&Acl);

    // write the security descriptor back

    return StoreSD(pSession);
}

bool Add9XAce(IWbemServices * pSession, WCHAR * wUser, WCHAR * wDomain, 
           WCHAR * wNamespace, long lMask, long lFlags, long lType)
{

    // Read the ntlm user list

    CBString InstPath(L"__systemsecurity=@");
    CBString GetMethName(L"Get9XUserList");
    CBString SetMethName(L"Set9XUserList");
    CBString ClassName(L"__ntlmuser9x");

    CBString MethClassName(L"__systemsecurity");


    IWbemClassObject * pOutParams = NULL;
    SCODE sc = pSession->ExecMethod(InstPath.GetString(),
            GetMethName.GetString(),
            0,
            NULL, NULL,
            &pOutParams, NULL);
    if(sc != S_OK)
    {
        printf("\nfailed executing the Get9XUserList method");
        return false;
    }

    // Get the __ntlmuser9x class and spawn an instance

    IWbemClassObject * pClassObj = NULL;
    IWbemClassObject * pUserInst = NULL;
    sc = pSession->GetObject(ClassName.GetString(), 0, NULL, &pClassObj, NULL);
    if(sc != S_OK)
        return false;
    pClassObj->SpawnInstance(0, &pUserInst);
    pClassObj->Release();

    // Set the arugments

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(wDomain);
    pUserInst->Put(L"Authority", 0, &var, 0);
    SysFreeString(var.bstrVal);

    var.bstrVal = SysAllocString(wUser);
    pUserInst->Put(L"name", 0, &var, 0);
    VariantClear(&var);

    var.vt = VT_I4;
    var.lVal = lType;
    pUserInst->Put(L"Type", 0, &var, 0);


    var.lVal = lFlags;
    pUserInst->Put(L"Flags", 0, &var, 0);

    var.vt = VT_I4;
    var.lVal = lMask;
    pUserInst->Put(L"Mask", 0, &var, 0);

    // Add the new user to the list

    pOutParams->Get(L"ul", 0, &var, NULL, NULL);
    
    SAFEARRAYBOUND sb;

    SAFEARRAY * psa = var.parray;
    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);    

    sb.cElements = lUBound - lLBound + 2;
    sb.lLbound = 0;

    sc = SafeArrayRedim( psa, &sb);
    long lNew = lLBound + sb.cElements -1;
    sc = SafeArrayPutElement(psa,&lNew, pUserInst);


    // Get the parameters class and spawn an instance

    IWbemClassObject * pMethClass = NULL;
    pClassObj = NULL;
    IWbemClassObject * pArgInstObj = NULL;

    sc = pSession->GetObject(MethClassName.GetString(), 0, NULL, &pMethClass, NULL);
    pMethClass->GetMethod(L"Set9XUserList", 0, &pClassObj, NULL);
    pMethClass->Release();

    pClassObj->SpawnInstance(0, &pArgInstObj);
    pClassObj->Release();

    var.vt = VT_ARRAY | VT_UNKNOWN;
    var.parray = psa;

    pArgInstObj->Put(L"ul", 0, &var, NULL);

    // write the list back

    sc = pSession->ExecMethod(InstPath.GetString(),
            SetMethName.GetString(),
            0,
            NULL, pArgInstObj,
            NULL, NULL);
    if(FAILED(sc))
        printf("\nPut failed, returned 0x%x",sc);

    return true;
}

bool AddAnyAce(IWbemLocator * pLocator,WCHAR * wUser, WCHAR * wDomain, 
           WCHAR * wNamespace, long lMask, long lFlags, long lType)
{

    bool bRet;

    // Connect up to the namespace

    IWbemServices * pSession = NULL;
    SCODE sc = pLocator->ConnectServer(wNamespace, NULL, NULL,0,0,NULL,NULL,&pSession);
    if(sc != S_OK)
        return false;
    ReleaseMe r(pSession);

    // Determine if the pc is 9x or nt

    bool bIsNT = false;
    CBString InstPath(L"__systemsecurity=@");
    CBString MethName(L"GetSD");

    IWbemClassObject * pOutParams = NULL;
    sc = pSession->ExecMethod(InstPath.GetString(),
            MethName.GetString(),
            0,
            NULL, NULL,
            &pOutParams, NULL);
    if(sc == S_OK)
    {
        bIsNT = true;
        pOutParams->Release();

    }
    // Add the ace

    if(bIsNT)
        bRet = AddNTAce(pSession, wUser, wDomain, wNamespace, lMask, lFlags, lType);
    else
    {
        if((lMask & WBEM_REMOTE_ACCESS) == 0)
            printf("\nWarning, win9X ACEs require remote access");
        bRet = Add9XAce(pSession, wUser, wDomain, wNamespace, lMask, lFlags, lType);
    }
    return bRet;


}

void PrintUsage()
{
    printf("\nUsage, c:>ace /namespace:root /user:name /domain:redmond /mask:0x3 /flags:2 /type:0\n"
        "where mask 1=enable, 2=methods, 4=full, 8=partial rep, 0x10=provider,\n"
        "0x20=remote access 0x40000=write DACL, 0x20000=read DACL\n"
        "\nFor optional flags, 2 = container inherit\n"
        "For type, 0 = allow (default), 1 = deny");

}

bool GetString(WCHAR * wOut, char * pArg)
{
    // find the ':' in the arugment

    for(;*pArg && *pArg != ':'; pArg++);    // intentional!

    if(*pArg == 0)
        return false;

    pArg++;

    mbstowcs(wOut, pArg, MAX_PATH);
    return true;
}

//***************************************************************************
//
// main
//
// Purpose: Initialized Ole, calls some test code, cleans up and exits.
//
//***************************************************************************

int __cdecl main(int argc, char ** argv)
{
    bool bOK = true;
    long lType = 0;
    long lFlags = 0;
    long lMask = 0;
    WCHAR wUser[MAX_PATH];
    WCHAR wDomain[MAX_PATH];
    WCHAR wNamespace[MAX_PATH];
    wUser[0] = 0;
    wDomain[0] = 0;
    wNamespace[0] = 0;



    if(argc < 2)
    {
        PrintUsage();
        return 1;
    }


    // Initialize com and get the locator pointer

    HRESULT hr = InitializeCom();
    if(hr != S_OK)
        return 1;

    IWbemLocator *pLocator = 0;

    hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, (LPVOID *) &pLocator);
    if(hr != S_OK)
    {
        printf("\nCCI failed, error is 0x%x", hr);
        return 1;
    }
    
    // Get the options

    for(int i = 1; bOK && i < argc; i++)
    {
        char *pcCurrArg = argv[i] + 1; 
        if(argv[i][0] != '-' && argv[i][0] != '/')
        {
            PrintUsage();
            return 1;
        }
        else if(!_strnicmp(pcCurrArg, "namespace:", 10))
        {
            bOK = GetString(wNamespace, pcCurrArg);
        }
        else if(!_strnicmp(pcCurrArg, "domain:", 7))
        {
            bOK = GetString(wDomain, pcCurrArg);
        }
        else if(!_strnicmp(pcCurrArg, "user:", 5))
        {
            bOK = GetString(wUser, pcCurrArg);
        }
        else if(!_strnicmp(pcCurrArg, "mask:", 5))
        {
            if(0 == sscanf(pcCurrArg+5, "%x", &lMask))
                bOK = false;
        }
        else if(!_strnicmp(pcCurrArg, "flags:", 6))
        {
            if(0 == sscanf(pcCurrArg+6, "%x", &lFlags))
                bOK = false;
        }
        else if(!_strnicmp(pcCurrArg, "type:", 5))
        {
            if(0 == sscanf(pcCurrArg+5, "%x", &lType))
                bOK = false;
        }
        else
        {
            bOK = false;
        }

    }

    // Check the choices

    if(lMask & WBEM_FULL_WRITE_REP && ((lMask & WBEM_PARTIAL_WRITE_REP) == 0 ||
        (lMask & WBEM_WRITE_PROVIDER) == 0))
    {
        printf("\nSpecifying full repository write(0x4) requires both \npartial repository write(0x8)"
            " and write provider(0x10) rights.");
        return 1;
    }
    if(!bOK)
    {
        printf("\nInvalid argument");
        PrintUsage();
        return 1;
    }

    // Add the Ace

    AddAnyAce(pLocator, wUser, wDomain, wNamespace, lMask, lFlags, lType);

    pLocator->Release();
    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor-nocom\bstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor-nocom\bstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.H

Abstract:

History:

--*/

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\ace\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\secedit\secedit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  SECEDIT.H
//
//  Support classes for WBEM Security Editor.
//
//  raymcc      8-Jul-97        Created
//  raymcc      5-Feb-98        Fixed some return codes
//
//***************************************************************************

#ifndef _SECEDIT_H_
#define _SECEDIT_H_

//***************************************************************************
//
//***************************************************************************

class CWbemSubject
{
protected:
    LPWSTR m_pName;
    LPWSTR m_pAuthority;
    DWORD  m_dwFlags;
    DWORD  m_dwType;

    CWbemSubject() { /* don't use this */ }      

public:
    enum 
    { 
        Perm_Enabled = 0x1, 
        Perm_Read = 0x2, 
        Perm_WriteInstance = 0x4,
        Perm_WriteClass = 0x8,
        Perm_EditSecurity = 0x10, 
        Perm_ExecuteMethods = 0x20 
    };

    enum 
    {
        Type_Invalid = 0,
        Type_User = 0x1,
        Type_Group = 0x2
    };

    enum { NoError, InvalidParameter, Failed, AccessDenied = 0x5 };

    CWbemSubject(DWORD dwType);
    virtual ~CWbemSubject();
    CWbemSubject(CWbemSubject &Src);
    CWbemSubject & operator =(CWbemSubject &Src);

    int SetName(LPWSTR pName);
        // Returns: NoError, InvalidParameter, Failed

    const LPWSTR GetName() { return m_pName; }
        // Returns string or NULL
    const LPWSTR GetAuthority() { return m_pAuthority; }

    void SetFlags(DWORD dwNewFlags) { m_dwFlags = dwNewFlags; }
        // Replaces the flags entirely

    DWORD GetFlags() { return m_dwFlags; }
        // Returns all flags

    int operator ==(CWbemSubject &Test);
        // Test two users for equality

    BOOL IsEmpty() { return m_pName ? FALSE : TRUE; }
        // Is the object empty?
        
    BOOL IsValid();
        // If FALSE, the user/group is not valid                
};

//***************************************************************************
//
//***************************************************************************

class CWbemUser : public CWbemSubject
{
    friend class CWbemSecurity;     
        // To get at password for computing digests.

public:
    enum { NoError, Failed, InvalidParameter, AccessDenied = 0x5 };

    CWbemUser();
   ~CWbemUser();
    CWbemUser(CWbemUser &Src);
    CWbemUser & operator =(CWbemUser &Src);

    int operator ==(CWbemUser &Test) { return CWbemSubject::operator==(Test); }

    int SetNtlmDomain(
        LPWSTR pszDomain
        );
        // Returns NoError, or Failed

    const LPWSTR GetNtlmDomain()  { return m_pAuthority; }    
        // Returns NULL if NTLM is disabled

    BOOL IsValid();
        // If FALSE, the user/group is not valid                
};

//***************************************************************************
//
//***************************************************************************

class CWbemSecurity;

class CWbemGroup : public CWbemSubject
{
    DWORD         m_dwGroupFlags;

public:
    enum { NoError, Failed, NoMoreData, InvalidParameter, NotFound, AccessDenied };
    enum { 
        GroupType_Undefined   = 0,
        GroupType_NTLM_Local  = 1,
        GroupType_NTLM_Global = 2 
        };

    CWbemGroup();
   ~CWbemGroup();
    CWbemGroup(CWbemGroup &Src);
    CWbemGroup & operator =(CWbemGroup &Src);

    int operator ==(CWbemGroup &Test) { return CWbemSubject::operator==(Test); }

    BOOL SetNtlmDomain(
        LPWSTR pszDomainName
        );
        // Sets the domain name if the group is an NTLM group

    const LPWSTR GetNtlmDomain()  { return m_pAuthority; }    
        // Gets the NTLM domain name if the group is an NTLM group

    BOOL IsValid();
        // If FALSE, the user/group is not valid                

    DWORD GetGroupFlags() { return m_dwGroupFlags; }
    void  SetGroupFlags(DWORD dwSrc) { m_dwGroupFlags = dwSrc; }
};


//***************************************************************************
//
//***************************************************************************

class CWbemSecurity
{
    CFlexArray      m_aGroups;
    CFlexArray      m_aUsers;
    CFlexArray      m_aOriginalObjects;
    DWORD           m_dwFlags;
    IWbemServices   *m_pSecurity;

    friend class CWbemGroup;

    // Disallow public construction, assignment, and initialization.
    // ==============================================================
    CWbemSecurity() {}
    CWbemSecurity(CWbemSecurity &Src) {  /* Not to be used */ }

    DWORD Load();
    DWORD LoadObject(
        IWbemClassObject *pObj
        );

    DWORD BuildNewUserList();
    DWORD BuildUser(
        CWbemUser &User, 
        IWbemClassObject *pUser
        );

    DWORD BuildNewGroupList();
    DWORD BuildGroup(
        CWbemGroup &Grp, 
        IWbemClassObject *pGroupDef
        );

    DWORD PurgeDeletedSubjects();


public:
    enum { NoError, Failed, NoMoreData, AlreadyExists, AccessDenied = 0x5, 
        NotFound, InvalidParameter, InvalidUser, InvalidGroup, QueryFailure,
        ExistsAsGroup, ExistsAsUser, AlienSubject
        };

    static int Login(
        LPWSTR pUser,
        LPWSTR pPassword,
        LPWSTR pDomain,
        DWORD  dwReserved,
        CWbemSecurity **pSecEdit
        );      
        // Factory
        // Returns NoError, AccessDenied, InvalidParameter, Failed
        // The returned pointer is deallocated using operator delete

    
    int CommitChanges();
        // Updates the WBEM database with all changes.
        // This should be called if the user does not CANCEL edits.

   ~CWbemSecurity();

    // Users.
    // ======

    // Nested users within this group.
    // ===============================        

    int GetNumUsers() { return m_aUsers.Size(); }
    CWbemUser GetUser(int n);

    int DeleteUser(
        LPWSTR pszUser,
        LPWSTR pszDomain         
        );
        // returns NoError, NotFound, AccessDenied, InvalidParameter

    int PutUser(    
        CWbemUser &User,
        BOOL bCreate = TRUE     // Set to FALSE for an update
        );    
        // Returns NoError, NotFound, AccessDenied, AlreadyExists, InvalidUser

    BOOL FindUser(
        IN LPWSTR pszUserName,
        LPWSTR pszDomain,         
        OUT CWbemUser &User
        );
        // Returns TRUE if found, FALSE if not

    // Global group list.
    // ==================

    int GetNumGroups() { return m_aGroups.Size(); }
    CWbemGroup GetGroup(int n);

    int DeleteGroup(
        LPWSTR pszGroup,
        LPWSTR pszDomain      
        );

    int PutGroup(    
        CWbemGroup &Group
        );    
        // Returns FALSE if the group was invalid, TRUE if group
        // was updated or added.

    BOOL FindGroup(
        LPWSTR pszGroupName,
        LPWSTR pszDomain,         
        OUT CWbemGroup &Group
        );
        // Returns NoError, Failed, NotFound, InvalidParameter
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\secedit\flexarry.cpp ===
//***************************************************************************
//
//  (c) 1996-2001 by Microsoft Corp.
//
//  FLEXARRY.CPP
//
//  CFlexArray implementation (non-arena).
//
//  15-Jul-97  raymcc    Created.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <flexarry.h>

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowBy
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowBy = nGrowBy;

    m_pArray = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * nSize);
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    LocalFree(m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowBy = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowBy = Src.m_nGrowBy;

    LocalFree(m_pArray);
    m_pArray = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * m_nExtent);
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nExtent);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;
        
    for (int i = nIndex; i < m_nSize - 1; i++) 
        m_pArray[i] = m_pArray[i + 1];

    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) 
    {
        if (m_nGrowBy == 0)
            return array_full;
        m_nExtent += m_nGrowBy;
        void **pTmp = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * m_nExtent);
        if (!pTmp)
            return out_of_memory;                
        for (int i = 0; i < m_nSize; i++)
            pTmp[i] = m_pArray[i];
        LocalFree(m_pArray);
        m_pArray = pTmp;
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) 
    {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================
    
    for (int i = m_nSize; i > nIndex; i--) 
        m_pArray[i] = m_pArray[i - 1];

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%X\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowBy = %d\n", m_nGrowBy);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%d] = %X\n", i, m_pArray[i]);
        else
            printf("?[%d] = %X\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while (m_pArray[nRightCursor] == 0 && nRightCursor < m_nSize)
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    while (m_pArray[m_nSize - 1] == 0 && m_nSize > 0) m_nSize--;
}    

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    LocalFree(m_pArray);
    m_pArray = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * m_nGrowBy);
    m_nSize = 0;
    m_nExtent = m_nGrowBy;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    Empty();
    return pp;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
    LocalFree(m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) 
    {
        for (int i = 0; i < m_Array.Size(); i++)
            if (_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else 
    {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
        wcscpy(pCopy, pSrc);
        m_Array.Add(pCopy);
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
    wcscpy(pNewStr, pSrc);
    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
    wcscpy(pNewStr, pSrc);
    return m_Array.InsertAt(nIndex, pNewStr);
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    LocalFree(pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, wchar_t *pSrc)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
        LocalFree(pDoomedString);

    wchar_t *pNewStr = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
    wcscpy(pNewStr, pSrc);
    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
        LocalFree(m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               _wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
        if (Src2.FindStr(Src1[i], no_case) == -1)
            Diff.Add(Src1[i]);    
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
        if (Src2.FindStr(Src1[i], no_case) != -1)
            Output.Add(Src1[i]);
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
        if (Output.FindStr(Src2[i], no_case) == not_found)
            Output.Add(Src2[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\testprov\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor\seceditor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  trantest.cpp 
//
//  Module: trantest.exe
//
//  Purpose: Exercises the various transports both locally and remotely.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include <time.h>
#include <wbemidl.h> 
#include "cominit.h"
#include <..\wbemtest\bstring.h>
#include <winntsec.h>
SCODE sc;
CNtSecurityDescriptor gSD;
WCHAR wPath[MAX_PATH];

class ReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    ReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~ReleaseMe() {if(m_pUnk) m_pUnk->Release();}
};

IWbemServices * GetServices()
{

    IWbemLocator *pLocator = 0;
    IWbemServices *pSession = 0;

    sc = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, (LPVOID *) &pLocator);

    if(sc != S_OK)
    {
        printf("\nCoCreateInstance failed!!!! sc = 0x%0x",sc);
        return NULL;
    }

    sc = pLocator->ConnectServer(wPath, NULL, NULL,0,0,NULL,NULL,&pSession);
    pLocator->Release();

    if(sc == S_OK)
    {
        SetInterfaceSecurity(pSession, NULL, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_IMP_LEVEL_IMPERSONATE, 0);
    }
    else
        printf("\n Connect server failed 0x%x", sc);
    return pSession;
}

bool MoveVariantIntoGlobalSD(VARIANT * pvar)
{
    if(pvar->vt != (VT_ARRAY | VT_UI1))
        return false;
    SAFEARRAY * psa = pvar->parray;
    PSECURITY_DESCRIPTOR pSD;
    sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if(sc != 0)
        return false;
    CNtSecurityDescriptor temp(pSD);
    gSD = temp;
    gSD.Dump();
    SafeArrayUnaccessData(psa);
    return true;
}


bool LoadSD()
{
    bool bRet = false;
    IWbemServices * pServices = GetServices();
    ReleaseMe r(pServices);
    if(pServices)
    {
        CBString InstPath(L"__systemsecurity=@");
        CBString MethName(L"GetSD");

        IWbemClassObject * pOutParams = NULL;
        sc = pServices->ExecMethod(InstPath.GetString(),
                MethName.GetString(),
                0,
                NULL, NULL,
                &pOutParams, NULL);
        if(sc == S_OK)
        {
            CBString prop(L"sd");
            VARIANT var;
            VariantInit(&var);
            sc = pOutParams->Get(prop.GetString(), 0, &var, NULL, NULL);
            if(sc == S_OK)
            {
                MoveVariantIntoGlobalSD(&var);
                VariantClear(&var);
                bRet = true;
            }
        }

    }
    return bRet;
}

DWORD QueryForFlag(char * Prompt, long OrInBit)
{
    printf("%s", Prompt);
    char cBuff[40];
    scanf("%s", cBuff);
    if(cBuff[0] == 'y' || cBuff[0] == 'Y')
        return OrInBit;
    else
        return 0;
}
bool AddAce(bool bAllow)
{

    char cUser[128]; WCHAR wcUser[128];
    printf("\nEnter the user name (EX:REDMOND\\USER):");
    scanf("%s", cUser);
    mbstowcs(wcUser, cUser, 128);

    printf("\nEnter the permissions mask (EX:6001F):");
    DWORD dwMask;
    scanf("%x", &dwMask);

    if(dwMask & WBEM_FULL_WRITE_REP && ((dwMask & WBEM_PARTIAL_WRITE_REP) == 0 ||
        (dwMask & WBEM_WRITE_PROVIDER) == 0))
    {
        printf("\nSpecifying full repository write(0x4) requires both \npartial repository write(0x8)"
            " and write provider(0x10) rights.\n");
        return false;
    }


    DWORD lFlags = 0;
    lFlags |= QueryForFlag("\nDo you want CONTAINER_INHERIT_ACE ? (y/n):", CONTAINER_INHERIT_ACE);
    lFlags |= QueryForFlag("\nDo you want INHERIT_ONLY_ACE ? (y/n):", INHERIT_ONLY_ACE);
    lFlags |= QueryForFlag("\nDo you want NO_PROPAGATE_INHERIT_ACE ? (y/n):", NO_PROPAGATE_INHERIT_ACE);


    CNtAce Ace(
        dwMask,
        (bAllow) ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE ,
        lFlags,
        wcUser,
        0
        );

    if(Ace.GetStatus() != 0)
    {
        printf("\nFAILED!!!!\n");
        return false;
    }
    CNtAcl Acl;
    gSD.GetDacl(Acl);
    Acl.AddAce(&Ace);

    gSD.SetDacl(&Acl);
    return true;
}

DeleteAce()
{
    printf("\nEnter the ace to be deleted, 0 being the first (-1 to bail):");
    int Index;
    scanf("%d", &Index);
    if(Index == -1)
        return true;
    CNtAcl Acl;
    gSD.GetDacl(Acl);

    if(!Acl.DeleteAce(Index))
        printf("\ndelete failed\n");

    gSD.SetDacl(&Acl);
    return true;

}
bool StoreSD()
{
    bool bRet = false;
    bool bToProtect = false;
    printf("\nDo you want to protect this from inherited aces?(0=no, 1=yes):");
    int iRet;
    scanf("%d", &iRet);
    if(iRet == 1)
        bToProtect = true;
    PSECURITY_DESCRIPTOR pActualSD = gSD.GetPtr();
    SetSecurityDescriptorControl(pActualSD, SE_DACL_PROTECTED,
        (bToProtect) ? SE_DACL_PROTECTED : 0);

    IWbemServices * pServices = GetServices();
    ReleaseMe r(pServices);
    if(pServices)
    {

        // Get the class object

        IWbemClassObject * pClass = NULL;
        CBString InstPath(L"__systemsecurity=@");
        CBString ClassPath(L"__systemsecurity");
        sc = pServices->GetObject(ClassPath.GetString(), 0, NULL, &pClass, NULL);
        if(sc != S_OK)
            return false;
        ReleaseMe c(pClass);

        // Get the input parameter class

        CBString MethName(L"SetSD");
        IWbemClassObject * pInClassSig = NULL;
        sc = pClass->GetMethod(MethName.GetString(),0, &pInClassSig, NULL);
        if(sc != S_OK)
            return false;
        ReleaseMe d(pInClassSig);

        // spawn an instance of the input parameter class

        IWbemClassObject * pInArg = NULL;
        pInClassSig->SpawnInstance(0, &pInArg);
        if(sc != S_OK)
            return false;
        ReleaseMe e(pInArg);


        // move the SD into a variant.

        SAFEARRAY FAR* psa;
        SAFEARRAYBOUND rgsabound[1];    rgsabound[0].lLbound = 0;
        long lSize = gSD.GetSize();
        rgsabound[0].cElements = lSize;
        psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
        if(psa == NULL)
            return false;

        char * pData = NULL;
        sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
        if(sc != S_OK)
            return false;

        memcpy(pData, gSD.GetPtr(), lSize);
    
        SafeArrayUnaccessData(psa);
        VARIANT var;
        var.vt = VT_I4|VT_ARRAY;
        var.parray = psa;

        // put the property

        sc = pInArg->Put(L"SD" , 0, &var, 0);      
        VariantClear(&var);
        if(sc != S_OK)
            return false;
    
        // Execute the method

        IWbemClassObject * pOutParams = NULL;
        sc = pServices->ExecMethod(InstPath.GetString(),
                MethName.GetString(),
                0,
                NULL, pInArg,
                NULL, NULL);
        printf("\nResult code was 0x%x", sc);
        if(sc)
        {
			printf(" Reinitializing stored security descriptor!\n");
		}

    }
    return bRet;
}

//***************************************************************************
//
// main
//
// Purpose: Initialized Ole, calls some test code, cleans up and exits.
//
//***************************************************************************
enum Commands{LOAD = 1, STORE, DISPLAY, DELETEACE, ADDALLOWACE,ADDDENYACE, QUIT};

int PrintAndGetOption()
{
    bool NotDone = true;
    int iRet;
    while (NotDone)
    {
        printf("\n1=Load Security Descriptor\n2=Store Security Descriptor\n3=Display Security Descriptor\n4=Delete ACE"
            "\n5=Add Allow Ace\n6=Add Deny Ace\n7=quit\nEnter Option:");
        scanf("%d", &iRet);
        if(iRet >= LOAD && iRet <= QUIT)
            NotDone = false;
    }
    return iRet;
}



int _cdecl main(int iArgCnt, char ** argv)
{

    if(iArgCnt < 2)
    {
        printf("\nError, you must enter a namespace path.  ex;\nc:>seceditor root\\default\n");
        return 1;
    }

    mbstowcs(wPath, argv[1], MAX_PATH);

    HRESULT hr = InitializeCom();
    if(!LoadSD())
        return 1;

    int iOpt = PrintAndGetOption();
    while (iOpt != QUIT)
    {
        switch(iOpt)
        {
        case LOAD:
            LoadSD();
            break;

        case STORE:
            StoreSD();
            break;

        case DISPLAY:
            gSD.Dump();
            break;
        case DELETEACE:
            DeleteAce();
            break;
        case ADDALLOWACE:
            AddAce(true);
            break;
        case ADDDENYACE:
            AddAce(false);
            break;
        }

        iOpt = PrintAndGetOption();
    }


    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\secedit\secedit.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  SECEDIT.CPP
//
//  Support classes for WBEM Security Editor.
//
//  raymcc      11-Jul-97       Created
//  raymcc      29-Jan-98       Updated for v1 Revised Security
//  raymcc      5-Feb-98        Fixed some return codes
//
//***************************************************************************



#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>
#include <flexarry.h>

#include <secedit.h>
#include <md5wbem.h>
#include <oahelp.inl>


//***************************************************************************
//
//  String helpers
//
//***************************************************************************

inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}


LPWSTR GetExpandedSlashes(LPWSTR pszUserName)
{
    static WCHAR wcBuff[MAX_PATH];
    memset(wcBuff,0,MAX_PATH*2);
    WCHAR * pTo;
    for(pTo = wcBuff; *pszUserName; pTo++, pszUserName++)
    {
        if(*pszUserName == '\\')
        {
            *pTo = '\\';
            pTo++;
        }
        *pTo = *pszUserName;
    }
    return wcBuff;
}

// Version which takes nulls into consideration.

BOOL StringTest(LPWSTR psz1, LPWSTR psz2)
{
    if (psz1 == 0 && psz2 == 0)
        return TRUE;

    if (psz1 == 0 || psz2 == 0)
        return FALSE;

    return _wcsicmp(psz1, psz2) == 0;
}


//***************************************************************************
//
//  CWbemSubject default constructor.
//
//***************************************************************************
// ok

CWbemSubject::CWbemSubject(DWORD dwType)
{
    m_pName = 0;
    m_pAuthority = Macro_CloneLPWSTR(L".");
    m_dwFlags = 0;
    m_dwType = dwType;
}

//***************************************************************************
//
//  CWbemSubject destructor.
//
//***************************************************************************
// ok

CWbemSubject::~CWbemSubject()
{
    delete [] m_pName;
    delete [] m_pAuthority;
}

//***************************************************************************
//
//  CWbemSubject copy constructor.
//
//***************************************************************************
// ok

CWbemSubject::CWbemSubject(CWbemSubject & Src)
{
    m_pName = 0;
    m_dwFlags = 0;
    m_dwType = 0;
    m_pAuthority = 0;
    *this = Src;
}

//***************************************************************************
//
//  CWbemSubject assignment operator.
//
//***************************************************************************
// ok

CWbemSubject & CWbemSubject::operator = (CWbemSubject & Src)
{
    delete [] m_pName;
    delete [] m_pAuthority;

    m_pName = Macro_CloneLPWSTR(Src.m_pName);
    m_pAuthority = Macro_CloneLPWSTR(Src.m_pAuthority);

    m_dwFlags = Src.m_dwFlags;
    m_dwType  = Src.m_dwType;

    return *this;
}

//***************************************************************************
//
//  CWbemSubject::operator ==
//
//  Comparison operator.
//
//  Tests only the name, domain and type.  Other functionality relies on
//  this test *not* being extended.  Don't touch it!
//
//***************************************************************************
// ok

int CWbemSubject::operator ==(CWbemSubject &Test)
{
    if (Test.m_dwType != m_dwType)
        return 0;

    if (StringTest(Test.m_pName, m_pName) == FALSE)
        return 0;

    if (StringTest(Test.m_pAuthority, m_pAuthority) == FALSE)
        return 0;

    return TRUE;
}

//***************************************************************************
//
//  CWbemSubject::SetName
//
//  Sets the subject 'name' field.
//
//  Parameters:
//  <pName>      The new 'name' string (read-only).
//
//  Return values:
//  InvalidParameter, NoError
//
//***************************************************************************
// ok

int CWbemSubject::SetName(LPWSTR pName)
{
    if (pName == 0 || wcslen(pName) == 0)
        return InvalidParameter;

    m_pName = Macro_CloneLPWSTR(pName);
    return NoError;
}

//***************************************************************************
//
//  CWbemSubject::IsValid
//
//  Determines whether the subject is valid (capable of being written to
//  the database).
//
//  Return value:
//  TRUE if the user has enough data to allow it to be written, FALSE
//  if not.
//
//***************************************************************************
// ok

BOOL CWbemSubject::IsValid()
{
    if (m_pName == 0 || wcslen(m_pName) == 0)
        return FALSE;

    if (m_dwType == 0)
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
//  CWbemUser::CWbemUser
//
//  Default constructor
//
//***************************************************************************
// ok

CWbemUser::CWbemUser()
    : CWbemSubject(CWbemSubject::Type_User)
{
}


//***************************************************************************
//
//  CWbemUser::~CWbemUser
//
//  Destructor
//
//***************************************************************************
// ok

CWbemUser::~CWbemUser()
{
}


//***************************************************************************
//
//  CWbemUser copy constructor
//
//***************************************************************************
// ok

CWbemUser::CWbemUser(CWbemUser &Src) : CWbemSubject(Src)
{
    *this = Src;
}


//***************************************************************************
//
//  CWbemUser::operator =
//
//  Assignment operator
//
//***************************************************************************
// ok

CWbemUser & CWbemUser::operator =(CWbemUser &Src)
{
    CWbemSubject::operator=(Src);   // Copy base class stuff
    return *this;
}


//***************************************************************************
//
//  CWbemUser::SetNtlmDomain
//
//  Sets the domain name if NTLM authentication is in use.
//  Authentication_NTLM must be set before calling this method.
//
//  Parameters:
//  <pszDomain>         The domain name to authenticate againt.
//
//  Return value:
//  NoError, InvalidParameter
//
//***************************************************************************
// ok

int CWbemUser::SetNtlmDomain(
    LPWSTR pszDomain
    )
{
    if (pszDomain)
        m_pAuthority = Macro_CloneLPWSTR(pszDomain);
    else
        m_pAuthority = Macro_CloneLPWSTR(L".");
    return NoError;
}

//***************************************************************************
//
//  CWbemUser::IsValid
//
//  Determines whether the subject is valid (capable of being written to
//  the database).
//
//  Return value:
//  TRUE if the user has enough data to allow it to be written, FALSE
//  if not.
//
//***************************************************************************
// ok

BOOL CWbemUser::IsValid()
{
    return CWbemSubject::IsValid();
}


//***************************************************************************
//
//  CWbemGroup default constructor
//
//***************************************************************************
// ok

CWbemGroup::CWbemGroup()
    : CWbemSubject(CWbemSubject::Type_Group)
{
    m_dwGroupFlags = 0;
}


//***************************************************************************
//
//  CWbemGroup
//
//  Destructor
//
//***************************************************************************
// ok

CWbemGroup::~CWbemGroup()
{
}


//***************************************************************************
//
//  CWbemGroup copy constructor
//
//***************************************************************************
// ok

CWbemGroup::CWbemGroup(CWbemGroup &Src) : CWbemSubject(Src)
{
    m_dwGroupFlags = 0;
    *this = Src;
}

//***************************************************************************
//
//  CWbemGroup assignment operator
//
//***************************************************************************
// ok

CWbemGroup & CWbemGroup::operator =(CWbemGroup &Src)
{
    CWbemSubject::operator=(Src);       // Copy base class stuff

    m_dwGroupFlags = Src.m_dwGroupFlags;
    return *this;
}

//***************************************************************************
//
//  CWbemGroup::IsValid
//
//  Determines whether the subject is valid (capable of being written to
//  the database).
//
//  Return value:
//  TRUE if the group has enough data to allow it to be written, FALSE
//  if not.
//
//***************************************************************************
// ok

BOOL CWbemGroup::IsValid()
{
    if (m_dwGroupFlags == 0)
        return FALSE;

    if (m_dwGroupFlags & GroupType_NTLM_Global)
    {
        if (m_pAuthority == 0 || wcslen(m_pAuthority) == 0)
            return FALSE;
    }

    return CWbemSubject::IsValid();
}


//***************************************************************************
//
//  CWbemGroup::SetNtlmDomain
//
//  Sets the domain name for the group if the group is an NTLM group.
//  Caller must call SetFlags() with GroupType_NTLM before calling
//  this method.
//
//  Parameters:
//  <pszDomainName>         The domain name for the group
//
//  Return value:
//
//
//***************************************************************************
// ok

BOOL CWbemGroup::SetNtlmDomain(
    LPWSTR pszDomainName
    )
{
    if (!(
        (m_dwGroupFlags & GroupType_NTLM_Global) ||
        (m_dwGroupFlags & GroupType_NTLM_Local)
        ))
        return FALSE;

    delete [] m_pAuthority;

    if (pszDomainName)
        m_pAuthority = Macro_CloneLPWSTR(pszDomainName);
    else
        m_pAuthority = Macro_CloneLPWSTR(L".");

    return TRUE;
}


//***************************************************************************
//
//  CWbemSecurity::Login
//
//  Object factory used to log in to the security editor classes.
//
//  Parameters:
//  <pUser>                 User who is logging in.
//  <pPassword>             Password
//  <pDomain>               Authority (Format: "NTLMDOMAIN:xxx") or NULL
//  <dwReserved>            Must be zero.
//  <pSecEdit>              If NoError is returned, receives the
//                          pointer to a new CWbemSecurity object.
//                          Group must deallocate using operator delete.
//
//  Return value:
//  NoError, Failed, AccessDenied
//
//***************************************************************************
// ok

int CWbemSecurity::Login(
    LPWSTR pUser,
    LPWSTR pPassword,
    LPWSTR pDomain,
    DWORD  dwReserved,
    CWbemSecurity **pSecEdit
    )
{
    *pSecEdit = 0;

    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLoc
            );

    if (dwRes != S_OK)
    {
        return Failed;
    }


    IWbemServices *pSvc = 0;

    HRESULT hRes = pLoc->ConnectServer(
        CBSTR(L"\\\\.\\ROOT\\SECURITY"),
        CBSTR(pUser),       // user
        CBSTR(pPassword),   // passwrd
        0,
        0,                  // Login type
        CBSTR(pDomain),
        0,
        &pSvc
        );

    if (hRes)
    {
        pLoc->Release();
        return AccessDenied;
    }

    CWbemSecurity *pNew = new CWbemSecurity;
    pNew->m_pSecurity = pSvc;

    pNew->Load();

    *pSecEdit = pNew;

    return NoError;
}



//***************************************************************************
//
//  CWbemSecurity::GetUser
//
//  Retrieves a user by index.
//
//  Parameters:
//  <n>             The 0-based index of the user to retrieve.
//
//  Return value:
//  The CWbemUser user object.  The name may be NULL if <n> was out of
//  range.
//
//***************************************************************************
// ok

CWbemUser CWbemSecurity::GetUser(int n)
{
    CWbemUser RetUser;

    if (n >= m_aUsers.Size())
        return RetUser;

    RetUser = *(CWbemUser *) m_aUsers[n];
    return RetUser;
}


//***************************************************************************
//
//  CWbemSecurity::DeleteUser
//
//  Removes the user from the database.
//
//  Parameters:
//  <pszUser>    A read-only pointer to the user name to delete.
//  <bCreate>    If TRUE, then create-only.  Otherwise, update-only.
//
//  Return value:
//  NoError, NotFound, InvalidParameter
//
//***************************************************************************
// ok

int CWbemSecurity::DeleteUser(
    LPWSTR pszUser,
    LPWSTR pszDomain
    )
{
    if (pszUser == 0 || wcslen(pszUser) == 0)
        return InvalidParameter;

    BOOL bRes = FALSE;

    // Remove user from main list.
    // ===========================

    for (int i = 0; i < m_aUsers.Size(); i++)
    {
        CWbemUser *pTest = (CWbemUser *) m_aUsers[i];

        if (StringTest(pTest->GetName(), pszUser) == TRUE &&
            StringTest(pTest->GetAuthority(), pszDomain) == TRUE
           )
        {
            delete pTest;
            m_aUsers.RemoveAt(i);
            bRes = TRUE;
            break;
        }
    }

    if (bRes == FALSE)
        return NotFound;

    return NoError;
}


//***************************************************************************
//
//  CWbemSecurity::PutUser
//
//  Writes the user to the database. Creates it if not present, or
//  overwrites the existing definition.
//
//  Parameters:
//  <User>          A copy of the user to write.
//
//  Return value:
//  NoError, InvalidUser, AlreadyExists, ExistsAsGroup
//
//***************************************************************************
// ok

int CWbemSecurity::PutUser(
    CWbemUser &User,
    BOOL bCreate
    )
{
    if (!User.IsValid())
        return InvalidUser;

    // Replace, if possible.
    // =====================

    for (int i = 0; i < m_aUsers.Size(); i++)
    {
        CWbemUser *p = (CWbemUser *) m_aUsers[i];
        if (*p == User)
        {
            if (bCreate)
                return AlreadyExists;
            *p = User;
            return NoError;
        }
    }

    // If here, a new user.  Make sure that there is no group by this name.
    // ====================================================================

    CWbemGroup Grp;
    if (FindGroup(User.GetName(), User.GetAuthority(), Grp) == TRUE)
        return ExistsAsGroup;

    // If here, we can safely add the user.
    // ====================================

    CWbemUser *pNew = new CWbemUser(User);
    m_aUsers.Add(pNew);

    return NoError;
}

//***************************************************************************
//
//  CWbemSecurity::FindUser
//
//  Finds a user based on the name.
//
//  Parameters:
//  <pszUserName>
//
//  Return value:
//  TRUE if found, FALSE if not.  If FALSE is returned <User> is not
//  set to a valid user.
//
//***************************************************************************
// ok

BOOL CWbemSecurity::FindUser(
     IN LPWSTR pszUserName,
     IN LPWSTR pszDomain,
     OUT CWbemUser &User
     )
{
    if (pszUserName == 0 || wcslen(pszUserName) == 0)
        return FALSE;

    for (int i = 0; i < m_aUsers.Size(); i++)
    {
        CWbemUser *pTest = (CWbemUser *) m_aUsers[i];
        if (StringTest(pTest->GetName(), pszUserName) == TRUE &&
            StringTest(pTest->GetAuthority(), pszDomain) == TRUE
            )
        {
            User = *pTest;
            return TRUE;
        }
    }

    return FALSE;
}

//***************************************************************************
//
//  CWbemSecurity::GetGroup
//
//  Retrieves the specified group by 0-based index.
//
//  Parameters:
//  <n>         The index of the group to retrieve.
//
//  Return value:
//  A CWbemGroup object.   This will be empty if the index <n> was out
//  of range. (Call CWbemGroup::IsValid() to determine this.
//
//***************************************************************************
// ok

CWbemGroup CWbemSecurity::GetGroup(int n)
{
    CWbemGroup RetGroup;

    if (n >= m_aGroups.Size())
        return RetGroup;

    RetGroup = *(CWbemGroup *) m_aGroups[n];
    return RetGroup;
}


//***************************************************************************
//
//  CWbemSecurity::DeleteGroup
//
//  Deletes a particular group.
//
//  Parameters:
//  <pszGroup>        A read-only pointer to the name of the group to delete
//
//  Return value:
//  InvalidParameter, NoError, NotFound
//
//***************************************************************************
// ok

int CWbemSecurity::DeleteGroup(
    LPWSTR pszGroup,
    LPWSTR pszDomain
    )
{
    if (pszGroup == 0 || wcslen(pszGroup) == 0)
        return InvalidParameter;

    BOOL bRes = FALSE;

    // Remove group from main list.
    // ============================

    for (int i = 0; i < m_aGroups.Size(); i++)
    {
        CWbemGroup *pTest = (CWbemGroup *) m_aGroups[i];

        if (StringTest(pTest->GetName(), pszGroup) == TRUE &&
            StringTest(pTest->GetAuthority(), pszDomain) == TRUE
            )
        {
            delete pTest;
            m_aGroups.RemoveAt(i);
            return NoError;
        }
    }

    return NotFound;
}


//***************************************************************************
//
//  CWbemSecurity::PutGroup
//
//  Writes a group definition.  Recursively updates any occurrences
//  of the group within other groups.
//
//  Parameters:
//  <Group>         A copy of the CWbemGroup object to add.
//
//  Return value:
//  InvalidGroup, NoError, ExistsAsUser
//
//***************************************************************************
// ok

int CWbemSecurity::PutGroup(
    CWbemGroup &Group
    )
{
    if (!Group.IsValid())
        return InvalidGroup;

    // Replace, if possible.
    // ======================

    for (int i = 0; i < m_aGroups.Size(); i++)
    {
        CWbemGroup *p = (CWbemGroup *) m_aGroups[i];
        if (*p == Group)
        {
            *p = Group;
            return NoError;
        }
    }

    // If here, a new group.  Make sure that there is no user by this name.
    // ====================================================================

    CWbemUser User;
    if (FindUser(Group.GetName(), Group.GetAuthority(), User) == TRUE)
        return ExistsAsUser;

    // If here, a new group.
    // =====================

    CWbemGroup *pNew = new CWbemGroup(Group);
    m_aGroups.Add(pNew);

    return NoError;
}

//***************************************************************************
//
//  CWbemSecurity::FindGroup
//
//  Finds a group based on the name.
//
//  Parameters:
//  <pszGroupName>
//
//  Return value:
//  TRUE if found, FALSE if not.  If FALSE is returned <Group> is not
//  set to a valid group name.
//
//***************************************************************************
// ok

BOOL CWbemSecurity::FindGroup(
     IN LPWSTR pszGroupName,
     IN LPWSTR pszDomain,
     OUT CWbemGroup &Group
     )
{
    if (pszGroupName == 0 || wcslen(pszGroupName) == 0)
        return FALSE;

    for (int i = 0; i < m_aGroups.Size(); i++)
    {
        CWbemGroup *pTest = (CWbemGroup *) m_aGroups[i];

        if (StringTest(pTest->GetName(), pszGroupName) == TRUE
            &&
            StringTest(pTest->GetAuthority(), pszDomain) == TRUE
            )
        {
            Group = *pTest;
            return TRUE;
        }
    }

    return FALSE;
}

//***************************************************************************
//
//  CWbemSecurity destructor
//
//***************************************************************************
// ok

CWbemSecurity::~CWbemSecurity()
{
    if (m_pSecurity)
        m_pSecurity->Release();

    for (int i = 0; i < m_aGroups.Size(); i++)
    {
        CWbemGroup *pTest = (CWbemGroup *) m_aGroups[i];
        delete pTest;
    }

    for (i = 0; i < m_aUsers.Size(); i++)
    {
        CWbemUser *pTest = (CWbemUser *) m_aUsers[i];
        delete pTest;
    }

    for (i = 0; i < m_aOriginalObjects.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) m_aOriginalObjects[i];
        pObj->Release();
    }
}



//***************************************************************************
//
//  CWbemSecurity::Load
//
//  Loads the editing classes with the entire user base and their
//  memberships.
//
//  Under the Revised Security Schema for V1, the query specified actually
//  returns NTLM
//
//***************************************************************************
// ok

DWORD CWbemSecurity::Load()
{
    // Query for all users and groups.
    // ===============================

    CBSTR Language(L"WQL");
    CBSTR Query(L"select * from __Subject");

    IEnumWbemClassObject *pEnum = 0;

    HRESULT hRes = m_pSecurity->ExecQuery(
        Language,
        Query,
        WBEM_FLAG_FORWARD_ONLY,         // Flags
        0,                              // Context
        &pEnum
        );

    if (hRes != 0)
        return QueryFailure;

    ULONG uTotal = 0;

    for (;;)
    {
        IWbemClassObject *pObj = 0;

        ULONG uReturned = 0;

        hRes = pEnum->Next(
            0,                  // timeout
            1,                  // one object
            &pObj,
            &uReturned
            );

        uTotal += uReturned;

        if (uReturned == 0)
            break;

        // If here, another user or group to add to the database.
        // ======================================================

        DWORD dwRes = LoadObject(pObj);

        // Save the object back so that when we write we can
        // write just diffs.
        // =================================================

        if (dwRes == 0)
            m_aOriginalObjects.Add(pObj);
        else
            pObj->Release();    // Release objects we don't own.
    }

    pEnum->Release();

    return NoError;
}


//***************************************************************************
//
//  CWbemSecurity::LoadObject
//
//  Loads a single object.  This might be a user or a group.
//
//***************************************************************************
// ok

DWORD CWbemSecurity::LoadObject(
    IWbemClassObject *pObj
    )
{
    // Determine if the object is a user or a group by examining
    // its class. We are looking for
    // =========================================================

    BOOL bUser = FALSE;
    BOOL bGroup = FALSE;

    CVARIANT vClass;
    pObj->Get(CBSTR(L"__CLASS"), 0, &vClass, 0, 0);

    if (_wcsicmp(vClass, L"__NTLMUser") == 0)
        bUser = TRUE;
    else if (_wcsicmp(vClass, L"__NTLMGroup") == 0)
        bGroup = TRUE;
    else
    {
        // If here, it was a __Subject not related to our security,
        // so we must leave it alone.

        return AlienSubject;
    }


    // Query for properties common to groups and users.
    // ================================================

    CVARIANT vName;
    CVARIANT vEnabled;
    CVARIANT vEditSecurity;
    CVARIANT vExecMethods;
    CVARIANT vPermissions;

    pObj->Get(CBSTR(L"Name"), 0, &vName, 0, 0);
    pObj->Get(CBSTR(L"Enabled"), 0, &vEnabled, 0, 0);
    pObj->Get(CBSTR(L"Permissions"), 0, &vPermissions, 0, 0);
    pObj->Get(CBSTR(L"EditSecurity"), 0, &vEditSecurity, 0, 0);
    pObj->Get(CBSTR(L"ExecuteMethods"), 0, &vExecMethods, 0, 0);

    // Set up the permissions flags.
    // =============================

    DWORD dwFlags = 0;

    if (vEnabled.GetBool())
        dwFlags |= CWbemSubject::Perm_Enabled;

    if (LONG(vPermissions) == 0)
        dwFlags |= CWbemSubject::Perm_Read;
    else if (LONG(vPermissions) == 1)
        dwFlags |= CWbemSubject::Perm_WriteInstance;
    else if (LONG(vPermissions) == 2)
        dwFlags |= CWbemSubject::Perm_WriteClass;

    if (vEditSecurity.GetBool())
        dwFlags |= CWbemSubject::Perm_EditSecurity;

    if (vExecMethods.GetBool())
        dwFlags |= CWbemSubject::Perm_ExecuteMethods;


    // Determine whether a group or user and add in the specific parts.
    // ================================================================

    if (bUser)
    {
        // If a user, set up user-specific parts.
        // ======================================

        CVARIANT vDomain;
        pObj->Get(CBSTR(L"Authority"), 0, &vDomain, 0, 0);

        CWbemUser User;

        User.SetName(vName);
        User.SetFlags(dwFlags);
        User.SetNtlmDomain(vDomain);

        PutUser(User, TRUE);
    }
    else
    {
        // If a group, add in the group-specific parts.
        // ============================================

        CWbemGroup Group;

        Group.SetName(vName);
        Group.SetFlags(dwFlags);

        CVARIANT vGroupType;
        pObj->Get(CBSTR(L"GroupType"), 0, &vGroupType, 0, 0);

        if (LONG(vGroupType) == 0)
            Group.SetGroupFlags(CWbemGroup::GroupType_NTLM_Local);
        else
        {
            CVARIANT vDomain;
            pObj->Get(CBSTR(L"Authority"), 0, &vDomain, 0, 0);
            Group.SetGroupFlags(CWbemGroup::GroupType_NTLM_Global);
            Group.SetNtlmDomain(vDomain);
        }

        PutGroup(Group);
    }

    return NoError;
}

//***************************************************************************
//
//  CWbemSecurity::BuildUser
//
//***************************************************************************
// ok

DWORD CWbemSecurity::BuildUser(
    CWbemUser &User,
    IWbemClassObject *pUser
    )
{
    CVARIANT vUser(User.GetName());
    HRESULT hRes = pUser->Put(CBSTR(L"Name"), 0, &vUser, 0);

    DWORD dwFlags = User.GetFlags();

    if (dwFlags & CWbemSubject::Perm_Enabled)
    {
        pUser->Put(CBSTR(L"Enabled"), 0, CVARIANT(TRUE), 0);
    }

    DWORD dwValue = 0;      // Read-only by default

    if (dwFlags & CWbemSubject::Perm_WriteInstance)
        dwValue = 1;
    if (dwFlags & CWbemSubject::Perm_WriteClass)
        dwValue = 2;

    CVARIANT vPermissions;
    vPermissions.SetLONG(LONG(dwValue));
    pUser->Put(CBSTR(L"Permissions"), 0, &vPermissions, 0);

    if (dwFlags & CWbemSubject::Perm_EditSecurity)
    {
        pUser->Put(CBSTR(L"EditSecurity"), 0, CVARIANT(TRUE), 0);
    }

    if (dwFlags & CWbemSubject::Perm_ExecuteMethods)
    {
        pUser->Put(CBSTR(L"ExecuteMethods"), 0, CVARIANT(TRUE), 0);
    }

    // Get the NTLM domain.
    // ====================
    CVARIANT vDomain;
    LPWSTR pDom = User.GetNtlmDomain();
    if (pDom == 0)
        pDom = L".";
    vDomain.SetStr(pDom);
    pUser->Put(CBSTR(L"Authority"), 0, &vDomain, 0);

    // Write the instance.
    // ===================

    hRes = m_pSecurity->PutInstance(pUser, 0, 0, 0);
    if (hRes)
        return Failed;

    return NoError;
}


//***************************************************************************
//
//  CWbemSecurity::BuildNewUserList
//
//***************************************************************************
// ok

DWORD CWbemSecurity::BuildNewUserList()
{
    // Get the class definition.
    // =========================

    IWbemClassObject *pUserClass = 0;

    HRESULT hRes = m_pSecurity->GetObject(CBSTR(L"__NtlmUser"), 0, 0, &pUserClass, 0);
    if (hRes)
        return Failed;

    // Assert all the users.
    // =====================

    for (int i = 0; i < GetNumUsers(); i++)
    {
        CWbemUser User = GetUser(i);

        if (!User.IsValid())
            continue;

        IWbemClassObject *pUser = 0;

        hRes = pUserClass->SpawnInstance(0, &pUser);
        if (hRes)
            return Failed;

        if (BuildUser(User, pUser))
            return Failed;

        pUser->Release();
    }

    // Release class definitions.
    // ==========================

    pUserClass->Release();

    return NoError;
}


//***************************************************************************
//
//  CWbemSecurity::BuildNewGroupBase
//
//***************************************************************************
// ok

DWORD CWbemSecurity::BuildNewGroupList()
{
    HRESULT hRes;

    // Create all the groups.
    // ======================

    IWbemClassObject *pNtlmGroupClass = 0;

    hRes = m_pSecurity->GetObject(CBSTR(L"__NTLMGroup"), 0, 0, &pNtlmGroupClass, 0);
    if (hRes)
       return Failed;

    for (int i = 0; i < GetNumGroups(); i++)
    {
        CWbemGroup Group = GetGroup(i);

        if (!Group.IsValid())
            continue;

        IWbemClassObject *pGroup = 0;
        hRes = pNtlmGroupClass->SpawnInstance(0, &pGroup);

        if (hRes)
            return Failed;

        if (BuildGroup(Group, pGroup))
            return Failed;

        pGroup->Release();
    }

    pNtlmGroupClass->Release();

    return NoError;
}

//***************************************************************************
//
//  CWbemSecurity::BuildGroup
//
//***************************************************************************
// ok

DWORD CWbemSecurity::BuildGroup(
    CWbemGroup &Group,
    IWbemClassObject *pGroup
    )
{
    CVARIANT vUser(Group.GetName());
    HRESULT hRes = pGroup->Put(CBSTR(L"Name"), 0, &vUser, 0);

    DWORD dwFlags = Group.GetFlags();

    if (dwFlags & CWbemSubject::Perm_Enabled)
    {
        pGroup->Put(CBSTR(L"Enabled"), 0, CVARIANT(TRUE), 0);
    }

    DWORD dwValue = 0;      // Read-only by default

    if (dwFlags & CWbemSubject::Perm_WriteInstance)
        dwValue = 1;
    if (dwFlags & CWbemSubject::Perm_WriteClass)
        dwValue = 2;

    CVARIANT vPermissions;
    vPermissions.SetLONG(LONG(dwValue));
    pGroup->Put(CBSTR(L"Permissions"), 0, vPermissions, 0);

    if (dwFlags & CWbemSubject::Perm_EditSecurity)
    {
        pGroup->Put(CBSTR(L"EditSecurity"), 0, CVARIANT(TRUE), 0);
    }

    if (dwFlags & CWbemSubject::Perm_ExecuteMethods)
    {
        pGroup->Put(CBSTR(L"ExecuteMethods"), 0, CVARIANT(TRUE), 0);
    }

    // Get the group type.
    // ===================

    CVARIANT vGroupType;

    DWORD dwGroupFlags = Group.GetGroupFlags();

    if (dwGroupFlags == CWbemGroup::GroupType_NTLM_Local)
        vGroupType.SetLONG(0);
    else if (dwGroupFlags == CWbemGroup::GroupType_NTLM_Global)
        vGroupType.SetLONG(1);

    pGroup->Put(CBSTR(L"GroupType"), 0, &vGroupType, 0);

    // Get the NTLM domain
    // ===================

    CVARIANT vDomain;
    LPWSTR pDom = Group.GetNtlmDomain();
    if (pDom == 0)
        pDom = L".";
    vDomain.SetStr(pDom);
    pGroup->Put(CBSTR(L"Authority"), 0, &vDomain, 0);

    // Write the group
    // ===============

    hRes = m_pSecurity->PutInstance(pGroup, 0, 0, 0);
    if (hRes)
        return Failed;

    return NoError;
}


//***************************************************************************
//
//  CWbemSecurity::CommitChanges
//
//  This will invoke a complex sequence to update ROOT\SECURITY.
//
//  The algorithm is as follows:
//
//  (1) We want to update the database in such a way that at no point are
//      all the users deleted.  For example, if we delete all __Subjects,
//      we actually can erase subjects which we don't own, and if a power
//      failure occurred, all subjects could get wiped out.
//  (2) During the Load() sequence, we save all the original objects returned
//      from the query.  All objects which we own are saved. Ones we don't
//      understand are simply ignored during the Load() sequence.
//  (3) When the user is finished editing, we have a 'new' list of users
//      and a copy of the 'old' list.  We now want to put all 'new' users
//      so as to write any changes.  Any users that were deleted
//      will appear in the 'old' list, but not the 'new' one.  For these,
//      we simply get the object path and delete them.
//
//***************************************************************************
// ?

int CWbemSecurity::CommitChanges()
{
    if (BuildNewUserList())
        return Failed;

    if (BuildNewGroupList())
        return Failed;

    if (PurgeDeletedSubjects())
        return Failed;

    // Reload so that any additional commits will work off the just saved list rather
    // than the original.

    Load();
    return NoError;
}


//***************************************************************************
//
//  CWbemSecurity::PurgeDeletedSubjects
//
//***************************************************************************

DWORD CWbemSecurity::PurgeDeletedSubjects()
{
    // Loop through all __Subjects looking for __NTLMGroup or
    // __NTLMUser instancs which are not in the aGroups[] or aUsers[]
    // arrays.  These will all be deleted.

    int i, iu, ig;
    HRESULT hRes;

    for (i = 0; i < m_aOriginalObjects.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) m_aOriginalObjects[i];

        CVARIANT vName;
        pObj->Get(CBSTR(L"Name"), 0, &vName, 0, 0);

        CVARIANT vDom;
        pObj->Get(CBSTR(L"Authority"), 0, &vDom, 0, 0);

        CVARIANT vPath;
        pObj->Get(CBSTR(L"__PATH"), 0, &vPath, 0, 0);

        BOOL bDelete = TRUE;

        // Now see if there are any users/groups with this name.
        // =====================================================

        for (iu = 0; iu < GetNumUsers(); iu++)
        {
            CWbemUser User = GetUser(iu);
            if (!User.IsValid())
                continue;

            if (StringTest(User.GetName(), vName) == TRUE &&
                StringTest(User.GetAuthority(), vDom) == TRUE
                )
            {
                bDelete = FALSE;
                goto DeleteTest;
            }
        }


        for (ig = 0; ig < GetNumGroups(); ig++)
        {
            CWbemGroup Group = GetGroup(ig);

            if (!Group.IsValid())
                continue;

            if (StringTest(Group.GetName(), vName) == TRUE &&
                StringTest(Group.GetAuthority(), vDom) == TRUE
                )
            {
                bDelete = FALSE;
                goto DeleteTest;
            }
        }


        DeleteTest:

        if (bDelete)
        {
            hRes = m_pSecurity->DeleteInstance(vPath, 0, 0, 0);
            if (hRes)
                return Failed;
        }
    }

    return NoError;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor-nocom\seceditor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  trantest.cpp 
//
//  Module: trantest.exe
//
//  Purpose: Exercises the various transports both locally and remotely.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include <time.h>
#include <wbemidl.h> 
#include "cominit.h"
#include <..\wbemtest\bstring.h>
#include "winntsec.h"
SCODE sc;
CNtSecurityDescriptor gSD;
WCHAR wPath[MAX_PATH];

class ReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    ReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~ReleaseMe() {if(m_pUnk) m_pUnk->Release();}
};

IWbemServices * GetServices()
{

    IWbemLocator *pLocator = 0;
    IWbemServices *pSession = 0;

    sc = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, (LPVOID *) &pLocator);

    if(sc != S_OK)
    {
        printf("\nCoCreateInstance failed!!!! sc = 0x%0x",sc);
        return NULL;
    }

    sc = pLocator->ConnectServer(wPath, NULL, NULL,0,0,NULL,NULL,&pSession);
    pLocator->Release();

    if(sc == S_OK)
    {
        SetInterfaceSecurity(pSession, NULL, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_IMP_LEVEL_IMPERSONATE, 0);
    }
    else
        printf("\n Connect server failed 0x%x", sc);
    return pSession;
}

bool MoveVariantIntoGlobalSD(VARIANT * pvar)
{
    if(pvar->vt != (VT_ARRAY | VT_UI1))
        return false;
    SAFEARRAY * psa = pvar->parray;
    PSECURITY_DESCRIPTOR pSD;
    sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if(sc != 0)
        return false;
    CNtSecurityDescriptor temp(pSD);
    gSD = temp;
    gSD.Dump();
    SafeArrayUnaccessData(psa);
    return true;
}


bool LoadSD()
{
    bool bRet = false;
    IWbemServices * pServices = GetServices();
    ReleaseMe r(pServices);
    if(pServices)
    {
        CBString InstPath(L"__systemsecurity=@");
        CBString MethName(L"GetSD");

        IWbemClassObject * pOutParams = NULL;
        sc = pServices->ExecMethod(InstPath.GetString(),
                MethName.GetString(),
                0,
                NULL, NULL,
                &pOutParams, NULL);
        if(sc == S_OK)
        {
            CBString prop(L"sd");
            VARIANT var;
            VariantInit(&var);
            sc = pOutParams->Get(prop.GetString(), 0, &var, NULL, NULL);
            if(sc == S_OK)
            {
                MoveVariantIntoGlobalSD(&var);
                VariantClear(&var);
                bRet = true;
            }
        }

    }
    return bRet;
}

DWORD QueryForFlag(char * Prompt, long OrInBit)
{
    printf("%s", Prompt);
    char cBuff[40];
    scanf("%s", cBuff);
    if(cBuff[0] == 'y' || cBuff[0] == 'Y')
        return OrInBit;
    else
        return 0;
}
bool AddAce(bool bAllow)
{

    char cUser[128]; WCHAR wcUser[128];
    printf("\nEnter the user name (EX:REDMOND\\USER):");
    scanf("%s", cUser);
    mbstowcs(wcUser, cUser, 128);

    printf("\nEnter the permissions mask (EX:6001F):");
    DWORD dwMask;
    scanf("%x", &dwMask);

    if(dwMask & WBEM_FULL_WRITE_REP && ((dwMask & WBEM_PARTIAL_WRITE_REP) == 0 ||
        (dwMask & WBEM_WRITE_PROVIDER) == 0))
    {
        printf("\nSpecifying full repository write(0x4) requires both \npartial repository write(0x8)"
            " and write provider(0x10) rights.\n");
        return false;
    }


    DWORD lFlags = 0;
    lFlags |= QueryForFlag("\nDo you want CONTAINER_INHERIT_ACE ? (y/n):", CONTAINER_INHERIT_ACE);
    lFlags |= QueryForFlag("\nDo you want INHERIT_ONLY_ACE ? (y/n):", INHERIT_ONLY_ACE);
    lFlags |= QueryForFlag("\nDo you want NO_PROPAGATE_INHERIT_ACE ? (y/n):", NO_PROPAGATE_INHERIT_ACE);


    CNtAce Ace(
        dwMask,
        (bAllow) ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE ,
        lFlags,
        wcUser,
        0
        );

    if(Ace.GetStatus() != 0)
    {
        printf("\nFAILED!!!!\n");
        return false;
    }
    CNtAcl Acl;
    gSD.GetDacl(Acl);
    Acl.AddAce(&Ace);

    gSD.SetDacl(&Acl);
    return true;
}

DeleteAce()
{
    printf("\nEnter the ace to be deleted, 0 being the first (-1 to bail):");
    int Index;
    scanf("%d", &Index);
    if(Index == -1)
        return true;
    CNtAcl Acl;
    gSD.GetDacl(Acl);

    if(!Acl.DeleteAce(Index))
        printf("\ndelete failed\n");

    gSD.SetDacl(&Acl);
    return true;

}
bool StoreSD()
{
    bool bRet = false;
    bool bToProtect = false;
    printf("\nDo you want to protect this from inherited aces?(0=no, 1=yes):");
    int iRet;
    scanf("%d", &iRet);
    if(iRet == 1)
        bToProtect = true;
    PSECURITY_DESCRIPTOR pActualSD = gSD.GetPtr();
    SetSecurityDescriptorControl(pActualSD, SE_DACL_PROTECTED,
        (bToProtect) ? SE_DACL_PROTECTED : 0);

    IWbemServices * pServices = GetServices();
    ReleaseMe r(pServices);
    if(pServices)
    {

        // Get the class object

        IWbemClassObject * pClass = NULL;
        CBString InstPath(L"__systemsecurity=@");
        CBString ClassPath(L"__systemsecurity");
        sc = pServices->GetObject(ClassPath.GetString(), 0, NULL, &pClass, NULL);
        if(sc != S_OK)
            return false;
        ReleaseMe c(pClass);

        // Get the input parameter class

        CBString MethName(L"SetSD");
        IWbemClassObject * pInClassSig = NULL;
        sc = pClass->GetMethod(MethName.GetString(),0, &pInClassSig, NULL);
        if(sc != S_OK)
            return false;
        ReleaseMe d(pInClassSig);

        // spawn an instance of the input parameter class

        IWbemClassObject * pInArg = NULL;
        pInClassSig->SpawnInstance(0, &pInArg);
        if(sc != S_OK)
            return false;
        ReleaseMe e(pInArg);


        // move the SD into a variant.

        SAFEARRAY FAR* psa;
        SAFEARRAYBOUND rgsabound[1];    rgsabound[0].lLbound = 0;
        long lSize = gSD.GetSize();
        rgsabound[0].cElements = lSize;
        psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
        if(psa == NULL)
            return false;

        char * pData = NULL;
        sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
        if(sc != S_OK)
            return false;

        memcpy(pData, gSD.GetPtr(), lSize);
    
        SafeArrayUnaccessData(psa);
        VARIANT var;
        var.vt = VT_I4|VT_ARRAY;
        var.parray = psa;

        // put the property

        sc = pInArg->Put(L"SD" , 0, &var, 0);      
        VariantClear(&var);
        if(sc != S_OK)
            return false;
    
        // Execute the method

        IWbemClassObject * pOutParams = NULL;
        sc = pServices->ExecMethod(InstPath.GetString(),
                MethName.GetString(),
                0,
                NULL, pInArg,
                NULL, NULL);
        printf("\nResult code was 0x%x", sc);
        if(sc)
        {
			printf(" Reinitializing stored security descriptor!\n");
		}

    }
    return bRet;
}

//***************************************************************************
//
// main
//
// Purpose: Initialized Ole, calls some test code, cleans up and exits.
//
//***************************************************************************
enum Commands{LOAD = 1, STORE, DISPLAY, DELETEACE, ADDALLOWACE,ADDDENYACE, QUIT};

int PrintAndGetOption()
{
    bool NotDone = true;
    int iRet;
    while (NotDone)
    {
        printf("\n1=Load Security Descriptor\n2=Store Security Descriptor\n3=Display Security Descriptor\n4=Delete ACE"
            "\n5=Add Allow Ace\n6=Add Deny Ace\n7=quit\nEnter Option:");
        scanf("%d", &iRet);
        if(iRet >= LOAD && iRet <= QUIT)
            NotDone = false;
    }
    return iRet;
}



int _cdecl main(int iArgCnt, char ** argv)
{

    if(iArgCnt < 2)
    {
        printf("\nError, you must enter a namespace path.  ex;\nc:>seceditor root\\default\n");
        return 1;
    }

    mbstowcs(wPath, argv[1], MAX_PATH);

    HRESULT hr = InitializeCom();
    if(!LoadSD())
        return 1;

    int iOpt = PrintAndGetOption();
    while (iOpt != QUIT)
    {
        switch(iOpt)
        {
        case LOAD:
            LoadSD();
            break;

        case STORE:
            StoreSD();
            break;

        case DISPLAY:
            gSD.Dump();
            break;
        case DELETEACE:
            DeleteAce();
            break;
        case ADDALLOWACE:
            AddAce(true);
            break;
        case ADDDENYACE:
            AddAce(false);
            break;
        }

        iOpt = PrintAndGetOption();
    }


    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor-nocom\winntsec.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.H

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#ifndef _WINNTSEC_H_
#define _WINNTSEC_H_

class  CNtSecurity;

// All ACE types are currently have the same binary layout. Rather
// than doing a lot of useless casts, we produce a general-purpose
// typedef to hold all ACEs.
// ================================================================

typedef ACCESS_ALLOWED_ACE GENERIC_ACE;
typedef GENERIC_ACE *PGENERIC_ACE;

#define FULL_CONTROL     \
        (DELETE |       \
         READ_CONTROL | \
        WRITE_DAC |         \
        WRITE_OWNER |   \
        SYNCHRONIZE | GENERIC_ALL)


//***************************************************************************
//
//  CNtSid
//
//  Models SIDs (users/groups).
//
//***************************************************************************

class  CNtSid
{
    PSID    m_pSid;
    LPWSTR  m_pMachine;
    LPWSTR  m_pDomain;
    DWORD   m_dwStatus;
    SID_NAME_USE m_snu;

public:
    enum { NoError, Failed, NullSid, InvalidSid, InternalError, AccessDenied = 0x5 };

    enum SidType {CURRENT_USER, CURRENT_THREAD};

    CNtSid(SidType st);
    CNtSid() { m_pSid = 0; m_pMachine = 0; m_dwStatus = NullSid; }
    bool IsUser(){return m_snu == SidTypeUser;};

    CNtSid(PSID pSrc);
        // Construct based on another SID.

    CNtSid(LPWSTR pUser, LPWSTR pMachine = 0);
        // Construct based on a user (machine name is optional).

   ~CNtSid();

    CNtSid(CNtSid &Src);
    CNtSid &operator =(CNtSid &Src);
    int operator ==(CNtSid &Comparand);

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    PSID GetPtr() { return m_pSid; }
        // Returns the internal SID ptr to interface with NT APIs
    DWORD GetSize();

    BOOL CopyTo(PSID pDestination);

    BOOL IsValid() { return (m_pSid && IsValidSid(m_pSid)); }
        // Checks the validity of the internal SID.

    void Dump();
        // Dumps SID info to console for debugging.

    int GetInfo(
        LPWSTR *pRetAccount,        // Account, use operator delete
        LPWSTR *pRetDomain,         // Domain, use operator delete
        DWORD  *pdwUse              // See SID_NAME_USE for values
        );

    BOOL GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen);

};

//***************************************************************************
//
//  CBaseAce
//
//  Base class for aces.
//
//***************************************************************************

class  CBaseAce
{

public:

    CBaseAce(){};
    virtual ~CBaseAce(){};

    virtual int GetType() = 0;
    virtual int GetFlags() = 0;         // inheritance etc.
    virtual ACCESS_MASK GetAccessMask() = 0;
    virtual HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize) = 0;
    virtual HRESULT GetFullUserName2(WCHAR ** pBuff) = 0; // call must free
    virtual DWORD GetStatus() = 0;
    virtual void SetFlags(long lFlags) =0;
    virtual DWORD GetSerializedSize() = 0;
    virtual bool  Serialize(BYTE * pData) = 0;
    virtual bool  Deserialize(BYTE * pData) = 0;
};


//***************************************************************************
//
//  CNtAce
//
//  Models NT ACEs.
//
//***************************************************************************

class  CNtAce : public CBaseAce
{
    PGENERIC_ACE    m_pAce;
    DWORD           m_dwStatus;

public:
    enum { NoError, InvalidAce, NullAce, InternalError };

    CNtAce() { m_pAce = 0; m_dwStatus = NullAce; }

    CNtAce(PGENERIC_ACE pAceSrc);
    CNtAce(CNtAce &Src);
    CNtAce & operator =(CNtAce &Src);

   ~CNtAce();

   CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser,
        LPWSTR pMachine = 0         // Defaults to local machine
        );

    CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        CNtSid & Sid
        );

    int GetType();
    int GetFlags();         // inheritance etc.
    void SetFlags(long lFlags){m_pAce->Header.AceFlags = (unsigned char)lFlags;};

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    int GetSubject(
        LPWSTR *pSubject
        );

    ACCESS_MASK GetAccessMask();

    CNtSid *GetSid();
    BOOL GetSid(CNtSid &Dest);

    PGENERIC_ACE GetPtr() { return m_pAce; }
    DWORD GetSize() { return m_pAce ? m_pAce->Header.AceSize : 0; }
    HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize);
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData);
    bool Deserialize(BYTE * pData);

    void Dump(int iAceNum = -1);
    void DumpAccessMask();
};

//***************************************************************************
//
//  C9XAce
//
//  Simulates NT ACEs for 9X boxs.
//
//***************************************************************************

class  C9XAce : public CBaseAce
{
    LPWSTR m_wszFullName;
    DWORD m_dwAccess;
    int m_iFlags;
    int m_iType;
public:

   C9XAce(){m_wszFullName = 0;};
   C9XAce(DWORD Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser);
   ~C9XAce();

    int GetType(){return m_iType;};
    int GetFlags(){return m_iFlags;};         // inheritance etc.

    ACCESS_MASK GetAccessMask(){return m_dwAccess;};
    HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize);
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetStatus(){ return CNtAce::NoError; };
    void SetFlags(long lFlags){m_iFlags = (unsigned char)lFlags;};
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData);
    bool Deserialize(BYTE * pData);

};


//***************************************************************************
//
//  CNtAcl
//
//  Models an NT ACL.
//
//***************************************************************************

class  CNtAcl
{
    PACL    m_pAcl;
    DWORD   m_dwStatus;

public:
    enum { NoError, InternalError, NullAcl, InvalidAcl };
    enum { MinimumSize = 1 };

    CNtAcl(DWORD dwInitialSize = 128);

    CNtAcl(CNtAcl &Src);
    CNtAcl & operator = (CNtAcl &Src);

    CNtAcl(PACL pAcl);  // Makes a copy
   ~CNtAcl();

    int  GetNumAces();

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    CNtAce *GetAce(int nIndex);
    BOOL GetAce(int nIndex, CNtAce &Dest);

    BOOL DeleteAce(int nIndex);
    BOOL AddAce(CNtAce *pAce);

    BOOL IsValid() { return(m_pAcl && IsValidAcl(m_pAcl)); }
        // Checks the validity of the embedded ACL.

    BOOL Resize(DWORD dwNewSize);
        // Or use CNtAcl::MinimumSize to trim the ACL to min size.
        // Fails if an illegal size is specified.

    DWORD GetSize();

    PACL GetPtr() { return m_pAcl; }
        // Returns the internal pointer for interface with NT APIs.

    BOOL GetAclSizeInfo(
        PDWORD pdwBytesInUse,
        PDWORD pdwBytesFree
        );

    void Dump();
};

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  Helper for converting between absolute and relative SDs.
//
//***************************************************************************

struct SNtAbsoluteSD
{
    PSECURITY_DESCRIPTOR m_pSD;

    PACL m_pDacl;
    PACL m_pSacl;
    PSID m_pOwner;
    PSID m_pPrimaryGroup;

    SNtAbsoluteSD();
   ~SNtAbsoluteSD();
};

//***************************************************************************
//
//  CNtSecurityDescriptor
//
//  Models an NT Security Descriptor.  Note that in order to use this for an
//  AccessCheck, the DACL, owner sid, and group sid must be set!
//
//***************************************************************************

class  CNtSecurityDescriptor
{
    PSECURITY_DESCRIPTOR m_pSD;
    int m_dwStatus;


public:
    enum { NoError, NullSD, Failed, InvalidSD, SDOwned, SDNotOwned };

    CNtSecurityDescriptor();

    CNtSecurityDescriptor(
        PSECURITY_DESCRIPTOR pSD,
        BOOL bAcquire = FALSE
        );

    CNtSecurityDescriptor(CNtSecurityDescriptor &Src);
    CNtSecurityDescriptor & operator=(CNtSecurityDescriptor &Src);

    ~CNtSecurityDescriptor();

    SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy();
    BOOL SetFromAbsoluteCopy(SNtAbsoluteSD *pSrc);

    int HasOwner();

    BOOL IsValid() { return(m_pSD && IsValidSecurityDescriptor(m_pSD)); }
        // Checks the validity of the embedded security descriptor&

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    CNtAcl *GetDacl();
        // Deallocate with operator delete

    BOOL GetDacl(CNtAcl &DestAcl);
        // Retrieve into an existing object

    BOOL SetDacl(CNtAcl *pSrc);

    CNtAcl *GetSacl();
        // Deallocate with operator delete

    BOOL SetSacl(CNtAcl *pSrc);

    CNtSid *GetOwner();
    BOOL SetOwner(CNtSid *pSid);

    CNtSid *GetGroup();
    BOOL SetGroup(CNtSid *pSid);

    PSECURITY_DESCRIPTOR GetPtr() { return m_pSD; }
        // Returns the internal pointer for interface with NT APIs

    DWORD GetSize();

    void Dump();
};

//***************************************************************************
//
//  CNtSecurity
//
//  General-purpose NT security helpers.
//
//***************************************************************************

class  CNtSecurity
{
public:
    enum { NoError, InternalFailure, NotFound, InvalidName, AccessDenied = 5, NoSecurity,
           Failed };

    static BOOL DumpPrivileges();

    static BOOL SetPrivilege(
        IN TCHAR *pszPrivilegeName,     // An SE_ value.
        IN BOOL  bEnable               // TRUE=enable, FALSE=disable
        );

    static BOOL GetFileSD(
        IN TCHAR *pszFile,
        IN SECURITY_INFORMATION SecInfo,
        OUT CNtSecurityDescriptor **pSD
        );

    static BOOL SetFileSD(
        IN TCHAR *pszFile,
        IN SECURITY_INFORMATION SecInfo,
        IN CNtSecurityDescriptor *pSD
        );

    static int GetRegSD(
        IN HKEY hRoot,
        IN TCHAR *pszSubKey,
        IN SECURITY_INFORMATION SecInfo,
        OUT CNtSecurityDescriptor **pSD
        );

    static int SetRegSD(
        IN HKEY hRoot,
        IN TCHAR *pszSubKey,
        IN SECURITY_INFORMATION SecInfo,
        IN CNtSecurityDescriptor *pSD
        );


/*    static int GetDCName(
        IN  LPWSTR   pszDomain,
        OUT LPWSTR *pszDC,
        IN  LPWSTR   pszServer
        );*/

    static BOOL IsUserInGroup(
        HANDLE hClientToken,
        CNtSid & Sid
        );

    static DWORD AccessCheck(
        HANDLE hAccessToken,
        ACCESS_MASK RequiredAccess,
        CNtSecurityDescriptor *pSD
        );  // TBD

    static CNtSid *GetCurrentThreadSid(); // TBD

    static bool DoesLocalGroupExist(LPWSTR pwszGroup, LPWSTR pwszMachine);
    static bool AddLocalGroup(LPWSTR pwszGroupName, LPWSTR pwszGroupDescription);
};

BOOL FIsRunningAsService(VOID);
 BOOL SetObjectAccess2(HANDLE hObj);
 BOOL IsAdmin(HANDLE hAccess);
 BOOL IsNetworkService(HANDLE hAccess);
 BOOL IsLocalService(HANDLE hAccess);
 HRESULT GetAccessToken(HANDLE &hAccessToken);
 BOOL IsInAdminGroup();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\seceditor-nocom\winntsec.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.CPP

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#include "precomp.h"

#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <winntsec.h>
#include <tchar.h>

#include <genutils.h>
#include "arena.h"
#include "reg.h"
#include "wbemutil.h"
#include "arrtempl.h"
#include <cominit.h>
extern "C"
{
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
};
#define MAXULONG (ULONG) ((MAXLONG << 1) | 0x1)

//***************************************************************************
//
//  CNtSid::GetSize
//
//  Returns the size of the SID in bytes.
//
//***************************************************************************
// ok

DWORD CNtSid::GetSize()
{
    if (m_pSid == 0 || !IsValidSid(m_pSid))
        return 0;

    return GetLengthSid(m_pSid);
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(CNtSid &Src)
{
    m_pSid = 0;
    m_dwStatus = 0;
    m_pMachine = 0;
    *this = Src;
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(SidType st)
{
    m_pSid = 0;
    m_dwStatus = InternalError;
    m_pMachine = 0;
    if(st == CURRENT_USER ||st == CURRENT_THREAD)
    {
        HANDLE hToken;
        if(st == CURRENT_USER)
        {
            if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
                return;
        }
        else
        {
            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
                return;
        }

        // Get the user sid
        // ================

        TOKEN_USER tu;
        DWORD dwLen = 0;
        GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &dwLen);

        if(dwLen == 0)
        {
            CloseHandle(hToken);
            return;
        }

        BYTE* pTemp = new BYTE[dwLen];
        if (!pTemp)
        {
            CloseHandle(hToken);
            return;
        }

        DWORD dwRealLen = dwLen;
        if(!GetTokenInformation(hToken, TokenUser, pTemp, dwRealLen, &dwLen))
        {
            CloseHandle(hToken);
            delete [] pTemp;
            return;
        }

        CloseHandle(hToken);

        // Make a copy of the SID
        // ======================

        PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;
        DWORD dwSidLen = GetLengthSid(pSid);
        m_pSid = new BYTE[dwSidLen];
        if (m_pSid)
            CopySid(dwSidLen, m_pSid, pSid);
        delete [] pTemp;
        m_dwStatus = 0;
    }
    return;
}



//***************************************************************************
//
//  CNtSid::CopyTo
//
//  An unchecked copy of the internal SID to the destination pointer.
//
//  Parameters:
//  <pDestination> points to the buffer to which to copy the SID. The
//  buffer must be large enough to hold the SID.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSid::CopyTo(PSID pDestination)
{
    if (m_pSid == 0 || m_dwStatus != NoError)
        return FALSE;

    DWORD dwLen = GetLengthSid(m_pSid);
    memcpy(pDestination, m_pSid, dwLen);

    return TRUE;
}


//***************************************************************************
//
//  CNtSid assignment operator
//
//***************************************************************************
// ok

CNtSid & CNtSid::operator =(CNtSid &Src)
{
    if (m_pMachine != 0)
    {
        delete [] m_pMachine;
        m_pMachine = 0;
    }

    if (m_pSid != 0)
    {
        delete [] m_pSid;
        m_pSid = 0;
    }

    if (Src.m_pSid == 0)
    {
        m_pSid = 0;
        m_dwStatus = NullSid;
        return *this;
    }

    if (!IsValidSid(Src.m_pSid))
    {
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return *this;
    }


    // If here, the source has a real SID.
    // ===================================

    DWORD dwLen = GetLengthSid(Src.m_pSid);

    m_pSid = (PSID) new BYTE [dwLen];
    if (!m_pSid)
    {
        m_dwStatus = InternalError;
        return *this;
    }

    ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, Src.m_pSid))
    {
        delete [] m_pSid;
        m_pSid = NULL;
        m_dwStatus = InternalError;
        return *this;
    }

    if (Src.m_pMachine)
    {
        m_pMachine = new wchar_t[wcslen(Src.m_pMachine) + 1];
        if (!m_pMachine)
        {
            delete [] m_pSid;
            m_pSid = NULL;
            m_dwStatus = InternalError;
            return *this;
        }

        wcscpy(m_pMachine, Src.m_pMachine);
    }

    m_dwStatus = NoError;
    return *this;
}

//***************************************************************************
//
//  CNtSid comparison operator
//
//***************************************************************************
int CNtSid::operator ==(CNtSid &Comparand)
{
    if (m_pSid == 0 && Comparand.m_pSid == 0)
        return 1;
    if (m_pSid == 0 || Comparand.m_pSid == 0)
        return 0;

    return EqualSid(m_pSid, Comparand.m_pSid);
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructor which builds a SID directly from a user or group name.
//  If the machine is available, then its name can be used to help
//  distinguish the same name in different SAM databases (domains, etc).
//
//  Parameters:
//
//  <pUser>     The desired user or group.
//
//  <pMachine>  Points to a machine name with or without backslashes,
//              or else is NULL, in which case the current machine, domain,
//              and trusted domains are searched for a match.
//
//  After construction, call GetStatus() to determine if the constructor
//  succeeded.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    DWORD  dwRequired = 0;
    DWORD  dwDomRequired = 0;
    LPWSTR pszDomain = NULL;
    m_pSid = 0;
    m_pMachine = 0;

    if (pMachine)
    {
        m_pMachine = new wchar_t[wcslen(pMachine) + 1];
        if (!m_pMachine)
        {
            m_dwStatus = Failed;
            return;
        }
        
        wcscpy(m_pMachine, pMachine);
    }

    BOOL bRes = LookupAccountNameW(
        m_pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        m_pSid = 0;
        if (dwLastErr == ERROR_ACCESS_DENIED)
            m_dwStatus = AccessDenied;
        else
            m_dwStatus = InvalidSid;
        return;
    }

    m_pSid = (PSID) new BYTE [dwRequired];
    if (!m_pSid)
    {
        m_dwStatus = Failed;
        return;
    }

    ZeroMemory(m_pSid, dwRequired);
    pszDomain = new wchar_t[dwDomRequired + 1];
    if (!pszDomain)
    {
        delete [] m_pSid;
        m_pSid = 0;
        m_dwStatus = Failed;
        return;
    }

    bRes = LookupAccountNameW(
        pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    if (!bRes || !IsValidSid(m_pSid))
    {
        delete [] m_pSid;
        delete [] pszDomain;
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return;
    }

    delete [] pszDomain;   // We never really needed this
    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructs a CNtSid object directly from an NT SID. The SID is copied,
//  so the caller retains ownership.
//
//  Parameters:
//  <pSrc>      The source SID upon which to base the object.
//
//  Call GetStatus() after construction to ensure the object was
//  constructed correctly.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(PSID pSrc)
{
    m_pMachine = 0;
    m_pSid = 0;
    m_dwStatus = NoError;

    if (!IsValidSid(pSrc))
    {
        m_dwStatus = InvalidSid;
        return;
    }

    DWORD dwLen = GetLengthSid(pSrc);

    m_pSid = (PSID) new BYTE [dwLen];
    // Check for mem. alloc. failure
	// NT RAID#: 158600		[marioh]
	if ( m_pSid == NULL )
	{
        m_dwStatus = Failed;
		return;
	}

	ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, pSrc))
    {
        delete [] m_pSid;
        m_dwStatus = InternalError;
        return;
    }
}

//***************************************************************************
//
//  CNtSid::GetInfo
//
//  Returns information about the SID.
//
//  Parameters:
//  <pRetAccount>       Receives a UNICODE string containing the account
//                      name (user or group).  The caller must use operator
//                      delete to free the memory.  This can be NULL if
//                      this information is not required.
//  <pRetDomain>        Returns a UNICODE string containing the domain
//                      name in which the account resides.   The caller must
//                      use operator delete to free the memory.  This can be
//                      NULL if this information is not required.
//  <pdwUse>            Points to a DWORD to receive information about the name.
//                      Possible return values are defined under SID_NAME_USE
//                      in NT SDK documentation.  Examples are
//                      SidTypeUser, SidTypeGroup, etc.  See CNtSid::Dump()
//                      for an example.
//
//  Return values:
//  NoError, InvalidSid, Failed
//
//***************************************************************************
// ok

int CNtSid::GetInfo(
    LPWSTR *pRetAccount,       // Account, use operator delete
    LPWSTR *pRetDomain,        // Domain, use operator delete
    DWORD  *pdwUse             // See SID_NAME_USE for values
    )
{
    if (pRetAccount)
        *pRetAccount = 0;
    if (pRetDomain)
        *pRetDomain  = 0;
    if (pdwUse)
        *pdwUse   = 0;

    if (!m_pSid || !IsValidSid(m_pSid))
        return InvalidSid;

    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPWSTR pUser = 0;
    LPWSTR pDomain = 0;
    SID_NAME_USE Use;


    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return Failed;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new wchar_t[dwNameLen + 1];
    if (!pUser)
        return Failed;

    pDomain = new wchar_t[dwDomainLen + 1];
    if (!pDomain)
    {
        delete pUser;
        return Failed;
    }

    bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    if (!bRes)
    {
        delete [] pUser;
        delete [] pDomain;
        return Failed;
    }

    if (pRetAccount)
        *pRetAccount = pUser;
    else
        delete [] pUser;
    if (pRetDomain)
        *pRetDomain  = pDomain;
    else
        delete [] pDomain;
    if (pdwUse)
        *pdwUse = Use;

    return NoError;
}

//***************************************************************************
//
//  CNtSid::Dump
//
//  Dumps the SID to the console outuput for debugging.
//
//***************************************************************************
// ok

void CNtSid::Dump()
{
    LPWSTR pUser, pDomain;
    DWORD dwUse;

    printf("---SID DUMP---\n");

    if (m_pSid == 0)
    {
        printf("<NULL>\n");
        return;
    }

    if (!IsValidSid(m_pSid))
    {
        printf("<Invalid Sid>\n");
        return;
    }

    int nRes = GetInfo(&pUser, &pDomain, &dwUse);

    if (nRes != NoError)
        return;

    // Print out SID in SID-style notation.
    // ====================================

    // Print out human-readable info.
    // ===============================

    printf("User = %S  Domain = %S  Type = ", pUser, pDomain);

    delete [] pUser;
    delete [] pDomain;

    switch (dwUse)
    {
        case SidTypeUser:
            printf("SidTypeUser\n");
            break;

        case SidTypeGroup:
            printf("SidTypeGroup\n");
            break;

        case SidTypeDomain:
            printf("SidTypeDomain\n");
            break;

        case SidTypeAlias:
            printf("SidTypeAlias\n");
            break;

        case SidTypeWellKnownGroup:
            printf("SidTypeWellKnownGroup\n");
            break;

        case SidTypeDeletedAccount:
            printf("SidTypeDeletedAccount\n");
            break;

        case SidTypeUnknown:
            printf("SidTypeUnknown\n");
            break;

        case SidTypeInvalid:
        default:
            printf("SidTypeInvalid\n");
    }
}

//***************************************************************************
//
//  CNtSid destructor
//
//***************************************************************************

CNtSid::~CNtSid()
{
    if (m_pSid)
        delete [] m_pSid;
    if (m_pMachine)
        delete [] m_pMachine;
}

//***************************************************************************
//
//  CNtSid::GetTextSid
//
//  Converts the sid to text form.  The caller should passin a 130 character
//  buffer.
//
//***************************************************************************

BOOL CNtSid::GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen)
{
      PSID_IDENTIFIER_AUTHORITY psia;
      DWORD dwSubAuthorities = 0;
      DWORD dwSidRev=SID_REVISION;
      DWORD dwCounter = 0;
      DWORD dwSidSize = 0;

      // test if Sid is valid

      if(m_pSid == 0 || !IsValidSid(m_pSid))
          return FALSE;

      // obtain SidIdentifierAuthority

      psia=GetSidIdentifierAuthority(m_pSid);

      // obtain sidsubauthority count

      PUCHAR p = GetSidSubAuthorityCount(m_pSid);
      dwSubAuthorities = *p;

      // compute buffer length
      // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL

      dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

      // check provided buffer length.  If not large enough, indicate proper size.

      if (*dwBufferLen < dwSidSize)
      {
         *dwBufferLen = dwSidSize;
         return FALSE;
      }

      // prepare S-SID_REVISION-

      dwSidSize=wsprintf(pszSidText, TEXT("S-%lu-"), dwSidRev );

      // prepare SidIdentifierAuthority

      if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
      {
         dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),
                             TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                             (USHORT)psia->Value[0],
                             (USHORT)psia->Value[1],
                             (USHORT)psia->Value[2],
                             (USHORT)psia->Value[3],
                             (USHORT)psia->Value[4],
                             (USHORT)psia->Value[5]);
      }
      else
      {
         dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),
                             TEXT("%lu"),
                             (ULONG)(psia->Value[5]      )   +
                             (ULONG)(psia->Value[4] <<  8)   +
                             (ULONG)(psia->Value[3] << 16)   +
                             (ULONG)(psia->Value[2] << 24)   );
      }

      // loop through SidSubAuthorities

      for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
      {
         dwSidSize+=wsprintf(pszSidText + dwSidSize, TEXT("-%lu"),
         *GetSidSubAuthority(m_pSid, dwCounter) );
      }
      return TRUE;
}


//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <sid>               CNtSid specifying the user or group for which the ACE is being
//                      created.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    CNtSid & Sid
    )
{
    m_pAce = 0;
    m_dwStatus = 0;

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) new BYTE[dwTotal];
    
    if (m_pAce)
    {
        ZeroMemory(m_pAce, dwTotal);

        // Build up the ACE info.
        // ======================

        m_pAce->Header.AceType  = BYTE(dwAceType);
        m_pAce->Header.AceFlags = BYTE(dwAceFlags);
        m_pAce->Header.AceSize = WORD(dwTotal);
        m_pAce->Mask = AccessMask;

        BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

        if (!bRes)
        {
            delete m_pAce;
            m_pAce = 0;
            m_dwStatus = InvalidAce;
            return;
        }

        m_dwStatus = NoError;
    }
    else
        m_dwStatus = InternalError;
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <pUser>             The user or group for which the ACE is being
//                      created.
//  <pMachine>          If NULL, the current machine, domain, and trusted
//                      domains are searched for a match.  If not NULL,
//                      can point to a UNICODE machine name (with or without
//                      leading backslashes) which contains the account.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    m_pAce = 0;
    m_dwStatus = 0;

    // Create the SID of the user.
    // ===========================

    CNtSid Sid(pUser, pMachine);

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) new BYTE[dwTotal];
	if ( m_pAce == NULL )
	{
        m_dwStatus = InternalError;		
		return;
	}
    ZeroMemory(m_pAce, dwTotal);

    // Build up the ACE info.
    // ======================

    m_pAce->Header.AceType  = BYTE(dwAceType);
    m_pAce->Header.AceFlags = BYTE(dwAceFlags);
    m_pAce->Header.AceSize = WORD(dwTotal);
    m_pAce->Mask = AccessMask;

    BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

    if (!bRes)
    {
        delete m_pAce;
        m_pAce = 0;
        m_dwStatus = InvalidAce;
        return;
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtAce::GetAccessMask
//
//  Returns the ACCESS_MASK of the ACe.
//
//***************************************************************************
ACCESS_MASK CNtAce::GetAccessMask()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Mask;
}

//***************************************************************************
//
//  CNtAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD CNtAce::GetSerializedSize()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Header.AceSize;
}

//***************************************************************************
//
//  CNtAce::DumpAccessMask
//
//  A helper function for CNtAce::Dump().  Illustrates the values
//  that the ACCESS_MASK for the ACE can take on.
//
//***************************************************************************
// ok

void CNtAce::DumpAccessMask()
{
    if (m_pAce == 0)
        return;

    ACCESS_MASK AccessMask = m_pAce->Mask;

    printf("Access Mask = 0x%X\n", AccessMask);
    printf("    User Portion = 0x%X\n", AccessMask & 0xFFFF);

    if (AccessMask & DELETE)
        printf("    DELETE\n");
    if (AccessMask & READ_CONTROL)
        printf("    READ_CONTROL\n");
    if (AccessMask & WRITE_DAC)
        printf("    WRITE_DAC\n");
    if (AccessMask & WRITE_OWNER)
        printf("    WRITE_OWNER\n");
    if (AccessMask & SYNCHRONIZE)
        printf("    SYNCHRONIZE\n");
    if (AccessMask & ACCESS_SYSTEM_SECURITY)
        printf("    ACCESS_SYSTEM_SECURITY\n");
    if (AccessMask & MAXIMUM_ALLOWED)
        printf("    MAXIMUM_ALLOWED\n");
    if (AccessMask & GENERIC_ALL)
        printf("    GENERIC_ALL\n");
    if (AccessMask & GENERIC_EXECUTE)
        printf("    GENERIC_EXECUTE\n");
    if (AccessMask & GENERIC_READ)
        printf("    GENERIC_READ\n");
    if (AccessMask & GENERIC_WRITE)
        printf("    GENERIC_WRITE\n");
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Returns a copy of the CNtSid object which makes up the ACE.
//
//  Return value:
//      A newly allocated CNtSid which represents the user or group
//      referenced in the ACE.  The caller must use operator delete to free
//      the memory.
//
//***************************************************************************
// ok

CNtSid* CNtAce::GetSid()
{
    if (m_pAce == 0)
        return 0;

    PSID pSid = 0;

    pSid = &m_pAce->SidStart;

    if (!IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Gets the SID in an alternate manner, by assigning to an existing
//  object instead of returning a dynamically allocated one.
//
//  Parameters:
//  <Dest>              A reference to a CNtSid to receive the SID.
//
//  Return value:
//  TRUE on successful assignment, FALSE on failure.
//
//***************************************************************************

BOOL CNtAce::GetSid(CNtSid &Dest)
{
    CNtSid *pSid = GetSid();
    if (pSid == 0)
        return FALSE;

    Dest = *pSid;
    delete pSid;
    return TRUE;
}


//***************************************************************************
//
//  CNtAce::Dump
//
//  Dumps the current ACE to the console for debugging purposes.
//  Illustrates the structure of the ACE and the values the different
//  fields can take on.
//
//***************************************************************************
// ok

void CNtAce::Dump(int iAceNum)
{
    if(iAceNum != -1)
        printf("\n---ACE DUMP FOR ACE #%d---\n", iAceNum);
    else
        printf("\n---ACE DUMP---\n");

    printf("Ace Type = ");

    if (m_pAce == 0)
    {
        printf("NULL ACE\n");
        return;
    }

    switch (m_pAce->Header.AceType)
    {
        case ACCESS_ALLOWED_ACE_TYPE:
            printf("ACCESS_ALLOWED_ACE_TYPE\n");
            break;

        case ACCESS_DENIED_ACE_TYPE:
            printf("ACCESS_DENIED_ACE_TYPE\n");
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            printf("SYSTEM_AUDIT_ACE_TYPE\n");
            break;

        default:
            printf("INVALID ACE\n");
            break;
    }

    // Dump ACE flags.
    // ===============

    printf("ACE FLAGS = ");

    if (m_pAce->Header.AceFlags & INHERITED_ACE)
        printf("INHERITED_ACE ");
    if (m_pAce->Header.AceFlags & CONTAINER_INHERIT_ACE)
        printf("CONTAINER_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & INHERIT_ONLY_ACE)
        printf("INHERIT_ONLY_ACE ");
    if (m_pAce->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE)
        printf("NO_PROPAGATE_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & OBJECT_INHERIT_ACE)
        printf("OBJECT_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG)
        printf(" FAILED_ACCESS_ACE_FLAG");
    if (m_pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        printf(" SUCCESSFUL_ACCESS_ACE_FLAG");
    printf("\n");

    // Dump the SID.
    // =============

    CNtSid *pSid = GetSid();
    
    if (pSid)
    {
        pSid->Dump();
        delete pSid;
    }

    DumpAccessMask();
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Alternate constructor which uses a normal NT ACE as a basis for
//  object construction.
//
//  Parameters:
//  <pAceSrc>       A read-only pointer to the source ACE upon which to
//                  base object construction.
//
//  After construction, GetStatus() can be used to determine if the
//  object constructed properly.  NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(PGENERIC_ACE pAceSrc)
{
    m_dwStatus = NoError;

    if (pAceSrc == 0)
    {
        m_dwStatus = NullAce;
        m_pAce = 0;
    }

    m_pAce = (PGENERIC_ACE) new BYTE[pAceSrc->Header.AceSize];
	if ( m_pAce == NULL )
	{
		m_dwStatus = InternalError;
		return;
	}
    ZeroMemory(m_pAce, pAceSrc->Header.AceSize);
    memcpy(m_pAce, pAceSrc, pAceSrc->Header.AceSize);
}

//***************************************************************************
//
//  CNtAce copy constructor.
//
//***************************************************************************
// ok

CNtAce::CNtAce(CNtAce &Src)
{
    m_dwStatus = NoError;
    m_pAce = 0;
    *this = Src;
}

//***************************************************************************
//
//  CNtAce assignment operator.
//
//***************************************************************************
// ok

CNtAce &CNtAce::operator =(CNtAce &Src)
{
    if (m_pAce != 0)
        delete m_pAce;

    if (Src.m_pAce == 0)
    {
        m_pAce = 0;
        m_dwStatus = NullAce;
        return *this;
    }

    m_pAce = (PGENERIC_ACE) new BYTE[Src.m_pAce->Header.AceSize];
    if(m_pAce == NULL)
    {
        m_dwStatus = InternalError;
    }
    else
    {
        ZeroMemory(m_pAce, Src.m_pAce->Header.AceSize);
        memcpy(m_pAce, Src.m_pAce, Src.m_pAce->Header.AceSize);
        m_dwStatus = Src.m_dwStatus;
    }
    return *this;
}



//***************************************************************************
//
//  CNtAce destructor
//
//***************************************************************************
// ok

CNtAce::~CNtAce()
{
    if (m_pAce)
        delete m_pAce;
}

//***************************************************************************
//
//  CNtAce::GetType
//
//  Gets the Ace Type as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returns ACCESS_ALLOWED_ACE_TYPE, ACCESS_DENIED_ACE_TYPE, or
//      SYSTEM_AUDIT_ACE_TYPE.  Returns -1 on error, such as a null ACE.
//
//      Returning -1 (or an analog) is required as an error code because
//      ACCESS_ALLOWED_ACE_TYPE is defined to be zero.
//
//***************************************************************************
// ok

int CNtAce::GetType()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceType;
}

//***************************************************************************
//
//  CNtAce::GetFlags
//
//  Gets the Ace Flag as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returning -1 if error, other wise the flags.
//
//***************************************************************************

int CNtAce::GetFlags()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceFlags;
}

//***************************************************************************
//
//  CNtAce::GetFullUserName
//
//  Gets the domain\user name.
//
//***************************************************************************

HRESULT CNtAce::GetFullUserName(WCHAR * pBuff, DWORD dwSize)
{
    CNtSid *pSid = GetSid();
    if(pSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtSid> d0(pSid);
    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk);
    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);
    WCHAR wTemp[256];
    wTemp[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
    {
        wcscpy(wTemp, pRetDomain);
        wcscat(wTemp, L"|");
    }
    wcscat(wTemp, pRetAccount);
    wcsncpy(pBuff, wTemp, dwSize-1);
    return S_OK;
}

HRESULT CNtAce::GetFullUserName2(WCHAR ** pBuff)
{
    CNtSid *pSid = GetSid();
    if(pSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtSid> d0(pSid);
    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    if(0 != pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk))
        return WBEM_E_FAILED;

    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);

    int iLen = 3;
    if(pRetAccount)
        iLen += wcslen(pRetAccount);
    if(pRetDomain)
        iLen += wcslen(pRetDomain);
    (*pBuff) = new WCHAR[iLen];
    if((*pBuff) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    (*pBuff)[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
        wcscpy(*pBuff, pRetDomain);
    else
        wcscpy(*pBuff, L".");
    wcscat(*pBuff, L"|");
    wcscat(*pBuff, pRetAccount);
    return S_OK;

}
//***************************************************************************
//
//  CNtAce::Serialize
//
//  Serializes the ace.
//
//***************************************************************************

bool CNtAce::Serialize(BYTE * pData)
{
    if(m_pAce == NULL)
        return false;
    DWORD dwSize = m_pAce->Header.AceSize;
    memcpy((void *)pData, (void *)m_pAce, dwSize);
    return true;
}

//***************************************************************************
//
//  CNtAce::Deserialize
//
//  Deserializes the ace.  Normally this isnt called since the
//  CNtAce(PGENERIC_ACE pAceSrc) constructor is fine.  However, this is
//  used for the case where the db was created on win9x and we are now
//  running on nt.  In that case, the format is the same as outlined in
//  C9XAce::Serialize
//
//***************************************************************************

bool CNtAce::Deserialize(BYTE * pData)
{
    BYTE * pNext;
    pNext = pData + 2*(wcslen((LPWSTR)pData) + 1);
    DWORD * pdwData = (DWORD *)pNext;
    DWORD dwFlags, dwType, dwAccess;
    dwFlags = *pdwData;
    pdwData++;
    dwType = *pdwData;
    pdwData++;
    dwAccess = *pdwData;
    pdwData++;
    CNtAce temp(dwAccess, dwType, dwFlags, (LPWSTR)pData);
    *this = temp;
    return true;

}

//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Constructs an empty ACL with a user-specified size.

//
//  Parameters:
//  <dwInitialSize>     Defaults to 128. Recommended values are 128 or
//                      higher in powers of two.
//
//  After construction, GetStatus() should be called to verify
//  the ACL initialized properly.  Expected value is NoError.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(DWORD dwInitialSize)
{
    m_pAcl = (PACL) new BYTE[dwInitialSize];
	if ( m_pAcl == NULL )
	{
		m_dwStatus = InternalError;
		return;
	}
    ZeroMemory(m_pAcl, dwInitialSize);
    BOOL bRes = InitializeAcl(m_pAcl, dwInitialSize, ACL_REVISION);

    if (!bRes)
    {
        delete m_pAcl;
        m_pAcl = 0;
        m_dwStatus = NullAcl;
        return;
    }

    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtAcl copy constructor.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(CNtAcl &Src)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    *this = Src;
}

//***************************************************************************
//
//  CNtAcl assignment operator
//
//***************************************************************************
// ok

CNtAcl &CNtAcl::operator = (CNtAcl &Src)
{
    if (m_pAcl != 0)
        delete m_pAcl;

    // Default to a NULL ACL.
    // ======================

    m_pAcl = 0;
    m_dwStatus = NullAcl;

    if (Src.m_pAcl == 0)
        return *this;

    // Now copy the source ACL.
    // ========================

    DWORD dwSize = Src.m_pAcl->AclSize;

    m_pAcl = (PACL) new BYTE[dwSize];
    if(m_pAcl == NULL)
    {
        m_dwStatus = InternalError;
        return *this;
    }

    ZeroMemory(m_pAcl, dwSize);

    memcpy(m_pAcl, Src.m_pAcl, dwSize);

    // Verify it.
    // ==========

    if (!IsValidAcl(m_pAcl))
    {
        delete m_pAcl;
        m_pAcl = 0;
        m_dwStatus = InvalidAcl;
        return *this;
    }

    m_dwStatus = Src.m_dwStatus;
    return *this;
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Returns an ACE at the specified index.  To enumerate ACEs, the caller
//  should determine the number of ACEs using GetNumAces() and then call
//  this function with each index starting from 0 to number of ACEs - 1.
//
//  Parameters:
//  <nIndex>        The index of the desired ACE.
//
//  Return value:
//  A newly allocated CNtAce object which must be deallocated using
//  operator delete.  This is only a copy.  Modifications to the returned
//  CNtAce do not affect the ACL from which it came.
//
//  Returns NULL on error.
//
//***************************************************************************
// ok

CNtAce *CNtAcl::GetAce(int nIndex)
{
    if (m_pAcl == 0)
        return 0;

    LPVOID pAce = 0;

    BOOL bRes = ::GetAce(m_pAcl, (DWORD) nIndex, &pAce);

    if (!bRes)
        return 0;

    return new CNtAce(PGENERIC_ACE(pAce));
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Alternate method to get ACEs to avoid dynamic allocation & cleanup,
//  since an auto object can be used as the parameter.
//
//  Parameters:
//  <Dest>          A reference to a CNtAce to receive the ACE value.
//
//  Return value:
//  TRUE if assigned, FALSE if not.
//
//***************************************************************************

BOOL CNtAcl::GetAce(int nIndex, CNtAce &Dest)
{
    CNtAce *pNew = GetAce(nIndex);
    if (pNew == 0)
        return FALSE;

    Dest = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  CNtAcl::DeleteAce
//
//  Removes the specified ACE from the ACL.
//
//  Parameters:
//  <nIndex>        The 0-based index of the ACE which should be removed.
//
//  Return value:
//  TRUE if the ACE was deleted, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::DeleteAce(int nIndex)
{
    if (m_pAcl == 0)
        return FALSE;

    BOOL bRes = ::DeleteAce(m_pAcl, DWORD(nIndex));

    return bRes;
}

//***************************************************************************
//
//  CNtAcl::GetSize()
//
//  Return value:
//  Returns the size in bytes of the ACL
//
//***************************************************************************
// ok

DWORD CNtAcl::GetSize()
{
    if (m_pAcl == 0 || !IsValidAcl(m_pAcl))
        return 0;

    return DWORD(m_pAcl->AclSize);
}


//***************************************************************************
//
//  CNtAcl::GetAclSizeInfo
//
//  Gets information about used/unused space in the ACL.  This function
//  is primarily for internal use.
//
//  Parameters:
//  <pdwBytesInUse>     Points to a DWORD to receive the number of
//                      bytes in use in the ACL.  Can be NULL.
//  <pdwBytesFree>      Points to a DWORD to receive the number of
//                      bytes free in the ACL.  Can be NULL.
//
//  Return value:
//  Returns TRUE if the information was retrieved, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::GetAclSizeInfo(
    PDWORD pdwBytesInUse,
    PDWORD pdwBytesFree
    )
{
    if (m_pAcl == 0)
        return 0;

    if (!IsValidAcl(m_pAcl))
        return 0;

    if (pdwBytesInUse)
        *pdwBytesInUse = 0;
    if (pdwBytesFree)
        *pdwBytesFree  = 0;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
        return FALSE;

    if (pdwBytesInUse)
        *pdwBytesInUse = inf.AclBytesInUse;
    if (pdwBytesFree)
        *pdwBytesFree  = inf.AclBytesFree;

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::AddAce
//
//  Adds an ACE to the ACL.
//  Ordering semantics for denial ACEs are handled automatically.
//
//  Parameters:
//  <pAce>      A read-only pointer to the CNtAce to be added.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::AddAce(CNtAce *pAce)
{
    // Verify we have an ACL and a valid ACE.
    // ======================================

    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (pAce->GetStatus() != CNtAce::NoError)
        return FALSE;

    // Inherited aces go after non inherited aces

    bool bInherited = (pAce->GetFlags() & INHERITED_ACE) != 0;
    int iFirstInherited = 0;

    // inherited aces must go after non inherited.  Find out
    // the position of the first inherited ace

    int iCnt;
    for(iCnt = 0; iCnt < m_pAcl->AceCount; iCnt++)
    {
        CNtAce *pAce2 = GetAce(iCnt);
        CDeleteMe<CNtAce> dm(pAce2);
        if (pAce2)
            if((pAce2->GetFlags() & INHERITED_ACE) != 0)
                break;
    }
    iFirstInherited = iCnt;


    // Since we want to add access denial ACEs to the front of the ACL,
    // we have to determine the type of ACE.
    // ================================================================

    DWORD dwIndex;

    if (pAce->GetType() == ACCESS_DENIED_ACE_TYPE)
        dwIndex = (bInherited) ? iFirstInherited : 0;
    else
        dwIndex = (bInherited) ? MAXULONG : iFirstInherited; 

    // Verify that there is enough room in the ACL.
    // ============================================

    DWORD dwRequiredFree = pAce->GetSize();

    DWORD dwFree = 0;
    DWORD dwUsed = 0;
    GetAclSizeInfo(&dwUsed, &dwFree);

    // If we don't have enough room, resize the ACL.
    // =============================================

    if (dwFree < dwRequiredFree)
    {
        BOOL bRes = Resize(dwUsed + dwRequiredFree);

        if (!bRes)
            return FALSE;
    }

    // Now actually add the ACE.
    // =========================

    BOOL bRes = ::AddAce(
        m_pAcl,
        ACL_REVISION,
        dwIndex,                      // Either beginning or end.
        pAce->GetPtr(),         // Get ptr to ACE.
        pAce->GetSize()                       // One ACE only.
        );

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::Resize()
//
//  Expands the size of the ACL to hold more info or reduces the size
//  of the ACL for maximum efficiency after ACL editing is completed.
//
//  Normally, the user should not attempt to resize the ACL to a larger
//  size, as this is automatically handled by AddAce.  However, shrinking
//  the ACL to its minimum size is recommended.
//
//  Parameters:
//  <dwNewSize>     The required new size of the ACL in bytes.  If set to
//                  the class constant MinimumSize (1), then the ACL
//                  is reduced to its minimum size.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::Resize(DWORD dwNewSize)
{
    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!IsValidAcl(m_pAcl))
        return FALSE;

    // If the ACL cannot be reduced to the requested size,
    // return FALSE.
    // ===================================================

    DWORD dwInUse, dwFree;

    if (!GetAclSizeInfo(&dwInUse, &dwFree))
        return FALSE;

    if (dwNewSize == MinimumSize)       // If user is requesting a 'minimize'
        dwNewSize = dwInUse;

    if (dwNewSize < dwInUse)
        return FALSE;

    // Allocate a new ACL.
    // ===================

    CNtAcl *pNewAcl = new CNtAcl(dwNewSize);

    if (!pNewAcl || pNewAcl->GetStatus() != NoError)
    {
        delete pNewAcl;
        return FALSE;
    }

    // Loop through ACEs and transfer them.
    // ====================================

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);

        if (pAce == NULL)
        {
            delete pNewAcl;
            return FALSE;
        }

        BOOL bRes = pNewAcl->AddAce(pAce);

        if (!bRes)
        {
            DWORD dwLast = GetLastError();
            delete pAce;
            delete pNewAcl;
            return FALSE;
        }

        delete pAce;
    }

    if (!IsValid())
    {
        delete pNewAcl;
        return FALSE;
    }

    // Now transfer the ACL.
    // =====================

    *this = *pNewAcl;
    delete pNewAcl;

    return TRUE;
}


//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Alternate constructor which builds the object based on a plain
//  NT ACL.
//
//  Parameters:
//  <pAcl>  Pointer to a read-only ACL.
//
//***************************************************************************
// ok
CNtAcl::CNtAcl(PACL pAcl)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    if (pAcl == 0)
    {
        m_dwStatus = NullAcl;
        return;
    }

    if (!IsValidAcl(pAcl))
    {
        m_dwStatus = InvalidAcl;
        return;
    }

    m_pAcl = (PACL) new BYTE[pAcl->AclSize];
    if(m_pAcl == NULL)
    {
        m_dwStatus = InternalError;
        return;
    }
    ZeroMemory(m_pAcl, pAcl->AclSize);
    memcpy(m_pAcl, pAcl, pAcl->AclSize);
}

//***************************************************************************
//
//  CNtAcl::GetNumAces
//
//  Return value:
//  Returns the number of ACEs available in the ACL.  Zero is a legal return
//  value. Returns -1 on error
//
//  Aces can be retrieved using GetAce using index values from 0...n-1 where
//  n is the value returned from this function.
//
//***************************************************************************
// ok

int CNtAcl::GetNumAces()
{
    if (m_pAcl == 0)
        return -1;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
    {
        return -1;
    }

    return (int) inf.AceCount;
}

//***************************************************************************
//
//  CNtAcl destructor
//
//***************************************************************************
// ok

CNtAcl::~CNtAcl()
{
    if (m_pAcl)
        delete m_pAcl;
}


//***************************************************************************
//
//  CNtAcl::Dump
//
//  Dumps the ACL to the console for debugging purposes.  Illustrates
//  how to traverse the ACL and extract the ACEs.
//
//***************************************************************************
// ok

void CNtAcl::Dump()
{
    printf("---ACL DUMP---\n");

    if (m_pAcl == 0)
    {
        switch (m_dwStatus)
        {
            case NullAcl:
                printf("NullAcl\n");
                break;

            case InvalidAcl:
                printf("InvalidAcl\n");
                break;

            default:
                printf("<internal error; unknown status>\n");
        }
        return;
    }

    DWORD InUse, Free;
    GetAclSizeInfo(&InUse, &Free);
    printf("%d bytes in use, %d bytes free\n",
        InUse, Free
        );

    printf("Number of ACEs = %d\n", GetNumAces());

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);
        if (pAce)
        {
            pAce->Dump(i+1);
            delete pAce;
        }
    }

    printf("---END ACL DUMP---\n");

}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  Returns the DACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the DACL.   This object
//  is a copy of the DACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no DACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetDacl()
{
    BOOL bDaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pDacl;
    BOOL bRes = GetSecurityDescriptorDacl(
        m_pSD,
        &bDaclPresent,
        &pDacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bDaclPresent)  // No DACL present
        return 0;

    CNtAcl *pNewDacl = new CNtAcl(pDacl);

    return pNewDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  An alternate method to returns the DACL of the security descriptor.
//  This version uses an existing object instead of returning a
//  dynamically allocated object.
//
//  Parameters:
//  <DestAcl>           A object which will receive the DACL.
//
//  Return value:
//  TRUE on success, FALSE on failure
//
//***************************************************************************

BOOL CNtSecurityDescriptor::GetDacl(CNtAcl &DestAcl)
{
    CNtAcl *pNew = GetDacl();
    if (pNew == 0)
        return FALSE;

    DestAcl = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  SD Helpers
//
//***************************************************************************

SNtAbsoluteSD::SNtAbsoluteSD()
{
    m_pSD = 0;
    m_pDacl = 0;
    m_pSacl = 0;
    m_pOwner = 0;
    m_pPrimaryGroup = 0;
}

SNtAbsoluteSD::~SNtAbsoluteSD()
{
    if (m_pSD)
        delete m_pSD;
    if (m_pDacl)
        delete m_pDacl;
    if (m_pSacl)
        delete m_pSacl;
    if (m_pOwner)
        delete m_pOwner;
    if (m_pPrimaryGroup)
        delete m_pPrimaryGroup;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetAbsoluteCopy
//
//  Returns a copy of the current object's internal SD in absolute format.
//  Returns NULL on error.  The memory must be freed with LocalFree().
//
//***************************************************************************
// ok

SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy()
{
    if (m_dwStatus != NoError || m_pSD == 0 || !IsValid())
        return 0;

    // Prepare for conversion.
    // =======================

    DWORD dwSDSize = 0, dwDaclSize = 0, dwSaclSize = 0,
        dwOwnerSize = 0, dwPrimaryGroupSize = 0;

    SNtAbsoluteSD *pNewSD = new SNtAbsoluteSD;
    if (!pNewSD)
        return NULL;

    BOOL bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        delete pNewSD;
        return 0;
    }

    // Allocate the required buffers and convert.
    // ==========================================

    pNewSD->m_pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSDSize];
    if(pNewSD->m_pSD == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pSD, dwSDSize);

    pNewSD->m_pDacl   = (PACL) new BYTE[dwDaclSize];
    if(pNewSD->m_pDacl == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pDacl, dwDaclSize);

    pNewSD->m_pSacl   = (PACL) new BYTE[dwSaclSize];
    if(pNewSD->m_pSacl == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pSacl, dwSaclSize);

    pNewSD->m_pOwner  = (PSID) new BYTE[dwOwnerSize];
    if(pNewSD->m_pOwner == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pOwner, dwOwnerSize);

    pNewSD->m_pPrimaryGroup  = (PSID) new BYTE[dwPrimaryGroupSize];
    if(pNewSD->m_pPrimaryGroup == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pPrimaryGroup, dwPrimaryGroupSize);

    bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (!bRes)
    {
        delete pNewSD;
        return 0;
    }

    return pNewSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetFromAbsoluteCopy
//
//  Replaces the current SD from an absolute copy.
//
//  Parameters:
//  <pSrcSD>    A read-only pointer to the absolute SD used as a source.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetFromAbsoluteCopy(
    SNtAbsoluteSD *pSrcSD
    )
{
    if (pSrcSD ==  0 || !IsValidSecurityDescriptor(pSrcSD->m_pSD))
        return FALSE;


    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSrcSD->m_pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
        return FALSE;

    if (ctrl & SE_SELF_RELATIVE)  // Source is not absolute!!
        return FALSE;

    // If here, we are committed to change.
    // ====================================

    if (m_pSD)
	{
        delete m_pSD;
	}
    m_pSD = 0;
    m_dwStatus = NullSD;


    DWORD dwRequired = 0;

    bRes = MakeSelfRelativeSD(
            pSrcSD->m_pSD,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    m_pSD = new BYTE[dwRequired];
    if (!m_pSD)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pSrcSD->m_pSD,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        delete m_pSD;
        m_pSD = 0;
        return FALSE;
    }

    m_dwStatus = NoError;
    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::SetDacl
//
//  Sets the DACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************

BOOL CNtSecurityDescriptor::SetDacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;


    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorDacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::Dump
//
//  Dumps the contents of the security descriptor to the console
//  for debugging purposes.
//
//***************************************************************************
// ?

void CNtSecurityDescriptor::Dump()
{
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRev;
    BOOL bRes;

    printf("--- SECURITY DESCRIPTOR DUMP ---\n");

    bRes = GetSecurityDescriptorControl(m_pSD, &Control, &dwRev);

    if (!bRes)
    {
        printf("SD Dump: Failed to get control info\n");
        return;
    }

    printf("Revision : 0x%X\n", dwRev);

    printf("Control Info :\n");

    if (Control & SE_SELF_RELATIVE)
        printf("    SE_SELF_RELATIVE\n");

    if (Control & SE_OWNER_DEFAULTED)
        printf("    SE_OWNER_DEFAULTED\n");

    if (Control & SE_GROUP_DEFAULTED)
        printf("    SE_GROUP_DEFAULTED\n");

    if (Control & SE_DACL_PRESENT)
        printf("    SE_DACL_PRESENT\n");

    if (Control & SE_DACL_DEFAULTED)
        printf("    SE_DACL_DEFAULTED\n");

    if (Control & SE_SACL_PRESENT)
        printf("    SE_SACL_PRESENT\n");

    if (Control & SE_SACL_DEFAULTED)
        printf("    SE_SACL_DEFAULTED\n");

    if (Control & SE_DACL_PROTECTED)
        printf("    SE_DACL_PROTECTED\n");

    // Get owner.
    // =========

    CNtSid *pSid = GetOwner();

    if (pSid)
    {
        printf("Owner : ");
        pSid->Dump();
        delete pSid;
    }

    CNtAcl *pDacl = GetDacl();

    if (pDacl == 0)
    {
        printf("Unable to locate DACL\n");
        return;
    }

    printf("DACL retrieved\n");

    pDacl->Dump();

    delete pDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor constructor
//
//  A default constructor creates a no-access security descriptor.
//
//***************************************************************************
//  ok

CNtSecurityDescriptor::CNtSecurityDescriptor()
{
    m_pSD = 0;
    m_dwStatus = NoError;

    PSECURITY_DESCRIPTOR pTmp = new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!pTmp)
    {
        delete pTmp;
        m_dwStatus = InvalidSD;
        return;
    }
    
    ZeroMemory(pTmp, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeSecurityDescriptor(pTmp, SECURITY_DESCRIPTOR_REVISION))
    {
        delete pTmp;
        m_dwStatus = InvalidSD;
        return;
    }

    DWORD dwRequired = 0;

    BOOL bRes = MakeSelfRelativeSD(
            pTmp,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        delete pTmp;
        return;
    }

    m_pSD = new BYTE[dwRequired];
    if (!m_pSD)
    {
        m_dwStatus = InvalidSD;
        delete pTmp;
        return;
    }

    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pTmp,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        delete m_pSD;
        m_pSD = 0;
        delete pTmp;
        return;
    }

    delete pTmp;
    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetSize
//
//  Returns the size in bytes of the internal SD.
//
//***************************************************************************
//  ok

DWORD CNtSecurityDescriptor::GetSize()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    return GetSecurityDescriptorLength(m_pSD);
}


//***************************************************************************
//
//  CNtSecurityDescriptor copy constructor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(CNtSecurityDescriptor &Src)
{
    m_pSD = 0;
    m_dwStatus = NoError;
    *this = Src;
}

//***************************************************************************
//
//  CNtSecurityDescriptor assignment operator
//
//***************************************************************************
// ok

CNtSecurityDescriptor & CNtSecurityDescriptor::operator=(
    CNtSecurityDescriptor &Src
    )
{
    if (m_pSD)
        delete m_pSD;

    m_dwStatus = Src.m_dwStatus;
    m_pSD = 0;

    if (Src.m_pSD == 0)
        return *this;

    //SIZE_T dwSize = 2*GetSecurityDescriptorLength(Src.m_pSD);
    SIZE_T dwSize = GetSecurityDescriptorLength(Src.m_pSD);
    m_pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
    if(m_pSD == NULL)
    {
        m_dwStatus = Failed;
    }
    else
    {
        ZeroMemory(m_pSD, dwSize);
        CopyMemory(m_pSD, Src.m_pSD, dwSize);
    }

    return *this;
}


//***************************************************************************
//
//  CNtSecurityDescriptor destructor.
//
//***************************************************************************
// ok

CNtSecurityDescriptor::~CNtSecurityDescriptor()
{
    if (m_pSD)
        delete m_pSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetSacl
//
//  Returns the SACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the SACL.   This object
//  is a copy of the SACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no SACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetSacl()
{
    BOOL bSaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pSacl;
    BOOL bRes = GetSecurityDescriptorSacl(
        m_pSD,
        &bSaclPresent,
        &pSacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bSaclPresent)  // No Sacl present
        return 0;

    CNtAcl *pNewSacl = new CNtAcl(pSacl);

    return pNewSacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetSacl
//
//  Sets the SACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetSacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorSacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetGroup
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetGroup()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorGroup(m_pSD, &pSid, &bDefaulted);

    // TMP: Check to make sure the group is not NULL!!!!
	if ( pSid == NULL )
	{
//		DebugBreak();
        ///ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor has no group\n"));
	}


    if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);

}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetGroup
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetGroup(CNtSid *pSid)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // TMP: Check to make sure the group is not NULL!!!!
	if ( pSid->GetPtr() == NULL )
	{
//		DebugBreak();
        ///ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor is trying to bland out the group!\n"));
	}


	
	// Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorGroup(
        pTmp->m_pSD,
        pSid->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::HasOwner
//
//  Determines if a security descriptor has an owner.
//
//  Return values:
//      SDNotOwned, SDOwned, Failed
//
//***************************************************************************
// ok

int CNtSecurityDescriptor::HasOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return Failed;

    PSID pSid = 0;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, 0);

    if (!bRes || !IsValidSid(pSid))
        return Failed;

    if (pSid == 0)
        return SDNotOwned;

    return SDOwned;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetOwner
//
//  Returns the SID of the owner of the Security Descriptor or NULL
//  if an error occurred or there is no owner.  Use HasOwner() to
//  determine this.
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, &bDefaulted);

    // TMP: Check to make sure the owner is not NULL!!!!
	if ( pSid == NULL )
	{
//		DebugBreak();
        ///ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor has no owner\n"));
	}



	if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetOwner
//
//  Sets the owner of a security descriptor.
//
//  Parameters:
//  <pSid>  The SID of the new owner.
//
//  Return Value:
//  TRUE if owner was changed, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetOwner(CNtSid *pSid)
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!pSid->IsValid())
        return FALSE;

    // TMP: Check to make sure the owner is not NULL!!!!
	if ( pSid->GetPtr() == NULL )
	{
        ///ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor is trying to zap the owner!\n"));
//		DebugBreak();
	}


    
	// We must convert to absolute format to make the change.
    // =======================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = SetSecurityDescriptorOwner(pTmp->m_pSD, pSid->GetPtr(), FALSE);

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    // If here, we have managed the change, so we have to
    // convert *this back from the temporary absolute SD.
    // ===================================================

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return bRes;
}



//***************************************************************************
//
//  CNtSecurityDescriptor::CNtSecurityDescriptor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD,
    BOOL bAcquire
    )
{
    m_pSD = 0;
    m_dwStatus = NullSD;

    // Ensure that SD is not NULL.
    // ===========================

    if (pSD == 0)
    {
        if (bAcquire)
            delete pSD;
        return;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            delete pSD;
        return;
    }

    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            delete pSD;
        return;
    }

    if ((ctrl & SE_SELF_RELATIVE) == 0)
    {
        // If here, we have to conver the SD to self-relative form.
        // ========================================================

        DWORD dwRequired = 0;

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        m_pSD = new BYTE[dwRequired];
        if (!m_pSD)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        ZeroMemory(m_pSD, dwRequired);

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (!bRes)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        m_dwStatus = NoError;
        return;
    }


    // If here, the SD was already self-relative.
    // ==========================================

    if (bAcquire)
        m_pSD = pSD;
    else
    {
        DWORD dwRes = GetSecurityDescriptorLength(pSD);
        m_pSD = new BYTE[dwRes];
        if (!m_pSD)
        {
            m_dwStatus = InvalidSD;
            return;
        }

        ZeroMemory(m_pSD, dwRes);
        memcpy(m_pSD, pSD, dwRes);
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSecurity::DumpPrivileges
//
//  Dumps current process token privileges to the console.
//
//***************************************************************************

BOOL CNtSecurity::DumpPrivileges()
{
    HANDLE hToken = 0;
    TOKEN_INFORMATION_CLASS tki;
    BOOL bRes;
    LPVOID pTokenInfo = 0;
    DWORD  dwRequiredBytes;
    BOOL   bRetVal = FALSE;
    TOKEN_PRIVILEGES *pPriv = 0;
    TCHAR *pName = 0;
    DWORD dwIndex;
    DWORD dwLastError;

    _tprintf(__TEXT("--- Current Token Privilege Dump ---\n"));

    // Starting point: open the process token.
    // =======================================

    bRes = OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    if (!bRes)
    {
        _tprintf(__TEXT("Unable to open process token\n"));
        goto Exit;
    }

    // Query for privileges.
    // =====================

    tki = TokenPrivileges;

    bRes = GetTokenInformation(
        hToken,
        tki,
        pTokenInfo,
        0,
        &dwRequiredBytes
        );

    dwLastError = GetLastError();

    if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        printf("Unable to get buffer size for token information\n");
        goto Exit;
    }

    pTokenInfo = new BYTE[dwRequiredBytes];
    if (!pTokenInfo)
        goto Exit;
    ZeroMemory(pTokenInfo, dwRequiredBytes);

    bRes = GetTokenInformation(
        hToken,
        tki,
        pTokenInfo,
        dwRequiredBytes,
        &dwRequiredBytes
        );

    if (!bRes)
    {
        printf("Unable to query token\n");
        goto Exit;
    }

    // Loop through the privileges.
    // ============================

    pPriv = (TOKEN_PRIVILEGES *) pTokenInfo;

    for (dwIndex = 0; dwIndex < pPriv->PrivilegeCount; dwIndex++)
    {
        pName = 0;
        dwRequiredBytes = 0;

        // Find the buffer size required for the name.
        // ===========================================

        bRes = LookupPrivilegeName(
            0,                          // System name
            &pPriv->Privileges[dwIndex].Luid,
            pName,
            &dwRequiredBytes
            );

        dwLastError = GetLastError();

        if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Failed to find privilege name\n");
            goto Exit;
        }

        // Allocate enough space to hold the privilege name.
        // =================================================

        pName = (TCHAR *) new BYTE[dwRequiredBytes];
        if(pName == NULL)
            goto Exit;

        ZeroMemory(pName, dwRequiredBytes);

        bRes = LookupPrivilegeName(
            0,                          // System name
            &pPriv->Privileges[dwIndex].Luid,
            pName,
            &dwRequiredBytes
            );

        printf("%s ", pName);
        delete pName;

        // Determine the privilege 'status'.
        // =================================

        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_ENABLED)
            printf("<ENABLED> ");
        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
            printf("<ENABLED BY DEFAULT> ");
        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS)
            printf("<USED FOR ACCESS> ");

        printf("\n");

        pName = 0;
    }

    printf("--- End Privilege Dump ---\n");

    bRetVal = TRUE;

Exit:
    if (pTokenInfo)
        delete pTokenInfo;
    if (hToken)
        CloseHandle(hToken);
    return bRetVal;
}

//***************************************************************************
//
//  CNtSecurity::SetPrivilege
//
//  Ensures a given privilege is enabled.
//
//  Parameters:
//
//  <pszPrivilegeName>  One of the SE_ constants defined in WINNT.H for
//                      privilege names.  Example: SE_SECURITY_NAME
//  <bEnable>           If TRUE, the privilege will be enabled. If FALSE,
//                      the privilege will be disabled.
//
//  Return value:
//  TRUE if the privilege was enabled, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurity::SetPrivilege(
    TCHAR *pszPrivilegeName,     // An SE_ value.
    BOOL  bEnable               // TRUE=enable, FALSE=disable
    )
{
    HANDLE hToken = 0;
    TOKEN_PRIVILEGES tkp;
    LUID priv;
    BOOL bRes;
    BOOL bRetVal = FALSE;

    bRes = OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    if (!bRes)
        goto Exit;

    // Locate the privilege LUID based on the requested name.
    // ======================================================

    bRes = LookupPrivilegeValue(
        0,                          // system name, 0=local
        pszPrivilegeName,
        &priv
        );

    if (!bRes)
        goto Exit;

    // We now have the LUID.  Next, we build up the privilege
    // setting based on the user-specified <bEnable>.
    // ======================================================

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid  = priv;

    if (bEnable)
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tkp.Privileges[0].Attributes = 0;

    // Do it.
    // ======

    bRes = AdjustTokenPrivileges(
        hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        0,
        0
        );

    if (!bRes)
        goto Exit;

    bRetVal = TRUE;

Exit:
    if (hToken)
        CloseHandle(hToken);
    return bRetVal;
}


//***************************************************************************
//
//  CNtSecurity::GetFileSD
//
//  Gets the complete security descriptor for file or directory on NT systems.
//
//  Parameters:
//  <pszFile>       The path to the file or directory.
//
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//
//  <pReturnedSD>   Receives a pointer to the CNtSecurityDecriptor object
//                  which represents security on the file.  The caller
//                  becomes onwer of the object, which must be deallocated
//                  with operator delete.
//
//                  The returned object which is a copy of the
//                  underlying security descriptor.  Changes to the returned
//                  object are not propagated to the file.  SetFileSD must
//                  be used to do this.
//
//                  This will be set to point to NULL on error.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
// ok

int CNtSecurity::GetFileSD(
    IN  TCHAR *pszFile,
    IN SECURITY_INFORMATION SecInfo,
    OUT CNtSecurityDescriptor **pReturnedSD
    )
{
    // First, verify that the file/dir exists.
    // =======================================

#ifdef _UNICODE
    int nRes = _waccess(pszFile, 0);
#else
    int nRes = _access(pszFile, 0);
#endif

    if (nRes != 0)
    {
        if (errno == ENOENT)
            return NotFound;
        if (errno == EACCES)
            return AccessDenied;
        if (nRes == -1) // Other errors
            return Failed;
    }

    // If here, we think we can play with it.
    // ======================================

    PSECURITY_DESCRIPTOR pSD = 0;
    DWORD dwRequiredBytes;
    BOOL bRes;
    DWORD dwLastError;

    *pReturnedSD = 0;

    // Call once first to get the required buffer sizes.
    // =================================================

    bRes = GetFileSecurity(
        pszFile,
        SecInfo,
        pSD,
        0,
        &dwRequiredBytes
        );

    dwLastError = GetLastError();

    if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        // Analyze the error

        return Failed;
    }

    // Now call again with a buffer large enough to hold the SD.
    // =========================================================

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwRequiredBytes];
    if(pSD == NULL)
        return Failed;

    ZeroMemory(pSD, dwRequiredBytes);

    bRes = GetFileSecurity(
        pszFile,
        SecInfo,
        pSD,
        dwRequiredBytes,
        &dwRequiredBytes
        );

    if (!bRes)
    {
        delete pSD;
        return Failed;
    }

    // If here, we have a security descriptor.
    // =======================================

    CNtSecurityDescriptor *pNewSD = new CNtSecurityDescriptor(pSD, TRUE);
    if(pNewSD == NULL)
    {
        delete pSD;
        return Failed;
    }

    *pReturnedSD = pNewSD;

    return NoError;
}

//***************************************************************************
//
//  CNtSecurity::GetRegSD
//
//  Retrieves the security descriptor for a registry key.
//
//  Parameters:
//  <hRoot>         The root key (HKEY_LOCAL_MACHINE, etc.)
//  <pszSubKey>     The subkey under the root key.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           Receives the pointer to the security descriptor if
//                  no error occurs.  Caller must use operator delete.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
int CNtSecurity::GetRegSD(
    IN HKEY hRoot,
    IN TCHAR *pszSubKey,
    IN SECURITY_INFORMATION SecInfo,
    OUT CNtSecurityDescriptor **pSD
    )
{
    HKEY hKey;
    *pSD = 0;

    ACCESS_MASK amAccess = KEY_ALL_ACCESS;
    if (SecInfo & SACL_SECURITY_INFORMATION)
        amAccess |= ACCESS_SYSTEM_SECURITY;

    LONG lRes = RegOpenKeyEx(hRoot, pszSubKey, 0, amAccess, &hKey);

    if (lRes == ERROR_ACCESS_DENIED)
        return AccessDenied;

    if (lRes != ERROR_SUCCESS)
        return Failed;

    // If here, the key is open.  Now we try to get the security descriptor.
    // =====================================================================

    PSECURITY_DESCRIPTOR pTmpSD = 0;
    DWORD dwRequired = 0;

    // Determine the buffer size required.
    // ===================================

    lRes = RegGetKeySecurity(hKey, SecInfo, pTmpSD, &dwRequired);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    // Allocate room for the SD and get it.
    // ====================================
    pTmpSD = new BYTE[dwRequired];
    if (!pTmpSD)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    ZeroMemory(pTmpSD, dwRequired);

    lRes = RegGetKeySecurity(hKey, SecInfo, pTmpSD, &dwRequired);

    if (lRes != 0 || !IsValidSecurityDescriptor(pTmpSD))
    {
        delete pTmpSD;
        RegCloseKey(hKey);
        return Failed;
    }

    RegCloseKey(hKey);
    CNtSecurityDescriptor *pNewSD = new CNtSecurityDescriptor(pTmpSD, TRUE);
    if(pNewSD == NULL)
    {
        delete pTmpSD;
        return Failed;
    }
        
    *pSD = pNewSD;

    return NoError;
}


//***************************************************************************
//
//  CNtSecurity::SetRegSD
//
//  Sets the security descriptor for a registry key.
//
//  Parameters:
//  <hRoot>         The root key (HKEY_LOCAL_MACHINE, etc.)
//  <pszSubKey>     The subkey under the root key.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           The read-only pointer to the new security descriptor.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
int CNtSecurity::SetRegSD(
    IN HKEY hRoot,
    IN TCHAR *pszSubKey,
    IN SECURITY_INFORMATION SecInfo,
    IN CNtSecurityDescriptor *pSD
    )
{
    HKEY hKey;

    if (!pSD->IsValid())
        return Failed;

    ACCESS_MASK amAccess = KEY_ALL_ACCESS;
    if (SecInfo & SACL_SECURITY_INFORMATION)
        amAccess |= ACCESS_SYSTEM_SECURITY;

    LONG lRes = RegOpenKeyEx(hRoot, pszSubKey, 0, amAccess, &hKey);

    if (lRes == ERROR_ACCESS_DENIED)
        return AccessDenied;

    if (lRes != ERROR_SUCCESS)
        return Failed;

    // If here, the key is open.  Now we try to get the security descriptor.
    // =====================================================================

    PSECURITY_DESCRIPTOR pTmpSD = 0;
    DWORD dwRequired = 0;

    // Determine the buffer size required.
    // ===================================

    lRes = RegSetKeySecurity(hKey, SecInfo, pSD->GetPtr());

    if (lRes != 0)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    RegCloseKey(hKey);
    return NoError;
}



//***************************************************************************
//
//  CNtSecurity::SetFileSD
//
//  Sets the security descriptor for a file or directory.
//
//  Parameters:
//  <pszFile>       The file/dir for which to set security.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           Pointer to a valid CNtSecurityDescriptor
//
//***************************************************************************
//  ok
BOOL CNtSecurity::SetFileSD(
    IN TCHAR *pszFile,
    IN SECURITY_INFORMATION SecInfo,
    IN CNtSecurityDescriptor *pSD
    )
{
    // First, verify that the file/dir exists.
    // =======================================
#ifdef _UNICODE
    int nRes = _waccess(pszFile, 0);
#else
    int nRes = _access(pszFile, 0);
#endif

    if (nRes != 0)
        return FALSE;

    // Verify the SD is good.
    // ======================

    if (pSD->GetStatus() != NoError)
        return FALSE;

    BOOL bRes = ::SetFileSecurity(
        pszFile,
        SecInfo,
        pSD->GetPtr()
        );

    return bRes;
}

//***************************************************************************
//
//  CNtSecurity::GetDCName
//
//  Determines the domain controller for a given domain name.
//
//  Parameters:
//  <pszDomain>         The domain name for which to find the controller.
//  <pszDC>             Receives a pointer to the DC name.  Deallocate with
//                      operator delete.
//  <pszServer>         Optional remote helper server on which to execute
//                      the query. Defaults to NULL, which typically
//                      succeeds.
//
//  Return value:
//  NoError, NotFound, InvalidName
//
//***************************************************************************
/*
int CNtSecurity::GetDCName(
    IN  LPWSTR   pszDomain,
    OUT LPWSTR *pszDC,
    IN  LPWSTR   pszServer
    )
{
    LPBYTE pBuf;
    NET_API_STATUS Status;

    Status = NetGetDCName(pszServer, pszDomain, &pBuf);

    if (Status == NERR_DCNotFound)
        return NotFound;

    if (Status == ERROR_INVALID_NAME)
        return InvalidName;

    LPWSTR pRetStr = new wchar_t[wcslen(LPWSTR(pBuf)) + 1];
    wcscpy(pRetStr, LPWSTR(pBuf));
    NetApiBufferFree(pBuf);

    *pszDC = pRetStr;
    return NoError;
}
*/
//***************************************************************************
//
//  CNtSecurity::IsUserInGroup2
//
//  Determines if the use belongs to a particular NTLM group by checking the
//  group list in the access token.  This may be a better way than the
//  current implementation.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************
/*
BOOL CNtSecurity::IsUserInGroup2(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(!IsNT() || hAccessToken == NULL)
        return FALSE;       // No point in further testing

    DWORD dwErr;

    // Obtain and the groups from token.  Start off by determining how much
    // memory is required.

    TOKEN_GROUPS Groups;
    DWORD dwLen = 0;
    GetTokenInformation(hAccessToken, TokenGroups, &Groups, sizeof(Groups), &dwLen);
    if(dwLen == 0)
        return FALSE;

    // Load up the group list

    int BUFFER_SIZE = dwLen;
    BYTE * byteBuffer = new BYTE[BUFFER_SIZE];
    if(byteBuffer == NULL)
        return FALSE;
    DWORD dwSizeRequired = 0;
    BOOL bResult = GetTokenInformation( hAccessToken,
                                        TokenGroups,
                                        (void *) byteBuffer,
                                        BUFFER_SIZE,
                                        &dwSizeRequired );
    if ( !bResult ) {
        delete [] byteBuffer;
        dwErr = GetLastError();
        return ( FALSE );
    }

    // Loop through the group list looking for a match

    BOOL bFound = FALSE;
    PTOKEN_GROUPS pGroups = (PTOKEN_GROUPS) byteBuffer;
    for ( unsigned i = 0; i < pGroups->GroupCount; i++ )
    {
        CNtSid test(pGroups->Groups[i].Sid);
        if(test == Sid)
        {
            bFound = TRUE;
            break;
        }
    }

    delete [] byteBuffer;
    return bFound;
}*/

//***************************************************************************
//
//  CNtSecurity::IsUserInGroup
//
//  Determines if the use belongs to a particular NTLM group.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************

BOOL CNtSecurity::IsUserInGroup(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(hAccessToken == NULL)
        return FALSE;       // No point in further testing

    // create a security descriptor with a single entry which
    // is the group in question.

    CNtAce ace(1,ACCESS_ALLOWED_ACE_TYPE,0,Sid);
    if(ace.GetStatus() != 0)
        return FALSE;

    CNtAcl acl;
    acl.AddAce(&ace);
    CNtSecurityDescriptor sd;
    sd.SetDacl(&acl);
    CNtSid owner(CNtSid::CURRENT_USER);
    sd.SetGroup(&owner);            // Access check doesnt really care what you put, so long as you
                                    // put something for the owner
    sd.SetOwner(&owner);

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0;
    map.GenericExecute = 0;
    map.GenericAll = 0;
    PRIVILEGE_SET ps[10];
    DWORD dwSize = 10 * sizeof(PRIVILEGE_SET);


    DWORD dwGranted;
    BOOL bResult;

    BOOL bOK = ::AccessCheck(sd.GetPtr(), hAccessToken, 1, &map, ps, &dwSize, &dwGranted, &bResult);
    DWORD dwErr = GetLastError();
    if(bOK && bResult)
        return TRUE;
    else
        return FALSE;
}
//***************************************************************************
//
//  CNtSecurity::DoesGroupExist
//
//  Determines if a group exists.
//
//  Return value:
//  TRUE if the group exists
//
//***************************************************************************

bool CNtSecurity::DoesLocalGroupExist(
        LPWSTR pwszGroup,
        LPWSTR pwszMachine)
{
    bool bRet = false;
    HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
    if(hAPI)
    {
        NET_API_STATUS (NET_API_FUNCTION *pfnGetInfo)(LPWSTR , LPWSTR ,DWORD , LPBYTE *);
        (FARPROC&)pfnGetInfo = GetProcAddress(hAPI, "NetLocalGroupGetInfo");
        long lRes;
        if(pfnGetInfo)
        {
            LOCALGROUP_INFO_1 * info;

            lRes = pfnGetInfo(pwszMachine, pwszGroup, 1, (LPBYTE *)&info);
            if(lRes == NERR_Success)
            {
                NET_API_STATUS (NET_API_FUNCTION *pfnBufferFree)(LPVOID);
                (FARPROC&)pfnBufferFree = GetProcAddress(hAPI, "NetApiBufferFree");
                if(pfnBufferFree)
                    pfnBufferFree(info);

                bRet = true;
            }
        }
        FreeLibrary(hAPI);
    }
    return bRet;
}

//***************************************************************************
//
//  CNtSecurity::AddLocalGroup
//
//  Determines if a group exists.
//
//  Return value:
//  TRUE if the group exists
//
//***************************************************************************

bool CNtSecurity::AddLocalGroup(LPWSTR pwszGroupName, LPWSTR pwszGroupDescription)
{
    bool bRet = false;
    HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
    if(hAPI)
    {
        LOCALGROUP_INFO_1 info;
        info.lgrpi1_name = pwszGroupName;
        info.lgrpi1_comment = pwszGroupDescription;
        NET_API_STATUS (*pfnLocalAdd)(LPWSTR ,DWORD , LPBYTE ,LPDWORD);

        (FARPROC&)pfnLocalAdd = GetProcAddress(hAPI, "NetLocalGroupAdd");
        if(pfnLocalAdd)
            bRet = (pfnLocalAdd(NULL, 1, (LPBYTE)&info, NULL) == NERR_Success);
        FreeLibrary(hAPI);
    }
    return bRet;
}

//***************************************************************************
//
//***************************************************************************
void ChangeSecurity(CNtSecurityDescriptor *pSD)
{
    CNtAcl Acl;


    ACCESS_MASK Mask = FULL_CONTROL;


    CNtSid Sid(L"Everyone", 0);
    CNtAce Ace(
        Mask,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
        Sid);

    if (Ace.GetStatus() != CNtAce::NoError)
    {
        printf("Bad ACE\n");
        return;
    }

    CNtAce Ace2(Ace);
    CNtAce Ace3;
    Ace3 = Ace2;

    Acl.AddAce(&Ace3);

    CNtAcl Acl2(Acl);
    CNtAcl Acl3;
    Acl3 = Acl2;

    pSD->SetDacl(&Acl);

    CNtSecurityDescriptor SD2(*pSD);
    CNtSecurityDescriptor SD3;
    SD3.SetDacl(&Acl3);

    SD3 = SD2;

    *pSD = SD3;

    CNtSid *pOwner = pSD->GetOwner();

    if (pOwner)
        pSD->SetOwner(pOwner);
}

//***************************************************************************
//
//***************************************************************************



void SidTest(char *pUser, char *pMachine)
{
    wchar_t User[128], Mach[128];

    MultiByteToWideChar(CP_ACP, 0, pUser, -1, User, 128);
    MultiByteToWideChar(CP_ACP, 0, pMachine, -1, Mach, 128);

    printf("------SID TEST----------\n");

    LPWSTR pMach2 = 0;
    if (pMachine)
        pMach2 = Mach;

    CNtSid TseSid(User, pMach2);

    printf("TseSid status = %d\n", TseSid.GetStatus());

    TseSid.Dump();
}


void TestRegSec()
{

    CNtSecurityDescriptor *pSD = 0;

    int nRes = CNtSecurity::GetRegSD(HKEY_LOCAL_MACHINE,WBEM_REG_WBEM,
        DACL_SECURITY_INFORMATION, &pSD);

    printf("----------------BEGIN SECURITY KEY DUMP-------------\n");
    pSD->Dump();
    printf("----------------END SECURITY KEY DUMP-------------\n");

    if (pSD->IsValid())
        nRes = CNtSecurity::SetRegSD(HKEY_LOCAL_MACHINE, WBEM_REG_WBEM,
                    DACL_SECURITY_INFORMATION, pSD);
}

/*
void main(int argc, char **argv)
{
    BOOL bRes;

    printf("Test\n");

    if (argc < 2)
        return;

    bRes = CNtSecurity::SetPrivilege(SE_SECURITY_NAME, TRUE);

    CNtSecurity::DumpPrivileges();

    CNtSecurityDescriptor *pSD = 0;

    int nRes = CNtSecurity::GetFileSD(argv[1], DACL_SECURITY_INFORMATION, &pSD);

    if (nRes == CNtSecurity::NotFound)
    {
        printf("No such file/dir\n");
        return;
    }

    if (nRes != 0)
    {
        printf("Cannot get security descriptor. Last=%d\n", GetLastError());
    }

    pSD->Dump();


    delete pSD;
}
*/
//***************************************************************************
//
//  FIsRunningAsService
//
//  Purpose:
//  Determines if the current process is running as a service.
//
//  Returns:
//      FALSE if running interactively
//      TRUE if running as a service.
//
//***************************************************************************

/*BOOL FIsRunningAsService(VOID)
{
    HWINSTA hws = GetProcessWindowStation();
    if(hws == NULL)
        return TRUE;

    DWORD LengthNeeded;

    BOOL bService = FALSE;
    USEROBJECTFLAGS fl;
    if(GetUserObjectInformation(hws, UOI_FLAGS, &fl, sizeof(USEROBJECTFLAGS), &LengthNeeded))
        if(fl.dwFlags & WSF_VISIBLE)
            bService = FALSE;
        else
            bService = TRUE;
    CloseWindowStation(hws);
    return bService;
}*/


C9XAce::C9XAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser
        )
{
    m_wszFullName = NULL;
    if(pUser)
        m_wszFullName = Macro_CloneLPWSTR(pUser);
    m_dwAccess = Mask;
    m_iFlags = dwAceFlags;
    m_iType = AceType;
}

C9XAce::~C9XAce()
{
    if(m_wszFullName)
        delete [] m_wszFullName;
}

HRESULT C9XAce::GetFullUserName(WCHAR * pBuff, DWORD dwSize)
{
    if(pBuff && m_wszFullName)
    {
        wcsncpy(pBuff, m_wszFullName, dwSize-1);
        pBuff[dwSize-1] = 0;
        return S_OK;
    }
    return WBEM_E_FAILED;
}

HRESULT C9XAce::GetFullUserName2(WCHAR ** pBuff)
{
    if(wcslen(m_wszFullName) < 1)
        return WBEM_E_FAILED;

    int iLen = wcslen(m_wszFullName)+4;
    *pBuff = new WCHAR[iLen];
    if(*pBuff == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // there are two possible formats, the first is "UserName", and the 
    // second is "domain\username".  

    WCHAR * pSlash;
    for(pSlash = m_wszFullName; *pSlash && *pSlash != L'\\'; pSlash++); // intentional

    if(*pSlash && pSlash > m_wszFullName)
    {
        // got a domain\user, convert to domain|user
        
        wcscpy(*pBuff, m_wszFullName);
        for(pSlash = *pBuff; *pSlash; pSlash++)
            if(*pSlash == L'\\')
            {
                *pSlash = L'|';
                break;
            }
    }
    else
    {
        // got a "user", convert to ".|user"
    
        wcscpy(*pBuff, L".|");
        wcscat(*pBuff, m_wszFullName);
    }
    return S_OK;
}

//***************************************************************************
//
//  C9XAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD C9XAce::GetSerializedSize()
{
    if (m_wszFullName == 0 || wcslen(m_wszFullName) == 0)
        return 0;
    return 2 * (wcslen(m_wszFullName) + 1) + 12;
}

//***************************************************************************
//
//  C9XAce::Serialize
//
//  Serializes the ace.  The serialized version will consist of
//  <DOMAIN\USERNAME LPWSTR><FLAGS><TYPE><MASK>
//
//  Note that the fields are dwords except for the name.
//
//***************************************************************************

bool C9XAce::Serialize(BYTE * pData)
{
    wcscpy((LPWSTR)pData, m_wszFullName);
    pData += 2*(wcslen(m_wszFullName) + 1);
    DWORD * pdwData = (DWORD *)pData;
    *pdwData = m_iFlags;
    pdwData++;
    *pdwData = m_iType;
    pdwData++;
    *pdwData = m_dwAccess;
    pdwData++;
    return true;
}

//***************************************************************************
//
//  C9XAce::Deserialize
//
//  Deserializes the ace.  See the comments for Serialize for comments.
//
//***************************************************************************

bool C9XAce::Deserialize(BYTE * pData)
{
    m_wszFullName = new WCHAR[wcslen((LPWSTR)pData) + 1];
    if (!m_wszFullName)
        return false;

    wcscpy(m_wszFullName, (LPWSTR)pData);
    pData += 2*(wcslen(m_wszFullName) + 1);

    DWORD * pdwData = (DWORD *)pData;

    m_iFlags = *pdwData;
    pdwData++;
    m_iType = *pdwData;
    pdwData++;
    m_dwAccess = *pdwData;
    pdwData++;
    return true;

}

//***************************************************************************
//
//  BOOL SetObjectAccess2
//
//  DESCRIPTION:
//
//  Adds read/open and set access for the everyone group to an object.
//
//  PARAMETERS:
//
//  hObj                Object to set access on.
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//
//***************************************************************************

BOOL SetObjectAccess2(IN HANDLE hObj)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLastErr = 0;
    BOOL bRet = FALSE;

    // no point if we arnt on nt

    // figure out how much space to allocate

    DWORD dwSizeNeeded;
    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    0,           // size of buffer for security descriptor
                    &dwSizeNeeded);  // address of required size of buffer

    if(bRet == TRUE || (ERROR_INSUFFICIENT_BUFFER != GetLastError()))
        return FALSE;

    pSD = new BYTE[dwSizeNeeded];
    if(pSD == NULL)
        return FALSE;

    // Get the data

    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    dwSizeNeeded,           // size of buffer for security descriptor
                    &dwSizeNeeded ); // address of required size of buffer
    if(bRet == FALSE)
    {
        delete pSD;
        return FALSE;
    }
    
    // move it into object for

    CNtSecurityDescriptor sd(pSD,TRUE);    // Acquires ownership of the memory
    if(sd.GetStatus() != 0)
        return FALSE;
    CNtAcl acl;
    if(!sd.GetDacl(acl))
        return FALSE;

    // Create an everyone ace

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;;

    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(EVENT_MODIFY_STATE | SYNCHRONIZE, ACCESS_ALLOWED_ACE_TYPE, 0 
                                                , SidUsers);
        if(pace == NULL)
            return FALSE;
        if( pace->GetStatus() == 0)
            acl.AddAce(pace);
        delete pace;

    }

    if(acl.GetStatus() != 0)
        return FALSE;
    sd.SetDacl(&acl);
    bRet = SetKernelObjectSecurity(hObj, DACL_SECURITY_INFORMATION, sd.GetPtr());
    return TRUE;
}


//***************************************************************************
//
//  IsAdmin
//
//  returns TRUE if we are a member of the admin group or running as 
//  NETWORK_SERVICE or running as LOCAL_SERVICE
//
//***************************************************************************

BOOL IsAdmin(HANDLE hAccess)
{
    BOOL bRet = FALSE;
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid Sid(pRawSid);
        bRet = CNtSecurity::IsUserInGroup(hAccess, Sid);

        // We're done with this
        FreeSid( pRawSid );
    }
    
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Lets check for NETWORK_SERVICE and LOCAL_SERVICE since 
	// they also want full admin rights
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( !bRet )
	{
		bRet = IsNetworkService ( hAccess );
		if ( !bRet )
		{
			bRet = IsLocalService ( hAccess );
		}
	}

	return bRet;
}


//***************************************************************************
//
//  IsNetworkService
//
//  returns TRUE if we are running as NETWORK_SERVICE
//
//***************************************************************************

BOOL IsNetworkService ( HANDLE hAccess )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the NETWORK_SERVICE SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;
	BOOL bRes = FALSE;
	
    if ( AllocateAndInitializeSid(&id, 1, SECURITY_NETWORK_SERVICE_RID, 0, 0,0,0,0,0,0,&pSidSystem) )
	{
		if ( !CheckTokenMembership ( hAccess, pSidSystem, &bRes ) )
		{
			bRes = FALSE;
		}
		FreeSid ( pSidSystem );
	}

	return bRes;
}



//***************************************************************************
//
//  IsLocalService
//
//  returns TRUE if we are running as LOCAL_SERVICE
//
//***************************************************************************

BOOL IsLocalService ( HANDLE hAccess )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the NETWORK_SERVICE SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;
	BOOL bRes = FALSE;
	
    if ( AllocateAndInitializeSid(&id, 1, SECURITY_LOCAL_SERVICE_RID, 0, 0,0,0,0,0,0,&pSidSystem) )
	{
		if ( !CheckTokenMembership ( hAccess, pSidSystem, &bRes ) )
		{
			bRes = FALSE;
		}
		FreeSid ( pSidSystem );
	}

	return bRes;
}


//***************************************************************************
//
//  IsInAdminGroup
//
//  returns TRUE if we are a member of the admin group.
//
//***************************************************************************

BOOL IsInAdminGroup()
{
    HANDLE hAccessToken = INVALID_HANDLE_VALUE;
    if(S_OK != GetAccessToken(hAccessToken))
        return TRUE;       // Not having a token indicates an internal thread

    CCloseHandle cm(hAccessToken);

    DWORD dwMask = 0;

    if(IsAdmin(hAccessToken))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  HRESULT GetAccessToken
//
//  Gets the access token and sets it the the reference argument.
//
//***************************************************************************

HRESULT GetAccessToken(HANDLE &hAccessToken)
{
    // Ensures auto release of the mutex if we crash
///    CAutoSecurityMutex  autosm;

    bool bIsImpersonating = WbemIsImpersonating();

    HRESULT hRes = S_OK;
    if(bIsImpersonating == false)
        hRes = WbemCoImpersonateClient();
    if(hRes == S_OK)
    {
        BOOL bOK = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hAccessToken);
        if(bOK == FALSE)
        {
            hRes = WBEM_E_INVALID_CONTEXT;
        }
        else
            hRes = S_OK;
    }

    if(bIsImpersonating == false)
        WbemCoRevertToSelf();

    // The security mutex will auto release

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\testprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WBEM method provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "testprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IWbemProviderInit *   pInit;
    HRESULT hr;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the Initialize object.
    
    pInit=new CMethodPro();

    if (NULL==pInit)
        return E_OUTOFMEMORY;

    hr=pInit->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pInit;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\testprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WBEM Method provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "testprov.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

// {AF9BA8DF-E159-11d2-B340-00104BCC4B4A}
DEFINE_GUID(CLSID_testprov, 
0xaf9ba8df, 0xe159, 0x11d2, 0xb3, 0x40, 0x0, 0x10, 0x4b, 0xcc, 0x4b, 0x4a);
                                 
//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
            return TRUE;
    }

    ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_testprov!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WBEM Method Provider Test";
    char * pModel;
    HKEY hKey1, hKey2;

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    StringFromGUID2(CLSID_testprov, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_testprov, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\testprov\testprov.cpp ===
//***************************************************************************
//
//  TESTPROV.CPP
//
//  Module: WBEM Method provider sample code
//
//  Purpose: Defines the CMethodPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
//#define _WIN32_WINNT 0x0400

#define POLARITY 
#include <objbase.h>
#include "testprov.h"
#include <process.h>
#include <wbemidl.h>
#include <stdio.h>
#include <arrtempl.h>
#include <genutils.h>
#include <var.h>
#include <cominit.h>
bool gNT;

//***************************************************************************
//
// CMethodPro::CMethodPro
// CMethodPro::~CMethodPro
//
//***************************************************************************

CMethodPro::CMethodPro()
{
    m_InitUserName[0] = 0;
    m_pWbemSvcs = NULL;
    m_cRef = 0;
    InterlockedIncrement(&g_cObj);
    return;
   
}

CMethodPro::~CMethodPro(void)
{
    if(m_pWbemSvcs)
        m_pWbemSvcs->Release();
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CMethodPro::QueryInterface
// CMethodPro::AddRef
// CMethodPro::Release
//
// Purpose: IUnknown members for CMethodPro object.
//***************************************************************************


STDMETHODIMP CMethodPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IWbemServices == riid || IID_IWbemProviderInit==riid)
       if(riid== IID_IWbemServices){
          *ppv=(IWbemServices*)this;
       }

       if(IID_IUnknown==riid || riid== IID_IWbemProviderInit){
          *ppv=(IWbemProviderInit*)this;
       }
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMethodPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMethodPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*CMethodPro::Initialize                                                *
*                                                                      *
*Purpose: This is the implementation of IWbemProviderInit. The method  *
* is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/
STDMETHODIMP CMethodPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{

   
   m_pWbemSvcs=pNamespace;
   m_pWbemSvcs->AddRef();
   if(pszUser)
       wcscpy(m_InitUserName, pszUser);
   
    //Let CIMOM know your initialized
    //===============================
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    gNT = IsNT() == TRUE;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  SetStatusAndReturnOK
//
//  If there is an error, it dumps an error message.  It also sets the status 
//
//***************************************************************************

HRESULT SetStatusAndReturnOK(SCODE sc, IWbemObjectSink* pSink, char * pMsg)
{
    pSink->SetStatus(0,sc, NULL, NULL);
    return S_OK;
}

SCODE GetUserName(IWbemClassObject * pOutParams, WCHAR * pInitUserName)
{
    CVar varName;
    varName.SetBSTR(pInitUserName);
    SCODE sc = pOutParams->Put(L"sInitialUser", 0, (VARIANT *)&varName, 0);
    if(gNT)
    {
        WCHAR user[MAX_PATH];
        DWORD dwLen = MAX_PATH;
        CoImpersonateClient();
        GetUserNameW(user, &dwLen);
        CoRevertToSelf();
        varName.SetBSTR(user);
    }
    else
        varName.SetBSTR(L"<n/a>");
    sc = pOutParams->Put(L"sImpersonateUser", 0, (VARIANT *)&varName, 0);
    return sc;
}

SCODE SetProperty(IWbemClassObject * pOutParams, WCHAR * pPropName, DWORD dwValue)
{
    VARIANT var;
    var.vt = VT_I4;
    var.lVal = dwValue;
    SCODE sc = pOutParams->Put(pPropName, 0, &var, 0);
    return sc;
}

DWORD GetAccessViaMethod(IWbemContext* pCtx, IWbemServices * pToTest)
{
    DWORD dwRet = -1;
    IWbemClassObject * pOut = NULL;
    SCODE sc = pToTest->ExecMethod(L"__systemsecurity", L"GetCallerAccessRights", 0,
                        pCtx, NULL, &pOut, NULL);
    if(sc == 0)
    {
        VARIANT var;
        VariantInit(&var);
        sc = pOut->Get(L"rights", 0, &var, NULL, NULL);
        if(sc == 0 && var.vt == VT_I4)
            dwRet = var.lVal;
        pOut->Release();
    }
    return dwRet;
}

DWORD NtSACLCheck(IWbemContext* pCtx, IWbemServices * pToTest)
{
    DWORD dwRet = 0;
    IWbemClassObject * pOut = NULL;
    SCODE sc = pToTest->ExecMethod(L"__systemsecurity", L"GetSD", 0,
                        pCtx, NULL, &pOut, NULL);
    if(sc == 0)
    {
        dwRet = 0x20000;
        sc = pToTest->ExecMethod(L"__systemsecurity", L"SetSD", 0,
                        pCtx, pOut, NULL, NULL);
        if(sc == 0)
            dwRet = 0x60000;
        pOut->Release();
    }
    
    return dwRet;
}

DWORD Win9XSACLCheck(IWbemContext* pCtx, IWbemServices * pToTest)
{
    DWORD dwRet = 0;
    IWbemClassObject * pOut = NULL;
    SCODE sc = pToTest->ExecMethod(L"__systemsecurity", L"Get9XUserList", 0,
                        pCtx, NULL, &pOut, NULL);
    if(sc == 0)
    {
        dwRet = 0x20000;
        sc = pToTest->ExecMethod(L"__systemsecurity", L"Set9XUserList", 0,
                        pCtx, pOut, NULL, NULL);
        if(sc == 0)
            dwRet = 0x60000;
        pOut->Release();
    }
    
    return dwRet;
}

DWORD GetAccessViaTest(IWbemContext* pCtx, IWbemServices * pToTest)
{
    DWORD dwRet;        // Lets assume that we are enabled.

    // try a class write

    IWbemClassObject * pClass = NULL;

    SCODE sc = pToTest->GetObject(NULL, 0, pCtx, &pClass, NULL);
    if(sc == S_OK)
    {
        dwRet = 1;      // must be enabled!

        VARIANT varName;
        varName.vt = VT_BSTR;
        varName.bstrVal = SysAllocString(L"SecTempTest");
        sc = pClass->Put(L"__class" , 0, &varName, 0);
        sc = pToTest->PutClass(pClass, 0, pCtx, NULL);
        if(sc == 0)
        {
            dwRet |= 4;
        }
        VariantClear(&varName);
        pClass->Release();
    }

    // Try to create an instance of a generic class.  It is the testers job
    // to make sure it exists before running the test.

    pClass = NULL;
    sc = pToTest->GetObject(L"TestProvStatic", 0, pCtx, &pClass, NULL);
    if(sc == S_OK)
    {
        IWbemClassObject * pInst = NULL;
        sc = pClass->SpawnInstance(0, &pInst);
        if(sc == 0)
        {
            VARIANT varKey;
            varKey.vt = VT_I4;
            varKey.lVal = 23;
            sc = pInst->Put(L"MYkey" , 0, &varKey, 0);
            sc = pToTest->PutInstance(pInst, 0, pCtx, NULL);
            if(sc == 0)
            {
                dwRet |= 8;
            }
            pInst->Release();
        }
        pClass->Release();
    }

    // Try a provider write.

    pClass = NULL;
    sc = pToTest->GetObject(L"TestProvDynamic", 0, pCtx, &pClass, NULL);
    if(sc == S_OK)
    {
        IWbemClassObject * pInst = NULL;
        sc = pClass->SpawnInstance(0, &pInst);
        if(sc == 0)
        {
            VARIANT varKey;
            varKey.vt = VT_BSTR;
            varKey.bstrVal = SysAllocString(L"a");
            sc = pInst->Put(L"mykey" , 0, &varKey, 0);
            sc = pToTest->PutInstance(pInst, 0, pCtx, NULL);
            VariantClear(&varKey);
            if(sc == 0)
            {
                dwRet |= 0x10;
            }
            pInst->Release();
        }
        pClass->Release();
    }

    // Try a method

    sc = pToTest->ExecMethod(L"testprov", L"DoNothing", 0,
                        pCtx, NULL, NULL, NULL);

    if(sc == 0)
        dwRet |= 2;

    if(gNT)
        dwRet |= NtSACLCheck(pCtx, pToTest);        
    else
        dwRet |= Win9XSACLCheck(pCtx, pToTest); 
    return dwRet;
}

//***************************************************************************
//
//  This needs to check access different ways.
//  1) impersonating and using the access check (NT only)
//  2) impersonation and actually trying to access (NT only)
//  3) not impersonating and using the access check
//  4) not impersonating and actually trying to access
//
//***************************************************************************

SCODE DoAccessChecks(IWbemContext* pCtx, IWbemServices * pToTest, IWbemClassObject * pOutParams)
{
    DWORD dwAccess;
    if(gNT)
    {
        CoImpersonateClient();
        dwAccess = GetAccessViaMethod(pCtx, pToTest);
        SetProperty(pOutParams, L"dwImpCheckedAccess", dwAccess);
        dwAccess = GetAccessViaTest(pCtx, pToTest);
        SetProperty(pOutParams, L"dwImpTestedAccess", dwAccess);
        CoRevertToSelf();
    }

    dwAccess = GetAccessViaMethod(pCtx, pToTest);
    SetProperty(pOutParams, L"dwNonImpCheckedAccess", dwAccess);
    dwAccess = GetAccessViaTest(pCtx, pToTest);
    SetProperty(pOutParams, L"dwNonImpTestedAccess", dwAccess);
 
    return S_OK;
}

SCODE CMethodPro::GetPointer(ConnType ct, ImpType it, LPWSTR name, IWbemServices ** ppServ)
{
    if(!gNT && it == IMP)
        return WBEM_E_METHOD_DISABLED;

    SCODE sc = S_OK;
    if(it == IMP)
        CoImpersonateClient();

    IWbemLocator *pLocator=NULL;
    sc = CoCreateInstance ((ct == UNAUTH) ? CLSID_WbemUnauthenticatedLocator :
                                    CLSID_WbemAuthenticatedLocator,
							NULL, CLSCTX_INPROC_SERVER,
							IID_IWbemLocator, (void **) &pLocator);
    if(sc == 0)
    {
	    sc =  pLocator->ConnectServer (name, m_InitUserName, 
						    NULL, NULL, 0, NULL, NULL, ppServ);
        pLocator->Release();
    }
    
    if(it == IMP)
        CoRevertToSelf();
    
    return sc;
}

/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named Echo.  It   * 
*         takes an input string, copies it to the output and returns the* 
*         length.  The mof definition is                                *
*                                                                       *
*    [dynamic: ToInstance, provider("TestProv")]class MethProvSamp      *
*    {                                                                  *
*         [implemented, static]                                         *
*            uint32 Echo([IN]string sInArg="default",                   *
*                [out] string sOutArg);                                 *
*    };                                                                 *
*                                                                       *
************************************************************************/

STDMETHODIMP CMethodPro::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink)
{
    SCODE sc;    

    // Do some parameter checking

    if(pSink == NULL || MethodName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
 
    // handle the simple case of the DoNothing method which is used for loop backs

    if(!_wcsicmp(MethodName, L"DoNothing"))
    {
        return SetStatusAndReturnOK(S_OK, pSink, "");
    }

    // Get the class object

    sc = m_pWbemSvcs->GetObject(L"TestProv", 0, pCtx, &pClass, NULL);
    if(sc != S_OK || pClass == NULL)
        return SetStatusAndReturnOK(sc, pSink, "getting the class object");

    // All the methods return data, so create an instance of the
    // output argument class.

    sc = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
    pClass->Release();
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "getting the method");

    sc = pOutClass->SpawnInstance(0, &pOutParams);
    pOutClass->Release();
    if(sc != S_OK || pOutParams == NULL)
        return SetStatusAndReturnOK(sc, pSink, "spawning an instance of the output class");
    
    CReleaseMe rm(pOutParams);
    
    IWbemServices * pToTest = NULL;
    
    // Most of the methods take a namespace argument

    VARIANT varName;
    VariantInit(&varName);
    if(!_wcsicmp(MethodName, L"GetUserName") || 
       !_wcsicmp(MethodName, L"GetRightsOnInitialPtr"))
    {
    }
    else
    {
        if(pInParams == NULL)
            return WBEM_E_INVALID_PARAMETER;
        sc = pInParams->Get(L"Name", 0, &varName, NULL, NULL);
        if(sc == 0)
            if(varName.vt != VT_BSTR  || varName.bstrVal == 0)
                sc = WBEM_E_INVALID_PARAMETER;
    }    
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "Getting the name property");
       

    // Depending on the actual method, call the appropritate routine

    if(!_wcsicmp(MethodName, L"GetUserName"))
    {
        sc = GetUserName(pOutParams, m_InitUserName);
    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnInitialPtr"))
    {
        pToTest = m_pWbemSvcs;
        pToTest->AddRef();
        sc = DoAccessChecks(pCtx, pToTest, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnImpOpenNamespacePtr"))
    {
        if(!gNT)
            sc = WBEM_E_METHOD_DISABLED;
        else
        {
            CoImpersonateClient();
            sc = m_pWbemSvcs->OpenNamespace(varName.bstrVal, 0, pCtx, &pToTest, NULL);
            CoRevertToSelf();
            if(sc == S_OK)
                sc = DoAccessChecks(pCtx, pToTest, pOutParams);
        }

    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnNonImpOpenNamespacePtr"))
    {
        sc = m_pWbemSvcs->OpenNamespace(varName.bstrVal, 0, pCtx, &pToTest, NULL);
        if(sc == S_OK)
            sc = DoAccessChecks(pCtx, pToTest, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnImpUnauthenicatedPtr"))
    {
        sc = GetPointer(UNAUTH, IMP, varName.bstrVal, &pToTest);
        if(sc == S_OK)
            sc = DoAccessChecks(pCtx, pToTest, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnNonImpUnauthenicatedPtr"))
    {
        sc = GetPointer(UNAUTH, NONIMP, varName.bstrVal, &pToTest);
        if(sc == S_OK)
            sc = DoAccessChecks(pCtx, pToTest, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnImpAuthenicatedPtr"))
    {
        sc = GetPointer(AUTH, IMP, varName.bstrVal, &pToTest);
        if(sc == S_OK)
            sc = DoAccessChecks(pCtx, pToTest, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"GetRightsOnNonImpAuthenicatedPtr"))
    {
        sc = GetPointer(AUTH, NONIMP, varName.bstrVal, &pToTest);
        if(sc == S_OK)
            sc = DoAccessChecks(pCtx, pToTest, pOutParams);
    }
    else
    {
        return SetStatusAndReturnOK(WBEM_E_INVALID_PARAMETER, pSink, "Invalid method name");
    }

    if(pToTest)
        pToTest->Release();
    VariantClear(&varName);

    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "calling method");

    // Set the return code

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = 0;    // special name for return value.
    sc = pOutParams->Put(L"ReturnValue" , 0, &var, 0); 
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "setting the ReturnCode property");

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    sc = pSink->Indicate(1, &pOutParams);    

    // all done now, set the status
    sc = pSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);

    return WBEM_S_NO_ERROR;
}

SCODE CMethodPro::PutInstanceAsync( IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pHandler)
{
    pHandler->SetStatus(0,0,NULL, NULL);

    return 0;
}

SCODE CMethodPro::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    pHandler->SetStatus(0,0,NULL, NULL);

    return 0;
}


SCODE CMethodPro::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    pHandler->SetStatus(0,WBEM_E_NOT_FOUND, NULL, NULL);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\cfdyn.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CFDYN.CPP

Abstract:

	Defines the virtual base class for the Dynamic Provider
	class factory objects.  This code was largly pilfered from
	the Brockschmidt samples.  The class is always overriden
	so that each provider type (DDE, registry, etc.) will have
	its own class factory.

History:

	a-davj  27-Sep-95   Created.

--*/

#include "precomp.h"
#include "cfdyn.h"

 
//***************************************************************************
// CCFDyn::CCFDyn
// CCFDyn::~CCFDyn
//
// DESCRIPTION:
//
// Constructor and destructor.
//
//***************************************************************************

CCFDyn::CCFDyn(void)
{
    InterlockedIncrement(&lObj); 
    m_cRef=0L;
    return;
}

CCFDyn::~CCFDyn(void)
{
    InterlockedDecrement(&lObj); 
    return;
}

//***************************************************************************
// HRESULT CCFDyn::QueryInterface
// long CCFDyn::AddRef
// long CCFDyn::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CCFDyn::QueryInterface(
    IN REFIID riid,
    OUT PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CCFDyn::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CCFDyn::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);

    if (0L!=lRet)
        return lRet;

    delete this;
    return 0L;
}


//***************************************************************************
// HRESULT CCFDyn::CreateInstance
//
//  DESCRIPTION:
//
//  Instantiates a provider object returning an interface pointer.  Note
//  that the CreateImpObj routine is always overriden in order
//  to create a particular type of provider.
//
//  PARAMETERS:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
//  RETURN VALUE:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CCFDyn::CreateInstance(
    IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj)
{
    IUnknown *     pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    //Verify that a controlling unknown asks for IUnknown

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.

    pObj = CreateImpObj(); 

    if (NULL==pObj)
        return hr;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    else
        InterlockedIncrement(&lObj);  // dec takes place in the objects destructor

    return hr;
}

//***************************************************************************
// HRESULT CCFDyn::LockServer
//
// DESCRIPTION:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// PARAMETERS:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// RETURN VALUE:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CCFDyn::LockServer(
    IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&lLock);
    else
        InterlockedDecrement(&lLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\autoprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    AUTOPROV.H

Abstract:

    Defines the guids for automation provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _autoprov_H_
#define _autoprov_H_

DEFINE_GUID(LIBID_autoprov,0xDAC651D0L,0x7CC7,0x11CF,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

DEFINE_GUID(CLSID_AutoProvider,0xDAC651D1L,0x7CC7,0x11CF,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

// {72967902-68EC-11d0-B729-00AA0062CBB7}
DEFINE_GUID(CLSID_AutoPropProv, 
0x72967902, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);

#ifdef __cplusplus
class AutoProvider;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\security\testprov\testprov.h ===
//***************************************************************************
//
//  testprov.h
//
//  Module: WBEM Method Test Provider code
//
//  Purpose: Method Provider Test Header File.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _testprov_H_
#define _testprov_H_

#include "wbemidl.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CMethodPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pWbemSvcs;
        WCHAR m_InitUserName[MAX_PATH];
     public:
        CMethodPro();
        ~CMethodPro(void);

        enum ConnType {AUTH, UNAUTH};
        enum ImpType { IMP, NONIMP};

        SCODE GetPointer(ConnType ct, ImpType it, LPWSTR name, IWbemServices ** ppServ);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};


        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        // Supported !!!!

        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**){return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

       
};

typedef CMethodPro *PCMethodPro;

// This class is the class factory for CMethodPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\cfdyn.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CFDYN.H

Abstract:

	Declares the the CCFDyn Class.

History:

	a-davj  27-Sep-95   Created.

--*/

#ifndef _CCFDYN_H_
#define _CCFDYN_H_

//Get the object definitions

#include "impdyn.h"


//***************************************************************************
//
//  CLASS NAME:
//
//  CCFDyn
//
//  DESCRIPTION:
//
//  This is the generic class factory.  It is always overridden so as to 
//  create a specific type of provider, such as a registry provider.
//
//***************************************************************************

class CCFDyn : public IClassFactory
    {
    protected:
        long           m_cRef;

    public:
        CCFDyn(void);
        ~CCFDyn(void);

        virtual IUnknown * CreateImpObj() = 0;

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CCFDyn *PCCFDyn;

#endif //_CCFDYN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\counters.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    COUNTERS.CPP

Abstract:

	Has the routines needed to message the counter data.  Note that
	this code was almost completly pilfered from the perfmon sample
	code done by Robert Watson and this ensures that the answers
	match what perfmon would give.

History:

	a-davj  12-20-95   v0.01.

--*/

#include "precomp.h"

#include <winperf.h>
#include "perfcach.h"      // Exported declarations for this file

#define INVERT             PERF_COUNTER_TIMER_INV
#define NS100_INVERT       PERF_100NSEC_TIMER_INV
#define NS100              PERF_100NSEC_TIMER
#define TIMER_MULTI        PERF_COUNTER_MULTI_TIMER
#define TIMER_MULTI_INVERT PERF_COUNTER_MULTI_TIMER_INV
#define NS100_MULTI        PERF_100NSEC_MULTI_TIMER
#define NS100_MULTI_INVERT PERF_100NSEC_MULTI_TIMER_INV


#define FRACTION 1
#define BULK     1

#define TOO_BIG   (FLOAT)1500000000
#pragma optimize("", off)

//***************************************************************************
//  FLOAT eGetTimeInterval
//
//  DESCRIPTION:
//  
//  Get the difference between the current and previous time counts,
//  then divide by the frequency.
//      
//  PARAMETERS:
//  
//  pCurrentTime    current time in ticks.
//  pPreviousTime   previous time in ticks.
//  pliFreq         # of  counts (clock ticks) per second
//  
//  RETURN VALUE:
//  
//  Floating point representation of Time Interval (seconds), 0.0 if error
//***************************************************************************

FLOAT eGetTimeInterval(
    IN LONGLONG *pliCurrentTime, 
    IN LONGLONG *pliPreviousTime,
    IN LONGLONG *pliFreq)

{
    FLOAT   eTimeDifference;
    FLOAT   eFreq;
    FLOAT   eTimeInterval ;

    LONGLONG liDifference;

    // Get the number of counts that have occured since the last sample

    liDifference = *pliCurrentTime - *pliPreviousTime;

    if (liDifference <= (LONGLONG)0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        eTimeDifference = (FLOAT)liDifference;

        // Get the counts per second

        eFreq = (FLOAT)(*pliFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Get the time since the last sample.

        eTimeInterval = eTimeDifference / eFreq ;

        return (eTimeInterval) ;
    }
} // eGetTimeInterval

//***************************************************************************
//  FLOAT Counter_Counter_Common
//  
//  DESCRIPTION:
//  
//  Take the difference between the current and previous counts
//  then divide by the time interval
//      
//  PARAMETERS:
//  
//  pLineStruct Line structure containing data to perform computations on
//  
//  iType       Counter Type
//          
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Counter_Common(
        IN PLINESTRUCT pLineStruct,
        IN INT iType)
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eCount ;
    BOOL    bValueDrop = FALSE ;

    LONGLONG   liDifference;

    if (iType != BULK) 
    {

        // check if it is too big to be a wrap-around case
        if (pLineStruct->lnaCounterValue[0] <
            pLineStruct->lnaOldCounterValue[0])
           {
           if (pLineStruct->lnaCounterValue[0] -
               pLineStruct->lnaOldCounterValue[0] > (DWORD)0x00ffff0000)
              {
              return (FLOAT) 0.0f;
              }
           bValueDrop = TRUE ;
           }

        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];

        liDifference &= (DWORD)(0x0ffffffff);

    } 
    else 
    {
        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];
    }
    
    if (liDifference <= (LONGLONG) 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                        &pLineStruct->lnOldTime,
                                        &pLineStruct->lnPerfFreq) ;
        if (eTimeInterval <= 0.0f) 
        {
            return (FLOAT) 0.0f;
        } 
        else 
        {
            eDifference = (FLOAT)(liDifference);

            eCount         = eDifference / eTimeInterval ;
            
            if (bValueDrop && eCount > (FLOAT) TOO_BIG) 
            {
                // ignore this bogus data since it is too big for 
                // the wrap-around case
                eCount = (FLOAT) 0.0f ;
            }
            return(eCount) ;
        }
    }
} // Counter_Counter_Common


//***************************************************************************
//  FLOAT Counter_Queuelen
//  
//  DESCRIPTION:
//  
//  Calculates queue lengths.
//      
//  PARAMETERS:
//  
//  pLineStruct Line structure containing data to perform computations on
//  
//  bLarge      TRUE if type LARGE
//          
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Queuelen(IN PLINESTRUCT pLineStruct, IN BOOL bLarge, IN BOOL b100NS)
{

    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eCount ;
    BOOL    bValueDrop = FALSE ;

    LONGLONG   liDifference;

    if (!bLarge) 
    {

        // check if it is too big to be a wrap-around case
        if (pLineStruct->lnaCounterValue[0] <
            pLineStruct->lnaOldCounterValue[0])
           {
           if (pLineStruct->lnaCounterValue[0] -
               pLineStruct->lnaOldCounterValue[0] > (DWORD)0x00ffff0000)
              {
              return (FLOAT) 0.0f;
              }
           bValueDrop = TRUE ;
           }

        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];

        liDifference &= (DWORD)(0x0ffffffff);

    } 
    else 
    {
        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];
    }
    
    if (liDifference <= (LONGLONG) 0) 
    {
        return (FLOAT) 0.0f;
    } 

    eDifference = (float)liDifference;

    if(b100NS)
        eTimeInterval = pLineStruct->lnNewTime100Ns - pLineStruct->lnOldTime100Ns;
    else
        eTimeInterval = pLineStruct->lnNewTime - pLineStruct->lnOldTime;
                                        
    if (eTimeInterval <= 0.0f) 
    {
        return (FLOAT) 0.0f;
    } 
 
    eCount = eDifference / eTimeInterval ;
    return(eCount) ;
}

//***************************************************************************
//  FLOAT Counter_Average_Timer
//  
//  DESCRIPTION:
//  
//  Take the differences between the current and previous times and counts
//  divide the time interval by the counts multiply by 10,000,000 (convert
//  from 100 nsec to sec)
//      
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Average_Timer(
        IN PLINESTRUCT pLineStruct)
{
    FLOAT   eTimeInterval;
    FLOAT   eCount;

    LONGLONG    liDifference;

    // Get the current and previous counts.

    liDifference = (DWORD)pLineStruct->lnaCounterValue[1] - 
            (DWORD)pLineStruct->lnaOldCounterValue[1];

    if ( liDifference <= 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        // Get the amount of time that has passed since the last sample
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnaCounterValue[0],
                                            &pLineStruct->lnaOldCounterValue[0],
                                            &pLineStruct->lnPerfFreq) ;

        if (eTimeInterval < 0.0f) 
        { // return 0 if negative time has passed
            return (0.0f);
        } 
        else 
        {
            // Get the number of counts in this time interval.
            eCount = eTimeInterval / ((FLOAT)liDifference);
            return(eCount) ;
        }
    }
} //Counter_Average_Timer

//***************************************************************************
//  FLOAT Counter_Average_Bulk
//  
//  DESCRIPTION:
//  
//  Take the differences between the current and previous byte counts and
//  operation counts divide the bulk count by the operation counts
//      
//  PARAMETERS:
//  
//  pLineStruct Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Average_Bulk(
        IN PLINESTRUCT pLineStruct)
{
    FLOAT   eBulkDelta;
    FLOAT   eDifference;
    FLOAT   eCount;

    LONGLONG liDifference;
    LONGLONG liBulkDelta;

    // Get the bulk count increment since the last sample

    liBulkDelta = pLineStruct->lnaCounterValue[0] -
            pLineStruct->lnaOldCounterValue[0];

    if (liBulkDelta <= (LONGLONG) 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        // Get the current and previous counts.
        liDifference = (DWORD)pLineStruct->lnaCounterValue[1] -
                (DWORD) pLineStruct->lnaOldCounterValue[1];
        liDifference &= (DWORD) (0x0ffffffff);

        // Get the number of counts in this time interval.

        if ( liDifference <= (LONGLONG) 0) 
        {
            // Counter value invalid
            return (FLOAT) 0.0f;
        } 
        else 
        {
            eBulkDelta = (FLOAT) (liBulkDelta);
            eDifference = (FLOAT) (liDifference);
            eCount = eBulkDelta / eDifference ;

            // Scale the value to up to 1 second

            return(eCount) ;
        }
    }
} // Counter_Average_Bulk

//***************************************************************************
//  FLOAT Counter_Timer_Common
//  
//  DESCRIPTION:
//  
//  Take the difference between the current and previous counts,
//  Normalize the count (counts per interval)
//  divide by the time interval (count = % of interval)
//  if (invert)
//        subtract from 1 (the normalized size of an interval)
//  multiply by 100 (convert to a percentage)
//  this value from 100.
//      
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  iType           Counter Type
//  
//  RETURN VALUE:
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Timer_Common(
        IN  PLINESTRUCT pLineStruct,
        IN  INT iType)
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eFreq;
    FLOAT   eFraction;
    FLOAT   eMultiBase;
    FLOAT   eCount ;

    LONGLONG   liTimeInterval;
    LONGLONG   liDifference;

    // Get the amount of time that has passed since the last sample

    if (iType == NS100 ||
        iType == NS100_INVERT ||
        iType == NS100_MULTI ||
        iType == NS100_MULTI_INVERT) 
    {
        liTimeInterval = pLineStruct->lnNewTime100Ns -
                pLineStruct->lnOldTime100Ns ;
        eTimeInterval = (FLOAT) (liTimeInterval);
    } 
    else 
    {
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                            &pLineStruct->lnOldTime,
                                            &pLineStruct->lnPerfFreq) ;
    }

    if (eTimeInterval <= 0.0f)
       return (FLOAT) 0.0f;

    // Get the current and previous counts.

    liDifference = pLineStruct->lnaCounterValue[0] -
            pLineStruct->lnaOldCounterValue[0] ;

    // Get the number of counts in this time interval.
    // (1, 2, 3 or any number of seconds could have gone by since
    // the last sample)

    eDifference = (FLOAT) (liDifference) ;

    if (iType == 0 || iType == INVERT)
    {
        // Get the counts per interval (second)

        eFreq = (FLOAT) (pLineStruct->lnPerfFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Calculate the fraction of the counts that are used by whatever
        // we are measuring

        eFraction = eDifference / eFreq ;
    }
    else
    {
        eFraction = eDifference ;
    }

    // Calculate the fraction of time used by what were measuring.

    eCount = eFraction / eTimeInterval ;

     // If this is  an inverted count take care of the inversion.

    if (iType == INVERT || iType == NS100_INVERT)
        eCount = (FLOAT) 1.0 - eCount ;

    // Do extra calculation for multi timers.

    if(iType == TIMER_MULTI || iType == NS100_MULTI ||
       iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT) 
    {

        eMultiBase = (float)pLineStruct->lnaCounterValue[1];
        if(eMultiBase == 0.0)
            return 0.0f;

        if (iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT)
            eCount = eMultiBase - eCount;
        eCount /= eMultiBase;
    }

    // Scale the value to up to 100.

    eCount *= 100.0f ;

    if (eCount < 0.0f) eCount = 0.0f ;

    if (eCount > 100.0f &&
        iType != NS100_MULTI &&
        iType != NS100_MULTI_INVERT &&
        iType != TIMER_MULTI &&
        iType != TIMER_MULTI_INVERT) 
    {
        eCount = 100.0f;
    }

    return(eCount) ;
} // Counter_Timer_Common

//***************************************************************************
//  FLOAT Counter_Raw_Fraction
//  
//  DESCRIPTION:
//  
//  Evaluate a raw fraction (no time, just two values: Numerator and
//  Denominator) and multiply by 100 (to make a percentage;
//  
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Raw_Fraction(
        IN PLINESTRUCT pLineStruct)
{
    FLOAT   eCount ;

    LONGLONG   liNumerator;

    if ( pLineStruct->lnaCounterValue[0] == 0 ||
            pLineStruct->lnaCounterValue[1] == 0 ) 
    {
        // invalid value
        return (0.0f);
    } 
    else 
    {
        liNumerator = pLineStruct->lnaCounterValue[0] * 100;
        eCount = ((FLOAT) (liNumerator))  /
                 ((FLOAT) pLineStruct->lnaCounterValue[1]);
        return(eCount) ;
    }
} // Counter_Raw_Fraction

//***************************************************************************
//  FLOAT eElapsedTime
//  
//  DESCRIPTION:
//  
//  Converts 100NS elapsed time to fractional seconds
//  
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  iType           Unused.
//  
//  RETURN VALUE:
//  
//  Floating point representation of elapsed time in seconds, 0.0 if error
//***************************************************************************

FLOAT eElapsedTime(
        IN PLINESTRUCT pLineStruct,
        IN INT iType)
{
    FLOAT   eSeconds ;

    LONGLONG   liDifference;

    if (pLineStruct->lnaCounterValue[0] <= (LONGLONG) 0) 
    {
        // no data [start time = 0] so return 0
        return (FLOAT) 0.0f;
    } 
    else 
    {
        LONGLONG PerfFreq;
       
        PerfFreq = *(LONGLONG UNALIGNED *)(&pLineStruct->ObjPerfFreq) ;

        // otherwise compute difference between current time and start time
        liDifference = 
            pLineStruct->ObjCounterTimeNew - pLineStruct->lnaCounterValue[0];

        if (liDifference <= (LONGLONG) 0 ||
            PerfFreq <= 0) 
        {
            return (FLOAT) 0.0f;
        } 
        else 
        {
            // convert to fractional seconds using object counter
            eSeconds = ((FLOAT) (liDifference)) /
                ((FLOAT) (PerfFreq));

            return (eSeconds);
        }
    }
    
} // eElapsedTime

//***************************************************************************
//  FLOAT Sample_Common
//  
//  DESCRIPTION:
//  
//  Divides "Top" differenced by Base Difference
//  
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  iType           Counter Type
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Sample_Common(
        IN PLINESTRUCT pLineStruct,
        IN INT iType)
{
    FLOAT   eCount ;

    LONG    lDifference;
    LONG    lBaseDifference;

    lDifference = (DWORD)pLineStruct->lnaCounterValue[0] -
        (DWORD)pLineStruct->lnaOldCounterValue[0] ;
    lDifference &= (DWORD) (0x0ffffffff);

    if (lDifference <= 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        lBaseDifference = (DWORD)pLineStruct->lnaCounterValue[1] -
            (DWORD)pLineStruct->lnaOldCounterValue[1] ;

        if ( lBaseDifference <= 0 ) 
        {
            // invalid value
            return (0.0f);
        } 
        else 
        {
            eCount = ((FLOAT)lDifference) / ((FLOAT)lBaseDifference) ;

            if (iType == FRACTION) 
            {
                eCount *= (FLOAT) 100.0f ;
            }
            return(eCount) ;
        }
    }
} // Sample_Common

//***************************************************************************
//
//  FLOAT Counter_Delta
// 
//  DESCRIPTION:
//  
//  Take the difference between the current and previous counts,
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  bLargeData      true if data is large
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Delta(PLINESTRUCT pLineStruct, BOOL bLargeData)
{
    FLOAT   eDifference;
    LONGLONG    llDifference;
    ULONGLONG   ullThisValue, ullPrevValue;

    // Get the current and previous counts.

    if (!bLargeData) {
        // then clear the high part of the word
        ullThisValue = (ULONGLONG)pLineStruct->lnaCounterValue[0];
        ullPrevValue = (ULONGLONG)pLineStruct->lnaOldCounterValue[0];
    } else {
        ullThisValue = (ULONGLONG)pLineStruct->lnaCounterValue[0];
        ullPrevValue = (ULONGLONG)pLineStruct->lnaOldCounterValue[0];
    }

    if (ullThisValue > ullPrevValue) {
        llDifference = (LONGLONG)(ullThisValue - ullPrevValue);
        eDifference = (FLOAT)llDifference;
    } else {
        // the new value is smaller than or equal to the old value
        // and negative numbers are not allowed.
        eDifference = 0.0f;
    }

    return(eDifference) ;

}

//***************************************************************************
//  FLOAT GenericConv
//  
//  DESCRIPTION:
//  
//  This handles the data types which the perf monitor doesnt currently
//  handle and does so by simply using the "formulas" indicated by the
//  bit fields in the counter's type.
//  
//  PARAMETERS:
//  
//  pLine       Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome
//***************************************************************************

FLOAT GenericConv(
        IN PLINESTRUCT pLine)
{
    FLOAT fRet = 0.0f;  // default if nothing makes sense

    // extract the various bit fields as defined in winperf.h

    DWORD PerfType = pLine->lnCounterType & 0x00000c00;
    DWORD SubType = pLine->lnCounterType &  0x000f0000;
    DWORD CalcMod = pLine->lnCounterType &  0x0fc00000;
    DWORD TimerType=pLine->lnCounterType &  0x00300000;
    DWORD Display = pLine->lnCounterType &  0xf0000000;
    DWORD dwSize =  pLine->lnCounterType &  0x00000300;

    if(PerfType == PERF_TYPE_NUMBER) 
    {
        
        // For simple number the calculation is fairly simple and only
        // involves a possible division by 1000

        fRet = (FLOAT)pLine->lnaCounterValue[0];
        if(SubType == PERF_NUMBER_DEC_1000)
            fRet /= 1000.0f;
        }
    else if(PerfType == PERF_TYPE_COUNTER) 
    {
        FLOAT eTimeDelta;
        FLOAT eDataDelta;
        FLOAT eBaseDelta;
        if(SubType == PERF_COUNTER_RATE || SubType ==PERF_COUNTER_QUEUELEN) 
        {

             // Need the delta time.  The data used for time delta is 
             // indicated by a subfield.

             if(TimerType == PERF_TIMER_TICK)
                 eTimeDelta = (((float)pLine->lnNewTime) - pLine->lnOldTime)/
                                    ((float)pLine->lnPerfFreq);
             else if(TimerType == PERF_TIMER_100NS)
                 eTimeDelta = ((float)pLine->lnNewTime100Ns) - pLine->lnOldTime100Ns;
             else
                 eTimeDelta = ((float)pLine->ObjCounterTimeNew -
                    pLine->ObjCounterTimeOld) / ((float)pLine->ObjPerfFreq);
             if(eTimeDelta == 0.0f)   // shouldnt happen, but delta can end
                    return 0.0f;    // up as a denominator.
        }
        if(SubType == PERF_COUNTER_FRACTION) 
        {

             // The base value is going to be used as the denominator.

             if(CalcMod & PERF_DELTA_BASE)
                eBaseDelta = (float)pLine->lnaCounterValue[1] - 
                                    pLine->lnaOldCounterValue[1];
            else
                eBaseDelta = (float)pLine->lnaCounterValue[1];
             if(eBaseDelta == 0.0f)   // shouldnt happen, but delta can end
                    return 0.0f;    // up as a denominator.
        }


        // Get the deta data value.

        if(CalcMod & PERF_DELTA_COUNTER)
            eDataDelta = (FLOAT)(pLine->lnaCounterValue[0] -
                    pLine->lnaOldCounterValue[0]);
        else
            eDataDelta = (FLOAT)pLine->lnaCounterValue[0];

        // Apply the appropriate formula

        switch(SubType) 
        {
             case PERF_COUNTER_VALUE:
                 fRet = eDataDelta;
                 break;
             case PERF_COUNTER_RATE:
                 fRet = eDataDelta / eTimeDelta;
                 break;
             case PERF_COUNTER_FRACTION:
                 fRet = ((FLOAT)eDataDelta)/eBaseDelta;
                 break;
             case PERF_COUNTER_ELAPSED:
                 if(TimerType == PERF_OBJECT_TIMER)
                    fRet = ((float)pLine->ObjCounterTimeNew - pLine->lnaCounterValue[0]) /
                                ((float)pLine->ObjPerfFreq);
                 else if(TimerType == PERF_TIMER_TICK)
                    fRet = ((float)pLine->lnNewTime - pLine->lnaCounterValue[0]) /
                                ((float)pLine->lnPerfFreq);
                 else 
                    fRet = (((float)pLine->lnNewTime100Ns) - pLine->lnaCounterValue[0]);
                 break;
             case PERF_COUNTER_QUEUELEN:
                 fRet = (FLOAT)pLine->lnaCounterValue[0];
                 fRet = (fRet + (pLine->lnNewTime *pLine->lnaCounterValue[1]))/
                    eTimeDelta; 
                 break;
             default:
                 fRet = (FLOAT)pLine->lnaCounterValue[0];
        }
            
        // Apply the final modifiers for "counters"

        if(CalcMod & PERF_INVERSE_COUNTER)
            fRet = 1.0f - fRet;
        if(Display == PERF_DISPLAY_PERCENT)
            fRet *= 100.0f;
        }
    return fRet;
 }


// ***************************************************************************
//  FLOAT CounterEntry
//  
//  DESCRIPTION:
//  
//  Main routine for converting perf data.  In general this routine is
//  just a swither for the actual routines that do the conversion.
//  
//  PARAMETERS:
//  
//  pLine       Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
// ***************************************************************************

FLOAT CounterEntry (
        IN PLINESTRUCT pLine)
{
    switch (pLine->lnCounterType) 
    {
        case  PERF_COUNTER_COUNTER:
            return Counter_Counter_Common(pLine, 0);

        case  PERF_COUNTER_TIMER:
        case  PERF_PRECISION_SYSTEM_TIMER:
            return Counter_Timer_Common(pLine, 0);

        case  PERF_COUNTER_BULK_COUNT:
            return Counter_Counter_Common(pLine, BULK);

        case  PERF_COUNTER_TEXT:
            return 0.0f;

        case  PERF_COUNTER_RAWCOUNT:
        case  PERF_COUNTER_RAWCOUNT_HEX:
            return (FLOAT) ((DWORD) (pLine->lnaCounterValue[0]));

        case  PERF_COUNTER_LARGE_RAWCOUNT:
        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            return (FLOAT) (pLine->lnaCounterValue[0]);

        case  PERF_SAMPLE_FRACTION:
            return Sample_Common(pLine, FRACTION);

        case  PERF_SAMPLE_COUNTER:
            return Sample_Common(pLine, 0);

        case  PERF_COUNTER_NODATA:
            return 0.0f;

        case  PERF_COUNTER_TIMER_INV:
            return Counter_Timer_Common(pLine, INVERT);

        case  PERF_RAW_BASE:
//      case  PERF_SAMPLE_BASE:
//      case  PERF_AVERAGE_BASE:
            return 0.0f;

        case  PERF_AVERAGE_TIMER:
            return Counter_Average_Timer(pLine); 

        case  PERF_AVERAGE_BULK:
            return Counter_Average_Bulk (pLine);

        case  PERF_100NSEC_TIMER:
        case  PERF_PRECISION_100NS_TIMER:
            return Counter_Timer_Common(pLine, NS100);

        case  PERF_100NSEC_TIMER_INV:
            return Counter_Timer_Common(pLine, NS100_INVERT);

        case  PERF_COUNTER_MULTI_TIMER:
            return Counter_Timer_Common(pLine, TIMER_MULTI);

        case  PERF_COUNTER_MULTI_TIMER_INV:
            return Counter_Timer_Common(pLine, TIMER_MULTI_INVERT);

        case  PERF_COUNTER_MULTI_BASE:
            return 0.0f;

        case  PERF_100NSEC_MULTI_TIMER:
            return Counter_Timer_Common(pLine, NS100_MULTI);
                 
        case  PERF_100NSEC_MULTI_TIMER_INV:
            return Counter_Timer_Common(pLine, NS100_MULTI_INVERT);

        case  PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine, TRUE, FALSE);

        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine, TRUE, TRUE);

        case  PERF_COUNTER_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine, FALSE, FALSE);

        case  PERF_RAW_FRACTION:
        case  PERF_LARGE_RAW_FRACTION:
            return Counter_Raw_Fraction (pLine);
        case  PERF_COUNTER_DELTA:
            return Counter_Delta(pLine, FALSE);
        case  PERF_COUNTER_LARGE_DELTA:
            return Counter_Delta(pLine, TRUE);

        case  PERF_ELAPSED_TIME:
            return eElapsedTime (pLine, 0); 
        default:
            return GenericConv (pLine);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\crc32.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CRC32.CPP

Abstract:

    Standard CRC-32 implementation

History:

    raymcc      07-Jul-97       Createada

--*/

#include "precomp.h"
#include <stdio.h>
#include <crc32.h>

static DWORD CrcTable[] =
{
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be 0xFFFFFFFF if no previous CRC
    )
{
    if(nBytes == 0)
        return dwOldCrc;

    DWORD dwNewCrc = 0;

    for (int n = 0; n < nBytes; n++)
    {
        dwNewCrc = CrcTable[ BYTE(dwOldCrc ^ DWORD(pSrc[n]))] 
            ^ ((dwOldCrc >> 8) & 0x00FFFFFF);
        dwOldCrc = dwNewCrc;            
    }
    
    return dwNewCrc;
}
    

/*
void main(int argc, char **argv)
{
    if (argc < 2)
    {
        return;
    }

    FILE *f = fopen(argv[1], "rb");
    
    DWORD dwCrc = STARTING_CRC32_VALUE;
    
    int nBytes = 0;

    while (1)
    {
        BYTE Buf[256];
        
        int nRes = fread(Buf, 1, 256, f);

        nBytes += nRes;

        if (nRes == 0)
            break;
            
        if (nRes != 0)
        {
            dwCrc = UpdateCRC32(Buf, nRes, dwCrc);
        }
    }        

    FINALIZE_CRC32(dwCrc);
    
    fclose(f);

    printf("Bytes = %d\n", nBytes);
        
    printf("CRC32 is 0x%X\n", dwCrc);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\cvariant.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CVARIANT.H

Abstract:

	Declares the CVariantClass

History:

	a-davj  9-27-95   Created.

--*/

#ifndef _CVARIANT_H_
#define _CVARIANT_H_

#include "stdprov.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  CVariant
//
//  DESCRIPTION:
//
//  A wrapper around the VARIANT stucture.  
//
//***************************************************************************

class CVariant : public CObject {
    public:

    CVariant();
    CVariant(LPWSTR pwcStr);
    SCODE SetData(void * pData, VARTYPE vt, int iSize = -1);
    SCODE GetData(void ** pData, DWORD dwRegType, DWORD * pdwSize);
    SCODE DoPut(long lFlags,IWbemClassObject FAR *,BSTR PropName, CVariant * pVar);
    ~CVariant();
    void SetType(VARTYPE vtNew){var.vt =  vtNew;};
    VARTYPE GetType(){return var.vt;};
    void * GetDataPtr(){return (void *)&var.lVal;};
    VARIANT * GetVarPtr(){return &var;};
    BSTR GetBstr(){return var.bstrVal;};
    BOOL bGetBOOL(){return var.boolVal;};
    DWORD GetNumElements(void);
    BOOL IsArray(void){return var.vt & VT_ARRAY;};
    SCODE ChangeType(VARTYPE vtNew);    
    void Clear(void);
    
    private:
    VARIANT var;
    int CalcNumStrings(TCHAR *pTest);
    SCODE SetArrayData(void * pData,VARTYPE vtSimple, int iSize);
    SCODE GetArrayData(void ** pData,  DWORD * pdwSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\enuminst.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    ENUMINST.CPP

Abstract:

	Implements the CEnumInst class which enumerates instances.

History:

	a-davj  19-Oct-95   Created.

--*/

#include "precomp.h"
#include "impdyn.h"

//***************************************************************************
//
//  CCFDyn::CCFDyn
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pEnumInfo       Object which enumerates the key values
//  lFlags          flags passed to the CreateInstanceEnum call
//  pClass          name of the class
//  pWBEMGateway     pointer to WBEM core
//  pProvider       pointer to provider obect which was asked to create
//                  the enumerator.
//***************************************************************************

CEnumInst::CEnumInst(
            IN CEnumInfo * pEnumInfo,
            IN long lFlags,
            IN WCHAR * pClass, 
            IN IWbemServices FAR* pWBEMGateway,
            IN CImpDyn * pProvider,
            IWbemContext  *pCtx):
            m_iIndex(0), m_pEnumInfo(0),m_pwcClass(0), m_lFlags(0), m_pCtx(0),  m_pWBEMGateway(0), 
            m_pProvider(0), m_cRef(0), m_bstrKeyName(0),  m_PropContextCache()
            
{
    m_pwcClass = new WCHAR[wcslen(pClass)+1];
    if(m_pwcClass == NULL) return;

    wcscpy(m_pwcClass,pClass);
    m_pWBEMGateway = pWBEMGateway;
    m_pWBEMGateway->AddRef();
    m_pProvider = pProvider;
    m_pProvider->AddRef();
    m_lFlags = lFlags;
    m_pEnumInfo = pEnumInfo;
    m_pEnumInfo->AddRef();
    m_pCtx = pCtx;
    if(pCtx) pCtx->AddRef();
    InterlockedIncrement(&lObj);

	// Get the KeyName

	IWbemClassObject * pClassObj = NULL;
    SCODE sc = m_pWBEMGateway->GetObject(pClass,0,m_pCtx,&pClassObj,NULL);
    if(FAILED(sc)) return;
    
	m_bstrKeyName = m_pProvider->GetKeyName(pClassObj);
	pClassObj->Release();
}

//***************************************************************************
//
//  CCFDyn::~CCFDyn
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CEnumInst::~CEnumInst(void)
{
    if(m_pwcClass)
        delete m_pwcClass;
    if(m_pWBEMGateway != NULL) {
        m_pWBEMGateway->Release();
        m_pProvider->Release();
        m_pEnumInfo->Release();
        InterlockedDecrement(&lObj);
        }
    if(m_pEnumInfo != NULL)
        delete m_pEnumInfo;
    if(m_pCtx)
        m_pCtx->Release();
	if(m_bstrKeyName)
		SysFreeString(m_bstrKeyName);
    return;
}

//***************************************************************************
// HRESULT CEnumInst::QueryInterface
// long CEnumInst::AddRef
// long CEnumInst::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumInst::QueryInterface(
                IN REFIID riid,
                OUT PPVOID ppv)
{
    *ppv=NULL;

    if ((IID_IUnknown==riid || IID_IEnumWbemClassObject==riid)
                            && m_pWBEMGateway != NULL) 
    {
        *ppv=this;
        AddRef();
        return NOERROR;
    }
    else
        return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumInst::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumInst::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;
    delete this;
    return 0L;
}

//***************************************************************************
//
//  CEnumInst::Reset
//
//  DESCRIPTION:
//
//  Sets pointer back to first element.
//
//  RETURN VALUES:
//
//  S_OK
//
//***************************************************************************

STDMETHODIMP CEnumInst::Reset()
{
    m_iIndex = 0;
    return S_OK;
}

//***************************************************************************
//
//  CEnumInst::Clone
//
//  DESCRIPTION:
//
//  Create a duplicate of the enumerator
//
//  PARAMETERS:
//
//  pEnum       Set to point to duplicate.
//
//  RETURN VALUES:
// 
//  S_OK                    if all is well
//  WBEM_E_OUT_OF_MEMORY     if out of memory
//  WBEM_E_INVALID_PARAMETER if passed a null
//
//***************************************************************************

STDMETHODIMP CEnumInst::Clone(
    OUT IEnumWbemClassObject FAR* FAR* pEnum)
{
    CEnumInst * pEnumObj;
    SCODE sc;
    if(pEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;

    pEnumObj=new CEnumInst(m_pEnumInfo,m_lFlags,m_pwcClass, 
                                m_pWBEMGateway,m_pProvider, m_pCtx);
    if(pEnumObj == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    sc = pEnumObj->QueryInterface(IID_IEnumWbemClassObject,(void **) pEnum);
    if(FAILED(sc))
        delete pEnumObj;
    pEnumObj->m_iIndex = m_iIndex;
    return S_OK;
}


//***************************************************************************
//
//  CEnumInst::Skip
//
//  DESCRIPTION:
//
//  Skips one or more elements in the enumeration.
//
//  PARAMETERS:
//
//  nNum        number of elements to skip
//
//  RETURN VALUES:
//
//  S_OK        if we still are not past the end of the list
//  S_FALSE     if requested skip number would go beyond the end of the list
//
//***************************************************************************

STDMETHODIMP CEnumInst::Skip(long lTimeout,
                IN ULONG nNum)
{
    SCODE sc;;
    int iTest = m_iIndex + nNum;    
    LPWSTR pwcKey;
    sc = m_pProvider->GetKey(m_pEnumInfo,iTest,&pwcKey);
    if(sc == S_OK) {
        delete pwcKey;
        m_iIndex = iTest;
        return S_OK;
        }
    return S_FALSE;
}

//***************************************************************************
//
//  CEnumInst::Next
//
//  DESCRIPTION:
//
//  Returns one or more instances.
//
//  PARAMETERS:
//
//  uCount      Number of instances to return.
//  pObj        Pointer to array of objects.
//  puReturned  Pointer to number of objects successfully returned.
//
//  RETURN VALUES:
//  S_OK if all the request instances are returned.  Note that WBEM_E_FAILED
//  is returned even if there are some instances returned so long as the 
//  number is less than uCount. Also WBEM_E_INVALID_PARAMETER may be
//  return if the arguments are bogus. 
//
//***************************************************************************

STDMETHODIMP CEnumInst::Next(long lTimeout,
                            IN ULONG uCount, 
                            OUT IWbemClassObject FAR* FAR* pObj, 
                            OUT ULONG FAR* puReturned)
{
    ULONG uIndex;
    SCODE sc;
    LPWSTR pwcKey;
    if(pObj == NULL || puReturned == NULL)
        return WBEM_E_INVALID_PARAMETER;
    IWbemClassObject FAR* FAR* pNewInst = pObj;
    *puReturned = 0;
    for(uIndex = 0; uIndex < uCount; ) 
    {
        sc = m_pProvider->GetKey(m_pEnumInfo,m_iIndex,&pwcKey);
        m_iIndex++;
        if(sc != S_OK) 
            break;  // if no more in registry, then we are done
        sc = m_pProvider->CreateInst(m_pWBEMGateway,m_pwcClass,
                                    pwcKey,pNewInst,m_bstrKeyName,
                                    &m_PropContextCache, m_pCtx);
        delete pwcKey;
        if(sc == S_OK)
        {
            uIndex++;
            pNewInst++;
            (*puReturned)++;  // add one to number of objects created
        }
    }
    return (uIndex == uCount) ? S_OK : WBEM_E_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\cvariant.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CVARIANT.CPP

Abstract:

	Defines the CVarinat class which is a purpose object to 
	wrap VARIANT structures.

History:

	a-davj  4-27-95 Created.

--*/


#include "precomp.h"
#include "impdyn.h"
#include "cvariant.h"
//#include <afxpriv.h>

BSTR SysAllocBstrFromTCHAR(TCHAR * pFrom)
{
#ifdef UNICODE
    return SysAllocString(pFrom);
#else
	WCHAR * pTemp = new WCHAR[lstrlen(pFrom)+1];
	if(pTemp == NULL)
		return NULL;
	mbstowcs(pTemp, pFrom,  lstrlen(pFrom)+1);
	BSTR bRet = SysAllocString(pTemp);
	delete pTemp;
	return bRet;
#endif
}
//***************************************************************************
//
//  int CVariant::CalcNumStrings
//
//  DESCRIPTION:
//
//  Calculates the number of strings
//
//  PARAMETERS:
//
//  pTest   points to string to test
//
//  RETURN VALUE:
//  Return - the number of strings in a multistring block.
//
//***************************************************************************

int CVariant::CalcNumStrings(
        IN TCHAR *pTest)
{
    int iRet = 0;
    if(pTest == NULL)
        return 0;
    while(*pTest) 
    {
        iRet++;
        pTest += lstrlen(pTest)+1;
    }
    return iRet;
}

//***************************************************************************
//
//  CVariant::ChangeType
//
//  DESCRIPTION:
//  
//  Changes the CVariant data into a new type.
//
//  PARAMETERS:
//
//  vtNew   Type to convert to
//
//  RETURN VALUE:
//
//  S_OK if alright, otherwise an error set by OMSVariantChangeType
//
//***************************************************************************

SCODE CVariant::ChangeType(
        IN VARTYPE vtNew)
{
    SCODE sc;

    // if type doesnt need changing, then already done!

    if(vtNew == var.vt)
        return S_OK;

    // Create and initialize a temp VARIANT

    VARIANTARG vTemp;
    VariantInit(&vTemp);
    
    // Change to the desired type.  Then delete the current value
    // and copy the temp copy

    sc = OMSVariantChangeType(&vTemp,&var,0,vtNew);
    OMSVariantClear(&var);
    
    var = vTemp; // structure copy
    return sc;
}

//***************************************************************************
//
//  CVariant::Clear
//
//  DESCRIPTION:
//
//  Clears out the VARIANT.
//
//***************************************************************************

void CVariant::Clear(void)
{
    OMSVariantClear(&var);
}


//***************************************************************************
//
//  CVariant::
//  CVariant::~CVariant
//
//  DESCRIPTION:
//
//  Constructor and destructor.
//
//***************************************************************************

CVariant::CVariant()
{
    VariantInit(&var);
    memset((void *)&var.lVal,0,8);
}

CVariant::CVariant(LPWSTR pwcStr)
{
    VariantInit(&var);
    if(pwcStr)
    {
        var.bstrVal = SysAllocString(pwcStr);
        if(var.bstrVal)
            var.vt = VT_BSTR;
    }
}

CVariant::~CVariant()
{
    OMSVariantClear(&var);
}


//***************************************************************************
//
//  SCODE CVariant::DoPut
//
//  DESCRIPTION:
//
//  "Puts" the data out to the WBEM server (if pClassInt isnt NULL), or just
//  copies the data to the variant.
//
//  PARAMETERS:
//
//  lFlags      flags to pass along to wbem server
//  pClassInt   pointer to class/instance object
//  PropName    property name
//  pVar        variant value
//
//  RETURN VALUE:
//
//  S_OK if no error other wise see wbemsvc error codes when, pClass isnt
//  null, or see the OMSVariantChangeType function.
//
//***************************************************************************

SCODE CVariant::DoPut(
        IN long lFlags,
        IN IWbemClassObject FAR * pClassInt,
        IN BSTR PropName, 
        IN CVariant * pVar)
{
    SCODE sc;

    if(pClassInt)
    {

        sc = pClassInt->Put(PropName,lFlags,&var,0);
    }
    else if(pVar)
    {
        pVar->Clear();
        sc = OMSVariantChangeType(&pVar->var,&var,0,var.vt);
    }
    else sc = WBEM_E_FAILED;
    return sc;
}

//***************************************************************************
//
//  SCODE CVariant::GetArrayData
//
//  DESCRIPTION:
//
//  Converts array data into a single data block.  This is used by the 
//  registry provider when it writes out array data.
//
//  PARAMETERS:
//
//  ppData      pointer to the return data.  Note it is the job of the 
//              caller to free this when the return code is S_OK
//  pdwSize     Size of returned data
//
//  RETURN VALUE:
//
//  S_OK                if all is well
//  WBEM_E_OUT_OF_MEMORY when we memory allocation fails
//  WBEM_E_FAILED        when variant has bogus type.
//  ???                 when failure is in SafeArrayGetElement
//
//***************************************************************************

SCODE CVariant::GetArrayData(
        OUT void ** ppData, 
        OUT DWORD * pdwSize)
{
    SCODE sc;
    DWORD dwSoFar = 0;
    SAFEARRAY * psa;
    long ix[2] = {0,0};
    BYTE * pb;
    TCHAR * ptc;
    BOOL bString = ((var.vt & ~VT_ARRAY) == CHARTYPE ||(var.vt & ~VT_ARRAY) == VT_BSTR );

    int iNumElements = GetNumElements();

    int iSizeOfType = iTypeSize(var.vt);
    if(iSizeOfType < 1)
        return WBEM_E_FAILED;
    
    // Calculate necessary size;

    psa = var.parray;
    if(bString) {
        *pdwSize = CHARSIZE;       // 1 for the final double null!
        for(ix[0] = 0; ix[0] < iNumElements; ix[0]++) {
            BSTR bstr;
            sc = SafeArrayGetElement(psa,ix,&bstr);
            if(FAILED(sc))
                return sc;
#ifdef UNICODE
            *pdwSize += 2 * (wcslen(bstr) +1);
#else
            int iWCSLen  = wcslen(bstr) + 1;
            *pdwSize += wcstombs(NULL,bstr,iWCSLen) + 1;            
#endif
            SysFreeString(bstr);
            }
        }
    else {
        *pdwSize = iNumElements * iSizeOfType;
        }

    // Allocate the memory to be filled

    *ppData = CoTaskMemAlloc(*pdwSize);
    if(*ppData == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pb = (BYTE *)*ppData;
    ptc = (TCHAR *)*ppData;

    // loop for each array element

    sc = S_OK;
    for(ix[0] = 0; ix[0] < iNumElements && sc == S_OK; ix[0]++) {
        if (bString) {
            BSTR bstr;
            sc = SafeArrayGetElement(psa,ix,&bstr);
            if(sc != S_OK)
                break;
            DWORD dwBytesLeft  = *pdwSize-dwSoFar;
#ifdef UNICODE
            lstrcpyn(ptc,bstr,dwBytesLeft/2);
#else
            wcstombs(ptc,bstr,dwBytesLeft);
#endif
            dwSoFar += CHARSIZE * (lstrlen(ptc) + 1);
            ptc += lstrlen(ptc) + 1;
            SysFreeString(bstr);
            *ptc = 0;       // double null
            }
        else {
            sc = SafeArrayGetElement(psa,ix,pb);
            pb += iSizeOfType;
            }
         }
    if(sc != S_OK)
        CoTaskMemFree(*ppData);
    
    return S_OK;
}

//***************************************************************************
//
//  SCODE CVariant::GetData
//
//  DESCRIPTION:
//
//  Used by the registry provider to take the data from VARIANT arg format
//  into a raw block for output. Note that the data allocated and stuck into
//  *ppData should be freed using CoTaskMemFree!
//
//  PARAMETERS:
//
//  ppData      Pointer to output data.
//  dwRegType   Type to convert to
//  pdwSize     Pointer to size of returned data
//
//  RETURN VALUE:
//
//  S_OK if all is well, otherwise a error code which is set by either 
//  OMSVariantChangeType, or GetArrayData.
//
//***************************************************************************

SCODE CVariant::GetData(
        OUT void ** ppData, 
        IN DWORD dwRegType, 
        OUT DWORD * pdwSize)
{

    SCODE sc =  S_OK;

    // Determine the type it may need to be converted to.  Note that binary
    // data is not converted intentionally.

    switch(dwRegType) {
        case REG_DWORD:
            sc = ChangeType(VT_I4);
            break;
        case REG_SZ:
            sc = ChangeType(VT_BSTR);
            break;

        case REG_MULTI_SZ:
            sc = ChangeType(VT_BSTR | VT_ARRAY);
            break;
        default:
            break;
        }

    if(sc != S_OK)
        return sc;

    // Special case for arrays

    if(dwRegType == REG_BINARY || dwRegType == REG_MULTI_SZ)
        return GetArrayData(ppData, pdwSize);

    // Allocate some memory and move the data into it.

    if(dwRegType == REG_SZ) {
#ifdef UNICODE
        *pdwSize = 2 * (wcslen(var.bstrVal)+1);
        *ppData = CoTaskMemAlloc(*pdwSize);
        if(*ppData == NULL) 
            return WBEM_E_OUT_OF_MEMORY;
        lstrcpyW((WCHAR *)*ppData,var.bstrVal);
#else
        *ppData = WideToNarrow(var.bstrVal);
        if(*ppData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        *pdwSize = lstrlenA((char *)*ppData)+1;
#endif
        }
    else {
        *pdwSize = iTypeSize(var.vt);
        *ppData = CoTaskMemAlloc(*pdwSize);
        if(*ppData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        memcpy(*ppData,(void *)&var.lVal,*pdwSize);
        }

    return S_OK;
}


//***************************************************************************
//
//  CVariant::GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements in an array. 
//
//  RETURN VALUE:
//
//  number of elements.  Scalers return a 1.
//
//***************************************************************************

DWORD CVariant::GetNumElements(void)
{
    SCODE sc;
    if(!IsArray())
        return 1;
    SAFEARRAY * psa = var.parray;
    long uLower, uUpper;
    sc = SafeArrayGetLBound(psa,1,&uLower);
    sc |= SafeArrayGetUBound(psa,1,&uUpper);
    if(sc != S_OK)
        return 0;
    else
        return uUpper - uLower +1;
}

//***************************************************************************
//
//  SCODE CVariant::SetArrayData
//
//  DESCRIPTION:
//
//  Sets the CVariant value using raw data.  Used by the reg provider.
//
//  PARAMETERS:
//
//  pData       pointer to data to set
//  vtSimple    Type to set the data to
//  iSize       size of data pointed to by pData
//
//  RETURN VALUE:
//
//  S_OK if OK.
//  WBEM_E_INVALID_PARAMETER if the arguments are bad
//  WBEM_E_OUT_OF_MEMORY     if out of memory
//  other wise error from SafeArrayPutElement
//
//***************************************************************************

SCODE CVariant::SetArrayData(
        IN void * pData, 
        IN VARTYPE vtSimple, 
        IN int iSize)
{
    SCODE sc;
    int iNumElements;
    BYTE * pNext;
    long ix[2] = {0,0};
    DWORD dwLeftOver = 0;
    int iSizeOfType = iTypeSize(vtSimple);
    
    if(pData  == NULL || iSizeOfType < 1 || iSize < 1)
        return WBEM_E_INVALID_PARAMETER; 
        
    // Calculate the number of elements and make sure it is a type that
    // is supported

    if(vtSimple == VT_BSTR) {
        iNumElements = CalcNumStrings((TCHAR *)pData);
        }
    else {
        iNumElements = iSize / iSizeOfType;
        dwLeftOver = iSize % iSizeOfType;
        }
    
    // Allocate array
    
    int iNumCreate = (dwLeftOver) ? iNumElements + 1 : iNumElements;
    SAFEARRAY * psa = OMSSafeArrayCreate(vtSimple,iNumCreate);
    if(psa == NULL)
        return WBEM_E_FAILED;

    // Set each element of the array

    for(ix[0] = 0, pNext = (BYTE *)pData; ix[0] < iNumElements; ix[0]++) {
        if(vtSimple == VT_BSTR) {
            BSTR bstr;
			bstr = SysAllocBstrFromTCHAR((LPTSTR)pNext);
            if(bstr == NULL)   {  // todo, free previously allocated strings!
                SafeArrayDestroy(psa);
                return WBEM_E_OUT_OF_MEMORY;
                }
            sc = SafeArrayPutElement(psa,ix,(void*)bstr);
            pNext += sizeof(TCHAR)*(lstrlen((TCHAR *)pNext) + 1);
            SysFreeString(bstr);
            }
        else {
            sc = SafeArrayPutElement(psa,ix,pNext);
            pNext += iSizeOfType;
            }
        if(sc) {    // todo, cleanup???
            SafeArrayDestroy(psa);
            return sc;
            }
        }

    // it is possible that the number of bytes being set doesnt evenly factor
    // into the type size.  For instance, there may be 10 bytes of registry
    // data being put into a DWORD array.  In this case, the last two bytes
    // are left overs

    if(dwLeftOver) {
        __int64 iTemp = 0;
        memcpy((void *)&iTemp,(void *)pNext,dwLeftOver);
        sc = SafeArrayPutElement(psa,ix,&iTemp);
        }

    var.vt = vtSimple | VT_ARRAY;
    var.parray = psa;
    return S_OK;
}

//***************************************************************************
//
// CVariant::SetData
//
//  Sets the CVariant value using raw data.  Used by the reg provider.
//
//  DESCRIPTION:
//
//  PARAMETERS:
//
//  pData       Data to be set
//  vtChangeTo  Type to change the data to
//  iSize       size of data pointed to by pData
//
//  RETURN VALUE:
//
//  S_OK if OK.
//  WBEM_E_INVALID_PARAMETER if the arguments are bad
//  WBEM_E_OUT_OF_MEMORY     if out of memory
//  other wise error from SafeArrayPutElement
//
//***************************************************************************

SCODE CVariant::SetData(
        IN void * pData, 
        IN VARTYPE vtChangeTo, 
        IN int iSize)
{
    int iToSize = iTypeSize(vtChangeTo);

    // check arguments and clear the variant

    if(pData == NULL || iToSize < 1)
        return WBEM_E_INVALID_PARAMETER;
    OMSVariantClear(&var);
    if(iSize < 1) 
        iSize = iToSize;

    // Special case for arrays!
    
    if(vtChangeTo & VT_ARRAY)
        return SetArrayData(pData,vtChangeTo & ~VT_ARRAY,iSize);

    if(vtChangeTo == CIM_SINT64 || vtChangeTo == CIM_UINT64)
    {

        // int64 and uint64 need to be converted to strings

        WCHAR wcTemp[50];
        __int64 iLong;
        memcpy((void *)&iLong, pData, 8);
        if(vtChangeTo == CIM_SINT64)
            swprintf(wcTemp,L"%I64d", iLong);
        else
            swprintf(wcTemp,L"%I64u", iLong);
        
        var.bstrVal = SysAllocString(wcTemp);
        if(var.bstrVal == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.vt = VT_BSTR;
    }
    else if(vtChangeTo == VT_BSTR) 
    {

        // All strings are stored as BSTRS

        var.bstrVal = SysAllocBstrFromTCHAR((LPTSTR)pData);
        if(var.bstrVal == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.vt = VT_BSTR;
    }
    else 
    {
        memcpy((void *)&var.lVal,pData,iToSize);
        var.vt = vtChangeTo;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\crc32.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CRC32.H

Abstract:

    Standard CRC-32 implementation

History:

	raymcc      07-Jul-97       Createada

--*/

#ifndef _CRC_H_
#define _CRC_H_

#define STARTING_CRC32_VALUE    0xFFFFFFFF

DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be STARTING_CRC_VALUE (0xFFFFFFFF) 
                                // if no previous CRC, otherwise this is the
                                // CRC of the previous cycle.
    );

#define FINALIZE_CRC32(x)    (x=~x)

/*
The CRC holding value must be preinitialized to STARTING_CRC32_VALUE
UpdateCRC32() may be called as many times as necessary on a single buffer.  
When computing the CRC32

The final value must be post-processed using the FINALIZE_CRC32() macro.

Example:

void main()
{
    BYTE Data[] = { 1, 2, 3 };

    DWORD dwCRC = STARTING_CRC32_VALUE;

    dwCRC = UpdateCRC32(Data, 3, dwCRC);

    FINALIZE_CRC32(dwCRC);

    printf("CRC32 = 0x%X\n", dwCRC);
}

*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\dataconv.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    DATACONV.CPP

Abstract:

	Provides a some generic data conversion routines.  In particular,
	OMSVariantChangeType and OMSVariantClear provide the same
	capabilities as the Ole VariantChangeType and VariantClear
	functions except that the OMS versions handle more data types.

History:

	a-davj  19-Oct-95   Created.

--*/

#include "precomp.h"

#include "resource.h"
#include "CVariant.h"
#include <ole2.h>


//***************************************************************************
//
//  char * WideToNarrow
//
//  DESCRIPTION:
//
//  Takes a WCHAR string and creates a MBS equivalent.  The caller should
//  free the string when done.
//
//  PARAMETERS:
//
//  pConv       UNICODE string to convert.
//
//  RETURN VALUE:
//
//  NULL if out of memory, otherwise a mbs string that the caller should free
//  via CoTaskMemFree.
//
//***************************************************************************

char * WideToNarrow(
        IN LPCWSTR pConv)
{
    char * cpRet = NULL;
    int iMBSLen = wcstombs(NULL,pConv,0) + 1;
    if(iMBSLen == 0)
        return NULL;
    cpRet = (char *)CoTaskMemAlloc(iMBSLen);
    if(cpRet)
    {
        memset(cpRet, 0, iMBSLen);
        wcstombs(cpRet,pConv,iMBSLen);
    }
    return cpRet;
}

int gDiag;

char * WideToNarrowA(
        IN LPCWSTR pConv)
{
    char * cpRet = NULL;
    int iMBSLen = wcstombs(NULL,pConv,0) + 1;
    if(iMBSLen == 0)
        return NULL;
    cpRet = new char[iMBSLen];
    gDiag = iMBSLen;
    if(cpRet)
    {
        memset(cpRet, 0, iMBSLen);
        wcstombs(cpRet,pConv,iMBSLen);
    }
    return cpRet;
}
//***************************************************************************
//
//  SAFEARRAY * OMSSafeArrayCreate
//
//  DESCRIPTION:
//
//  Creates a safe array.  
//
//  PARAMETERS:
//
//  vt              element type
//  iNumElements    number of elements
//
//  RETURN VALUE:
//
//  Returns null if there is a problem.
//
//***************************************************************************

SAFEARRAY * OMSSafeArrayCreate(
                IN VARTYPE vt,
                IN int iNumElements)
{
    if(iTypeSize(vt) < 1 || iNumElements < 1)
        return NULL;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    return SafeArrayCreate(vt,1,rgsabound);
}

//***************************************************************************
//
//  SCODE OMSVariantChangeType
//
//  DESCRIPTION:
//
//  Converts a variant from one type into another.  This functions takes the
//  same arguments and does the same action as the standard 
//  VariantChangeType except that it also handles arrays.
//
//
//  PARAMETERS:
//
//  pDest       points to the variant which is to be updated
//  pSrc        points to the variant that is the source
//  wFlags      flags which are passed on to VariantChangeType
//  vtDest      Type that the pDest is conveted to
//
//  RETURN VALUE:
//
//  S_OK                        All is well.
//  WBEM_E_INVALID_PARAMETER     Invalid argument
//  WBEM_E_OUT_OF_MEMORY         Out of memory
//  otherwise various return codes from VariantChangeType, or safe array
//  manipulation
//
//***************************************************************************

HRESULT OMSVariantChangeType(
            IN OUT VARIANTARG * pDest, 
            IN VARIANTARG *pSrc, 
            IN USHORT wFlags, 
            IN VARTYPE vtDest)
{
    SCODE sc;

    // Verify arguments and clear out the destination

    if(pDest == NULL || pSrc == NULL || iTypeSize(vtDest)<1 || iTypeSize(pSrc->vt)<1)
        return WBEM_E_INVALID_PARAMETER;          // Junk args
    OMSVariantClear(pDest);

    // if both are arrays,

    if(vtDest & VT_ARRAY && pSrc->vt & VT_ARRAY) {

        // Set the VARTYPES without the VT_ARRAY bits

        VARTYPE vtDestSimple = vtDest & ~VT_ARRAY;
        VARTYPE vtSrcSimple = pSrc->vt &~ VT_ARRAY;

        // Determine the size of the source array.  Also make sure that the array 
        // only has one dimension

        unsigned int uDim = SafeArrayGetDim(pSrc->parray);
        if(uDim != 1)
            return WBEM_E_FAILED;      // Bad array, or too many dimensions
        long ix[2] = {0,0};
        long lLower, lUpper;
        sc = SafeArrayGetLBound(pSrc->parray,1,&lLower);
        if(sc != S_OK)
            return sc;
        sc = SafeArrayGetUBound(pSrc->parray,1,&lUpper);
        if(sc != S_OK)
            return sc;
        int iNumElements = lUpper - lLower +1; 

        // Create a destination array of equal size

        SAFEARRAY * pDestArray = OMSSafeArrayCreate(vtDestSimple,iNumElements);
        if(pDestArray == NULL)
            return WBEM_E_FAILED;  // Most likely a bad type!

        // For each element in the source array

        for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) {
 
            CVariant varSrc, varDest;
                   
            // Set Temp CVariant to the source data

            sc = SafeArrayGetElement(pSrc->parray,ix,varSrc.GetDataPtr());
            if(sc != S_OK)
                break;
            varSrc.SetType(vtSrcSimple);

            // Convert to destination data using VariantConvert
            
            sc = VariantChangeType(varDest.GetVarPtr(),varSrc.GetVarPtr(),wFlags,vtDestSimple);
            if(sc != S_OK)
                break;

            // Set destination data into the array
            
            if(vtDestSimple == VT_BSTR || vtDestSimple == VT_UNKNOWN || 
                                                    vtDestSimple == VT_DISPATCH)
                sc = SafeArrayPutElement(pDestArray,ix,(void *)varDest.GetBstr());
            else
                sc = SafeArrayPutElement(pDestArray,ix,(void *)varDest.GetDataPtr());

            }

        if(sc != S_OK){
            SafeArrayDestroy(pDestArray);
            }
        else {
            // set the VARTYPE of the destination

            pDest->vt = vtDest;
            pDest->parray = pDestArray;
            }
        return sc;
        }
    
    // if one, but not the other is an array, bail out

    if(vtDest & VT_ARRAY || pSrc->vt & VT_ARRAY) 
        return WBEM_E_FAILED;

    // Attempt to use standard conversion

    return VariantChangeType(pDest,pSrc,wFlags,vtDest);
   
}

//***************************************************************************
//
//  OMSVariantClear
//
//  DESCRIPTION:
//
//  Does the same as the Ole VariantClear function except
//  that it also sets the data to all 0.
//
//  PARAMETERS:
//
//  pClear      Variant to be cleared.
//
//  RETURN VALUE:
//
//  Result from VariantClear, most always S_OK
//
//***************************************************************************

HRESULT OMSVariantClear(
            IN OUT VARIANTARG * pClear)
{
    HRESULT sc;
    sc = VariantClear(pClear);
    memset((void *)&pClear->lVal,0,8);
    return sc;
}

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown 
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN VARTYPE vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;
        case CIM_SINT64:
        case CIM_UINT64:
            iRet = 8;
            break;

        default:
            iRet = 0;
        }
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\cpropset.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROPSET.H

Abstract:

		Purpose: Used by the compound file property set provider.  This code was
		largly taken from some MSVC sample code which was modified
		somewhat in order to support VARIANT type arrays.  In general,
		a CPropSet object contains a list of CPropSection objects 
		which each contain a list of CProp objects.

History:

	a-davj  04-Mar-97   Created.

--*/

typedef struct tagSECTIONHEADER
{
    DWORD       cbSection ;
    DWORD       cProperties ;  // Number of props.
} SECTIONHEADER, *LPSECTIONHEADER ;

typedef struct tagPROPERTYIDOFFSET
{
    DWORD       propertyID;
    DWORD       dwOffset;
} PROPERTYIDOFFSET, *LPPROPERTYIDOFFSET;

typedef struct tagPROPHEADER
{
    WORD        wByteOrder ;    // Always 0xFFFE
    WORD        wFormat ;       // Always 0
    DWORD       dwOSVer ;       // System version
    CLSID       clsID ;         // Application CLSID
    DWORD       cSections ;     // Number of sections (must be at least 1)
} PROPHEADER, *LPPROPHEADER ;

typedef struct tagFORMATIDOFFSET
{
    GUID        formatID;
    DWORD       dwOffset;
} FORMATIDOFFSET, *LPFORMATIDOFFSET;


/////////////////////////////////////////////////////////////////////////////
// CProp

class CProp : public CObject
{
    friend class CPropSet ;
    friend class CPropSection ;

public:
// Construction
    CProp( void ) ;

// Qualifiers
    BOOL    Set( DWORD dwID, const LPVOID pValue, DWORD dwType, DWORD dwSize ) ;
    LPVOID  Get( void ) ;           // Returns pointer to actual value
    DWORD   GetType( void ) ;       // Returns property type
    DWORD   GetID( void ) ;

// Operations
    BOOL    WriteToStream( IStream* pIStream ) ;
    BOOL    ReadFromStream( IStream* pIStream, DWORD dwSize ) ;

private:
    DWORD       m_dwPropID ;
    DWORD       m_dwType ;
    LPVOID      m_pValue ;
    DWORD       m_dwSize;

    LPVOID  AllocValue(ULONG cb);
    void    FreeValue();

public:
    ~CProp() ;
} ;


/////////////////////////////////////////////////////////////////////////////
// CPropSection

class CPropSection : public CObject
{
    friend class CPropSet ;
    friend class CProp ;

public:
// Construction
    CPropSection( void ) ;
    CPropSection( CLSID FormatID ) ;
// Qualifiers

    void    SetFormatID( CLSID FormatID ) ;

    void    RemoveAll() ;

    CProp* GetProperty( DWORD dwPropID ) ;
    void AddProperty( CProp* pProp ) ;

    DWORD   GetSize( void ) ;
    DWORD   GetCount( void ) ;
    CObList* GetList( void ) ;

    BOOL    SetSectionName( LPCTSTR pszName );
    LPCTSTR GetSectionName( void );

// Operations
    BOOL    WriteToStream( IStream* pIStream ) ;
    BOOL    ReadFromStream( IStream* pIStream, LARGE_INTEGER liPropSet ) ;

private:
// Implementation
    CLSID           m_FormatID ;
    SECTIONHEADER   m_SH ;
    // List of properties (CProp)
    CObList         m_PropList ;
    // Dictionary of property names
    CMapStringToPtr m_NameDict ;
    CString         m_strSectionName;

public:
    ~CPropSection();
} ;


/////////////////////////////////////////////////////////////////////////////
// CPropSet

class CPropSet : public CObject
{
    friend class CPropSection ;
    friend class CProp ;

public:
// Construction
    CPropSet( void ) ;

// Qualifiers
    void    RemoveAll( ) ;

    CProp* GetProperty( CLSID FormatID, DWORD dwPropID ) ;
    void AddProperty( CLSID FormatID, CProp* pProp ) ;
    CPropSection* GetSection( CLSID FormatID ) ;
    CPropSection* AddSection( CLSID FormatID ) ;
    void AddSection( CPropSection* psect ) ;

    WORD    GetByteOrder( void ) ;
    WORD    GetFormatVersion( void ) ;
    void    SetFormatVersion( WORD wFmtVersion ) ;
    DWORD   GetOSVersion( void ) ;
    void    SetOSVersion( DWORD dwOSVer ) ;
    CLSID   GetClassID( void ) ;
    void    SetClassID( CLSID clsid ) ;
    DWORD   GetCount( void ) ;
    CObList* GetList( void ) ;

// Operations
    BOOL    WriteToStream( IStream* pIStream ) ;
    BOOL    ReadFromStream( IStream* pIStream ) ;

// Implementation
private:
    PROPHEADER      m_PH ;
    CObList         m_SectionList ;

public:
    ~CPropSet();
} ;


/////////////////////////////////////////////////////////////////////////////
// CBuff

class CBuff : public CObject
{
public:
// Construction
    CBuff( void ) ;
    ~CBuff() ;

// Qualifiers
    void Add(void *, DWORD dwAddSize);
    void * Get(void){return pBuff;};
    DWORD GetSize(void){return dwSize;};
    DWORD bOK(void){return !bAllocError;};
    void RoundOff(void);
private:

    void * pBuff;
    DWORD dwSize;
    BOOL bAllocError;
public:
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\cpropset.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROPSET.CPP

Abstract:

    Implements the CProp and CPropSet classes.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "stdafx.h"
#include <wbemidl.h>
#include "cpropset.h"

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CProp::CProp()
{
    m_dwPropID = 0;
    m_dwSize = 0;
    m_dwType = VT_EMPTY;
    m_pValue = NULL;       // must init to NULL
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CProp::~CProp()
{
    FreeValue();
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CProp::Set(DWORD dwID, const LPVOID pValue, DWORD dwType, DWORD dwSize)
{
    if (m_pValue != NULL)
        FreeValue();
    
    m_dwPropID = dwID;
    m_dwSize = dwSize;
    m_dwType = dwType;
    m_pValue = NULL;       // set later on if there is data
    if(pValue == NULL || m_dwType == 0)
        return TRUE;
    if (NULL == AllocValue(dwSize))
    {
        TRACE0("CProp::AllocValue failed");
        return FALSE;
    }
    memcpy(m_pValue, pValue, dwSize);
    return TRUE;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

LPVOID CProp::Get()
{   return m_pValue;   }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

DWORD  CProp::GetType()
{   return m_dwType;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

DWORD CProp::GetID()
{   return m_dwPropID;   }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CProp::WriteToStream(IStream* pIStream)
{
    DWORD cb;

    // write the type

    pIStream->Write((LPVOID)&m_dwType, sizeof(m_dwType), &cb);
    if (cb != sizeof(m_dwType))
        return FALSE; //todo

    // Write the value
    if(m_dwSize > 0)
        pIStream->Write(m_pValue, m_dwSize, &cb);
    if (cb != m_dwSize)
        return FALSE ; //todo

    // make sure it ends up on a 32 bit boundry

    int iLeftover = m_dwSize % 4;
    DWORD dwTemp = 0;
    if(iLeftover)
        pIStream->Write((LPVOID)&dwTemp, iLeftover, &cb);
    return TRUE;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CProp::ReadFromStream(IStream* pIStream, DWORD dwSize)
{

    DWORD cb;

    // All properties are made up of a type/value pair.
    // The obvious first thing to do is to get the type...

    pIStream->Read((LPVOID)&m_dwType, sizeof(m_dwType), &cb);
    if (cb != sizeof(m_dwType))
        return FALSE;

    if (m_pValue != NULL)
        FreeValue();

    m_dwSize = dwSize;
    m_pValue = NULL;
    if(dwSize > 0) {
        if (NULL == AllocValue(dwSize))
            {
            TRACE0("CProp::AllocValue failed");
            return FALSE;
            }
        pIStream->Read((LPVOID)m_pValue, dwSize, &cb); //?? does size need to be passed?
        if (cb != dwSize)
            return FALSE;
        }    
// Done!
    return TRUE;
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

LPVOID CProp::AllocValue(ULONG cb)
{
    return m_pValue = malloc((int)cb);
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CProp::FreeValue()
{
    if (m_pValue != NULL)
    {
        free(m_pValue);
        m_pValue = NULL;
    }
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSection::CPropSection()
{
    m_FormatID = GUID_NULL;
    m_SH.cbSection = 0;
    m_SH.cProperties = 0;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSection::CPropSection( CLSID FormatID)
{
    m_FormatID = FormatID;
    m_SH.cbSection = 0;
    m_SH.cProperties = 0;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSection::~CPropSection()
{
    RemoveAll();
    return;
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSection::SetFormatID(CLSID FormatID)
{   m_FormatID = FormatID; }




//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSection::RemoveAll()
{
    POSITION pos = m_PropList.GetHeadPosition();
    while (pos != NULL)
        delete (CProp*)m_PropList.GetNext(pos);
    m_PropList.RemoveAll();
    m_SH.cProperties = 0;
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CProp* CPropSection::GetProperty(DWORD dwPropID)
{
    POSITION pos = m_PropList.GetHeadPosition();
    CProp* pProp;
    while (pos != NULL)
    {
        pProp= (CProp*)m_PropList.GetNext(pos);
        if (pProp->m_dwPropID == dwPropID)
            return pProp;
    }
    return NULL;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSection::AddProperty(CProp* pProp)
{
    m_PropList.AddTail(pProp);
    m_SH.cProperties++;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

DWORD CPropSection::GetSize()
{   return m_SH.cbSection; }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

DWORD CPropSection::GetCount()
{   return m_PropList.GetCount();  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CObList* CPropSection::GetList()
{   return &m_PropList;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CPropSection::WriteToStream(IStream* pIStream)
{
    // Create a dummy property entry for the name dictionary (ID == 0).
    ULONG           cb;
    ULARGE_INTEGER  ulSeekOld;
    ULARGE_INTEGER  ulSeek;
    LPSTREAM        pIStrPIDO;
    PROPERTYIDOFFSET  pido;
    LARGE_INTEGER   li;

    // The Section header contains the number of bytes in the
    // section.  Thus we need  to go back to where we should
    // write the count of bytes
    // after we write all the property sets..
    // We accomplish this by saving the seek pointer to where
    // the size should be written in ulSeekOld
    m_SH.cbSection = 0;
    m_SH.cProperties = m_PropList.GetCount();
    LISet32(li, 0);
    pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeekOld);

    pIStream->Write((LPVOID)&m_SH, sizeof(m_SH), &cb);
    if (sizeof(m_SH) != cb)
    {
        TRACE0("Write of section header failed (1).\n");
        return FALSE;
    }

    if (m_PropList.IsEmpty())
    {
        TRACE0("Warning: Wrote empty property section.\n");
        return TRUE;
    }

    // After the section header is the list of property ID/Offset pairs
    // Since there is an ID/Offset pair for each property and we
    // need to write the ID/Offset pair as we write each property
    // we clone the stream and use the clone to access the
    // table of ID/offset pairs (PIDO)...
    //
    pIStream->Clone(&pIStrPIDO);

    // Now seek pIStream past the PIDO list
    //
    LISet32(li,  m_SH.cProperties * sizeof(PROPERTYIDOFFSET));
    pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);

    // Now write each section to pIStream.
    CProp* pProp = NULL;
    POSITION pos = m_PropList.GetHeadPosition();
    while (pos != NULL)
    {
        // Get next element (note cast)
        pProp = (CProp*)m_PropList.GetNext(pos);

            // Write it
            if (!pProp->WriteToStream(pIStream))
            {
                pIStrPIDO->Release();
                return FALSE;
            }

        // Using our cloned stream write the Format ID / Offset pair
        // The offset to this property is the current seek pointer
        // minus the pointer to the beginning of the section
        pido.dwOffset = ulSeek.LowPart - ulSeekOld.LowPart;
        pido.propertyID = pProp->m_dwPropID;
        pIStrPIDO->Write((LPVOID)&pido, sizeof(pido), &cb);
        if (sizeof(pido) != cb)
        {
            TRACE0("Write of 'pido' failed\n");
            pIStrPIDO->Release();
            return FALSE;
        }

        // Get the seek offset after the write
        LISet32(li, 0);
        pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);
    }

    pIStrPIDO->Release();

    // Now go back to ulSeekOld and write the section header.
    // Size of section is current seek point minus old seek point
    //
    m_SH.cbSection = ulSeek.LowPart - ulSeekOld.LowPart;


    // Seek to beginning of this section and write the section header.
    LISet32(li, ulSeekOld.LowPart);
    pIStream->Seek(li, STREAM_SEEK_SET, NULL);
    pIStream->Write((LPVOID)&m_SH, sizeof(m_SH), &cb);
    if (sizeof(m_SH) != cb)
    {
        TRACE0("Write of section header failed (2).\n");
        return FALSE;
    }

    // Set pointer to where it was after last write

    LISet32(li, ulSeek.LowPart);
    pIStream->Seek(li, STREAM_SEEK_SET, NULL);

    return TRUE;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CPropSection::ReadFromStream(IStream* pIStream,
    LARGE_INTEGER liPropSet)
{
    ULONG               cb;
    LPSTREAM            pIStrPIDO;
    ULARGE_INTEGER      ulSectionStart;
    LARGE_INTEGER       li;
    CProp*          pProp;

    if (m_SH.cProperties || !m_PropList.IsEmpty())
        RemoveAll();

    // pIStream is pointing to the beginning of the section we
    // are to read.  First there is a DWORD that is the count
    // of bytes in this section, then there is a count
    // of properties, followed by a list of propertyID/offset pairs,
    // followed by type/value pairs.
    //
    LISet32(li, 0);
    pIStream->Seek(li, STREAM_SEEK_CUR, &ulSectionStart);
    pIStream->Read((LPVOID)&m_SH, sizeof(m_SH), &cb);
    if (cb != sizeof(m_SH))
        return FALSE;

    // Now we're pointing at the first of the PropID/Offset pairs
    // (PIDOs).   To get to each property we use a cloned stream
    // to stay back and point at the PIDOs (pIStrPIDO).  We seek
    // pIStream to each of the Type/Value pairs, creating CProperites
    // and so forth as we go...
    //
    pIStream->Clone(&pIStrPIDO);

    // Read the propid /offset structures first

    DWORD dwCnt;
    PROPERTYIDOFFSET * pArray = new PROPERTYIDOFFSET[m_SH.cProperties];
    if(pArray == NULL)
        return FALSE;   //TODO 

    for(dwCnt = 0; dwCnt < m_SH.cProperties; dwCnt++) {
        pIStrPIDO->Read((LPVOID)&pArray[dwCnt], sizeof(PROPERTYIDOFFSET), &cb);
        if (cb != sizeof(PROPERTYIDOFFSET))
            {
            pIStrPIDO->Release();
            delete pArray;
            return FALSE;
            }
        }
    pIStrPIDO->Release();
    
    // Now read in the actual properties

    for(dwCnt = 0; dwCnt < m_SH.cProperties; dwCnt++)
    {
        
        DWORD dwSize;

        // Do a seek from the beginning of the property set.
        LISet32(li, ulSectionStart.LowPart + pArray[dwCnt].dwOffset);
        pIStream->Seek(liPropSet, STREAM_SEEK_SET, NULL);
        pIStream->Seek(li, STREAM_SEEK_CUR, NULL);

        // Now pIStream is at the type/value pair
        pProp = new CProp();        //todo, error checking???
        pProp->Set(pArray[dwCnt].propertyID, NULL, 0,0);
        if(dwCnt < m_SH.cProperties-1)
            dwSize = pArray[dwCnt+1].dwOffset - pArray[dwCnt].dwOffset -
                        sizeof(DWORD);
        else
            dwSize = /*ulSectionStart.LowPart +*/ m_SH.cbSection - 
                     pArray[dwCnt].dwOffset - sizeof(DWORD);

        ASSERT(dwSize < 1000);
        pProp->ReadFromStream(pIStream,dwSize);
        m_PropList.AddTail(pProp);
    }
    
    delete pArray;
    return TRUE;
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CPropSection::SetSectionName(LPCTSTR pszName)
{
    m_strSectionName = pszName;
    return TRUE;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

LPCTSTR CPropSection::GetSectionName()
{
    return (LPCTSTR)m_strSectionName;
}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSet::CPropSet()
{
    m_PH.wByteOrder = 0xFFFE;
    m_PH.wFormat = 0;
    m_PH.dwOSVer = (DWORD)MAKELONG(LOWORD(GetVersion()), 2);
    m_PH.clsID =  GUID_NULL;
    m_PH.cSections = 0;

}


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSet::~CPropSet()
{   RemoveAll();  }


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSet::RemoveAll()
{
    POSITION pos = m_SectionList.GetHeadPosition();
    while (pos != NULL)
    {
        delete (CPropSection*)m_SectionList.GetNext(pos);
    }
    m_SectionList.RemoveAll();
    m_PH.cSections = 0;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSection* CPropSet::GetSection(CLSID FormatID)
{
    POSITION pos = m_SectionList.GetHeadPosition();
    CPropSection* pSect;
    while (pos != NULL)
    {
        pSect = (CPropSection*)m_SectionList.GetNext(pos);
        if (IsEqualCLSID(pSect->m_FormatID, FormatID))
            return pSect;
    }
    return NULL;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CPropSection* CPropSet::AddSection(CLSID FormatID)
{
    CPropSection* pSect = GetSection(FormatID);
    if (pSect)
        return pSect;

    pSect = new CPropSection(FormatID);
    if (pSect)
        AddSection(pSect);
    return pSect;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSet::AddSection(CPropSection* pSect)
{
    m_SectionList.AddTail(pSect);
    m_PH.cSections++;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CProp* CPropSet::GetProperty(CLSID FormatID, DWORD dwPropID)
{
    CPropSection* pSect = GetSection(FormatID);
    if (pSect)
        return pSect->GetProperty(dwPropID);
    else
        return NULL;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSet::AddProperty(CLSID FormatID, CProp* pProp)
{
    CPropSection* pSect = GetSection(FormatID);
    if(pSect == NULL)
        pSect = AddSection(FormatID);
    if (pSect)
        pSect->AddProperty(pProp);
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

WORD CPropSet::GetByteOrder()
{   return m_PH.wByteOrder;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

WORD CPropSet::GetFormatVersion()
{   return m_PH.wFormat;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSet::SetFormatVersion(WORD wFmtVersion)
{   m_PH.wFormat = wFmtVersion;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

DWORD CPropSet::GetOSVersion()
{   return m_PH.dwOSVer;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSet::SetOSVersion(DWORD dwOSVer)
{   m_PH.dwOSVer = dwOSVer;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CLSID CPropSet::GetClassID()
{   return m_PH.clsID;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CPropSet::SetClassID(CLSID clsID)
{   m_PH.clsID = clsID;  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

DWORD CPropSet::GetCount()
{   return m_SectionList.GetCount();  }

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CObList* CPropSet::GetList()
{   return &m_SectionList;  }


//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CPropSet::WriteToStream(IStream* pIStream)
{
    LPSTREAM        pIStrFIDO;
    FORMATIDOFFSET  fido;
    ULONG           cb;
    ULARGE_INTEGER  ulSeek;
    LARGE_INTEGER   li;
    LISet32(li, 0);
    pIStream->Seek(li,STREAM_SEEK_SET,NULL);

    // Write the Property List Header
    m_PH.cSections = m_SectionList.GetCount();
    pIStream->Write((LPVOID)&m_PH, sizeof(m_PH), &cb);
    if (sizeof(m_PH) != cb)
    {
        TRACE0("Write of Property Set Header failed.\n");
        return FALSE;
    }

    if (m_SectionList.IsEmpty())
    {
        TRACE0("Warning: Wrote empty property set.\n");
        return TRUE;
    }

    // After the header is the list of Format ID/Offset pairs
    // Since there is an ID/Offset pair for each section and we
    // need to write the ID/Offset pair as we write each section
    // we clone the stream and use the clone to access the
    // table of ID/offset pairs (FIDO)...
    //
    pIStream->Clone(&pIStrFIDO);

    // Now seek pIStream past the FIDO list
    //
    LISet32(li, m_PH.cSections * sizeof(FORMATIDOFFSET));
    pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);

    // Write each section.
    CPropSection*   pSect = NULL;
    POSITION            pos = m_SectionList.GetHeadPosition();
    while (pos != NULL)
    {
        // Get next element (note cast)
        pSect = (CPropSection*)m_SectionList.GetNext(pos);

        // Write it
        if (!pSect->WriteToStream(pIStream))
        {
            pIStrFIDO->Release();
            return FALSE;
        }

        // Using our cloned stream write the Format ID / Offset pair
        fido.formatID = pSect->m_FormatID;
        fido.dwOffset = ulSeek.LowPart;
        pIStrFIDO->Write((LPVOID)&fido, sizeof(fido), &cb);
        if (sizeof(fido) != cb)
        {
            TRACE0("Write of 'fido' failed.\n");
            pIStrFIDO->Release();
            return FALSE;
        }

        // Get the seek offset (for pIStream) after the write
        LISet32(li, 0);
        pIStream->Seek(li, STREAM_SEEK_CUR, &ulSeek);
    }

    pIStrFIDO->Release();

    return TRUE;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

BOOL CPropSet::ReadFromStream(IStream* pIStream)
{
    ULONG               cb;
    FORMATIDOFFSET      fido;
    ULONG               cSections;
    LPSTREAM            pIStrFIDO;
    CPropSection*   pSect;
    LARGE_INTEGER       li;
    LARGE_INTEGER       liPropSet;

    LISet32(li, 0);
    pIStream->Seek(li,STREAM_SEEK_SET,NULL);
    // Save the stream position at which the property set starts.
    LARGE_INTEGER liZero = {0,0};
    pIStream->Seek(liZero, STREAM_SEEK_CUR, (ULARGE_INTEGER*)&liPropSet);

    if (m_PH.cSections || !m_SectionList.IsEmpty())
         RemoveAll();

    // The stream starts like this:
    //  wByteOrder   wFmtVer   dwOSVer   clsID  cSections
    // Which is nice, because our PROPHEADER is the same!
    pIStream->Read((LPVOID)&m_PH, sizeof(m_PH), &cb);
    if (cb != sizeof(m_PH))
        return FALSE;

    // Now we're pointing at the first of the FormatID/Offset pairs
    // (FIDOs).   To get to each section we use a cloned stream
    // to stay back and point at the FIDOs (pIStrFIDO).  We seek
    // pIStream to each of the sections, creating CProperitySection
    // and so forth as we go...
    //
    pIStream->Clone(&pIStrFIDO);

    cSections = m_PH.cSections;
    while (cSections--)
    {
        pIStrFIDO->Read((LPVOID)&fido, sizeof(fido), &cb);
        if (cb != sizeof(fido))
        {
            pIStrFIDO->Release();
            return FALSE;
        }

        // Do a seek from the beginning of the property set.
        LISet32(li, fido.dwOffset);
        pIStream->Seek(liPropSet, STREAM_SEEK_SET, NULL);
        pIStream->Seek(li, STREAM_SEEK_CUR, NULL);

        // Now pIStream is at the type/value pair
        pSect = new CPropSection;
        pSect->SetFormatID(fido.formatID);
        pSect->ReadFromStream(pIStream, liPropSet);
        m_SectionList.AddTail(pSect);
    }

    pIStrFIDO->Release();
    return TRUE;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CBuff::CBuff( void )
{
    bAllocError = FALSE;
    pBuff = NULL;
    dwSize = 0;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

CBuff::~CBuff()
{
    if(pBuff)
        CoTaskMemFree(pBuff);
    pBuff = NULL;
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CBuff::Add(void * pSrc, DWORD dwAddSize)
{
    char * pDest;
    if(pBuff == NULL) {
        pBuff = CoTaskMemAlloc(dwAddSize);
        if(pBuff == NULL) {
            bAllocError = TRUE;
            return;
            }
        pDest = (char *)pBuff;
        dwSize = dwAddSize;    
        }
    else {
        void * pNew;
        pNew = CoTaskMemRealloc(pBuff,dwSize+dwAddSize);
        if(pNew == NULL) {
            bAllocError = TRUE;
            return;
            }
        pBuff = pNew;
        pDest = (char *)pBuff + dwSize;
        dwSize += dwAddSize;
        }
    memcpy(pDest,pSrc,dwAddSize);
}

//***************************************************************************
//
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//***************************************************************************

void CBuff::RoundOff(void)
{
    DWORD dwLeftOver = dwSize % 4;
    if(dwLeftOver) {
        DWORD dwAdd = 4 - dwLeftOver;
        DWORD dwZero = 0;
        Add((void *)&dwZero,dwAdd);
        }
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\impdyn.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    IMPDYN.CPP

Abstract:

	Defines the virtual base class for the Dynamic Provider
	objects.  The base class is overriden for each specific
	provider which provides the details of how an actual
	property "Put" or "Get" is done.

History:

	a-davj  27-Sep-95   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
//#define _MT

#include <process.h>
#include "impdyn.h"
#include "CVariant.h"
#include <genlex.h>
#include <objpath.h>
#include <genutils.h>
#include <cominit.h>

//***************************************************************************
//
// CImpDyn::CImpDyn
//
// DESCRIPTION:
//
// Constructor.
//
// PARAMETERS:
//
// ObjectPath           Full path to the namespace
// User                 User name
// Password             Password
//
//***************************************************************************

CImpDyn::CImpDyn() : m_pGateway(NULL), m_cRef(0)
{
    wcCLSID[0] = 0;       // Set to correct value in derived class constructors
}

HRESULT STDMETHODCALLTYPE CImpDyn::Initialize(LPWSTR wszUser, long lFlags,
                LPWSTR wszNamespace, LPWSTR wszLocale, 
                IWbemServices* pNamespace, IWbemContext* pContext, 
                IWbemProviderInitSink* pSink)
{
    m_pGateway = pNamespace;
    m_pGateway->AddRef();
    pSink->SetStatus(WBEM_S_NO_ERROR, 0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CImpDyn::~CImpDyn
//
// DESCRIPTION:
//
// Destructor.
//
//***************************************************************************

CImpDyn::~CImpDyn(void)
{
    if(m_pGateway)
        m_pGateway->Release();
    return;
}

//***************************************************************************
//
// SCODE CImpDyn::CreateInstanceEnum
//
// DESCRIPTION:
//
// Creates an enumerator object that can be used to enumerate 
// the instances of this class.
//
// PARAMETERS:
//
// Class                Path specifying the class to be enumerated
// lFlags               flags to control the enumeration
// phEnum               returned pointer to enumerator 
// ppErrorObject        returned pointer to error object
//
// RETURN VALUE:
//
// S_OK                 if all is well
// WBEM_E_OUT_OF_MEMORY  if not enough memory
// various error codes from IWbemServices::GetObject
//
//***************************************************************************

SCODE CImpDyn::CreateInstanceEnum(
                        IN const BSTR Class, 
                        IN long lFlags, 
						IWbemContext  *pCtx,
                        OUT IN IEnumWbemClassObject FAR* FAR* phEnum)
{
    CEnumInst * pEnumObj;
    SCODE sc;
    WCHAR * pwcClassContext = NULL;
    IWbemClassObject * pClassInt = NULL;
    CEnumInfo * pInfo = NULL;

    // Get the class

    sc = m_pGateway->GetObject(Class,0, pCtx, &pClassInt,NULL);
    if(sc != S_OK)
		return sc;

    // Get the class context string

    sc = GetAttString(pClassInt, NULL, L"classcontext", &pwcClassContext);
    pClassInt->Release();
    if(sc != S_OK)
		return sc;

    // Get the info needed for enumeration.  This is overrided by any 
    // provider that supports dynamic instances.
    
    CProvObj ProvObj(pwcClassContext,MAIN_DELIM, NeedsEscapes());

    sc = MakeEnum(pClassInt,ProvObj,&pInfo);
    delete pwcClassContext;
	
    if(sc != S_OK)
        return sc;

    pEnumObj=new CEnumInst(pInfo,lFlags,Class,m_pGateway,this, pCtx);
    if(pEnumObj == NULL) 
    {
        delete pInfo;
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Once the enumerator object is created, it owns the info object and
    // will free it appropriatly

    sc = pEnumObj->QueryInterface(IID_IEnumWbemClassObject,(void **) phEnum);
    if(FAILED(sc))
        delete pEnumObj;

    return sc;

}

//***************************************************************************
//
// CreateInstanceEnumAsyncThread
//
// DESCRIPTION:
//
// Routine for which does the work and sends the
// subsequent notify for the Instance provider's CreateInstanceEnumAsync
// routine.
//
// PARAMETERS:
//
// pIEnum               Our enumerator
// pSink             Core's sink
// pGateway             IWbemServices pointer to the core
// pCtx                 context to be used.
//
//***************************************************************************

void CreateInstanceEnumAsyncThread(   IEnumWbemClassObject FAR* pIEnum,
   IWbemObjectSink FAR* pSink, IWbemServices FAR *  pGateway,    IWbemContext  *pCtx)
{
    IWbemClassObject * pNewInst = NULL;
    SCODE sc = S_OK;

    // enumerate and send each object to the notify interface

    while (sc == S_OK) 
    {
        ULONG uRet;
        sc = pIEnum->Next(-1, 1,&pNewInst,&uRet);
        if(sc == S_OK) 
        {
            pSink->Indicate(1,&pNewInst);
            pNewInst->Release();
        }
    }

    pSink->SetStatus(0,0,NULL, NULL);

}


//***************************************************************************
//
// SCODE CInstPro::CreateInstanceEnumAsync
//
// DESCRIPTION:
//
// Asynchronously enumeratres the instances of this class.
//
// PARAMETERS:
//
// RefStr               Path which defines the object class
// lFlags               enumeration flags
// pSink             Pointer to the notify object
// plAsyncRequestHandle pointer to the enumeration cancel handle (future use)
//
// RETURN VALUE:
//
// S_OK                 All is well
// WBEM_E_INVALID_PARAMETER  Bad argument
// WBEM_E_OUT_OF_MEMORY  Lacked resources to create a thread
// otherwise, error from CreateInstanceEnum
//
//***************************************************************************

SCODE CImpDyn::CreateInstanceEnumAsync(
                        IN const BSTR RefStr,
                        IN long lFlags,
						IWbemContext __RPC_FAR *pCtx,
                        OUT IWbemObjectSink FAR* pSink)
{
    SCODE sc = S_OK;
    IEnumWbemClassObject * pIEnum = NULL;
    if(pSink == NULL || RefStr == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
        sc = WbemCoImpersonateClient();

    if(sc == S_OK)
        sc = CreateInstanceEnum(RefStr,lFlags, pCtx, &pIEnum);
    if(sc != S_OK) 
    {
        pSink->SetStatus(0, sc, NULL, NULL);
        return S_OK;
    }
    CreateInstanceEnumAsyncThread(pIEnum, pSink, m_pGateway, pCtx);
    pIEnum->Release();

    return S_OK;
}

//***************************************************************************
//
// SCODE CImpDyn::CreateClassEnumAsync
//
// DESCRIPTION:
//
// Asynchronously enumeratres the classes that this provider supplies.  This is
// acutally just a ruse to get the core to load the dll.
//
// PARAMETERS:
//
// SuperClass           Parent to be enumerated.
// lFlags               enumeration flags
// pResponseHandler     Pointer to the notify object
// plAsyncRequestHandle pointer to the enumeration cancel handle (future use)
//
// RETURN VALUE:
//
// S_OK                 All is well
//
//***************************************************************************

IWbemServices * gGateway;

SCODE CImpDyn::CreateClassEnumAsync(BSTR Superclass,  long lFlags,IWbemContext *pCtx, IWbemObjectSink FAR* pResponseHandler)
{
	return E_NOTIMPL;
}


//***************************************************************************
//
// SCODE CImpDyn::GetObject
//
// DESCRIPTION:
//
// Creates an instance given a particular path value.
//
// PARAMETERS:
//
// ObjectPath           Object path
// lFlags               flags
// pObj                 Set to point to the created object
// ppErrorObject        Optional error object pointer
//
// RETURN VALUE:
//
// S_OK                 All is well
// WBEM_E_NOT_FOUND      bad path
// otherwise the return code from CreateInst
//
//***************************************************************************

SCODE CImpDyn::GetObject(
                        IN BSTR ObjectPath,
                        IN long lFlags,
						IWbemContext *pCtx,
                        OUT IWbemClassObject FAR* FAR* pObj,
						IWbemCallResult  **ppCallResult)
{
    SCODE sc = S_OK;
    
    // Parse the object path.
    // ======================

    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;

    int nStatus = p.Parse(ObjectPath, &pOutput);

    if(nStatus != 0)
        return ReturnAndSetObj(WBEM_E_NOT_FOUND, ppCallResult);

    WCHAR wcKeyValue[BUFF_SIZE];
    
    sc = WBEM_E_NOT_FOUND;
    
    if(pOutput->m_dwNumKeys > 0 || pOutput->m_bSingletonObj)
    {


        if(pOutput->m_bSingletonObj)
            wcscpy(wcKeyValue,L"@");
        else
        {
            KeyRef *pTmp = pOutput->m_paKeys[0];
        
            switch (V_VT(&pTmp->m_vValue))
            {
                case VT_I4:
                    swprintf(wcKeyValue, L"%d", V_I4(&pTmp->m_vValue));
                    break;
                case VT_BSTR:
                    wcsncpy(wcKeyValue, V_BSTR(&pTmp->m_vValue), BUFF_SIZE-1);
                    break;
                default:
                    wcscpy(wcKeyValue, L"<unknown>");;
            }
        }
        sc = CreateInst(m_pGateway,pOutput->m_pClass,wcKeyValue,pObj, NULL, NULL, pCtx);

    }

    
    // Create the instance.
    
    p.Free(pOutput);
    return ReturnAndSetObj(sc, ppCallResult);
}

//***************************************************************************
//
// GetObjectAsyncThread
//
// DESCRIPTION:
//
// Routine for the thread which does the work and sends the
// subsequent notify to the Instance provider's GetObjectAsync
// routine.
//
// PARAMETERS:
//
// pTemp                pointer to the argument structure
//
//***************************************************************************

void GetObjectAsyncThread(WCHAR * pObjPath, long lFlags, IWbemObjectSink FAR* pSink,
                          CImpDyn * pThis, IWbemContext  *pCtx)
{

    IWbemClassObject FAR* pNewInst = NULL;

    SCODE sc = pThis->GetObject(pObjPath, lFlags, pCtx, &pNewInst, NULL);
    if(sc == WBEM_NO_ERROR) 
    {
        pSink->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    pSink->SetStatus(0, sc, NULL, NULL);
}


//***************************************************************************
//
// SCODE CInstPro::GetObjectAsync
//
// DESCRIPTION:
//
// Asynchronously gets an instance of this class.
//
// PARAMETERS:
//
// RefStr               Path which defines the object class
// lFlags               enumeration flags
// pSink             Pointer to the notify object
// plAsyncRequestHandle pointer to the enumeration cancel handle (future use)
//
// RETURN VALUE:
//
// S_OK                 All is well
// WBEM_E_INVALID_PARAMETER  Bad argument
// WBEM_E_OUT_OF_MEMORY  Lacked resources to create a thread
//
//***************************************************************************

SCODE CImpDyn::GetObjectAsync(
                        IN BSTR ObjPath,
                        IN long lFlags,
						IWbemContext __RPC_FAR *pCtx,
                        IN IWbemObjectSink FAR* pSink)
{
    if(pSink == NULL || ObjPath == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
    {
        SCODE sc = WbemCoImpersonateClient();
        if(sc != S_OK) 
        {
            pSink->SetStatus(0, sc, NULL, NULL);
            return S_OK;
        }
    }

    GetObjectAsyncThread(ObjPath, lFlags, pSink, this, pCtx);
    return S_OK;
}

//***************************************************************************
//
// SCODE CImpDyn::StartBatch
//
// DESCRIPTION:
//
// Called at the start of a batch of gets or puts.  Overriden by
// derived classes which need to do something.  
//
// PARAMETERS:
//
// lFlags               flags
// pClassInt            Points to an instance object
// pObj                 Misc object pointer
// bGet                 TRUE if we will be getting data.
//
// RETURN VALUE:
//
// S_OK
//***************************************************************************

SCODE CImpDyn::StartBatch(
                        IN long lFlags,
                        IN IWbemClassObject FAR * pClassInt,
                        IN CObject **pObj,
                        IN BOOL bGet)
{
    *pObj = NULL;
    return S_OK;
}

//***************************************************************************
//
// CImpDyn::EndBatch
//
// DESCRIPTION:
//
// Called at the end of a batch of gets or puts.  Overriden by
// derived classes which need to do something.  
//
// lFlags               flags
// pClassInt            Points to an instance object
// pObj                 Misc object pointer
// bGet                 TRUE if we will be getting data.
//
// RETURN VALUE:
//
// S_OK
//***************************************************************************

void CImpDyn::EndBatch(
                        IN long lFlags,
                        IN IWbemClassObject FAR * pClassInt,
                        IN CObject *pObj,
                        IN BOOL bGet)
{
    if(pObj)
        delete pObj;
}

//***************************************************************************
// HRESULT CImpDyn::QueryInterface
// long CImpDyn::AddRef
// long CImpDyn::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CImpDyn::QueryInterface(
                        IN REFIID riid, 
                        OUT PPVOID ppv)
{
    *ppv=NULL;
    
    // The only calls for IUnknown are either in a nonaggregated
    // case or when created in an aggregation, so in either case
    // always return our IUnknown for IID_IUnknown.

    if (IID_IUnknown==riid || IID_IWbemServices == riid)
        *ppv=(IWbemServices*)this;
    else if (IID_IWbemProviderInit==riid)
        *ppv=(IWbemProviderInit*)this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
 }


STDMETHODIMP_(ULONG) CImpDyn::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CImpDyn::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;

    /*
     * Tell the housing that an object is going away so it can
     * shut down if appropriate.
     */
    delete this; // do before decrementing module obj count.
    InterlockedDecrement(&lObj);
    return 0;
}

//***************************************************************************
//
// CImpDyn::EnumPropDoFunc
//
// DESCRIPTION:
//
// This gets an objects attributes and then loops through the propeties
// calling UpdateProperty or RefreshProperty to put or get the data.
//
// PARAMETERS:
//
// lFlags               flags
// pClassInt            Object being refreshed or updated
// FuncType             Indicates if refresh or update
// pwcKey               Optional Key value of the object
// pCache               Option cache
//
// RETURN VALUE:
//
// S_OK                 all is well
// otherwise an WBEMSVC type error.
//
//***************************************************************************

SCODE CImpDyn::EnumPropDoFunc(
                        IN long lFlags,
                        OUT IN IWbemClassObject FAR* pInstance,
                        IN FUNCTYPE FuncType,
                        IN WCHAR * pwcKey,
                        OUT IN CIndexCache * pCache,
                        IN IWbemClassObject * pClass)
{

    SCODE sc;
    BSTR PropName;
    WCHAR * pwcClassContext =  NULL;
    WCHAR * pwcKeyValue = NULL;
    WCHAR * pwcTemp = NULL;
    BOOL bClsidSetForClass = FALSE;
    CProvObj * pProvObj = NULL;
    BSTR bstrKeyName = NULL;
    BOOL bGotOurClass = FALSE;
	int iWorked = 0;
    int iCurr = 0;
    CVariant vProp;
    BOOL bTesterDetails = FALSE;
	bool bAccessDenied = false;

    // Make sure we have a class object.  In some cases, such as enumeration, it
    // is passed.  In others, it must be obtained

    if(pClass == NULL)
    {
        VARIANT var;
        VariantInit(&var);
        sc = pInstance->Get(L"__Class",0,&var,NULL,NULL);
        if(sc != S_OK)
            return sc;
        if(m_pGateway == NULL)
            return WBEM_E_FAILED;
        sc = m_pGateway->GetObject(var.bstrVal,0, NULL, &pClass, NULL);
        VariantClear(&var);
        if(FAILED(sc)) 
            return sc;
        bGotOurClass = TRUE;
    }

    // Find out if expensive test data is desired

    {
        IWbemQualifierSet * pQualifier = NULL;
        CVariant var;

        sc = pClass->GetQualifierSet(&pQualifier); // Get instance Qualifier
        if(FAILED(sc))
            return sc;

        sc = pQualifier->Get(L"TesterDetails" ,0,var.GetVarPtr(), NULL);
        pQualifier->Release();     // free up the interface
        if(sc == S_OK && var.GetType() == VT_BOOL && var.bGetBOOL())
            bTesterDetails = TRUE;
    }


    CObject * pPackageObj = NULL;
    sc = StartBatch(lFlags,pInstance,&pPackageObj,FuncType == REFRESH);
    if(sc != S_OK)
        return WBEM_E_FAILED;

    sc = GetAttString(pClass, NULL, L"classcontext", &pwcClassContext);


    if(pwcKey)
    {
        // This is a special case and means that we are being called
        // as part of instance enumeration.  This means that the key value
        // is already known, and that the class is one of ours

        pwcKeyValue = pwcKey;
        bClsidSetForClass = TRUE;
    }
    else
    {
        
        // Get the Key property.  Note that this doesnt have to work since
        // there might be single instance classes supported by this provider!

        bstrKeyName = GetKeyName(pClass);

        if(bstrKeyName != NULL) 
        {
            sc = pInstance->Get(bstrKeyName,0,vProp.GetVarPtr(),NULL,NULL);
            SysFreeString(bstrKeyName);
            if(sc == S_OK) 
            {
                VARIANT * pTemp = vProp.GetVarPtr();
                if(pTemp->vt == VT_BSTR && pTemp->bstrVal != 0)
                {
                    
                    pwcKeyValue = new WCHAR[wcslen(vProp.GetBstr())+1];
                    if(pwcKeyValue == NULL) 
                    {
                        sc = WBEM_E_OUT_OF_MEMORY;
                        goto EnumCleanUp;
                    }
                    wcscpy(pwcKeyValue,vProp.GetBstr());
                }
            }
            vProp.Clear();
        }
    }

    // For each property, Get the properties Qualifiers and
    // call the appropriate function to do the a refreshing/updating

    pInstance->BeginEnumeration(0);

    while(WBEM_NO_ERROR == pInstance->Next(0,&PropName, vProp.GetVarPtr(), NULL, NULL)) 
    {
        vProp.Clear();
        pwcTemp = NULL;
        sc = GetAttString(pClass, PropName, L"propertycontext", &pwcTemp, pCache, iCurr);
        iCurr++;
        if(sc== S_OK) 
        {
            LPWSTR pwcFullContext =  NULL;
            sc = MergeStrings(&pwcFullContext,pwcClassContext,pwcKeyValue,pwcTemp);
            if(pwcTemp)
            {
                delete pwcTemp;
                pwcTemp = NULL;
            }
            if(sc == S_OK) 
            {
                if(pProvObj == NULL)
                {
                    pProvObj = new CProvObj(pwcFullContext,MAIN_DELIM,NeedsEscapes());
                    if(pProvObj == NULL)
                    {
                        sc = WBEM_E_OUT_OF_MEMORY;
                        break;
                    }
                }
                else if (!pProvObj->Update(pwcFullContext))
                {
                    sc = WBEM_E_FAILED;
                    break;
                }

                sc = pProvObj->dwGetStatus(iGetMinTokens());

                if(FuncType == REFRESH && sc == S_OK)
				{
                    sc = RefreshProperty(lFlags,pInstance,
                        PropName, *pProvObj, pPackageObj, NULL,bTesterDetails);
					if(sc == S_OK)
							iWorked++;
					else if (sc == 5)
						bAccessDenied = true;
				}
                 else if(FuncType == UPDATE && sc == S_OK)
				 {
                    sc = UpdateProperty(lFlags,pInstance,
                        PropName,  *pProvObj, pPackageObj, NULL);
					if(sc == S_OK)
							iWorked++;
					else if (sc == 5)
						bAccessDenied = true;
				 }
                if(pwcFullContext)
                    delete pwcFullContext;
            }
        }
        else
            sc = S_OK;  // ignore props without propertyContext
        SysFreeString(PropName);
    }  
 
EnumCleanUp:
	if(iWorked > 0)
		sc = S_OK;
    else if(bAccessDenied)
		sc = WBEM_E_ACCESS_DENIED;
	else
        sc = WBEM_E_INVALID_OBJECT_PATH;
    if(pProvObj)
        delete pProvObj;
    if(pwcTemp)
        delete pwcTemp;  
    if(pwcClassContext)
        delete pwcClassContext;  
    if(pwcKeyValue && pwcKey == NULL)
        delete pwcKeyValue;  
    if(bGotOurClass)
        pClass->Release();
    EndBatch(lFlags,pInstance,pPackageObj,FuncType == REFRESH); 
    return sc;
}

//***************************************************************************
//
// SCODE CImpDyn::GetAttString
//
// DESCRIPTION:
//
// Gets an Qualifier string.  The string is will be pointed to by 
// the ppResult argument and should be freed by "delete".
//
// PARAMETERS:
//
// pClassInt            Class object pointer
// pPropName            Property Name, could be null if going after
//                      class attribute
// pAttName             Attribute name
// ppResult             Set to point to the retuned value.
// pCache               Optional cache of values
// iIndex               Optional index in the cache
//
// RETURN VALUE:
//
// S_OK                 all is well
// WBEM_E_OUT_OF_MEMORY  
// otherwise the error is set by the class object's GetQualifierSet function
// or by the qualifier sets "Get" function.
//
//***************************************************************************

SCODE CImpDyn::GetAttString(
                        IN IWbemClassObject FAR* pClassInt,
                        IN LPWSTR pPropName, 
                        IN LPWSTR pAttName,
                        OUT IN LPWSTR * ppResult,
                        OUT IN CIndexCache * pCache,
                        IN int iIndex)
{
    SCODE sc;
    IWbemQualifierSet * pQualifier = NULL;
    CVariant var;

    if(*ppResult)
        delete *ppResult;
    *ppResult = NULL;

    // if there is a cache, try to get it from there
    if(pCache && iIndex != -1)
    {
        *ppResult = pCache->GetWString(iIndex);
        if(*ppResult != NULL)
            return S_OK;
    }
    // Get an Qualifier set interface.

    if(pPropName == NULL)
        sc = pClassInt->GetQualifierSet(&pQualifier); // Get instance Qualifier
    else
        sc = pClassInt->GetPropertyQualifierSet(pPropName,&pQualifier); // Get prop att
    if(FAILED(sc))
        return sc;

    // Get the string and free the Qualifier interface

    sc = pQualifier->Get(pAttName,0,var.GetVarPtr(), NULL);
    pQualifier->Release();     // free up the interface
    if(FAILED(sc))
        return sc;

    // make sure the type is OK

    if(var.GetType() != VT_BSTR) 
        return WBEM_E_FAILED;

    // Allocate data for the buffer and copy the results

    *ppResult = new WCHAR[wcslen(var.GetBstr())+1];
    if(*ppResult) 
    {
        wcscpy(*ppResult,var.GetBstr());
        sc = S_OK;
    }
    else
        sc = WBEM_E_OUT_OF_MEMORY;

    // If there is a cache, add this to it

    if(pCache && iIndex != -1 && *ppResult)
    {
        pCache->SetAt(*ppResult, iIndex);
    }

    return sc;

}

//***************************************************************************
//
// BSTR CImpDyn::GetKeyName
//
// DESCRIPTION:
//
// Gets the name of the property with the the key Qualifier.
//
// PARAMETERS:
//
// pClassInt            Class object pointer
//
// RETURN VALUE:
//
// NULL if error,
// other wise a BSTR which the caller must free
//
//***************************************************************************

BSTR CImpDyn::GetKeyName(
                        IN IWbemClassObject FAR* pClassInt)
{
    IWbemQualifierSet * pQualifier = NULL;
    BSTR PropName = NULL;
    pClassInt->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);


    // Loop through each of the properties and stop once one if found that
    // has a "Key" Qualifier

    while(WBEM_NO_ERROR == pClassInt->Next(0,&PropName,NULL, NULL, NULL)) 
    {
        return PropName;
    }
    return NULL;
}

//***************************************************************************
//
// SCODE CImpDyn::PutInstanceAsync
//
// DESCRIPTION:
//
// PutInstaceAsync writes instance data out.
//
// PARAMETERS:
//
// pClassInt            Class Object pointer
// lFlags               flags.
// pCtx                 Context object, not used anymore.
// pResponseHandler     Where to set the return code.
//
// RETURN VALUE:
//
// Set by EnumPropDoFunc
//
//***************************************************************************

STDMETHODIMP CImpDyn::PutInstanceAsync(
 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    SCODE sc = S_OK;
    if(pInst == NULL || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
        sc = WbemCoImpersonateClient();
    if(sc == S_OK)
        sc = EnumPropDoFunc(lFlags,pInst,UPDATE);

    // Set the status

    pResponseHandler->SetStatus(0,sc, NULL, NULL);
    return sc;

}

//***************************************************************************
//
// SCODE CImpDyn::ExecMethodAsync
//
// DESCRIPTION:
//
// Executes methods.
//
// PARAMETERS:
//
// pClassInt            Class Object pointer
// lFlags               flags.
// pCtx                 Context object, not used anymore.
// pResponseHandler     Where to set the return code.
//
// RETURN VALUE:
//
// Set by EnumPropDoFunc
//
//***************************************************************************

STDMETHODIMP CImpDyn::ExecMethodAsync(            
			/* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
 )
{

    return MethodAsync(ObjectPath, MethodName, 
            lFlags,pCtx, pInParams, pResponseHandler);

}
//***************************************************************************
//
// SCODE CImpDyn::RefreshInstance
//
// DESCRIPTION:
//
// gets fresh values for the properties.
//
// PARAMETERS:
//
// pClassInt            Class Object pointer
// lFlags               flags.
// ppErrorObject        Optional error object
//
// RETURN VALUE:
//
// Set by EnumPropDoFunc
//
//***************************************************************************

STDMETHODIMP CImpDyn::RefreshInstance(
                        IN long lFlags,
                        OUT IN IWbemClassObject FAR* pClassInt)
{
    return EnumPropDoFunc(lFlags,pClassInt,REFRESH);        
}

//***************************************************************************
//
// SCODE CImpDyn::CreateInst
//
// DESCRIPTION:
//
// Creates a new instance via the gateway provider and sets
// the inital values of the properties.
//
// PARAMETERS:
//
// pGateway             Pointer to WBEM 
// pwcClass             Class Name
// pKey                 Key value
// pNewInst             returned pointer to created instance
// pwcKeyName           Name of key property
// pCache               Optional cache
//
// RETURN VALUE:
//
// Return:   S_OK if all is well, 
// otherwise an error code is returned by either GetObject(most likely)
// or spawn instance.
//
//***************************************************************************

SCODE CImpDyn::CreateInst(
                        IN IWbemServices * pGateway,
                        IN LPWSTR pwcClass,
                        IN LPWSTR pKey,
                        OUT IN IWbemClassObject ** pNewInst,
                        IN LPWSTR pwcKeyName,
                        OUT IN CIndexCache * pCache,
                        IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass = NULL;
    

    // Create the new instance

    sc = pGateway->GetObject(pwcClass,0, pCtx, &pClass, NULL);
    if(FAILED(sc)) 
        return sc;
    sc = pClass->SpawnInstance(0, pNewInst);
    if(FAILED(sc)) 
    {
        pClass->Release();
        return sc;
    }
    // Set the key value.  Note that CVariant isnt used because
    // it assumes that the input is a TCHAR.

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(pKey);
    if(var.bstrVal == NULL)    
    {
 		(*pNewInst)->Release();
        pClass->Release();
        return WBEM_E_OUT_OF_MEMORY;
    }

    BSTR bstrKeyName;
    if(pwcKeyName == NULL)
        bstrKeyName = GetKeyName(*pNewInst);
    else
        bstrKeyName = SysAllocString(pwcKeyName);

    if(bstrKeyName != NULL) 
    {
        sc = (*pNewInst)->Put(bstrKeyName,0,&var,0);
        SysFreeString(bstrKeyName);
    }
    VariantClear(&var);
    // Use the RefreshInstance routine to set all the other properties

    sc = EnumPropDoFunc(0,*pNewInst,REFRESH, pKey,  pCache, pClass);
    pClass->Release();

	if (FAILED(sc))
		(*pNewInst)->Release();
    // Clean up

    return sc;
}

//***************************************************************************
//
// SCODE CImpDyn::MergeStrings
//
// DESCRIPTION:
//
// Combines the Class Context, Key, and Property Context strings.
//
// PARAMETERS:
//
// ppOut                output combined string, must be freed via delete
// pClassContext        class context
// pKey                 key value
// pPropContext         property context
//
// RETURN VALUE:
//
// S_OK                 if all is well, 
// WBEM_E_INVALID_PARAMETER no property context string or ppOut is NULL
// WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpDyn::MergeStrings(
                        OUT LPWSTR * ppOut,
                        IN LPWSTR  pClassContext,
                        IN LPWSTR  pKey,
                        IN LPWSTR  pPropContext)
{
    
    // Allocate space for output

    int iLen = 3;
    if(pClassContext)
        iLen += wcslen(pClassContext);
    if(pKey)
        iLen += wcslen(pKey);
    if(pPropContext)
        iLen += wcslen(pPropContext);
    else
        return WBEM_E_INVALID_PARAMETER;  // should always have this!
    if(ppOut == NULL)
        return WBEM_E_INVALID_PARAMETER;  // should always have this!

    *ppOut = new WCHAR[iLen];
    if(*ppOut == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // simple case is that everything is in the property context.  That would
    // be the case when the provider is being used as a simple dynamic 
    // property provider

    if(pClassContext == NULL || pKey == NULL) {
        wcscpy(*ppOut,pPropContext);
        return S_OK;
        }

    // Copy the class context, then search for the delimeter 

    wcscpy(*ppOut,pClassContext);
    WCHAR * pTest;
    for(pTest = *ppOut; *pTest; pTest++)
        if(*pTest == MAIN_DELIM)
            break;
    
     // Three cases;

    if(*pTest == NULL)
        wcscat(*ppOut,L"|");    // HKLM  BLA VALUE      add |
    else if( *(pTest +1))
        wcscat(*ppOut,L"\\");   // HKLM|BLA BLA VALUE   add \ 
    else;                       // HKLM| BLA VALUE      do nothing!
    
    wcscat(*ppOut,pKey);
    if(pPropContext[0] != L'|' && pPropContext[0] != L'\\')
        wcscat(*ppOut,L"|");
    wcscat(*ppOut,pPropContext);
    return S_OK;
}


//***************************************************************************
//
// SCODE CImpDyn::ReturnAndSetObj
//
// DESCRIPTION:
//
// Takes care of creating and setting an error object.
//
// PARAMETERS:
//
// sc                   value to set
// ppErrorObject        point which will point to the error object.
//
// RETURN VALUE:
//
// what ever was passed in.
//***************************************************************************

SCODE CImpDyn::ReturnAndSetObj(
                        IN SCODE sc,
                        OUT IN IWbemCallResult FAR* FAR* ppCallResult)
{
//    if(ppErrorObject)
//        *ppErrorObject = GetNotifyObj(m_pGateway,sc);
    return sc;
}


//***************************************************************************
//
// long CImpDyn::AddRef
//
// DESCRIPTION:
//
// Adds to the reference count.
//  
// RETURN VALUE:
//
// current reference count.
//
//***************************************************************************

long CEnumInfo::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//***************************************************************************
//
// long CImpDyn::Release
//
// DESCRIPTION:
//
// Interface has been released.  Object will be deleted if the
// usage count is zero.
//
// RETURN VALUE:
//
// current reference count.
//
//***************************************************************************

long CEnumInfo::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\impdynp.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    IMPDYNP.CPP

Abstract:

	Defines the virtual base class for the Property Provider
	objects.  The base class is overriden for each specific
	provider which provides the details of how an actual
	property "Put" or "Get" is done.

History:

	a-davj  27-Sep-95   Created.

--*/

#include "precomp.h"

//#define _MT
#include <process.h>
#include "impdyn.h"
#include "CVariant.h"
#include <genlex.h>
#include <objpath.h>
#include <genutils.h>
#include <cominit.h>

//***************************************************************************
//
//  CImpDynProp::CImpDynProp  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CImpDynProp::CImpDynProp()
{
    m_pImpDynProv = NULL;  // This is set in the derived class constructors.
    m_cRef=0;

    return;
}

//***************************************************************************
//
//  CImpDynProp::~CImpDynProp  
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CImpDynProp::~CImpDynProp(void)
{
    return;
}

//***************************************************************************
// HRESULT CImpDynProp::QueryInterface
// long CImpDynProp::AddRef
// long CImpDynProp::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CImpDynProp::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;
    
    // The only calls for IUnknown are either in a nonaggregated
    // case or when created in an aggregation, so in either case
    // always return our IUnknown for IID_IUnknown.

    if (IID_IUnknown==riid || IID_IWbemPropertyProvider == riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
 }

STDMETHODIMP_(ULONG) CImpDynProp::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CImpDynProp::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L != lRet)
        return lRet;

     // Tell the housing that an object is going away so it can
     // shut down if appropriate.
     
    delete this; // do before decrementing module obj count.
    InterlockedDecrement(&lObj);
    return 0;
}

//***************************************************************************
//
//  WCHAR * CImpDynProp::BuildString  
//
//  DESCRIPTION:
//
//  Creates a concatenation of the mapping strings.
//
//  PARAMETERS:
//
//  ClassMapping        Class Mapping string passed in by WBEM
//  InstMapping         Instance Mapping string passed in by WBEM
//  PropMapping         Property Mapping string passed in by WBEM
//
//  RETURN VALUE:
//
//  Pointer to the combined string.  This must be freed by the caller 
//  via "delete".  NULL is return if low memory.
//
//***************************************************************************

WCHAR * CImpDynProp::BuildString(
                        IN BSTR ClassMapping,
                        IN BSTR InstMapping,
                        IN BSTR PropMapping)
{

    int iLen = 3;
    if(ClassMapping)
        iLen += wcslen(ClassMapping);
        
    if(InstMapping)
        iLen += wcslen(InstMapping);
        
    if(PropMapping) 
        iLen += wcslen(PropMapping);

    WCHAR * pNew = new WCHAR[iLen]; 
    if(pNew == NULL)
        return NULL;

    *pNew = NULL;
    if(ClassMapping)
        wcscat(pNew, ClassMapping);

    if(InstMapping)
        wcscat(pNew, InstMapping);

    if(PropMapping)
        wcscat(pNew, PropMapping);

    return pNew;
 
}

//***************************************************************************
//
//  STDMETHODIMP CImpDynProp::PutProperty  
//
//  DESCRIPTION:
//
//  Writes data out to something like the registry.
//
//  PARAMETERS:
//
//  ClassMapping        Class Mapping string passed in by WBEM
//  InstMapping         Instance Mapping string passed in by WBEM
//  PropMapping         Property Mapping string passed in by WBEM
//  pvValue             Value to be put
//
//  RETURN VALUE:
//
//  S_OK                    all is well
//  WBEM_E_OUT_OF_MEMORY     low memory
//  WBEM_E_INVALID_PARAMETER missing tokens
//  otherwise error code from OMSVariantChangeType, or UpdateProperty
//
//***************************************************************************

STDMETHODIMP CImpDynProp::PutProperty(
					    long lFlags,
						const BSTR Locale,
                        IN const BSTR ClassMapping,
                        IN const BSTR InstMapping,
                        IN const BSTR PropMapping,
                        IN const VARIANT *pvValue)
{
    SCODE sc;
    if(IsNT())
    {
        sc = WbemCoImpersonateClient();
        if(FAILED(sc))
            return sc;
    }
    WCHAR * pNew = BuildString(ClassMapping, InstMapping, PropMapping);
    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(wcslen(pNew) == 3)
    {
        delete pNew;
        return WBEM_E_INVALID_PARAMETER;
    }

    CObject * pPackageObj = NULL;
    sc = m_pImpDynProv->StartBatch(0,NULL,&pPackageObj,FALSE);
    if(sc != S_OK) 
    {
        delete pNew;
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVariant cVar;
    sc = OMSVariantChangeType(cVar.GetVarPtr(), (VARIANT *)pvValue, 0, pvValue->vt);

    if(sc == S_OK)
    {
        CProvObj ProvObj(pNew,MAIN_DELIM,NeedsEscapes());

        sc = m_pImpDynProv->UpdateProperty(0,NULL, NULL, ProvObj, pPackageObj, &cVar);
    }
    delete pNew;

    m_pImpDynProv->EndBatch(0, NULL,pPackageObj, FALSE); 
    return sc;

}

//***************************************************************************
//
//  STDMETHODIMP CImpDynProp::GetProperty  
//
//  DESCRIPTION:
//
//  Gets data from something like the registry.
//
//  PARAMETERS:
//
//  ClassMapping        Class Mapping string passed in by WBEM
//  InstMapping         Instance Mapping string passed in by WBEM
//  PropMapping         Property Mapping string passed in by WBEM
//  pvValue             Value to be put
//
//  RETURN VALUE:
//
//  S_OK                    all is well
//  WBEM_E_OUT_OF_MEMORY     low memory
//  WBEM_E_INVALID_PARAMETER missing tokens
//  otherwise error code from RefreshProperty
//
//***************************************************************************

STDMETHODIMP CImpDynProp::GetProperty(
					    long lFlags,
						const BSTR Locale,
                        IN const BSTR ClassMapping,
                        IN const BSTR InstMapping,
                        IN const BSTR PropMapping,
                        OUT IN VARIANT *pvValue)
{
    SCODE sc;
    if(IsNT())
    {
        sc = WbemCoImpersonateClient();
        if(FAILED(sc))
            return sc;
    }

    WCHAR * pNew = BuildString(ClassMapping, InstMapping, PropMapping);
    memset((void *)&(pvValue->bstrVal),0,8);
    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(wcslen(pNew) == 3)
    {
        delete pNew;
        return WBEM_E_INVALID_PARAMETER;
    }

    CObject * pPackageObj = NULL;
    sc = m_pImpDynProv->StartBatch(0,NULL,&pPackageObj,TRUE);
    if(sc != S_OK) 
    {
        delete pNew;
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVariant cVar;
    CProvObj ProvObj(pNew,MAIN_DELIM,NeedsEscapes());

    sc = m_pImpDynProv->RefreshProperty(0, NULL, NULL, ProvObj, pPackageObj, &cVar, FALSE);

    if(sc == S_OK)
        sc = VariantCopy(pvValue, cVar.GetVarPtr());

    delete pNew;
    m_pImpDynProv->EndBatch(0,NULL,pPackageObj, TRUE); 
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\idynprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    IDYNPROV.H

Abstract:

	Declares the CProvStub class.

History:

	a-davj  04-Mar-97   Created.

--*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Thu Aug 10 09:54:39 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __idynprov_h__
#define __idynprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMoDynPropProvider_FWD_DEFINED__
#define __IMoDynPropProvider_FWD_DEFINED__
typedef interface IMoDynPropProvider IMoDynPropProvider;
#endif 	/* __IMoDynPropProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Aug 10 09:54:39 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 36 */
typedef struct  tagMODYNPROP
    {
    DWORD dwStructSize;
    OLECHAR __RPC_FAR *pPropertySetName;
    OLECHAR __RPC_FAR *pPropertyName;
    OLECHAR __RPC_FAR *pProviderString;
    DWORD dwType;
    BYTE __RPC_FAR *pPropertyValue;
    DWORD dwBufferSize;
    DWORD dwOptArrayIndex;
    DWORD dwResult;
    }	MODYNPROP;

			/* size is 4 */
typedef struct tagMODYNPROP __RPC_FAR *LPMODYNPROP;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMoDynPropProvider_INTERFACE_DEFINED__
#define __IMoDynPropProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMoDynPropProvider
 * at Thu Aug 10 09:54:39 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IMoDynPropProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMoDynPropProvider : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetProperties( 
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize) = 0;
        
        virtual HRESULT __stdcall SetProperties( 
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMoDynPropProviderVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMoDynPropProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMoDynPropProvider __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMoDynPropProvider __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetProperties )( 
            IMoDynPropProvider __RPC_FAR * This,
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize);
        
        HRESULT ( __stdcall __RPC_FAR *SetProperties )( 
            IMoDynPropProvider __RPC_FAR * This,
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize);
        
    } IMoDynPropProviderVtbl;

    interface IMoDynPropProvider
    {
        CONST_VTBL struct IMoDynPropProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMoDynPropProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMoDynPropProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMoDynPropProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMoDynPropProvider_GetProperties(This,pPropList,dwListSize)	\
    (This)->lpVtbl -> GetProperties(This,pPropList,dwListSize)

#define IMoDynPropProvider_SetProperties(This,pPropList,dwListSize)	\
    (This)->lpVtbl -> SetProperties(This,pPropList,dwListSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IMoDynPropProvider_GetProperties_Proxy( 
    IMoDynPropProvider __RPC_FAR * This,
    /* [in] */ LPMODYNPROP pPropList,
    /* [in] */ unsigned long dwListSize);


void __RPC_STUB IMoDynPropProvider_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoDynPropProvider_SetProperties_Proxy( 
    IMoDynPropProvider __RPC_FAR * This,
    /* [in] */ LPMODYNPROP pPropList,
    /* [in] */ unsigned long dwListSize);


void __RPC_STUB IMoDynPropProvider_SetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMoDynPropProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\impdyn.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    IMPDYN.H

Abstract:

	Declares the various generic provider classes.

History:

	a-davj  27-Sep-95   Created.

--*/

#ifndef _IMPDYN_H_
#define _IMPDYN_H_

#include "indexcac.h"
#include "cvariant.h"

typedef enum {REFRESH,UPDATE} FUNCTYPE;

typedef struct SET_STATUS{
    DWORD dwType;
    DWORD dwSize;
    DWORD dwResult;
    } STATSET, * PSETSTAT;

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumInfo
//
//  DESCRIPTION:
//
//  base class of various collection objects used to keep track of instances
//  for enumeration.
//
//***************************************************************************

class CEnumInfo : public CObject{
    public:
        CEnumInfo(){m_cRef = 1;};
        virtual ~CEnumInfo(){return;};
        long AddRef(void);
        long Release(void);
    private:
        long m_cRef;         //Object reference count
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpDyn
//
//  DESCRIPTION:
//
//  This is the base class of the instance providers.  It does quite a lot
//  though the actual getting and putting of data is overriden by derived
//  classes.
//
//***************************************************************************

class CImpDyn : public IWbemServices, public IWbemProviderInit
    {
    protected:
        long           m_cRef;         //Object reference count
        IWbemServices *  m_pGateway;
        WCHAR           wcCLSID[42];
        IWbemContext *   m_pCtx;
    public:
        CImpDyn();
        virtual ~CImpDyn(void);

        SCODE ReturnAndSetObj(SCODE sc, IWbemCallResult FAR* FAR* ppCallResult);
        virtual SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
                                 CEnumInfo ** ppInfo) { return E_NOTIMPL;};
        virtual SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey) 
                                 {return E_NOTIMPL;};

        BSTR GetKeyName(IWbemClassObject FAR* pClassInt);
        virtual int iGetMinTokens(void) = 0;
        virtual SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                                        BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
                                        CVariant * pVar, BOOL bTesterDetails) = 0;
        virtual SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                                        BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
                                        CVariant * pVar) = 0;
        virtual SCODE StartBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject **pObj,BOOL bGet);
        virtual void EndBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject *pObj,BOOL bGet);
        
        SCODE EnumPropDoFunc( long lFlags, IWbemClassObject FAR* pInstance, FUNCTYPE FuncType,
                              LPWSTR pwcKey = NULL,
                              CIndexCache * pCache = NULL,
                              IWbemClassObject * pClass = NULL);
        SCODE CImpDyn::GetAttString(IWbemClassObject FAR* pClassInt, LPWSTR pPropName, 
                                            LPWSTR pAttName, LPWSTR * ppResult,
                                            CIndexCache * pCache = NULL, int iIndex = -1);
        
        SCODE GetByKey( BSTR ClassRef, long lFlags, SAFEARRAY FAR* FAR* pKeyNames, SAFEARRAY FAR* FAR* pKeyValues, IWbemClassObject FAR* FAR* pObj);
        SCODE CreateInst( IWbemServices * pGateway, LPWSTR pwcClass, 
                              LPWSTR pKey, IWbemClassObject ** pNewInst,
                              LPWSTR pwcKeyName = NULL,
                              CIndexCache * pCache = NULL,
                              IWbemContext  *pCtx = NULL);
		virtual SCODE MethodAsync(BSTR ObjectPath, BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink){return WBEM_E_NOT_SUPPORTED;};

        virtual SCODE MergeStrings(LPWSTR *ppOut,LPWSTR  pClassContext,LPWSTR  pKey,LPWSTR  pPropContext);

        virtual bool NeedsEscapes(){return false;};     // so far, on reg prov needs this
    STDMETHOD_(SCODE, RefreshInstance)(THIS_  long lFlags, IWbemClassObject FAR* pObj);

    //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    /* IWbemProviderInit methods */
    
        HRESULT STDMETHODCALLTYPE Initialize(LPWSTR wszUser, long lFlags,
                LPWSTR wszNamespace, LPWSTR wszLocale, 
                IWbemServices* pNamespace, IWbemContext* pContext, 
                IWbemProviderInitSink* pSink);

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
						{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
   };

typedef CImpDyn *PCImpDyn;


//***************************************************************************
//
//  CLASS NAME:
//
//  CImpDynProp
//
//  DESCRIPTION:
//
//  This is the base class of the property providers.  It does quite a lot
//  though the actual getting and putting of data is overriden by derived
//  classes.
//
//***************************************************************************

class CImpDynProp : public IWbemPropertyProvider
    {
    protected:
        long            m_cRef;         //Object reference count
        WCHAR           wcCLSID[42];
        CImpDyn *       m_pImpDynProv;
        WCHAR * BuildString(BSTR ClassMapping, BSTR InstMapping, 
                                  BSTR PropMapping);
    public:
        CImpDynProp();
        virtual ~CImpDynProp(void);
        virtual bool NeedsEscapes(){return false;};     // so far, on reg prov needs this

    //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    
    /* IWbemPropertyProvider methods */

       virtual HRESULT STDMETHODCALLTYPE GetProperty( 
		    long lFlags,
		    const BSTR Locale,
            const BSTR ClassMapping,
            const BSTR InstMapping,
            const BSTR PropMapping,
            VARIANT *pvValue);
        
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
		    long lFlags,
		    const BSTR Locale,
            /* [in] */ const BSTR ClassMapping,
            /* [in] */ const BSTR InstMapping,
            /* [in] */ const BSTR PropMapping,
            /* [in] */ const VARIANT __RPC_FAR *pvValue);
    };



//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumInst
//
//  DESCRIPTION:
//
//  This class is used to enumerate instances
//
//***************************************************************************

class CEnumInst : public IEnumWbemClassObject
    {
    protected:
        int    m_iIndex;
        CEnumInfo * m_pEnumInfo;
        WCHAR * m_pwcClass;
        long m_lFlags;
        IWbemContext  * m_pCtx;
        

        IWbemServices FAR* m_pWBEMGateway;
        CImpDyn * m_pProvider;
        long           m_cRef;
        BSTR m_bstrKeyName;
        CIndexCache m_PropContextCache;
    public:
        CEnumInst(CEnumInfo * pEnumInfo,long lFlags,WCHAR * pClass,IWbemServices FAR* pWBEMGateway,
            CImpDyn * pProvider, IWbemContext  *pCtx);
        ~CEnumInst(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};
      
       /* IEnumWbemClassObject methods */

        HRESULT STDMETHODCALLTYPE Reset( void);
        
        HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [out] */ unsigned long __RPC_FAR *puReturned);
        
        HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ unsigned long uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long nNum);

    };
// This structure is passed to async enumerators

typedef struct {
   IEnumWbemClassObject FAR* pIEnum;
   IWbemObjectSink FAR* pHandler;
   } ArgStruct;

// this utility is useful for setting error objects and end of async calls

IWbemClassObject * GetNotifyObj(IWbemServices * pServices, long lRet, IWbemContext * pCtx);


#endif //_IMPDYN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\indexcac.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INDEXCAC.CPP

Abstract:

	Caches string/integer combinations.

History:

	a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "indexcac.h"

//***************************************************************************
//
//  CCacheEntry::CCacheEntry  
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pValue              string value to save
//  iIndex              integer value to save
//***************************************************************************

CCacheEntry::CCacheEntry(
                        TCHAR * pValue,
                        int iIndex) 
                        : CObject()
{
    m_iIndex = iIndex;
    m_ptcValue = pValue;
    m_pwcValue = NULL;
}

//***************************************************************************
//
//  CCacheEntry::CCacheEntry  
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pValue              string value to save
//  
//***************************************************************************

CCacheEntry::CCacheEntry(
                        WCHAR * pValue) 
                        : CObject()
{
    m_iIndex = -1;
    m_ptcValue = NULL;
    m_pwcValue = pValue;
}

//***************************************************************************
//
//  CCacheEntry::~CCacheEntry  
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CCacheEntry::~CCacheEntry()
{
    if(m_ptcValue)
        delete m_ptcValue;
    if(m_pwcValue)
        delete m_pwcValue;
}

//***************************************************************************
//
//  CIndexCache::CIndexCache  
//
//  DESCRIPTION:
//
//  Constructor.
//  
//***************************************************************************

CIndexCache::CIndexCache()
{

}

//***************************************************************************
//
//  void CIndexCache::Empty  
//
//  DESCRIPTION:
//
//  Frees up the storage.
//  
//***************************************************************************

void CIndexCache::Empty()
{
    CCacheEntry * pEntry;
    int iCnt, iSize;
    iSize = m_Array.Size();
    for(iCnt = 0; iCnt < iSize; iCnt++)
    {
        pEntry = (CCacheEntry *)m_Array.GetAt(iCnt);
        if(pEntry)
            delete pEntry;
    }
    if(iSize > 0)
        m_Array.Empty();

}

//***************************************************************************
//
//  int CIndexCache::Find  
//
//  DESCRIPTION:
//
//  Finds an entry in the cache.
//
//  PARAMETERS:
//
//  pFind               string value used to locate the entry
//  dwWhichEntry        a non zero value would return subsequent 
//                      matching entries.
//
//  RETURN VALUE:
//
//  index in cache.  -1 if the entry cant be found
//  
//***************************************************************************

int CIndexCache::Find(
                        IN const TCHAR * pFind, DWORD dwWhichEntry)
{
    CCacheEntry * pEntry;
    int iCnt, iSize;
    DWORD dwFound = 0;
    iSize = m_Array.Size();
    for(iCnt = 0; iCnt < iSize; iCnt++)
    {
        pEntry = (CCacheEntry *)m_Array.GetAt(iCnt);
        if(!lstrcmpi(pEntry->m_ptcValue, pFind))
            if(dwFound == dwWhichEntry)
                return pEntry->m_iIndex;
            else
                dwFound++;
    }
    return -1;  // never found it
}

//***************************************************************************
//
//  BOOL CIndexCache::Add  
//
//  DESCRIPTION:
//
//  Adds an entry to the cache.
//
//  PARAMETERS:
//
//  pAdd                string to add to cache
//  iIndex              associated number
//
//  RETURN VALUE:
//
//  
//***************************************************************************

BOOL CIndexCache::Add(
                        IN TCHAR * pAdd,
                        IN int iIndex)
{
    TCHAR * pValue = new TCHAR[lstrlen(pAdd)+1];

    if(pValue == NULL)
        return FALSE;
    lstrcpy(pValue, pAdd);

    // Note that if created, the CCacheEntry object owns the string and
    // will take care of freeing it

    CCacheEntry * pNew = new CCacheEntry(pValue, iIndex);
    if(pNew == NULL)
    {
        delete pValue;
        return FALSE;
    }
    int iRet = m_Array.Add(pNew);
	if(iRet == CFlexArray::no_error)
		return TRUE;
    {
        delete pNew;
        return FALSE;
    }
}


//***************************************************************************
//
//  WCHAR * CIndexCache::GetWString  
//
//  DESCRIPTION:
//
//  Gets a string from the cache.
//
//  PARAMETERS:
//
//  iIndex              cache index
//
//  RETURN VALUE:
//
//  pointer to string, does not need to be freed.  NULL if the index 
//  is invalid.
//***************************************************************************

WCHAR * CIndexCache::GetWString(
                        IN int iIndex)
{
    if(iIndex >= m_Array.Size())
        return NULL;
    CCacheEntry * pEntry = (CCacheEntry *)m_Array.GetAt(iIndex);
    if(pEntry == NULL)
        return NULL;
    
    WCHAR * pRet = new WCHAR[wcslen(pEntry->m_pwcValue)+1];
    if(pRet)
        wcscpy(pRet,pEntry->m_pwcValue);
    return pRet;
}

//***************************************************************************
//
//  BOOL CIndexCache::SetAt  
//
//  DESCRIPTION:
//
//  Sets a cache entry.
//
//  PARAMETERS:
//
//  pwcAdd              string to store
//  iIndex              cache index to use
//
//  RETURN VALUE:
//
//  
//***************************************************************************

BOOL CIndexCache::SetAt(
                        IN WCHAR * pwcAdd,
                        IN int iIndex)
{
    WCHAR * pValue = new WCHAR[wcslen(pwcAdd)+1];

    if(pValue == NULL)
        return FALSE;
    wcscpy(pValue, pwcAdd);

    // Note that if created, the CCacheEntry object owns the string and
    // will take care of freeing it

    CCacheEntry * pNew = new CCacheEntry(pValue);
    if(pNew == NULL)
    {
        delete pValue;
        return FALSE;
    }
    
	if(iIndex < m_Array.Size())
	{
		m_Array.SetAt(iIndex, pNew);
		return TRUE;
	}

	if(CFlexArray::no_error == m_Array.InsertAt(iIndex, pNew))
        return TRUE;
    {
        delete pNew;
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\general.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    GENERAL.CPP

Abstract:

	Containes some general purpose classes 
	which are of use to serveral providers.
	Specifically, this contains the code for
	the classes used to cache open handles and
	the classes used to parse the mapping strings.

History:

	a-davj  11-Nov-95   Created.

--*/

#include "precomp.h"
#include <tchar.h>
//***************************************************************************
//
//  CEntry::CEntry()
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEntry::CEntry()
{
    hHandle = NULL;
    sPath.Empty();
}

//***************************************************************************
//
//  CEntry::~CEntry()
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CEntry::~CEntry()
{
    sPath.Empty();
}
    
//***************************************************************************
//
//  CHandleCache::~CHandleCache
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CHandleCache::~CHandleCache()
{
    Delete(0);    
}

//***************************************************************************
//
//  CHandleCache::lAddToList
//
//  DESCRIPTION:
//
//  Adds an entry to the handle list.
//
//
//  PARAMETERS:
//
//  pAdd    Name that will be used to retrieve the handle
//  hAdd    handle to be added
//  
//  RETURN VALUE:
//  
//  S_OK                    all is well.
//  WBEM_E_OUT_OF_MEMORY     out of memory
//
//***************************************************************************

long int CHandleCache::lAddToList(
                        IN const TCHAR * pAdd, 
                        IN HANDLE hAdd)
{
    CEntry * pNew = new CEntry();
    if(pNew == NULL) 
        return WBEM_E_OUT_OF_MEMORY; 
    pNew->hHandle = hAdd;
    pNew->sPath = pAdd;
    
    if(CFlexArray::no_error != List.Add(pNew))
        return WBEM_E_OUT_OF_MEMORY;
    return S_OK;
}

//***************************************************************************
//
//  CHandleCache::lGetNumMatch
//
//  DESCRIPTION:
//
//  Returns the number of entries which match the path tokens.  For example,
//  the path might be    HKEY_LOCAL_MACHINE, hardware, description, xyz, and 
//  if the tokens, were, HKEY_LOCAL_MACHINE, hardware, devicemap, xyz then a 
//  two would be returned since the first two parts matched.
//
//  PARAMETERS:
//
//  iEntry      Entry to start checking at
//  iToken      Token to start checking
//  Path        This object supplies the tokens to be checked.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

long int CHandleCache::lGetNumMatch(
                        IN int iEntry,
                        IN int iToken, 
                        IN CProvObj & Path)
{
    int iMatch = 0;
    for(;iEntry < List.Size() && iToken < Path.iGetNumTokens();
            iEntry++, iToken++, iMatch++) 
    {
        CEntry * pCurr = (CEntry *)List.GetAt(iEntry);
        TString sTemp = Path.sGetFullToken(iToken);
        if(lstrcmpi(pCurr->sPath,sTemp))
            break;
    }
    return iMatch;            
}

//***************************************************************************
//
//  CHandleCache::Delete
//
//  DESCRIPTION:
// 
//  Empties all or part of the cache.
//
//  PARAMETERS:
//
//  lStart      Indicates first element to delete.  To empty entire cache,
//              a zero should be entered.
//
//***************************************************************************

void CHandleCache::Delete(
                    IN long int lStart)
{
    int iCurr;
    for(iCurr = List.Size()-1; iCurr >= lStart; iCurr--) 
    {
        CEntry * pCurr = (CEntry *)List.GetAt(iCurr);
        delete pCurr;
        List.RemoveAt(iCurr);        
    }
}


//***************************************************************************
//
//  CHandleCache::hGetHandle
//
//  DESCRIPTION:
//
//  Gets a handle.
//
//  PARAMETERS:
//
//  lIndex      Indicates which handle to get.  0 is the first.
//
//  RETURN VALUE:
//  handle retuested, NULL only if bad index is entered.
//
//***************************************************************************

HANDLE CHandleCache::hGetHandle(
                        IN long int lIndex)
{
    if(lIndex < List.Size()) 
    {
        CEntry * pCurr = (CEntry *)List.GetAt(lIndex);
        if(pCurr)
            return pCurr->hHandle;
    }
    return NULL;
}

//***************************************************************************
//
//  CHandleCache::sGetString
//
//  DESCRIPTION:
//
//  Gets the string associated with a cache entry.
//
//  PARAMETERS:
//
//  lIndex          Index in cache, 0 is the first element.
//
//  RETURN VALUE:
//
//  Returns a pointer to the string.  NULL if bad index.
//
//***************************************************************************

const TCHAR * CHandleCache::sGetString(
                                IN long int lIndex)
{
    if(lIndex < List.Size()) {
        CEntry * pCurr = (CEntry *)List.GetAt(lIndex);
        if(pCurr)
            return pCurr->sPath;
        }
    return NULL;
}

//***************************************************************************
//
//  CToken::CToken
//
//  DESCRIPTION:
//
//  constructor.
// 
//  PARAMETERS:
//
//  cpStart         String to be parsed.
//  cDelim          Token delimeter.
//  bUsesEscapes    If true, then need to look for special characters
//
//***************************************************************************

#define MAX_TEMP 150

CToken::CToken(
                IN const TCHAR * cpStart,
                IN const OLECHAR cDelim, 
                bool bUsesEscapes)
{
    const TCHAR * cpCurr;        //atoi
    iOriginalLength = -1;
    TString *psExp;
    int iNumQuote;
    BOOL bLastWasEsc, bInExp, bInString;
    bLastWasEsc = bInExp = bInString = FALSE;

	
	// Before doing an elaborate parse, first check for the simple case where there
	// are no quotes, escapes, commas, etc

    bool bGotSpecialChar = false;

	for(cpCurr = cpStart; *cpCurr && *cpCurr != cDelim; cpCurr++)
	{
		if(*cpCurr == ESC || *cpCurr == '\"' || *cpCurr == '(')
			bGotSpecialChar = true;
	}


	if(!bUsesEscapes || cDelim != MAIN_DELIM || *cpCurr == cDelim || !bGotSpecialChar)
	{
		// Simple case do it quickly

		iOriginalLength = cpCurr - cpStart;
		if(iOriginalLength < MAX_TEMP)
		{
			TCHAR tcTemp[MAX_TEMP];
			lstrcpyn(tcTemp, cpStart, iOriginalLength + 1);
			sFullData = tcTemp;
			sData = tcTemp;
			if(*cpCurr)
				iOriginalLength++;
			return;
		}
	}


    for(cpCurr = cpStart; *cpCurr; cpCurr++) {
        
        // check if end of token

        if(*cpCurr == cDelim && !bLastWasEsc) {
            cpCurr++;
            break;                    
            }

        // full data stores everything.  Check if character
        // is the escape which means that the following
        // character should be interpreted as a literal

        sFullData += *cpCurr;
        if(*cpCurr == ESC && !bLastWasEsc) {
            bLastWasEsc = TRUE;
            continue;
            }
        
        // tokens can include indexs of the form 
        // (xxx) or ("xxx").  If an index is detected,
        // then store the characters between () separately

        if((*cpCurr == '(' && !bInExp && !bLastWasEsc)||
           (*cpCurr == ',' && bInExp && !bLastWasEsc)) {
            
            // start of index expression. Allocate a new
            // string to store it and store the string 
            // in the expression collection. 
    
            psExp = new (TString);
            if(psExp) {    
                Expressions.Add((CObject *)psExp);
                bInExp = TRUE;
                iNumQuote = 0;
                }
            }
        else if(*cpCurr == ')' && bInExp && !bInString && !bLastWasEsc)
            bInExp = FALSE;    // end of index expression
        else if (*cpCurr == '\"' && bInExp && !bLastWasEsc) {
            iNumQuote++;
            if(iNumQuote == 1) {
                bInString = TRUE;
                *psExp += *cpCurr;
                }
            else if(iNumQuote == 2)
                bInString = FALSE;
            else 
                return; 
            }
        else if (bInExp)
            *psExp += *cpCurr;
        else
            sData += *cpCurr;
        bLastWasEsc = FALSE;
        }
    if(bInString || bInExp)   
        return; // got junk!!!
    iOriginalLength = cpCurr - cpStart;
    return;
}

//***************************************************************************
//
//  CToken::~CToken
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CToken::~CToken()
{
    int iCnt;
    TString * pCurr;
    for (iCnt = 0; iCnt < Expressions.Size(); iCnt++) {
        pCurr = (TString *)Expressions.GetAt(iCnt);
        delete pCurr;
        }
    Expressions.Empty();
    sData.Empty();
    sFullData.Empty();
}

//***************************************************************************
//
//  CToken::iConvOprand
//
//  DESCRIPTION:
//
//  Converts the characters in a string into an integer.
//
//  PARAMETERS:
//
//  tpCurr      String to be converted.
//  iArray      Not used anymore.
//  dwValue     where the result is set.
//
//  RETURN VALUE:
//
//  Number of digits converted.
//
//***************************************************************************

long int CToken::iConvOprand(
                    IN const TCHAR * tpCurr, 
                    IN int iArray, 
                    OUT long int & dwValue)
{
    TString sTemp;
    long int iRet = 0;

    // Build up a string containing
    // all characters upto the first non didgit

    for(;*tpCurr; tpCurr++)
        if(iswdigit(*tpCurr)) 
        {
            sTemp += *tpCurr;
            iRet++;
        }
        else
            break;        
    
    // Convert and return the length

    dwValue = _ttoi(sTemp);    
    return iRet;
}

//***************************************************************************
//
//  CToken::GetIntExp
//
//  DESCRIPTION:
//
//  Converts the expression into an integer.  The expression
//  can only be made up of integers, '+', '-' and a special
//  character ('#' as of now)for substituting iArray.  Examples,
//  (23)  (#+3)  (#-4)
//
//  PARAMETERS:
//  
//  iExp        which integer to retrieve in the case where you have 2,5,8
//  iArray      Not used anymore
//
//  RETURN VALUE:
//  
//  -1 if error.
//
//***************************************************************************

long int CToken::GetIntExp(int iExp,int iArray)
{
    TString * psTest;
    TString sNoBlanks;
    TCHAR const * tpCurr;
    long int lOpSize;
    int iCnt;
    long int lAccum = 0, lOperand;
    TCHAR tUnary = ' ';
    TCHAR tBinary = '+';
    BOOL bNeedOperator = FALSE; // Start off needing operand
    
    // Do some intial check such as making sure the expression
    // exists and that it isnt a string expression

    if(Expressions.Size() <= iExp)
        return -1;
    if(IsExpString(iExp)) 
        return -1;
    psTest = (TString *)Expressions.GetAt(iExp);
    if(psTest == NULL) {
        return -1;
        }

    // Get rid of any blanks

    for(iCnt = 0; iCnt < psTest->Length(); iCnt++)
        if(psTest->GetAt(iCnt) != ' ')
            sNoBlanks += psTest->GetAt(iCnt);
    
    // Evalate the expression

    for(tpCurr = sNoBlanks; *tpCurr; tpCurr++) 
    {
        if(*tpCurr == '+' || *tpCurr == '-') 
        {
            
            // got an operator.  Note that if an operator is not needed,
            // such as before the first operand, then it must be a unary 
            // operator.  Only one unary operator in a row is valid.

            if(bNeedOperator) 
            {
                tBinary = *tpCurr;
                bNeedOperator = FALSE;
            }
            else
            {
                if(tUnary != ' ') // Gratuitous unary operator
                    return -1;
                tUnary = *tpCurr;
            }
        }
        else 
        {
            // got an operand
            
            if(bNeedOperator) // Gratuitous unary operand
                return -1;
            lOpSize = iConvOprand(tpCurr,iArray,lOperand);
            if(lOpSize > 1)
                tpCurr += lOpSize-1;
            if(tUnary == '-')
                lOperand =  -lOperand;
            if(tBinary == '+')
                lAccum = lAccum + lOperand;
            else
                lAccum = lAccum - lOperand;
            bNeedOperator = TRUE;
            tUnary = ' ';
        }
    }
    return lAccum;
}

//***************************************************************************
//
//  CToken::GetStringExp
//
//  DESCRIPTION:
//
//  Returns a string expression.
//
//  PARAMETERS:
//
//  iExp        Which string to use when they are separated by commans
//
//  RETURN VALUE:
//
//  Pointer to string, NULL if iExp is bogus.
//
//***************************************************************************

TCHAR const * CToken::GetStringExp(
                        IN int iExp)
{
    TString * psTest;
    TCHAR const * tp;
    
    // start by making sure expression exists.
            
    if(Expressions.Size() <= iExp)
        return NULL;
    psTest = (TString *)Expressions.GetAt(iExp);
    if(psTest != NULL) 
    {
        int iIndex;
        iIndex = psTest->Find('\"');
        if(iIndex != -1) 
        {

            // All is well.  Return a pointer one passed
            // the initial \" whose only purpose is to 
            // indicate that this is a string expression.

            tp = *psTest;
            return tp + iIndex + 1;
            }
    }
    return NULL;  
}

//***************************************************************************
//
//  CToken::IsExpString
//
//  DESCRIPTION:
//
//  Tests if the token contains a string
//
//  PARAMETERS:
//
//  iExp        Indicates which substring for when the strings are divided
//              by commas
//
//  RETURN VALUE:
//  Returns true if the expression is a string.
//
//***************************************************************************

BOOL CToken::IsExpString(int iExp)
{
    TString * psTest;
    
    // make sure that the expression exists.
            
    if(Expressions.Size() <= iExp)
        return FALSE;
    psTest = (TString *)Expressions.GetAt(iExp);
    if(psTest != NULL) {
        int iIndex;
        
        // String expressions always contain at least one \"
        
        iIndex = psTest->Find('\"');
        if(iIndex != -1)
            return TRUE;
        }
    return FALSE;
}
            


//***************************************************************************
//
//  CProvObj::CProvObj(const char * ProviderString,const TCHAR cDelim)
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  ProviderString      String passed from wbem
//  cDelim              Token delimeter
//  bUsesEscapes        True if we need to treat escapes in a special way.
//
//***************************************************************************
#ifndef UNICODE
CProvObj::CProvObj(
                IN const char * ProviderString,
                IN const TCHAR cDelim, bool bUsesEscapes)
{
    m_bUsesEscapes = bUsesEscapes;
    Init(ProviderString,cDelim);
    return;
}
#endif

//***************************************************************************
//
//  CProvObj::CProvObj(const WCHAR * ProviderString,const TCHAR cDelim)
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  ProviderString      String passed from wbem
//  cDelim              Token delimeter
//
//***************************************************************************


CProvObj::CProvObj(
                IN const WCHAR * ProviderString,
                IN const TCHAR cDelim, bool bUsesEscapes)
{
    m_bUsesEscapes = bUsesEscapes;
#ifdef UNICODE
    Init(ProviderString,cDelim);
#else
    char * pTemp = WideToNarrowA(ProviderString);
    if(pTemp == NULL)
        dwStatus = WBEM_E_FAILED;
    else {
        Init(pTemp,cDelim);
        delete pTemp;
        }
#endif
    return;
}

//***************************************************************************
//
//  void CProvObj::Init
//
//  DESCRIPTION:
//
//  Doest the acutal work for the various constructors.
//
//  PARAMETERS:
//  ProviderString      String passed from wbem
//  cDelim              Token delimeter
//
//***************************************************************************

void CProvObj::Init(
                IN const TCHAR * ProviderString,
                IN const TCHAR cDelim)
{
    CToken * pNewToken;
    const TCHAR * cpCurr;

	m_cDelim = cDelim;

    // Create a list of tokens

        for(cpCurr = ProviderString; *cpCurr;cpCurr+=pNewToken->GetOrigLength()) 
        {
			int iRet = 0;
            pNewToken = new CToken(cpCurr,cDelim, m_bUsesEscapes);
			if(pNewToken)
				iRet = myTokens.Add(pNewToken);
			if(pNewToken == NULL || iRet != CFlexArray::no_error)
			{
				dwStatus = WBEM_E_OUT_OF_MEMORY;
				return;
			}
            if(pNewToken->GetOrigLength() == -1)
            {
				dwStatus = WBEM_E_INVALID_PARAMETER;
				return;
            }
        }
        dwStatus = WBEM_NO_ERROR;
        return;

}            

//***************************************************************************
//
//  CProvObj::Empty
//
//  DESCRIPTION:
// 
//  frees up all the data
//
//***************************************************************************

void CProvObj::Empty(void)
{
    int iCnt;
    CToken * pCurr;
    for (iCnt = 0; iCnt < myTokens.Size(); iCnt++) {
        pCurr = (CToken *)myTokens.GetAt(iCnt);
        delete pCurr;
        }
    myTokens.Empty();
}

//***************************************************************************
//
//  BOOL CProvObj::Update
//
//  DESCRIPTION:
//
//  Resets the value with a new provider string. 
//
//  PARAMETERS:
//
//  pwcProvider     New provider string
//
//  RETURN VALUE:
//
//  TRUE if ok.
//***************************************************************************

BOOL CProvObj::Update(
                        IN WCHAR * pwcProvider)
{
	// Do a quick check to see if the "fast" update can be used

	BOOL bComplex = FALSE;
	int iDelim = 0;
	WCHAR * pwcCurr;
	for(pwcCurr = pwcProvider; *pwcCurr; pwcCurr++)
	{
		if(*pwcCurr == m_cDelim) 
			iDelim++;
		else if(*pwcCurr == ESC || *pwcCurr == L'\"' || *pwcCurr == L'(')
		{
			bComplex = TRUE;
			break;
		}
	}

	// If the number of tokens changed, or there is some embedded junk
	// just empty and retry.

	if(bComplex || iDelim != myTokens.Size()-1)
	{
		Empty();
#ifdef UNICODE
		Init(pwcProvider,m_cDelim);
#else
		char * pTemp = WideToNarrowA(pwcProvider);
		if(pTemp == NULL)
			return FALSE;
		Init(pTemp,m_cDelim);
        delete pTemp;
#endif
		return TRUE;
	}

	// We can take the shortcut.  Start by creating a TCHAR temp version

	int iLen = 2*wcslen(pwcProvider) + 1;
	TCHAR * pTemp = new TCHAR[iLen];
	if(pTemp == NULL)
		return FALSE;
#ifdef UNICODE
	wcscpy(pTemp,pwcProvider);
#else
	wcstombs(pTemp, pwcProvider, iLen);
#endif	

	TCHAR * ptcCurr;
	TCHAR * pStart;
	BOOL bTheEnd = FALSE;
    
    iDelim = 0;
	for(pStart = ptcCurr = pTemp;!bTheEnd;ptcCurr++)
	{
		if(*ptcCurr == m_cDelim || *ptcCurr == NULL)
		{
			bTheEnd = (*ptcCurr == NULL);
			*ptcCurr = NULL;
			CToken * pToken = (CToken *)myTokens.GetAt(iDelim);
			if(pToken && lstrcmpi(pStart,pToken->sFullData))
			{
				pToken->sFullData = pStart;
				pToken->sData = pStart;
			}
            iDelim++;
			pStart = ptcCurr+1;
		}
	}

	delete pTemp;
	return TRUE;
}

//***************************************************************************
//
//  CProvObj::GetTokenPointer
//
//  DESCRIPTION:
//
//  Gets a pointer to a token
//
//  PARAMETERS:
//
//  iToken              Which token to get
//
//  RETURN VALUE:
//  
//  pointer to token, or NULL if bad request.
//
//***************************************************************************

CToken * CProvObj::GetTokenPointer(
                        IN int iToken)
{
    if(iToken >= myTokens.Size() || iToken < 0) 
        return NULL;
    return (CToken *)myTokens.GetAt(iToken);
}

//***************************************************************************
//
//  CProvObj::dwGetStatus
//
//  DESCRIPTION:
//
//  Gets status and also checks to make sure a minimum number of tokens
//  exist.
//
//  PARAMETERS:
//
//  iMin                minimum number of tokens.
//
//  RETURN VALUE:
//
//  Returns S_OK if OK, WBEM_E_FAILED otherwise.
//
//***************************************************************************

DWORD CProvObj::dwGetStatus(
                        IN int iMin)
{
    if(dwStatus)
        return dwStatus;
    else
        return (iMin <= myTokens.Size()) ? S_OK : WBEM_E_FAILED;

}
//***************************************************************************
//
//  CProvObj::sGetToken
//
//  DESCRIPTION:
//
//  Gets a token.  Note that the token will not include embleded "(stuff)"
//
//  PARAMETERS:
//
//  iToken              which token to get
//
//  RETURN VALUE:
//
//  pointer to token, NULL if invalid argument
//***************************************************************************

const TCHAR * CProvObj::sGetToken(
                        IN int iToken)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetStringValue() : NULL;
}

//***************************************************************************
//
//  const TCHAR * CProvObj::sGetFullToken
//
//  DESCRIPTION:
//
//  Gets a full and unadulterated token.
//
//  PARAMETERS:
//
//  iToken              token to get
//
//  RETURN VALUE:
//
//  pointer to token, NULL if invalid argument
//***************************************************************************

const TCHAR * CProvObj::sGetFullToken(
                        IN int iToken)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetFullStringValue() : NULL;
}


//***************************************************************************
//
//  const TCHAR * CProvObj::sGetStringExp
//
//  DESCRIPTION:
//
//  Gets a substring for a particular token
//
//  PARAMETERS:
//
//  iToken              token to get
//  iExp                substring to get
//
//  RETURN VALUE:
//
//  pointer to substring, NULL if invalid argument
//***************************************************************************

const TCHAR * CProvObj::sGetStringExp(
                        IN int iToken,
                        IN int iExp)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetStringExp(iExp) : NULL;
}

//***************************************************************************
//
//  long int CProvObj::iGetIntExp
//
//  DESCRIPTION:
//
//  For a particular token, gets the integer value of a substring.
//
//  PARAMETERS:
//
//  iToken              token to get
//  iExp                substring
//  iArray              no longer used
//
//  RETURN VALUE:
//  
//  int value, or -1 if bad argument
//***************************************************************************

long int CProvObj::iGetIntExp(
                        IN int iToken, 
                        IN int iExp, 
                        IN int iArray)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetIntExp(iExp,iArray) : -1;
}

//***************************************************************************
//
//  BOOL CProvObj::IsExpString
//
//  DESCRIPTION:
//
//  Tests a substring to see if it is a string, or numeric
//
//  PARAMETERS:
//
//  iToken              token to get
//  iExp                substring
//
//
//  RETURN VALUE:
//
//  True if arguments are valid and it is not numeric
//***************************************************************************

BOOL CProvObj::IsExpString(
                        IN int iToken, 
                        IN int iExp)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->IsExpString(iExp) : FALSE;
}

//***************************************************************************
//
//  long int CProvObj::iGetNumExp
//
//  DESCRIPTION:
//
//  Gets the number of subexpressions
//
//  PARAMETERS:
//
//  iToken              token to check
//
//  RETURN VALUE:
//
//  number of substrings (subexpressions) or -1 if invalid argument
//***************************************************************************

long int CProvObj::iGetNumExp(
                        IN int iToken)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetNumExp() : -1;
}


//***************************************************************************
//
//  IWbemClassObject * GetNotifyObj
//
//  DESCRIPTION:
//
//  This utility is useful for setting notify objects 
//  at the end of async calls.
//
//  PARAMETERS:
//
//  pServices           pointer back into WBEM
//  lRet                status code to set in notify object
//                
//  RETURN VALUE:
//
//  Class object.  Null if failure.
//***************************************************************************

IWbemClassObject * GetNotifyObj(
                        IN IWbemServices * pServices, 
                        IN long lRet,
                        IN IWbemContext  *pCtx)
{
    
    if(pServices == NULL)
        return NULL;
    IWbemClassObject * pInst = NULL;
    IWbemClassObject * pClass = NULL;

    SCODE sc = pServices->GetObject(L"__ExtendedStatus", 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return NULL;

    sc = pClass->SpawnInstance(0, &pInst);
    pClass->Release();

    if(sc == S_OK && pInst)
    {

        VARIANT v;
        v.vt = VT_I4;
        v.lVal = lRet;
        sc = pInst->Put(L"StatusCode", 0, &v, 0);
        if(sc != S_OK)
        {
            pInst->Release();
            return NULL;
        }
        else
            return pInst;

    }
    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\indexcac.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INDEXCAC.H

Abstract:

	Declares the CCacheEntry and CIndexCache classes.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _INDEXCAC_H_
#define _INDEXCAC_H_


//***************************************************************************
//
//  CLASS NAME:
//
//  CCacheEntry
//
//  DESCRIPTION:
//
//   This "object" is used as a structure.   It holds a cache entry.
//
//***************************************************************************

class CCacheEntry : public CObject {
   public:
      CCacheEntry(TCHAR * pValue, int iIndex);
      CCacheEntry(WCHAR * pValue);
      ~CCacheEntry();
      int m_iIndex;
      TCHAR * m_ptcValue;
      WCHAR * m_pwcValue;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CIndexCache
//
//  DESCRIPTION:
//
//  Holds a cache for string/integer combinations that the perf monitor 
//  provider uses to speed up lookup.
//
//***************************************************************************

class CIndexCache : public CObject {
   public:
      CIndexCache();
      ~CIndexCache(){Empty();};
      void Empty();

      // this routine returns -1, if the entry isnt found.  The second
      // argument can be used to find subsequent entries.

      int Find(const TCHAR * pFind, DWORD dwWhichEntry = 0);

      // this routine returns TRUE if the add worked

      BOOL Add(TCHAR * pAdd, int iIndex);
      
      // this routine returns NULL if the index isnt found.  Note that
      // the index isnt necessarily the m_iIndex value as found in the entry

      WCHAR * GetWString(int iIndex);
      BOOL SetAt(WCHAR * pwcAdd, int iIndex);


   private:
      CFlexArray m_Array;
};

#endif //_INDEXCAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\locator.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCATOR.CPP

Abstract:

	Defines the Locator object.

History:

	a-davj  3-JUN-96   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
//#define _MT
#include <process.h>
#include "impdyn.h"

//***************************************************************************
//
//  CLocator::CLocator  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CLocator::CLocator()
{
    m_cRef=0;
    return;
}

//***************************************************************************
//
//  CLocator::~CLocator  
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CLocator::~CLocator(void)
{
    return;
}

//***************************************************************************
// HRESULT CLocator::QueryInterface
// long CLocator::AddRef
// long CLocator::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CLocator::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemLocator)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CLocator::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CLocator::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;

    delete this;
    return 0;
} 

//***************************************************************************
//
//  SCODE CLocator::ConnectServer  
//
//  DESCRIPTION:
//
//  Retrieves a pointer to a provider object that has been created so as
//  to service the NetworkResource, User, and Password.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User
//  Password,           Password
//  LocaleId            language locale
//  lFlags              flags
//  ppProv              Set to point to namespace provider.
//
//  RETURN VALUE:
//
//  S_OK                            all is well
//  WBEM_E_PROVIDER_LOAD_FAILURE     Couldnt create the provider
//***************************************************************************

SCODE CLocator::ConnectServer(
                        IN BSTR NetworkResource,
                        IN BSTR User,
                        IN BSTR Password, 
                        IN BSTR LocaleId,
                        IN long lFlags,
                        IN BSTR Authority,
                        IN IWbemContext *pCtx,
                        OUT IN IWbemServices FAR* FAR* ppProv)

{
    SCODE sc;  

    // Create a new instance of the provider to handle the namespace.

    IWbemServices * pNew = GetProv(NetworkResource, User, Password, Authority,
                                    lFlags, pCtx);
    if(pNew == NULL)
        return WBEM_E_PROVIDER_LOAD_FAILURE;
    sc = pNew->QueryInterface(IID_IWbemServices,(void **) ppProv);
    if(sc != S_OK) 
        delete pNew;
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\node.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NODE.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "node.h"
#include "eventreg.h"
#include <impdyn.h>
#include "regevent.h"


CValue::CValue(TCHAR * pName, DWORD dwType, DWORD dwDataSize, BYTE * pData)
{

}
CValue::~CValue()
{

}

CNode::CNode()
{
}
CNode::~CNode()
{

}
DWORD CNode::AddSubNode(CNode * pAdd)
{
    return 0;
}
DWORD CNode::AddValue(CValue *)
{
    return 0;
}
DWORD CNode::CompareAndReportDiffs(CNode * pComp)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\ntcnfg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    NTCONFIG.H

Abstract:

    This module contains the definitions associated with the conventions
    used to access the configuration registry.

History:

	a--davj  04-Mar-97   Created.

--*/

#include <winnt.h>

#ifndef _NTCONFIG_
#define _NTCONFIG_


typedef enum _CM_RESOURCE_TYPE {
    CmResourceTypeNull = 0,    // Reserved
    CmResourceTypePort,
    CmResourceTypeInterrupt,
    CmResourceTypeMemory,
    CmResourceTypeDma,
    CmResourceTypeDeviceSpecific
} CM_RESOURCE_TYPE;

/*
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    LONGLONG QuadPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
*/

typedef LARGE_INTEGER PHYSICAL_ADDRESS;


typedef enum Interface_Type {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    MaximumInterfaceType
}INTERFACE_TYPE;


#define REG_RESOURCE_LIST            ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//

#pragma pack(4)
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#pragma pack()

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// Note2: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

#endif // _NTCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\node.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    NODE.H

Abstract:

	Declares the CNode class

History:

	a-davj    1-July-97       Created.

--*/

#ifndef _Node_H_
#define _Node_H_

#include <wbemcomn.h>


class CValue
{
public:
	CValue(TCHAR * pName, DWORD dwType, DWORD dwDataSize, BYTE * pData);
	~CValue();
private:
	TCHAR * m_pName;
    DWORD m_dwType;
	DWORD m_dwDataSize;
	BYTE * m_pData;
};

class CNode
{
public:
	CNode();
	~CNode();
    DWORD AddSubNode(CNode * pAdd);
    DWORD AddValue(CValue *);
    DWORD CompareAndReportDiffs(CNode * pComp);
private:

    CFlexArray m_SubNodes;
    CFlexArray m_Values;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\perfcach.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PERFCACH.H

Abstract:

	Defines data useful for the NT performance providers.

History:

	a-davj  04-Mar-97   Created.

--*/

#define PERMANENT 0xFFFFFFFF

// If an object has not be retrieved in this many MS, the stop 
// automatically getting it

#define MAX_UNUSED_KEEP 30000

// Define how big the buffers will start as.  This size should be a bit 
// bigger than the "standard" counters and thus reallocations shouldnt
// be necessary

#define INITIAL_ALLOCATION 25000

// maximum age in ms of the "newest" data in the cache

#define MAX_NEW_AGE     2000

// maximum age in ms of the "oldest" data in the cache

#define MAX_OLD_AGE     10000

// minimum time difference between old and new sample

#define MIN_TIME_DIFF 1000


typedef struct _LINESTRUCT
   {
   LONGLONG                        lnNewTime;
   LONGLONG                        lnOldTime;
   LONGLONG                        lnOldTime100Ns ;
   LONGLONG                        lnNewTime100Ns ;
   LONGLONG                        lnaCounterValue[2];
   LONGLONG                        lnaOldCounterValue[2];
   DWORD                           lnCounterType;
   LONGLONG                        lnPerfFreq ;
   LONGLONG                        ObjPerfFreq ;
   LONGLONG                        ObjCounterTimeNew;
   LONGLONG                        ObjCounterTimeOld;
   }LINESTRUCT ;

typedef LINESTRUCT *PLINESTRUCT ;

FLOAT CounterEntry (PLINESTRUCT pLine);


class Entry : public CObject {
    public:
    int iObject;
    DWORD dwLastUsed;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CIndicyList
//
//  DESCRIPTION:
//
//  Implementation of the CIndicyList class.  This class keeps a list of the
//  object types that are to be retrieved.  Each object type also has a time
//  of last use so that object types that are no longer used will not be 
//  retrieved forever.  Some entries are part of the standard globals and 
//  are marked as permanent so that they will always be read.
//
//***************************************************************************

class CIndicyList : public CObject {
    
    public:
        BOOL SetUse(int iObj);
        BOOL bItemInList(int iObj);
        BOOL bAdd(int iObj, DWORD dwTime);
        void PruneOld(void);
        LPCTSTR pGetAll(void);
  //      BOOL bItemInList(int iObj);
        ~CIndicyList(){FreeAll();};
        CIndicyList & operator = ( CIndicyList & from);
        void FreeAll(void);
    private:
        TString sAll;
        CFlexArray Entries;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  PerfBuff
//
//  DESCRIPTION:
//
//  Holds a chunk of data read from the registry's perf monitor data.
//
//***************************************************************************

class PerfBuff : public CObject {
    public:
        friend class PerfCache;
        DWORD Read(HKEY hKey, int iObj, BOOL bInitial);
        LPSTR Get(int iObj);
        void Free();
        ~PerfBuff(){Free();};
        PerfBuff();
        BOOL bOK(HKEY hKey, DWORD dwMaxAge, int iObj);
        PerfBuff & operator = ( PerfBuff & from);
        BOOL bEmpty(void){return !dwSize;};
 //       __int64 Time(void){return dwBuffLastRead;};
 //      __int64 Time2(void){return PerfTime;};
    private:
        DWORD dwSize;
        LPSTR pData;
        CIndicyList List;
        HKEY hKeyLastRead;
        DWORD dwBuffLastRead;           // GetCurrentTime of last read
        LONGLONG PerfTime;               // Time in last block
        LONGLONG PerfTime100nSec;               // Time in last block
        LONGLONG PerfFreq;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  PerfCache
//
//  DESCRIPTION:
//
//  Implementation of the PerfCache class.  This is the object which is 
//  directly used by the perf provider class.  Each object keeps track of
//  several PerfBuff object.  There is a newest which is what was just read,
//  an oldest which has previously read data and an intermediate buffer which
//  has data that isnt quite old enough to be moved into the old buffer.  Note
//  that time average data requires having two samples which are separated by
//  a MIN_TIME_DIFF time difference.
//
//***************************************************************************

class PerfCache : public CObject {
    public:
        void FreeOldBuffers(void);
        DWORD dwGetNew(LPCTSTR pName, int iObj, LPSTR * pData,PLINESTRUCT pls);
        DWORD dwGetPair(LPCTSTR pName, int iObj, LPSTR * pOldData,
                            LPSTR * pNewData,PLINESTRUCT pls);
        PerfCache();
        ~PerfCache();
    private:
        PerfBuff Old,New;
        HKEY hHandle;
        TString sMachine;
        DWORD dwGetHandle(LPCTSTR pName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\precomp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PRECOMP.H

Abstract:

	include file for standard system include files,
	or project specific include files that are used frequently, but
	are changed infrequently

History:

	a--davj  04-Mar-97   Created.

--*/

#pragma warning (disable : 4786)
#pragma warning( disable : 4251 )
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#include <wbemidl.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "tstring.h"

class CObject
{
public:
    virtual ~CObject(){}

};

#include "stdprov.h"

#undef PURE
#define PURE {return (unsigned long)E_NOTIMPL;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\perfprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PERFPROV.H

Abstract:

	Defines the guids for performance monitor provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _PERFPROV_H_
#define _PERFPROV_H_

DEFINE_GUID(LIBID_PERFPROV,0xF00B4403L,0xF8F1,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

DEFINE_GUID(CLSID_PerfProvider,0xF00B4404L,0xF8F1,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

// {72967903-68EC-11d0-B729-00AA0062CBB7}
DEFINE_GUID(CLSID_PerfPropProv, 
0x72967903, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);

#ifdef __cplusplus
class PerfProvider;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\perfcach.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PERFCACH.CPP

Abstract:

	Containes some classes which are used to cache NT performance data.

History:

	a-davj  15-DEC-95   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include "perfcach.h"
#include <winperf.h>
#include <tchar.h>

//***************************************************************************
//
//  BOOL CIndicyList::SetUse  
//
//  DESCRIPTION:
//
//  Indicates that an object type has just been used.  If the object
//  is already on the list, then its last accessed time is updated.  New
//  object types are added to the list
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  always TRUE unless it was a new entry and there isnt enough memory
//  to add.
//***************************************************************************

BOOL CIndicyList::SetUse(
                        IN int iObj)
{
    int iNumEntries, iCnt;

    // Go Through list and determine if there is an entry
    
    Entry * pCurr;
    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        if(iObj == pCurr->iObject)  // found it!
            break;
    }

    if(iCnt < iNumEntries) 
    {

        // Found the entry.  Set its last used to to the
        // present unless it is a permanent entry

        if(pCurr->dwLastUsed != PERMANENT)
            pCurr->dwLastUsed = GetCurrentTime();
        return TRUE;
    }
    else
        
        // Entry  not found, add to list
         
        return bAdd(iObj,GetCurrentTime());
}

//***************************************************************************
//
//  BOOL CIndicyList::bItemInList  
//
//  DESCRIPTION:
//
//  Checks if an item is in the list.
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  TRUE if the item is in the list
//  
//***************************************************************************

BOOL CIndicyList::bItemInList(
                        IN int iObj)
{
    int iNumEntries, iCnt;

    // Go Through list and determine if the entry is there
    
    Entry * pCurr;
    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        if(iObj == pCurr->iObject)  // found it!
            return TRUE;
    }
    return FALSE;
}

//***************************************************************************
//
//  BOOL CIndicyList::bAdd  
//
//  DESCRIPTION:
//
//  Adds an object type to the list
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//  dwTime              Current system time
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//  
//***************************************************************************

BOOL CIndicyList::bAdd(
                        IN int iObj,
                        IN DWORD dwTime)
{
    Entry * pNew = new Entry;
    if(pNew == NULL)
        return FALSE;
    pNew->iObject = iObj;
    pNew->dwLastUsed = dwTime;
          
    int iRet = Entries.Add(pNew);
    if(iRet != CFlexArray::no_error)
    {
        delete pNew;
        return FALSE;
    }
    return TRUE;
}

//***************************************************************************
//
//  void CIndicyList::PruneOld  
//
//  DESCRIPTION:
//
//  Looks at the entries in the list and removes any that have
//  not been used in a long time.
//
//***************************************************************************

void CIndicyList::PruneOld(void)
{
    Entry * pCurr;
    int iNumEntries, iCnt;
    DWORD dwCurr = GetCurrentTime();
    iNumEntries = Entries.Size();
    for(iCnt = iNumEntries-1; iCnt >= 0; iCnt--) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        if(pCurr->dwLastUsed != PERMANENT)
            if((dwCurr - pCurr->dwLastUsed) > MAX_UNUSED_KEEP) 
            {
                Entries.RemoveAt(iCnt);
                delete pCurr;
            }
    }
//    Entries.FreeExtra();
}

//***************************************************************************
//
//  LPCTSTR CIndicyList::pGetAll  
//
//  DESCRIPTION:
//
//  Returns a pointer to a string containing the numbers of all the objects
//  on the list.  For example, if the list had objects 2,4, and 8; then
//  the string "2 4 8" would be retrieved.  Null is returned if there
//  isnt enough memory.
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

LPCTSTR CIndicyList::pGetAll(void)
{
    int iNumEntries, iCnt;
    Entry * pCurr;
    
    // Go Through list and add each object number to the string
    
    sAll.Empty();
    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        TCHAR pTemp[20];
        pCurr = (Entry *)Entries.GetAt(iCnt);
        sAll += _itot(pCurr->iObject,pTemp,10);
        if(iCnt < iNumEntries-1)
            sAll += TEXT(" ");
    }
    return sAll;
}

//***************************************************************************
//
//  CIndicyList & CIndicyList::operator =   
//
//  DESCRIPTION:
//
//  Supports the assignment of one CIndicyList object to another
//
//  PARAMETERS:
//
//  from                Value to copy
//
//  RETURN VALUE:
//
//  reterence the "this" object  
//***************************************************************************

CIndicyList & CIndicyList::operator = (
                        CIndicyList & from)
{
    int iNumEntries, iCnt;
    Entry * pCurr;

    // Free existing list

    FreeAll();  
    
    iNumEntries = from.Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)from.Entries.GetAt(iCnt);
        bAdd(pCurr->iObject, pCurr->dwLastUsed);
    }            
    return *this;
}

//***************************************************************************
//
//  void CIndicyList::FreeAll  
//
//  DESCRIPTION:
//
//  Purpose: Clears out the list and frees memory.
//
//***************************************************************************

void CIndicyList::FreeAll(void)
{
    int iNumEntries, iCnt;
    // Go Through list and determine if there is an entry
    
    Entry * pCurr;

    // delete each object in the list.

    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        delete pCurr;
    }
    Entries.Empty();
}

//***************************************************************************
//
//  DWORD PerfBuff::Read  
//
//  DESCRIPTION:
//
//  Read the perf monitor data.
//
//  PARAMETERS:
//
//  hKey                Registry key for perf mon data
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//  bInitial            Set to TRUE for first call
//
//  RETURN VALUE:
//
//  0                   All is well
//  WBEM_E_OUT_OF_MEMORY
//
//***************************************************************************

DWORD PerfBuff::Read(
                        IN HKEY hKey,
                        IN int iObj,
                        IN BOOL bInitial)
{
    DWORD dwRet;
    LPCTSTR pRequest;
    // Make sure there is a data buffer

    if(dwSize == 0) 
    {
        pData = new char[INITIAL_ALLOCATION];
        if(pData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        dwSize = INITIAL_ALLOCATION;
    }
    hKeyLastRead = hKey; // record the key that was used
    
    // Make sure that the desired object is in the list of
    // objects to be retrieved.  Also set pRequest to the string that will
    // be passed to retrieve the perf counter block.  An initial read is done
    // in order to establish the list of permanent object types which are
    // always to be retrived and that includes the standard "global" types
    // such as memory, processor, disk, etc.

    if(!bInitial) 
    {
        if(!List.SetUse(iObj))
            return WBEM_E_OUT_OF_MEMORY;
        List.PruneOld();
        pRequest = List.pGetAll();
        if(pRequest == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
        pRequest = TEXT("Global");
    
    // Read the data.  Note that the read may be retried if the data
    // block needs to be expanded

    do 
    {
        DWORD dwTempSize, dwType;
        dwTempSize = dwSize;
try
{
        dwRet = RegQueryValueEx (hKey,pRequest,NULL,&dwType,
                                        (BYTE *)pData,&dwTempSize);
}
catch(...)
{
        delete pData;
        return WBEM_E_FAILED;
}
        if(dwRet == ERROR_MORE_DATA) 
        {
            delete pData;
            dwSize += 5000;
            pData = new char[dwSize];
            if(pData == NULL)
            {
                dwSize = 0; 
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    } while (dwRet == ERROR_MORE_DATA);
    
    // Set the age of the data

    if(dwRet == ERROR_SUCCESS) 
    {
        PERF_DATA_BLOCK * pBlock = (PERF_DATA_BLOCK *)pData; 
        PerfTime = *(LONGLONG UNALIGNED *)(&pBlock->PerfTime);
        PerfTime100nSec = *(LONGLONG UNALIGNED *)(&pBlock->PerfTime100nSec);
        PerfFreq = *(LONGLONG UNALIGNED *)(&pBlock->PerfFreq);
        dwBuffLastRead = GetCurrentTime();
    }
    else
        dwBuffLastRead = 0;

    // If this was an initial read of the default objects, add all the
    // default objects to the list as permanent entries

    if(bInitial && dwRet == ERROR_SUCCESS) 
    {
        int iIndex;
        PERF_DATA_BLOCK * pBlock = (PERF_DATA_BLOCK * )pData;
        PPERF_OBJECT_TYPE pObj;
            pObj = (PPERF_OBJECT_TYPE)((PBYTE)pBlock + pBlock->HeaderLength);
        for(iIndex = 0; iIndex < (int)pBlock->NumObjectTypes; iIndex++) 
        {
            //todo, check for errors on add.
            if(!List.bAdd((int)pObj->ObjectNameTitleIndex,PERMANENT))
                return WBEM_E_OUT_OF_MEMORY;

            pObj = (PPERF_OBJECT_TYPE)((PBYTE)pObj + pObj->TotalByteLength);
        }
    }

    return dwRet;
}

//***************************************************************************
//
//  LPSTR PerfBuff::Get  
//
//  DESCRIPTION:
//
//  Returns a pointer to the data and also indicates that the particular type
//  was just used.
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

LPSTR PerfBuff::Get(
                        int iObj)
{
    List.SetUse(iObj);
    return pData;
}

//***************************************************************************
//
//  void PerfBuff::Free  
//
//  DESCRIPTION:
//
//  Frees up the memory
//
//***************************************************************************

void PerfBuff::Free()
{
    if(pData)
        delete pData;
    pData = NULL;
    dwSize = 0;
    hKeyLastRead = NULL;
    dwBuffLastRead = 0;
    List.FreeAll();
}

//***************************************************************************
//
//  PerfBuff::PerfBuff  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

PerfBuff::PerfBuff()
{
    dwSize = 0;
    pData = NULL;
    hKeyLastRead = NULL;
    dwBuffLastRead = 0;
}

//***************************************************************************
//
//  BOOL PerfBuff::bOK  
//
//  DESCRIPTION:
//
//  Returns TRUE, if and only if the same registry key was used to read
//  the data, the data isnt too old, and the particular object type is
//  in the data block.
//
//  PARAMETERS:
//
//  hKey                Registry key for reading data
//  dwMaxAge            Maximum acceptable age
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  see desription
//***************************************************************************

BOOL PerfBuff::bOK(
                        IN HKEY hKey,
                        IN DWORD dwMaxAge,
                        IN int iObj)
{
    if(dwSize ==0)
        return FALSE;
    if(hKey != hKeyLastRead)
        return FALSE;
    if((GetCurrentTime() - dwBuffLastRead) > dwMaxAge)
        return FALSE;
    return List.bItemInList(iObj);
}

//***************************************************************************
//
//  PerfBuff & PerfBuff::operator =   
//
//  DESCRIPTION:
//
//  Allows assignment.
//
//  PARAMETERS:
//
//  from                Assignment source
//
//  RETURN VALUE:
//
//  reference to "this" object.
//***************************************************************************

PerfBuff & PerfBuff::operator = (
                        IN PerfBuff & from)
{
    // if the objects have different buffer sizes, free up the destinations
    // buffer and reallocate on of the same size as the source.

    if(from.dwSize != dwSize) 
    {
        Free();
        pData = new char[from.dwSize];
        if(pData == NULL) 
        {

            // failure in assignment isnt too serious since the buffer
            // will just return null when asked for the data.

            dwSize = 0;
            dwBuffLastRead = 0;
            return *this;
        }
        dwSize = from.dwSize;
    }

    // Copy the list of objects and times etc.

    memcpy(pData,from.pData,dwSize);
    List = from.List;
    hKeyLastRead = from.hKeyLastRead;
    dwBuffLastRead = from.dwBuffLastRead;
    PerfTime = from.PerfTime;
    PerfTime100nSec = from.PerfTime100nSec;
    PerfFreq = from.PerfFreq;
    return *this;
}

//***************************************************************************
//
//  void PerfCache::FreeOldBuffers  
//
//  DESCRIPTION:
//
//  Called by the house keeping thread to free up any buffers tool old to
//  be of any use.
//
//***************************************************************************

void PerfCache::FreeOldBuffers(void)
{
    if(Old.dwSize != 0 && 
        (GetCurrentTime() - Old.dwBuffLastRead) > MAX_OLD_AGE)
        Old.Free();
    if(New.dwSize != 0 && 
        (GetCurrentTime() - New.dwBuffLastRead) > MAX_OLD_AGE)
        New.Free();
}

//***************************************************************************
//
//  DWORD PerfCache::dwGetNew  
//
//  DESCRIPTION:
//
//  Sets a pointer to the most recently read data and will actually do a read
//  if the data in the new buffer isnt fresh enough.  The PLINESTRUCT data is
//  also set.
//
//  PARAMETERS:
//
//  pName               Machine name
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//  pData               Set to the object name
//  pls                 Set to info used to do calculations.
//
//  RETURN VALUE:
//
//  0                   all is well
//  WBEM_E_OUT_OF_MEMORY
//  otherwise error from dwGetHandle, or Read.
//***************************************************************************

DWORD PerfCache::dwGetNew(
                        IN LPCTSTR pName,
                        IN int iObj,
                        OUT IN LPSTR * pData,
                        OUT IN PLINESTRUCT pls)
{
    DWORD dwRet;

    // Get the handle

    dwRet = dwGetHandle(pName);
    if(hHandle == NULL || dwRet != 0) 
        return dwRet; 


    // If the new data is acceptable, then use it

    if(New.bOK(hHandle,MAX_NEW_AGE, iObj)) 
    {
//        OutputDebugString(TEXT("\r\nCurrent New is OK"));
    }
    else 
    {
        // If the new data has the correct type, AND either the old data
        // is junk, or the new data has aged enough to be old, copy the
        // new into the old.

        if(New.bOK(hHandle,MAX_OLD_AGE, iObj) &&
           (!Old.bOK(hHandle,MAX_OLD_AGE, iObj) || 
            (GetCurrentTime() - New.dwBuffLastRead >= MIN_TIME_DIFF)))
            {
//            OutputDebugString("\r\nMoving New into Old in dwGetNew");
            Old = New;
            if(Old.dwSize == 0)     // could happen in low memory
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        // Read the latest data.  
        
        dwRet = New.Read(hHandle, iObj, FALSE);
//        OutputDebugString(TEXT("\r\nRead in New"));
        if(dwRet != ERROR_SUCCESS) 
            return dwRet;
    }        
    *pData = New.Get(iObj);
    pls->lnNewTime = New.PerfTime;
    pls->lnNewTime100Ns = New.PerfTime100nSec;
    pls->lnPerfFreq = New.PerfFreq;
    return ERROR_SUCCESS;
    
}
            
//***************************************************************************
//
//  DWORD PerfCache::dwGetPair  
//
//  DESCRIPTION:
//
//  Sets a pointer to the most recently read data and to the old data so that
//  time averaging can be done.  This routine will ensure that the time 
//  difference between the old and new is sufficient.  The dwGetNew
//  routine should always be called first.  The PLINESTRUCT data is
//  also set.
//
//  PARAMETERS:
//
//  pName               Object Name
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  pOldData            Older data sample
//  pNewData            Newer data sample
//  pls                 line struct data with things like frequency, age etc.
//
//  RETURN VALUE:
//
//  0 if OK, otherwise retuns an error code.
//  
//***************************************************************************

DWORD PerfCache::dwGetPair(
                        IN LPCTSTR pName,
                        IN int iObj,
                        OUT IN LPSTR * pOldData,
                        OUT IN LPSTR * pNewData,
                        OUT IN PLINESTRUCT pls)
{
    DWORD dwRet;
    BOOL bOldOK;

    // Check to see if the old buffer is OK.

    bOldOK = Old.bOK(hHandle,MAX_OLD_AGE, iObj);

    // If both buffers are ok, then we are done

    if(bOldOK) 
    {
        *pOldData = Old.Get(iObj);
        pls->lnOldTime = Old.PerfTime;
        pls->lnOldTime100Ns = Old.PerfTime100nSec;
//        OutputDebugString(TEXT("\r\nOld is OK"));
        return ERROR_SUCCESS;
    }


    // Since the new buffer has already been read, use it as the old buffer

    Old = New;
    if(Old.dwSize == 0)     // could happen in low memory
        return WBEM_E_OUT_OF_MEMORY;
//    OutputDebugString(TEXT("\r\nCopying New into Old in dwGetPair"));

    // Possibly delay long enough so that there is a decent interval

    DWORD dwAge = GetCurrentTime() - Old.dwBuffLastRead;
    if(dwAge < MIN_TIME_DIFF) 
    {
        DWORD dwSleep = MIN_TIME_DIFF - dwAge;
        TCHAR temp[100];
        wsprintf(temp,TEXT("\r\nsleeping %u ms"),dwSleep); 
//        OutputDebugString(temp);
        Sleep(dwSleep);
    } 

    // Read in the new buffer

    dwRet = New.Read(hHandle, iObj, FALSE);
//    OutputDebugString(TEXT("\r\ndoing raw read of new after delay"));
    if(dwRet != ERROR_SUCCESS) 
        return dwRet;
 
    *pNewData = New.Get(iObj);
    *pOldData = Old.Get(iObj);
    pls->lnOldTime = Old.PerfTime;
    pls->lnOldTime100Ns = Old.PerfTime100nSec;

    pls->lnNewTime = New.PerfTime;
    pls->lnNewTime100Ns = New.PerfTime100nSec;
    pls->lnPerfFreq = New.PerfFreq;
    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  PerfCache::PerfCache  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

PerfCache::PerfCache()
{
    // Read in the standard counters.  This builds a list containing
    // those standards as well as providing immediate data for any 
    // request to come in the near future.
    
    hHandle = HKEY_PERFORMANCE_DATA;
  ///  New.Read(hHandle, 0, TRUE);
}

//***************************************************************************
//
//  PerfCache::~PerfCache  
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

PerfCache::~PerfCache()
{
    // If the handle is to a remote machine, close it.

    if(hHandle != NULL && hHandle != HKEY_PERFORMANCE_DATA)
        RegCloseKey(hHandle);
}

//***************************************************************************
//
//  DWORD PerfCache::dwGetHandle  
//
//  DESCRIPTION:
//
//  Makes sure that hHandle is set correctly.
//
//  PARAMETERS:
//
//  pMachine            Machine name.
//
//  RETURN VALUE:
//
//  0                   all is well
//  WBEM_E_OUT_OF_MEMORY
//  WBEM_E_INVALID_PARAMETER  bad argument
//  otherwise error from RegConnectRegistry
//
//***************************************************************************

DWORD PerfCache::dwGetHandle(
                        LPCTSTR pMachine)
{
    DWORD dwRet;

    // if the machines are the same, the just use the existing handle

    if(pMachine == NULL)
        return WBEM_E_INVALID_PARAMETER;   // bad mapping string

    if(!lstrcmpi(sMachine,pMachine) && hHandle != NULL)
        return 0;           // already got it!

    // handle is needed for machine other that the local.  Start
    // by freeing the existing handle if it too is non local

    if(hHandle != NULL && hHandle != HKEY_PERFORMANCE_DATA)
        RegCloseKey(hHandle);

    // save the machine name so that we dont reopen this

    sMachine = pMachine;
    
    if(lstrcmpi(pMachine,TEXT("local"))) 
    {

        LPTSTR pTemp = NULL;    
        int iLen = sMachine.Length() +1;

        dwRet = RegConnectRegistry(sMachine,HKEY_PERFORMANCE_DATA,
                    &hHandle);

        if(dwRet != ERROR_SUCCESS) 
        { // could not remote connect
            hHandle = NULL;
            sMachine.Empty();
        }
    }
    else 
    {              // local machine, use standard handle.
        sMachine = TEXT("Local");
        hHandle = HKEY_PERFORMANCE_DATA;
        dwRet = 0;
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provperf.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVPERF.CPP

Abstract:

	Defines the acutal "Put" and "Get" functions for the
	performance counter provider.  The format of the mapping
	string is;
			  machine|Object|counter[|instance]
	Examples;
			  local|memory|available bytes
			  a-davj2|LogicalDisk|Free Megabytes|C:

History:

	a-davj  9-27-95    Created.

--*/

#include "precomp.h"
#include <tchar.h>
#include "provperf.h"
#include "cvariant.h"

// maximum amount of time to wait for exclusive access

#define MAX_EXEC_WAIT 5000


//***************************************************************************
//
//  AddTesterDetails
//
//  DESCRIPTION:
//
//  This function is used add the counter type to the property and is useful
//  to wbem testers.  Normal users dont want the overhead caused by this.
//
//  PARAMETERS:
//
//  pClassInt           Object being refreshed
//  PropName            Property Name
//  dwCtrType           counter type
//
//  RETURN VALUE:
//
//  always 0
//
//***************************************************************************

void AddTesterDetails(IWbemClassObject FAR * pClassInt,BSTR PropName,DWORD dwCtrType)
{
    // Get the qualifier pointer for the property

    IWbemQualifierSet * pQualifier = NULL;

    // Get an Qualifier set interface.

    SCODE sc = pClassInt->GetPropertyQualifierSet(PropName,&pQualifier); // Get prop attribute
    if(FAILED(sc))
        return;

    WCHAR wcName[40];

    switch(dwCtrType)
    {
        case PERF_COUNTER_COUNTER:
            wcsncpy(wcName,L"PERF_COUNTER_COUNTER", 39);
            break;

        case PERF_COUNTER_TIMER:
            wcsncpy(wcName,L"PERF_COUNTER_TIMER", 39);
            break;

        case PERF_COUNTER_QUEUELEN_TYPE:
            wcsncpy(wcName,L"PERF_COUNTER_QUEUELEN_TYPE", 39);
            break;

        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_QUEUELEN_TYPE", 39);
            break;

        case PERF_COUNTER_BULK_COUNT:
            wcsncpy(wcName,L"PERF_COUNTER_BULK_COUNT", 39);
            break;

        case PERF_COUNTER_TEXT:
            wcsncpy(wcName,L"PERF_COUNTER_TEXT", 39);
            break;

        case PERF_COUNTER_RAWCOUNT:
            wcsncpy(wcName,L"PERF_COUNTER_RAWCOUNT", 39);
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_RAWCOUNT", 39);
            break;

        case PERF_COUNTER_RAWCOUNT_HEX:
            wcsncpy(wcName,L"PERF_COUNTER_RAWCOUNT_HEX", 39);
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_RAWCOUNT_HEX", 39);
            break;

        case PERF_SAMPLE_FRACTION:
            wcsncpy(wcName,L"PERF_SAMPLE_FRACTION", 39);
            break;

        case PERF_SAMPLE_COUNTER:
            wcsncpy(wcName,L"PERF_SAMPLE_COUNTER", 39);
            break;

        case PERF_COUNTER_NODATA:
            wcsncpy(wcName,L"PERF_COUNTER_NODATA", 39);
            break;

        case PERF_COUNTER_TIMER_INV:
            wcsncpy(wcName,L"PERF_COUNTER_TIMER_INV", 39);
            break;

        case PERF_SAMPLE_BASE:
            wcsncpy(wcName,L"PERF_SAMPLE_BASE", 39);
            break;

        case PERF_AVERAGE_TIMER:
            wcsncpy(wcName,L"PERF_AVERAGE_TIMER", 39);
            break;

        case PERF_AVERAGE_BASE:
            wcsncpy(wcName,L"PERF_AVERAGE_BASE", 39);
            break;

        case PERF_AVERAGE_BULK:
            wcsncpy(wcName,L"PERF_AVERAGE_BULK", 39);
            break;

        case PERF_100NSEC_TIMER:
            wcsncpy(wcName,L"PERF_100NSEC_TIMER", 39);
            break;

        case PERF_100NSEC_TIMER_INV:
            wcsncpy(wcName,L"PERF_100NSEC_TIMER_INV", 39);
            break;

        case PERF_COUNTER_MULTI_TIMER:
            wcsncpy(wcName,L"PERF_COUNTER_MULTI_TIMER", 39);
            break;

        case PERF_COUNTER_MULTI_TIMER_INV:
            wcsncpy(wcName,L"PERF_COUNTER_MULTI_TIMER_INV", 39);
            break;

        case PERF_COUNTER_MULTI_BASE:
            wcsncpy(wcName,L"PERF_COUNTER_MULTI_BASE", 39);
            break;

        case PERF_100NSEC_MULTI_TIMER:
            wcsncpy(wcName,L"PERF_100NSEC_MULTI_TIMER", 39);
            break;

        case PERF_100NSEC_MULTI_TIMER_INV:
            wcsncpy(wcName,L"PERF_100NSEC_MULTI_TIMER_INV", 39);
            break;

        case PERF_RAW_FRACTION:
            wcsncpy(wcName,L"PERF_RAW_FRACTION", 39);
            break;

        case PERF_RAW_BASE:
            wcsncpy(wcName,L"PERF_RAW_BASE", 39);
            break;

        case PERF_ELAPSED_TIME:
            wcsncpy(wcName,L"PERF_ELAPSED_TIME", 39);
            break;

        case PERF_COUNTER_HISTOGRAM_TYPE:
            wcsncpy(wcName,L"PERF_COUNTER_HISTOGRAM_TYPE", 39);
            break;

        case PERF_COUNTER_DELTA:
            wcsncpy(wcName,L"PERF_COUNTER_DELTA", 39);
            break;

        case PERF_COUNTER_LARGE_DELTA:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_DELTA", 39);
            break;

        default:
            swprintf(wcName,L"0x%x", dwCtrType);
    }
    wcName[39] = 0;
    CVariant var(wcName);
    
    BSTR bstr = SysAllocString(L"CounterType");
    if(bstr)
    {
        sc = pQualifier->Put(bstr, var.GetVarPtr(), 0);
        SysFreeString(bstr);
    }
    pQualifier->Release();

}


//***************************************************************************
//
//  CImpPerf::CImpPerf
//
//  DESCRIPTION:
//
//  Constuctor.
//
//  PARAMETERS:
//
//***************************************************************************

CImpPerf::CImpPerf()
{
    wcscpy(wcCLSID,L"{F00B4404-F8F1-11CE-A5B6-00AA00680C3F}");
    sMachine = TEXT("local");
    hKeyMachine = HKEY_LOCAL_MACHINE;
    dwLastTimeUsed = 0;
    hKeyPerf =    HKEY_PERFORMANCE_DATA;
    TitleBuffer = NULL;
    hExec = CreateMutex(NULL, false, TEXT("WbemPerformanceDataMutex"));
    m_hTermEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    return;
}

//***************************************************************************
//
//  CImpPerf::~CImpPerf
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CImpPerf::~CImpPerf()
{
    bool bGotMutex = false;
    if(hExec)
    {
        DWORD dwRet = WaitForSingleObject(hExec,2*MAX_EXEC_WAIT);  
        if(dwRet == WAIT_OBJECT_0 || dwRet == WAIT_ABANDONED)
            bGotMutex = true;
    }
    if(bGotMutex)
        ReleaseMutex(hExec);
    FreeStuff();
    sMachine.Empty();
    if(hExec)
        CloseHandle(hExec);
    if(m_hTermEvent)
        CloseHandle(m_hTermEvent);
}

//***************************************************************************
//
//  SCODE CImpPerf::LoadData
//
//  DESCRIPTION:
//
//  Loads up the perf monitor data.
//
//  PARAMETERS:
//
//  ProvObj             Object containing the property context string.
//  pls                 Where to put the data
//  piObject            Identifies the perf mon object
//  piCounter           Identifies the perf mon counter
//  **ppNew             Created data block
//  bJustGettingInstances Flag which indicates that we are actully
//                      looking for the instance names.
//
//  RETURN VALUE:
//
//  WBEM_E_INVALID_PARAMETER     Bad  context string
//  WBEM_E_OUT_OF_MEMORY         low memory
//  otherwise error from called function
//
//***************************************************************************

SCODE CImpPerf::LoadData(
                        CProvObj & ProvObj,
                        LINESTRUCT * pls,
                        int * piObject, 
                        int * piCounter,
                        PERF_DATA_BLOCK **ppNew,
                        BOOL bJustGettingInstances)
{
    SCODE sc;
    BOOL bChange;
    if( ( ProvObj.sGetToken(0) == NULL ) || ( piObject == NULL ) || ( piCounter == NULL ) ) 
        return WBEM_E_INVALID_PARAMETER;  //BAD MAPPING STRING
 
    // Determine if there has been a change in the machine being
    // accessed.  Save the current machine and get the handles if
    // there was a change.

    bChange = lstrcmpi(sMachine,ProvObj.sGetToken(0));
    sMachine = ProvObj.sGetToken(0);

    if(bChange)
    {
        sc = dwGetRegHandles(ProvObj.sGetToken(0));
        if(sc != S_OK)
            return sc;
    }

    // build up a table of the performance strings and
    // their corresponding indexes.  This only needs to be done
    // when the buffer is empty or when the machine changes.  

    if(bChange || TitleBuffer == NULL) 
    {
        sc = GetPerfTitleSz ();
        if(sc != S_OK) 
            return sc;
    }

    // get the indexs for the object and counter names

    dwLastTimeUsed = GetCurrentTime();
    *piObject = iGetTitleIndex(ProvObj.sGetToken(1));
    if(bJustGettingInstances)
        *piCounter = 0;
    else    
        *piCounter = iGetTitleIndex(ProvObj.sGetToken(2));
    if(*piObject == -1 || *piCounter == -1) 
    {
        return WBEM_E_INVALID_PARAMETER;  // bad mapping string
    }

    // Using the index for the object, get the perf counter data
    // data.

    sc = Cache.dwGetNew(ProvObj.sGetToken(0),*piObject,(LPSTR *)ppNew,pls);
    return sc;
} 

//***************************************************************************
//
//  SCODE CImpPerf::RefreshProperty
//
//  DESCRIPTION:
//
//  Gets the value of a single property from the NT performance
//  counter data.
//
//  PARAMETERS:
//
//  lFlags              flags.  Not currently used
//  pClassInt           Instance object
//  PropName            Property name
//  ProvObj             Object containing the property context string.
//  pPackage            Caching object
//  pVar                Points to value to set
//  bTesterDetails      Provide extra info for testers
//  RETURN VALUE:
//
//  S_OK                all is well
//  else probably set by LoadData or FindData.
//
//***************************************************************************

SCODE CImpPerf::RefreshProperty(
                        IN long lFlags,
                        IN IWbemClassObject FAR * pClassInt,
                        IN BSTR PropName,
                        IN CProvObj & ProvObj,
                        OUT IN CObject * pPackage,
                        OUT CVariant * pVar, BOOL bTesterDetails)
{
    DWORD dwCtrType;
    float fRet;
    SCODE sc;
    int iObject,iCounter;
    PERF_DATA_BLOCK *  pNew, * pOld;
    DWORD dwSize;
    LINESTRUCT ls;
    void * pCountData, *pIgnore;
    CVariant vPerf;

    //  The perf counter provider keeps some rather expensive data and 
    //  so it doesnt support complete reentrancy. 

    if(hExec) 
    {
        DWORD dwRet;
        dwRet = WaitForSingleObject(hExec,MAX_EXEC_WAIT);  
        if(dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
            return WBEM_E_FAILED; 
    }
    else
        return WBEM_E_FAILED;

    // Load up the data

    sc = LoadData(ProvObj,&ls,&iObject,&iCounter,&pNew,FALSE);
    if(sc != S_OK)
        goto Done;

    // Find the desired data.
    
    sc = FindData(pNew,iObject,iCounter,ProvObj,&dwSize,&pCountData,
            &ls,TRUE,NULL); // find data sets the error in pMo!
    if(sc != S_OK) 
        goto Done;

    // determine what type of counter it is

    dwCtrType = ls.lnCounterType & 0xc00;

    if(dwCtrType == PERF_TYPE_COUNTER) 
    {
        
        // This type of counter requires time average data.  Get the cache to
        // get two buffers which are separated by a minimum amount of time

        sc = Cache.dwGetPair(ProvObj.sGetToken(0),iObject,
                                    (LPSTR *)&pOld,(LPSTR *)&pNew,&ls);
        if(sc != S_OK) 
            goto Done;
        sc = FindData(pNew,iObject,iCounter,ProvObj,&dwSize,&pCountData,&ls,TRUE,NULL);
        if(sc != S_OK) 
            goto Done;
        sc = FindData(pOld,iObject,iCounter,ProvObj,&dwSize,&pIgnore,&ls,FALSE,NULL);
        if(sc != S_OK) 
            goto Done;
        fRet = CounterEntry(&ls);
        vPerf.SetData(&fRet,VT_R4);
    
    }
    else if(dwCtrType == PERF_TYPE_NUMBER) 
    {
        
        // Simple counter. 

        fRet = CounterEntry(&ls);
        vPerf.SetData(&fRet,VT_R4);
    }
    else if(dwCtrType == PERF_TYPE_TEXT) 
    {
        
        // Text.  Allocate enough space to hold the text and
        // copy the text into temp WCHAR buffer since it is not
        // clear from the documentation if the data in the block
        // is null terminated.        
        
        WCHAR * pNew = (WCHAR *)CoTaskMemAlloc(dwSize+2);
        if(pNew == NULL) 
        {
            sc = WBEM_E_OUT_OF_MEMORY;
            goto Done;
        }
        memset(pNew,0,dwSize+2);
        if(ls.lnCounterType & 0x10000)
            mbstowcs(pNew,(char *)pCountData,dwSize);
        else
            memcpy(pNew,pCountData,dwSize);

        VARIANT * pVar = vPerf.GetVarPtr();
        VariantClear(pVar);
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(pNew);
        if(pVar->bstrVal == NULL)
            sc = WBEM_E_OUT_OF_MEMORY;
        CoTaskMemFree(pNew);
        if(sc != S_OK) 
        {
            goto Done;
        }
    }
        
    // Convert the data into the desired form
    sc = vPerf.DoPut(lFlags,pClassInt,PropName,pVar);

    if(bTesterDetails)
        AddTesterDetails(pClassInt, PropName, dwCtrType);

Done:
    if(hExec)
        ReleaseMutex(hExec);
    return sc;
}

//***************************************************************************
//
//  SCODE CImpPerf::UpdateProperty
//
//  DESCRIPTION:
//
//  Normally this routine is used to save properties, but NT 
//  performance counter data is Read only.
//
//  PARAMETERS:
//
//  lFlags              N/A
//  pClassInt           N/A
//  PropName            N/A
//  ProvObj             N/A
//  pPackage            N/A
//  pVar                N/A
//
//  RETURN VALUE:
//
//  E_NOTIMPL
//
//***************************************************************************

SCODE CImpPerf::UpdateProperty(
                        long lFlags,
                        IWbemClassObject FAR * pClassInt,
                        BSTR PropName,
                        CProvObj & ProvObj,
                        CObject * pPackage,
                        CVariant * pVar)
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  void CImpPerf::FreeStuff
//
//  DESCRIPTION:
//
//  Used to free up memory that is no longer needed as well as
//  freeing up registry handles.
//
//***************************************************************************

void CImpPerf::FreeStuff(void)
{
    if(hKeyMachine != HKEY_LOCAL_MACHINE)
    {
        RegCloseKey(hKeyMachine);
        hKeyMachine = NULL;
    }
    if(hKeyPerf != HKEY_PERFORMANCE_DATA)
    {
        RegCloseKey(hKeyPerf);
        hKeyPerf = NULL;
    }

    if(TitleBuffer)
    {
        delete TitleBuffer;
        TitleBuffer = NULL;
    }
    m_IndexCache.Empty();

    return;
}

//***************************************************************************
//
//  DWORD   CImpPerf::GetPerfTitleSz 
//
//  DESCRIPTION:
//
//  Retrieves the performance data title strings.
//  This call retrieves english version of the title strings.
//
//  RETURN VALUE:
//
//  0                   if OK
//  WBEM_E_OUT_OF_MEMORY if low memory
//  else set by RegOpenKeyEx
//
//***************************************************************************

DWORD   CImpPerf::GetPerfTitleSz ()
{
    HKEY    hKey1;
    DWORD   Type;
    DWORD   DataSize;
    DWORD   dwR;

    // Free any existing stuff

    if(TitleBuffer)
    {
        delete TitleBuffer;
        TitleBuffer = NULL;
    }
    m_IndexCache.Empty();
    
    // Initialize
    //
    hKey1        = NULL;

    // Open the perflib key to find out the last counter's index and system version.
    
//    char cRegPath[100];
//    DWORD dwLoc = GetUserDefaultLCID();
//    dwLoc &= 0x3ff;        // mask off the high word
//    wsprintf(cRegPath,"software\\microsoft\\windows nt\\currentversion\\perflib\\%03x",
//        dwLoc);
//    dwR = RegOpenKeyEx (hKeyMachine,
//                        cRegPath,
//                        0,
//                        KEY_READ,
//                        &hKey1);
//    if (dwR != S_OK)
//    {
        dwR = RegOpenKeyEx (hKeyMachine,
                        TEXT("software\\microsoft\\windows nt\\currentversion\\perflib\\009"),
                        0,
                        KEY_READ,
                        &hKey1);
//    }

    if (dwR != S_OK)
        goto done;
         
    // Find out the size of the data.
    //
    dwR = RegQueryValueEx (hKey1, TEXT("Counter"), 
                            0, &Type, 0, &DataSize);
    if (dwR != S_OK)
        goto done;

    // Allocate memory
    //

    TitleBuffer = new TCHAR[DataSize];
    if (!TitleBuffer)
    {
        dwR = WBEM_E_OUT_OF_MEMORY;
        goto done;
    }

    // Query the data
    //
    dwR = RegQueryValueEx (hKey1, TEXT("Counter"), 
                0, &Type, (BYTE *)TitleBuffer, &DataSize);

done:

    if(dwR == 5)
        dwR = WBEM_E_ACCESS_DENIED;
    if(hKey1 != NULL)
        RegCloseKey(hKey1); 
    return dwR;

} 

//***************************************************************************
//
//  DWORD CImpPerf::dwGetRegHandles
//
//  DESCRIPTION:
//
//  Sets the handles for the local computer and the performance
//  information.
//
//  PARAMETERS:
//
//  pMachine            Machine name
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  otherwise return is from RegConnectRegistry  
//***************************************************************************

DWORD CImpPerf::dwGetRegHandles(
                    const TCHAR * pMachine)
{
    DWORD dwRet;
    TCHAR pTemp[256];
    if(pMachine == NULL)
        return WBEM_E_INVALID_PARAMETER;
    lstrcpy(pTemp,pMachine);

    // if the current handles are to a remote machine, then free them

    if(!lstrcmpi(sMachine,TEXT("local"))) 
    {
        if(hKeyPerf && hKeyPerf != HKEY_PERFORMANCE_DATA)
            RegCloseKey(hKeyPerf);
        if(hKeyMachine)
            RegCloseKey(hKeyMachine);
        hKeyPerf = hKeyMachine = NULL;
    }

    // Determine if the target is remote or local

    if(lstrcmpi(pMachine,TEXT("local"))) 
    {
    
        // Remote, connect up

        dwRet = RegConnectRegistry(pTemp,HKEY_PERFORMANCE_DATA,
                    &hKeyPerf);
        if(dwRet != S_OK) // could not remote connect
            return dwRet;

        dwRet = RegConnectRegistry(pTemp,HKEY_LOCAL_MACHINE,
                    &hKeyMachine);
        if(dwRet != S_OK)
        {
            RegCloseKey(hKeyPerf);
            hKeyPerf = hKeyMachine = NULL;
            return dwRet;
        }
    }
    else 
    {
        hKeyMachine = HKEY_LOCAL_MACHINE;
        hKeyPerf = HKEY_PERFORMANCE_DATA;
    }
    return 0;
}

//***************************************************************************
//
//  int CImpPerf::iGetTitleIndex
//
//  DESCRIPTION:
//
//  Looks for the name in the buffer containing the names and 
//  returns the index.  The buffer is a series of strings with a double
//  null at the end.  Each counter or object is represented by a pair of
//  strings with the first having the number and the second having the 
//  text.  This code goes through the pairs, storing the number string and
//  checking the text vs the input.  If a match, then the number is returned.
//
//  PARAMETERS:
//
//  pSearch             String to be found in buffer
//
//  RETURN VALUE:
//
//  integer that goes with the string.  -1 if not found
//
//***************************************************************************

int CImpPerf::iGetTitleIndex(
                    const TCHAR * pSearch)
{
    DWORD Index;
    int Len;
    TCHAR * pIndex;
    if(pSearch == NULL)
        return -1;
    Index = m_IndexCache.Find(pSearch);
    if(Index != -1)
        return Index;
    int iRet = -1;

    LPTSTR szTitle = TitleBuffer;

    while (Len = lstrlen (szTitle))
    {
        pIndex = szTitle;    // save pointer to number

        szTitle = szTitle + Len +1; // skip to name

        if (pSearch != NULL && !lstrcmpi(pSearch,szTitle)) 
        {  // found string!
            Index = _ttoi (pIndex);    // get number
            m_IndexCache.Add(szTitle, Index);
            if(iRet == -1)
                iRet = Index;
        }

        szTitle = szTitle + lstrlen (szTitle) +1; // skip to next number
    }
    return iRet;
}


//***************************************************************************
//
//  SCODE CImpPerf::FindData
//
//  DESCRIPTION:
//
//  Finds the counter in the data block.  Note that the steps are quite
//  involved and an understanding of the structure of performance data
//  is probably required.  See chap 66 of the Win32 Programmers Ref.
//
//
//  PARAMETERS:
//
//  pData               Data block to be searched
//  iObj                Int which identifies the object
//  iCount              Int which identifies the counter
//  ProvObj             Object containing the parsed context string
//  pdwSize             Size of data
//  **ppRetData         points to data
//  pls                 Line structure
//  bNew                If true, indicates that we are searching the newest
//                      sample of data.
//  pInfo               If set, points to an collection object which 
//                      contains a list of instance names.  By being set
//                      the function doesnt look for actual data, instead
//                      it is used just to get the instance names.
//
//  RETURN VALUE:
//
//  S_OK                    all is well
//  WBEM_E_FAILED            couldnt find the data in the block
//  
//***************************************************************************

SCODE CImpPerf::FindData(
                    IN PERF_DATA_BLOCK * pData,
                    IN int iObj,
                    IN int iCount,
                    IN CProvObj & ProvObj,
                    OUT DWORD * pdwSize,
                    OUT void **ppRetData,
                    OUT PLINESTRUCT pls,
                    IN BOOL bNew,
                    OUT CEnumPerfInfo * pInfo)
{
    try
    {
    int iIndex;
    BOOL bEqual;
    DWORD dwSize = 0;
    DWORD dwType,dwTypeBase = 0;
    *ppRetData = NULL;
    void * pVoid = NULL, * pVoidBase = NULL;
    PPERF_OBJECT_TYPE pObj = NULL;
    PPERF_COUNTER_DEFINITION pCount = NULL;
    PPERF_COUNTER_DEFINITION pCountBase= NULL;
    PPERF_INSTANCE_DEFINITION pInst = NULL;

    // Some objects, such as disks, have what are called instances and in
    // that case the provider string will have an extra token with the 
    // instance name in it.

    WCHAR wInstName[MAX_PATH];
    wInstName[0] = 0;
    WCHAR * pwInstName = wInstName;
    long lDuplicateNum = 0;

    // If there is an instance name, convert it to WCHAR.  Also, the 
    // instance name may be of the for "[123]chars" and in this case the
    // didits between "[]" are converted to a number and the actual name
    // starts after the ']'.

    if(ProvObj.iGetNumTokens() > 3) 
    {
        if(lstrlen(ProvObj.sGetToken(3)) > MAX_PATH -1)
            return WBEM_E_FAILED;
#ifdef UNICODE
       wcscpy(wInstName, ProvObj.sGetToken(3));
#else
        mbstowcs(wInstName, ProvObj.sGetToken(3), MAX_PATH-1);
#endif
        if(wInstName[0] == L'[')
        {
            lDuplicateNum = _wtol(&wInstName[1]);
            for(pwInstName = &wInstName[1]; *pwInstName && *pwInstName != L']'; 
                        pwInstName++);      // INTENTIONAL SEMI!
            if(*pwInstName == L']')
                pwInstName++;
        }
    }
    else
    {
        // if there is not an instance name and the argument for enumeration is null, then we have a
        // bad path

        if(pInfo == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
    }


    // Go through the list of objects and find the one
    // that matches iObj

    pObj = (PPERF_OBJECT_TYPE)((PBYTE)pData + pData->HeaderLength);
    for(iIndex = 0; iIndex < (int)pData->NumObjectTypes; iIndex++) 
    {
        if((int)pObj->ObjectNameTitleIndex == iObj)
            break; // found it!
        pObj = (PPERF_OBJECT_TYPE)((PBYTE)pObj + pObj->TotalByteLength);
    }
    if(iIndex == (int)pData->NumObjectTypes) 
        return WBEM_E_FAILED; // never found object in the block
    
    // Object was found, set the object type data

    if(bNew) 
    {
        pls->ObjPerfFreq = *(LONGLONG UNALIGNED *)(&pObj->PerfFreq);
        pls->ObjCounterTimeNew = *(LONGLONG UNALIGNED *)(&pObj->PerfTime);
    }
    else
        pls->ObjCounterTimeOld = *(LONGLONG UNALIGNED *)(&pObj->PerfTime);

    // Go through the list of counters for the object and find the one that 
    // matches iCount.  Note that some counter names may be have more than 
    // one id.  Therefore, try the other ids if the intial one doesnt work.

    bool bFound = false;
    bool bEndOfList = false;
    int lTry = 0;               // how may times we have tried
    do 
    {

        pCount = (PPERF_COUNTER_DEFINITION)((PBYTE)pObj + pObj->HeaderLength);
        for(iIndex = 0; iIndex < (int)pObj->NumCounters; iIndex++) 
        {
            if((int)pCount->CounterNameTitleIndex == iCount || pInfo)
            {
                bFound = true;
                break; // found it!
            }
            pCount = (PPERF_COUNTER_DEFINITION)((PBYTE)pCount + pCount->ByteLength);
        }
        if(bFound == false)
        {
            lTry++;
            iCount = m_IndexCache.Find(ProvObj.sGetToken(2), lTry);
            if(iCount == -1)
                bEndOfList = true;
        }
        
    } while (bFound == false && bEndOfList == false);


    if(bFound == false) 
    {
        return WBEM_E_FAILED; // never found object in the block
    }

    // The counter was found, save the counter information
    // If the counter is not the last one in the object, then the
    // next one might be the base which is used for certain calculations

    dwType = pCount->CounterType;
    pls->lnCounterType = pCount->CounterType;
    if(iIndex < (int)pObj->NumCounters - 1) 
    {

        // might be the base

        pCountBase = (PPERF_COUNTER_DEFINITION)((PBYTE)pCount + 
                            pCount->ByteLength);
        dwTypeBase = pCountBase->CounterType;
    }

    // Get a pointer to the start of the perf counter block
    // There are two cases:  If there are no instances, then
    // the data starts after the last counter descriptor.  
    // If there are instances, each instance has it's own block.

    pVoid = NULL;
    if(pObj->NumInstances == -1) 
    {
		// The object is a singleton

        if(pInfo)         // If we are enumerating instances
        {
            pInfo->AddEntry(L"@");
            return S_OK; 
        }

        // easy case, get offset into data, add offset
        // for particular counter.

        pVoid = (PBYTE)pObj + pObj->DefinitionLength 
                     + pCount->CounterOffset;
        if(pCountBase)
            pVoidBase = (PBYTE)pObj + pObj->DefinitionLength 
                     + pCountBase->CounterOffset;
    }
    else if(pObj->NumInstances > 0) 
    {

		WCHAR wNum[12];
		
        // hard case, got a list of instaces, start off
        // by getting a pointer to the first one.

        long lNumDupsSoFar = 0;
        pInst= (PPERF_INSTANCE_DEFINITION)((PBYTE)pObj + pObj->DefinitionLength);
        for(iIndex = 0; iIndex < (int)pObj->NumInstances; iIndex++) 
        {

            // Each instance has a unicode name, get it and
            // compare it against the name passed in the
            // provider string.

            PPERF_COUNTER_BLOCK pCtrBlk;
            WCHAR * pwName;
            if(pInst->UniqueID == PERF_NO_UNIQUE_ID)
            	pwName = (WCHAR *)((PBYTE)pInst + pInst->NameOffset);
            else
            {
            	_ltow (pInst->UniqueID, wNum, 10);
				pwName = wNum;
            }
            if(pInfo)
            {
                // We we are mearly getting the instance names, just add the
                // instance name to the list.  If the instance name is a 
                // duplicate, prepend "[num]" to the name.

                if(wcslen(pwName) > 240)
                    continue;       // should never happen but just in case!
                int iRet = pInfo->GetNumDuplicates(pwName);
                if(iRet > 0)
                {
                    swprintf(wInstName,L"[%ld]", iRet);
                    wcscat(wInstName, pwName);
                }
                else
                    wcscpy(wInstName, pwName);
                pInfo->AddEntry(wInstName);
            }
            else 
            {
            
              // for now the code assumes that the first instance
              // will be retrieved if the instance is not specified

              if(wcslen(pwInstName) == 0)
                bEqual = TRUE;
              else 
              {  
                bEqual = !_wcsicmp(pwName ,pwInstName);
                if(lDuplicateNum > lNumDupsSoFar && bEqual)
                {
                    bEqual = FALSE;
                    lNumDupsSoFar++;
                }
              }
            
              if(bEqual) 
              {
                
                // we found the instance !!!!  Data is found
                // in data block following instance offset 
                // appropriatly for this counter.

                pVoid = (PBYTE)pInst + pInst->ByteLength +
                    pCount->CounterOffset;
                if(pCountBase)
                    pVoidBase =  (PBYTE)pInst + pInst->ByteLength +
                                   pCountBase->CounterOffset;
                break;
              }
            }
            
            // not found yet, next instance is after this
            // instance + this instance's counter data

            pCtrBlk = (PPERF_COUNTER_BLOCK)((PBYTE)pInst +
                        pInst->ByteLength);
            pInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)pInst +
                pInst->ByteLength + pCtrBlk->ByteLength);
        }
    }

    // Bail out if data was never found or if we were just looking for instances

    if(pInfo)
        return pInfo->GetStatus();

    if(pVoid == NULL) 
    {
        return WBEM_E_FAILED; // never found object in the block
    }

    // Move the counter data and possibly the base data into the structure
    // Note that text is handled via the ppRetData pointer and is not
    // done here.

    DWORD dwSizeField = dwType & 0x300;
    void * pDest = (bNew) ? &pls->lnaCounterValue[0] : &pls->lnaOldCounterValue[0]; 
    if(dwSizeField == PERF_SIZE_DWORD) 
    {
        memset(pDest,0,sizeof(LONGLONG));  // zero out unused portions
        dwSize = sizeof(DWORD);
        memcpy(pDest,pVoid,dwSize);
    }
    else if(dwSizeField == PERF_SIZE_LARGE) 
    {
        dwSize = sizeof(LONGLONG);
        memcpy(pDest,pVoid,dwSize);
    }
    else if(dwSizeField == PERF_SIZE_VARIABLE_LEN) 
        dwSize = pCount->CounterSize;   // this sets it for text
    else 
    {
        return WBEM_E_FAILED; // never found object in the block
    }

    // possibly do the base now.  

    dwSizeField = dwTypeBase & 0x300;
    pDest = (bNew) ? &pls->lnaCounterValue[1] : &pls->lnaOldCounterValue[1]; 
    if(dwSizeField == PERF_SIZE_DWORD && pVoidBase) 
    {
        memset(pDest,0,sizeof(LONGLONG));
        memcpy(pDest,pVoidBase,sizeof(DWORD));
    }
    else if(dwSizeField == PERF_SIZE_LARGE && pVoidBase)
        memcpy(pDest,pVoidBase,sizeof(LONGLONG));

    *ppRetData = pVoid;  // Set to return data
    *pdwSize = dwSize;
    return S_OK;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
 }

//***************************************************************************
//
//  SCODE CImpPerf::MakeEnum
//
//  DESCRIPTION:
//
//  Creates a CEnumPerfInfo object which can be used for enumeration
//
//  PARAMETERS:
//
//  pClass              Pointer to the class object.
//  ProvObj             Object containing the property context string.
//  ppInfo              Set to point to an collection object which has
//                      the keynames of the instances.
//
//  RETURN VALUE:
//
//  S_OK                all is well,
//  else set by LoadData or FindData
//  
//***************************************************************************

SCODE CImpPerf::MakeEnum(
                    IN IWbemClassObject * pClass,
                    IN CProvObj & ProvObj, 
                    OUT CEnumInfo ** ppInfo)
{
    SCODE sc;
    int iObject,iCounter;
    PERF_DATA_BLOCK *  pNew;
    DWORD dwSize;
    LINESTRUCT ls;
    void * pCountData;
    CVariant vPerf;
    CEnumPerfInfo * pInfo = NULL;
    *ppInfo = NULL;

    //  The perf counter provider keeps some rather expensive data and 
    //  so it doesnt support complete reentrancy. 

    if(hExec) 
    {
        DWORD dwRet;
        dwRet = WaitForSingleObject(hExec,MAX_EXEC_WAIT);  
        if(dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
            return WBEM_E_FAILED; 
    }
    else
        return WBEM_E_FAILED;

    // Load up the data

    sc = LoadData(ProvObj,&ls,&iObject,&iCounter,&pNew,TRUE);
    if(sc != S_OK)
        goto DoneMakeEnum;
    
    // Create a new CEnumPerfInfo object.  Its entries will be filled
    // in by Find Data.
    
    pInfo = new CEnumPerfInfo();
    if(pInfo == NULL) 
    {
        sc = WBEM_E_OUT_OF_MEMORY;
        goto DoneMakeEnum;
    }
    sc = FindData(pNew,iObject,iCounter,ProvObj,&dwSize,&pCountData,
            &ls,TRUE,pInfo); 
    if(sc != S_OK)
        delete pInfo;

DoneMakeEnum:
    if(sc == S_OK)
        *ppInfo = pInfo;
    if(hExec)
        ReleaseMutex(hExec);
    return sc;
}
                                 
//***************************************************************************
//
//  SCODE CImpPerf::GetKey
//
//  DESCRIPTION:
//
//  Gets the key name of an entry in the enumeration list.
//
//  PARAMETERS:
//
//  pInfo               Collection list
//  iIndex              Index in the collection
//  ppKey               Set to the string.  MUST BE FREED with "delete"
//
//  RETURN VALUE:
//
//  S_OK                    if all is well
//  WBEM_E_INVALID_PARAMETER bad index
//  WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpPerf::GetKey(
                    IN CEnumInfo * pInfo,
                    IN int iIndex,
                    OUT LPWSTR * ppKey)
{
    CEnumPerfInfo * pPerfInfo = (CEnumPerfInfo *)pInfo;
    LPWSTR pEntry = pPerfInfo->GetEntry(iIndex);
    if(pEntry == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *ppKey = new WCHAR[wcslen(pEntry)+1];
    if(*ppKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    wcscpy(*ppKey,pEntry);
    return S_OK;
}

//***************************************************************************
//
//  SCODE CImpPerf::MergeStrings
//
//  DESCRIPTION:
//
//  Combines the Class Context, Key, and Property Context strings.
//
//  PARAMETERS:
//
//  ppOut               Output string.  MUST BE FREED VIA "delete"
//  pClassContext       Class context
//  pKey                Key property value
//  pPropContext        Property context
//
//  RETURN VALUE:
//
//  S_OK                    if all is well
//  WBEM_E_INVALID_PARAMETER context string
//  WBEM_E_OUT_OF_MEMORY
//  
//***************************************************************************

SCODE CImpPerf::MergeStrings(
                    OUT LPWSTR * ppOut,
                    IN LPWSTR  pClassContext,
                    IN LPWSTR  pKey,
                    IN LPWSTR  pPropContext)
{
    
    // Allocate space for output

    int iLen = 3;
    if(pClassContext)
        iLen += wcslen(pClassContext);
    if(pKey)
        iLen += wcslen(pKey);
    if(pPropContext)
        iLen += wcslen(pPropContext);
    else
        return WBEM_E_INVALID_PARAMETER;  // should always have this!
    *ppOut = new WCHAR[iLen];
    if(*ppOut == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //todo todo, remove this demo specical
    if(pPropContext[0] == L'@')
    {
        wcscpy(*ppOut,pPropContext+1);
        return S_OK;
    }
    //todo todo, remove this demo specical

    // simplecase is that everything is in the property context.  That would
    // be the case when the provider is being used as a simple dynamic 
    // property provider

    if(pClassContext == NULL || pKey == NULL) 
    {
        wcscpy(*ppOut,pPropContext);
        return S_OK;
    }

    // Copy the class context, property, and finally the key

    wcscpy(*ppOut,pClassContext);
    wcscat(*ppOut,L"|");
    wcscat(*ppOut,pPropContext);
    wcscat(*ppOut,L"|");
    wcscat(*ppOut,pKey);
    return S_OK;
}

//***************************************************************************
//
//  CEnumPerfInfo::CEnumPerfInfo
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumPerfInfo::CEnumPerfInfo()
{
    m_iNumUniChar = 0;
    m_iNumEntries = 0;
    m_pBuffer = NULL;
    m_status = S_OK;
}

//***************************************************************************
//
//  CEnumPerfInfo::~CEnumPerfInfo
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumPerfInfo::~CEnumPerfInfo()
{
    if(m_pBuffer)
        delete m_pBuffer;
}

//***************************************************************************
//
//  void CEnumPerfInfo::AddEntry
//
//  DESCRIPTION:
//
//  Adds an entry to the enumeration list.
//
//  PARAMETERS:
//
//  pNew                String to add to collection.
//
//***************************************************************************

void CEnumPerfInfo::AddEntry(
                    LPWSTR pNew)
{
    if(m_status != S_OK)
        return;     // already had memory problems.
    int iNewSize = wcslen(pNew) + 1 + m_iNumUniChar;
    LPWSTR pNewBuff = new WCHAR[iNewSize];
    if(pNewBuff == NULL) 
    {
        m_status = WBEM_E_OUT_OF_MEMORY;
        return;
    }
    wcscpy(&pNewBuff[m_iNumUniChar],pNew);
    if(m_pBuffer) 
    {
        memcpy(pNewBuff,m_pBuffer,m_iNumUniChar*2);
        delete m_pBuffer;
    }
    m_iNumEntries++;
    m_iNumUniChar = iNewSize;
    m_pBuffer = pNewBuff;
}

//***************************************************************************
//
//  int CEnumPerfInfo::GetNumDuplicates
//
//  DESCRIPTION:
//
//  Checks the list to find duplicate entries.
//
//  PARAMETERS:
//
//  pwcTest             string to test for duplicates
//
//  RETURN VALUE:
//
//  number of matching strings in the collection.
//
//***************************************************************************

int CEnumPerfInfo::GetNumDuplicates(
                    LPWSTR pwcTest)
{
    int iRet = 0;
    int iCnt;
    LPWSTR pVal = m_pBuffer;
    for(iCnt = 0; iCnt < m_iNumEntries; iCnt++)
    {
        WCHAR * pwcText = pVal;

        // If the string is of the form "[number]text", skip the "[number]"
        // part.

        if(*pVal == L'[')
        {
            for(pwcText = pVal+1; *pwcText && *pwcText != L']';pwcText++);
            if(*pwcText == L']')
                pVal = pwcText+1;
        }
        if(!_wcsicmp(pwcTest, pVal))
            iRet++;
        pVal += wcslen(pVal) + 1;       
    }
    return iRet;
}


//***************************************************************************
//
//  LPWSTR CEnumPerfInfo::GetEntry
//
//  DESCRIPTION:
//
//  Gets a list entry.
//
//  PARAMETERS:
//
//  iIndex              collection index
//
//  RETURN VALUE:
//
//  pointer to string in index.  Should NOT be freed.
//  NULL if bad index
// 
//***************************************************************************

LPWSTR CEnumPerfInfo::GetEntry(
                    IN int iIndex)
{
    // fist check for bad conditions

    if(m_status != S_OK || iIndex < 0 || iIndex >= m_iNumEntries)
        return NULL;
    
    int iCnt;
    LPWSTR pRet = m_pBuffer;
    for(iCnt = 0; iCnt < iIndex; iCnt++)
        pRet += wcslen(pRet) + 1;       
    return pRet;
}

//***************************************************************************
//
//  CImpPerfProp::CImpPerfProp
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CImpPerfProp::CImpPerfProp()
{
    m_pImpDynProv = new CImpPerf();
}

//***************************************************************************
//
//  CImpPerfProp::~CImpPerfProp
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CImpPerfProp::~CImpPerfProp()
{
    if(m_pImpDynProv)
        delete m_pImpDynProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provcomp.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVCOMP.CPP

Abstract:

    Purpose: Defines the acutal "Put" and "Get" functions for the
             Ole compound file provider.

History:

    a-davj  10-10-95    v0.01

--*/

#include "precomp.h"
#include "stdafx.h"
#include <wbemidl.h>
#include "impdyn.h"

#define GET_FLAGS STGM_READ|STGM_SHARE_DENY_WRITE
#define PUT_FLAGS STGM_READWRITE|STGM_SHARE_EXCLUSIVE
enum {NORMAL, STRING, WSTRING, DBLOB, DCLSID, UNKNOWN};


void CImpComp::AddBlankData(CBuff * pBuff,DWORD dwType)
{            
    VARIANTARG vTemp;
    DWORD dwDataSize;
    BOOL bStringType;
    
    // If we have an variant array, then add an empty entry and be done
    if(dwType == VT_VARIANT) {
        DWORD dwEmpty = VT_EMPTY;   //TODO, is the right? maybe VT_NULL??
        pBuff->Add((void *)&dwEmpty,sizeof(DWORD));
        return;
        }
        
    // Create an empty variantarg, get its statistics
    VariantInit(&vTemp);

    vTemp.cyVal.int64 = 0;
    vTemp.vt = (VARTYPE)dwType;
    if(!bGetVariantStats(&vTemp, NULL,  &dwDataSize, &bStringType))
        return;
    
    if(!bStringType) {
        pBuff->Add((void *)&vTemp.cyVal.int64,dwDataSize);
        }
    else if (dwType == VT_BLOB){
        DWORD dwSize = 0;
        pBuff->Add((void *)&dwSize,sizeof(DWORD));
        }
    else {
        DWORD dwSize = 1;
        pBuff->Add((void *)&dwSize,sizeof(DWORD));
        pBuff->Add((void *)&vTemp.cyVal.int64,2); // add a null, 
        pBuff->RoundOff();
        }

}
//***************************************************************************
//
//  CImpComp::AddVariantData
//
//  Adds the property value to a buffer that is to be output.  For normal
//  data, this acutally sets the buffer.  However, for the case of array
//  data, it is probably adding to the buffer (unless its the first element)
//
//***************************************************************************

void CImpComp::AddVariantData(VARIANTARG * pIn,CBuff * pBuff) 
{
    void * pCopy;
    BOOL bSizeNeeded;
    DWORD dwDataSize;
    
    bGetVariantStats(pIn, NULL, &dwDataSize, &bSizeNeeded);

    // If strings, blobs etc, copy size in first

    if(bSizeNeeded) { 
        if(pIn->vt == VT_LPWSTR){
            DWORD dwTemp = dwDataSize /2 ;
            pBuff->Add((void*)&dwTemp,sizeof(DWORD));
            }
        else
            pBuff->Add((void*)&dwDataSize,sizeof(DWORD));
        pCopy = (void *)pIn->bstrVal;
        }
     else
        pCopy = (void *)&pIn->iVal;
      
    // copy the data

    pBuff->Add((void *)pCopy,dwDataSize);

    // round the data to a 4 byte boundry

    if(bSizeNeeded)
        pBuff->RoundOff();
    return;
}

//***************************************************************************
//
//  CImpComp::bCreateWriteArray
//
//  Create a buffer with an array of values.  This is used when writting
//  out properties that are members of arrays.  To do this, an array must 
//  be constructed.
//
//***************************************************************************

BOOL CImpComp::bCreateWriteArray(VARIANTARG * pIn, CBuff * pBuff,
    MODYNPROP *pMo, int iIndex, DWORD & dwType, BOOL bExisting, CProp * pProp)
{
    DWORD * dwp;
    DWORD dwExisting;       // number of existing entries
    DWORD dwNumElem;        // number of elements to be written
    DWORD dwTempType;
    SCODE sc;

    // If the property alread exists, get the current type and number
    // of existing elements.

    if(bExisting) {
        dwType = pProp->GetType();
        dwType &= ~VT_VECTOR;
        dwp = (DWORD *)pProp->Get();
        dwExisting = *dwp;
        }
    else {
        if(!bGetVariantStats(pIn, &dwType, NULL, NULL)){
            pMo->dwResult = ERROR_UNKNOWN;  // BAD INPUT DATA
            return FALSE;
            }
        dwExisting = 0;
        }
    
    // Determine the number of elements to write.  It may be more that the
    // number of existing elements when writting a new vector or adding to
    // an existing one

    if((unsigned)iIndex >= dwExisting)
        dwNumElem = iIndex + 1;     // iIndex has 0 as the first element
    else
        dwNumElem = dwExisting;
    
    // Copy in the number of elements

    pBuff->Add((void *)&dwNumElem,sizeof(DWORD));

    // Now build the output array one element at the time
    // todo, more error checking in here???

    DWORD dwCnt;
    for(dwCnt = 0; dwCnt < dwNumElem; dwCnt++) {
        if(dwCnt == (unsigned)iIndex) {
            
            // This element is being supplied by the caller
            
            if(!bExisting) {
            
                // no converstion necessary since this is a new array
            
                AddVariantData(pIn,pBuff);

                }
            else if(dwType == VT_VARIANT) {
            
                // write type first
                DWORD dwTemp = 0; 
                dwTemp = pIn->vt;
                pBuff->Add((void *)&dwTemp,sizeof(DWORD));
                
                // write the data;
                AddVariantData(pIn,pBuff);
                }
            else {
                // existing array that isnt VARIANT type.  Convert the input
                // data into the same format and then add

                VARIANTARG vTemp;
                VariantInit(&vTemp);
                vTemp.cyVal.int64 = 0;
                sc = OMSVariantChangeType(&vTemp,pIn,0,(VARTYPE)dwType);
                if(sc != S_OK) {
                    pMo->dwResult = sc;
                    return FALSE;
                }
                    
                // write the data;
                AddVariantData(&vTemp,pBuff);
                OMSVariantClear(&vTemp);        // all done, free it
                }
            }
        else if (dwCnt < dwExisting) {
            // Add from the read data
            int iIgnore;
            void * pTemp = ExtractData(pProp,dwTempType,dwCnt,TRUE);
            DWORD dwSkip = dwSkipSize((char *)pTemp,dwTempType,iIgnore);
            pBuff->Add(pTemp,dwSkip);
            }
        else
            // create a blank entry
            AddBlankData(pBuff,dwType);
        }
    dwType |= VT_VECTOR;
    return TRUE;
}

//***************************************************************************
//
//  CImpComp::bGetVariantStats
//
//  Determines various characteristics of a VARIANTARG.
//
//  Returns TRUE if the variant type is valid.
//
//***************************************************************************

BOOL CImpComp::bGetVariantStats(VARIANTARG * pIn, DWORD * pType, DWORD * pDataSize, BOOL * pSizeNeeded)
{
    BOOL bSizeNeeded = FALSE; // set to true for strings and blobs etc.
    DWORD dwDataSize = 0, dwType;
    void * pData = (void *)pIn->bstrVal;
    
    // normall the type is whatever is in the VARIANTARG.  However, 
    // certain new types, such as VT_UI4 are not in the ole spec and
    // might cause problems to older programs.  Therefore, the new
    // types have an equivalent older type returned.

    dwType = pIn->vt;

    // just in case we are running in a 16 bit environment

    if((sizeof(INT) == 2) && (pIn->vt == VT_INT || pIn->vt == VT_UINT))
        pIn->vt = VT_I2;
    
    // determine how big the data is, where to copy it from and determine
    // if the size needs to also be written.

    switch (pIn->vt) {
        case VT_I1:
        case VT_UI1:
        case VT_I2: 
        case VT_BOOL:
        case VT_UI2:    // all get handled as I2
            if(pIn->vt != VT_BOOL)
                dwType = VT_I2;
            dwDataSize = 2;
            break;

        case VT_R4: 
        case VT_I4: 
        case VT_INT:
        case VT_UINT:
        case VT_UI4:    
            if(pIn->vt != VT_R4)
                dwType = VT_I4;
            dwDataSize = 4;
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8: 
        case VT_CY: 
        case VT_DATE: 
            if(pIn->vt == VT_UI8)
                dwType = VT_I8;
            dwDataSize = 8;
            break;

        case VT_LPSTR:
            dwDataSize = lstrlenA((char *)pData)+1;
            bSizeNeeded = TRUE;
            break;

        case VT_LPWSTR:
            dwDataSize = 2*(lstrlenW((WCHAR *)pData)+1);
            bSizeNeeded = TRUE;
            break;

        case VT_BSTR:
            if(sizeof(OLECHAR) == 2)         
                dwDataSize = 2*(lstrlenW((WCHAR *)pData)+1);
            else
                dwDataSize = lstrlenA((char *)pData)+1;
            bSizeNeeded = TRUE;
            break;

        default:
            return FALSE;
        }

    // Set the desired values

    if(pType)
        *pType = dwType;
    if(pDataSize)
        *pDataSize = dwDataSize;
    if(pSizeNeeded)
        *pSizeNeeded = bSizeNeeded;
    return TRUE;
}


//***************************************************************************
//
//  CImpComp::CImpComp
//
//  Constructor.  Doesnt do much except call base class constructor.
//
//***************************************************************************

CImpComp::CImpComp(LPUNKNOWN pUnkOuter) : CImpDyn(pUnkOuter)
    {
    return;
    }

//***************************************************************************
//
//  CImpComp::ConvertGetData
//
//  Converts the data from the property set into the format desired by
//    the caller.
//
//***************************************************************************


void CImpComp::ConvertGetData(MODYNPROP *pMo,char * pData,DWORD dwType)
{
    HRESULT sc;
    OLECHAR * poTemp = NULL;
    GUID * piid;
    int iCat;
    DWORD dwLen = dwSkipSize(pData,dwType,iCat);

    // TODO, remove this temporary stuff!!!

    DWORD dwSave = pMo->dwType;
    
    if(pMo->dwType == M_TYPE_LPSTR)
        pMo->dwType = VT_LPSTR;
    else if(pMo->dwType == M_TYPE_DWORD)
        pMo->dwType = VT_UINT;
    else if(pMo->dwType == M_TYPE_INT64)
        pMo->dwType = VT_I8;
    else {
        pMo->dwResult = M_INVALID_TYPE;
        return;
    }

    // bail out if bad data
    if(iCat == UNKNOWN || pData == NULL) {
        pMo->dwResult = ERROR_UNKNOWN;
        return;
        }

    // convert the data into standard form

    VARIANTARG vTemp,* pvConvert;
    pvConvert = (VARIANTARG *)CoTaskMemAlloc(sizeof(VARIANTARG));
    if(pvConvert == NULL) {
        pMo->dwResult = WBEM_E_OUT_OF_MEMORY;
        return;
        }
    VariantInit(&vTemp);
    VariantInit(pvConvert);
    vTemp.cyVal.int64 = 0;    
    pvConvert->cyVal.int64 = 0;

    switch(iCat) {
        case NORMAL:
            memcpy((void *)&vTemp.iVal,pData,dwLen);            
            vTemp.vt = (VARTYPE)dwType;
            break;
       
        case STRING:
            vTemp.bstrVal = (BSTR)(pData + sizeof(DWORD));
            vTemp.vt = VT_LPSTR;
            break;

        case WSTRING:
            vTemp.bstrVal = (BSTR)(pData + sizeof(DWORD));
            vTemp.vt = VT_LPWSTR;
            break;

        case DBLOB:
            vTemp.bstrVal = (BSTR)pData;  // TODO, check on this!
            vTemp.vt = VT_BLOB;
            break;

        case DCLSID:
            piid = (GUID * )pData;
            sc = StringFromIID(*piid,&poTemp); //todo, error checking!
            vTemp.bstrVal = (BSTR)poTemp;
            if(sizeof(OLECHAR) == 1)
                vTemp.vt = VT_LPSTR;
            else
                vTemp.vt = VT_LPWSTR;
            break;
        }
    
    sc = OMSVariantChangeType(pvConvert,&vTemp,0,(VARTYPE)pMo->dwType);
    
    if(poTemp)
        CoTaskMemFree(poTemp);

    // note, that the variant memory is not freeded here since it is
    // actually "owned" by the CProp object which will free it.

    if(sc != S_OK) {
        pMo->dwResult = sc;
        return;
        }

    //todo, in the future, the size should just be s
    // sizeof VARIANTARG! AND WE SHOULD RETURN THE VARIANT
    // POINTER AND NOT THE DATA!!!!!

    int iSize = sizeof(VARIANTARG);
    if(pMo->dwType == VT_LPSTR)
        iSize = lstrlen((LPTSTR)pvConvert->pbstrVal) + 1;
    if(pMo->dwType == VT_LPWSTR)
        iSize = 2*wcslen((WCHAR *)pvConvert->pbstrVal) + 2;
    if(pMo->dwType == VT_BSTR)
        iSize = 2*wcslen((WCHAR *)pvConvert->pbstrVal) + 6;
    
    pMo->pPropertyValue = CoTaskMemAlloc(iSize);
    
    // check for errors

    if(pMo->pPropertyValue == NULL){
        pMo->dwResult = WBEM_E_OUT_OF_MEMORY;
        }
    else {
        if(pMo->dwType != VT_LPSTR)
            memcpy(pMo->pPropertyValue,(void *)&pvConvert->iVal,iSize);
        else
            memcpy(pMo->pPropertyValue,(void *)pvConvert->pbstrVal,iSize);
        pMo->dwResult = ERROR_SUCCESS;
        }
    pMo->dwType = dwSave ;
    
}

//***************************************************************************
//
//  CImpComp::DoSetData
//
//  Conversts the property data into propset format and writes it out.
//
//***************************************************************************

void CImpComp::DoSetData(MODYNPROP *pMo,int iIndex,CProp * pProp,
                    CPropSet * pSet,GUID fmtid,int iPid,LPSTREAM pIStream)
{
    BOOL bExisting = TRUE;
    CBuff OutBuff;
    DWORD dwType;
   
    // If the property doesnt exist, I.e, its new, then create it

    if(pProp == NULL) {
        bExisting = FALSE;
        pProp = new CProp;
        if(pProp == NULL) {
            pMo->dwResult = WBEM_E_OUT_OF_MEMORY;
            return;
            }
        pSet->AddProperty(fmtid,pProp);
        }
        
    // TODO REMOVE, TEMP CODE, create variant
    VARIANTARG vIn;
    VariantInit(&vIn);
    vIn.cyVal.int64 = 0;
    if(pMo->dwType == M_TYPE_DWORD){
        vIn.vt = VT_I4;
        vIn.lVal = *(DWORD *)pMo->pPropertyValue;
        }
    else if(pMo->dwType == M_TYPE_LPSTR){
        vIn.vt = VT_LPSTR;
        vIn.bstrVal = (BSTR)pMo->pPropertyValue;
        }
    else {
        pMo->dwResult = M_TYPE_NOT_SUPPORTED;
        return;
        }
    // TODO REMOVE, TEMP CODE, 
    
    if(iIndex >= 0) {
        // Get the data for an array
        if(!bCreateWriteArray(&vIn,&OutBuff,pMo,iIndex,dwType,
                bExisting,pProp)) {
            return;
            }
        }
    else {
        if(!bGetVariantStats(&vIn, &dwType, NULL, NULL)) {
            pMo->dwResult = ERROR_UNKNOWN;  // bad input data
            return;
            }
        AddVariantData(&vIn,&OutBuff);
        /* temp stuff to generate a sample vector 
        dwType = VT_VARIANT | VT_VECTOR;
        DWORD dwCnt = 3;
        OutBuff.Add((void *)&dwCnt, 4);
        DWORD dwT = VT_I4;
        OutBuff.Add((void *)&dwT, 4);
        DWORD dwData = 0x1234;
        OutBuff.Add((void *)&dwData, 4);

        dwT = VT_I2;
        dwData = 1;
        OutBuff.Add((void *)&dwT, 4);
        OutBuff.Add((void *)&dwData, 2);

        dwData = 2;
        OutBuff.Add((void *)&dwT, 4);
        OutBuff.Add((void *)&dwData, 2);
             end of temp stuff       */
        }
    if(!OutBuff.bOK()) 
        pMo->dwResult = WBEM_E_OUT_OF_MEMORY;  // bad input data
    else {
        pProp->Set(iPid, OutBuff.Get(),dwType,OutBuff.GetSize());
        pSet->WriteToStream(pIStream);
        }
//xxx     pIStream->Commit(STGC_OVERWRITE);
    return;
}

//***************************************************************************
//
//  CImpComp::dwSkip
//
//  Returns the size of a data element.  Also sets the iCat reference to 
//  indicate the category of the data type.
//
//***************************************************************************

DWORD CImpComp::dwSkipSize(char *pData,DWORD dwType, int & iCat)
{
    DWORD cbItem, cbVariant = 0;
    DWORD * dwp;
    iCat = NORMAL;
    dwType &= ~VT_VECTOR;
    if(dwType == VT_VARIANT) {
        dwp =  (DWORD *)pData;
        dwType = *dwp;
        pData += sizeof(DWORD);
        cbVariant = sizeof(DWORD);
        }
    switch (dwType)
        {
        case VT_EMPTY:          // nothing
            cbItem = 0;
            break;

        case VT_I2:             // 2 byte signed int
        case VT_BOOL:           // True=-1, False=0
            cbItem = 2;
            break;

        case VT_I4:             // 4 byte signed int
        case VT_R4:             // 4 byte real
            cbItem = 4;
            break;

        case VT_R8:             // 8 byte real
        case VT_CY:             // currency
        case VT_DATE:           // date
        case VT_I8:             // signed 64-bit int
        case VT_FILETIME:       // FILETIME
            cbItem = 8;
            break;

        case VT_LPSTR:          // null terminated string
        case VT_BSTR:           // binary string
        case VT_BLOB:           // Length prefixed bytes
        case VT_BLOB_OBJECT:    // Blob contains an object
        case VT_BLOB_PROPSET:   // Blob contains a propset

            // Read the DWORD that gives us the size, making
            // sure we increment cbValue.
            dwp = (DWORD *)pData;
            cbItem = sizeof(DWORD)+ *dwp;
            if(dwType != VT_BLOB && dwType != VT_BLOB_OBJECT &&
                dwType != VT_BLOB_PROPSET)
                    iCat = STRING;
                else
                    iCat = DBLOB;
            for(;cbItem % 4; cbItem++); // round up to 4 byte boundry
            break;

        case VT_LPWSTR:         // UNICODE string
            dwp = (DWORD *)pData;
            cbItem = sizeof(DWORD)+ (*dwp) * sizeof(WCHAR);
            iCat = WSTRING;
            for(;cbItem % 4; cbItem++); // round up to 4 byte boundry
            break;

        case VT_CLSID:          // A Class ID
            cbItem = sizeof(CLSID);
            iCat = DCLSID;
            break;

        default:
            iCat = UNKNOWN;
            cbItem = 0;
        }

    return cbItem + cbVariant;
}

//***************************************************************************
//
//  CImpComp::EndBatch
//
//  Called at the end of a batch of Refrest/Update Property calls.  Free up 
//  any cached handles and then delete the handle cache.
//
//***************************************************************************

void CImpComp::EndBatch(MODYNPROP * pMo,CObject *pObj,DWORD dwListSize,BOOL bGet)
{
    if(pObj != NULL) {
        Free(0,(CHandleCache *)pObj);
        delete pObj;
        }
}
//***************************************************************************
//
//  CImpComp::ExtractData
//
//  Gets the property objects data and returns a pointer to it.  This is
//  complicated since the data may be a vector (array) or the data might
//  be a variant, or even a vectory of variants.
//
//  Returns a pointer to the data and also sets the dwType reference to 
//  indicate the type.  Note that the type refernce indicates the acutal
//  data and does not include the vector bit or the fact that the data
//  may be a variant.
//
//***************************************************************************

void * CImpComp::ExtractData( CProp * pProp,DWORD & dwType,int iIndex, BOOL bRaw)
{
    // Get the type and data

    char * pRet;
    int iIgnore;
    pRet = (char *)pProp->Get();
    dwType = pProp->GetType();
    
    // if the type is a vector, then step into the data.  Ie if there are
    // 10 elements and we want the 5th, step over the first four

    if(dwType & VT_VECTOR) {
        DWORD dwCnt;
        DWORD * dwpNumVec = (DWORD *)pRet; // first dword is num elements
        pRet += sizeof(DWORD);
        if(iIndex == -1 || (unsigned)iIndex >= *dwpNumVec) 
            return NULL;
        for(dwCnt = 0; dwCnt < (unsigned)iIndex; dwCnt++) 
            pRet += dwSkipSize(pRet,dwType, iIgnore); 
        }

    dwType &= ~VT_VECTOR;

    // If the data type is VARIANT, then get the actual type out of
    // the variant structure and increment the pointer past it.

    if(dwType == VT_VARIANT && !bRaw) {
        DWORD *dwp = (DWORD *)pRet;
        dwType = *dwp;
        pRet += sizeof(DWORD);
        }
 
    return pRet;
}

//***************************************************************************
//
//  CImpComp::Free
//
//  Frees up cached registry handles starting with position
//  iStart till the end.  After freeing handles, the cache object 
//  member function is used to delete the cache entries.
//
//***************************************************************************

void CImpComp::Free(int iStart, CHandleCache * pCache)
{
    int iCurr,iLast;
    iLast = pCache->lGetNumEntries()-1;
    for(iCurr = iLast; iCurr >= iStart; iCurr--) { 
        LPSTORAGE pIStorage = (LPSTORAGE)pCache->hGetHandle(iCurr);
//        if(iCurr == 0)
//            pIStorage->Commit(STGC_OVERWRITE);
        if(pIStorage != NULL) 
            pIStorage->Release();
        }
    pCache->Delete(iStart); // get cache to delete the entries
}



//***************************************************************************
//
//  CImpComp::GetData
//
//  Gets a pointer to a property object and then calls the conversion
//  routines to convert the properties data.  Note that some properties
//  are stream or storage names and so this routine may be called 
//  recursively to get the acutual data.
//
//***************************************************************************

void CImpComp::GetData(MODYNPROP * pMo, CProvObj & ProvObj, int iToken, 
                LPSTORAGE pIStore, LPSTREAM pIStream, BOOL bGet, BOOL bNewStream)
{
    SCODE hr;
    COleString sTemp;
    DWORD dwType;
    void * pData;
   
    // create a property set object

    CPropSet Set;
    GUID fmtid;
    if(!bNewStream) {
        BOOL bRet = Set.ReadFromStream(pIStream);
        if(bRet == 0) {
            pMo->dwResult = ERROR_UNKNOWN;  //bad stream, probably bad mapping
            return;
            }
        }

    // Get the property. 

    sTemp = ProvObj.sGetToken(iToken++);
    hr = IIDFromString(sTemp,&fmtid);

    if(hr != S_OK) {
        pMo->dwResult = ERROR_UNKNOWN;
        return;
        }
    int iPid = ProvObj.iGetIntExp(iToken,0,pMo->dwOptArrayIndex);
    if(iPid == -1) {
        pMo->dwResult = ERROR_UNKNOWN;  // bad mapping string!
        return;
        }

    CProp * pProp = Set.GetProperty(fmtid,iPid);

    int iIndex = ProvObj.iGetIntExp(iToken,1,pMo->dwOptArrayIndex);

    if(bGet) {
        // Get the data, it might be complicated if the property is an array
        // etc.
       
       if(pProp == NULL) {
            pMo->dwResult = ERROR_UNKNOWN;  // bad mapping string!
            return;
            }
    
        pData = ExtractData(pProp, dwType,iIndex,FALSE);
        if(pData == NULL) 
            pMo->dwResult = ERROR_UNKNOWN;  // bad mapping string!
        else
            ConvertGetData(pMo, (char *)pData, dwType); 
        }
    else
        DoSetData(pMo, iIndex, pProp, &Set,fmtid, iPid, pIStream);
    return;
}

//***************************************************************************
//
//  CImpComp::GetProp
//
//  Gets the value of a single property from an Ole Compound file
//
//***************************************************************************

void CImpComp::GetProp(MODYNPROP * pMo, CProvObj & ProvObj,CObject * pPackage)
{
    int iCnt;
    int iNumSkip;   // number of handles already provided by cache.

    SCODE hr;
    int iLast;
    CHandleCache * pCache = (CHandleCache *)pPackage; 
    CString sRoot,sRet;
    COleString soTemp;
    LPSTORAGE pCurr,pNew;
    LPSTREAM pIStream;

    // Do a second parse on the provider string.  The initial parse
    // is done by the calling routine and it's first token is 
    // the path.  The path token is then parsed 
    // into StorePath and it will have a token for each part of the
    // storage path.  

    CProvObj StorePath(ProvObj.sGetFullToken(1),SUB_DELIM);
    pMo->dwResult = StorePath.dwGetStatus();
    if(pMo->dwResult != WBEM_NO_ERROR)
        return;
    
    // Get the root storage (ie, the file) and possibly other substorages
    // if available in the cache.

    pMo->dwResult = GetRoot(&pCurr,StorePath,ProvObj.sGetFullToken(0),
                        pCache,iNumSkip,TRUE);
    if(pMo->dwResult != ERROR_SUCCESS)  
        return;
    pIStream = (LPSTREAM)pCurr; // just in case cache matched all the way. 

    // Go down the storage path till we get to the stream

    iLast = StorePath.iGetNumTokens() -1;
    for(iCnt = iNumSkip; iCnt <= iLast; iCnt ++) {
        soTemp = StorePath.sGetToken(iCnt);
        if(iCnt == iLast) {
            
            // the last entry in the path specifies the stream

            hr = pCurr->OpenStream(soTemp,NULL,
                STGM_READ|STGM_SHARE_EXCLUSIVE,
                0,&pIStream);
            if(hr != S_OK) {
                pMo->dwResult = hr;  // bad storage name!
                return;
                }
            pMo->dwResult = pCache->lAddToList(soTemp,pIStream);
            if(pMo->dwResult != WBEM_NO_ERROR)
                return;
            }
        else {
            hr = pCurr->OpenStorage(soTemp,NULL,
                STGM_READ|STGM_SHARE_EXCLUSIVE,
                NULL,0,&pNew);
            if(hr != S_OK) {
                pMo->dwResult = hr;  // bad storage name!
                return;
                }
            pMo->dwResult = pCache->lAddToList(soTemp,pNew);
            if(pMo->dwResult != WBEM_NO_ERROR)
                return;
            pCurr = pNew;
            }
       }

    // Finish up getting the data.
   
    GetData(pMo,ProvObj,2, pNew, pIStream, TRUE); 

    return;
}

//***************************************************************************
//
//  CImpComp::GetRoot
//
//  Sets the pointer to an open storage.  Typically this is the root storage,
//  but it might be a substorage if the path matches the storages in the
//  cachee.
//  Returns 0 if OK, otherwise return is error code.  Also the storage 
//  pointer is set as well as the number of substorages to skip in
//  cases where the cache is being used.
//
//***************************************************************************
    
int CImpComp::GetRoot(LPSTORAGE * pRet,CProvObj & Path,const TCHAR * pNewFilePath,CHandleCache * pCache,int & iNumSkip,BOOL bGet)
{
    *pRet = NULL;
    int iRet;
    iNumSkip = 0;
    LPSTORAGE pIStorage;
    SCODE hr;
    if(pCache->lGetNumEntries() > 0){    //I.e. in use
        const TCHAR * pOldFilePath = pCache->sGetString(0);
        if(lstrcmpi(pOldFilePath,pNewFilePath)) //todo, handle nulls here!
    
                 // If the file path has changed, free all
                 // the cached handles and get a new root

                 Free(0,pCache);
             else {
                 
                 // FilePath is in common.
                 // determine how much else is in
                 // common, free what isnt in common, 
                 // return handle of best match.

                 iNumSkip = pCache->lGetNumMatch(1,0,Path);
                 Free(1+iNumSkip,pCache);
                 *pRet = (LPSTORAGE)pCache->hGetHandle(1+iNumSkip);
                 return ERROR_SUCCESS;
                 }
        }

    
    // If the is a Set, and the file doesnt exist, create it
    
    COleString sNew;
    sNew = pNewFilePath;
    if(!bGet)
        if(NOERROR != StgIsStorageFile(sNew)) {
            hr = StgCreateDocfile(sNew,
                    STGM_READWRITE|STGM_SHARE_DENY_WRITE|STGM_CREATE,
                    0L, &pIStorage);
            if(hr == S_OK) { 
                iRet = pCache->lAddToList(pNewFilePath,pIStorage);
                if(iRet)
                    return iRet;
                *pRet = pIStorage;
                }
            return hr;    
        }

    // open an existing file

    hr = StgOpenStorage(sNew,NULL,
                      (bGet) ? GET_FLAGS : PUT_FLAGS,
                      NULL,0L, &pIStorage);
    if(hr == S_OK){ 
        hr = pCache->lAddToList(pNewFilePath,pIStorage);
        *pRet = pIStorage;
        }
    return hr;    
}


//***************************************************************************
//
//  CImpComp::SetProp
//
//  Writes the value of a single property into an Ole Compound file
//
//***************************************************************************

void CImpComp::SetProp(MODYNPROP *  pMo, CProvObj & ProvObj,CObject * pPackage)
{
    int iCnt;
    int iNumSkip;   // number of handles already provided by cache.

    SCODE hr;
    int iLast;
    CHandleCache * pCache = (CHandleCache *)pPackage; 
    CString sRoot,sRet;
    COleString soTemp;
    LPSTORAGE pCurr,pNew;
    LPSTREAM pIStream;
    BOOL bStreamCreated = FALSE;

    // Do a second parse on the provider string.  The initial parse
    // is done by the calling routine and it's first token is 
    // the path.  The path token is then parsed 
    // into StorePath and it will have a token for each part of the
    // storage path.  

    CProvObj StorePath(ProvObj.sGetFullToken(1),SUB_DELIM);
    pMo->dwResult = StorePath.dwGetStatus();
    if(pMo->dwResult != WBEM_NO_ERROR)
        return;
    
    // Get the root storage (ie, the file) and possibly other substorages
    // if available in the cache.

    pMo->dwResult = GetRoot(&pCurr,StorePath,ProvObj.sGetFullToken(0),
                        pCache,iNumSkip,FALSE);
    if(pMo->dwResult != ERROR_SUCCESS)  
        return;
    pIStream = (LPSTREAM)pCurr; // just in case cache matched all the way. 

    // Go down the storage path till we get to the stream

    iLast = StorePath.iGetNumTokens() -1;
    for(iCnt = iNumSkip; iCnt <= iLast; iCnt ++) {
        soTemp = StorePath.sGetToken(iCnt);
        if(iCnt == iLast) {
            
            // the last entry in the path specifies the stream

            hr = pCurr->OpenStream(soTemp,NULL,
                    STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                    0,&pIStream);
            if(hr == STG_E_FILENOTFOUND) {
                bStreamCreated = TRUE;
                hr = pCurr->CreateStream(soTemp,
                        STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_FAILIFTHERE,
                        0,0,&pIStream);
                }

            if(hr != S_OK) {
                pMo->dwResult = hr;  // bad storage name!
                return;
                }
            pMo->dwResult = pCache->lAddToList(soTemp,pIStream);
            if(pMo->dwResult != WBEM_NO_ERROR)
                return;
            }
        else {
            hr = pCurr->OpenStorage(soTemp,NULL,
                STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                NULL,0,&pNew);
            if(hr == STG_E_FILENOTFOUND)
                hr = pCurr->CreateStorage(soTemp,
                        STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_FAILIFTHERE,
                        0,0,&pNew);
            if(hr != S_OK) {
                pMo->dwResult = hr;  // bad storage name!
                return;
                }
            pMo->dwResult = pCache->lAddToList(soTemp,pNew);
            if(pMo->dwResult != WBEM_NO_ERROR)
                return;
            pCurr = pNew;
            }
       }

    // Finish up getting the data.
   
    GetData(pMo,ProvObj,2, pNew, pIStream, FALSE, bStreamCreated); 

    return;
}

//***************************************************************************
//
//  CImpComp::StartBatch
//
//  Called at the start of a batch of Refrest/Update Property calls.  Initialize
//  the handle cache.
//
//***************************************************************************

void CImpComp::StartBatch(MODYNPROP * pMo,CObject **pObj,DWORD dwListSize,BOOL bGet)
{
    *pObj = new CHandleCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provreg.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVREG.CPP

Abstract:

	Defines the acutal "Put" and "Get" functions for the
			 registry provider.  The mapping string format is;
	machine|regpath[|datafield]
         
	Examples:

	local|hkey_current_user\dave
	local|hkey_current_user\dave|stringdata
	local|hkey_local_machine\hardware\resourcemap\hardware abstraction layer\
		pc compatible eisa/isa HAL|.raw("internal")(0)(2)("interrupt.vector")
	LMPGM|hkey_local_machine\clone\clone\control|CurrentUser

History:

	a-davj  9-27-95    Created.

--*/

#include "precomp.h"
#include <initguid.h>
#include "perfprov.h"
#include "cvariant.h"
#include "provreg.h"
#include <genutils.h>
#include <cominit.h>
#include <userenv.h>

#define NUM_FOR_LIST 4
#define NUM_FOR_PARTIAL 2 
#define TYPE_OFFSET 0
#define BUS_OFFSET 1
#define PARTIAL_OFFSET 0
#define DATA_OFFSET 1
#define NUM_LIST_ONLY 2

#define MIN_REG_TOKENS 2

#define BOGUS 0

// for certain "resource" registry item it is necessary to specify which bus
// and what part of the data union is to be returned.  These strings allow
// the mapping string to specify both using text

TCHAR * cpIntTypes[] = {
    TEXT("Internal"),TEXT("Isa"),TEXT("Eisa"),TEXT("MicroChannel"),TEXT("TurboChannel"),
    TEXT("PCIBus"),TEXT("VMEBus"),TEXT("NuBus"),TEXT("PCMCIABus"),TEXT("CBus"),
    TEXT("MPIBus"),TEXT("MPSABus"),TEXT("MaximumInterfaceType")};

struct UnionOffset 
{
    TCHAR * tpName;
    int iOffset;
    int iType;
    int iSize;
} Offsets[] = 
    {
        {TEXT("Port.Start"),0,CmResourceTypePort,8},
        {TEXT("Port.PhysicalAddress"),0,CmResourceTypePort,8},
        {TEXT("Port.Physical Address"),0,CmResourceTypePort,8},
        {TEXT("Port.Length"),8,CmResourceTypePort,4},
        {TEXT("Interrupt.Level"),0,CmResourceTypeInterrupt,4},
        {TEXT("Interrupt.Vector"),4,CmResourceTypeInterrupt,4},
        {TEXT("Interrupt.Affinity"),8,CmResourceTypeInterrupt,4},
        {TEXT("Memory.Start"),0,CmResourceTypeMemory,8},
        {TEXT("Memory.PhysicalAddress"),0,CmResourceTypeMemory,8},
        {TEXT("Memory.Physical Address"),0,CmResourceTypeMemory,8},
        {TEXT("Memory.Length"),8,CmResourceTypeMemory,4},
        {TEXT("Dma.Channel"),0,CmResourceTypeDma,4},
        {TEXT("Dma.Port"),4,CmResourceTypeDma,4},
        {TEXT("Dma.Reserved1"),8,CmResourceTypeDma,4},
        {TEXT("DeviceSpecificData.DataSize"),0,CmResourceTypeDeviceSpecific,4},
        {TEXT("DeviceSpecificData.Data Size"),0,CmResourceTypeDeviceSpecific,4},
        {TEXT("DeviceSpecificData.Reserved1"),4,CmResourceTypeDeviceSpecific,4},
        {TEXT("DeviceSpecificData.Reserved2"),8,CmResourceTypeDeviceSpecific,4}
    };

// Define the names of the basic registry handles

struct BaseTypes 
{
    LPTSTR lpName;
    HKEY hKey;
} Bases[] = 
    {
       {TEXT("HKEY_CLASSES_ROOT") , HKEY_CLASSES_ROOT},
       {TEXT("HKEY_CURRENT_USER") , HKEY_CURRENT_USER},
       {TEXT("HKEY_LOCAL_MACHINE") ,  HKEY_LOCAL_MACHINE},
       {TEXT("HKEY_USERS") ,  HKEY_USERS},
       {TEXT("HKEY_PERFORMANCE_DATA") ,  HKEY_PERFORMANCE_DATA},
       {TEXT("HKEY_CURRENT_CONFIG") ,  HKEY_CURRENT_CONFIG},
       {TEXT("HKEY_DYN_DATA") ,  HKEY_DYN_DATA}};

//***************************************************************************
//
//  BOOL CImpReg::bGetOffsetData
//
//  DESCRIPTION:
//
//  Getting data from a resource list requires four offsets while getting
//  it from a single descriptor requires the last two offsets. 
//   
//  PARAMETERS:
//
//  dwReg               Indicates if we are looking for a full or partial
//                      resource descriptor.
//  ProvObj             Object containing the property context string.
//  iIntType            interface type - could be a string such as "eisa"
//  iBus                bus number
//  iPartial            partial descriptor number - each full descriptor 
//                      has several partial desc.
//  iDataOffset         Data Offset - each partial descriptor has data in 
//                      a union and this is the byte offset.  Could be a 
//                      sting such as "Dma.Channel"
//  iDataType           Data type
//  iSourceSize         Size of data
//  dwArray             no longer used, should always be 0
//
//  RETURN VALUE:
//  
//  TRUE if data is found
//
//***************************************************************************

BOOL CImpReg::bGetOffsetData(
                    IN DWORD dwReg,
                    IN CProvObj & ProvObj,
                    OUT IN int & iIntType,
                    OUT IN int & iBus,
                    OUT IN int & iPartial,
                    OUT IN int & iDataOffset,
                    OUT IN int & iDataType,
                    OUT IN int & iSourceSize,
                    DWORD dwArray)
{
    int iNumRequired, iListOffset;
    int iLastToken = ProvObj.iGetNumTokens()-1;

    // determine the number needed for the type of data being requested

    if(dwReg == REG_RESOURCE_LIST)
        iNumRequired = NUM_FOR_LIST;
    else
        iNumRequired = NUM_FOR_PARTIAL;

    if(ProvObj.iGetNumExp(iLastToken) < iNumRequired)
        return FALSE;
    
    // Get the first two descriptors that are only needed in the list case.

    if(dwReg == REG_RESOURCE_LIST) 
    {

        // the first offset can either be a string such as "EISA" or a
        // numeric offset.

        if(ProvObj.IsExpString(iLastToken,TYPE_OFFSET))
            iIntType = iLookUpInt(ProvObj.sGetStringExp(iLastToken,TYPE_OFFSET));
        else
            iIntType = ProvObj.iGetIntExp(iLastToken,TYPE_OFFSET,dwArray);
        iBus = ProvObj.iGetIntExp(iLastToken,BUS_OFFSET,dwArray);
        if(iBus == -1 || iIntType == -1)
            return FALSE;
        iListOffset = NUM_LIST_ONLY;
    }
    else
        iListOffset = 0;

    // Get the last two offsets which are for identenfying which partial
    // descriptor and the last is for specifying the offset inside the 
    // union.

    iPartial = ProvObj.iGetIntExp(iLastToken,PARTIAL_OFFSET+iListOffset,dwArray);
    
    // The data offset can be a string such as "Dma.Port".
    iDataType = -1; // not necessarily an error, see the function
                    // GetResourceDescriptorData for more info.
    iSourceSize = 0; 
    if(ProvObj.IsExpString(iLastToken,DATA_OFFSET+iListOffset))
        iDataOffset = iLookUpOffset(ProvObj.sGetStringExp(iLastToken,
                            DATA_OFFSET+iListOffset),
                            iDataType,iSourceSize);
    else
        iDataOffset = ProvObj.iGetIntExp(iLastToken,DATA_OFFSET+iListOffset,dwArray);

    if(iPartial == -1 || iDataOffset == -1) 
        return FALSE;
    return TRUE;
}

//***************************************************************************
//
//  CImpReg::CImpReg
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//***************************************************************************

CImpReg::CImpReg()
{                       
    wcscpy(wcCLSID,L"{FE9AF5C0-D3B6-11CE-A5B6-00AA00680C3F}");

//  To disable dmreg, uncomment hDMRegLib = NULL;
//  To disable dmreg, uncomment return;
    
    hDMRegLib = NULL; //LoadLibrary("DMREG.DLL");

    m_hRoot = NULL;
    m_hToken = NULL;
    m_bLoadedProfile = false;
    if(IsNT())
    {
        SCODE sc = WbemCoImpersonateClient();
        if(sc == S_OK)
        {
            sc = LoadProfile(m_hToken, m_hRoot);
            if(sc == S_OK)
                m_bLoadedProfile = true;

            WbemCoRevertToSelf();
        }
    }
    return;
}

//***************************************************************************
//
//  CImpReg::~CImpReg
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CImpReg::~CImpReg()
{
    if(hDMRegLib)
        FreeLibrary(hDMRegLib);
    if(m_bLoadedProfile)
        UnloadUserProfile(m_hToken, m_hRoot);
    if(m_hToken)
        CloseHandle(m_hToken);
}

//***************************************************************************
//
//  CImpReg::ConvertGetDataFromDesc
//
//  DESCRIPTION:
//
//  Extracts the data when it is in either the REG_RESOURCE_LIST or
//  REG_FULL_RESOURCE_DESCRIPTOR format.  The REG_RESOURCE_LIST has a list
//  of "full resource" blocks and so in that case it is necessary to first
//  determine which block to extract from and after that the code is common.
//
//  PARAMETERS:
//
//  cVar                reference to CVariant that get set with the result
//  pData               raw data
//  dwRegType           Indicates if we are looking for a full or partial
//                      resource descriptor.
//  dwBufferSize        not used
//  ProvObj             Object containing the property context string.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_INVALID_PARAMETER  couldnt find the data.  Probably a bad context
//                           string
//  otherwise, error converting the data in SetData()
//***************************************************************************

SCODE CImpReg::ConvertGetDataFromDesc(
                        OUT CVariant  & cVar,
                        IN void * pData,
                        IN DWORD dwRegType,
                        IN DWORD dwBufferSize,
                        IN CProvObj & ProvObj)
{
    int iIntType, iBus, iPartial, iDataOffset,iDataType,iSourceSize;
    ULONG uCnt;

    PCM_FULL_RESOURCE_DESCRIPTOR pFull;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartial;

    // Get the various operator values.  A typical provider string would
    // be "..|.raw("internal")(0)(2)("interrupt.vector")

    if(!bGetOffsetData(dwRegType,ProvObj,iIntType,iBus,iPartial,
            iDataOffset,iDataType, iSourceSize, BOGUS)) 
        return WBEM_E_INVALID_PARAMETER;

    // if list, get the right full resource block.

    if(dwRegType == REG_RESOURCE_LIST) 
    {
        PCM_RESOURCE_LIST pList = (PCM_RESOURCE_LIST)pData;
        pFull = &pList->List[0];
        for(uCnt=0; uCnt < pList->Count; uCnt++)
            if(pFull->InterfaceType == iIntType && pFull->BusNumber == (unsigned)iBus)
                break;  // found it!
            else 
                pFull = GetNextFull(pFull);
                
        if(uCnt == pList->Count) 
            return WBEM_E_INVALID_PARAMETER; // specified invalid type or bus number
    }
    else
        pFull = (PCM_FULL_RESOURCE_DESCRIPTOR)pData;
    
    // Get the partial resource descriptor.  Each full 
    // descriptor is a list of partial descriptors. If the
    // last expression was of the form ("interrupt.vector"),
    // then all the partial blocks that arn't interrupt data
    // will be ignored.  If the last expression just has a
    // number, then the type of block is ignored.
        
    unsigned uSoFar = 0;
    pPartial = pFull->PartialResourceList.PartialDescriptors;
    unsigned uLimit = pFull->PartialResourceList.Count;
    for(uCnt = 0; uCnt < (unsigned)uLimit; uCnt++) 
    {
        if(iDataType == -1 || iDataType == pPartial->Type)
        { 
            if(uSoFar == (unsigned)iPartial)
                break;  // got it!
            uSoFar++;
        }
        pPartial = GetNextPartial(pPartial); 
    }
    if(uCnt == uLimit)
        return WBEM_E_INVALID_PARAMETER; // specified invalid block

    // Copy the data into a variant

    char * cpTemp = (char *)&pPartial->u.Dma.Channel + iDataOffset;
    if(iSourceSize == 1)
        return cVar.SetData(cpTemp,VT_UI1);
    else if(iSourceSize == 2)
        return cVar.SetData(cpTemp,VT_I2);
    else if(iSourceSize == 4)
        return cVar.SetData(cpTemp,VT_I4);
    else
        return cVar.SetData(cpTemp,VT_I8);  //todo fix this VT_I8 dont work!!!
}

//***************************************************************************
//
//  SCODE CImpReg::ConvertGetDataFromSimple
//
//  DESCRIPTION:
//
//  Converts that data returned by the registry into the closest VARIANT 
//  type.  
//
//  PARAMETERS:
//
//  cVar                Reference to CVariant where result is to be put
//  pData               pointer to data
//  dwRegType           registry type, ex, REG_MUTISZ
//  dwBufferSize        size of data
//  pClassInt           Pointer to class object
//  PropName            Property name.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else could fail if the "Get" on the property fails,
//  or if the data conversion fails in SetData.
//***************************************************************************

SCODE CImpReg::ConvertGetDataFromSimple(
                        OUT CVariant & cVar,
                        IN void * pData,
                        IN DWORD dwRegType,
                        IN DWORD dwBufferSize,
                        IN IWbemClassObject FAR * pClassInt,
                        IN BSTR PropName)
{           
    TCHAR tTemp[1];
    TCHAR * pTemp;
    SCODE sc = S_OK;
    int nSize;
    char * cpTo, * cpFrom;
    long vtProp;

    // Note that the current winnt.h file defines the constants 
    // REG_DWORD_LITTLE_ENDIAN and REG_DWORD as being the same.  
    // The compiler considers this an error in a switch statement and so
    // there is this "if" to ensure that they are handled the same even
    // if someday the constants become different

    if(dwRegType == REG_DWORD_LITTLE_ENDIAN)
        dwRegType = REG_DWORD;

    switch(dwRegType) 
    {
        case REG_SZ:
            sc = cVar.SetData(pData, VT_BSTR,dwBufferSize);
            break;    
       
        case REG_EXPAND_SZ:
            nSize = ExpandEnvironmentStrings((TCHAR *)pData,tTemp,1) + 1;
            pTemp = new TCHAR[nSize+1];
            if(pTemp == NULL) 
                return WBEM_E_OUT_OF_MEMORY;
            ExpandEnvironmentStrings((TCHAR *)pData,pTemp,nSize+1);
            sc = cVar.SetData(pTemp, VT_BSTR, nSize+1);
            delete pTemp;
            break;

        case REG_BINARY:
            if(pClassInt)
            {
                sc = pClassInt->Get(PropName,0,NULL,&vtProp,NULL);
                if(sc != S_OK)
                    return sc;
             }
            else 
                vtProp = VT_UI1 | VT_ARRAY;
            if((vtProp & VT_ARRAY) == 0)
                sc = WBEM_E_FAILED;        // Incompatible types
            else
                sc = cVar.SetData(pData,vtProp, dwBufferSize);
            break;

        case REG_DWORD:
            sc = cVar.SetData(pData,VT_I4);
            break;

        case REG_DWORD_BIG_ENDIAN:
            sc = cVar.SetData(pData,VT_I4);
            cpTo = (char *)cVar.GetDataPtr();
            cpFrom = (char *)pData;
            cpTo[0] = cpFrom[3];
            cpTo[1] = cpFrom[2];
            cpTo[2] = cpFrom[1];
            cpTo[3] = cpFrom[0];
            break;

        case REG_MULTI_SZ: 
            sc = cVar.SetData(pData, VT_BSTR | VT_ARRAY, dwBufferSize);
            break;

        default:
            sc = WBEM_E_TYPE_MISMATCH;
    }        
    return sc;
}
  
//***************************************************************************
//
//  SCODE CImpReg::ConvertSetData
//
//  DESCRIPTION:
//
//  Takes WBEM type data and converts it into the proper
//  form for storage in the registry.  There are two distinct
//  case:  Binary array data and normal data.
//
//  PARAMETERS:
//
//  cVar                Contains the source
//  **ppData            pointer which will be set to point to some allocate
//                      data.  Note that the data allocated should be freed 
//                      using CoTaskMemFree
//  pdwRegType          desired registry type
//  pdwBufferSize       size of allocated data
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_TYPE_MISMATCH invalied type
//  else error is set by GetData()
//  
//***************************************************************************

SCODE CImpReg::ConvertSetData(
                         IN CVariant & cVar,
                         OUT void **ppData,
                         IN DWORD * pdwRegType,
                         OUT DWORD * pdwBufferSize)
{
    void * pRet = NULL;
    SCODE sc;

    switch (cVar.GetType() & ~VT_ARRAY) 
    {
        case VT_I1:
        case VT_UI1:
        case VT_I2: 
        case VT_UI2:
        case VT_I4: 
        case VT_UI4:  
        case VT_BOOL:
        case VT_INT:
        case VT_UINT:

            // convert data into DWORD format which is equivalent to 
            // the REG_DWORD.

            *pdwRegType = (cVar.IsArray()) ? REG_BINARY : REG_DWORD;
            sc = cVar.GetData(ppData,*pdwRegType,pdwBufferSize);
            break;      
                       
        case VT_I8:
        case VT_UI8:
        case VT_LPSTR:
        case VT_LPWSTR:
        case VT_R4: 
        case VT_R8: 
        case VT_CY: 
        case VT_DATE: 
        case VT_BSTR:
            *pdwRegType = (cVar.IsArray()) ? REG_MULTI_SZ : REG_SZ;
            sc = cVar.GetData(ppData,*pdwRegType,pdwBufferSize);
            break;
        
        default:
            
            sc = WBEM_E_TYPE_MISMATCH;
    }
    return sc;
}

//***************************************************************************
//
//  void CImpReg::EndBatch
//
//  DESCRIPTION:
//
//  Called at the end of a batch of Refrest/Update Property calls.  Free up 
//  any cached handles and then delete the handle cache.
//
//  PARAMETERS:
//
//  lFlags              flags, not used
//  pClassInt           class object, not used
//  *pObj               pointer to our cache, free it
//  bGet                indicates if a Refresh or Put was being done
//
//***************************************************************************

void CImpReg::EndBatch(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    CObject *pObj,
                    BOOL bGet)
{
    if(pObj != NULL) 
    {
        Free(0,(CHandleCache *)pObj);
        delete pObj;
    }
}

//***************************************************************************
//
//  void CImpReg::Free
//
//  DESCRIPTION:
//
//  Frees up cached registry handles starting with position
//  iStart till the end.  After freeing handles, the cache object 
//  member function is used to delete the cache entries.
//
//  PARAMETERS:
//
//  iStart              Where to start freeing.  0 indicates that whole
//                      cache should be emptied
//  pCache              Cache to be freed
//
//***************************************************************************

void CImpReg::Free(
                    IN int iStart,
                    IN CHandleCache * pCache)
{
    HKEY hClose;
    int iCurr; long lRet;
    for(iCurr = pCache->lGetNumEntries()-1; iCurr >= iStart; iCurr--) 
    { 
        hClose = (HKEY)pCache->hGetHandle(iCurr); 
        if(hClose != NULL) 
            if(hDMRegLib && !pCache->IsRemote())
                lRet = pClose(hClose);
            else
                lRet = RegCloseKey(hClose);
    }
    pCache->Delete(iStart); // get cache to delete the entries
}

//***************************************************************************
//
//  PCM_FULL_RESOURCE_DESCRIPTOR CImpReg::GetNextFull
//
//  DESCRIPTION:
//
//  Returns a pointer to the next full resource descritor block.  Used
//  when stepping through resource data.
//
//  PARAMETERS:
//
//  pCurr               points to current location.
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

PCM_FULL_RESOURCE_DESCRIPTOR CImpReg::GetNextFull(
                    IN PCM_FULL_RESOURCE_DESCRIPTOR pCurr)
{
    unsigned uCount;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartial;

    // Get a pointer to the first partial descriptor and then step
    // through each of the partial descriptor blocks.

    pPartial = &pCurr->PartialResourceList.PartialDescriptors[0];

    for(uCount = 0; uCount < pCurr->PartialResourceList.Count; uCount++)
        pPartial = GetNextPartial(pPartial);
    return (PCM_FULL_RESOURCE_DESCRIPTOR)pPartial;
}

//***************************************************************************
//
//  PCM_PARTIAL_RESOURCE_DESCRIPTOR CImpReg::GetNextPartial
//
//  DESCRIPTION:
//
//  Returns a pointer to the next partial resource descritor block.  Used
//  when stepping through resource data.
//
//  PARAMETERS:
//
//  pCurr               Current location.
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

PCM_PARTIAL_RESOURCE_DESCRIPTOR CImpReg::GetNextPartial(
                    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR pCurr)
{
    char * cpTemp = (char *)pCurr;
    cpTemp += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    if(pCurr->Type == CmResourceTypeDeviceSpecific)
        cpTemp += pCurr->u.DeviceSpecificData.DataSize;
    return (PCM_PARTIAL_RESOURCE_DESCRIPTOR)cpTemp;
}

//***************************************************************************
//
//  int CImpReg::GetRoot
//
//  DESCRIPTION:
//
//  Gets the starting registry key.  The key can be on either the local 
//  machine or a remote one.  If there are handles in the cache, then
//  the starting key can be retrieved from it in so far as the paths match.
//
//  PARAMETERS:
//
//  pKey                Set to point to the root key
//  Path                registry path
//  pNewMachine         Machine name
//  pCache              Handle cache object
//  iNumSkip            Set to the number of tokens that matched 
//
//  RETURN VALUE:
//
//  
//***************************************************************************

int CImpReg::GetRoot(
                    OUT HKEY * pKey,
                    IN CProvObj & Path,
                    IN const TCHAR * pNewMachine,
                    OUT IN CHandleCache * pCache,
                    OUT int & iNumSkip)
{
    int iCnt;
    *pKey = NULL;
    iNumSkip = 0;
    int iRet;
    HKEY hRoot = NULL;
    const TCHAR * pNewRoot = Path.sGetFullToken(0);
    if(pNewRoot == NULL || pNewMachine == NULL)
        return ERROR_UNKNOWN;   // bad mapping string

    // If there are handles in the cache, then they may be used if and
    // only if the machines names and root keys match.

    if(pCache->lGetNumEntries() > 0)
    {    
        const TCHAR * pOldMachine = pCache->sGetString(0);
        const TCHAR * pOldRoot = pCache->sGetString(1);
        if(pOldMachine == NULL || pOldRoot == NULL)
            return ERROR_UNKNOWN;
        if(lstrcmpi(pOldMachine,pNewMachine) ||
              lstrcmpi(pOldRoot,pNewRoot))
    
                 // Either machine or root key has changed, in either 
                 // case, free all the cached handles and get a new root.

                 Free(0,pCache);
             else 
             {
                 
                 // Machine and root are in common.  Determine how much 
                 // else is in common, free what isnt in common, and return
                 // the subkey share a common path.

                 iNumSkip = pCache->lGetNumMatch(2,1,Path);
                 Free(2+iNumSkip,pCache);
                 *pKey = (HKEY)pCache->hGetHandle(1+iNumSkip);
                 return ERROR_SUCCESS;
             }
    }

    // Got to get the root key.  First, use the second token to determine
    // which predefined key to use. That would be something like;
    // HKEY_CURRENT_USER.

    int iSize= sizeof(Bases) / sizeof(struct BaseTypes);
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(!lstrcmpi(pNewRoot,Bases[iCnt].lpName)) 
        {
            hRoot = Bases[iCnt].hKey;
            break;
        }
    if(hRoot == HKEY_CURRENT_USER && m_bLoadedProfile)
        hRoot = m_hRoot;

    if(hRoot == NULL)
        return ERROR_UNKNOWN;

    // Now use the first key to determine if it is the local machine or
    // another.

    if(lstrcmpi(pNewMachine,TEXT("LOCAL"))) 
    { 
        
        // Connect to a remote machine.

        int iRet;
        pCache->SetRemote(TRUE);
        // Note that RegConnectRegistry requires a NON constant name 
        // pointer (ARG!) and thus a temp string must be created!!

        TString sTemp;
    
        sTemp = pNewMachine;
        iRet = RegConnectRegistry(sTemp, hRoot,pKey);

        sTemp.Empty();
        if(iRet == 0)
            iRet = pCache->lAddToList(pNewMachine,NULL);   // dont need to free this
        if(iRet == 0)
            iRet = pCache->lAddToList(pNewRoot,*pKey);        // do free this.
        return iRet;
    }
    else 
    {

        // Local registry.  Save tokens and handles.  By adding NULL to the
        // cache, the handle will not be freed.  

        pCache->SetRemote(FALSE);
        iRet = pCache->lAddToList(pNewMachine,NULL);
        if(iRet == 0)
            iRet = pCache->lAddToList(pNewRoot,NULL); // standard handles dont need to be freed
        *pKey = hRoot;
    }
    return iRet;
}

//***************************************************************************
//
//  int CImpReg::iLookUpInt
//
//  DESCRIPTION:
//
//  Searches (case insensitive) the list of interface types and
//  returns the index of the match or -1 if no match.
//
//  PARAMETERS:
//
//  tpTest              name to search for
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

int CImpReg::iLookUpInt(
                    const TCHAR * tpTest)
{
    int iCnt,iSize;
    iSize = sizeof(cpIntTypes) / sizeof(TCHAR *);
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(tpTest != NULL && !lstrcmpi(tpTest,cpIntTypes[iCnt]))
            return iCnt;
    return -1; 
}

//***************************************************************************
//
//  int CImpReg::iLookUpOffset
//
//  DESCRIPTION:
//
//  Searches (case insensitive) the list data types held in
//  resource descripters.
//
//  PARAMETERS:
//
//  tpTest              String to look for
//  iType               Set to the type
//  iTypeSize           Set to the type's size
//
//  RETURN VALUE:
//
//  Returns index if match is found (-1 for failure) and also
//  sets the referneces that specifiy which type and the type's
//  size.
//
//  
//***************************************************************************

int CImpReg::iLookUpOffset(
                    IN const TCHAR * tpTest,
                    OUT int & iType,
                    OUT int & iTypeSize)
{
    int iCnt, iSize;
    iSize = sizeof(Offsets) / sizeof(struct UnionOffset);  
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(tpTest != NULL && !lstrcmpi(tpTest,Offsets[iCnt].tpName)) 
        {
            iType = Offsets[iCnt].iType;
            iTypeSize = Offsets[iCnt].iSize; 
            return Offsets[iCnt].iOffset;
        }
    return -1; 
}

//***************************************************************************
//
//  int CImpReg::OpenKeyForWritting
//
//  DESCRIPTION:
//
//  Opens a registry for updates.  Since updates are writes, it is
//  possible that the key may need to be created.  Since DM reg
//  does not support RegCreateKey, then it must be called and the
//  resulting key closed for the new key case.
//
//  PARAMETERS:
//
//  hCurr               Parent key
//  pName               sub key to be opened/created
//  pNew                pointer to opened/created key
//  pCache              handle cache.
//
//  RETURN VALUE:
//
//  0                   if OK,
//  else set by RegOpenKey or RegCreateKey
//
//***************************************************************************

int CImpReg::OpenKeyForWritting(
                    HKEY hCurr,
                    LPTSTR pName,
                    HKEY * pNew,
                    CHandleCache * pCache)
{
    int iRet;
    iRet = RegOpenKeyEx(hCurr,pName,0,KEY_WRITE,pNew);
    if(iRet == 0)   // all done should be normal case.
        return 0;

    iRet = RegOpenKeyEx(hCurr,pName,0,KEY_SET_VALUE,pNew);
    if(iRet == 0)   // all done should be normal case.
        return 0;
    
    // Try creating the key.  If not using DM reg, just use the key from
    // here

    iRet = RegCreateKey(hCurr,pName,pNew);
    if(hDMRegLib!=NULL && !pCache->IsRemote() && iRet == 0)
    {
        // Close the key and reopen

        RegCloseKey(*pNew);
        iRet = pOpen(hCurr,pName,0,0,KEY_QUERY_VALUE,pNew);
    }
    return iRet;
}

//***************************************************************************
//
//  SCODE CImpReg::ReadRegData
//
//  DESCRIPTION:
//
//  Allocates a buffer and reads the registry.  If the buffer is not large
//  enough, then it is reallocated and reread.
//
//  PARAMETERS:
//
//  hKey                Registry Key
//  pName               Value Name
//  dwRegType           Set to the type
//  dwSize              set to the size
//  pData               set to the allocated data.  This must be freed via
//                      CoTaskmemFree()
//  pCache              Handle Cache.
//
//  RETURN VALUE:
//
//  Return: Registry value.  Also sets the size and type of the registry data
//  
//***************************************************************************

SCODE CImpReg::ReadRegData(
                    IN HKEY hKey,
                    IN const TCHAR * pName,
                    OUT DWORD & dwRegType, 
                    OUT DWORD & dwSize,
                    OUT void ** pData,
                    IN CHandleCache * pCache)
{
    void * pRet;
    int iRet;
        
    // Initially the buffer is set to hold INIT_SIZE 
    // bytes.  If that isnt enough, the query will be 
    // repeated a second time

    dwSize = INIT_SIZE;
    pRet = (unsigned char *)CoTaskMemAlloc(dwSize);
    if(pRet == NULL) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if(hDMRegLib && !pCache->IsRemote())
        iRet = pQueryValue(hKey, (TCHAR *) pName, 0l, &dwRegType, (LPBYTE)pRet,&dwSize);
    else
        iRet = RegQueryValueEx(hKey, pName, 0l, &dwRegType, 
                (LPBYTE)pRet,&dwSize);

    // If we failed for lack of space, retry once.

    if(iRet == ERROR_MORE_DATA) 
    { 
        pRet= (char *)CoTaskMemRealloc(pRet, dwSize); 
        if(pRet == NULL) 
        { 
            return WBEM_E_OUT_OF_MEMORY;
        }
        if(hDMRegLib && !pCache->IsRemote())
            iRet = pQueryValue(hKey, (TCHAR *) pName, 0l, &dwRegType, 
                    (LPBYTE)pRet,&dwSize);
        else
            iRet = RegQueryValueEx(hKey, pName, 0l, &dwRegType, 
                (LPBYTE)pRet, &dwSize);
    }
    *pData = pRet;
    return iRet;
}

//***************************************************************************
//
//  SCODE CImpReg::RefreshProperty
//
//  DESCRIPTION:
//
//  Gets the value of a single property from the registry.
//
//  PARAMETERS:
//
//  lFlags              flags.  Not currently used
//  pClassInt           Instance object
//  PropName            Property name
//  ProvObj             Object containing the property context string.
//  pPackage            Caching object
//  pVar                Points to value to set
//  bTesterDetails      Provide extra info for testers
//
//  RETURN VALUE:
//
//  S_OK
//  WBEM_E_INVALID_PARAMETER
//  or others??
//***************************************************************************

SCODE CImpReg::RefreshProperty(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    BSTR PropName,
                    CProvObj & ProvObj,
                    CObject * pPackage,
                    CVariant * pVar, BOOL bTesterDetails)
{
    int iCnt;
    int iNumSkip;   // number of handles already provided by cache.

    CHandleCache * pCache = (CHandleCache *)pPackage; 
    DWORD dwRegType,dwBufferSize;
    void * pData = NULL;
    const TCHAR * pName;
    HKEY hCurr,hNew;  
    SCODE sc;

    // Do a second parse on the provider string.  The initial parse
    // is done by the calling routine and it's first token is 
    // the path.  The path token is then parsed 
    // into RegPath and it will have a token for each part of the
    // registry path.  

    CProvObj RegPath(ProvObj.sGetFullToken(1),SUB_DELIM,true);
    sc = RegPath.dwGetStatus(1);
    if(sc != S_OK)
        return WBEM_E_INVALID_PARAMETER;
    
    // Get a handle to a place in the reg path. Note that it might be just
    // a root key (such as HKEY_LOCAL_MACHINE) or it might be a subkey
    // if the cache contains some open handles that can be used.

    sc = GetRoot(&hCurr,RegPath,ProvObj.sGetFullToken(0),
                        pCache,iNumSkip);
    if(sc != ERROR_SUCCESS)  
        return sc;

    // Go down the registry path till we get to the key

    for(iCnt = 1+iNumSkip; iCnt < RegPath.iGetNumTokens(); iCnt ++) 
    {
        int iRet;
        if(hDMRegLib && !pCache->IsRemote())
            iRet = pOpen(hCurr,RegPath.sGetToken(iCnt),0,0,KEY_QUERY_VALUE,&hNew);
        else
            iRet = RegOpenKeyEx(hCurr,RegPath.sGetToken(iCnt),0,KEY_READ,&hNew);
        if(iRet != ERROR_SUCCESS) 
        {
            sc = iRet;  // bad path!
            return sc;
        }
        hCurr = hNew;
        sc = pCache->lAddToList(RegPath.sGetToken(iCnt),hNew);
        if(sc != ERROR_SUCCESS)
            return sc;
    }

    // If it is a named value, get a pointer to the name
        
    if(ProvObj.iGetNumTokens() > MIN_REG_TOKENS) 
        pName = ProvObj.sGetToken(MIN_REG_TOKENS);
    else
        pName = NULL;

    // Time to get the data. 

    sc  = ReadRegData(hCurr, pName,dwRegType, dwBufferSize, &pData,pCache);
	if(sc == S_OK && dwBufferSize == 0)
		sc = 2;
    if(sc == S_OK) 
    {
        CVariant cVar;
        if(dwRegType == REG_RESOURCE_LIST || dwRegType == REG_FULL_RESOURCE_DESCRIPTOR)
            sc = ConvertGetDataFromDesc(cVar,pData,dwRegType,dwBufferSize,ProvObj);
        else
            sc = ConvertGetDataFromSimple(cVar,pData,dwRegType,dwBufferSize,pClassInt,PropName);
        if(sc == S_OK)
            sc = cVar.DoPut(lFlags,pClassInt,PropName,pVar);
    }
    if(pData != NULL)
        CoTaskMemFree(pData);
    return sc;
}

//***************************************************************************
//
//  SCODE CImpReg::StartBatch
//
//  DESCRIPTION:
//
//  Called at the start of a batch of Refrest/Update Property calls.  Initialize
//  the handle cache.
//
//  PARAMETERS:
//
//  lFlags               flags
//  pClassInt            Points to an instance object
//  pObj                 Misc object pointer
//  bGet                 TRUE if we will be getting data.
//
//  RETURN VALUE:
//
//  S_OK                 all is well
//  WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpReg::StartBatch(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    CObject **pObj,
                    BOOL bGet)
{
    *pObj = new CHandleCache;
    return (*pObj) ? S_OK : WBEM_E_OUT_OF_MEMORY;
}

//***************************************************************************
//
//  SCODE CImpReg::UpdateProperty
//
//  DESCRIPTION:
//
//  Sets the value of a single property into the registry.
//
//  PARAMETERS:
//
//  lFlags              not used
//  pClassInt           pointer to instance object
//  PropName            property name
//  ProvObj             Object containing the property context string.
//  pPackage            pointer to the handle cache
//  pVar                value to be set
//
//  RETURN VALUE:
//
//  S_OK                if ok,
//  otherwise misc errors.
//***************************************************************************

SCODE CImpReg::UpdateProperty(
                    IN long lFlags,
                    IN IWbemClassObject FAR * pClassInt,
                    IN BSTR PropName,
                    IN CProvObj & ProvObj,
                    IN CObject * pPackage,
                    IN CVariant * pVar)
{
    int iCnt;
    SCODE sc;
    void * pData;
    TString sProv;
    CHandleCache * pCache = (CHandleCache *)pPackage; 
    const TCHAR * pName;
    int iNumSkip;
    HKEY hCurr,hNew;
    DWORD dwRegType, dwBufferSize;

    // Do a second parse on the provider string.  The initial parse
    // is done by the calling routine and it's first token is 
    // the path.  The path token is then parsed 
    // into RegPath and it will have a token for each part of the
    // registry path.  

    CProvObj RegPath(ProvObj.sGetFullToken(1),SUB_DELIM,true);
    sc = RegPath.dwGetStatus(1);
    if(sc != WBEM_NO_ERROR)
        return sc;

    // Get a handle to a place in the reg path. Note that it might be just
    // a root key (such as HKEY_LOCAL_MACHINE) or it might be a subkey
    // if the cache contains some open handles that can be used.

    sc = GetRoot(&hCurr,RegPath,ProvObj.sGetFullToken(0),
                        pCache,iNumSkip);
    if(sc != ERROR_SUCCESS) 
        return sc;

    // Go down the registry path, creating keys if necessary
    
    for(iCnt = 1+iNumSkip; iCnt < RegPath.iGetNumTokens(); iCnt ++) 
    {
        int iRet;
        iRet = OpenKeyForWritting(hCurr,(LPTSTR)RegPath.sGetToken(iCnt),
                                        &hNew, pCache);
        if(iRet != ERROR_SUCCESS) 
        {
            sc = iRet;
            return sc;
        }
        hCurr = hNew;
        sc = pCache->lAddToList(RegPath.sGetToken(iCnt),hNew);
        if(sc != ERROR_SUCCESS)
            return sc;
    }

    // If it is a named value, get a pointer to the name
        
    if(ProvObj.iGetNumTokens() > MIN_REG_TOKENS) 
        pName = ProvObj.sGetToken(MIN_REG_TOKENS);
    else
        pName = NULL;

    // Get the data and set it

    CVariant cVar;

    if(pClassInt)
    {
        sc = pClassInt->Get(PropName,0,cVar.GetVarPtr(),NULL,NULL);
    }
    else if(pVar)
    {
        sc = OMSVariantChangeType(cVar.GetVarPtr(), 
                            pVar->GetVarPtr(),0, pVar->GetType());
    }
    else
        sc = WBEM_E_FAILED;
    if(sc != S_OK)
        return sc;

    sc = ConvertSetData(cVar, &pData, &dwRegType, &dwBufferSize);
    if(sc == S_OK) 
    {

        if(hDMRegLib && !pCache->IsRemote())
            sc = pSetValue(hCurr, pName, 0l, 
                   dwRegType, (LPBYTE)pData, dwBufferSize);
        else
            sc = RegSetValueEx(hCurr, pName, 0l, 
                   dwRegType, (LPBYTE)pData, dwBufferSize);
        CoTaskMemFree(pData);
    }
    
    return sc;
}

//***************************************************************************
//
//  SCODE CImpReg::MakeEnum
//
//  DESCRIPTION:
//
//  Creates a CEnumRegInfo object which can be used for enumeration
//
//  PARAMETERS:
//
//  pClass              Pointer to the class object.
//  ProvObj             Object containing the property context string.
//  ppInfo              Set to point to an collection object which has
//                      the keynames of the instances.
//
//  RETURN VALUE:
//
//  S_OK                all is well,
//  WBEM_E_INVALID_PARAMETER  bad context string
//  WBEM_E_OUT_OF_MEMORY
//  WBEM_E_FAILED             couldnt open the root key
//  or RegConnectRegistry failure,
//  or RegOpenKeyEx failure
//
//***************************************************************************

SCODE CImpReg::MakeEnum(
                    IWbemClassObject * pClass,
                    CProvObj & ProvObj, 
                    CEnumInfo ** ppInfo)
{
    HKEY hRoot = NULL;
    HKEY hKey =  NULL;
    HKEY hRemoteKey = NULL;
    // Parse the class context
    
    if(ProvObj.iGetNumTokens() < 2)
        return WBEM_E_INVALID_PARAMETER;
    TCHAR * pTemp = new TCHAR[lstrlen(ProvObj.sGetToken(1))+1];
    if(pTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;



    lstrcpy(pTemp,ProvObj.sGetToken(1));

    // Point to the root name and path.  These initially in a single string
    // and separated by a '\'.  find the backslash and replace with a null

    LPTSTR pRoot = pTemp;
    LPTSTR pPath;
    for(pPath = pRoot; *pPath; pPath++)
        if(*pPath == TEXT('\\'))
            break;
    if(*pPath == NULL || pPath[1] == NULL) 
    {   
        pPath = NULL;
    }
    else
    {
        *pPath = NULL;
        pPath ++;
    }

    // Got to get the root key.  First, use the second token to determine
    // which predefined key to use. That would be something like;
    // HKEY_CURRENT_USER.

    int iSize= sizeof(Bases) / sizeof(struct BaseTypes), iCnt;
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(!lstrcmpi(pRoot,Bases[iCnt].lpName)) 
        {
            hRoot = Bases[iCnt].hKey;
            break;
        }
    if(hRoot == NULL) 
    {
        delete pTemp;
        return WBEM_E_FAILED;
    }
    if(hRoot == HKEY_CURRENT_USER && m_bLoadedProfile && !lstrcmpi(ProvObj.sGetToken(0),TEXT("local")))
        hRoot = m_hRoot;

    // If the machine is remote, hook up to it.  Note that RegConnectRegistry
    // requires a non constant arg for the machine name and so a temp string
    // must be created.

    if(lstrcmpi(ProvObj.sGetToken(0),TEXT("local"))) 
    {
        TCHAR * pMachine = new TCHAR[lstrlen(ProvObj.sGetToken(0))+1];
        if(pMachine == NULL) 
        {
            delete pTemp;
            return WBEM_E_FAILED;
        }
        lstrcpy(pMachine,ProvObj.sGetToken(0));
        int iRet = RegConnectRegistry(pMachine,hRoot,&hRemoteKey);
        delete pMachine;
        if(iRet != 0)
        {
            delete pTemp;
            return iRet;
        }
       hRoot = hRemoteKey;
   }

    // Open the key down to be used for enumeration!

    int iRet;
    if(hDMRegLib && hRemoteKey == NULL)
            iRet = pOpen(hRoot,pPath,0,0,KEY_ALL_ACCESS,&hKey);
    else
            iRet = RegOpenKeyEx(hRoot,pPath,0,KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS ,&hKey);

    delete pTemp;   // all done
	if(iRet == ERROR_BAD_IMPERSONATION_LEVEL)
		return WBEM_E_ACCESS_DENIED;
    if(iRet != 0)
        return WBEM_E_FAILED;
    
    if(hDMRegLib && hRemoteKey == NULL)
        *ppInfo = new CEnumRegInfo(hKey,hRemoteKey,pClose);
    else
        *ppInfo = new CEnumRegInfo(hKey,hRemoteKey,NULL);

    return (*ppInfo) ? S_OK : WBEM_E_OUT_OF_MEMORY;

}
                                 
//***************************************************************************
//
//  SCODE CImpReg::GetKey
//
//  DESCRIPTION:
//
//  Gets the key name of an entry in the enumeration list.
//
//  PARAMETERS:
//
//  pInfo               Collection list
//  iIndex              Index in the collection
//  ppKey               Set to the string.  MUST BE FREED with "delete"
//
//  RETURN VALUE:
//
//  S_OK                    if all is well
//  WBEM_E_FAILED            end of data
//  WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpReg::GetKey(
                    CEnumInfo * pInfo,
                    int iIndex,
                    LPWSTR * ppKey)
{
    CEnumRegInfo * pRegInfo = (CEnumRegInfo *)pInfo;
    BOOL bUseDM = (hDMRegLib && pRegInfo->GetRemoteKey() == NULL);
    int iSize = 100;
    LPTSTR pData = NULL;
    *ppKey = NULL;
    long lRet = ERROR_MORE_DATA;
    while(lRet == ERROR_MORE_DATA && iSize < 1000) 
    {
        FILETIME ft;
        iSize *= 2;
        if(pData)
            delete pData;
        pData = new TCHAR[iSize];
        if(pData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        DWORD dwSize = iSize;
        if(bUseDM)
            lRet = pEnumKey(pRegInfo->GetKey(),iIndex,pData,&dwSize,NULL,NULL,NULL,&ft);
        else    
            lRet = RegEnumKeyEx(pRegInfo->GetKey(),iIndex,pData,&dwSize,NULL,NULL,NULL,&ft);
    }
    if(lRet == 0) 
    {

        // got data.  if we are in unicode, just use the current buffer, otherwise
        // we have to convert
#ifdef UNICODE
        *ppKey = pData;
        return S_OK;
#else
        *ppKey = new WCHAR[lstrlen(pData)+1];
        if(*ppKey == NULL) 
        {
            delete pData;
            return WBEM_E_OUT_OF_MEMORY;
        }
        mbstowcs(*ppKey,pData,lstrlen(pData)+1);
        delete pData;
        return S_OK;
#endif
    }
    delete pData;    
    return WBEM_E_FAILED;
}

//***************************************************************************
//
//  CEnumRegInfo::CEnumRegInfo
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  hKey            Registry Key
//  hRemoteKey      Remote registry key
//  pClose          pointer to function used to close the handle
//
//***************************************************************************

CEnumRegInfo::CEnumRegInfo(
                    HKEY hKey,
                    HKEY hRemoteKey,
                    PCLOSE pClose)
{
    m_pClose = pClose;
    m_hKey = hKey;
    m_hRemoteKey = hRemoteKey;
}

//***************************************************************************
//
//  CEnumRegInfo::~CEnumRegInfo
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumRegInfo::~CEnumRegInfo()
{
    long lRet;
    if(m_pClose != NULL && m_hRemoteKey == NULL)
        lRet = m_pClose(m_hKey);
    else
        lRet = RegCloseKey(m_hKey);
    if(m_hRemoteKey)
        lRet = RegCloseKey(m_hRemoteKey);
}

//***************************************************************************
//
//  CImpRegProp::CImpRegProp
//
//  DESCRIPTION:
//
//  Constructor.
//  
//***************************************************************************

CImpRegProp::CImpRegProp()
{
    m_pImpDynProv = new CImpReg();
}

//***************************************************************************
//
//  CImpRegProp::~CImpRegProp
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CImpRegProp::~CImpRegProp()
{
    if(m_pImpDynProv)
        delete m_pImpDynProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provreg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVREG.H

Abstract:

	Defines the classes for supporting the registry provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _PROVREG_H_
#define _PROVREG_H_

#include "regprov.h"
#include "ntcnfg.h"
//#include <DMREG.H>
#include "impdyn.h"
#include "cfdyn.h"

// define for calling dmreg indirectly

typedef LONG (PASCAL * POPEN)(HKEY              hKey,
			    LPCTSTR             lpszSubKey,     
				DWORD           dwInstanceIndex,
			    DWORD               dwReserved,
			    REGSAM              samDesired,
			    PHKEY               phkResult);
typedef LONG (PASCAL *  PQUERYVALUE)(HKEY               hKey,
			    LPTSTR              lpszValueName,
			    LPDWORD             lpdwReserved,
			    LPDWORD             lpdwType,
			    LPBYTE              lpbData,
			    LPDWORD             lpcbData);
typedef LONG (PASCAL * PCLOSE)(HKEY hKey);

typedef LONG (PASCAL * PSETVALUE)(HKEY          hKey,
			    LPCTSTR             lpValueName,
			    DWORD               Reserved,
			    DWORD               dwType,
			    CONST BYTE *lpData,
			    DWORD               cbDat);
typedef LONG (PASCAL *PENUMKEY)( HKEY           hKey,
			    DWORD               iSubkey,
			    LPTSTR              lpszName,
			    LPDWORD             lpcchName,
			    LPDWORD             lpdwReserved,
			    LPTSTR              lpszClass,
			    LPDWORD             lpcchClass,
			    PFILETIME   lpftLastWrite); 

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumRegInfo
//
//  DESCRIPTION:
//
//  A collection used to hold the instance keys so as to support enumeration.
//
//***************************************************************************

class CEnumRegInfo : public CEnumInfo{
    public:
	CEnumRegInfo(HKEY hKey, HKEY hRemoteKey,PCLOSE pClose);
	~CEnumRegInfo();
	HKEY GetKey(void){return m_hKey;};
	HKEY GetRemoteKey(void){return m_hRemoteKey;};
    private:
	 HKEY m_hKey;
	 HKEY m_hRemoteKey;
	 PCLOSE m_pClose;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpReg
//
//  DESCRIPTION:
//
//  Support the registry as an instance provider.
//
//***************************************************************************

class CImpReg : public CImpDyn {
    public:
	CImpReg();
	~CImpReg();
	int iGetMinTokens(void){return 2;};
     
	SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
					BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar, BOOL bTesterDetails);
	SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
					BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar);
	SCODE StartBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject **pObj,BOOL bGet);
	void EndBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject *pObj,BOOL bGet);

	SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
				 CEnumInfo ** ppInfo);
	SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey); 
	void Free(int iStart,CHandleCache * pCache);
	int GetRoot(HKEY * pKey,CProvObj &Path,const TCHAR * pMachine,
			CHandleCache * pCache,int & iNumToSkip);
	SCODE ConvertSetData(CVariant & cVar, void **ppData, DWORD * pdwRegType, 
			DWORD * pdwBufferSize);
	SCODE ReadRegData(HKEY hKey, const TCHAR * pName,DWORD & dwRegType, 
			DWORD & dwSize, void ** pData,CHandleCache * pCache);
	int OpenKeyForWritting(HKEY hCurr, LPTSTR pName, HKEY * pNew,CHandleCache * pCache);
	int iLookUpInt(const TCHAR * tpTest);
	int iLookUpOffset(const TCHAR * tpTest,int & iType,int & iTypeSize);
	BOOL bGetOffsetData(DWORD dwReg,CProvObj & ProvObj, int & iIntType,
			int & iBus, int & iPartial,int & iDataOffset,
			int & iDataType, int & iSourceSize,DWORD dwArray);
	PCM_PARTIAL_RESOURCE_DESCRIPTOR GetNextPartial(PCM_PARTIAL_RESOURCE_DESCRIPTOR pCurr);
	PCM_FULL_RESOURCE_DESCRIPTOR GetNextFull(PCM_FULL_RESOURCE_DESCRIPTOR pCurr);
	SCODE ConvertGetDataFromDesc(CVariant  & cVar,void * pData,DWORD dwRegType,DWORD dwBufferSize,CProvObj & ProvObj);
	SCODE ConvertGetDataFromSimple(CVariant  & cVar, void * pData,DWORD dwRegType,DWORD dwBufferSize,
					  IWbemClassObject FAR * pClassInt, BSTR PropName);
	SCODE MethodAsync(BSTR ObjectPath, BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink);
    bool NeedsEscapes(){return true;};     // so far, on reg prov needs this

    private:
	HINSTANCE hDMRegLib;
	POPEN pOpen;
	PCLOSE pClose;
	PQUERYVALUE pQueryValue;
	PSETVALUE pSetValue;
	PENUMKEY pEnumKey;
    HANDLE m_hToken;
    HKEY m_hRoot;
    bool m_bLoadedProfile;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CCFReg
//
//  DESCRIPTION:
//
//  class factory for CLocatorReg
//
//***************************************************************************

class CCFReg : public CCFDyn 
{
    public:
	IUnknown * CreateImpObj() {return (IWbemServices*) new CImpReg;};
}  ;


//***************************************************************************
//
//  CLASS NAME:
//
//  CImpRegProp
//
//  DESCRIPTION:
//
//  Support registry property provider
//
//***************************************************************************

class CImpRegProp : public CImpDynProp {

    public:
      CImpRegProp();
      ~CImpRegProp();
      bool NeedsEscapes(){return true;};     // so far, on reg prov needs this


};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFRegProp
//
//  DESCRIPTION:
//
//  Class factory for CImpRegProp
//
//***************************************************************************

class CCFRegProp : public CCFDyn 
{

    public:
	IUnknown * CreateImpObj() {return new CImpRegProp();};

}  ;

#endif //_PROVREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provauto.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVAUTO.H

Abstract:

	Declares the classes necessary for the automation provider.

History:

	a-davj  04-Mar-96   Created.

--*/


#ifndef _PROVAUTO_H_
#define _PROVAUTO_H_

#include "autoprov.h"
#include "impdyn.h"
#include "cfdyn.h"
#include <occimpl.h>

typedef enum {BOTH,PATH,NEWCLASS,RUNNINGCLASS} OBJTYPE;
extern HANDLE ghAutoMutex;
#define MAX_AUTO_WAIT 3000

//***************************************************************************
//
//  CLASS NAME:
//
//  CCtlWnd
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CCtlWnd : public CFrameWnd
{
public:
	CCtlWnd();
    COleControlContainer * pGetCont(){return m_pCtrlCont;};
};

class CAutoCache : public CHandleCache {
    public:
	COleControlSite * pSite;
	TCHAR * pSavePath;
	CCtlWnd * pCtlWnd;
	CAutoCache();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumAutoInfo
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CEnumAutoInfo : public CEnumInfo{
    public:
	CEnumAutoInfo(int iCount);
	~CEnumAutoInfo();
	int GetCount(){return m_iCount;};
    private:
	 int m_iCount;
};


// This defines the maximum number of arguments to a method.  Note that if this
// is changed, then the InvokeHelper CALLS MUST ALSO BE UPDATED!

#define MAX_ARGS 5

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpAuto
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CImpAuto : public CImpDyn {
    public:
	// Standard provider routines

	CImpAuto();

	int iGetMinTokens(void){return 2;};
	SCODE StartBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject **pObj,BOOL bGet);
	void EndBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject *pObj,BOOL bGet);
	SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
					BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar);
	SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
					BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar);
	SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
			    CEnumInfo ** ppInfo);
	SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey);
	SCODE MergeStrings(LPWSTR * ppOut,LPWSTR  pClassContext,LPWSTR  pKey,LPWSTR  pPropContext);


	// Special routines for automation

	BOOL bIsControl(LPUNKNOWN lpTest);
	SCODE DoCall(WORD wOpt, CProvObj & ProvObj,int iIndex,
			    LPDISPATCH pDisp,VARTYPE vt, void *pData,
			    WCHAR * pProp = NULL);
	SCODE GetCFileStreamObj(const TCHAR * pPath, LPSTORAGE * ppStorage, 
		COleStreamFile **ppFile,CAutoCache *pCache);
	SCODE ParsePathClass(const CString & sMix, CString & sPath, 
	    CString & sClass, OBJTYPE * type);        

	void Free(int iStart, CAutoCache * pCache);
	LPDISPATCH pGetBoth(SCODE * psc, const TCHAR * pPath, 
				   const TCHAR * pClass,CAutoCache *pCache);
	LPDISPATCH pGetDispatch(SCODE * psc,CProvObj & ObjectPath,LPCTSTR pPathClass,
					CAutoCache *pCache, int iDepth);
	LPDISPATCH pGetPath(SCODE * psc, const TCHAR * pPath);
	LPDISPATCH pGetNewClass(SCODE * psc,  const TCHAR * pClass,CAutoCache *pCache);
	LPDISPATCH pGetOCX(SCODE * psc, const TCHAR * pPath,CLSID & clsid,
				   CAutoCache *pCache, LPUNKNOWN lpUnk);
	LPDISPATCH pGetRunningClass(SCODE * psc,  const TCHAR * pClass,CAutoCache *pCache);
	LPDISPATCH pGetDispatchRoot(SCODE * psc,CProvObj & ObjectPath,LPCTSTR pPathClass,
					CAutoCache *pCache,int & iNumSkip);
	void StoreControl(CAutoCache *pCache);

};


class CCFAuto : public CCFDyn 
{

    public:
	IUnknown * CreateImpObj() {return (IWbemServices*) new CImpAuto;};

}  ;

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpAutoProp
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CImpAutoProp : public CImpDynProp {
   public:
      CImpAutoProp();
      ~CImpAutoProp();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFAutoProp
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CCFAutoProp : public CCFDyn 
{

    public:
 	IUnknown * CreateImpObj() {return new CImpAutoProp();};

}  ;

#endif //_PROVAUTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provauto.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVAUTO.CPP

Abstract:

        Defines the acutal "Put" and "Get" functions for the
        Automation provider.  The syntax of the mapping string is;
        "[path],[classid]|property

History:

    a-davj  3-13-96    Created.

--*/

NOTE, THE ORIGINAL SERVER2.CPP HAS CODE TO INITIALIZE gpStorage and ghAutoMutex

#include "precomp.h"
#include "stdafx.h"
#include <wbemidl.h>
#include "afxpriv.h"
#include "provauto.h"
#include "cvariant.h"
#define NOTFOUND -1
extern TCHAR * gpStorageFile;
extern CMyDLL theApp;


//////////////////////////////////////////////////////////////////////////////
// Special automation version of CHandleCache which also stores a hidden window,
// site and path information.  The hidden window also contains a COleContainer
// object.  Note that this extra information is only used by OCXs. The various
// values are freed up by the CImpAuto::Free routine and so a destructor isnt
// needed for this class.

//***************************************************************************
//
//  CAutoCache::CAutoCache 
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CAutoCache::CAutoCache ()
{
    pSavePath = NULL;
    pSite = NULL;
    pCtlWnd = NULL;
}


//***************************************************************************
//
//  SCODE CImpAuto::DoCall
//
//  DESCRIPTION:
//
//  Makes an IDispath Invoke call. 
//
//  PARAMETERS:
//
//  wOpt
//  ProvObj
//  iIndex
//  pDisp
//  vt
//  pData
//  pProp
//
//  RETURN VALUE:
//  Return: True if OK.  If there is a problem, then the error code is set
//          in pMo in addition to having a FALSE return code.
//
//  
//***************************************************************************

SCODE CImpAuto::DoCall(
                        WORD wOpt,
                        CProvObj & ProvObj,
                        int iIndex,
                        LPDISPATCH pDisp,
                        VARTYPE vt,
                        void * pData,
                        WCHAR * pProp)
{
    USES_CONVERSION;
    DISPID dispid;
    SCODE sc;
    COleDispatchDriver Disp;

    BYTE cArgTypes[MAX_ARGS+2];     // Extra for null terminator and for Put value
    void * Args[MAX_ARGS+1];        // Extra for put value
    int iNumArgs = 0,iExp;

    
    // Get the dispatch ID for property/method name

    OLECHAR * pArg;
    if(pProp == NULL)
        pArg = T2OLE(ProvObj.sGetToken(iIndex));
    else
        pArg = pProp;

    sc = pDisp->GetIDsOfNames(IID_NULL,&pArg,1,LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (sc != S_OK) 
        return sc;

    // Get the arguments, if any, ready for the call

    memset(cArgTypes,0,MAX_ARGS+2);
    iNumArgs = ProvObj.iGetNumExp(iIndex);
    if(iNumArgs > MAX_ARGS) 
    {
        return WBEM_E_FAILED;  // too many arguments
    }
    for(iExp = 0; iExp < iNumArgs; iExp++) 
    {
        
        // if the argument is a string, then create a BSTR and point to it.  If the
        // argument is an integer, just typecast it into the argument array

        if(ProvObj.IsExpString(iIndex,iExp)) 
        {
            Args[iExp] = SysAllocString(T2OLE(ProvObj.sGetStringExp(iIndex,iExp)));
            if(Args[iExp] == NULL) 
            {
                sc = WBEM_E_OUT_OF_MEMORY;
                goto DoInvokeCleanup;
            }
            cArgTypes[iExp] = VT_BSTR;
        }
        else 
        {
            cArgTypes[iExp] = VT_I4;
            Args[iExp] = (void *)ProvObj.iGetIntExp(iIndex,iExp,0);
        }
    }


    // use the MFC automation driver to do the acual invoke

    Disp.AttachDispatch(pDisp);
    TRY 
    { 
        if((wOpt & DISPATCH_PROPERTYPUT) || (wOpt & DISPATCH_PROPERTYPUTREF)) 
        {
        cArgTypes[iNumArgs] = (BYTE)vt;
            Args[iNumArgs] = pData;
            Disp.InvokeHelper(dispid,wOpt,VT_EMPTY,NULL,cArgTypes,
                        Args[0],Args[1],Args[2],Args[3],Args[4],Args[5]);
        }
        else
            Disp.InvokeHelper(dispid,wOpt,vt,pData,cArgTypes,
                        Args[0],Args[1],Args[2],Args[3],Args[4],Args[5]); 
        sc = S_OK;
    }
    CATCH(CException, e) 
    {
        sc = WBEM_E_FAILED;
    }
    END_CATCH


    Disp.DetachDispatch();

// This is used to clean up any BSTR strings that might have been allocated.  This
// can be skipped if it fails before any of the strings are allocated.

DoInvokeCleanup:
    for(iExp = 0; iExp < iNumArgs; iExp++) 
        if(cArgTypes[iExp] == VT_BSTR)
            SysFreeString((BSTR)Args[iExp]);
    return sc;
}

//***************************************************************************
//
//  SCODE CImpAuto::GetCFileStreamObj
//
//  DESCRIPTION:
//
//  Some OCXs use a persistent stream to load and save data.  This
//  routine gets a COleStreamFile object for such proposes.
//
//  PARAMETERS:
//
//  pPath
//  ppStorage
//  **ppFile
//  *pCache
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::GetCFileStreamObj(
                        const TCHAR * pPath,  
                        LPSTORAGE * ppStorage,
                        COleStreamFile **ppFile,
                        CAutoCache *pCache)
{
    SCODE sc;
    USES_CONVERSION;
    *ppStorage = NULL;
    *ppFile = NULL;
    if(pPath == NULL) // Some OCXs dont need storage, this is OK.
        return S_OK;

    // Save Path in the cache

    ASSERT(pCache->pSavePath == NULL);
    pCache->pSavePath = new TCHAR[lstrlen(pPath) + 1];
    lstrcpy(pCache->pSavePath,pPath);

    // During first run after install, the compond file will not exist.  This
    // is not as a problem as it will be created during the write

    sc =  StgIsStorageFile(T2OLE(gpStorageFile));
    if(sc == STG_E_FILENOTFOUND)
        return S_OK;
    if(sc != S_OK) 
    { // unusual failure!
        return sc;
    }

    // Open up the root storage.  It should never fail since we just checked to make
    // sure the file is available.
    // TODO, might want to mutex control access to the storage

    sc = StgOpenStorage(T2OLE(gpStorageFile),NULL,STGM_READ|STGM_SHARE_DENY_WRITE,
            NULL,0l,ppStorage);

    if(FAILED(sc)) 
    {
        return WBEM_E_FAILED;
    }

    // Create a new COleStreamFile object and set the stream using the storage object.
   
    *ppFile = new COleStreamFile();
    if(*ppFile == NULL) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Open a stream.  Note that failure isnt unusual since this might be the 
    // first time for the control.

    COleStreamFile * pFile = *ppFile;      
    if(!pFile->OpenStream(*ppStorage,pPath,STGM_READ|STGM_SHARE_EXCLUSIVE)) 
    {
        delete *ppFile;
        *ppFile = NULL;
    }
    return S_OK;
}

//***************************************************************************
//
//  BOOL CImpAuto::bIsControl
//
//  DESCRIPTION:
//
//  tests if the IUnknown is pointing to an object which is an OCX.
//
//  PARAMETERS:
//
//  lpTest
//
//  RETURN VALUE:
//
//  
//***************************************************************************

BOOL CImpAuto::bIsControl(
                        LPUNKNOWN lpTest)
{
    LPOLECONTROL lpCont = NULL;
    SCODE sc = lpTest->QueryInterface(IID_IOleControl,(LPVOID *) & lpCont);
    if(FAILED(sc) || lpCont == NULL) 
        return FALSE;

    // Have an OCX, free up the pointer for now since it will be retireved by
    // the COleControlSite object later on

    lpCont->Release();
    return TRUE;

}

//***************************************************************************
//
//  SCODE CImpAuto::ParsePathClass
//
//  DESCRIPTION:
//
//  Takes in a string in the sMix argument which is of the same for 
//  as the arguments to VB's GetObject and parses the string.  This routine
//  retrieves the path and class strings and determines the type.  This could be;
//  "path","class"      (Type BOTH) or
//  "path"              (Type PATH) or
//  "","class"          (Type NEWCLASS) or
//  ,"class"            (Type RUNNINGCLASS) 
//
//  PARAMETERS:
//
//  sMix
//  sPath
//  sClass
//  type
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::ParsePathClass(
                    const CString & sMix,
                    CString & sPath, 
                    CString & sClass,
                    OBJTYPE * type)
{
    int iLen = sMix.GetLength();
    int iFstst = NOTFOUND;                // first quote of the first string
    int iFsten = NOTFOUND;                // last quote of the last string
    int iSecst = NOTFOUND;                // first quote of the second string
    int iSecen = NOTFOUND;                // last quote of the second string
    int iCommaPos = NOTFOUND;             // position of comma between strings
    int iIndex;
    int iNumSoFar = 0;              // number of '"' found so far

    // Go through the string and find the starting and ending '"' of the path string
    // and possibly the class string.  Note the location of the comma.

    for(iIndex = 0; iIndex < iLen; iIndex++) 
    {
        if(sMix[iIndex] == DQUOTE)
        {
            iNumSoFar++;
            if(iFstst == NOTFOUND && iCommaPos == NOTFOUND)
                iFstst = iIndex;
            if(iCommaPos == NOTFOUND)
                iFsten = iIndex;
            if(iSecst == NOTFOUND && iCommaPos != NOTFOUND)
                iSecst = iIndex;
            if(iCommaPos != NOTFOUND)
                iSecen = iIndex;
        }
        if(sMix[iIndex] == SEPARATOR && (iNumSoFar%2 == 0) && iCommaPos == NOTFOUND) 
            iCommaPos = iIndex;
    }
    
    // Verify that there were an even number of quotes.

    if(iNumSoFar%2 || iNumSoFar == 0) 
    {
        return WBEM_E_FAILED;      // odd number of quotes is bad
    }

    // Extract the strings.

    for(iIndex = iFstst+1; iIndex < iFsten; iIndex++) 
    {
        sPath += sMix[iIndex];

        // if there is a "" in the string, copy just the first
        if(sMix[iIndex] == DQUOTE)
            iIndex++;
    }


    for(iIndex = iSecst+1; iIndex < iSecen; iIndex++) 
    {
        sClass += sMix[iIndex];

        // if there is a "" in the string, copy just the first
        if(sMix[iIndex] == DQUOTE)
            iIndex++;
    }

    // make sure that something was retrieved!

    if(sPath.GetLength() < 1 && sClass.GetLength() < 1) 
    {
        return WBEM_E_FAILED;      // didnt get any data!
    }

    // figure out what type of request

    if(sPath.GetLength() > 0 && sClass.GetLength() > 0) 
        *type = BOTH;
    else if(sPath.GetLength() > 0 && sClass.GetLength() == 0)
        *type = PATH;
    else if(sPath.GetLength() == 0 && sClass.GetLength() > 0 && iFstst != NOTFOUND)
        *type = NEWCLASS;
    else if(sPath.GetLength() == 0 && sClass.GetLength() > 0 && iFstst == NOTFOUND)
        *type = RUNNINGCLASS;
    else 
    {
        return WBEM_E_FAILED;      // got some sort of junk!
    }
    return S_OK;    // all is well
}


//***************************************************************************
//
//  CImpAuto::CImpAuto
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  ObjectPath
//  User
//  Password
//
//***************************************************************************

CImpAuto::CImpAuto()
{
    wcscpy(wcCLSID,L"{DAC651D1-7CC7-11cf-A5B6-00AA00680C3F}");
}


//***************************************************************************
//  void CImpAuto::EndBatch
//
//  DESCRIPTION:
//
//  Called at the end of a batch of Refrest/Update Property calls.  Free up 
//  any cached handles and then delete the handle cache.
//
//  PARAMETERS:
//
//  lFlags
//  pClassInt
//  *pObj
//  bGet
//
//  RETURN VALUE:
//
//  
//***************************************************************************

void CImpAuto::EndBatch(
                        long lFlags,
                        IWbemClassObject FAR * pClassInt,
                        CObject *pObj,
                        BOOL bGet)
{
    if(pObj != NULL) 
    {
        Free(0,(CAutoCache *)pObj);
        delete pObj;
    }
}

//***************************************************************************
//
//  void CImpAuto::Free
//
//  DESCRIPTION:
//
//  Frees up cached IDispatch interfaces starting with position
//  iStart till the end.  After freeing handles, the cache object 
//  member function is used to delete the cache entries.
//
//  PARAMETERS:
//
//  iStart
//  pCache
//
//  RETURN VALUE:
//
//  
//***************************************************************************

void CImpAuto::Free(
                    int iStart,
                    CAutoCache * pCache)
{
    int iCurr;
    LPOLEOBJECT pTemp = NULL;
    AFX_MANAGE_STATE(AfxGetStaticModuleState())
    for(iCurr = pCache->lGetNumEntries()-1; iCurr >= iStart; iCurr--) 
    { 
        LPDISPATCH pDisp = (LPDISPATCH)pCache->hGetHandle(iCurr); 
        if(pDisp != NULL) 
            pDisp->Release();
    }
    pCache->Delete(iStart); // get cache to delete the entries
    if(iStart == 0) 
    {
        if(pCache->pSavePath) 
        {
            if(pCache->pSite) 
            {
                DWORD dwRet;
                dwRet = WaitForSingleObject(ghAutoMutex,MAX_AUTO_WAIT);  
                if(dwRet == WAIT_ABANDONED || dwRet == WAIT_OBJECT_0) 
                {
                    try 
                    {
                        StoreControl(pCache);
                    }
                    catch(...) {}
                    ReleaseMutex(ghAutoMutex);
                }
            }
            delete pCache->pSavePath;
            pCache->pSavePath = NULL;
        }
        if(pCache->pCtlWnd != NULL)
        {
            // DONOT delete the Site object since the Control container does it!!
            // Note important HACK!  There is a bug in the MFC that ships with VC 4.0.
            // The COleControlSite::CreateOrLoad routine has a QueryInterface call
            // to get an IPersistMemory interface, BUT DOES NOT RELEASE IT!  So, to 
            // release it, there is a bit of code here to call release until the count
            // goes to 0.

            if(pCache->pSite) 
            {
                pTemp = pCache->pSite->m_pObject;
                pTemp->AddRef();
            }
            pCache->pCtlWnd->DestroyWindow();  // note that DestroyWindow frees up the object
            pCache->pCtlWnd =  NULL;           // and gets rid of the container within
            // First release for the AddRef right above.  Second possible release is
            // for the bug!
            if(pCache->pSite && pTemp) 
            {
                DWORD dwRes = pTemp->Release();
                if(dwRes > 0)
                    pTemp->Release();
            }
        }
        pCache->pSite = NULL;
    }
}

//***************************************************************************
//
//  SCODE CImpAuto::RefreshProperty
//
//  DESCRIPTION:
//
//  Gets the value of a single property from an automation server.
//
//  PARAMETERS:
//
//  lFlags
//  pClassInt
//  PropName
//  ProvObj
//  pPackage
//  pVar
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::RefreshProperty(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    BSTR PropName,
                    CProvObj & ProvObj,
                    CObject * pPackage,
                    CVariant * pVar)
{
    SCODE sc;
    USES_CONVERSION;
    CString sRet;
    LPDISPATCH pDisp = NULL;
    CAutoCache * pCache = (CAutoCache *)pPackage; 

    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    // Do a second parse on the provider string.

    CProvObj ObjectPath(ProvObj.sGetFullToken(1),DOT);
    sc = ObjectPath.dwGetStatus(1);  //todo, is 1 ok??
    if(sc != S_OK)
        return sc;

    // Get the IDispatch interface and then do the "Get"
    
    int iDepth = ObjectPath.iGetNumTokens()-1;

    HINSTANCE hTest = afxCurrentInstanceHandle;

    pDisp = pGetDispatch(&sc,ObjectPath,ProvObj.sGetToken(0),pCache,iDepth);
    if(pDisp) 
    {
        int iLast = ObjectPath.iGetNumTokens()-1;
        sc = DoCall(DISPATCH_PROPERTYGET,ObjectPath,iLast,pDisp,VT_BSTR,&sRet);
        if(sc == S_OK) 
        {
            CVariant varAuto;
            sc = varAuto.SetData(T2OLE(sRet),VT_LPWSTR);
            if(sc != S_OK)
                return sc;
            sc = varAuto.DoPut(lFlags,pClassInt,PropName,pVar);
        }
   }
    return sc;
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetBoth
//
//  DESCRIPTION:
//
//  Gets IDISPATCH interface to the server using path and class.
//
//  PARAMETERS:
//
//  psc
//  pPath
//  pClass
//  *pCache
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetBoth(
                    SCODE * psc,
                    const TCHAR * pPath,
                    const TCHAR * pClass,
                    CAutoCache *pCache)
{
    HRESULT sc;
    USES_CONVERSION;
    CLSID clsid;
    LPDISPATCH lpRetDispatch = NULL;
    LPUNKNOWN lpUnknown = NULL;
    LPPERSISTFILE lpPersist = NULL;

    sc = CLSIDFromProgID(T2OLE(pClass), &clsid);
    if (FAILED(sc))        
        goto BadBoth;

    // create an instance with the IUnknown

    sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_IUnknown, (LPVOID *)&lpUnknown);
    if (FAILED(sc))
        goto BadBoth;

    OleRun(lpUnknown);      // Some objects need this!

    // If the class is an OCX, then use special code to get its value

    if(bIsControl(lpUnknown)) 
    {
        DWORD dwRet;
        dwRet = WaitForSingleObject(ghAutoMutex,MAX_AUTO_WAIT);  
        if(dwRet == WAIT_ABANDONED || dwRet == WAIT_OBJECT_0) 
        {
            try 
            {
                lpRetDispatch = pGetOCX(psc,pPath,clsid,pCache,lpUnknown);  //frees lpUnknown
            }
            catch(...) 
            { 
                lpRetDispatch = NULL;
            }
            ReleaseMutex(ghAutoMutex);
        }
        else
            *psc = WBEM_E_FAILED;
        return lpRetDispatch;
    }

    // query for persist file interface

    sc = lpUnknown->QueryInterface(IID_IPersistFile,(LPVOID *)&lpPersist);
    lpUnknown->Release();
    if (FAILED(sc))
        goto BadBoth;

    // do a sanity check, probably not necessary.

    ASSERT(lpPersist != NULL);
    if (lpPersist == NULL) 
    {
        sc = WBEM_E_FAILED;
        goto BadBoth;
    }

    // Load up the desired file
    
    sc = lpPersist->Load(T2OLE(pPath),0); 
    if (FAILED(sc)) 
        goto BadBoth;

    sc = lpPersist->QueryInterface(IID_IDispatch,(LPVOID *)&lpRetDispatch);
    lpPersist->Release();
    if (FAILED(sc))
        goto BadBoth;

    ASSERT(lpRetDispatch != NULL);
    if (lpRetDispatch != NULL)
        return lpRetDispatch;
        
    
BadBoth:
    if(lpPersist != NULL)
        lpPersist->Release();
    *psc = sc;
    return NULL;
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetDispatch
//
//  DESCRIPTION:
//
//  Gets get the IDispatch for gets and sets
//
//  PARAMETERS:
//
//  psc
//  ObjectPath
//  pPathClass
//  *pCache
//  iDepth
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetDispatch(
                    SCODE * psc,
                    CProvObj & ObjectPath,
                    LPCTSTR pPathClass,
                    CAutoCache *pCache,
                    int iDepth)
{
    LPDISPATCH pRetDisp;
    int iNumSkip;
    int iIndex;

    // Get at least the application interface.  If the object path is in common with
    // previous calls, then some of the subobject are already set and that is 
    // indicated by the value in iNumSkip;

    pRetDisp = pGetDispatchRoot(psc,ObjectPath,pPathClass,pCache,iNumSkip);
    
    // For each subobject that wasnt in the cache, get its IDispatch, and add it 
    // to the cache.

    for(iIndex = iNumSkip; iIndex < iDepth && pRetDisp; iIndex++) 
    {
        LPDISPATCH pNewDisp;
        *psc = DoCall(DISPATCH_PROPERTYGET,ObjectPath,iIndex,
                            pRetDisp,VT_DISPATCH,&pNewDisp);
        if(*psc != S_OK)
            return NULL;
        *psc = pCache->lAddToList(ObjectPath.sGetFullToken(iIndex),pNewDisp);
        if(*psc != S_OK)
            return NULL;
        pRetDisp = pNewDisp;
    }
    return pRetDisp;
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetDispatchRoot
//
//  DESCRIPTION:
//
//  Gets the interface to the application object or some other starting point
//  such as a "document" object.
//
//  PARAMETERS:
//
//  psc
//  ObjectPath
//  pPathClass
//  *pCache
//  iNumSkip
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetDispatchRoot(
                    SCODE * psc,
                    CProvObj & ObjectPath,
                    LPCTSTR pPathClass,
                    CAutoCache *pCache,
                    int & iNumSkip)
{
    iNumSkip = 0;
    LPDISPATCH pRetDisp = NULL;
    OBJTYPE type;
    HKEY hRoot = NULL;
    const TCHAR * pObject = ObjectPath.sGetFullToken(0);
    if(pPathClass == NULL || pObject == NULL) 
    {
        *psc = WBEM_E_FAILED;   // bad mapping string
        return NULL;
    }

    // If there are handles in the cache, then they may be used if and
    // only if the path/class matches.

    if(pCache->lGetNumEntries() > 0)
    {    
        if(lstrcmpi(pCache->sGetString(0),pPathClass))
    
                 // The path/class has changed.free all the cached handles.

                 Free(0,pCache);
             else 
             {
                 
                 // The Path/class matches what is in the cache.  Determine how much 
                 // else is in common, free what isnt in common, and return
                 // the subkey share a common path.

                 iNumSkip = pCache->lGetNumMatch(1,0,ObjectPath);
                 Free(1+iNumSkip,pCache);
                 return (LPDISPATCH )pCache->hGetHandle(iNumSkip);
             }
    }


    // Need to get the initial IDispatch handle.  Start off by breaking up
    // path/class string.  Note that TRY/CATCH is used since
    // bParsePathClass does CString allocations which can give exceptions.

    CString sPath,sClass;

    TRY 
    {
        *psc = ParsePathClass(pPathClass,sPath,sClass,&type);
        if(*psc != S_OK)
            return NULL;    // bad string, actual error set in bParsePathClass
    }
    CATCH(CException, e) 
    {
        *psc = WBEM_E_OUT_OF_MEMORY;
        return NULL;
    }
    END_CATCH

    // Based on the path/class combination, call the correct routine to 
    // actually hook up to the server.

    switch(type) 
    {
        case BOTH:
            pRetDisp = pGetBoth(psc,sPath,sClass,pCache);
            break;

        case PATH:
            pRetDisp = pGetPath(psc,sPath);
            break;

        case NEWCLASS:
            pRetDisp = pGetNewClass(psc,sClass,pCache);
            break;

        case RUNNINGCLASS:
            pRetDisp = pGetRunningClass(psc,sClass,pCache);
            break;

        default:
            *psc = WBEM_E_FAILED;
    }

    if(pRetDisp == NULL) 
        return NULL;

    // Got the initial IDispatch interface.  Add it to the Cache

    *psc = pCache->lAddToList(pPathClass,pRetDisp);
    if(*psc != S_OK) 
    {    // error adding to cache, probably memory
        pRetDisp->Release();
        return NULL;
    }
    return pRetDisp;       // all is well!
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetNewClass
//
//  DESCRIPTION:
//
//  Gets IDISPATCH interface to the server using the class id and always
//  creates a new object.
//
//  PARAMETERS:
//
//  psc
//  pClass
//  *pCache
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetNewClass(
                    SCODE * psc,
                    const TCHAR * pClass,
                    CAutoCache *pCache)
{
    HRESULT sc;
    CLSID clsid;
    USES_CONVERSION;
    LPDISPATCH lpRetDispatch = NULL;
    LPUNKNOWN lpUnknown = NULL;

    sc = CLSIDFromProgID(T2OLE(pClass), &clsid);
    if (FAILED(sc))
        goto BadNewClass;

    // create an instance with the IUnknown

    sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_IUnknown, (LPVOID *)&lpUnknown);
    if (FAILED(sc))
        goto BadNewClass;
    OleRun(lpUnknown);

    // If the class is an OCX, then use special code to get its value

    if(bIsControl(lpUnknown)) 
    {
        DWORD dwRet;
        dwRet = WaitForSingleObject(ghAutoMutex,MAX_AUTO_WAIT);  
        if(dwRet == WAIT_ABANDONED || dwRet == WAIT_OBJECT_0) 
        {
            try 
            {
                lpRetDispatch = pGetOCX(psc,NULL,clsid,pCache,lpUnknown);  //frees lpUnknown
            }
            catch(...) 
            {   lpRetDispatch = NULL;
            }
            ReleaseMutex(ghAutoMutex);
        }
        else
            *psc = WBEM_E_FAILED;
        return lpRetDispatch;
    }

    // query for IDispatch interface

    sc = lpUnknown->QueryInterface(IID_IDispatch,(LPVOID *)&lpRetDispatch);
    lpUnknown->Release();
    if (FAILED(sc))
        goto BadNewClass;

    ASSERT(lpRetDispatch != NULL);
    return lpRetDispatch;

BadNewClass:
    *psc = sc;
    return NULL;
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetOCX
//
//  DESCRIPTION:
//
//  Gets IDISPATCH interface to an OCX. Note that the lpUnk should be 
//  released at the end of the routine so that the server will  
//  continue running even as it is setup as a control!
//
//  PARAMETERS:
//
//  psc
//  pPath
//  clsid
//  *pCache
//  lpUnk
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetOCX(
                    SCODE * psc,
                    const TCHAR * pPath, 
                    CLSID & clsid,
                    CAutoCache *pCache,
                    LPUNKNOWN lpUnk)
{
    RECT rect;      
    rect.left = 0; rect.right = 150; rect.top = 0; rect.bottom = 150; 
    LPDISPATCH lpRetDispatch = NULL;
    COleControlContainer * pCont = NULL;
    BOOL bOK; 
    SCODE sc;
    LPSTORAGE pStorage = NULL;
    COleStreamFile * pFileStream = NULL;
    

    // Possibly create a COleStreamFile object.  This is done only if the pPath is 
    // not NULL and if everything exists.  This routine must release the pStorage
    // interface and the pFileStream objects if the are created!
               
    *psc = GetCFileStreamObj(pPath, &pStorage, &pFileStream,pCache);
    if(*psc != S_OK)
        goto EndpGetOCX;


    // Create the window that will contain the controls.  The window's contstructor
    // creates the COleContainer object.

    pCache->pCtlWnd = new CCtlWnd();
    if(pCache->pCtlWnd == NULL) 
    {
        *psc = WBEM_E_OUT_OF_MEMORY;
        goto EndpGetOCX;
    }
    pCont = pCache->pCtlWnd->pGetCont();
        
    // Do quick sanity check, shouldnt fail

    if(pCont == NULL) 
    {
        *psc = WBEM_E_FAILED;
        goto EndpGetOCX;
    }
        
    // Use the control container to create the site and control in one call

    bOK = pCont->CreateControl(NULL, clsid, NULL,WS_CHILD,
        rect, 23, pFileStream, FALSE,       
        NULL, &pCache->pSite);
     
    if(!bOK || pCache->pSite == NULL)
    {
        pCache->pSite = NULL;
        *psc = WBEM_E_FAILED;
        goto EndpGetOCX;
    }

    // query for IDispatch interface

    sc = pCache->pSite->m_pObject->QueryInterface(IID_IDispatch,
                                                (LPVOID *)&lpRetDispatch);
    
    if (FAILED(sc)) 
    {
        *psc = sc;
        lpRetDispatch = NULL;
    }

EndpGetOCX:
    if(pFileStream) 
    {
        pFileStream->Close();
        delete pFileStream;
    }
    if(pStorage)
        pStorage->Release();
    if(lpUnk)
        lpUnk->Release();
    return lpRetDispatch;
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetPath
//
//  DESCRIPTION:
//
//  Gets IDISPATCH interface to the server using the path.
//
//  PARAMETERS:
//
//  psc
//  pPath
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetPath(
                    SCODE * psc,
                    const TCHAR * pPath)
{
    HRESULT sc;
    LPBC pbc=NULL;
    LPDISPATCH lpRetDispatch = NULL;
    USES_CONVERSION;
    LPMONIKER pmk;
    pmk=NULL;
    DWORD dwEat;

    // Get a bind context object.

    sc = CreateBindCtx(0, &pbc);
    if (FAILED(sc)) 
    {
        *psc = sc;
        return NULL;
    }

    // Get a moniker

    sc = MkParseDisplayName(pbc, T2OLE(pPath), &dwEat, &pmk);
    if (FAILED(sc))
        goto BadPath;

    // Bind the moniker

    sc = (pmk)->BindToObject(pbc, NULL, IID_IDispatch
            , (void **)&lpRetDispatch);

    pmk->Release();
    if(FAILED(sc))
        goto BadPath;
    ASSERT(lpRetDispatch != NULL);

    // If the class is an OCX, then something is wrong here.

    if(bIsControl(lpRetDispatch)) 
    {
        *psc = WBEM_E_FAILED;
        lpRetDispatch->Release();
        return NULL;
    }

    if(lpRetDispatch) 
    {         // should always be true at this point!
        pbc->Release();
        return lpRetDispatch;
    }
    sc = WBEM_E_FAILED;

BadPath:
    if(pbc)
        pbc->Release();
    *psc = sc;
    return NULL;
}

//***************************************************************************
//
//  LPDISPATCH CImpAuto::pGetRunningClass
//
//  DESCRIPTION:
//
//  Gets IDISPATCH interface to the server using the class id and always
//  returns only running objects.
//
//  PARAMETERS:
//
//  psc
//  pClass
//  *pCache
//
//  RETURN VALUE:
//
//  
//***************************************************************************

LPDISPATCH CImpAuto::pGetRunningClass(
                        SCODE * psc,
                        const TCHAR * pClass,
                        CAutoCache *pCache)
{
    HRESULT sc;
    CLSID clsid;
    LPDISPATCH lpRetDispatch = NULL;
    USES_CONVERSION;
    LPUNKNOWN lpUnknown = NULL;

    sc = CLSIDFromProgID(T2OLE(pClass), &clsid);
    if (FAILED(sc))
        goto BadRunningClass;

    // create an instance with the IUnknown

    sc = GetActiveObject(clsid,NULL,&lpUnknown);
    if (FAILED(sc))
        goto BadRunningClass;

    // query for IDispatch interface

    sc = lpUnknown->QueryInterface(IID_IDispatch,(LPVOID *)&lpRetDispatch);
    lpUnknown->Release();
    if (FAILED(sc))
        goto BadRunningClass;

    // If the class is an OCX, then use special code to get its value

    if(bIsControl(lpUnknown))
        return pGetOCX(psc,NULL,clsid,pCache,lpUnknown);  //frees lpUnknown

    ASSERT(lpRetDispatch != NULL);
    if (lpRetDispatch != NULL)
        return lpRetDispatch;

BadRunningClass:
    *psc = sc;
    return NULL;
}

//***************************************************************************
//
//  SCODE CImpAuto::UpdateProperty
//
//  DESCRIPTION:
//
//  Writes the value of a single property to an automation server.
//
//  PARAMETERS:
//
//  lFlags
//  pClassInt
//  PropName
//  ProvObj
//  pPackage
//  pVar
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::UpdateProperty(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    BSTR PropName,
                    CProvObj & ProvObj,
                    CObject * pPackage,
                    CVariant * pVar)
{
    CVariant vIn;
    SCODE sc;
    AFX_MANAGE_STATE(AfxGetStaticModuleState())
    
    // Get the property value

    if(pClassInt)
    {
        sc = pClassInt->Get(PropName,lFlags,vIn.GetVarPtr(),NULL,NULL);
        if(sc != S_OK)
            return sc;
        sc = vIn.ChangeType(VT_BSTR);
    }
    else if(pVar)
    {
        sc =OMSVariantChangeType(vIn.GetVarPtr(), pVar->GetVarPtr(),0, VT_BSTR);
    }
    else
        sc = WBEM_E_FAILED;
    if(sc != S_OK)
        return sc;



    LPDISPATCH pDisp = NULL;
    CAutoCache * pCache = (CAutoCache *)pPackage; 

    // Do a second parse on the provider string.

    CProvObj ObjectPath(ProvObj.sGetFullToken(1),DOT);
    sc = ObjectPath.dwGetStatus(1);
    if(sc != S_OK)
        return sc;

    // Get the IDispatch interface and then do the "Get"
    
    int iDepth = ObjectPath.iGetNumTokens()-1;
    pDisp = pGetDispatch(&sc,ObjectPath,ProvObj.sGetToken(0),pCache,iDepth);
    if(pDisp) 
    {
        int iLast = ObjectPath.iGetNumTokens()-1;
        sc = DoCall(DISPATCH_PROPERTYPUT,ObjectPath,iLast,pDisp,VT_BSTR,vIn.GetBstr());
    }
    return sc;
}

//***************************************************************************
//
//  SCODE CImpAuto::StartBatch
//
//  DESCRIPTION:
//
//  Called at the start of a batch of Refrest/Update Property calls.  Initialize
//  the handle cache.
//
//  PARAMETERS:
//
//  lFlags
//  pClassInt
//  **pObj
//  bGet
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::StartBatch(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    CObject **pObj,
                    BOOL bGet)
{
    *pObj = new CAutoCache;
    return (pObj != NULL) ? S_OK : WBEM_E_OUT_OF_MEMORY;
}

//***************************************************************************
//
//  void CImpAuto::StoreControl
//
//  DESCRIPTION:
//
//  Used when an OCX is no longer being used and the OCX uses
//  a stream to store its data.
//
//  PARAMETERS:
//
//  *pCache
//
//***************************************************************************

void CImpAuto::StoreControl(
                        CAutoCache *pCache)
{
    SCODE sc;
    LPSTORAGE pIStorage = NULL;
    LPSTREAM pIStream = NULL;
    LPPERSISTSTREAMINIT pPersStm = NULL;
    USES_CONVERSION;

    // Open up the storage file, create it if necessary

    sc = StgIsStorageFile(T2OLE(gpStorageFile));

    if(sc == S_OK)
           sc = StgOpenStorage(T2OLE(gpStorageFile),NULL,
                      STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                      NULL,0L, &pIStorage);
    else if(sc == STG_E_FILENOTFOUND)
        sc = StgCreateDocfile(T2OLE(gpStorageFile),
                    STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
                    0L, &pIStorage);
    if(sc != S_OK)
        return;            //todo, error handling?????

    // Open/Create the stream

    sc = pIStorage->OpenStream(T2OLE(pCache->pSavePath),NULL,
                    STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                    0,&pIStream);
    if(sc == STG_E_FILENOTFOUND) 
        sc = pIStorage->CreateStream(T2OLE(pCache->pSavePath),
                    STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_FAILIFTHERE,
                    0,0,&pIStream);
    if(sc != S_OK) 
    {
        goto cleanupStoreControl;
    }
    sc = pCache->pSite->m_pObject->QueryInterface(IID_IPersistStreamInit,
                                                        (void **)&pPersStm);
    if(!FAILED(sc))
        pPersStm->Save(pIStream,TRUE);

cleanupStoreControl:
    if(pPersStm)
        pPersStm->Release();
    if(pIStream)
        pIStream->Release();
    if(pIStorage)
        pIStorage->Release();
}

/////////////////////////////////////////////////////////////////////////////////
// Special version of CWnd which is used to hold OCXs.  It automatically sets 
// itself up as an OCX container and it also has a function to return pointer
// to the control container.

//***************************************************************************
//
//  CCtlWnd::CCtlWnd
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CCtlWnd::CCtlWnd()
{
    RECT rect; rect.left = 0; rect.right = 50; rect.bottom = 100; rect.top = 0;
    AfxEnableControlContainer();
    HANDLE hh = afxCurrentInstanceHandle;
    hh = AfxGetInstanceHandle();
    Create(NULL,"");
    InitControlContainer();
}

//***************************************************************************
//
//  SCODE CImpAuto::MakeEnum
//
//  DESCRIPTION:
//
//  Creates a CEnumPerfInfo object which can be used for enumeration
//
//  PARAMETERS:
//
//  pClass
//  ProvObj
//  ppInfo
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::MakeEnum(
                    IWbemClassObject * pClass,
                    CProvObj & ProvObj, 
                    CEnumInfo ** ppInfo)
{
    SCODE sc;
    *ppInfo = NULL;
    LPDISPATCH pDisp = NULL;
    CAutoCache Cache;
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    // Do a second parse on the provider string.

    CProvObj ObjectPath(ProvObj.sGetFullToken(1),DOT);
    sc = ObjectPath.dwGetStatus(1);  //todo, is 1 ok??
    if(sc != S_OK)
        return sc;

    // Get the IDispatch interface and then get thedo the "Get"
    
    int iDepth = ObjectPath.iGetNumTokens();
    pDisp = pGetDispatch(&sc,ObjectPath,ProvObj.sGetToken(0),&Cache,iDepth);
    if(pDisp) 
    {
        int iCount;
        sc = DoCall(DISPATCH_PROPERTYGET,ObjectPath,0,pDisp,VT_I4,
                        &iCount,L"Count");
        if(sc == S_OK) 
        {
            // Create a new CEnumAutoInfo object.
            CEnumAutoInfo * pInfo = new CEnumAutoInfo(iCount);
            if(pInfo == NULL) 
            {
                sc = WBEM_E_OUT_OF_MEMORY;
            }
            else
                *ppInfo = pInfo;
        }
   }
    return sc;

}
                                 
//***************************************************************************
//
//  SCODE CImpAuto::GetKey
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pInfo
//  iIndex
//  ppKey
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::GetKey(
                    CEnumInfo * pInfo,
                    int iIndex,
                    LPWSTR * ppKey)
{
    *ppKey = new WCHAR[10];
    CEnumAutoInfo * pAuto = (CEnumAutoInfo *)pInfo;
    if(iIndex >= pAuto->GetCount())
        return WBEM_E_FAILED;
    if(*ppKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    _itow(iIndex + 1,*ppKey,10);
    return S_OK;
}

//***************************************************************************
//
//  SCODE CImpAuto::MergeStrings
//
//  DESCRIPTION:
//
//  Combines the Class Context, Key, and Property Context strings.
//
//  PARAMETERS:
//
//  ppOut
//  pClassContext
//  pKey
//  pPropContext
//
//  RETURN VALUE:
//
//  
//***************************************************************************

SCODE CImpAuto::MergeStrings(
                        LPWSTR * ppOut,
                        LPWSTR  pClassContext,
                        LPWSTR  pKey,
                        LPWSTR  pPropContext)
{
    
    // Allocate space for output

    int iLen = 6;
    if(pClassContext)
        iLen += wcslen(pClassContext);
    if(pKey)
        iLen += wcslen(pKey);
    if(pPropContext)
        iLen += wcslen(pPropContext);
    else
        return WBEM_E_FAILED;  // should always have this!
    *ppOut = new WCHAR[iLen];
    if(*ppOut == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // simple case is that everything is in the property context.  That would
    // be the case when the provider is being used as a simple dynamic 
    // property provider

    if(pClassContext == NULL || pKey == NULL) 
    {
        wcscpy(*ppOut,pPropContext);
        return S_OK;
    }

    // Copy the class context, property, and finally the key

    wcscpy(*ppOut,pClassContext);
    wcscat(*ppOut,L"(");
    wcscat(*ppOut,pKey);
    wcscat(*ppOut,L").");
    wcscat(*ppOut,pPropContext);
    return S_OK;
}

//***************************************************************************
//
//  CEnumAutoInfo::CEnumAutoInfo
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS: 
//
//  iCount
//  
//***************************************************************************

CEnumAutoInfo::CEnumAutoInfo(
                        int iCount)
{
    m_iCount = iCount;
}

//***************************************************************************
//
//  CEnumAutoInfo::~CEnumAutoInfo
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CEnumAutoInfo::~CEnumAutoInfo()
{

}

//***************************************************************************
//
//  CImpAutoProp::CImpAutoProp
//
//  DESCRIPTION:
//
//  Constructor.
//  
//***************************************************************************

CImpAutoProp::CImpAutoProp()
{
    m_pImpDynProv = new CImpAuto();
}

//***************************************************************************
//
//  CImpAutoProp::~CImpAutoProp
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CImpAutoProp::~CImpAutoProp()
{
    if(m_pImpDynProv)
        delete m_pImpDynProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provsnmp.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVSNMP.CPP

Abstract:

    Purpose: Defines the acutal "Put" and "Get" functions for the
             "SNMP" file provider.  The syntax of the mapping string is;
          "TBD"

History:

    TBD    4-5-96       v0.01.

--*/

#include "precomp.h"
#include "stdafx.h"
#include <wbemidl.h>
#include "impdyn.h"

// This max size just prevents the read from incrementing to the point 
// where CStrings no longer work

#define MAXSIZE 0x4FFF

//SNMP specific constants
#define TIMEOUT 500
#define RETRIES 3
#define IPADDRESSSTRLEN 16
  //Indexes of SNMP parameters in the provider string
#define AGENT_INX 0
#define COMMUNITY_INX 1
#define OID_INX 2

BYTE HEXCHAR[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};


BOOL IsDisplayable(AsnOctetString OctetString)
{
    BYTE *p;
    UINT i;

    for (i=0, p=OctetString.stream; 
              ((i<OctetString.length) && ((*p >= 0x20) && (*p <= 0x7E))); 
              i++, p++);
    if (i == OctetString.length)
        return(TRUE);
    else
        return(FALSE);
}

//***************************************************************************
//
//  CImpSNMP::CImpSNMP
//
//  Constructor. Only current purpose is to call its base class constructor.
//
//***************************************************************************

CImpSNMP::CImpSNMP(LPUNKNOWN pUnkOuter) : CImpDyn(pUnkOuter)
{
    return;
}

//***************************************************************************
//
//  CImpSNMP::StartBatch
//
//  Called at the start of a batch of gets or puts. 
//  Retrieve agent & community from first provider string (ignore all other)
//  and open a session with this agent for SNMP requests.
//
//***************************************************************************

void CImpSNMP::StartBatch(MODYNPROP * pMo,CObject **pObj,DWORD dwListSize,BOOL bGet)
{
    TCHAR *agentStr; //IP address as String
    TCHAR *communityStr; //Community String

    *pObj = NULL;
    generalError = 0;
    Session = NULL;
    //Reset variable binding list
    variableBindings.list = NULL;
    variableBindings.len = 0;
    TCHAR * pMapString;

#ifdef UNICODE
        pMapString = pMo->pProviderString;
#else
        pMapString = WideToNarrow(pMo->pProviderString);
#endif

    //Retrieve agent & community information from 1st property structure :
      //Create token object and make sure it has enough tokens
    CProvObj ProvObj(pMapString,MAIN_DELIM);
    if(ProvObj.dwGetStatus() != WBEM_NO_ERROR)
    {
        generalError = ProvObj.dwGetStatus();
        return;
    }

    if(ProvObj.iGetNumTokens() < iGetMinTokens())
    {
        generalError = M_MISSING_INFORMATION;
        return;
    }
      
    //Provider string seems OK - 
    //Extract agent address & community name and open SNMP session with agent
    agentStr = new TCHAR[lstrlen(ProvObj.sGetToken(AGENT_INX))+1];
    //(TCHAR *)CoTaskMemAlloc(lstrlen(ProvObj.sGetToken(AGENT_INX))+1);
    if (agentStr == NULL)
    {
        generalError = WBEM_E_OUT_OF_MEMORY;
        return;
    }
    lstrcpy(agentStr, ProvObj.sGetToken(AGENT_INX));

    communityStr = new TCHAR[lstrlen(ProvObj.sGetToken(COMMUNITY_INX))+1];
    //(TCHAR *)CoTaskMemAlloc(lstrlen(ProvObj.sGetToken(COMMUNITY_INX)));
    if (communityStr == NULL)
    {
        generalError = WBEM_E_OUT_OF_MEMORY;
        delete agentStr;
        //CoTaskMemFree(agentStr);
        return;
    }
    lstrcpy(communityStr, ProvObj.sGetToken(COMMUNITY_INX));

    Session = SnmpMgrOpen(agentStr, communityStr, TIMEOUT, RETRIES);
    if (Session == NULL) //error
    {
        generalError = GetLastError();
        delete agentStr; delete communityStr;
        //CoTaskMemFree(agentStr); CoTaskMemFree(communityStr);
        return;
    }

    //Set requestType value
    requestType = (bGet ? ASN_RFC1157_GETREQUEST : ASN_RFC1157_SETREQUEST);

    //Free allocated buffers for agent & community - not needed once the session is open
    delete agentStr; delete communityStr;
    //CoTaskMemFree(agentStr); CoTaskMemFree(communityStr);

    //Free pMapString
#ifndef UNICODE
    if(pMapString)
            CoTaskMemFree(pMapString);
#endif

    return;
}

//***************************************************************************
//
//  CImpSNMP::EndBatch
//
//  Called at the end of a batch of gets or puts.  
//  At this point we should have a valid session open and a variable binding
//  constructed. If so, send the SNMP request, and after receiving the answer
//  close the session with this agent.  
//
//***************************************************************************

void CImpSNMP::EndBatch(MODYNPROP *pMo,CObject *pObj,DWORD dwListSize,BOOL bGet)
{
    AsnInteger errorStatus;
    AsnInteger errorIndex;
    DWORD reqCnt;
    DWORD varBindCnt;
    DWORD allocatedLength;

    //temps to hold values for conversion
    AsnObjectSyntax *SNMPValue;
    BYTE *OLESMValue;

    if ((Session == NULL) || (generalError != 0))
        return;
    
    //Carry out request
    if (!SnmpMgrRequest(Session, requestType, &variableBindings, &errorStatus, &errorIndex))
        //API error occured
        generalError = GetLastError();

    
    varBindCnt = 0;
    for (reqCnt = 0; reqCnt < dwListSize; reqCnt++, pMo++)
    {
        //if request failed above, need to set all dwResults to the failure code
        if (generalError != 0)
        {
            pMo->dwResult = generalError;
            continue;
        }
        //if dwResult was already set to an error, this request was not sent in the SNMP message
        //  in the first place, so skip to the next one
        if (pMo->dwResult != WBEM_NO_ERROR)
            continue;

        if (errorStatus != SNMP_ERRORSTATUS_NOERROR)
        {
            //There was an SNMP error - no values are returned
            pMo->pPropertyValue = NULL;
            pMo->dwResult = WBEM_E_FAILED; 
            //should I return specific SNMP error ?????
            //the errorIndex information is lost here !!!!
            continue;
        }

        //Value is valid - try converting to supported types
        SNMPValue = &(variableBindings.list[varBindCnt].value);
        generalError = CopySNMPValToOLESMVal(SNMPValue, &OLESMValue, pMo->dwType, &allocatedLength);
        if (generalError != 0)
        {   //error detected when converting types
            pMo->pPropertyValue = NULL;
            pMo->dwBufferSize = 0;
            pMo->dwResult = generalError;
        }
        else
        {   //types converted OK, so OLESMValue is pointing to the newly allocated value
            pMo->pPropertyValue = OLESMValue;
            pMo->dwBufferSize = allocatedLength;
            pMo->dwResult = WBEM_NO_ERROR;
        }

        varBindCnt++;
    }//for
                        
    //Free variable bindings structure
    if (variableBindings.list != NULL)
        CoTaskMemFree(variableBindings.list);

    //Close session with agent (don't check status since we can't return error anyway....????)
    SnmpMgrClose(Session);

    return;

}//EndBatch

//***************************************************************************
//
//  CImpSNMP::GetProp
//
//  Builds a variable binding for the current property 
//
//***************************************************************************

void CImpSNMP::GetProp(MODYNPROP * pMo, CProvObj & ProvObj,CObject * pPackage)
{
    TCHAR * oidStr;
    AsnObjectIdentifier reqObject;
    
    pMo->dwResult = WBEM_NO_ERROR;  //To be checked in EndBatch()
    
    //If Session is not open - error !
    if ((Session == NULL) || (generalError != 0))
    {
        pMo->dwResult = generalError;
        return;
    }

    //Extract OID of property from provider string
    oidStr = new TCHAR[lstrlen(ProvObj.sGetToken(OID_INX))+1];
    //(TCHAR *)CoTaskMemAlloc(lstrlen(ProvObj.sGetToken(OID_INX)));
    if (oidStr == NULL)
    {
        pMo->dwResult = WBEM_E_OUT_OF_MEMORY;
        return;
    }
    lstrcpy(oidStr, ProvObj.sGetToken(OID_INX)); //oid is the 3rd parameter in the provider string

    //Convert string representation of OID to internal rep.
    if (!SnmpMgrStrToOid(oidStr, &reqObject))
    {
        pMo->dwResult = M_MISSING_INFORMATION;
        delete oidStr;
        //CoTaskMemFree(oidStr);
        return;
    }

    //If conversion successful, free OID string - not needed once we have the OID in internal rep.
    delete oidStr;
    //CoTaskMemFree(oidStr);

    //Allocate new variable binding in list
    variableBindings.list = 
             (RFC1157VarBind *)CoTaskMemRealloc(variableBindings.list, 
                                                sizeof(RFC1157VarBind) * (variableBindings.len+1));
    if (variableBindings.list == NULL) //allocation failed
    {
        pMo->dwResult = WBEM_E_OUT_OF_MEMORY;
        return;
    }

    //if allocation succesful, copy info to new variable binding
    variableBindings.len++;
    variableBindings.list[variableBindings.len - 1].name = reqObject; //structure copy !!
    variableBindings.list[variableBindings.len - 1].value.asnType = ASN_NULL;
    return;
}//GetProp


//***************************************************************************
//
//  CImpSNMP::SetProp
//
//  Writes the value of a single property
//
//***************************************************************************

void CImpSNMP::SetProp(MODYNPROP *  pMo, CProvObj & ProvObj,CObject * pPackage)
{
    CString sString;
    
    sString = ProvObj.sGetToken(0);
    pMo->dwResult = 0 ;
    return;
}


//***************************************************************************
//
//  CImpSNMP::CopySNMPValToOLESMVal
//
//  Converts an SNMP value to an OLESM supported type, allocates and sets
//  the value in the property structure.
//  The pLen parameter outputs the length of the allocated memory
//  The return value specifies the outcome of the function (0 for success)
//
//***************************************************************************

DWORD CImpSNMP::CopySNMPValToOLESMVal(AsnAny *fromVal, BYTE **pToVal, DWORD OLESMType, DWORD *pLen)
{
    DWORD ret = WBEM_NO_ERROR;
    UINT i;
    BYTE *pSrc, *pDst;

    switch (OLESMType)
    {
        case M_TYPE_DWORD :
            if ((fromVal->asnType == ASN_INTEGER) || (fromVal->asnType == ASN_RFC1155_COUNTER) ||
                (fromVal->asnType == ASN_RFC1155_GAUGE) || (fromVal->asnType == ASN_RFC1155_TIMETICKS))
            {
                if (!(*pToVal = (BYTE *)CoTaskMemAlloc(sizeof(DWORD))))
                    ret = WBEM_E_OUT_OF_MEMORY;
                else
                {   //allocation succeeded
                    *pLen = sizeof(DWORD);
                    switch (fromVal->asnType)
                    {
                      case ASN_INTEGER :           *(DWORD *)(*pToVal) = fromVal->asnValue.number;  break;
                      case ASN_RFC1155_COUNTER :   *(DWORD *)(*pToVal) = fromVal->asnValue.counter; break;
                      case ASN_RFC1155_GAUGE :     *(DWORD *)(*pToVal) = fromVal->asnValue.gauge;   break;
                      case ASN_RFC1155_TIMETICKS : *(DWORD *)(*pToVal) = fromVal->asnValue.ticks;     break;
                      default : break;
                    }
                }
            }
            else 
                ret = M_TYPE_MISMATCH;
            break;

        case M_TYPE_LPSTR :
            switch (fromVal->asnType)
            {
                case ASN_OCTETSTRING :
                    if (IsDisplayable(fromVal->asnValue.string))
                        //Need to add '\0' only
                        if (!(*pToVal = (BYTE *)CoTaskMemAlloc(fromVal->asnValue.string.length+1)))
                            ret = WBEM_E_OUT_OF_MEMORY;
                        else
                        {   //allocation succeeded
                            *pLen = fromVal->asnValue.string.length+1;
                            memcpy(*pToVal, fromVal->asnValue.string.stream, fromVal->asnValue.string.length);
                            *(*pToVal + (*pLen-1)) = '\0';
                        }
                    else    //String is stream of bytes (non-displayable)   
                        //Need to copy non-displayable characters to "^XX" format
                        //Allocate 3 chars for every byte in the stream + '\0'
                        if (!(*pToVal = (BYTE *)CoTaskMemAlloc((fromVal->asnValue.string.length * 3) + 1)))
                            ret = WBEM_E_OUT_OF_MEMORY;
                        else
                        {   //allocation succeeded
                            *pLen  = (fromVal->asnValue.string.length * 3) + 1;
                            for (i=0, pSrc=fromVal->asnValue.string.stream, pDst=*pToVal;
                                 i<fromVal->asnValue.string.length;
                                 i++, pSrc++)
                                 {
                                     *(pDst++) = '^';
                                     *(pDst++) = HEXCHAR[(*pSrc & 0x0F)];
                                     *(pDst++) = HEXCHAR[((*pSrc & 0xF0) >> 4)];
                                 }
                            *(*pToVal + (*pLen-1)) = '\0';
                        }

                    break;
                case ASN_OBJECTIDENTIFIER :
                    {
                        TCHAR *oidStr = NULL;
                        SnmpMgrOidToStr(&(fromVal->asnValue.object), &oidStr);
                        if (!oidStr)
                            ret = WBEM_E_OUT_OF_MEMORY;
                        else
                        {
                            if (!(*pToVal = (BYTE *)CoTaskMemAlloc(lstrlen(oidStr)+1)))
                                ret = WBEM_E_OUT_OF_MEMORY;
                            else
                            {
                                *pLen = lstrlen(oidStr)+1;
                                memcpy(*pToVal, oidStr, *pLen);
                            }
                            GlobalFree(oidStr);
                        }
                    }
                    break;
                case ASN_SEQUENCE :
                    if (!(*pToVal = (BYTE *)CoTaskMemAlloc(fromVal->asnValue.sequence.length)))
                        ret = WBEM_E_OUT_OF_MEMORY;
                    else
                    {
                        *pLen = fromVal->asnValue.sequence.length;
                        memcpy(*pToVal, fromVal->asnValue.sequence.stream, fromVal->asnValue.sequence.length);
                    }
                    break;
                case ASN_RFC1155_IPADDRESS :
                    //allocate a string for string representation of IP address
                    if (!(*pToVal = (BYTE *)CoTaskMemAlloc(IPADDRESSSTRLEN)))
                        ret = WBEM_E_OUT_OF_MEMORY;
                    else
                    {   //allocation succeeded
                        //Copy IP address to formatted string
                        sprintf((TCHAR *)*pToVal, "%u.%u.%u.%u\0", *(fromVal->asnValue.address.stream),
                                                        *(fromVal->asnValue.address.stream+1),
                                                        *(fromVal->asnValue.address.stream+2),
                                                        *(fromVal->asnValue.address.stream+3));
                        *pLen = lstrlen((TCHAR *)*pToVal)+1;
                        //*pLen = fromVal->asnValue.address.length;
                        //memcpy(*pToVal, fromVal->asnValue.address.stream, fromVal->asnValue.address.length);
                    }
                    break;
                case ASN_RFC1155_OPAQUE :
                    if (!(*pToVal = (BYTE *)CoTaskMemAlloc(fromVal->asnValue.arbitrary.length)))
                        ret = WBEM_E_OUT_OF_MEMORY;
                    else
                    {
                        *pLen = fromVal->asnValue.arbitrary.length;
                        memcpy(*pToVal, fromVal->asnValue.arbitrary.stream, fromVal->asnValue.arbitrary.length);
                    }
                    break;
                default :
                    ret = M_TYPE_MISMATCH;
                    break;
            }
            break;
        default :
            ret = M_TYPE_NOT_SUPPORTED;
            break;
    }//switch (OLESMType)

    if (ret != WBEM_NO_ERROR) //error
    {
        *pToVal = NULL; 
        *pLen = 0;
    }

    return(ret);

}//CopySNMPValToOLESMVal()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\provperf.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVPERF.H

Abstract:

	Declares the classes needed for the perm monitor provider.

History:

	a-davj  27-Nov-95   Created.

--*/

#ifndef _PROVPERF_H_
#define _PROVPERF_H_

#include <winperf.h>
#include "perfprov.h"
#include "impdyn.h"
#include "cfdyn.h"
#include "perfcach.h"
#include "indexcac.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumPerfInfo
//
//  DESCRIPTION:
//
//  A collection class that holds the instance information for use when
//  support enumeration.
//
//***************************************************************************

class CEnumPerfInfo : public CEnumInfo
{
    public:
       CEnumPerfInfo();
       ~CEnumPerfInfo();
       void AddEntry(LPWSTR pNew);
       LPWSTR GetEntry(int iIndex);
       int GetNumDuplicates(LPWSTR pwcTest);
       SCODE GetStatus(void){return m_status;};
    private:
       int m_iNumUniChar;
       int m_iNumEntries;
       LPWSTR m_pBuffer;
       SCODE m_status;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpPerf
//
//  DESCRIPTION:
//
//  This overrides the CImpDyn class and provides the main functions of 
//  support the perf monitor instance provider.
//
//***************************************************************************

class CImpPerf : public CImpDyn 
{
    public:
    friend DWORD CleanUpThreadRoutine( LPDWORD pParam );
    CImpPerf();
    ~CImpPerf();
    int iGetMinTokens(void){return 3;};
    SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                    BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar, BOOL bTesterDetails);
    SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                    BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar);
    SCODE LoadData(CProvObj & ProvObj,LINESTRUCT * pls,int * piObject, 
        int * piCounter, PERF_DATA_BLOCK **ppNew, BOOL bJustGettingInstances);
    SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
                CEnumInfo ** ppInfo);
    SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey);
    virtual void FreeStuff(void);
    DWORD   GetPerfTitleSz ();
    DWORD dwGetRegHandles(const TCHAR * pMachine);
    int iGetTitleIndex(const TCHAR * pSearch);
    SCODE FindData(PERF_DATA_BLOCK * pData,int iObj, int iCount,CProvObj & ProvObj,DWORD * pdwSize,
        void **ppRetData,PLINESTRUCT pls, BOOL bNew,CEnumPerfInfo * pInfo);
    SCODE MergeStrings(LPWSTR *ppOut,LPWSTR  pClassContext,LPWSTR  pKey,LPWSTR  pPropContext);
    private:
    HANDLE hExec;
    PerfCache Cache;
    HKEY hKeyMachine;
    DWORD dwLastTimeUsed;
    HKEY    hKeyPerf;
    TString sMachine;
    HANDLE m_hTermEvent;
    LPTSTR TitleBuffer; // raw buffer of counter titles
   CIndexCache m_IndexCache;

    
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFPerf
//
//  DESCRIPTION:
//
//  Class factory for CLocatorPerf class
//
//***************************************************************************

class CCFPerf : public CCFDyn 
{

    public:
    IUnknown * CreateImpObj() {return (IWbemServices*) new CImpPerf;};
}  ;

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpPerfProp
//
//  DESCRIPTION:
//
//  Perf Provider property provider class.
//
//***************************************************************************

class CImpPerfProp : public CImpDynProp {

    public:
      CImpPerfProp();
      ~CImpPerfProp();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFPerfProp
//
//  DESCRIPTION:
//
//  Class factory for CImpPerfProp class.
//
//***************************************************************************

class CCFPerfProp : public CCFDyn 
{

    public:
    IUnknown * CreateImpObj() {return new CImpPerfProp();};

}  ;

#endif //_PROVPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regedefs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEDEFS.H

Abstract:

History:

--*/

#ifndef __WBEM_REG_EVENT_DEFS__H_
#define __WBEM_REG_EVENT_DEFS__H_

#define REG_KEY_EVENT_CLASS L"RegistryKeyChangeEvent"
#define REG_VALUE_EVENT_CLASS L"RegistryValueChangeEvent"
#define REG_TREE_EVENT_CLASS L"RegistryTreeChangeEvent"

#define REG_HIVE_PROPERTY_NAME L"Hive"
#define REG_KEY_PROPERTY_NAME L"KeyPath"
#define REG_VALUE_PROPERTY_NAME L"ValueName"
#define REG_ROOT_PROPERTY_NAME L"RootPath"

enum
{
    e_RegValueChange,
    e_RegKeyChange,
    e_RegTreeChange
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regcrc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGCRC.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "regcrc.h"
#include "tchar.h"

HRESULT CRegCRC::ComputeValueCRC(HKEY hKey, LPCTSTR szValueName, 
                                    DWORD dwPrevCRC, DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Get the size of the value
    // =========================

    DWORD dwSize = 0;
    long lRes = RegQueryValueEx(hKey, szValueName, NULL, NULL, NULL, &dwSize);
    if(lRes)
    {
        return S_FALSE;
    }

    // Get the actual value
    // ====================

    BYTE* pBuffer = new BYTE[dwSize];
    DWORD dwType;
    lRes = RegQueryValueEx(hKey, szValueName, NULL, &dwType, 
                                pBuffer, &dwSize);
    if(lRes)
    {
        return S_FALSE;
    }

    // Hash the type
    // =============

    dwNewCRC = UpdateCRC32((BYTE*)&dwType, sizeof(DWORD), dwNewCRC);

    // Hash the data
    // =============

    dwNewCRC = UpdateCRC32(pBuffer, dwSize, dwNewCRC);

    delete [] pBuffer;

    return S_OK;
}

HRESULT CRegCRC::ComputeKeyValuesCRC(HKEY hKey, DWORD dwPrevCRC, 
                                     DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Get maximum value length
    // ========================

    DWORD dwNumValues, dwMaxValueLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                                &dwNumValues, &dwMaxValueLen, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the values
    // ========================

    for(DWORD dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxValueLen + 1];
        DWORD dwLen = dwMaxValueLen + 1;
        long lRes = RegEnumValue(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);

        // Hash the value
        // ==============

        ComputeValueCRC(hKey, szName, dwNewCRC, dwNewCRC);
        delete [] szName;
    }

    return S_OK;
}

HRESULT CRegCRC::ComputeKeyCRC(HKEY hKey, DWORD dwPrevCRC, 
                                     DWORD& dwNewCRC)
{
    HRESULT hres = ComputeKeyValuesCRC(hKey, dwPrevCRC, dwNewCRC);

    // Get maximum subkey length
    // =========================

    DWORD dwNumKeys, dwMaxKeyLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, 
                                &dwMaxKeyLen, NULL, NULL,
                                NULL, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the subkeys
    // =========================

    for(DWORD dwIndex = 0; dwIndex < dwNumKeys; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxKeyLen + 1];
        DWORD dwLen = dwMaxKeyLen + 1;
        long lRes = RegEnumKeyEx(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);
        delete [] szName;
    }

    return S_OK;
}

HRESULT CRegCRC::ComputeTreeCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Compute this key's CRC
    // ======================

    HRESULT hres = ComputeKeyValuesCRC(hKey, dwNewCRC, dwNewCRC);
    if(FAILED(hres)) return hres;

    // Get maximum subkey length
    // =========================

    DWORD dwNumKeys, dwMaxKeyLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, 
                                &dwMaxKeyLen, NULL, NULL,
                                NULL, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the subkeys
    // =========================

    for(DWORD dwIndex = 0; dwIndex < dwNumKeys; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxKeyLen + 1];
        DWORD dwLen = dwMaxKeyLen + 1;
        long lRes = RegEnumKeyEx(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);

        // Open the subkey
        // ===============

        HKEY hChild;
        lRes = RegOpenKeyEx(hKey, szName, 0, KEY_READ, &hChild);
        delete [] szName; 

        if(lRes)
        {
            continue;
        }
        else
        {
            // Hash the value
            // ==============
    
            ComputeTreeCRC(hChild, dwNewCRC, dwNewCRC);
            RegCloseKey(hChild);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regcrc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGCRC.H

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <crc32.h>

class CRegCRC
{
public:
    static HRESULT ComputeValueCRC(HKEY hKey, LPCTSTR szValueName, 
                                    DWORD dwPrevCRC, DWORD& dwNewCRC);
    static HRESULT ComputeKeyValuesCRC(HKEY hKey, DWORD dwPrevCRC, 
                                       DWORD& dwNewCRC);
    static HRESULT ComputeKeyCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC);
    static HRESULT ComputeTreeCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regeprov.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEPROV.H

Abstract:

History:

--*/

#ifndef __WBEM_REG_EVENT_PROVIDER__H_
#define __WBEM_REG_EVENT_PROVIDER__H_

#include <windows.h>
#include <wbemidl.h>
#include <stdio.h>
#include "regereq.h"
#include <ql.h>
#include "cfdyn.h"

class CRegEventProvider : public IWbemEventProvider, 
                            public IWbemEventProviderQuerySink,
                            public IWbemEventProviderSecurity,
                            public IWbemProviderInit
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Initialize)(LPWSTR wszUser, long lFlags, LPWSTR wszNamespace,
        LPWSTR wszLocale, IWbemServices* pNamespace, IWbemContext* pCtx,
        IWbemProviderInitSink* pSink);
    STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);

    STDMETHOD(NewQuery)(DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery);
    STDMETHOD(CancelQuery)(DWORD dwId);
    STDMETHOD(AccessCheck)(WBEM_CWSTR wszLanguage, WBEM_CWSTR wszQuery, 
                                long lSidLength, const BYTE* aSid);

	static VOID CALLBACK EnqueueEvent(PVOID lpParameter,        
										BOOLEAN TimerOrWaitFired);

	void EnqueueEvent(CRegistryEventRequest *pReq);

protected:
    long m_lRef;

    IWbemClassObject* m_pKeyClass;
    IWbemClassObject* m_pValueClass;
    IWbemClassObject* m_pTreeClass;

    DWORD m_dwId;
    HANDLE m_hThread;
    IWbemObjectSink* m_pSink;

    CRefedPointerArray<CRegistryEventRequest> m_apRequests;
    CRITICAL_SECTION m_cs;

	HANDLE m_hQueueSemaphore;
	CRITICAL_SECTION m_csQueueLock;
	CRefedPointerQueue<CRegistryEventRequest> m_qEventQueue;
	//CPointerQueue<CRegistryEventRequest,CReferenceManager<CRegistryEventRequest> > m_qEventQueue;
protected:
    static DWORD Worker(void* p);
    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}

    HRESULT GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CWStringArray& awsVals);
    HKEY TranslateHiveName(LPCWSTR wszName);
    HRESULT AddRequest(CRegistryEventRequest* pNewReq);
	void KillWorker();
	void CreateWorker();

    friend class CRegistryEventRequest;
    friend class CRegistryKeyEventRequest;
    friend class CRegistryValueEventRequest;
    friend class CRegistryTreeEventRequest;
    
public:
    CRegEventProvider();
    ~CRegEventProvider();

    void* GetInterface(REFIID riid);

    HRESULT SetTimerInstruction(CTimerInstruction* pInst);
    HRESULT RemoveTimerInstructions(CRegistryInstructionTest* pTest);
    HRESULT RaiseEvent(IWbemClassObject* pEvent);
};

extern const CLSID CLSID_RegistryEventProvider;

class CRegEventProviderFactory : public CCFDyn
{
public:
    IUnknown* CreateImpObj();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regeprov.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEPROV.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <stdio.h>
#include "cfdyn.h"
#include "stdprov.h"
#include "regeprov.h"
#include <sync.h>
#include <tss.h>
#include <genutils.h>
#include <analyser.h>
#include <cominit.h>
#include <GroupsForUser.h>


template <class T>
class CLockUnlock
{
private:
	T *m_pObj;
public:
	CLockUnlock(T *pObj) : m_pObj(pObj) { if(pObj) pObj->Lock(); }
	~CLockUnlock() { if(m_pObj) m_pObj->Unlock(); }
};

CRegEventProvider::CRegEventProvider()
    : m_lRef(0), m_hThread(NULL), m_dwId(NULL),
    m_pKeyClass(NULL), m_pValueClass(NULL), m_pTreeClass(NULL), m_pSink(NULL)
{
    InitializeCriticalSection(&m_cs);
	InitializeCriticalSection(&m_csQueueLock);
	m_hQueueSemaphore = CreateSemaphore(NULL,		// lpSemaphoreAttributes
										0,			// lInitialCount
										0x7fffffff,	// lMaximumCount
										NULL);		// lpName

}

CRegEventProvider::~CRegEventProvider()
{
    if(m_pSink)
        m_pSink->Release();
    if(m_pKeyClass)
        m_pKeyClass->Release();
    if(m_pValueClass)
        m_pValueClass->Release();
    if(m_pTreeClass)
        m_pTreeClass->Release();

    DeleteCriticalSection(&m_cs);
	DeleteCriticalSection(&m_csQueueLock);
    InterlockedDecrement(&lObj);
    if (m_hThread) CloseHandle(m_hThread);
	if (m_hQueueSemaphore) CloseHandle(m_hQueueSemaphore);
}

STDMETHODIMP CRegEventProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IWbemEventProvider || riid == IID_IUnknown)
    {
        *ppv = (IWbemEventProvider*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemEventProviderQuerySink)
    {
        *ppv = (IWbemEventProviderQuerySink*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemEventProviderSecurity)
    {
        *ppv = (IWbemEventProviderSecurity*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CRegEventProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CRegEventProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
      {
        CInCritSec ics(&m_cs);
		    // deactivate all event requests

		    for(int i = 0; i < m_apRequests.GetSize(); i++)
		    {
			    CRegistryEventRequest* pReq = m_apRequests[i];

			    if(pReq) pReq->ForceDeactivate();
		    }

		    m_apRequests.RemoveAll();

        if(m_hThread) KillWorker();
      }

/*        *m_pbEnd = TRUE;
        m_lRef = 1;
        HANDLE hThread = m_hThread;
        CycleWorker();
        WaitForSingleObject(hThread, 5000);
*/
		  delete this;
    }

    return lRef;
}

STDMETHODIMP CRegEventProvider::Initialize(LPWSTR wszUser, 
											long lFlags, 
											LPWSTR wszNamespace,
											LPWSTR wszLocale, 
											IWbemServices* pNamespace, 
											IWbemContext* pCtx,
											IWbemProviderInitSink* pSink)
{
    HRESULT hres = pNamespace->GetObject(REG_KEY_EVENT_CLASS,// strObjectPath
											0,				// lFlags		
											pCtx,			// pCtx
											&m_pKeyClass,	// ppObject
											NULL);			// ppCallResult

    hres = pNamespace->GetObject(REG_VALUE_EVENT_CLASS, 
									0, 
									pCtx, 
                                    &m_pValueClass, 
									NULL);

    hres = pNamespace->GetObject(REG_TREE_EVENT_CLASS, 
									0, 
									pCtx, 
                                    &m_pTreeClass, 
									NULL);

    pSink->SetStatus(hres, 0);
    return hres;
}


STDMETHODIMP CRegEventProvider::ProvideEvents(IWbemObjectSink* pSink, 
											  long lFlags)
{
    m_pSink = pSink;
    pSink->AddRef();

    return S_OK;
}

HRESULT CRegEventProvider::AddRequest(CRegistryEventRequest* pNewReq)
{
	// This is only called after entering the critical section m_cs


	int nActiveRequests = m_apRequests.GetSize();

    // Search for a similar request
    // ============================

	// This will not change the number of active requests.
	// It will cause the request Id to be served by an existing
	// CRegistryEventRequest.

    for(int i = 0; i < nActiveRequests; i++)
    {
        CRegistryEventRequest* pReq = m_apRequests[i];
		
		// Only active requests are in the array.

        if(pReq->IsSameAs(pNewReq))
        {
            // Found it!
            // =========

            HRESULT hres = pReq->Reactivate(pNewReq->GetPrimaryId(), 
                                                pNewReq->GetMsWait());
            delete pNewReq;
            return hres;
        }
    }

    // Not found. Add it
    // =================

    HRESULT hres = pNewReq->Activate();
    if(SUCCEEDED(hres))
    {
        m_apRequests.Add(pNewReq);

		// If there were no active requests before this one was added
		// then we have to start up the worker thread.

		if ( nActiveRequests == 0 )
		{
			CreateWorker();
		}
    }
    return hres;
}
    

STDMETHODIMP CRegEventProvider::CancelQuery(DWORD dwId)
{
    CInCritSec ics(&m_cs);

	int nOriginalSize = m_apRequests.GetSize();

    // Remove all requests with this Id
    // ================================


    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CRegistryEventRequest* pReq = m_apRequests[i];

		// If Deactivate returns WBEM_S_FALSE then the request was not serving 
		// this id or it is still serving other ids so we leave it in the array.
		// If S_OK is returned then the request is no longer serving any ids
		// and it is marked as inactive and its resources are released. There
		// may still be references to it in the worker thread queue, but the 
		// worker thread will see that it is inactive and not fire the events.

		if (pReq->Deactivate(dwId) == S_OK)
		{
			m_apRequests.RemoveAt(i);
			--i;
		}
    }
        

	// If we have cancelled the last subscription then kill the worker thread.

	if (nOriginalSize > 0 && m_apRequests.GetSize() == 0)
	{
		if(m_hThread) KillWorker();
	}

    return WBEM_S_NO_ERROR;
}

void CRegEventProvider::CreateWorker()
{
	// This is only called while in m_cs

	m_hThread = CreateThread(NULL,		// lpThreadAttributes
							0,			// dwStackSize
		(LPTHREAD_START_ROUTINE)&CRegEventProvider::Worker, // lpStartAddress
							this,		// lpParameter
							0,			// dwCreationFlags
							&m_dwId);	// lpThreadId
}

void CRegEventProvider::KillWorker()
{
	// When this is called the following is true:

	// All waits have been unregistered .
	// All thread pool requests have been processed.
	// All CRegistryEventRequests in the queue are inactive.
	// m_cs has been entered.

	// Therefore no other threads will:

	// Place events in the queue.
	// Modify CRegistryEventRequests in the queue.
	// Create or destroy a worker thread.

	// So the worker thread will empty the queue of the remaining
	// inactive CRegistryEventRequests and then retrieve the null
	// event and return.

	EnqueueEvent((CRegistryEventRequest*)0);

	WaitForSingleObject(m_hThread,		//	hHandle
						INFINITE);		// dwMilliseconds

	CloseHandle(m_hThread);
	m_hThread = 0;
	m_dwId = 0;
}

HRESULT CRegEventProvider::GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
											CPropertyName& PropName, 
											CWStringArray& awsVals)
{
    awsVals.Empty();

    // Get the necessary query
    // =======================

    QL_LEVEL_1_RPN_EXPRESSION* pPropExpr = NULL;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, 
                            PropName, pPropExpr);
    if(FAILED(hres))
    {
        return hres;
    }

    if(pPropExpr == NULL)
    	return WBEM_E_FAILED;
    
    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        if(Token.nTokenType == QL1_NOT)
        {
            delete pPropExpr;
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
        else if(Token.nTokenType == QL1_AND || Token.nTokenType == QL1_OR)
        {
            // We treat them all as ORs
            // ========================
        }
        else    
        {
            // This is a token
            // ===============

            if(Token.nOperator != QL1_OPERATOR_EQUALS)
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }

            if(V_VT(&Token.vConstValue) != VT_BSTR)
            {
                delete pPropExpr;
                return WBEM_E_INVALID_QUERY;
            }

            // This token is a string equality. Add the string to the list
            // ===========================================================

            awsVals.Add(V_BSTR(&Token.vConstValue));
        }
    }

    delete pPropExpr;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegEventProvider::SetTimerInstruction(CTimerInstruction* pInst)
{
    //return m_pGenerator->Set(pInst, CWbemTime::GetZero());
	return S_OK;
}

HRESULT CRegEventProvider::RemoveTimerInstructions(
                                        CRegistryInstructionTest* pTest)
{
    //return m_pGenerator->Remove(pTest);
	return S_OK;
}

HRESULT CRegEventProvider::RaiseEvent(IWbemClassObject* pEvent)
{
    if(m_pSink)
        return m_pSink->Indicate(1, &pEvent);
    else
        return WBEM_S_NO_ERROR;
}

HKEY CRegEventProvider::TranslateHiveName(LPCWSTR wszName)
{
    if(!_wcsicmp(wszName, L"HKEY_CLASSES_ROOT"))
        return HKEY_CLASSES_ROOT;
/* Disallowed: different semantics for client and server
    else if(!_wcsicmp(wszName, L"HKEY_CURRENT_USER"))
        return HKEY_CURRENT_USER;
*/
    else if(!_wcsicmp(wszName, L"HKEY_LOCAL_MACHINE"))
        return HKEY_LOCAL_MACHINE;
    else if(!_wcsicmp(wszName, L"HKEY_USERS"))
        return HKEY_USERS;
    else if(!_wcsicmp(wszName, L"HKEY_PERFORMANCE_DATA"))
        return HKEY_PERFORMANCE_DATA;
    else if(!_wcsicmp(wszName, L"HKEY_CURRENT_CONFIG"))
        return HKEY_CURRENT_CONFIG;
    else if(!_wcsicmp(wszName, L"HKEY_DYN_DATA"))
        return HKEY_DYN_DATA;
    else
        return NULL;
}

DWORD CRegEventProvider::Worker(void* p)
{
	CoInitializeEx(0,COINIT_MULTITHREADED);

    CRegEventProvider* pThis = (CRegEventProvider*)p;

	while(true)
    {
		WaitForSingleObject(pThis->m_hQueueSemaphore,	// hHandle
							INFINITE);					// dwMilliseconds

		CRegistryEventRequest *pReq = 0;

		{
			CInCritSec ics(&(pThis->m_csQueueLock));
			pReq = pThis->m_qEventQueue.Dequeue();
		}

		// If pReq is null then it is a signal for the thread to terminate.

		if (pReq)
		{
			pReq->ProcessEvent();

			// Dequeueing the request doesn't release it.
			// If it did then it might be deleted before we had a chance to use it.
			// Now we are done with it.

			pReq->Release();
		}
		else
		{
			break;
		}
    }

	CoUninitialize();

    return 0;
}

void CRegEventProvider::EnqueueEvent(CRegistryEventRequest *pReq)
{
	{
		CInCritSec ics(&m_csQueueLock);

		// Placing the request in the queue AddRefs it.
		
		m_qEventQueue.Enqueue(pReq);
	}

	// Tell the worker thread that there is an item to process in the queue.

	ReleaseSemaphore(m_hQueueSemaphore,	// hSemaphore
					1,					// lReleaseCount
					NULL);				// lpPreviousCount

}

VOID CALLBACK CRegEventProvider::EnqueueEvent(PVOID lpParameter,        
												BOOLEAN TimerOrWaitFired)
{
	CRegistryEventRequest *pReq = (CRegistryEventRequest*) lpParameter;
	CRegEventProvider *pProv = pReq->GetProvider();

	pProv->EnqueueEvent(pReq);
}

const CLSID CLSID_RegistryEventProvider = 
    {0xfa77a74e,0xe109,0x11d0,{0xad,0x6e,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

IUnknown* CRegEventProviderFactory::CreateImpObj()
{
    return (IWbemEventProvider*) new CRegEventProvider;
}

STDMETHODIMP CRegEventProvider::NewQuery(DWORD dwId, 
										WBEM_WSTR wszLanguage, 
										WBEM_WSTR wszQuery)
{
    HRESULT hres;

	CancelQuery(dwId);
    
    // Parse the query
    // ===============

    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    
    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    if(Parser.Parse(&pExpr))
    {
        return WBEM_E_INVALID_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    // Check the class
    // ===============

    int nEventType;
    if(!_wcsicmp(pExpr->bsClassName, REG_VALUE_EVENT_CLASS))
    {
        nEventType = e_RegValueChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_KEY_EVENT_CLASS))
    {   
        nEventType = e_RegKeyChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_TREE_EVENT_CLASS))
    {
        nEventType = e_RegTreeChange;
    }
    else
    {
        // No such class
        // =============

        return WBEM_E_INVALID_QUERY;
    }

    // Check tolerance on Win95
    // ========================

    if(!IsNT() && pExpr->Tolerance.m_bExact)
    {
        return WBEMESS_E_REGISTRATION_TOO_PRECISE;
    }

    // Extract the values of hive from the query
    // =========================================

    CPropertyName Name;

    Name.AddElement(REG_HIVE_PROPERTY_NAME);
    CWStringArray awsHiveVals;

    hres = GetValuesForProp(pExpr, Name, awsHiveVals);
    if(FAILED(hres)) return hres;

    // Translate them to real hives
    // ============================

    CUniquePointerArray<HKEY> aHives;
    for(int i = 0; i < awsHiveVals.Size(); i++)
    {
        HKEY hHive = TranslateHiveName(awsHiveVals[i]);
        if(hHive == NULL)
        {
            return WBEM_E_INVALID_QUERY;
        }
        
        aHives.Add(new HKEY(hHive));
    }
        
    // Extract the values of key from the query
    // ========================================

    Name.Empty();
    if(nEventType == e_RegTreeChange)
    {
        Name.AddElement(REG_ROOT_PROPERTY_NAME);
    }
    else
    {
        Name.AddElement(REG_KEY_PROPERTY_NAME);
    }

    CWStringArray awsKeyVals;
    hres = GetValuesForProp(pExpr, Name, awsKeyVals);
    if(FAILED(hres)) 
    {
        return hres;
    }
                                      
    CWStringArray awsValueVals;
    if(nEventType == e_RegValueChange)
    {
        // Extract the values for the value
        // ================================
            
        Name.Empty();
        Name.AddElement(REG_VALUE_PROPERTY_NAME);
    
        hres = GetValuesForProp(pExpr, Name, awsValueVals);
        if(FAILED(hres)) 
        {
            return hres;
        }
    }

    HRESULT hresGlobal = WBEM_E_INVALID_QUERY;

    {
        CInCritSec ics(&m_cs); // do this in a critical section

        // Go through every combination of the above and create requests
        // =============================================================
    
        for(int nHiveIndex = 0; nHiveIndex < aHives.GetSize(); nHiveIndex++)
        {
            HKEY hHive = *aHives[nHiveIndex];
            LPWSTR wszHive = awsHiveVals[nHiveIndex];
            
            for(int nKeyIndex = 0; nKeyIndex < awsKeyVals.Size(); nKeyIndex++)
            {
                LPWSTR wszKey = awsKeyVals[nKeyIndex];
    
                if(nEventType == e_RegValueChange)
                {
                    for(int nValueIndex = 0; nValueIndex < awsValueVals.Size();
                            nValueIndex++)
                    {
                        LPWSTR wszValue = awsValueVals[nValueIndex];
        
                        CRegistryEventRequest* pReq = 
                            new CRegistryValueEventRequest(this, 
                                pExpr->Tolerance,
                                dwId, hHive, wszHive, wszKey, wszValue);
    
                        if(pReq->IsOK())
                        {
                            HRESULT hres = AddRequest(pReq);
                            if(SUCCEEDED(hres))
                                hresGlobal = hres;
                        }
                        else
                        {
                            DEBUGTRACE((LOG_ESS, "Invalid registration: key "
                                "%S, value %S\n", wszKey, wszValue));
                            delete pReq;
                        }
                    }
                }
                else
                {
                    // Value-less request
                    // ==================
    
                    CRegistryEventRequest* pReq;
                    if(nEventType == e_RegKeyChange)
                    {
                        pReq = new CRegistryKeyEventRequest(this, 
                                            pExpr->Tolerance,
                                            dwId, hHive, wszHive, wszKey);
                    }   
                    else
                    {
                        pReq = new CRegistryTreeEventRequest(this, 
                                            pExpr->Tolerance,
                                            dwId, hHive, wszHive, wszKey);
                    }   
                    
                    if(pReq->IsOK())
                    {
                        hres = AddRequest(pReq);
                        if(SUCCEEDED(hres))
                            hresGlobal = hres;
                    }
                    else
                    {
                        DEBUGTRACE((LOG_ESS, "Invalid registration: key %S\n", 
                                            wszKey));
                        delete pReq;
                    }
                }
            }
        }

    } // out of critical section

    return hresGlobal;
}

STDMETHODIMP CRegEventProvider::AccessCheck(WBEM_CWSTR wszLanguage, 
											WBEM_CWSTR wszQuery, 
											long lSidLength,
											const BYTE* aSid)
{
    HRESULT hres;

    PSID pSid = (PSID)aSid;
    HANDLE hToken = NULL;
    if(pSid == NULL)
    {
        //
        // Access check based on the thread
        //

        hres = WbemCoImpersonateClient();
        if(FAILED(hres))
            return hres;
        
        BOOL bRes = OpenThreadToken(GetCurrentThread(),	// ThreadHandle
									TOKEN_READ,			// DesiredAccess
									TRUE,				// OpenAsSelf
                                    &hToken);			// TokenHandle
        WbemCoRevertToSelf();
        if(!bRes)
        {
            return WBEM_E_ACCESS_DENIED;
        }    
    }
    CCloseMe cm1(hToken);
        
    // Parse the query
    // ===============

    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    
    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    if(Parser.Parse(&pExpr))
    {
        return WBEM_E_INVALID_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    // Check the class
    // ===============

    int nEventType;
    if(!_wcsicmp(pExpr->bsClassName, REG_VALUE_EVENT_CLASS))
    {
        nEventType = e_RegValueChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_KEY_EVENT_CLASS))
    {   
        nEventType = e_RegKeyChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_TREE_EVENT_CLASS))
    {
        nEventType = e_RegTreeChange;
    }
    else
    {
        // No such class
        // =============

        return WBEM_E_INVALID_QUERY;
    }

    // Extract the values of hive from the query
    // =========================================

    CPropertyName Name;

    Name.AddElement(REG_HIVE_PROPERTY_NAME);
    CWStringArray awsHiveVals;

    hres = GetValuesForProp(pExpr, Name, awsHiveVals);
    if(FAILED(hres)) return hres;

    // Translate them to real hives
    // ============================

    CUniquePointerArray<HKEY> aHives;
    for(int i = 0; i < awsHiveVals.Size(); i++)
    {
        HKEY hHive = TranslateHiveName(awsHiveVals[i]);
        if(hHive == NULL)
        {
            return WBEM_E_INVALID_QUERY;
        }
        
        aHives.Add(new HKEY(hHive));
    }
        
    // Extract the values of key from the query
    // ========================================

    Name.Empty();
    if(nEventType == e_RegTreeChange)
    {
        Name.AddElement(REG_ROOT_PROPERTY_NAME);
    }
    else
    {
        Name.AddElement(REG_KEY_PROPERTY_NAME);
    }

    CWStringArray awsKeyVals;
    hres = GetValuesForProp(pExpr, Name, awsKeyVals);
    if(FAILED(hres)) 
    {
        return hres;
    }
                                      
    HRESULT hresGlobal = WBEM_E_INVALID_QUERY;

    // Go through every combination of the above and create requests
    // =============================================================

    for(int nHiveIndex = 0; nHiveIndex < aHives.GetSize(); nHiveIndex++)
    {
        HKEY hHive = *aHives[nHiveIndex];
        LPWSTR wszHive = awsHiveVals[nHiveIndex];
        
        for(int nKeyIndex = 0; nKeyIndex < awsKeyVals.Size(); nKeyIndex++)
        {
            LPWSTR wszKey = awsKeyVals[nKeyIndex];
        
            // Get that key's security
            // =======================

            HKEY hKey;
            long lRes = RegOpenKeyExW(hHive,			// hKey
										wszKey,			// lpSubKey
										0,				// ulOptions
										READ_CONTROL,	// samDesired
										&hKey);			// phkResult
            if(lRes)
                return WBEM_E_NOT_FOUND;
            CRegCloseMe cm2(hKey);

            DWORD dwLen = 0;
            lRes = RegGetKeySecurity(hKey,			// hKey
							OWNER_SECURITY_INFORMATION | 
							GROUP_SECURITY_INFORMATION |
							DACL_SECURITY_INFORMATION,	// SecurityInformation
									NULL,			// pSecurityDescriptor
									&dwLen);		// lpcbSecurityDescriptor		

            if(lRes != ERROR_INSUFFICIENT_BUFFER)
                return WBEM_E_FAILED;

            PSECURITY_DESCRIPTOR pDesc = (PSECURITY_DESCRIPTOR)new BYTE[dwLen];
            if(pDesc == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CVectorDeleteMe<BYTE> vdm((BYTE*)pDesc);

            lRes = RegGetKeySecurity(hKey, 
							OWNER_SECURITY_INFORMATION | 
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
									pDesc,
									&dwLen);
            if(lRes)
                return WBEM_E_FAILED;

            //
            // Check permissions differently depending on whether we have a SID
            // or an actual token
            //
            
            if(pSid)
            {
                //
                // We have a SID --- walk the ACL
                //

                //
                // Extract the ACL
                // 

                PACL pAcl = NULL;
                BOOL bAclPresent, bAclDefaulted;
                if(!GetSecurityDescriptorDacl(pDesc,	// pSecurityDescriptor
											&bAclPresent,	// lpbDaclPresent
											&pAcl,			// pDacl
											&bAclDefaulted))// lpbDaclDefaulted
                {
                    return WBEM_E_FAILED;
                }
            
                if(bAclPresent)
                {
                    //
                    // This is our own ACL walker
                    //
    
                    DWORD dwAccessMask;
                    NTSTATUS st = GetAccessMask((PSID)pSid, pAcl, 
                                            &dwAccessMask);
                    if(st)
                    {
                        ERRORTRACE((LOG_ESS, "Registry event provider unable "
                            "to retrieve access mask for the creator of "
                            "registration %S: NT status %d.\n"
                            "Registration disabled\n", wszQuery));
                        return WBEM_E_FAILED;
                    }
    
                    if((dwAccessMask & KEY_NOTIFY) == 0)
                        return WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // 
                // We have a token --- use AccessCheck
                //

                //
                // Construct generic mapping for registry keys
                //

                GENERIC_MAPPING map;
                map.GenericRead = KEY_READ;
                map.GenericWrite = KEY_WRITE;
                map.GenericExecute = KEY_EXECUTE;
                map.GenericAll = KEY_ALL_ACCESS;

                //
                // Construct privilege array receptacle
                //

                PRIVILEGE_SET ps[10];
                DWORD dwSize = 10 * sizeof(PRIVILEGE_SET);

                DWORD dwGranted;
                BOOL bResult;

                BOOL bOK = ::AccessCheck(pDesc,		// pSecurityDescriptor
										hToken,		// ClientToken
										KEY_NOTIFY,	// DesiredAccess	
										&map,		// GenericMapping
										ps,			// PrivilegeSet
                                        &dwSize,	// PrivilegeSetLength
										&dwGranted,	// GrantedAccess
										&bResult);	// AccessStatus
                if(!bOK || !bResult)
                    return WBEM_E_ACCESS_DENIED;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regereq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEREQ.H

Abstract:

History:

--*/

#ifndef __WBEM_REGEVENT_REQUEST__H_
#define __WBEM_REGEVENT_REQUEST__H_

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include "CWbemTime.h"
#include <tss.h>
#include <ql.h>
#include <wbemcomn.h>
#include "regedefs.h"



class CRegEventProvider;
class CRegistryEventRequest;
class CRegistryTimerInstruction : public CTimerInstruction
{
    long m_lRef;

    CWbemInterval m_Interval;
    CRegistryEventRequest* m_pReq;

public:
    CRegistryTimerInstruction(CRegistryEventRequest* pReq);
    ~CRegistryTimerInstruction();

    void AddRef();
    void Release();
    int GetInstructionType() {return INSTTYPE_INTERNAL;}

    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const;
    CWbemTime GetFirstFiringTime() const;
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
    
    INTERNAL CRegistryEventRequest* GetRequest() {return m_pReq;}
};

class CRegistryInstructionTest : public CInstructionTest
{
    class CRegistryEventRequest* m_pReq;
public:
    CRegistryInstructionTest(CRegistryEventRequest* pReq) : m_pReq(pReq){}
    BOOL operator()(CTimerInstruction* pToTest);
};

class CRegistryEventRequest
{
protected:
    long m_lRef;
    BOOL m_bOK;

    CRegEventProvider* m_pProvider;
    DWORD m_dwMsWait;

    CFlexArray m_adwIds;

    HKEY m_hHive;
    WString m_wsHive;
    WString m_wsKey;

    HKEY m_hKey;
    HANDLE m_hEvent;
    DWORD m_dwLastCRC;
    long m_lActiveCount;
    BOOL m_bNew;

	HANDLE m_hWaitRegistration;
	CRITICAL_SECTION m_cs;

public:
    CRegistryEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, 
                          HKEY hHive, LPWSTR wszHive, LPWSTR wszKey);
    virtual ~CRegistryEventRequest();
    BOOL IsOK() {return m_bOK;}
    BOOL IsActive() {return m_lActiveCount >= 0;}
    DWORD GetPrimaryId();
    BOOL DoesContainId(DWORD dwId);
    BOOL IsNew() {return m_bNew;}
	CRegEventProvider* GetProvider() { return m_pProvider; }
    void AddRef();
    void Release();

    DWORD GetMsWait() {return m_dwMsWait;}

    HRESULT Activate();
    HRESULT Reactivate(DWORD dwId, DWORD dwMsWait);
    HRESULT Deactivate(DWORD dwId);
    HRESULT ForceDeactivate(void);
    virtual HRESULT Execute(BOOL bOnTimer);
    HANDLE GetOnChangeHandle();
    BOOL ResetOnChangeHandle();
    virtual void CacheValue(){}

    virtual int GetType() = 0;
    virtual HRESULT CreateNewEvent(IWbemClassObject** ppEvent) = 0;
    virtual HRESULT ComputeCRC(DWORD& dwCRC) = 0;

    virtual BOOL IsSameAs(CRegistryEventRequest* pOther);

	void ProcessEvent();

protected:
    HRESULT SetCommonProperties(IWbemClassObject* pEvent);
};


class CRegistryValueEventRequest : public CRegistryEventRequest
{
protected:

    WString m_wsValue;

public:
    CRegistryValueEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey, LPWSTR wszValue)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey), m_wsValue(wszValue)
    {}

    int GetType() {return e_RegValueChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
    virtual HRESULT Execute(BOOL bOnTimer);
    virtual void CacheValue();
    BOOL IsSameAs(CRegistryEventRequest* pOther);
};

class CRegistryKeyEventRequest : public CRegistryEventRequest
{
public:
    CRegistryKeyEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey)
    {}

    int GetType() {return e_RegKeyChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
};

class CRegistryTreeEventRequest : public CRegistryEventRequest
{
public:
    CRegistryTreeEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey)
    {}

    int GetType() {return e_RegTreeChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regereq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEREQ.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "regereq.h"
#include "regcrc.h"
#include <genutils.h>
#include "regeprov.h"

//******************************************************************************
//******************************************************************************
//
//                  TIMER INSTRUCTION
//
//******************************************************************************
//******************************************************************************

CRegistryTimerInstruction::CRegistryTimerInstruction(
                                            CRegistryEventRequest* pReq)
             : m_pReq(pReq), m_lRef(0)
{
    pReq->AddRef();
    m_Interval.SetMilliseconds(pReq->GetMsWait());
}
          
CRegistryTimerInstruction::~CRegistryTimerInstruction()
{
    m_pReq->Release();
}

void CRegistryTimerInstruction::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CRegistryTimerInstruction::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}

CWbemTime CRegistryTimerInstruction::GetNextFiringTime(CWbemTime LastFiringTime,
                                    OUT long* plFiringCount) const
{
    CWbemTime Next = LastFiringTime + m_Interval;
    if(Next < CWbemTime::GetCurrentTime())
    {
        return CWbemTime::GetCurrentTime() + m_Interval;
    }
    else
    {
        return Next;
    }
}

CWbemTime CRegistryTimerInstruction::GetFirstFiringTime() const
{
    return CWbemTime::GetCurrentTime() + m_Interval;
}

HRESULT CRegistryTimerInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    m_pReq->Execute(TRUE);
    return S_OK;
}

//******************************************************************************
//******************************************************************************
//
//                  TIMER INSTRUCTION
//
//******************************************************************************
//******************************************************************************

BOOL CRegistryInstructionTest::operator()(CTimerInstruction* pToTest)
{
    CRegistryTimerInstruction* pRegInst = (CRegistryTimerInstruction*)pToTest;
    return (pRegInst->GetRequest() == m_pReq);
}

//******************************************************************************
//******************************************************************************
//
//                      GENERIC REQUEST
//
//******************************************************************************
//******************************************************************************



CRegistryEventRequest::CRegistryEventRequest(CRegEventProvider* pProvider,
                                    WBEM_QL1_TOLERANCE& Tolerance, 
                                    DWORD dwId, HKEY hHive, LPWSTR wszHive,
                                    LPWSTR wszKey)
        : m_hHive(hHive), m_wsKey(wszKey), m_pProvider(pProvider),
            m_wsHive(wszHive), m_lActiveCount(0), m_bNew(TRUE),
            m_lRef(0), m_bOK(TRUE), m_dwLastCRC(0), m_hKey(NULL), m_hEvent(NULL),
			m_hWaitRegistration(NULL)
{
    if(Tolerance.m_bExact)
    {
        m_dwMsWait = 0;
    }
    else
    {
        m_dwMsWait = Tolerance.m_fTolerance * 1000;
    }

    if ( CFlexArray::no_error != m_adwIds.Add(ULongToPtr(dwId)) )
    {
        throw CX_MemoryException( );
    }
    
	InitializeCriticalSection(&m_cs);
}

CRegistryEventRequest::~CRegistryEventRequest()
{

	if (m_hKey)
	{
		RegCloseKey(m_hKey);
	}

    if(m_hEvent)
    {
        CloseHandle(m_hEvent);
    }

	DeleteCriticalSection(&m_cs);
}

void CRegistryEventRequest::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CRegistryEventRequest::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0) delete this;
}

BOOL CRegistryEventRequest::IsSameAs(CRegistryEventRequest* pOther)
{
    if(GetType() != pOther->GetType())
        return FALSE;

    if(m_hHive != pOther->m_hHive)
        return FALSE;

    if(!m_wsHive.EqualNoCase(pOther->m_wsHive))
        return FALSE;

    if(!m_wsKey.EqualNoCase(pOther->m_wsKey))
        return FALSE;

    return TRUE;
}


DWORD CRegistryEventRequest::GetPrimaryId()
{
    return PtrToLong(m_adwIds[0]);
}

BOOL CRegistryEventRequest::DoesContainId(DWORD dwId)
{
	// not called

    for(int i = 0; i < m_adwIds.Size(); i++)
    {
        if(PtrToLong(m_adwIds[i]) == dwId)
            return TRUE;
    }
    return FALSE;
}

HRESULT CRegistryEventRequest::Reactivate(DWORD dwId, DWORD dwMsWait)
{
	// This is only called on active objects.

	CInCritSec ics(&m_cs);

    if(m_dwMsWait > dwMsWait)
        m_dwMsWait = dwMsWait;

    m_adwIds.Add(ULongToPtr(dwId));

	InterlockedIncrement(&m_lActiveCount);

	return WBEM_S_NO_ERROR;
}

HRESULT CRegistryEventRequest::Activate()
{
	// This function doesn't need to enter a critical section
	// for the reasons explained in the following argument. 
	// This reasoning might be invalidated by design changes.

	// This is only called on new objects before they are added
	// to the active request array.

	// Since all the independent COM client threads get access 
	// to these objects through that array, this object is locked to
	// all threads but the current one.

	// Once RegisterWaitForSingleObject is called this object is registered
	// with the thread pool but it won't be accessed because no events will
	// occur until ResetOnChangeHandle is called by the worker thread.
	
	// When m_pProvider->EnqueueEvent(this) is called then the worker thread
	// has access to the object. At this point there is nothing left to do 
	// but return.



    // Open the key
    // ============

#ifdef UNICODE
    long lRes = RegOpenKeyEx(m_hHive, m_wsKey, 0, KEY_READ, &m_hKey);
#else
    LPSTR szName = m_wsKey.GetLPSTR();
    long lRes = RegOpenKeyEx(m_hHive, szName, 0, KEY_READ, &m_hKey);
    delete [] szName;
#endif

    if(lRes)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Create an event
    // ===============

    m_hEvent = CreateEvent(NULL,	// lpEventAttributes
							FALSE,	// bManualReset
							FALSE,	// bInitialState
							NULL);	// lpName

	RegisterWaitForSingleObject(
							&m_hWaitRegistration,	// phNewWaitObject
							m_hEvent,				// hObject
							CRegEventProvider::EnqueueEvent, // Callback
							this,					// Context
							INFINITE,				// dwMilliseconds
							WT_EXECUTEINWAITTHREAD);// dwFlags

	// This represents the thread pool's reference.

	AddRef();

    // It will be connected to the key by the worker thread
	// because when the thread that calls RegNotifyChangeKeyValue
	// exits the event is signaled. Therefore if this thread called
	// RegNotifyChangeKeyValue then we would get a spurious event when
	// this thread exits. When the worker thread exits all the event
	// subscriptions will have already been cancelled.
    // ==========================================================

    m_bNew = TRUE;

    CacheValue();

	m_pProvider->EnqueueEvent(this);

    return S_OK;
}

BOOL CRegistryEventRequest::ResetOnChangeHandle()
{
	// This is only called from ProcessEvent which has already
	// acquired the lock.

    m_bNew = FALSE;

    long lRes = RegNotifyChangeKeyValue(
							m_hKey,							// hKey
							(GetType() == e_RegTreeChange), // bWatchSubtree
							REG_NOTIFY_CHANGE_NAME | 
							REG_NOTIFY_CHANGE_LAST_SET | 
							REG_NOTIFY_CHANGE_ATTRIBUTES,	// dwNotifyFilter
							m_hEvent,						// hEvent
							TRUE);							// fAsynchronous
    return (lRes == 0);
}

HANDLE CRegistryEventRequest::GetOnChangeHandle() 
{
	// not called

    return m_hEvent;
}

HRESULT CRegistryEventRequest::Deactivate(DWORD dwId)
{
	CInCritSec ics(&m_cs);

    // Remove the ID from the list
    // ===========================

	bool bFoundId = false;
	int nIdCount = m_adwIds.Size();

    for(int i = 0; i < nIdCount; i++)
    {
        if(PtrToLong(m_adwIds[i]) == dwId)
        {
            m_adwIds.RemoveAt(i);
			bFoundId = true;
			break;
        }
    }

    if(!bFoundId || (InterlockedDecrement(&m_lActiveCount) >= 0))
        return WBEM_S_FALSE;

	// Unregister the event with the thread pool and wait for
	// pending requests to be processed.

	// We wait because this object could be released and deleted when this
	// function returns which would mean the thread pool holds an invalid
	// pointer.

	// When the thread pool processes a request it places it in the worker thread
	// queue which AddRefs the request.

	UnregisterWaitEx(m_hWaitRegistration,		// WaitHandle
						INVALID_HANDLE_VALUE);	// CompletionEvent

	m_hWaitRegistration = NULL;

	// This will signal m_hEvent but we just unregistered it
	// so nobody is waiting on it.

	RegCloseKey(m_hKey);
	m_hKey = 0;

	CloseHandle(m_hEvent);
	m_hEvent = 0;

	// The thread pool no longer holds a reference 
	// so call Release on its behalf.

	Release();

    return S_OK;
}

HRESULT CRegistryEventRequest::ForceDeactivate(void)
{
    CInCritSec ics(&m_cs);

	// deactivate the event request

    InterlockedExchange(&m_lActiveCount, -1);

    // Remove all IDs from the list

    int nIdCount = m_adwIds.Size();

	m_adwIds.Empty();

    // Unregister the event with the thread pool and wait for
    // pending requests to be processed.

    // We wait because this object could be released and deleted when this
    // function returns which would mean the thread pool holds an invalid
    // pointer.

    // When the thread pool processes a request it places it in the worker thread
    // queue which AddRefs the request.

    UnregisterWaitEx(m_hWaitRegistration,       // WaitHandle
                        INVALID_HANDLE_VALUE);  // CompletionEvent

    m_hWaitRegistration = NULL;

    // This will signal m_hEvent but we just unregistered it
    // so nobody is waiting on it.

    RegCloseKey(m_hKey);
    m_hKey = 0;

    CloseHandle(m_hEvent);
    m_hEvent = 0;

    // The thread pool no longer holds a reference
    // so call Release on its behalf.

    Release();

    return S_OK;
}

HRESULT CRegistryEventRequest::Execute(BOOL bOnTimer)
{
    // If called by the timer, we need to check if anything actually changed
    // =====================================================================

    if(bOnTimer || GetType() == e_RegValueChange)
    {
        DWORD dwNewCRC;
        HRESULT hres = ComputeCRC(dwNewCRC);
        if(FAILED(hres))
        {
            return hres;
        }
        if(dwNewCRC == m_dwLastCRC)
        {
            // No real change. Return
            // ======================

            return S_FALSE;
        }

        m_dwLastCRC = dwNewCRC;
    }

    // If here, a real change has occurred
    // ===================================

    IWbemClassObject* pEvent;

    HRESULT hres = CreateNewEvent(&pEvent);
    if(FAILED(hres))
    {
        return hres;
    }

    hres = m_pProvider->RaiseEvent(pEvent);
    pEvent->Release();
    return hres;
}

HRESULT CRegistryEventRequest::SetCommonProperties(IWbemClassObject* pEvent)
{
    // Set the hive name
    // =================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsHive);
    pEvent->Put(REG_HIVE_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    return WBEM_S_NO_ERROR;
}

void CRegistryEventRequest::ProcessEvent()
{
	CInCritSec ics(&m_cs);

	if(IsActive())
    {
		// New requests are immediately queued in order for the worker
		// thread to initialize them. They don't represent actual events.

		// We need to save the new status because ResetOnChangeHandle 
		// erases it.

		BOOL bIsNew = IsNew();
		
        ResetOnChangeHandle();

		if (!bIsNew)
		{
			Execute(FALSE);
		}
    }
}

//******************************************************************************
//******************************************************************************
//
//                          VALUE REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryValueEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    m_pProvider->m_pValueClass->SpawnInstance(0, &pEvent);

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the key
    // ===========

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_KEY_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    // Set the value
    // =============

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsValue);
    pEvent->Put(REG_VALUE_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryValueEventRequest::ComputeCRC(DWORD& dwCRC)
{
#ifdef UNICODE
    HRESULT hres = CRegCRC::ComputeValueCRC(m_hKey, m_wsValue, 
                        STARTING_CRC32_VALUE, dwCRC);
#else
    LPSTR szValue = m_wsValue.GetLPSTR();
    HRESULT hres = CRegCRC::ComputeValueCRC(m_hKey, szValue, 
                        STARTING_CRC32_VALUE, dwCRC);
    delete [] szValue;
#endif
    return hres;
}

HRESULT CRegistryValueEventRequest::Execute(BOOL bOnTimer)
{
    // Since NT does not allow per-value change registration, CRC needs to be
    // computed no matter what
    // ======================================================================

    return CRegistryEventRequest::Execute(TRUE);
}

void CRegistryValueEventRequest::CacheValue()
{
    ComputeCRC(m_dwLastCRC);
}

BOOL CRegistryValueEventRequest::IsSameAs(CRegistryEventRequest* pOther)
{
    if(!CRegistryEventRequest::IsSameAs(pOther))
        return FALSE;

    CRegistryValueEventRequest* pValueOther = 
        (CRegistryValueEventRequest*)pOther;

    if(!m_wsValue.EqualNoCase(pValueOther->m_wsValue))
        return FALSE;

    return TRUE;
}

    
//******************************************************************************
//******************************************************************************
//
//                          KEY REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryKeyEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    m_pProvider->m_pKeyClass->SpawnInstance(0, &pEvent);

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the key
    // ===========

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_KEY_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryKeyEventRequest::ComputeCRC(DWORD& dwCRC)
{
    HRESULT hres = CRegCRC::ComputeKeyCRC(m_hKey, STARTING_CRC32_VALUE, dwCRC);
    return hres;
}
    
//******************************************************************************
//******************************************************************************
//
//                          TREE REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryTreeEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    m_pProvider->m_pTreeClass->SpawnInstance(0, &pEvent);

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the root
    // ============

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_ROOT_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryTreeEventRequest::ComputeCRC(DWORD& dwCRC)
{
    HRESULT hres = CRegCRC::ComputeTreeCRC(m_hKey, STARTING_CRC32_VALUE, dwCRC);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    REGEVENT.CPP

Abstract:

	Declares the CRegEvent class

History:

	a-davj    1-July-97       Created.

--*/

#include "precomp.h"
#include "node.h"
#include "eventreg.h"
#include <impdyn.h>
#include "regevent.h"

CRegEventSet gSet;

struct BaseTypes2 
{
    LPTSTR lpName;
    HKEY hKey;
} Bases2[] = 
    {
       {TEXT("HKEY_CLASSES_ROOT") , HKEY_CLASSES_ROOT},
       {TEXT("HKEY_CURRENT_USER") , HKEY_CURRENT_USER},
       {TEXT("HKEY_LOCAL_MACHINE") ,  HKEY_LOCAL_MACHINE},
       {TEXT("HKEY_USERS") ,  HKEY_USERS},
       {TEXT("HKEY_PERFORMANCE_DATA") ,  HKEY_PERFORMANCE_DATA},
       {TEXT("HKEY_CURRENT_CONFIG") ,  HKEY_CURRENT_CONFIG},
       {TEXT("HKEY_DYN_DATA") ,  HKEY_DYN_DATA}};


DWORD AddToCheckSub(DWORD & dwNewCheckSum, void * pData, DWORD dwDataSize)
{
    return 0;
}

void CRegEvent::TimerCheck()
{

    DWORD dwError;
    CNode * pNewHiveImage = NULL;

	// todo, need some sort of mutex so as not to reenter this.  Also need to create
	// a thread to do this!!!!

	DWORD dwNewCheckSum = 0;
    HKEY hSubKey = NULL;

    // Open the root key

    TCHAR * pSt = m_sRegPath;
    TCHAR * pAfter = NULL;
    HKEY hBase = NULL;
    int iSlash = m_sRegPath.Find('\\');
    if(iSlash < 0)
    {
        return;
    }

    pSt[iSlash] = 0;
    pAfter = pSt + iSlash + 1;

    for(int iCnt = 0; iCnt < sizeof(Bases2) / sizeof(struct BaseTypes2 ); iCnt++)
        if(!lstrcmpi(Bases2[iCnt].lpName, pSt))
        {
            hBase = Bases2[iCnt].hKey;
            break;
        }

    if(hBase == NULL)
    {
        return;     //todo, bitch
    }
    
    long lRes = RegOpenKeyEx(hBase, pAfter, 0, KEY_READ, &hSubKey);
    if(lRes != 0)
    {
        dwError = GetLastError();
        return; //todo, bitch
    }

    if(m_bSaveHiveImage)
        pNewHiveImage = new CNode;

    CalcHive(hSubKey, dwNewCheckSum);
    RegCloseKey(hSubKey);

    if(dwNewCheckSum != m_dwCheckSum)
    {
        //todo, send event
        m_dwCheckSum = dwNewCheckSum;
    }

    if(m_bSaveHiveImage)
    {
        if(m_pLastHiveImage)
        {
            m_pLastHiveImage->CompareAndReportDiffs(pNewHiveImage);
            {
            
            }


            delete m_pLastHiveImage;
        }
        
        m_pLastHiveImage = pNewHiveImage;
    }
}

DWORD CRegEvent::CalcHive(HKEY hKey,DWORD & dwNewCheckSum)
{

    long lRes;
    DWORD dwRet = 0;
    TCHAR * pSubKeyName = NULL;
    TCHAR * pValueName = NULL;
    BYTE * pValue = NULL;
    DWORD dwError;

    // Get the general info on the directory.

    DWORD dwSubKeys, dwMaxSubKeyLen, dwValues, dwMaxValueNameLen, dwMaxValueLen;

    lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwSubKeys, &dwMaxSubKeyLen, NULL, 
                        &dwValues, &dwMaxValueNameLen, &dwMaxValueLen, NULL, NULL);
    if(lRes != ERROR_SUCCESS)
    {
        DWORD dwRet = GetLastError();
        goto CalcHiveCleanup;
    }

    // Allocate space to hold the various names and data

    pValueName = new TCHAR[dwMaxValueNameLen+1];
    if(dwMaxValueLen > 0)
        pValue = new BYTE[dwMaxValueLen];
    
    if(pValueName == NULL || (dwMaxValueLen > 0 &&pValue == NULL))
    {
        dwRet = WBEM_E_OUT_OF_MEMORY;
        goto CalcHiveCleanup;
    }

    // Enumerate each value, add the name, type, and data to the check sum

    DWORD dwCnt;
    for(dwCnt = 0; dwCnt < dwValues ; dwCnt++)
    {
        DWORD dwTempNameSize = dwMaxValueNameLen+1;
        DWORD dwType;
        DWORD dwTempDataSize = dwMaxValueLen;

        lRes = RegEnumValue(hKey, dwCnt, pValueName, &dwTempNameSize, 0, &dwType,
                                pValue, &dwTempDataSize);
        if(lRes != ERROR_SUCCESS)
        {
            DWORD dwRet = GetLastError();
            goto CalcHiveCleanup;
        }
        AddToCheckSub(dwNewCheckSum, pValueName, dwTempNameSize);
        AddToCheckSub(dwNewCheckSum, &dwType, sizeof(DWORD));
        AddToCheckSub(dwNewCheckSum, pValue, dwTempNameSize);
    }
    
    // Free up the memory which is no longer needed

    if(pValueName)
        delete pValueName;
    pValueName = NULL;
    if(pValue)
        delete pValue;
    pValue = NULL;

    // Enumerate the subkeys and calculate them

    pSubKeyName = new TCHAR[dwMaxSubKeyLen+1];

    for(dwCnt = 0; dwCnt < dwSubKeys ; dwCnt++)
    {
        lRes = RegEnumKey(hKey, dwCnt, pSubKeyName, dwMaxSubKeyLen+1);
        if(lRes != ERROR_SUCCESS)
        {
            DWORD dwRet = GetLastError();
            goto CalcHiveCleanup;
        }

        // Add the name to the check sum, open the key and call this recursively

        AddToCheckSub(dwNewCheckSum, pSubKeyName, lstrlen(pSubKeyName));
        HKEY hSubKey = NULL;
        long lRes = RegOpenKeyEx(hKey, pSubKeyName, 0, KEY_READ, &hSubKey);
        if(lRes != 0)
        {
            dwError = GetLastError();
            return dwError; //todo, bitch
        }

        CalcHive(hSubKey, dwNewCheckSum);
        RegCloseKey(hSubKey);
    }
CalcHiveCleanup:

    if(pSubKeyName)
        delete pSubKeyName;
    if(pValueName)
        delete pValueName;
    if(pValue)
        delete pValue;
    return dwRet;
}

SCODE MyCreateInstance(IWbemServices * pGateway, WCHAR * pwcClass, WCHAR * pwcKeyName,
				WCHAR * pwcKeyValue, IWbemClassObject ** ppNewInst)
{
    SCODE sc;

	if(pGateway == NULL || pwcClass == NULL || pwcKeyName == NULL ||
		pwcKeyValue == NULL || ppNewInst == NULL)
			return WBEM_E_INVALID_PARAMETER;

    *ppNewInst = NULL;

    // Create the new instance

	IWbemClassObject * pClassObj = NULL;

    sc = pGateway->GetObject(pwcClass,0, NULL, &pClassObj,NULL);
    if(FAILED(sc)) 
        return sc;
    sc = pClassObj->SpawnInstance(0, ppNewInst);
    pClassObj->Release();
    if(FAILED(sc)) 
        return sc;

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(pwcKeyValue);
    if(var.bstrVal == NULL)    
        return sc;

    sc = (*ppNewInst)->Put(pwcKeyName,0,&var,0);
    VariantClear(&var);
	return sc;
}

SCODE CreateTimerEvent(WCHAR * pwcName, long lTimeIntSec, IWbemServices * pGateway)
{
	IWbemClassObject * pNewInst = NULL;
	SCODE sc = MyCreateInstance(pGateway, L"__IntervalTimerInstruction", 
				L"TimerID", pwcName, &pNewInst);
	if(sc != S_OK)
		return sc;

	VARIANT var;
	VariantInit(&var);
	var.vt = VT_I4;
	var.lVal = lTimeIntSec * 1000;
    sc = pNewInst->Put(L"IntervalBetweenEvents",0,&var,0);
	var.vt = VT_BOOL;
	var.boolVal = VARIANT_FALSE;
    sc = pNewInst->Put(L"SkipIfPassed",0,&var,0);
	sc = pGateway->PutInstance(pNewInst, 0, NULL, NULL);
	return sc;
}

CRegEvent::CRegEvent(IWbemClassObject * pObj, IWbemServices * pWbem)
{

	m_dwCheckSum = 0xffffffff;		// indicates that check sum has never been done
	// Save a pointer to the core

    m_bSaveHiveImage = FALSE;
    m_pLastHiveImage = NULL;
	if(pWbem)
	{
		m_pWbem = pWbem;
		m_pWbem->AddRef();
	}
	else
		m_pWbem = NULL;

	// generate a unique name by creating a new GUID and convert it to string format

    GUID guid;
    int iLen;
    SCODE sc = CoCreateGuid(&guid);
    if(sc == S_OK)
	    iLen = StringFromGUID2(guid,m_wcGuid,39);
	else
		m_wcGuid[0] = 0;

	// Read the path and possibly value field

	VARIANT var;
	VariantInit(&var);
	sc = pObj->Get(L"Key", 0, &var, NULL, NULL);
	if(sc == S_OK && var.vt == VT_BSTR && var.bstrVal != NULL)
		m_sRegPath = var.bstrVal;
	VariantInit(&var);
	sc = pObj->Get(L"Value", 0, &var, NULL, NULL);
	if(sc == S_OK && var.vt == VT_BSTR && var.bstrVal != NULL)
		m_sRegValue = var.bstrVal;

	VariantInit(&var);
	sc = pObj->Get(L"PollingIntervalSec", 0, &var, NULL, NULL);
	if(sc == S_OK && var.vt == VT_I4)
	{
		WCHAR wcQuery[256];
		wcscpy(wcQuery, L"select * from __TimerEvent where TimerId = \"");
		wcscat(wcQuery, m_wcGuid);
		wcscat(wcQuery, L"\"");
		m_lTimeIntSec = var.lVal;
		m_TimerEvent.SetQuery(wcQuery);
		sc = m_TimerEvent.StoreToWBEM(m_pWbem);
		sc = CreateTimerEvent(m_wcGuid, m_lTimeIntSec, m_pWbem);
	}

}

CRegEvent::~CRegEvent()
{
	if(m_pWbem)
		m_pWbem->Release();

    if(m_pLastHiveImage)
        delete m_pLastHiveImage;

	//todo, release the timer objects????

}


CRegEventSet::CRegEventSet()
{

}

SCODE CRegEventSet::Initialize(IWbemServices * pWbem)
{

    SCODE sc;

	m_pWbem = pWbem;
	if(m_pWbem)
	{
		m_pWbem->AddRef();

		//fornow, loop through the list of RegEvent instances and create an entry for each

	    IWbemClassObject * pNewInst = NULL;

		IEnumWbemClassObject FAR* pIEnum = NULL;

	    sc = m_pWbem->CreateInstanceEnum(L"RegEvent", 0, NULL, &pIEnum);
	    while (sc == S_OK) 
		{
	        ULONG uRet;
			sc = pIEnum->Next(-1, 1,&pNewInst,&uRet); 
			if(sc == S_OK) 
			{
				CRegEvent * pNewEvent = new CRegEvent(pNewInst,m_pWbem);
				if(pNewEvent)
					m_Set.Add(pNewEvent);

				pNewInst->Release();
            }
        } 

		if(pIEnum)
			pIEnum->Release(); 

		// fornow, register to get change events for that class.

		m_Event.SetQuery(L"select * from __InstanceCreationEvent where newinstance.__class = \"regevent\"");
		sc = m_Event.StoreToWBEM(m_pWbem);
	}
	return WBEM_E_INVALID_PARAMETER;
}

CRegEventSet::~CRegEventSet()
{
	if(m_pWbem)
		m_pWbem->Release();
	m_Set.Empty();
}

void CRegEventSet::FindEvent(WCHAR * pwcID)
{

	CRegEvent * pEvent;
	for(long lEvent = 0; lEvent < m_Set.Size(); lEvent++)
	{
		pEvent = (CRegEvent *)m_Set.GetAt(lEvent);
		if(pEvent && pEvent->IsMatch(pwcID))
			pEvent->TimerCheck();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\resource.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    RESOURCE.H

Abstract:

	defiines stuff in the resource file

History:

	a-davj  04-Mar-97   Created.

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SERVER2.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\stdafx.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STDAFX.CPP

Abstract:

History:

	a-davj  04-Mar-97   Created.

--*/

// stdafx.cpp : source file that includes just the standard includes
//	server2.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    REGEVENT.H

Abstract:

	Declares the CRegEvent class

History:

	a-davj    1-July-97       Created.

--*/

#ifndef _Regevent_H_
#define _Regevent_H_


#include <wbemcomn.h>
#include <node.h>

class CRegEvent
{
public:
	CRegEvent(IWbemClassObject * pObj, IWbemServices * pWbem);
	~CRegEvent();
	BOOL IsMatch(WCHAR * pwcID){return !_wcsicmp(pwcID, m_wcGuid);};
	void TimerCheck();
    DWORD CalcHive(HKEY hSubKey,DWORD & dwNewCheckSum);
private:
	IWbemServices * m_pWbem;
	DWORD m_dwCheckSum;
    CNode * m_pLastHiveImage;
	WCHAR m_wcGuid[40];
	long m_lTimeIntSec;
	CEventRegistration m_TimerEvent;
	TString m_sRegPath;
	TString m_sRegValue;
    BOOL m_bSaveHiveImage;
};


class CRegEventSet
{
public:
	CRegEventSet();
	SCODE Initialize(IWbemServices * pWbem);
	~CRegEventSet();
	void FindEvent(WCHAR * pwcID);
private:

	IWbemServices * m_pWbem;
	CFlexArray m_Set;
	CEventRegistration m_Event;
};

extern CRegEventSet gSet;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regmethods.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REGMETHODS.CPP

Abstract:

	Purpose: Implements the registry provider methods.

History:

--*/

#include "precomp.h"
#include "perfprov.h"
#include "cvariant.h"
#include "provreg.h"
#include "reg.h"
#include "genutils.h"
#include <cominit.h>
#include <arrtempl.h>
#include <userenv.h>
enum StringType{SIMPLE, EXPANDED};

void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen)
{ 
#ifdef UNICODE
    wcsncpy(pTo, pFrom,iLen);
#else
    wcstombs(pTo, pFrom, iLen);
#endif
    pTo[iLen-1] = 0;
    return;
}
BSTR GetBSTR(TCHAR * pIn)
{
#ifdef UNICODE 
    return SysAllocString(pIn);
#else
    int iBuffLen = lstrlen(pIn)+1;
    WCHAR * pTemp = new WCHAR[iBuffLen];
    if(pTemp == NULL)
        return NULL;
    mbstowcs(pTemp, pIn, iBuffLen);
    BSTR bRet = SysAllocString(pTemp);
    delete []pTemp;
    return bRet;
#endif
}

BOOL IsTypeMismatch(Registry & reg, TCHAR * pValueName, DWORD dwExpectedType)
{
    DWORD dwType;
    long lRet = reg.GetType(pValueName, &dwType);
    if(lRet == ERROR_SUCCESS && dwExpectedType != dwType)
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  HRESULT SetStatusAndReturnOK;
//
//  Purpose: Sets the status code in the sink.
//
//***************************************************************************

HRESULT SetStatusAndReturnOK(SCODE sc, IWbemObjectSink* pSink)
{
    pSink->SetStatus(0,sc, NULL, NULL);
    return S_OK;
}

//***************************************************************************
//
//  SAFEARRAY FAR* MySafeArrayCreate
//
//  Purpose:  Creates a safearray.
//
//  Return:  pointer to safearray, NULL if error.
//
//***************************************************************************

SAFEARRAY FAR* MySafeArrayCreate(long lNumElement, VARTYPE vt)
{

    SAFEARRAYBOUND rgsabound[1];    
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lNumElement;
    return SafeArrayCreate( vt, 1 , rgsabound );
}

//***************************************************************************
//
//  bool GetInArgString
//
//  Purpose:  Reads a string argument from the input object and puts it into
//  a value allocated by the caller.
//
//  Return:  true if OK.
//
//***************************************************************************

TCHAR * GetInArgString(IWbemClassObject* pInParams, WCHAR * pwcName)
{
    TCHAR * pOut = NULL;
    if(pInParams == NULL || pwcName == NULL)
        return NULL;
    VARIANT var;
    VariantInit(&var);
    SCODE sc = pInParams->Get(pwcName, 0, &var, NULL, NULL);   
    if(sc == S_OK && var.vt == VT_BSTR)
    {
        pOut = new TCHAR[wcslen(var.bstrVal) + 1];
        if(pOut)
            wcscpy(pOut, var.bstrVal);
    }
    VariantClear(&var);
    return pOut;
}


//***************************************************************************
//
//  SCODE EnumKey
//
//  Purpose:  Enumerate the subkeys and loads them into the output arguments.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE EnumKey(HKEY hRoot, TCHAR * cSubKey, IWbemClassObject* pOutParams)
{
    SCODE sc;
    DWORD dwNumSubKeys, dwMaxSubKeyLen, dwNumValues, dwMaxValueNameLen;
    TCHAR * pcTemp = NULL;
    
    // Open the key

    HKEY hKey;
    long lRet = RegOpenKeyEx(hRoot, cSubKey, 0, KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE , &hKey);
	if(lRet != ERROR_SUCCESS)
		return lRet;

	// Count the number of keys and the max size

    lRet = RegQueryInfoKey(hKey, NULL, NULL, NULL,
                &dwNumSubKeys,             // number of subkeys
                &dwMaxSubKeyLen,        // longest subkey name
                NULL,         
                &dwNumValues,              // number of value entries
                &dwMaxValueNameLen,     // longest value name
                NULL, NULL, NULL);

	if(lRet != ERROR_SUCCESS || dwMaxSubKeyLen == 0)
		return lRet;

    pcTemp = new TCHAR[dwMaxSubKeyLen+1];
    if(pcTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVectorDeleteMe<TCHAR> dm(pcTemp);

    // Create the safe array for returning the data

    SAFEARRAY FAR* psa = MySafeArrayCreate(dwNumSubKeys, VT_BSTR);
	if(psa == NULL)
	{
		RegCloseKey(hKey);
		return WBEM_E_OUT_OF_MEMORY;
	}

	// Put each value name into the array

    for(long lTry = 0; lTry < dwNumSubKeys; lTry++)
    {
        lRet = RegEnumKey(hKey, lTry, pcTemp, dwMaxSubKeyLen+1);
        if(lRet == ERROR_SUCCESS)
		{

			BSTR bstr = GetBSTR(pcTemp);
			if(bstr)
			{
				sc = SafeArrayPutElement(psa, &lTry, bstr);
				SysFreeString(bstr);
				if(FAILED(sc))
				{
                                SafeArrayDestroy(psa);
                                return sc;
				}
			}
		}
    }

	// Write the data back!

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psa;
    sc = pOutParams->Put( L"sNames", 0, &var, 0);      
	VariantClear(&var);
    RegCloseKey(hKey);
	return sc;
}

//***************************************************************************
//
//  SCODE EnumValue
//
//  Purpose:  Enumerates the value names and types and puts the results into
//  the output object.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE EnumValue(HKEY hRoot, TCHAR * cSubKey, IWbemClassObject* pOutParams)
{
    SCODE sc1, sc2;
    DWORD dwNumSubKeys, dwMaxSubKeyLen, dwNumValues, dwMaxValueNameLen;
    TCHAR * pcTemp = NULL;
    DWORD dwType, dwSize;

    // Open the registry key

    HKEY hKey;
    long lRet = RegOpenKeyEx((HKEY)hRoot, cSubKey, 0, KEY_QUERY_VALUE, &hKey);
	if(lRet != ERROR_SUCCESS)
		return lRet;

	// Count the number of values and the max size

    lRet = RegQueryInfoKey(hKey, NULL, NULL, NULL,
                &dwNumSubKeys,             // number of subkeys
                &dwMaxSubKeyLen,        // longest subkey name
                NULL,         
                &dwNumValues,              // number of value entries
                &dwMaxValueNameLen,     // longest value name
                NULL, NULL, NULL);

	if(lRet != ERROR_SUCCESS || dwMaxValueNameLen == 0)
		return lRet;

    pcTemp = new TCHAR[dwMaxValueNameLen+1];
    if(pcTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVectorDeleteMe<TCHAR> dm(pcTemp);
    
	// Create safe arrays for the data names and types

    SAFEARRAY FAR* psaNames = MySafeArrayCreate(dwNumValues, VT_BSTR);
	if(psaNames == NULL)
	{
	    RegCloseKey(hKey);
		return WBEM_E_OUT_OF_MEMORY;
	}
    SAFEARRAY FAR* psaTypes = MySafeArrayCreate(dwNumValues, VT_I4);
	if(psaTypes == NULL)
	{
		SafeArrayDestroy(psaNames);
		RegCloseKey(hKey);
		return WBEM_E_OUT_OF_MEMORY;
	}

	// Fill in the arrays

    for(long lTry = 0; lTry < dwNumValues; lTry++)
    {
        dwSize = dwMaxValueNameLen+1;
        lRet = RegEnumValue(hKey, lTry, pcTemp, &dwSize, 0, &dwType, NULL, 0);
        if(lRet == ERROR_SUCCESS)
		{
			BSTR bstr = GetBSTR(pcTemp);
			if(bstr)
			{
				sc1 = SafeArrayPutElement(psaNames, &lTry, bstr);
				sc2 = SafeArrayPutElement(psaTypes, &lTry, &dwType);
				SysFreeString(bstr);
				if(FAILED(sc1) || FAILED(sc2))
				{
				    SafeArrayDestroy(psaNames);
				    SafeArrayDestroy(psaTypes);
				    return WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
    }

	// Put the arrays containing the value names and types into the output object

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psaNames;
    pOutParams->Put( L"sNames", 0, &var, 0);
    VariantClear(&var);

    var.vt = VT_I4 | VT_ARRAY;
    var.parray = psaTypes;
    SCODE sc = pOutParams->Put( L"Types", 0, &var, 0);      
    VariantClear(&var);
    RegCloseKey(hKey);
	return sc;
}

//***************************************************************************
//
//  SCODE GetStr
//
//  Purpose:  Reads a string and puts it into the output argument.  Note that
//  this works with either normal strings or expanded registry strings.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE GetStr(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pOutParams)
{
	Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)cSubKey);
	long lRet = reg.GetLastError();
	if(lRet != ERROR_SUCCESS)
		return lRet;

    // Get the string

	TCHAR * pcValue;
	lRet = reg.GetStr(cValueName, &pcValue);
	if(lRet != ERROR_SUCCESS)
    {
        DWORD dwType;
        long lRet2 = reg.GetType(cValueName, &dwType);
        if(lRet2 == ERROR_SUCCESS && dwType != REG_SZ && dwType != REG_EXPAND_SZ)
            return WBEM_E_TYPE_MISMATCH;
		return lRet;
    }
    CDeleteMe<TCHAR> dm(pcValue);

	VARIANT var;
    var.bstrVal = GetBSTR(pcValue);
	var.vt = VT_BSTR;
	if(var.bstrVal == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	lRet = pOutParams->Put( L"sValue", 0, &var, 0);
	VariantClear(&var);
	return lRet;
}

//***************************************************************************
//
//  SCODE SetMultiStrValue
//
//  Purpose:  Writes multi string values to the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE SetMultiStrValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pInParams)
{
	SCODE sc;
	Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)cSubKey);
	if(reg.GetLastError() != 0)
		return reg.GetLastError();

	VARIANT var;
	VariantInit(&var);

    sc = pInParams->Get(L"sValue", 0, &var, NULL, NULL);   
	if(sc != S_OK)
		return sc;
	if(var.vt != (VT_ARRAY | VT_BSTR))
	{
		VariantClear(&var);
		return WBEM_E_INVALID_PARAMETER;
	}

    SAFEARRAY * psa = var.parray;
    long lLbound, lUbound;
    sc = SafeArrayGetLBound(psa,   1, &lLbound  );
    sc |= SafeArrayGetUBound(psa,   1, &lUbound  );
	if(sc != S_OK)
	{
		VariantClear(&var);
		return WBEM_E_INVALID_PARAMETER;
	}

    long lNumElements = lUbound - lLbound + 1;

    // Calculate the necessary size

    long lSize = 1, lTry;

    for(lTry = lLbound; lTry <= lUbound; lTry++)
    {
        BSTR bstr;
        if(S_OK == SafeArrayGetElement(psa, &lTry, &bstr))
		{
			lSize += SysStringLen(bstr) + 1;
			SysFreeString(bstr);
		}
    }

    WCHAR * pMulti = new WCHAR [lSize];
	if(pMulti == NULL)
	{
		VariantClear(&var);
		return WBEM_E_OUT_OF_MEMORY;
	}

    memset(pMulti, 0, lSize * sizeof(WCHAR));
    WCHAR * pNext = pMulti;

    // Do the conversion;

    for(lTry = lLbound; lTry <= lUbound; lTry++)
    {
        BSTR bstr;
        if(S_OK == SafeArrayGetElement(psa, &lTry, &bstr))
		{
			wcscpy(pNext, bstr);
			pNext += SysStringLen(bstr) + 1;
			SysFreeString(bstr);
		}
    }
	VariantClear(&var);

    long lRet;
    lRet = reg.SetMultiStr(cValueName, pMulti, lSize * sizeof(WCHAR));
    delete [] pMulti;
	return lRet;
}

//***************************************************************************
//
//  SCODE GetMultiStrValue
//
//  Purpose:  Reads multi strings from the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE GetMultiStrValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pOutParams)
{
    SCODE sc;
	Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)cSubKey);
	if(reg.GetLastError() != 0)
		return reg.GetLastError();

    DWORD dwSize = 0;
    TCHAR * pMulti = reg.GetMultiStr(cValueName, dwSize);
    if(pMulti == NULL)
		return reg.GetLastError();

    CVectorDeleteMe<TCHAR> dm(pMulti);
    
    // count the number of strings

    long lNumString = 0;
    TCHAR * pNext;
    for(pNext = pMulti; *pNext; pNext += lstrlen(pNext) + 1)
        lNumString++;

    // create the bstr array

    SAFEARRAY FAR* psa = MySafeArrayCreate(lNumString, VT_BSTR);
	if(psa == NULL)
	{
 		return WBEM_E_OUT_OF_MEMORY;
	}
    pNext = pMulti;
    for(long lTry = 0; lTry < lNumString; lTry++, pNext += lstrlen(pNext) + 1)
    {
        int iLen = lstrlen(pNext) + 1;
		BSTR bstr = GetBSTR(pNext);
		if(bstr)
		{
			sc = SafeArrayPutElement(psa, &lTry, bstr);
			SysFreeString(bstr);
			if(FAILED(sc))
			{
				SafeArrayDestroy(psa);
				return sc;
			}
		}
    }

    // put the data

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psa;
    sc = pOutParams->Put( L"sValue", 0, &var, 0);
    VariantClear(&var);
 	return sc;
}


//***************************************************************************
//
//  SCODE SetStringValue
//
//  Purpose:  Writes strings to the registry.  These strings may 
//  contain environment strings.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE SetStringValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pInParams,
							 StringType st)
{
	Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)cSubKey);
	long lRet = reg.GetLastError();
	if(lRet != ERROR_SUCCESS)
		return  lRet;

	VARIANT var;
	VariantInit(&var);

	SCODE sc = pInParams->Get(L"sValue", 0, &var, NULL, NULL);
	if(sc != S_OK)
		return sc;
	if(var.vt != VT_BSTR)
	{
		VariantClear(&var);
		return WBEM_E_INVALID_PARAMETER;
	}
	int iLen = 2*wcslen(var.bstrVal) + 2;
	TCHAR * pValue = new TCHAR[iLen];
	if(pValue)
	{
		CopyOrConvert(pValue, var.bstrVal, iLen);
		if(st == SIMPLE)
			sc = reg.SetStr(cValueName, pValue);
		else
			sc = reg.SetExpandStr(cValueName, pValue);
		delete [] pValue;
	}
	else
		sc = WBEM_E_OUT_OF_MEMORY;
	VariantClear(&var);
	return sc;
}

//***************************************************************************
//
//  SCODE SetBinaryValue
//
//  Purpose:  Writes binary data to the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE SetBinaryValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pInParams)
{
	Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)cSubKey);
	if(reg.GetLastError() != 0)
		return reg.GetLastError();

	VARIANT var;
	VariantInit(&var);

    SCODE sc = pInParams->Get(L"uValue", 0, &var, NULL, NULL);   
	if(sc != S_OK)
		return sc;

	if(var.vt != (VT_ARRAY | VT_UI1) || var.parray == NULL)
	{
		VariantClear(&var);
		return WBEM_E_INVALID_PARAMETER;
	}

    SAFEARRAY * psa = var.parray;
    long lLbound, lUbound;
    sc = SafeArrayGetLBound(psa,   1, &lLbound  );
    sc |= SafeArrayGetUBound(psa,   1, &lUbound  );
	if(sc == S_OK)
	{
		byte * pData;
		sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
		if(sc == S_OK)
		{
			sc = reg.SetBinary(cValueName, pData, DWORD(lUbound - lLbound + 1));
		}
	}
    VariantClear(&var);
	return sc;

}

//***************************************************************************
//
//  SCODE GetBinaryValue
//
//  Purpose:  Reads binary data from the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE GetBinaryValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pOutParams)
{
	Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)cSubKey);
	if(reg.GetLastError() != 0)
		return reg.GetLastError();

	SCODE sc;
    DWORD dwSize;
    byte * pRegData;
    long lRet = reg.GetBinary(cValueName, &pRegData, &dwSize);
	if(lRet != ERROR_SUCCESS || pRegData == NULL)
    {
        if(IsTypeMismatch(reg, cValueName, REG_BINARY))
            return WBEM_E_TYPE_MISMATCH;
        else
		    return lRet;
    }

    SAFEARRAY FAR* psa = MySafeArrayCreate(dwSize, VT_UI1);
	if(psa)
	{
		TCHAR * pData = NULL;
		sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
		if(sc == S_OK)
		{
			memcpy(pData, pRegData, dwSize);
			SafeArrayUnaccessData(psa);
			VARIANT var;
			var.vt = VT_UI1|VT_ARRAY;
			var.parray = psa;
			sc = pOutParams->Put(L"uValue" , 0, &var, 0);      
			VariantClear(&var);
		}
	}
	else
		sc = WBEM_E_OUT_OF_MEMORY;
	delete [] pRegData;
	return sc;
}


//***************************************************************************
//
//  SCODE LoadProfile
//
//  Purpose:  Sets up all the arguments needed for calling LoadUserProfile
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE LoadProfile(HANDLE & hToken,HKEY &  hRoot)
{
    PROFILEINFO pi;
    memset((void *)&pi, 0, sizeof(pi));
    pi.dwSize = sizeof(pi);
    SCODE sc;

    BOOL bRes;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE, 
                                                TRUE, &hToken); 
    if(!bRes)
        return WBEM_E_FAILED;
    
    TCHAR cUsername[MAX_PATH];
    cUsername[0] = 0;
    DWORD dwSize = MAX_PATH;
    GetUserName(cUsername, &dwSize);
    pi.lpUserName = cUsername;
    pi.dwFlags = 1;
    WbemCoRevertToSelf();
    BOOL bRet = LoadUserProfile(hToken, &pi);
    if(bRet == 0)
    {
        hRoot = NULL;
        sc = WbemCoImpersonateClient();
        return WBEM_E_FAILED;        
    }
    else
        hRoot = (HKEY)pi.hProfile;
    sc = WbemCoImpersonateClient();
    if(FAILED(sc))
    {
            UnloadUserProfile(hToken, hRoot);
            hRoot = NULL;
    }
    return sc;
}


/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*                                                                       *
************************************************************************/

SCODE CImpReg::MethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    TCHAR * pcValueName = NULL;
    TCHAR * pcSubKey = NULL;
    long lRet = 0;

	if(ObjectPath == NULL || MethodName == NULL || pInParams == NULL || pSink == NULL)
		return WBEM_E_INVALID_PARAMETER;

    // Kevin needs a way to tell if something is write

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  Then create the output argument

    hr = m_pGateway->GetObject(L"StdRegProv", 0, pCtx, &pClass, NULL);
	if(hr == S_OK)
	{
		hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
		if(hr == S_OK)
		{
			hr  = pOutClass->SpawnInstance(0, &pOutParams);
			pOutClass->Release();    
		}
		pClass->Release();
	}
	if(hr != S_OK)
		return SetStatusAndReturnOK(hr, pSink);

	CReleaseMe rm0(pOutParams);
    
    // Get the root key and subkeys

    VARIANT var;
    VariantInit(&var);    // Get the input argument
    hr = pInParams->Get(L"hDefKey", 0, &var, NULL, NULL);   
	if(hr != S_OK)
		return SetStatusAndReturnOK(hr, pSink);
#ifdef _WIN64
    HKEY hRoot = (HKEY)IntToPtr(var.lVal);
#else
    HKEY hRoot = (HKEY)var.lVal;
#endif
    pcSubKey = GetInArgString(pInParams, L"sSubKeyName");
    if(pcSubKey == NULL)
		return SetStatusAndReturnOK(WBEM_E_INVALID_PARAMETER, pSink);
    CVectorDeleteMe<TCHAR> dm1(pcSubKey);

	// This may or may not work since the value name isnt required

    pcValueName = GetInArgString(pInParams, L"sValueName");
    CVectorDeleteMe<TCHAR> dm2(pcValueName);

	SCODE sc = S_OK;

    // Impersonate if using NT

    if(IsNT() && IsDcomEnabled())
    {
        sc = WbemCoImpersonateClient();
        if(sc != S_OK)
			return sc;
	}

    // If we are using HKCU, the hive may need to be loaded

    bool bUsingHKCU = IsNT() && hRoot == HKEY_CURRENT_USER;


    HANDLE hToken = INVALID_HANDLE_VALUE;
    CCloseMe cm(hToken);

    if(bUsingHKCU)
        sc = LoadProfile(hToken, hRoot);

    if(sc != S_OK)
		return sc;

    if(!_wcsicmp(MethodName, L"CreateKey"))
    {
		HKEY hKey;
        if(lstrlen(pcSubKey) < 1)
            sc = WBEM_E_INVALID_PARAMETER;
        else
        {
    		lRet = RegCreateKey(hRoot, pcSubKey, &hKey);
		    if(lRet == ERROR_SUCCESS)
			    RegCloseKey(hKey);
        }
    }
    else if(!_wcsicmp(MethodName, L"DeleteKey"))
    {
        if(lstrlen(pcSubKey) < 1)
            sc = WBEM_E_INVALID_PARAMETER;
        else
            lRet = RegDeleteKey(hRoot, pcSubKey);
    }
    else if(!_wcsicmp(MethodName, L"DeleteValue"))
    {
        HKEY hKey;
        lRet = RegOpenKey(hRoot, pcSubKey, &hKey);
		if(lRet == ERROR_SUCCESS)
		{
			lRet = RegDeleteValue(hKey, pcValueName);
			RegCloseKey(hKey);
		}
    }
    else if(!_wcsicmp(MethodName, L"EnumKey"))
    {
		lRet = EnumKey(hRoot, pcSubKey, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"EnumValues"))
    {
        lRet = EnumValue(hRoot, pcSubKey, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"GetStringValue") ||
		    !_wcsicmp(MethodName, L"GetExpandedStringValue"))
    {
		lRet = GetStr(hRoot, pcSubKey, pcValueName, pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"SetMultiStringValue"))
    {
		lRet = SetMultiStrValue(hRoot,pcSubKey,pcValueName,pInParams);
    }
    else if(!_wcsicmp(MethodName, L"GetMultiStringValue"))
    {
		lRet = GetMultiStrValue(hRoot,pcSubKey,pcValueName,pOutParams);
    }
    else if(!_wcsicmp(MethodName, L"SetExpandedStringValue"))
    {
		lRet = SetStringValue(hRoot, pcSubKey, pcValueName, pInParams, EXPANDED);
    }
    else if(!_wcsicmp(MethodName, L"SetStringValue"))
    {
		lRet = SetStringValue(hRoot, pcSubKey, pcValueName, pInParams, SIMPLE);
    }
    else if(!_wcsicmp(MethodName, L"SetBinaryValue"))
    {
		lRet = SetBinaryValue(hRoot, pcSubKey, pcValueName, pInParams);
    }
    else if(!_wcsicmp(MethodName, L"SetDWORDValue"))
    {
        lRet = pInParams->Get(L"uValue", 0, &var, NULL, NULL); 
		if(lRet == S_OK)
		{
			DWORD dwValue = var.lVal;
			Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)pcSubKey);
			lRet = reg.GetLastError();
			if(lRet ==0)
				lRet = reg.SetDWORD(pcValueName, dwValue);
		}
    }
    else if(!_wcsicmp(MethodName, L"GetDWORDValue"))
    {
        // Get the value name

		Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)pcSubKey);
		lRet = reg.GetLastError();
		if(lRet == 0)
	        lRet = reg.GetDWORD(pcValueName, (DWORD *)&var.lVal);
		if(lRet == ERROR_SUCCESS)
		{
			var.vt = VT_I4;
			lRet = pOutParams->Put( L"uValue", 0, &var, 0);      
		}
        else if(IsTypeMismatch(reg, pcValueName, REG_DWORD))
            lRet = WBEM_E_TYPE_MISMATCH;
    }
    else if(!_wcsicmp(MethodName, L"GetBinaryValue"))
    {
		lRet = GetBinaryValue(hRoot,pcSubKey,pcValueName,pOutParams);
    }
	else if(!_wcsicmp(MethodName, L"CheckAccess"))
	{
        lRet = pInParams->Get(L"uRequired", 0, &var, NULL, NULL); 
		if(lRet == S_OK)
		{
			BOOL bSuccess = FALSE;
			DWORD dwValue = var.lVal;
			HKEY hKey;
			lRet = RegOpenKeyEx(hRoot, pcSubKey, 0,  dwValue, &hKey);
			if(lRet == ERROR_SUCCESS)
			{
				RegCloseKey(hKey);
				bSuccess = TRUE;
			}
			var.vt = VT_BOOL;
			var.boolVal = (bSuccess) ? VARIANT_TRUE : VARIANT_FALSE;
			pOutParams->Put( L"bGranted", 0, &var, 0);      
		}
	}
    else
        sc = WBEM_E_INVALID_METHOD;

    if(bUsingHKCU)
    {
        WbemCoRevertToSelf();
        UnloadUserProfile(hToken, hRoot);
    }
    
	// Set the return value

    if(sc == S_OK)
    {
        BSTR retValName = SysAllocString(L"ReturnValue");
	    if(retValName)
	    {
		    var.vt = VT_I4;
		    var.lVal = lRet;
	        pOutParams->Put(retValName , 0, &var, 0); 
    	    SysFreeString(retValName);
	    }
        hr = pSink->Indicate(1, &pOutParams);    
    }

    return SetStatusAndReturnOK(sc, pSink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    REGPROV.H

Abstract:

	Defines the guids for the registry provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _regprov_H_
#define _regprov_H_

DEFINE_GUID(LIBID_SAMPLEMO,0x8B26C640L,0xE46F,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

DEFINE_GUID(CLSID_RegProvider,0xFE9AF5C0L,0xD3B6,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

// {72967901-68EC-11d0-B729-00AA0062CBB7}
DEFINE_GUID(CLSID_RegPropProv, 
0x72967901, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);


// {AA2B1081-EC0B-11d0-9E4D-00C04FC324A8}
DEFINE_GUID(CLSID_RegEventCallback, 
0xaa2b1081, 0xec0b, 0x11d0, 0x9e, 0x4d, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

SCODE LoadProfile(HANDLE & hToken,HKEY &  hRoot);

#ifdef __cplusplus
class RegProvider;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\assoc\guid.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    GUID.H

Abstract:

History:

--*/

#include <objbase.h>

// {8EF92BE0-8EBA-11d0-AD59-00C04FD8FDFF}
DEFINE_GUID(CLSID_AssociationProvider, 
0x8ef92be0, 0x8eba, 0x11d0, 0xad, 0x59, 0x0, 0xc0, 0x4f, 0xd8, 0xfd, 0xff);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\stdafx.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STDAFX.H

Abstract:

	include file for standard system include files,
	or project specific include files that are used frequently, but
	are changed infrequently

History:

	a-davj  04-Mar-97   Created.

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxdb.h>          // MFC database classes
#include "stdprov.h"

#undef PURE
#define PURE {return (unsigned long)E_NOTIMPL;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\tstring.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TSTRING.H

Abstract:

	Utility string class

History:

	a-davj    1-July-97       Created.

--*/

#ifndef _TString_H_
#define _TString_H_

class TString
{
    TCHAR *m_pString;
    TCHAR m_empty;		// something to point at if memory alloc fails.
	int m_Size;
	void assign(const TCHAR * pSrc);
public:
	TString();
    TString(const TCHAR *pSrc);
    TString& operator =(LPTSTR);
#ifndef UNICODE
    TString& operator =(WCHAR *);
#endif
	TString& operator =(const TString &);
    void Empty();
	~TString() { Empty(); }
    TString& operator +=(TCHAR *);
    TString& operator +=(TCHAR tAdd);

	TCHAR GetAt(int iIndex);
	int Find(TCHAR cFind);

    operator TCHAR *() { return m_pString; } 
    int Length() { return lstrlen(m_pString); }
    BOOL Equal(TCHAR *pTarget) 
        { return lstrcmp(m_pString, pTarget) == 0; }
    BOOL EqualNoCase(TCHAR *pTarget) 
        { return lstrcmpi(m_pString, pTarget) == 0; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\assoc\assrule.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSRULE.H

Abstract:

History:

--*/

#include <windows.h>
#include <wbemidl.h>
#include <arena.h>
#include <flexarry.h>

class CObjectCache
{
protected:
    CFlexArray m_aObjects;

public:
    ~CObjectCache();
    void Invalidate();
    void Add(IWbemClassObject* pObject);
    HRESULT Indicate(IWbemObjectSink* pSink);
};

class CEndpointCache
{
protected:
    BSTR m_strQuery;
    BOOL m_bCache;
    IEnumWbemClassObject* m_pEnum;
public:
    CEndpointCache();
    void Create(BSTR strQuery, BOOL bCache);
    ~CEndpointCache();

    HRESULT GetInstanceEnum(IWbemServices* pNamespace,
                            IEnumWbemClassObject** ppEnum);
};

class CAssocRule
{
protected:
    int m_nRef;

    BSTR m_strAssocClass;
    BSTR m_strProp1;
    CEndpointCache m_Cache1;
    BSTR m_strProp2;
    CEndpointCache m_Cache2;
protected:
    IWbemClassObject* m_pClass;
    CObjectCache m_ObjectCache;
    BOOL m_bMayCacheResult;
    BOOL m_bResultCached;

public:
    CAssocRule();
    ~CAssocRule();

    void AddRef();
    void Release();

    BSTR GetAssocClass() {return m_strAssocClass;}

    HRESULT LoadFromObject(IWbemClassObject* pRule, BOOL bLongTerm);
    HRESULT Produce(IWbemServices* pNamespace, IWbemObjectSink* pNotify);
};

class CAssocInfoCache
{
protected:
    CFlexArray m_aRules;
    IWbemServices* m_pNamespace;

public:
    CAssocInfoCache();
    ~CAssocInfoCache();

    void SetNamespace(IWbemServices* pNamespace);

    HRESULT GetRuleForClass(BSTR strClass, CAssocRule** ppRule);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\tstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"

TString::TString()
{
	m_empty = 0;
	m_pString = &m_empty;
	m_Size = 0;
}


TString::TString(const TCHAR *pSrc)
{
	m_empty = 0;
	m_pString = &m_empty;
	m_Size = 0;
	assign(pSrc);
}


void TString::assign(const TCHAR * pSrc)
{
	if(pSrc)
	{
		int iLen = lstrlen(pSrc)+1;
		TCHAR * pNew = new TCHAR[iLen];
		if(pNew)
		{
			m_pString = pNew;
			m_Size = iLen;
			lstrcpy(m_pString, pSrc);
		}
	}
}

#ifndef UNICODE
TString& TString::operator =(WCHAR * pwcSrc)
{
	Empty();
    long len = 2*(wcslen(pwcSrc)+1);
	TCHAR * pNew = new TCHAR[len];
	if(pNew)
	{
		wcstombs(pNew, pwcSrc, len);
		assign(pNew);
		delete pNew;
	}
	return *this;
}
#endif

TString& TString::operator =(LPTSTR pSrc)
{
	Empty();
	assign(pSrc);
	return *this;
}

TString& TString::operator =(const TString &Src)
{
    Empty();
    assign(Src.m_pString);
    return *this;    
}
//TString::operator=(class TString const &)

void TString::Empty()
{
	m_Size = 0;
	if(m_pString != &m_empty)
		delete m_pString;
	m_pString = &m_empty;
}

TString& TString::operator +=(TCHAR * pSrc)
{
	if(pSrc)
	{
		int iLen = lstrlen(m_pString) + lstrlen(pSrc)+1;
		TCHAR * pNew = new TCHAR[iLen];
		if(pNew)
		{
			lstrcpy(pNew, m_pString);
			lstrcat(pNew, pSrc);
			Empty();
			m_Size = iLen;
			m_pString = pNew;
		}
	}
	return *this;
}

TString& TString::operator +=(TCHAR Src)
{
	if(lstrlen(m_pString) + 2 > m_Size)
	{
		int iLen =  lstrlen(m_pString) + 32;

		TCHAR * pNew = new TCHAR[iLen];
		if(pNew == NULL)
			return *this;
		lstrcpy(pNew, m_pString);
        Empty();
		m_pString = pNew;
		m_Size = iLen;
	}
	TCHAR temp[2];
	temp[0] = Src;
	temp[1] = 0;
	lstrcat(m_pString, temp); 
	return *this;
}


TCHAR TString::GetAt(int iIndex)
{
	if(iIndex < 0 || iIndex >= lstrlen(m_pString))
		return -1;
	else
		return m_pString[iIndex];
}

int TString::Find(TCHAR cFind)
{
	int iCnt, iLen = lstrlen(m_pString);
	for(iCnt = 0 ;iCnt < iLen; iCnt++)
		if(cFind == m_pString[iCnt])
			return iCnt;
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\assoc\assrule.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSRULE.CPP

Abstract:

History:

--*/

#include "assrule.h"
#include <stdio.h>

#define CLASSNAME_ASSOCIATION_RULE L"AssociationRule"
#define PROPNAME_ASSOCIATION_CLASS L"AssociationClass"
#define PROPNAME_RULE_IMMUTABLE L"RuleIsImmutable"
#define PROPNAME_PROPNAME_1 L"PropertyName1"
#define PROPNAME_QUERY_1 L"PropertyQuery1"
#define PROPNAME_IMMUTABLE_1 L"Property1IsImmutable"
#define PROPNAME_PROPNAME_2 L"PropertyName2"
#define PROPNAME_QUERY_2 L"PropertyQuery2"
#define PROPNAME_IMMUTABLE_2 L"Property2IsImmutable"

#define EXTRA_GET_PARAMS ,NULL, NULL
#define EXTRA_PUT_PARAMS ,0

CEndpointCache::CEndpointCache()
    : m_strQuery(NULL), m_pEnum(NULL)
{
}

void CEndpointCache::Create(BSTR strQuery, BOOL bCache)
{
    m_strQuery = SysAllocString(strQuery);
    m_bCache = bCache; 
}

CEndpointCache::~CEndpointCache()
{
    SysFreeString(m_strQuery);
    if(m_pEnum)
        m_pEnum->Release();
}


HRESULT CEndpointCache::GetInstanceEnum(IWbemServices* pNamespace,
                                        IEnumWbemClassObject** ppEnum)
{
    if(m_pEnum)
    {
        *ppEnum = m_pEnum;
        m_pEnum->AddRef();
        return S_OK;
    }

    HRESULT hres = pNamespace->ExecQuery(L"WQL", m_strQuery, 0, ppEnum, NULL);
    if(FAILED(hres)) return hres;

    if(m_bCache)
    {
        m_pEnum = *ppEnum;
        m_pEnum->AddRef();
    }
    
    return hres;
}



CAssocRule::CAssocRule() 
    : m_strAssocClass(NULL), m_strProp1(NULL), m_strProp2(NULL), m_pClass(NULL),
    m_nRef(0), m_bMayCacheResult(FALSE), m_bResultCached(FALSE)
{
}

CAssocRule::~CAssocRule()
{
    SysFreeString(m_strAssocClass);
    SysFreeString(m_strProp1);
    SysFreeString(m_strProp2);

    if(m_pClass)
        m_pClass->Release();
}

void CAssocRule::AddRef()
{
    m_nRef++;
}

void CAssocRule::Release()
{
    if(--m_nRef == 0)
    {
        delete this;
    }
}

HRESULT CAssocRule::LoadFromObject(IWbemClassObject* pRule, BOOL bLongTerm)
{
    HRESULT hres;

    VARIANT v;
    VariantInit(&v);

    // Read association name
    // =====================

    hres = pRule->Get(PROPNAME_ASSOCIATION_CLASS, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }
    m_strAssocClass = SysAllocString(V_BSTR(&v));
    VariantClear(&v);

    // Read property names
    // ===================

    hres = pRule->Get(PROPNAME_PROPNAME_1, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }
    m_strProp1 = SysAllocString(V_BSTR(&v));
    VariantClear(&v);

    hres = pRule->Get(PROPNAME_PROPNAME_2, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }
    m_strProp2 = SysAllocString(V_BSTR(&v));
    VariantClear(&v);

    m_bMayCacheResult = bLongTerm;

    // Read property rule (1)
    // ======================

    VARIANT vImmutable;
    VariantInit(&vImmutable);

    hres = pRule->Get(PROPNAME_QUERY_1, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    hres = pRule->Get(PROPNAME_IMMUTABLE_1, 0, &vImmutable EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&vImmutable) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    m_Cache1.Create(V_BSTR(&v), V_BOOL(&vImmutable));
    VariantClear(&v);
    if(!V_BOOL(&vImmutable)) 
        m_bMayCacheResult = FALSE;

    // Read property rule (2)
    // ======================

    hres = pRule->Get(PROPNAME_QUERY_2, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    hres = pRule->Get(PROPNAME_IMMUTABLE_2, 0, &vImmutable EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&vImmutable) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    m_Cache2.Create(V_BSTR(&v), V_BOOL(&vImmutable));
    VariantClear(&v);
    if(!V_BOOL(&vImmutable)) 
        m_bMayCacheResult = FALSE;

    return S_OK;
}

HRESULT CAssocRule::Produce(IWbemServices* pNamespace, IWbemObjectSink* pNotify)
{
    HRESULT hres;

    // Check if we have it cached
    // ==========================

    if(m_bResultCached)
    {
        return m_ObjectCache.Indicate(pNotify);
    }

    // Get first enumerator
    // ====================

    IEnumWbemClassObject* pEnum1;
    hres = m_Cache1.GetInstanceEnum(pNamespace, &pEnum1);
    if(FAILED(hres))
    {
        return hres;
    }

    // Get second enumerator
    // =====================

    IEnumWbemClassObject* pEnum2;
    hres = m_Cache2.GetInstanceEnum(pNamespace, &pEnum2);
    if(FAILED(hres))
    {
        pEnum1->Release();
        return hres;
    }

    // Get the association class
    // =========================

    IWbemClassObject* pClass;
    if(m_pClass != NULL)
    {
        pClass = m_pClass;
        pClass->AddRef();
    }
    else
    {
        hres = pNamespace->GetObject(m_strAssocClass, 0, &pClass, NULL);
        if(FAILED(hres))
        {
            pEnum1->Release();
            pEnum2->Release();
            return hres;
        }
    }

    // Create all the associations
    // ===========================

    
    IWbemClassObject* pInstance1, *pInstance2;
    ULONG lNum;

    VARIANT v;
    VariantInit(&v);

    // Iterate through the first result set
    // ====================================

    pEnum1->Reset();
    while(pEnum1->Next(1, &pInstance1, &lNum) == S_OK)
    {
        // Get the first path
        // ==================

        hres = pInstance1->Get(L"__PATH", 0, &v EXTRA_GET_PARAMS);
        if(FAILED(hres))
        {
            pEnum1->Release();
            pEnum2->Release();
            pClass->Release();
            return hres;
        }
        BSTR strPath1 = V_BSTR(&v);
        VariantInit(&v); // intentional.

        // Iterate through the second result set
        // =====================================

        pEnum2->Reset();
        while(pEnum2->Next(1, &pInstance2, &lNum) == S_OK)
        {
            // Get the second path
            // ===================

            hres = pInstance2->Get(L"__PATH", 0, &v EXTRA_GET_PARAMS);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                return hres;
            }
            BSTR strPath2 = V_BSTR(&v);
            VariantInit(&v); // intentional

            // Create the association instance
            // ===============================

            IWbemClassObject* pInstance;
            hres = pClass->SpawnInstance(0, &pInstance);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                return hres;
            }

            // Set the properties
            // ==================

            V_VT(&v) = VT_BSTR;
            V_BSTR(&v) = strPath1;

            hres = pInstance->Put(m_strProp1, 0, &v EXTRA_PUT_PARAMS);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                pInstance->Release();
                return hres;
            }

            V_BSTR(&v) = strPath2;
            hres = pInstance->Put(m_strProp2, 0, &v EXTRA_PUT_PARAMS);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                pInstance->Release();
                return hres;
            }

            // Supply it
            // =========

            pNotify->Indicate(1, &pInstance);

            // Cache it if allowed
            // ===================

            if(m_bMayCacheResult)
                m_ObjectCache.Add(pInstance);

            pInstance->Release();

            SysFreeString(strPath2);
            pInstance2->Release();
        }

        SysFreeString(strPath1);
        pInstance1->Release();
    }

    pEnum1->Release();
    pEnum2->Release();
    pClass->Release();

    if(m_bMayCacheResult)
        m_bResultCached = TRUE;
    return S_OK;
}

//*****************************************************************************

CAssocInfoCache::CAssocInfoCache() : m_pNamespace(NULL)
{
}

void CAssocInfoCache::SetNamespace(IWbemServices* pNamespace)
{
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
}

CAssocInfoCache::~CAssocInfoCache()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    for(int i = 0; i < m_aRules.Size(); i++)
    {
        CAssocRule* pRule = (CAssocRule*)m_aRules[i];
        pRule->Release();
    }
}


HRESULT CAssocInfoCache::GetRuleForClass(BSTR strClass, CAssocRule** ppRule)
{
    // Search our rules to see if we have it
    // =====================================

    for(int i = 0; i < m_aRules.Size(); i++)
    {
        CAssocRule* pRule = (CAssocRule*)m_aRules[i];
        if(!wcsicmp(pRule->GetAssocClass(), strClass))
        {
            pRule->AddRef();
            *ppRule = pRule;
            return S_OK;
        }
    }

    // Don't have it. Search for the rule in the database.
    // ===================================================

    HRESULT hres;

    BSTR strPath = SysAllocStringLen(NULL, wcslen(strClass) + 100);
    swprintf(strPath, L"%s.%s=\"%s\"", CLASSNAME_ASSOCIATION_RULE,
        PROPNAME_ASSOCIATION_CLASS, strClass);

    IWbemClassObject* pRuleInstance;
    hres = m_pNamespace->GetObject(strPath, 0, &pRuleInstance, NULL);
    SysFreeString(strPath);
    if(FAILED(hres))
    {
        return hres;
    }

    // Check if it is cachable
    // ========================

    VARIANT v;
    VariantInit(&v);
    hres = pRuleInstance->Get(PROPNAME_RULE_IMMUTABLE, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres))
    {
        pRuleInstance->Release();
        return hres;
    }

    // Got it. Create the rule.
    // ========================

    CAssocRule* pRule = new CAssocRule;
    hres = pRule->LoadFromObject(pRuleInstance, V_BOOL(&v));
    pRuleInstance->Release();
  
    if(FAILED(hres))
    {
        delete pRule;
        return hres;
    }

    // Cache if allowed
    // ================

    if(V_BOOL(&v))
    {
        m_aRules.Add(pRule);
        pRule->AddRef();
    }

    // Return it to the caller
    // =======================

    pRule->AddRef();
    *ppRule = pRule;

    return S_OK;
}




//****************************************************************************

CObjectCache::~CObjectCache()
{
    Invalidate();
}

void CObjectCache::Invalidate()
{
    for(int i = 0; i < m_aObjects.Size(); i++)
    {
        IWbemClassObject* pObject = (IWbemClassObject*)m_aObjects[i];
        pObject->Release();
    }
    m_aObjects.Empty();
}

void CObjectCache::Add(IWbemClassObject* pObject)
{
    m_aObjects.Add((void*)pObject);
    pObject->AddRef();
}

HRESULT CObjectCache::Indicate(IWbemObjectSink* pSink)
{
    if(m_aObjects.Size() == 0) 
        return S_OK;

    void** ppvData = m_aObjects.GetArrayPtr();

    return pSink->Indicate(m_aObjects.Size(), (IWbemClassObject**)ppvData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regcrc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGCRC.H

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <crc32.h>

class CRegCRC
{
public:
    static HRESULT ComputeValueCRC(HKEY hKey, LPCTSTR szValueName, 
                                    DWORD dwPrevCRC, DWORD& dwNewCRC);
    static HRESULT ComputeKeyValuesCRC(HKEY hKey, DWORD dwPrevCRC, 
                                       DWORD& dwNewCRC);
    static HRESULT ComputeKeyCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC);
    static HRESULT ComputeTreeCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regedefs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEDEFS.H

Abstract:

History:

--*/

#ifndef __WBEM_REG_EVENT_DEFS__H_
#define __WBEM_REG_EVENT_DEFS__H_

#define REG_KEY_EVENT_CLASS L"RegistryKeyChangeEvent"
#define REG_VALUE_EVENT_CLASS L"RegistryValueChangeEvent"
#define REG_TREE_EVENT_CLASS L"RegistryTreeChangeEvent"

#define REG_HIVE_PROPERTY_NAME L"Hive"
#define REG_KEY_PROPERTY_NAME L"KeyPath"
#define REG_VALUE_PROPERTY_NAME L"ValueName"
#define REG_ROOT_PROPERTY_NAME L"RootPath"

enum
{
    e_RegValueChange,
    e_RegKeyChange,
    e_RegTreeChange
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\stdprov.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    STDPROV.CPP

Abstract:

	Contains DLL entry points.  Also has code that controls
	when the DLL can be unloaded by tracking the number of
	object.  Also holds various utility classes and 
	functions.

History:

	a-davj  9-27-95    Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <genutils.h>
#include "cvariant.h"
#include "cfdyn.h"
#include "provreg.h"
#include "provperf.h"
#include <regeprov.h>

// Count number of objects and number of locks so DLL can know when to unload

long lObj = 0;
long lLock = 0;
HINSTANCE ghModule = NULL;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
 	if(ghModule == NULL)
    {
		ghModule = hInstance;
    }
 
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else if (DLL_PROCESS_ATTACH==ulReason)
    {
        return TRUE;
    }

    return TRUE;
}              
//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  E_OUTOFMEMORY       out of memory
//  
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT             hr;
//    CCFDyn *pObj;
    IClassFactory *pObj;

// ****  FOR EACH PROVIDER  ***
    if (CLSID_RegProvider ==rclsid)
        pObj=new CCFReg();
    else if (CLSID_RegPropProv ==rclsid)
        pObj=new CCFRegProp();
    else if (CLSID_PerfProvider ==rclsid)
        pObj=new CCFPerf();
    else if (CLSID_PerfPropProv ==rclsid)
        pObj=new CCFPerfProp();
    else if (CLSID_RegistryEventProvider ==rclsid)
        pObj=new CRegEventProviderFactory;
    else
        return ResultFromScode(E_FAIL);

// ****  FOR EACH PROVIDER  ***

    if (NULL==pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
	if(lLock == 0 && lObj == 0)
		return S_OK;
	else
		return S_FALSE;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    RegisterDLL(ghModule, CLSID_RegProvider, __TEXT("WBEM Registry Instance Provider"), __TEXT("Both"), NULL);
    RegisterDLL(ghModule, CLSID_RegPropProv, __TEXT("WBEM Registry Property Provider"), __TEXT("Both"), NULL);
	if(IsNT())
	{
		RegisterDLL(ghModule, CLSID_PerfProvider, __TEXT("WBEM PerfMon Instance Provider"), __TEXT("Both"), NULL);
		RegisterDLL(ghModule, CLSID_PerfPropProv, __TEXT("WBEM PerfMon Property Provider"), __TEXT("Both"), NULL);
	}
    RegisterDLL(ghModule, CLSID_RegistryEventProvider, 
                __TEXT("WBEM Registry Event Provider"), __TEXT("Both"), NULL);
	return S_OK;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnRegisterDLL(CLSID_RegProvider, NULL);
 	UnRegisterDLL(CLSID_RegPropProv, NULL);
	UnRegisterDLL(CLSID_PerfProvider, NULL);
	UnRegisterDLL(CLSID_PerfPropProv, NULL);
	UnRegisterDLL(CLSID_RegistryEventProvider, NULL);
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\stdprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STDPROV.H

Abstract:

	Defines general purpose defines as well as some common
	objects that are generaly useful for all the different
	provider types.

History:

	a-davj  27-Sep-97   Created.

--*/

#ifndef _SERVER2_H_
#define _SERVER2_H_

#define INC_OBJ    1
#define INC_LOCK   2
#define DEC_OBJ    3
#define DEC_LOCK   4

#define INIT_SIZE            20



// Used to parse all provider strings

#define MAIN_DELIM '|'

// Used to parse substrings for the registry and
// compound file providers

#define SUB_DELIM '\\'

// Used to parse substrings for the automation

#define DOT '.'

// Used to parse the PATH/CLASS token for the automation

#define DQUOTE '\"'
#define SEPARATOR ','


// Used to parse ini strings.

#define COMMA ','

// Use in dde provider strings to delimit item names

#define DELIMCHR '@'
#define DELIMSTR "@"

// Used to ignore any of the above!

#define ESC '^'

// Indicates that the dwUseOptArray value should
// be substituted

#define USE_ARRAY '#'

#define ERROR_UNKNOWN 255

#ifdef UNICODE
#define CHARTYPE VT_LPWSTR
#define CHARSIZE 2
#else
#define CHARTYPE VT_LPSTR
#define CHARSIZE 1
#endif

SAFEARRAY * OMSSafeArrayCreate(VARTYPE vt,int iNumElements);
HRESULT OMSVariantChangeType(VARIANTARG * pDest, VARIANTARG *pSrc,USHORT wFlags, VARTYPE vtNew);
HRESULT OMSVariantClear(VARIANTARG * pClear);
int iTypeSize(VARTYPE vtTest);
char * WideToNarrow(LPCWSTR);
char * WideToNarrowA(LPCWSTR);      // uses new instead of CoTaskMemAlloc

#define BUFF_SIZE 256

extern long lObj;
extern long lLock;


//***************************************************************************
//
//  CLASS NAME:
//
//  CToken
//
//  DESCRIPTION:
//
//  The CToken holds a single token in the provider string
//
//***************************************************************************

class CToken : public CObject {
private:
    long int iOriginalLength;
    long int iOptArrayIndex;
    TString sData;
    TString sFullData;
    CFlexArray Expressions;
public:
	friend class CProvObj;
    CToken(const TCHAR * cpStart,const OLECHAR cDelim, bool bUsesEscapes);
    ~CToken();
    TCHAR const * GetStringValue(void){return sData;};
    TCHAR const * GetFullStringValue(void){return sFullData;};    
    long int GetOrigLength(void){return iOriginalLength;};    
    long int GetIntExp(int iExp,int iArray);    
    long int iConvOprand(const TCHAR * tpCurr, int iArray, long int & dwValue);
    TCHAR const * GetStringExp(int iExp);
    long int GetNumExp(void){return    Expressions.Size();};
    BOOL IsExpString(int iExp);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CProvObj
//
//  DESCRIPTION:
//
//  The CProvObj class holds a an array of CTokens objects which together
//  contain the provider string.
//
//***************************************************************************

class CProvObj : public CObject {
private:
    CToken * GetTokenPointer(int iToken);
    CFlexArray myTokens;
    DWORD dwStatus;
    TCHAR m_cDelim;
    void Init(const TCHAR * ProviderString,const TCHAR cDelim);
    bool m_bUsesEscapes;
public:
    DWORD dwGetStatus(int iMin);
    CProvObj(const WCHAR * ProviderString,const TCHAR cDelim, bool bUsesEscapes);
#ifndef UNICODE
    CProvObj(const char * ProviderString,const TCHAR cDelim, bool bUsesEscapes);
#endif
    const TCHAR * sGetToken(int iToken);
    const TCHAR * sGetFullToken(int iToken);
    const TCHAR * sGetStringExp(int iToken,int iExp);
    long int iGetIntExp(int iToken,int iExp, int iArray);
    BOOL IsExpString(int iToken,int iExp);
    long int iGetNumExp(int iToken);
    long int iGetNumTokens(void) {return myTokens.Size();};
    ~CProvObj(){Empty(); return;};
    void Empty();
    BOOL Update(WCHAR * pwcProvider);

};


//***************************************************************************
//
//  CLASS NAME:
//
//  CEntry and CHandleCache
//
//  DESCRIPTION:
//
//  The CEntry and CHandleCache objects provide an way
//  to cache handles and the path strings associated
//  with them.
//
//***************************************************************************

class CEntry : public CObject {
public:
    CEntry();
    ~CEntry();
    TString sPath;
    HANDLE hHandle;
};
    
class CHandleCache : public CObject {
public:
    ~CHandleCache();
    BOOL IsRemote(void){return bRemote;};
    void SetRemote(BOOL bSet){bRemote = bSet;};
    long int lAddToList(const TCHAR * pAdd, HANDLE hAdd);
    long int lGetNumEntries(void){return List.Size();};
    long int lGetNumMatch(int iStart,int iTokenStart, CProvObj & Path);
    void Delete(long int lStart);
    HANDLE hGetHandle(long int lIndex);
    const TCHAR *  sGetString(long int lIndex);
private:
    CFlexArray List;
    BOOL bRemote;
};
 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\assoc\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAIN.CPP

Abstract:

History:

--*/

#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>

#include "initguid.h"
#include "guid.h"
#include <baseprov.h>
#include "assrule.h"

class CAssocProvider : public CBaseProvider
{
protected:
    CAssocInfoCache m_Cache;

public:
    CAssocProvider(BSTR strNamespace, BSTR strUser, BSTR strPassword);

    HRESULT EnumInstances(BSTR strClass, long lFlags,
                                  IWbemObjectSink* pHandler);
    HRESULT GetInstance(ParsedObjectPath* pPath, long lFlags,
                                  IWbemClassObject** ppInstance);
};

CAssocProvider::CAssocProvider(BSTR strNamespace, BSTR strUser, BSTR strPassword)
: CBaseProvider(strNamespace, strUser, strPassword)
{
    m_Cache.SetNamespace(m_pNamespace);
}

HRESULT CAssocProvider::EnumInstances(BSTR strClass, long lFlags,
                                      IWbemObjectSink* pHandler)
{
    HRESULT hres;

    CAssocRule* pRule;
    hres = m_Cache.GetRuleForClass(strClass, &pRule);
    if(FAILED(hres)) 
    {
        return hres;
    }

    hres = pRule->Produce(m_pNamespace, pHandler);

    return hres;
}

HRESULT CAssocProvider::GetInstance(ParsedObjectPath* pPath, long lFlags,
                                  IWbemClassObject** ppInstance)
{
    return WBEM_E_NOT_FOUND;
}



void DllInitialize()
{
    SetClassInfo(CLSID_AssociationProvider, 
               new CLocatorFactory<CAssocProvider>,
               "Microsoft WBEM Rule-baed association provider",
               TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regereq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEREQ.H

Abstract:

History:

--*/

#ifndef __WBEM_REGEVENT_REQUEST__H_
#define __WBEM_REGEVENT_REQUEST__H_

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include "CWbemTime.h"
#include <tss.h.>
#include <wbemcomn.h>
#include "regedefs.h"

class CRegEventProvider;
class CRegistryEventRequest;
class CRegistryTimerInstruction : public CTimerInstruction
{
    long m_lRef;

    CWbemInterval m_Interval;
    CRegistryEventRequest* m_pReq;

public:
    CRegistryTimerInstruction(CRegistryEventRequest* pReq);
    ~CRegistryTimerInstruction();

    void AddRef();
    void Release();
    int GetInstructionType() {return INSTTYPE_INTERNAL;}

    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const;
    CWbemTime GetFirstFiringTime() const;
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
    
    INTERNAL CRegistryEventRequest* GetRequest() {return m_pReq;}
};

class CRegistryInstructionTest : public CInstructionTest
{
    class CRegistryEventRequest* m_pReq;
public:
    CRegistryInstructionTest(CRegistryEventRequest* pReq) : m_pReq(pReq){}
    BOOL operator()(CTimerInstruction* pToTest);
};

class CRegistryEventRequest
{
protected:
    long m_lRef;
    BOOL m_bOK;

    CRegEventProvider* m_pProvider;
    DWORD m_dwMsWait;

    CFlexArray m_adwIds;

    HKEY m_hHive;
    WString m_wsHive;
    WString m_wsKey;

    HKEY m_hKey;
    HANDLE m_hEvent;
    DWORD m_dwLastCRC;
    long m_lActiveCount;
    BOOL m_bNew;

public:
    CRegistryEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, 
                          HKEY hHive, LPWSTR wszHive, LPWSTR wszKey);
    virtual ~CRegistryEventRequest();
    BOOL IsOK() {return m_bOK;}
    BOOL IsActive() {return m_lActiveCount >= 0;}
    DWORD GetPrimaryId();
    BOOL DoesContainId(DWORD dwId);
    BOOL IsNew() {return m_bNew;}

    void AddRef();
    void Release();

    DWORD GetMsWait() {return m_dwMsWait;}

    HRESULT Activate();
    HRESULT Reactivate(DWORD dwId, DWORD dwMsWait);
    HRESULT Deactivate(DWORD dwId);
    virtual HRESULT Execute(BOOL bOnTimer);
    HANDLE GetOnChangeHandle();
    BOOL ResetOnChangeHandle();
    virtual void CacheValue(){}

    virtual int GetType() = 0;
    virtual HRESULT CreateNewEvent(IWbemClassObject** ppEvent) = 0;
    virtual HRESULT ComputeCRC(DWORD& dwCRC) = 0;

    virtual BOOL IsSameAs(CRegistryEventRequest* pOther);

protected:
    HRESULT SetCommonProperties(IWbemClassObject* pEvent);
};


class CRegistryValueEventRequest : public CRegistryEventRequest
{
protected:

    WString m_wsValue;

public:
    CRegistryValueEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey, LPWSTR wszValue)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey), m_wsValue(wszValue)
    {}

    int GetType() {return e_RegValueChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
    virtual HRESULT Execute(BOOL bOnTimer);
    virtual void CacheValue();
    BOOL IsSameAs(CRegistryEventRequest* pOther);
};

class CRegistryKeyEventRequest : public CRegistryEventRequest
{
public:
    CRegistryKeyEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey)
    {}

    int GetType() {return e_RegKeyChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
};

class CRegistryTreeEventRequest : public CRegistryEventRequest
{
public:
    CRegistryTreeEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey)
    {}

    int GetType() {return e_RegTreeChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regeprov.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEPROV.H

Abstract:

History:

--*/

#ifndef __WBEM_REG_EVENT_PROVIDER__H_
#define __WBEM_REG_EVENT_PROVIDER__H_

#include <windows.h>
#include <wbemidl.h>
#include <stdio.h>
#include "regereq.h"
#include <ql.h>
#include "cfdyn.h"

class CRegEventProvider : public IWbemEventProvider, 
                            public IWbemEventProviderQuerySink,
                            public IWbemEventProviderSecurity,
                            public IWbemProviderInit
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Initialize)(LPWSTR wszUser, long lFlags, LPWSTR wszNamespace,
        LPWSTR wszLocale, IWbemServices* pNamespace, IWbemContext* pCtx,
        IWbemProviderInitSink* pSink);
    STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);

    STDMETHOD(NewQuery)(DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery);
    STDMETHOD(CancelQuery)(DWORD dwId);
    STDMETHOD(AccessCheck)(WBEM_CWSTR wszLanguage, WBEM_CWSTR wszQuery, 
                                long lSidLength, const BYTE* aSid);

protected:
    long m_lRef;

    IWbemClassObject* m_pKeyClass;
    IWbemClassObject* m_pValueClass;
    IWbemClassObject* m_pTreeClass;

    DWORD m_dwId;
    HANDLE m_hThread;
    IWbemObjectSink* m_pSink;

    CUniquePointerArray<CRegistryEventRequest> m_apRequests;
    CRITICAL_SECTION m_cs;
    CTimerGenerator* m_pGenerator;

    HANDLE m_hResyncEvent;

    BOOL* m_pbEnd;

protected:
    static DWORD Worker(void* p);
    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}

    HRESULT GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CWStringArray& awsVals);
    HKEY TranslateHiveName(LPCWSTR wszName);
    HRESULT CycleWorker();
    HRESULT AddRequest(CRegistryEventRequest* pNewReq);

    friend class CRegistryEventRequest;
    friend class CRegistryKeyEventRequest;
    friend class CRegistryValueEventRequest;
    friend class CRegistryTreeEventRequest;
    
public:
    CRegEventProvider();
    ~CRegEventProvider();

    void* GetInterface(REFIID riid);

    HRESULT SetTimerInstruction(CTimerInstruction* pInst);
    HRESULT RemoveTimerInstructions(CRegistryInstructionTest* pTest);
    HRESULT RaiseEvent(IWbemClassObject* pEvent);
};

extern const CLSID CLSID_RegistryEventProvider;

class CRegEventProviderFactory : public CCFDyn
{
public:
    IUnknown* CreateImpObj();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regcrc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGCRC.CPP

Abstract:

History:

--*/

#include "regcrc.h"
#include "tchar.h"

HRESULT CRegCRC::ComputeValueCRC(HKEY hKey, LPCTSTR szValueName, 
                                    DWORD dwPrevCRC, DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Get the size of the value
    // =========================

    DWORD dwSize = 0;
    long lRes = RegQueryValueEx(hKey, szValueName, NULL, NULL, NULL, &dwSize);
    if(lRes)
    {
        return S_FALSE;
    }

    // Get the actual value
    // ====================

    BYTE* pBuffer = new BYTE[dwSize];
    DWORD dwType;
    lRes = RegQueryValueEx(hKey, szValueName, NULL, &dwType, 
                                pBuffer, &dwSize);
    if(lRes)
    {
        return S_FALSE;
    }

    // Hash the type
    // =============

    dwNewCRC = UpdateCRC32((BYTE*)&dwType, sizeof(DWORD), dwNewCRC);

    // Hash the data
    // =============

    dwNewCRC = UpdateCRC32(pBuffer, dwSize, dwNewCRC);

    delete [] pBuffer;

    return S_OK;
}

HRESULT CRegCRC::ComputeKeyValuesCRC(HKEY hKey, DWORD dwPrevCRC, 
                                     DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Get maximum value length
    // ========================

    DWORD dwNumValues, dwMaxValueLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                                &dwNumValues, &dwMaxValueLen, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the values
    // ========================

    for(DWORD dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxValueLen + 1];
        DWORD dwLen = dwMaxValueLen + 1;
        long lRes = RegEnumValue(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);

        // Hash the value
        // ==============

        ComputeValueCRC(hKey, szName, dwNewCRC, dwNewCRC);
        delete [] szName;
    }

    return S_OK;
}

HRESULT CRegCRC::ComputeKeyCRC(HKEY hKey, DWORD dwPrevCRC, 
                                     DWORD& dwNewCRC)
{
    HRESULT hres = ComputeKeyValuesCRC(hKey, dwPrevCRC, dwNewCRC);

    // Get maximum subkey length
    // =========================

    DWORD dwNumKeys, dwMaxKeyLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, 
                                &dwMaxKeyLen, NULL, NULL,
                                NULL, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the subkeys
    // =========================

    for(DWORD dwIndex = 0; dwIndex < dwNumKeys; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxKeyLen + 1];
        DWORD dwLen = dwMaxKeyLen + 1;
        long lRes = RegEnumKeyEx(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);
        delete [] szName;
    }

    return S_OK;
}

HRESULT CRegCRC::ComputeTreeCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Compute this key's CRC
    // ======================

    HRESULT hres = ComputeKeyValuesCRC(hKey, dwNewCRC, dwNewCRC);
    if(FAILED(hres)) return hres;

    // Get maximum subkey length
    // =========================

    DWORD dwNumKeys, dwMaxKeyLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, 
                                &dwMaxKeyLen, NULL, NULL,
                                NULL, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the subkeys
    // =========================

    for(DWORD dwIndex = 0; dwIndex < dwNumKeys; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxKeyLen + 1];
        DWORD dwLen = dwMaxKeyLen + 1;
        long lRes = RegEnumKeyEx(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);

        // Open the subkey
        // ===============

        HKEY hChild;
        lRes = RegOpenKeyEx(hKey, szName, 0, KEY_READ, &hChild);
        delete [] szName; 

        if(lRes)
        {
            continue;
        }
        else
        {
            // Hash the value
            // ==============
    
            ComputeTreeCRC(hChild, dwNewCRC, dwNewCRC);
            RegCloseKey(hChild);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regeprov.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEPROV.CPP

Abstract:

History:

--*/

#include "..\precomp.h"
#include <wbemidl.h>
#include <stdio.h>
#include "cfdyn.h"
#include "stdprov.h"
#include "regeprov.h"
#include <sync.h>
#include <tss.h>
#include <genutils.h>
#include <analyser.h>
#include <cominit.h>
#include <GroupsForUser.h>

CRegEventProvider::CRegEventProvider()
    : m_lRef(0), m_hThread(NULL), m_dwId(NULL), m_pGenerator(NULL),
    m_pKeyClass(NULL), m_pValueClass(NULL), m_pTreeClass(NULL), m_pSink(NULL)
{
    InitializeCriticalSection(&m_cs);
    m_pbEnd = new BOOL(FALSE);
    m_hResyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CRegEventProvider::~CRegEventProvider()
{
    if(m_pSink)
        m_pSink->Release();
    if(m_pKeyClass)
        m_pKeyClass->Release();
    if(m_pValueClass)
        m_pValueClass->Release();
    if(m_pTreeClass)
        m_pTreeClass->Release();

    delete m_pGenerator;
    DeleteCriticalSection(&m_cs);
    InterlockedDecrement(&lObj);
    CloseHandle(m_hResyncEvent);
    CloseHandle(m_hThread);
    delete m_pbEnd;
}

STDMETHODIMP CRegEventProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IWbemEventProvider)
    {
        *ppv = (IWbemEventProvider*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemEventProviderQuerySink)
    {
        *ppv = (IWbemEventProviderQuerySink*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemEventProviderSecurity)
    {
        *ppv = (IWbemEventProviderSecurity*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CRegEventProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CRegEventProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        *m_pbEnd = TRUE;
        m_lRef = 1;
        HANDLE hThread = m_hThread;
        CycleWorker();
        WaitForSingleObject(hThread, 5000);
    }

    return lRef;
}

STDMETHODIMP CRegEventProvider::Initialize(LPWSTR wszUser, long lFlags, 
        LPWSTR wszNamespace,
        LPWSTR wszLocale, IWbemServices* pNamespace, IWbemContext* pCtx,
        IWbemProviderInitSink* pSink)
{
    HRESULT hres = pNamespace->GetObject(REG_KEY_EVENT_CLASS, 0, NULL, 
                                         &m_pKeyClass, NULL);
    hres = pNamespace->GetObject(REG_VALUE_EVENT_CLASS, 0, NULL, 
                                         &m_pValueClass, NULL);
    hres = pNamespace->GetObject(REG_TREE_EVENT_CLASS, 0, NULL, 
                                         &m_pTreeClass, NULL);

    if(IsNT())
    {
        m_hThread = CreateThread(NULL, 0, 
                         (LPTHREAD_START_ROUTINE)&CRegEventProvider::Worker, 
                         this, 0, &m_dwId);
    }
    else
    {
        m_pGenerator = new CTimerGenerator;
    }

    pSink->SetStatus(hres, 0);
    return hres;
}


STDMETHODIMP CRegEventProvider::ProvideEvents(
                                            IWbemObjectSink* pSink, long lFlags)
{
    m_pSink = pSink;
    pSink->AddRef();

    return S_OK;
}

HRESULT CRegEventProvider::AddRequest(CRegistryEventRequest* pNewReq)
{
    // Search for a similar request
    // ============================

    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CRegistryEventRequest* pReq = m_apRequests[i];
        if(pReq->IsActive() && pReq->IsSameAs(pNewReq))
        {
            // Found it!
            // =========

            HRESULT hres = pReq->Reactivate(pNewReq->GetPrimaryId(), 
                                                pNewReq->GetMsWait());
            delete pNewReq;
            return hres;
        }
    }

    // Not found. Add it
    // =================

    HRESULT hres = pNewReq->Activate();
    if(SUCCEEDED(hres))
    {
        m_apRequests.Add(pNewReq);
    }
    return hres;
}
    
STDMETHODIMP CRegEventProvider::NewQuery(DWORD dwId, WBEM_WSTR wszLanguage, 
                                WBEM_WSTR wszQuery)
{
    HRESULT hres;

    // Remove whatever requests we may have had for this id
    // ====================================================

    {
        CInCritSec ics(&m_cs);
    
        // Remove all requests with this Is
        // ================================
    
        for(int i = 0; i < m_apRequests.GetSize(); i++)
        {
            CRegistryEventRequest* pReq = m_apRequests[i];
            if(pReq->DoesContainId(dwId))
            {
                pReq->Deactivate(dwId);
            }
        }
    }
    
    // Parse the query
    // ===============

    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    
    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    if(Parser.Parse(&pExpr))
    {
        return WBEM_E_INVALID_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    // Check the class
    // ===============

    int nEventType;
    if(!_wcsicmp(pExpr->bsClassName, REG_VALUE_EVENT_CLASS))
    {
        nEventType = e_RegValueChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_KEY_EVENT_CLASS))
    {   
        nEventType = e_RegKeyChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_TREE_EVENT_CLASS))
    {
        nEventType = e_RegTreeChange;
    }
    else
    {
        // No such class
        // =============

        return WBEM_E_INVALID_QUERY;
    }

    // Check tolerance on Win95
    // ========================

    if(!IsNT() && pExpr->Tolerance.m_bExact)
    {
        return WBEMESS_E_REGISTRATION_TOO_PRECISE;
    }

    // Extract the values of hive from the query
    // =========================================

    CPropertyName Name;

    Name.AddElement(REG_HIVE_PROPERTY_NAME);
    CWStringArray awsHiveVals;

    hres = GetValuesForProp(pExpr, Name, awsHiveVals);
    if(FAILED(hres)) return hres;

    // Translate them to real hives
    // ============================

    CUniquePointerArray<HKEY> aHives;
    for(int i = 0; i < awsHiveVals.Size(); i++)
    {
        HKEY hHive = TranslateHiveName(awsHiveVals[i]);
        if(hHive == NULL)
        {
            return WBEM_E_INVALID_QUERY;
        }
        
        aHives.Add(new HKEY(hHive));
    }
        
    // Extract the values of key from the query
    // ========================================

    Name.Empty();
    if(nEventType == e_RegTreeChange)
    {
        Name.AddElement(REG_ROOT_PROPERTY_NAME);
    }
    else
    {
        Name.AddElement(REG_KEY_PROPERTY_NAME);
    }

    CWStringArray awsKeyVals;
    hres = GetValuesForProp(pExpr, Name, awsKeyVals);
    if(FAILED(hres)) 
    {
        return hres;
    }
                                      
    CWStringArray awsValueVals;
    if(nEventType == e_RegValueChange)
    {
        // Extract the values for the value
        // ================================
            
        Name.Empty();
        Name.AddElement(REG_VALUE_PROPERTY_NAME);
    
        hres = GetValuesForProp(pExpr, Name, awsValueVals);
        if(FAILED(hres)) 
        {
            return hres;
        }
    }

    HRESULT hresGlobal = WBEM_E_INVALID_QUERY;

    {
        CInCritSec ics(&m_cs); // do this in a critical section

        // Go through every combination of the above and create requests
        // =============================================================
    
        for(int nHiveIndex = 0; nHiveIndex < aHives.GetSize(); nHiveIndex++)
        {
            HKEY hHive = *aHives[nHiveIndex];
            LPWSTR wszHive = awsHiveVals[nHiveIndex];
            
            for(int nKeyIndex = 0; nKeyIndex < awsKeyVals.Size(); nKeyIndex++)
            {
                LPWSTR wszKey = awsKeyVals[nKeyIndex];
    
                if(nEventType == e_RegValueChange)
                {
                    for(int nValueIndex = 0; nValueIndex < awsValueVals.Size();
                            nValueIndex++)
                    {
                        LPWSTR wszValue = awsValueVals[nValueIndex];
        
                        CRegistryEventRequest* pReq = 
                            new CRegistryValueEventRequest(this, 
                                pExpr->Tolerance,
                                dwId, hHive, wszHive, wszKey, wszValue);
    
                        if(pReq->IsOK())
                        {
                            HRESULT hres = AddRequest(pReq);
                            if(SUCCEEDED(hres))
                                hresGlobal = hres;
                        }
                        else
                        {
                            DEBUGTRACE((LOG_ESS, "Invalid registration: key "
                                "%S, value %S\n", wszKey, wszValue));
                            delete pReq;
                        }
                    }
                }
                else
                {
                    // Value-less request
                    // ==================
    
                    CRegistryEventRequest* pReq;
                    if(nEventType == e_RegKeyChange)
                    {
                        pReq = new CRegistryKeyEventRequest(this, 
                                            pExpr->Tolerance,
                                            dwId, hHive, wszHive, wszKey);
                    }   
                    else
                    {
                        pReq = new CRegistryTreeEventRequest(this, 
                                            pExpr->Tolerance,
                                            dwId, hHive, wszHive, wszKey);
                    }   
                    
                    if(pReq->IsOK())
                    {
                        hres = AddRequest(pReq);
                        if(SUCCEEDED(hres))
                            hresGlobal = hres;
                    }
                    else
                    {
                        DEBUGTRACE((LOG_ESS, "Invalid registration: key %S\n", 
                                            wszKey));
                        delete pReq;
                    }
                }
            }
        }

    } // out of critical section

    // Inform the polling thread that it has new work 
    // ==============================================

    CycleWorker();
    
    return hresGlobal;
}

STDMETHODIMP CRegEventProvider::AccessCheck(WBEM_CWSTR wszLanguage, 
                                WBEM_CWSTR wszQuery, 
                                long lSidLength,
                                const BYTE* aSid)
{
    HRESULT hres;

    if(!IsNT())
        return WBEM_S_FALSE;

    PSID pSid = (PSID)aSid;
    HANDLE hToken = NULL;
    if(pSid == NULL)
    {
        //
        // Access check based on the thread
        //

        hres = WbemCoImpersonateClient();
        if(FAILED(hres))
            return hres;
        
        BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, 
                                        &hToken);
        WbemCoRevertToSelf();
        if(!bRes)
        {
            return WBEM_E_ACCESS_DENIED;
        }    
    }
    CCloseMe cm1(hToken);
        
    // Parse the query
    // ===============

    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    
    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    if(Parser.Parse(&pExpr))
    {
        return WBEM_E_INVALID_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    // Check the class
    // ===============

    int nEventType;
    if(!_wcsicmp(pExpr->bsClassName, REG_VALUE_EVENT_CLASS))
    {
        nEventType = e_RegValueChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_KEY_EVENT_CLASS))
    {   
        nEventType = e_RegKeyChange;
    }
    else if(!_wcsicmp(pExpr->bsClassName, REG_TREE_EVENT_CLASS))
    {
        nEventType = e_RegTreeChange;
    }
    else
    {
        // No such class
        // =============

        return WBEM_E_INVALID_QUERY;
    }

    // Extract the values of hive from the query
    // =========================================

    CPropertyName Name;

    Name.AddElement(REG_HIVE_PROPERTY_NAME);
    CWStringArray awsHiveVals;

    hres = GetValuesForProp(pExpr, Name, awsHiveVals);
    if(FAILED(hres)) return hres;

    // Translate them to real hives
    // ============================

    CUniquePointerArray<HKEY> aHives;
    for(int i = 0; i < awsHiveVals.Size(); i++)
    {
        HKEY hHive = TranslateHiveName(awsHiveVals[i]);
        if(hHive == NULL)
        {
            return WBEM_E_INVALID_QUERY;
        }
        
        aHives.Add(new HKEY(hHive));
    }
        
    // Extract the values of key from the query
    // ========================================

    Name.Empty();
    if(nEventType == e_RegTreeChange)
    {
        Name.AddElement(REG_ROOT_PROPERTY_NAME);
    }
    else
    {
        Name.AddElement(REG_KEY_PROPERTY_NAME);
    }

    CWStringArray awsKeyVals;
    hres = GetValuesForProp(pExpr, Name, awsKeyVals);
    if(FAILED(hres)) 
    {
        return hres;
    }
                                      
    HRESULT hresGlobal = WBEM_E_INVALID_QUERY;

    // Go through every combination of the above and create requests
    // =============================================================

    for(int nHiveIndex = 0; nHiveIndex < aHives.GetSize(); nHiveIndex++)
    {
        HKEY hHive = *aHives[nHiveIndex];
        LPWSTR wszHive = awsHiveVals[nHiveIndex];
        
        for(int nKeyIndex = 0; nKeyIndex < awsKeyVals.Size(); nKeyIndex++)
        {
            LPWSTR wszKey = awsKeyVals[nKeyIndex];
        
            // Get that key's security
            // =======================

            HKEY hKey;
            long lRes = RegOpenKeyExW(hHive, wszKey, 0, READ_CONTROL, &hKey);
            if(lRes)
                return WBEM_E_NOT_FOUND;
            CRegCloseMe cm2(hKey);

            DWORD dwLen = 0;
            lRes = RegGetKeySecurity(hKey, 
                        OWNER_SECURITY_INFORMATION | 
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                        NULL,
                        &dwLen);
            if(lRes != ERROR_INSUFFICIENT_BUFFER)
                return WBEM_E_FAILED;

            PSECURITY_DESCRIPTOR pDesc = (PSECURITY_DESCRIPTOR)new BYTE[dwLen];
            if(pDesc == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CVectorDeleteMe<BYTE> vdm((BYTE*)pDesc);

            lRes = RegGetKeySecurity(hKey, 
                        OWNER_SECURITY_INFORMATION | 
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                        pDesc,
                        &dwLen);
            if(lRes)
                return WBEM_E_FAILED;

            //
            // Check permissions differently depending on whether we have a SID
            // or an actual token
            //
            
            if(pSid)
            {
                //
                // We have a SID --- walk the ACL
                //

                //
                // Extract the ACL
                // 

                PACL pAcl = NULL;
                BOOL bAclPresent, bAclDefaulted;
                if(!GetSecurityDescriptorDacl(pDesc, &bAclPresent, &pAcl, 
                        &bAclDefaulted))
                {
                    return WBEM_E_FAILED;
                }
            
                if(bAclPresent)
                {
                    //
                    // This is our own ACL walker
                    //
    
                    DWORD dwAccessMask;
                    NTSTATUS st = GetAccessMask((PSID)pSid, pAcl, 
                                            &dwAccessMask);
                    if(st)
                    {
                        ERRORTRACE((LOG_ESS, "Registry event provider unable "
                            "to retrieve access mask for the creator of "
                            "registration %S: NT status %d.\n"
                            "Registration disabled\n", wszQuery));
                        return WBEM_E_FAILED;
                    }
    
                    if((dwAccessMask & KEY_NOTIFY) == 0)
                        return WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // 
                // We have a token --- use AccessCheck
                //

                //
                // Construct generic mapping for registry keys
                //

                GENERIC_MAPPING map;
                map.GenericRead = KEY_READ;
                map.GenericWrite = KEY_WRITE;
                map.GenericExecute = KEY_EXECUTE;
                map.GenericAll = KEY_ALL_ACCESS;

                //
                // Construct privilege array receptacle
                //

                PRIVILEGE_SET ps[10];
                DWORD dwSize = 10 * sizeof(PRIVILEGE_SET);

                DWORD dwGranted;
                BOOL bResult;

                BOOL bOK = ::AccessCheck(pDesc, hToken, KEY_NOTIFY, &map, ps, 
                                            &dwSize, &dwGranted, &bResult);
                if(!bOK || !bResult)
                    return WBEM_E_ACCESS_DENIED;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CRegEventProvider::CancelQuery(DWORD dwId)
{
    CInCritSec ics(&m_cs);

    // Remove all requests with this Is
    // ================================

    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CRegistryEventRequest* pReq = m_apRequests[i];
        if(pReq->DoesContainId(dwId))
        {
            pReq->Deactivate(dwId);
        }
    }
        
    // Inform the polling thread that it has new work 
    // ==============================================

    CycleWorker();

    return WBEM_S_NO_ERROR;
}

HRESULT CRegEventProvider::CycleWorker()
{
    SetEvent(m_hResyncEvent);
    return S_OK;
}

HRESULT CRegEventProvider::GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CWStringArray& awsVals)
{
    awsVals.Empty();

    // Get the necessary query
    // =======================

    QL_LEVEL_1_RPN_EXPRESSION* pPropExpr;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, 
                            PropName, pPropExpr);
    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        if(Token.nTokenType == QL1_NOT)
        {
            delete pPropExpr;
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
        else if(Token.nTokenType == QL1_AND || Token.nTokenType == QL1_OR)
        {
            // We treat them all as ORs
            // ========================
        }
        else    
        {
            // This is a token
            // ===============

            if(Token.nOperator != QL1_OPERATOR_EQUALS)
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }

            if(V_VT(&Token.vConstValue) != VT_BSTR)
            {
                delete pPropExpr;
                return WBEM_E_INVALID_QUERY;
            }

            // This token is a string equality. Add the string to the list
            // ===========================================================

            awsVals.Add(V_BSTR(&Token.vConstValue));
        }
    }

    delete pPropExpr;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegEventProvider::SetTimerInstruction(CTimerInstruction* pInst)
{
    return m_pGenerator->Set(pInst, CWbemTime::GetZero());
}

HRESULT CRegEventProvider::RemoveTimerInstructions(
                                        CRegistryInstructionTest* pTest)
{
    return m_pGenerator->Remove(pTest);
}

HRESULT CRegEventProvider::RaiseEvent(IWbemClassObject* pEvent)
{
    if(m_pSink)
        return m_pSink->Indicate(1, &pEvent);
    else
        return WBEM_S_NO_ERROR;
}

HKEY CRegEventProvider::TranslateHiveName(LPCWSTR wszName)
{
    if(!_wcsicmp(wszName, L"HKEY_CLASSES_ROOT"))
        return HKEY_CLASSES_ROOT;
/* Disallowed: different semantics for client and server
    else if(!_wcsicmp(wszName, L"HKEY_CURRENT_USER"))
        return HKEY_CURRENT_USER;
*/
    else if(!_wcsicmp(wszName, L"HKEY_LOCAL_MACHINE"))
        return HKEY_LOCAL_MACHINE;
    else if(!_wcsicmp(wszName, L"HKEY_USERS"))
        return HKEY_USERS;
    else if(!_wcsicmp(wszName, L"HKEY_PERFORMANCE_DATA"))
        return HKEY_PERFORMANCE_DATA;
    else if(!_wcsicmp(wszName, L"HKEY_CURRENT_CONFIG"))
        return HKEY_CURRENT_CONFIG;
    else if(!_wcsicmp(wszName, L"HKEY_DYN_DATA"))
        return HKEY_DYN_DATA;
    else
        return NULL;
}

DWORD CRegEventProvider::Worker(void* p)
{
    CRegEventProvider* pThis = (CRegEventProvider*)p;
    BOOL* pbEnd = pThis->m_pbEnd;

    while(!*pbEnd)
    {
        // Construct an array of handles to wait on
        // ========================================

        HANDLE* aHandles = NULL;
        int nNumHandles = 0;

        {
            CInCritSec ics(&pThis->m_cs);

            aHandles = new HANDLE[pThis->m_apRequests.GetSize()+1];
            nNumHandles = 0;
    
            for(int i = 0; i < pThis->m_apRequests.GetSize(); i++)
            {
                CRegistryEventRequest* pReq = pThis->m_apRequests[i];
                if(!pReq->IsActive())
                {
                    pThis->m_apRequests.RemoveAt(i);
                    i--;
                }
                else
                {
                    if(pReq->IsNew())
                        pReq->ResetOnChangeHandle();

                    aHandles[nNumHandles++] = pReq->GetOnChangeHandle();
                }
            }
    
            // Add the standard event
            // ======================
    
            aHandles[nNumHandles++] = pThis->m_hResyncEvent;
        }

        // Wait for something
        // ==================

        DWORD dwRes = WaitForMultipleObjects(nNumHandles, aHandles, FALSE,
                                                INFINITE);
        delete [] aHandles;
        {
            CInCritSec ics(&pThis->m_cs);

            // Check if a resync occurred
            // ==========================
    
            if(dwRes == WAIT_FAILED)
            {
                DEBUGTRACE((LOG_ESS, "CRITICAL ERROR: wait failure!!! Error code %d\n", 
                    GetLastError()));
                Sleep(1000);
                continue;
            }

            if(dwRes == WAIT_OBJECT_0 + nNumHandles - 1 || dwRes == WAIT_FAILED)
            {
                continue;
            }
    
            // Check which handle it is
            // ========================
    
            int nIndex = dwRes - WAIT_OBJECT_0;
            if(nIndex >= 0 || nIndex < nNumHandles)
            {
                CRegistryEventRequest* pReq = pThis->m_apRequests[nIndex];
                if(pReq->IsActive())
                {
                    pReq->ResetOnChangeHandle();
                    pReq->Execute(FALSE);
                }
            }
        }
    }

    // The object signaled to us that it is time to go away
    // ====================================================

    delete pThis;
    return 0;
}

const CLSID CLSID_RegistryEventProvider = 
    {0xfa77a74e,0xe109,0x11d0,{0xad,0x6e,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

IUnknown* CRegEventProviderFactory::CreateImpObj()
{
    return (IWbemEventProvider*) new CRegEventProvider;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\stdprov\regevent\regereq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEREQ.CPP

Abstract:

History:

--*/

#include "..\precomp.h"
#include "regereq.h"
#include "regcrc.h"
#include <genutils.h>
#include "regeprov.h"

//******************************************************************************
//******************************************************************************
//
//                  TIMER INSTRUCTION
//
//******************************************************************************
//******************************************************************************

CRegistryTimerInstruction::CRegistryTimerInstruction(
                                            CRegistryEventRequest* pReq)
             : m_pReq(pReq), m_lRef(0)
{
    pReq->AddRef();
    m_Interval.SetMilliseconds(pReq->GetMsWait());
}
          
CRegistryTimerInstruction::~CRegistryTimerInstruction()
{
    m_pReq->Release();
}

void CRegistryTimerInstruction::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CRegistryTimerInstruction::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}

CWbemTime CRegistryTimerInstruction::GetNextFiringTime(CWbemTime LastFiringTime,
                                    OUT long* plFiringCount) const
{
    CWbemTime Next = LastFiringTime + m_Interval;
    if(Next < CWbemTime::GetCurrentTime())
    {
        return CWbemTime::GetCurrentTime() + m_Interval;
    }
    else
    {
        return Next;
    }
}

CWbemTime CRegistryTimerInstruction::GetFirstFiringTime() const
{
    return CWbemTime::GetCurrentTime() + m_Interval;
}

HRESULT CRegistryTimerInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    m_pReq->Execute(TRUE);
    return S_OK;
}

//******************************************************************************
//******************************************************************************
//
//                  TIMER INSTRUCTION
//
//******************************************************************************
//******************************************************************************

BOOL CRegistryInstructionTest::operator()(CTimerInstruction* pToTest)
{
    CRegistryTimerInstruction* pRegInst = (CRegistryTimerInstruction*)pToTest;
    return (pRegInst->GetRequest() == m_pReq);
}

//******************************************************************************
//******************************************************************************
//
//                      GENERIC REQUEST
//
//******************************************************************************
//******************************************************************************



CRegistryEventRequest::CRegistryEventRequest(CRegEventProvider* pProvider,
                                    WBEM_QL1_TOLERANCE& Tolerance, 
                                    DWORD dwId, HKEY hHive, LPWSTR wszHive,
                                    LPWSTR wszKey)
        : m_hHive(hHive), m_wsKey(wszKey), m_pProvider(pProvider),
            m_wsHive(wszHive), m_lActiveCount(0), m_bNew(TRUE),
            m_lRef(0), m_bOK(TRUE), m_dwLastCRC(0), m_hKey(NULL), m_hEvent(NULL)
{
    if(Tolerance.m_bExact)
    {
        m_dwMsWait = 0;
    }
    else
    {
        m_dwMsWait = Tolerance.m_fTolerance * 1000;
    }

    m_adwIds.Add((void*)dwId);
}

CRegistryEventRequest::~CRegistryEventRequest()
{
    RegCloseKey(m_hKey);
    if(m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
}

void CRegistryEventRequest::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CRegistryEventRequest::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0) delete this;
}

BOOL CRegistryEventRequest::IsSameAs(CRegistryEventRequest* pOther)
{
    if(GetType() != pOther->GetType())
        return FALSE;

    if(m_hHive != pOther->m_hHive)
        return FALSE;

    if(!m_wsHive.EqualNoCase(pOther->m_wsHive))
        return FALSE;

    if(!m_wsKey.EqualNoCase(pOther->m_wsKey))
        return FALSE;

    return TRUE;
}


DWORD CRegistryEventRequest::GetPrimaryId()
{
    return (DWORD)m_adwIds[0];
}

BOOL CRegistryEventRequest::DoesContainId(DWORD dwId)
{
    for(int i = 0; i < m_adwIds.Size(); i++)
    {
        if((DWORD)m_adwIds[i] == dwId)
            return TRUE;
    }
    return FALSE;
}

HRESULT CRegistryEventRequest::Reactivate(DWORD dwId, DWORD dwMsWait)
{
    if(m_dwMsWait > dwMsWait)
        m_dwMsWait = dwMsWait;

    m_adwIds.Add((void*)dwId);

    if(InterlockedIncrement(&m_lActiveCount) > 0)
    {
        if(!IsNT())
        {
            // Cancel and re-create the timer instruction
            // ==========================================

            CRegistryInstructionTest Test(this);
            m_pProvider->RemoveTimerInstructions(&Test);
    
            CRegistryTimerInstruction* pInst = 
                new CRegistryTimerInstruction(this);
            pInst->AddRef();
    
            m_pProvider->SetTimerInstruction(pInst);
            DEBUGTRACE((LOG_ESS, "Registry provider setting timer instruction to %d ms\n", m_dwMsWait));
        }
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return Activate();
    }
}

HRESULT CRegistryEventRequest::Activate()
{
    // Open the key
    // ============

#ifdef UNICODE
    long lRes = RegOpenKeyEx(m_hHive, m_wsKey, 0, KEY_READ, &m_hKey);
#else
    LPSTR szName = m_wsKey.GetLPSTR();
    long lRes = RegOpenKeyEx(m_hHive, szName, 0, KEY_READ, &m_hKey);
    delete [] szName;
#endif

    if(lRes)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // If not NT, create and schedule the timer instruction
    // ====================================================

    if(!IsNT())
    {
        ComputeCRC(m_dwLastCRC);

        CRegistryTimerInstruction* pInst = 
            new CRegistryTimerInstruction(this);
        pInst->AddRef();

        m_pProvider->SetTimerInstruction(pInst);
        DEBUGTRACE((LOG_ESS, "Registry provider setting timer instruction to %d ms\n", m_dwMsWait));
    }
    else
    {
        // Create an event
        // ===============

        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        // It will be connected to the key by the notification thread
        // ==========================================================

        m_bNew = TRUE;

        CacheValue();
    }

    return S_OK;
}

BOOL CRegistryEventRequest::ResetOnChangeHandle()
{
    m_bNew = FALSE;
    long lRes = RegNotifyChangeKeyValue(m_hKey, 
            (GetType() == e_RegTreeChange), 
            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET | 
                REG_NOTIFY_CHANGE_ATTRIBUTES, 
            m_hEvent, TRUE);
    return (lRes == 0);
}

HANDLE CRegistryEventRequest::GetOnChangeHandle() 
{
    return m_hEvent;
}

HRESULT CRegistryEventRequest::Deactivate(DWORD dwId)
{
    // Remove the ID from the list
    // ===========================

    for(int i = 0; i < m_adwIds.Size(); i++)
    {
        if((DWORD)m_adwIds[i] == dwId)
        {
            m_adwIds.RemoveAt(i);
            break;
        }
    }

    if(InterlockedDecrement(&m_lActiveCount) >= 0)
        return WBEM_S_FALSE;

    // If not NT, remove the timer instruction
    // =======================================

    if(!IsNT())
    {
        CRegistryInstructionTest Test(this);
        m_pProvider->RemoveTimerInstructions(&Test);
    }

    return S_OK;
}

HRESULT CRegistryEventRequest::Execute(BOOL bOnTimer)
{
    // If called by the timer, we need to check if anything actually changed
    // =====================================================================

    if(bOnTimer || GetType() == e_RegValueChange)
    {
        DWORD dwNewCRC;
        HRESULT hres = ComputeCRC(dwNewCRC);
        if(FAILED(hres))
        {
            return hres;
        }
        if(dwNewCRC == m_dwLastCRC)
        {
            // No real change. Return
            // ======================

            return S_FALSE;
        }

        m_dwLastCRC = dwNewCRC;
    }

    // If here, a real change has occurred
    // ===================================

    IWbemClassObject* pEvent;

    HRESULT hres = CreateNewEvent(&pEvent);
    if(FAILED(hres))
    {
        return hres;
    }

    hres = m_pProvider->RaiseEvent(pEvent);
    pEvent->Release();
    return hres;
}

HRESULT CRegistryEventRequest::SetCommonProperties(IWbemClassObject* pEvent)
{
    // Set the hive name
    // =================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsHive);
    pEvent->Put(REG_HIVE_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    return WBEM_S_NO_ERROR;
}


//******************************************************************************
//******************************************************************************
//
//                          VALUE REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryValueEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    m_pProvider->m_pValueClass->SpawnInstance(0, &pEvent);

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the key
    // ===========

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_KEY_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    // Set the value
    // =============

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsValue);
    pEvent->Put(REG_VALUE_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryValueEventRequest::ComputeCRC(DWORD& dwCRC)
{
#ifdef UNICODE
    HRESULT hres = CRegCRC::ComputeValueCRC(m_hKey, m_wsValue, 
                        STARTING_CRC32_VALUE, dwCRC);
#else
    LPSTR szValue = m_wsValue.GetLPSTR();
    HRESULT hres = CRegCRC::ComputeValueCRC(m_hKey, szValue, 
                        STARTING_CRC32_VALUE, dwCRC);
    delete [] szValue;
#endif
    return hres;
}

HRESULT CRegistryValueEventRequest::Execute(BOOL bOnTimer)
{
    // Since NT does not allow per-value change registration, CRC needs to be
    // computed no matter what
    // ======================================================================

    return CRegistryEventRequest::Execute(TRUE);
}

void CRegistryValueEventRequest::CacheValue()
{
    ComputeCRC(m_dwLastCRC);
}

BOOL CRegistryValueEventRequest::IsSameAs(CRegistryEventRequest* pOther)
{
    if(!CRegistryEventRequest::IsSameAs(pOther))
        return FALSE;

    CRegistryValueEventRequest* pValueOther = 
        (CRegistryValueEventRequest*)pOther;

    if(!m_wsValue.EqualNoCase(pValueOther->m_wsValue))
        return FALSE;

    return TRUE;
}

    
//******************************************************************************
//******************************************************************************
//
//                          KEY REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryKeyEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    m_pProvider->m_pKeyClass->SpawnInstance(0, &pEvent);

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the key
    // ===========

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_KEY_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryKeyEventRequest::ComputeCRC(DWORD& dwCRC)
{
    HRESULT hres = CRegCRC::ComputeKeyCRC(m_hKey, STARTING_CRC32_VALUE, dwCRC);
    return hres;
}
    
//******************************************************************************
//******************************************************************************
//
//                          TREE REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryTreeEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    m_pProvider->m_pTreeClass->SpawnInstance(0, &pEvent);

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the root
    // ============

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_ROOT_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryTreeEventRequest::ComputeCRC(DWORD& dwCRC)
{
    HRESULT hres = CRegCRC::ComputeTreeCRC(m_hKey, STARTING_CRC32_VALUE, dwCRC);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\arena.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ARENA.H

Abstract:

    Standard Arena allocators.

History:

    a-raymcc    23-Apr-96

--*/

#ifndef _ALLOC_H_
#define _ALLOC_H_

#include "corepol.h"

class POLARITY CArena
{
    virtual LPVOID Alloc(SIZE_T dwBytes) = 0;
    virtual LPVOID Realloc(LPVOID pOriginal, SIZE_T dwNewSize) = 0;
    virtual BOOL   Free(LPVOID) = 0;
};

class POLARITY CWin32DefaultArena : public CArena
{
public:

    CWin32DefaultArena() {}
    ~CWin32DefaultArena() {}

    //  Allocates dwBytes of memory using the standard WBEM allocator
    LPVOID Alloc(SIZE_T dwBytes) {return WbemMemAlloc(dwBytes);}

    //  Reallocates the block from Alloc using the standard WBEM allocator
    LPVOID Realloc(LPVOID pOriginal, SIZE_T dwNewSize) 
    {return WbemMemReAlloc(pOriginal, dwNewSize);}

    //  Frees the block of memory from Alloc or Realloc using the standard
    //  WBEM allocator
    BOOL   Free(LPVOID pBlock) {return WbemMemFree(pBlock);}

    //
    // sets the heap used by the allocation functions.  Will return false 
    // if one is already set.  Most likely this function will be called at 
    // module initialization, such as DllMain.  Calling this function 
    // is optional when -- 1 ) You can accept using the ProcessHeap and 
    // 2 ) You are guaranteed that no allocations will occur before 
    // static initialization has occurred in this module.
    //
    static BOOL WbemHeapInitialize( HANDLE hHeap );
    static void WbemHeapFree( );

	//	Explicitly define as __cdecl as these are causing backwards compatibility
	//	issues WbemMemAlloc, WbemMemFree and WbemMemSize

    //  This is the main allocator for the whole of WinMgmt.  All parts
    //  of WinMgmt which allocate memory through HeapAlloc and the
    //  the likes should use this instead
    static LPVOID __cdecl WbemMemAlloc(SIZE_T dwBytes);

    //  This is the main allocator for the whole of WinMgmt.  This
    //  reallocates a block returned through WbemMemAlloc
    static LPVOID WbemMemReAlloc(LPVOID pOriginal, SIZE_T dwNewSize);

    //  This is the main allocator for the whole of WinMgmt.  This
    //  frees up a block returned through WbemMemAlloc or WbemMemReAlloc.
    static BOOL __cdecl WbemMemFree(LPVOID pBlock) ;

    static BSTR WbemSysAllocString(const wchar_t *wszString);
    static BSTR WbemSysAllocStringByteLen(const char *szString, UINT len);
    static INT  WbemSysReAllocString(BSTR *, const wchar_t *wszString);
    static BSTR WbemSysAllocStringLen(const wchar_t *wszString, UINT);
    static int  WbemSysReAllocStringLen(BSTR *, const wchar_t *wszString, UINT);
    static void WbemSysFreeString(BSTR bszString) {SysFreeString(bszString);}

    static BOOL WbemOutOfMemory();

    //Returns the size of an allocated block
    static SIZE_T __cdecl WbemMemSize(LPVOID pBlock);

    //  Makes sure there is probably enough virtual memory available to
    //  carry out an operation.
    static BOOL ValidateMemSize(BOOL bLargeValidation = FALSE);

    static BOOL WriteHeapHint();
    static void Compact();

    // Allows validation calls
    static BOOL ValidateHeap( DWORD dwFlags, LPCVOID lpMem );

	//
	static HANDLE GetArenaHeap();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\buffer.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef __BUFFER_H__
#define __BUFFER_H__

#include "corepol.h"

/************************************************************************
  CBuffer
*************************************************************************/

class POLARITY CBuffer : public IStream
{
    long m_cRefs;
    PBYTE m_pData;
    ULONG m_cData;
    ULONG m_iData;
    BOOL m_bDelete;

    void EnsureSize( ULONG ulSize );

public:

    CBuffer( PBYTE pData=NULL, ULONG cData=0, BOOL bDelete=TRUE );
    CBuffer& operator= ( const CBuffer& );
    CBuffer( const CBuffer& );
    ~CBuffer();

    void Reset() { m_iData = 0; }
    ULONG GetIndex() { return m_iData; }
    ULONG GetSize() { return m_cData; }
    PBYTE GetRawData() { return m_pData; }
    
    HRESULT SetSize( ULONG ulSize )
    {
        ULARGE_INTEGER uliSize;
        uliSize.LowPart = ulSize;
        uliSize.HighPart = 0;
        return SetSize( uliSize );
    }

    HRESULT Advance( ULONG ulMove )
    {
        LARGE_INTEGER dlibMove;
        dlibMove.LowPart = ulMove;
        dlibMove.HighPart = 0;
        return Seek( dlibMove, STREAM_SEEK_CUR, NULL );
    }

    HRESULT ReadLPWSTR( LPCWSTR& rwszStr );
    HRESULT WriteLPWSTR( LPCWSTR wszStr );

    //
    // IUnknown
    //

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    //
    // ISequentialStream
    //

    STDMETHOD(Read)( void *pv, ULONG cb, ULONG *pcbRead );

    STDMETHOD(Write)( const void *pv, ULONG cb, ULONG *pcbWritten);

    //
    // IStream
    //

    STDMETHOD(Seek)( LARGE_INTEGER dlibMove, 
                     DWORD dwOrigin,
                     ULARGE_INTEGER *plibNewPosition );

    STDMETHOD(SetSize)( ULARGE_INTEGER libNewSize );
 
    STDMETHOD(CopyTo)( IStream *pstm,
                       ULARGE_INTEGER cb,
                       ULARGE_INTEGER *pcbRead,
                       ULARGE_INTEGER *pcbWritten );

    STDMETHOD(Commit)( DWORD grfCommitFlags ) { return E_NOTIMPL; }

    STDMETHOD(Revert)( void) { return E_NOTIMPL; }

    STDMETHOD(LockRegion)( ULARGE_INTEGER libOffset,
                           ULARGE_INTEGER cb,
                           DWORD dwLockType ) { return E_NOTIMPL; }

    STDMETHOD(UnlockRegion)( ULARGE_INTEGER libOffset,
                             ULARGE_INTEGER cb,
                             DWORD dwLockType ) { return E_NOTIMPL; }

    STDMETHOD(Stat)( STATSTG *pstatstg, DWORD grfStatFlag );

    STDMETHOD(Clone)( IStream **ppstm );
};


#endif __BUFFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\arena.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "genutils.h"
#include "arena.h"
#include "sync.h"
#include "reg.h"
#include "arrtempl.h"

#define STARTUP_HEAP_HINT_REGVAL_W L"Startup Heap Preallocation Size"

static HANDLE g_hHeap = NULL;

static class DefaultInitializer
{
public:
    DefaultInitializer() 
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }
} g_hDefaultInitializer;

BOOL CWin32DefaultArena::WbemHeapInitialize( HANDLE hHeap )
{
    if ( g_hHeap != NULL )
    {
        return FALSE;
    }
    g_hHeap = hHeap;
    return TRUE;
}

void CWin32DefaultArena::WbemHeapFree()
{
    if ( g_hHeap == NULL )
    {
        return;
    }
	if (g_hHeap != GetProcessHeap())
	    HeapDestroy(g_hHeap);
	g_hHeap = NULL;
    return;
}

//
//***************************************************************************

LPVOID CWin32DefaultArena::WbemMemAlloc(SIZE_T dwBytes)
{
    if ( g_hHeap == NULL )
        return NULL;

    return HeapAlloc( g_hHeap, 0, dwBytes);
}

//***************************************************************************
//
//***************************************************************************

LPVOID CWin32DefaultArena::WbemMemReAlloc(LPVOID pOriginal, SIZE_T dwNewSize)
{   
    if ( g_hHeap == NULL )
        return NULL;
    return HeapReAlloc( g_hHeap, 0, pOriginal, dwNewSize);
}

//***************************************************************************
//
//***************************************************************************

BOOL CWin32DefaultArena::WbemMemFree(LPVOID pBlock)
{
    if ( g_hHeap == NULL )
        return FALSE;
	if (pBlock==0)
		return TRUE;
    return HeapFree( g_hHeap, 0, pBlock);
}

//***************************************************************************
//
//***************************************************************************

SIZE_T CWin32DefaultArena::WbemMemSize(LPVOID pBlock)
{
    if ( g_hHeap == NULL )
        return 0;
    return HeapSize( g_hHeap, 0, pBlock);
}

//***************************************************************************
//
//***************************************************************************

BSTR CWin32DefaultArena::WbemSysAllocString(const wchar_t *wszString)
{
    if ( g_hHeap == NULL )
        return NULL;
    BSTR pBuffer = SysAllocString(wszString);

    return pBuffer;
}

//***************************************************************************
//
//***************************************************************************


BSTR CWin32DefaultArena::WbemSysAllocStringByteLen(const char *szString, UINT len)
{
    if ( g_hHeap == NULL )
        return NULL;
	BSTR pBuffer = SysAllocStringByteLen(szString, len);

	return pBuffer;
}

//***************************************************************************
//
//****************************************************************************

INT  CWin32DefaultArena::WbemSysReAllocString(BSTR *bszString, const wchar_t *wszString)
{
    if ( g_hHeap == NULL )
        return FALSE;
	INT nRet = SysReAllocString(bszString, wszString);

	return nRet;
}

//***************************************************************************
//
//***************************************************************************


BSTR CWin32DefaultArena::WbemSysAllocStringLen(const wchar_t *wszString, UINT len)
{
    if ( g_hHeap == NULL )
        return NULL;
	BSTR pBuffer = SysAllocStringLen(wszString, len);

	return pBuffer;
}

//***************************************************************************
//
//***************************************************************************


int CWin32DefaultArena::WbemSysReAllocStringLen( BSTR *bszString, 
                                                 const wchar_t *wszString, 
                                                 UINT nLen)
{
    if ( g_hHeap == NULL )
        return FALSE;
    INT nRet = SysReAllocStringLen(bszString, wszString, nLen);
    
    return nRet;
}

//***************************************************************************
//
//***************************************************************************


BOOL CWin32DefaultArena::WbemOutOfMemory()
{
    return FALSE;
}

BOOL CWin32DefaultArena::ValidateMemSize(BOOL bLargeValidation)
{
    if ( g_hHeap == NULL )
        return FALSE;
    MEMORYSTATUS memBuffer;
    memset(&memBuffer, 0, sizeof(MEMORYSTATUS));
    memBuffer.dwLength = sizeof(MEMORYSTATUS);
    DWORD dwMemReq = 0;

    if (bLargeValidation)
        dwMemReq = 0x400000;    //4MB
    else
        dwMemReq = 0x200000;    //2MB

    GlobalMemoryStatus(&memBuffer);

    if (memBuffer.dwAvailPageFile >= dwMemReq)
    {
        return TRUE;
    }

    static CCritSec cs;
    try
    {
        cs.Enter();
    }
    catch(...)
    {
        return FALSE;
    }
    //THIS ABSOLUTELY HAS TO BE HeapAlloc, and not the WBEM Allocator!!!
    LPVOID pBuff = HeapAlloc( g_hHeap, 0, dwMemReq);
    //THIS ABSOLUTELY HAS TO BE HeapAlloc, and not the WBEM Allocator!!!
    if (pBuff == NULL)
    {
        cs.Leave();
        return FALSE;
    }

    HeapFree( g_hHeap, 0, pBuff);

    GlobalMemoryStatus(&memBuffer);

    cs.Leave();

    if (memBuffer.dwAvailPageFile >= dwMemReq)
    {
        return TRUE;
    }

    return FALSE;
}

HANDLE CWin32DefaultArena::GetArenaHeap()
{
	return g_hHeap;
}

BOOL CWin32DefaultArena::WriteHeapHint()
{
    if ( g_hHeap == NULL )
        return FALSE;

    //
    // Don't bother if not on NT.  We will use internal NT APIs
    //

    if(!IsNT())
        return FALSE;

    //
    // Don't bother if running in a client --- only WinMgmt uses hints
    //

    if(!IsWinMgmt())
        return FALSE;

    //
    // In WinMgmt. Walk the heap to calculate total size
    //

    PROCESS_HEAP_ENTRY entry;
    entry.lpData = NULL;

    DWORD dwTotalAllocations = 0;
    while(HeapWalk( g_hHeap, &entry))
    {
        if(entry.wFlags & PROCESS_HEAP_ENTRY_BUSY)
        {
            //
            // Allocated block. Add both it's size and its overhead to the total
            // We want the overhead since it figures into the total required
            // commitment.
            //

            dwTotalAllocations += entry.cbData + entry.cbOverhead;
        }
    }

    //
    // Write the total to the registry.  Note that we write this data even if
    // startup preallocations are disabled, since they may be enabled before
    // WinMgmt starts up the next time
    //

    HKEY hKey;
    long lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT, 0,
                                KEY_SET_VALUE, &hKey);
    if(lRes)
        return FALSE;
    CRegCloseMe cm1(hKey);

    lRes = RegSetValueExW(hKey, STARTUP_HEAP_HINT_REGVAL_W, 0,
                REG_DWORD, (const BYTE*)&dwTotalAllocations, sizeof(DWORD));
    if(lRes)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\arrtempl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ARRTEMPL.H

Abstract:

    This file defines a simple template for an array of arbitrary pointers.
    Actual growing array functionality is provided by CFlexArray.

    Classes defined:

        template CPointerArray

History:

    11/27/96    a-levn      Compiles.

--*/

#ifndef __ARRAY_TEMPLATE__H_
#define __ARRAY_TEMPLATE__H_

#pragma warning(disable:4786)

#include <map>
#include <strutils.h>


using namespace std;
class wcsless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

class wcsiless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wbem_wcsicmp(wcs1, wcs2) < 0;}
};


class CReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    CReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~CReleaseMe() { release();}
    void release() { if(m_pUnk) m_pUnk->Release(); m_pUnk=0;}
};

template<class T>
class CTemplateReleaseMe
{
protected:
    T* m_p;

public:
    CTemplateReleaseMe(T* p) : m_p(p){}
    ~CTemplateReleaseMe() { release();}
    void release(){ if(m_p) m_p->Release();m_p=0;}
};

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p = NULL) : m_p(p){}
    ~CDeleteMe() {delete m_p;}

    //  overwrites the previous pointer, does NOT delete it
    void operator= (T* p) {m_p = p;}
};

class CCloseMe
{
protected:
    HANDLE m_h;
public:
    CCloseMe(HANDLE hToClose){m_h = hToClose;};
    ~CCloseMe(){if(m_h && m_h != INVALID_HANDLE_VALUE)CloseHandle(m_h);};
};

class CfcloseMe
{
protected:
    FILE * m_h;
public:
    CfcloseMe(FILE * ToClose){m_h = ToClose;};
    ~CfcloseMe(){if(m_h != NULL)fclose(m_h);};
};

typedef CCloseMe CCloseHandle;

class CRegCloseMe
{
protected:
    HKEY m_h;
public:
    CRegCloseMe(HKEY hToClose){m_h = hToClose;};
    ~CRegCloseMe(){if(m_h)RegCloseKey(m_h);};
};

template<class T>
class CVectorDeleteMe
{
protected:
    T* m_p;
    T** m_pp;

public:
    CVectorDeleteMe(T* p) : m_p(p), m_pp(NULL){}
    CVectorDeleteMe(T** pp) : m_p(NULL), m_pp(pp){}
    ~CVectorDeleteMe() {if(m_p) delete [] m_p; else if(m_pp) delete [] *m_pp;}
};

class CClearMe
{
protected:
    VARIANT* m_pv;

public:
    CClearMe(VARIANT* pv) : m_pv(pv){}
    ~CClearMe() {VariantClear(m_pv);}
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() { if ( NULL != m_str ) SysFreeString(m_str);}
};

class CUnaccessMe
{
protected:
    SAFEARRAY* m_psa;
public:
    CUnaccessMe(SAFEARRAY* psa) : m_psa(psa){}
    ~CUnaccessMe() {SafeArrayUnaccessData(m_psa);}
};

class CMemFreeMe
{
protected:
    void*	m_pMem;
public:
    CMemFreeMe( void* pMem ) : m_pMem(pMem){}
    ~CMemFreeMe() { if ( NULL != m_pMem ) CoTaskMemFree(m_pMem);}
};

#include <arena.h>
#include <flexarry.h>
#include <flexq.h>
#include <smallarr.h>

//*****************************************************************************
//
//  class CPointerArray
//
//  Array of pointers to TMember, where TMember is any class. See CFlexArray
//  in coredll\flexarry.h/cpp for documentation.
//
//*****************************************************************************

template <class TMember>
class CNullManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember*){}
};

template <class TMember, class TManager = CNullManager<TMember>,
                class TArray = CFlexArray>
class CPointerArray
{
protected:
    TArray m_Array;
    TManager m_Manager;
public:
    CPointerArray(const TManager& Manager = TManager())
        : m_Manager(Manager){}
    ~CPointerArray();

     int GetSize() const
        {return m_Array.Size();}
     void SetSize(int nNewSize)
        {m_Array.SetSize(nNewSize);}
     const TMember* GetAt(int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* GetAt(int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     const TMember* operator[](int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* operator[](int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     void SetAt(int nIndex, TMember* pElement, TMember** ppOld = NULL);
     void Discard(int nIndex);
     bool RemoveAt(int nIndex, TMember** ppOld = NULL);
     bool InsertAt(int nIndex, TMember* pElement);
     int Add(TMember* pElement);
     TMember** GetArrayPtr();
     TMember** UnbindPtr();
     void RemoveAll();
     void Swap(int nIndex1, int nIndex2);
     void Trim() {m_Array.Trim();}

protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};

template<class TMember>
class CPointerSmallArray :
        public CPointerArray<TMember, CNullManager<TMember>, CSmallArray>
{
};

//*****************************************************************************
//
//  class CPointerQueue
//
//  Queue of pointers to TMember, where TMember is any class. See CFlexQueue
//  in coredll\flexq.h/cpp for documentation.
//
//*****************************************************************************
template <class TMember, class TManager = CNullManager<TMember> >
class CPointerQueue
{
protected:
    CFlexQueue m_Queue;
    TManager m_Manager;
public:
    CPointerQueue(int nInitialSize = 1, const TManager& Manager = TManager())
        : m_Manager(Manager), m_Queue(nInitialSize){}
    void Clear();
    ~CPointerQueue()
        {Clear();}

    inline int GetQueueSize() const
        {return m_Queue.GetQueueSize();}

    bool Enqueue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Enqueue(pNew);
    }
    TMember* Dequeue()
    {
        TMember* p = (TMember*)m_Queue.Dequeue();
        return p;
    }
    bool Requeue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Requeue(pNew);
    }
    TMember* Unqueue()
    {
        TMember* p = (TMember*)m_Queue.Unqueue();
        AddRefElement(p);
        return p;
    }
protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};


//*****************************************************************************
//
//  UNIQUE POINTER ARRAY
//
//*****************************************************************************

template <class TMember>
class CUniqueManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember* pMember) {delete pMember;}
};

template<class TMember>
class CUniquePointerArray :
        public CPointerArray<TMember, CUniqueManager<TMember> >
{
};

template<class TMember>
class CUniquePointerSmallArray :
        public CPointerArray<TMember, CUniqueManager<TMember>, CSmallArray>
{
};

template<class TMember>
class CUniquePointerQueue :
        public CPointerQueue<TMember, CUniqueManager<TMember> >
{
public:
    CUniquePointerQueue<TMember>(int nInitialSize = 1)
        : CPointerQueue<TMember, CUniqueManager<TMember> >(nInitialSize)
    {}
};

//*****************************************************************************
//
//  REFED POINTER ARRAY
//
//*****************************************************************************
template <class TMember>
class CReferenceManager
{
public:
    void AddRefElement(TMember* pMember) {if(pMember)pMember->AddRef();}
    void ReleaseElement(TMember* pMember) {if(pMember)pMember->Release();}
};

template<class TMember>
class CRefedPointerArray :
        public CPointerArray<TMember, CReferenceManager<TMember> >
{
};

template<class TMember>
class CRefedPointerSmallArray :
        public CPointerArray<TMember, CReferenceManager<TMember>, CSmallArray>
{
};

template<class TMember>
class CRefedPointerQueue :
        public CPointerQueue<TMember, CReferenceManager<TMember> >
{
public:
    CRefedPointerQueue(int nInitialSize = 1)
        : CPointerQueue<TMember, CReferenceManager<TMember> >(nInitialSize)
    {}
};

//*****************************************************************************
//
//  ARRAY OF UNIQUE ARRAYS
//
//*****************************************************************************

template <class TMember>
class CUniqueArrayManager
{
    void AddRefElement(TMember**){}
    void ReleaseElement(TMember** pMember) {delete [] pMember;}
};
template<class TMember>
class CUniqueArrayArray : public CPointerArray<TMember,
                                               CUniqueArrayManager<TMember> >
{
};

//*****************************************************************************
//
//  IMPLEMENTATION
//
//*****************************************************************************

template <class TMember, class TManager, class TArray>
CPointerArray<TMember, TManager, TArray>::~CPointerArray()
{
    RemoveAll();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::RemoveAll()
{
    for(int i = 0; i < m_Array.Size(); i++)
    {
        //
        // Remove it from array before releasing --- otherwise for a moment 
        // there we have a garbage pointer in array!
        //
        
        TMember* p = GetAt(i);
        m_Array.SetAt(i, NULL);
        ReleaseElement(p);
    }
    m_Array.Empty();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::SetAt(int nIndex,
                                            TMember* pElement, TMember** ppOld)
{
    AddRefElement(pElement);

    //
    // Remove it from array before releasing --- otherwise for a moment 
    // there we have a garbage pointer in array!
    //

    TMember* pOld = GetAt(nIndex);
    m_Array.SetAt(nIndex, (void*)pElement);
    
    if(ppOld == NULL)
        ReleaseElement(pOld);
    else
        *ppOld = pOld;
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::Discard(int nIndex)
{
    m_Array.SetAt(nIndex, NULL);
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::RemoveAt(int nIndex,
                                                        TMember** ppOld)
{
    //
    // Remove it from array before releasing --- otherwise for a moment 
    // there we have a garbage pointer in array!
    //

    TMember* pOld = GetAt(nIndex);
    if(m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
        return false;

    if(ppOld == NULL)
        ReleaseElement(pOld);
    else
        *ppOld = pOld;

    return true;
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::InsertAt(int nIndex,
                                                        TMember* pElement)
{
    if(m_Array.InsertAt(nIndex, (void*)pElement) != CFlexArray::no_error)
        return false;

    AddRefElement(pElement);
    return true;
}

template <class TMember, class TManager, class TArray>
int CPointerArray<TMember, TManager, TArray>::Add(TMember* pElement)
{
    if(m_Array.Add((void*)pElement) != CFlexArray::no_error)
        return -1;

    AddRefElement(pElement);
    return m_Array.Size()-1;
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::GetArrayPtr()
{
    return (TMember**)m_Array.GetArrayPtr();
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::UnbindPtr()
{
    return (TMember**)m_Array.UnbindPtr();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::Swap(int nIndex1, int nIndex2)
{
    void* pTemp = m_Array[nIndex1];
    m_Array.SetAt(nIndex1, m_Array[nIndex2]);
    m_Array.SetAt(nIndex2, pTemp);
}

template <class TMember, class TManager>
void CPointerQueue<TMember, TManager>::Clear()
{
    TMember* p;
    while(p = (TMember*)m_Queue.Dequeue())
    {
        ReleaseElement(p);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\buffer.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "buffer.h"
#include "comutl.h"

/************************************************************************
  CBuffer
*************************************************************************/

CBuffer::CBuffer( PBYTE pData, ULONG cData, BOOL bDelete )
: m_pData(pData), m_cData(cData), m_bDelete(bDelete), m_iData(0), m_cRefs(0)
{

}

CBuffer::~CBuffer()
{
    if ( m_bDelete )
    {
        delete [] m_pData;
    }
}

CBuffer::CBuffer( const CBuffer& rOther )
: m_pData(NULL), m_cData(0), m_bDelete(FALSE), m_iData(0), m_cRefs(0)
{
    *this = rOther;
}

CBuffer& CBuffer::operator= ( const CBuffer& rOther )
{
    EnsureSize( rOther.m_iData );
    memcpy( m_pData, rOther.m_pData, m_iData );
    return *this;
}

void CBuffer::EnsureSize( ULONG ulSize )
{
    if ( ulSize <= m_cData )
    {
        return;
    }

    ULONG cData = m_cData*2 > ulSize ? m_cData*2 : ulSize + 256;

    BYTE* pData = new BYTE[cData];
    
    if ( pData == NULL ) 
    {
        throw CX_MemoryException();
    }
    
    memcpy( pData, m_pData, m_iData ); 

    if ( m_bDelete )
    {
        delete [] m_pData; 
    }

    m_bDelete = TRUE;
    m_cData = cData;
    m_pData = pData;
}


HRESULT CBuffer::ReadLPWSTR( LPCWSTR& rwszStr )
{
    HRESULT hr;
    ULONG cStr;

    hr = Read( &cStr, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return hr;
    }

    if ( m_cData-m_iData < cStr )
    {
        return S_FALSE;
    }

    rwszStr = LPCWSTR(m_pData+m_iData);

    m_iData += cStr;

    return S_OK;
}

HRESULT CBuffer::WriteLPWSTR( LPCWSTR wszStr )
{
    HRESULT hr;

    //
    // ensure that the packed string's length is divisible by sizeof WCHAR.
    // this makes it easier to ensure that all strings in the message are 
    // at least aligned appropriately.
    //

    DWORD cStr = (wcslen(wszStr) + 1)*2; // in bytes
    DWORD cPad = cStr%2;
    DWORD cPackedStr = cStr + cPad;

    hr = Write( &cPackedStr, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = Write( wszStr, cStr, NULL );

    if ( SUCCEEDED(hr) )
    {
        hr = Advance( cPad );
    }

    return hr;
}

ULONG CBuffer::AddRef()
{
    return InterlockedIncrement( &m_cRefs );
}

ULONG CBuffer::Release()
{
    ULONG cRefs = InterlockedDecrement( &m_cRefs );

    if ( cRefs == 0 )
    {
        delete this;
    }

    return cRefs;
}

STDMETHODIMP CBuffer::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;

    if ( riid==IID_IStream || 
         riid==IID_ISequentialStream ||
         riid==IID_IUnknown )
    {
        *ppv = (IStream*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP CBuffer::Read( void *pv, ULONG cb, ULONG *pcbRead )
{
    ULONG cRead = cb > m_cData-m_iData ? m_cData-m_iData : cb; 
    
    memcpy( pv, m_pData + m_iData, cRead );

    if ( pcbRead != NULL )
    {
        *pcbRead = cRead;
    }
    
    m_iData += cRead;
    
    return cRead == cb ? S_OK : S_FALSE;
}

STDMETHODIMP CBuffer::Write( const void *pv, ULONG cb, ULONG *pcbWritten )
{
    ENTER_API_CALL

    HRESULT hr;

    if ( pcbWritten != NULL )
    {
        *pcbWritten = 0;
    }

    EnsureSize( m_iData + cb );
    memcpy( m_pData + m_iData, pv, cb );
    
    m_iData += cb;

    if ( pcbWritten != NULL )
    {
        *pcbWritten = cb;
    }

    return S_OK;

    EXIT_API_CALL
}

STDMETHODIMP CBuffer::Seek( LARGE_INTEGER dlibMove, 
                            DWORD dwOrigin,
                            ULARGE_INTEGER *plibNewPosition )
{
    ENTER_API_CALL 

    HRESULT hr;
    
    __int64 i64Data;
    __int64 i64Move = dlibMove.QuadPart;

    if ( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = m_iData;
    }

    if ( dwOrigin == STREAM_SEEK_SET )
    {
        i64Data = 0;
    }
    else if ( dwOrigin == STREAM_SEEK_CUR  )
    {
        i64Data = m_iData;
    }
    else if ( dwOrigin == STREAM_SEEK_END )
    {
        i64Data = m_cData;
    }
    else
    {
        return STG_E_INVALIDFUNCTION;   
    }

    i64Data += i64Move;

    EnsureSize( ULONG(i64Data) );

    m_iData = ULONG(i64Data);

    if ( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = i64Data;
    }

    return S_OK;

    EXIT_API_CALL
}

STDMETHODIMP CBuffer::SetSize( ULARGE_INTEGER libNewSize )
{
    ENTER_API_CALL
    EnsureSize( libNewSize.LowPart );
    return S_OK;
    EXIT_API_CALL
}

STDMETHODIMP CBuffer::CopyTo( IStream *pstm,
                              ULARGE_INTEGER cb,
                              ULARGE_INTEGER *pcbRead,
                              ULARGE_INTEGER *pcbWritten )
{
    ENTER_API_CALL

    HRESULT hr;
    ULONG cRead, cWritten;

    if ( pcbRead != NULL )
    {
        pcbRead->QuadPart = 0;
    }

    cRead = cb.LowPart > m_cData-m_iData ? m_cData-m_iData : cb.LowPart;
    
    hr = pstm->Write( m_pData + m_iData, cRead, &cWritten ); 

    if ( pcbWritten != NULL )
    {
        pcbWritten->QuadPart = cWritten;
    }

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    m_iData += cRead;

    if ( pcbRead != NULL )
    {
        pcbRead->QuadPart = cRead;
    }

    return hr;

    EXIT_API_CALL
}
        
STDMETHODIMP CBuffer::Stat( STATSTG* pstatstg, DWORD grfStatFlag )
{
    if ( pstatstg == NULL )
    {
        return STG_E_INVALIDPOINTER;
    }

    ZeroMemory( pstatstg, sizeof(STATSTG) );

    pstatstg->cbSize.LowPart = m_cData;

    return S_OK;
}

STDMETHODIMP CBuffer::Clone( IStream **ppstm )
{
    ENTER_API_CALL

    BYTE* pData = new BYTE[m_cData];
    
    if ( pData == NULL )
    {
        return E_OUTOFMEMORY;
    }

    CBuffer* pNew;

    try 
    {
        pNew = new CBuffer( pData, m_cData );
    }
    catch( CX_MemoryException )
    {
        delete pData;
        throw;
    }

    if ( pNew == NULL ) // just in case we don't have a new which throws on OOM
    {
        delete pData;    
        return E_OUTOFMEMORY;
    }

    pNew->m_iData = m_iData;

    return pNew->QueryInterface( IID_IStream, (void**)ppstm );

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\callsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

    IWbemCallSecurity, IServerSecurity implementation for
    provider impersonation.

History:

    raymcc      29-Jul-98        First draft.

--*/

#include "precomp.h"
#include <stdio.h>

#include <initguid.h>
#include <winntsec.h>
#include <callsec.h>
#include <cominit.h>
#include <arrtempl.h>
#include <cominit.h>
#include <genutils.h>

//***************************************************************************
//
//  CWbemCallSecurity
//
//  This object is used to supply client impersonation to providers.
//
//  Usage:
//  (1) When client first makes call, call CreateInst() and get a new
//      empty object (ref count of 1).  Constructors/Destructors are private.
//  
//***************************************************************************
// ok

CWbemCallSecurity::CWbemCallSecurity()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&os);
    if (os.dwPlatformId != VER_PLATFORM_WIN32_NT)
        m_bWin9x = TRUE;
    else
        m_bWin9x = FALSE;                       

    m_lRef = 1;                             // Ref count

    m_hThreadToken = 0;                     // Handle to thread imp token

    m_dwPotentialImpLevel   = 0;            // Potential 
    m_dwActiveImpLevel      = 0;            // Active impersonation

    m_dwAuthnSvc   = 0;
    m_dwAuthzSvc   = 0;
    m_dwAuthnLevel = 0;

    m_pServerPrincNam = 0;
    m_pIdentity = 0;
}



//***************************************************************************
//
//  ~CWbemCallSecurity
//
//  Destructor.  Closes any open handles, deallocates any non-NULL
//  strings.
//
//***************************************************************************
// ok

CWbemCallSecurity::~CWbemCallSecurity()
{
    if (m_hThreadToken)
        CloseHandle(m_hThreadToken);

    if (m_pServerPrincNam)
        CoTaskMemFree(m_pServerPrincNam);

    if (m_pIdentity)
        CoTaskMemFree(m_pIdentity);
}

void 
CWbemCallSecurity::operator=(const CWbemCallSecurity& Other)
{
    if(m_hThreadToken)
	{
        CloseHandle(m_hThreadToken);
	    m_hThreadToken=NULL ;
	}

	if ( Other.m_hThreadToken )
	{
		DuplicateHandle(
				GetCurrentProcess(),
				Other.m_hThreadToken, 
				GetCurrentProcess(),
				&m_hThreadToken,
				0,
				TRUE,
				DUPLICATE_SAME_ACCESS);
	}

    m_dwPotentialImpLevel   = Other.m_dwPotentialImpLevel; 
    m_dwActiveImpLevel      = 0; 

    m_dwAuthnSvc   = Other.m_dwAuthnSvc;
    m_dwAuthzSvc   = Other.m_dwAuthzSvc;
    m_dwAuthnLevel = Other.m_dwAuthnLevel;

    if(m_pServerPrincNam)
    {
        CoTaskMemFree(m_pServerPrincNam);
        m_pServerPrincNam = NULL;
    }

    if (Other.m_pServerPrincNam)
    {        
        m_pServerPrincNam = (LPWSTR)CoTaskMemAlloc(
                (wcslen(Other.m_pServerPrincNam) + 1) * 2);
        if(m_pServerPrincNam)
            wcscpy(m_pServerPrincNam, Other.m_pServerPrincNam);
    }

    if(m_pIdentity)
    {
        CoTaskMemFree(m_pIdentity);
        m_pIdentity = NULL;
    }

    if (Other.m_pIdentity)
    {        
        m_pIdentity = (LPWSTR)CoTaskMemAlloc(
                (wcslen(Other.m_pIdentity) + 1) * 2);
        if(m_pIdentity)
            wcscpy(m_pIdentity, Other.m_pIdentity);
    }
}
    
//***************************************************************************
//
//  CWbemCallSecurity::AddRef
//
//***************************************************************************
// ok

ULONG CWbemCallSecurity::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CWbemCallSecurity::Release
//
//***************************************************************************
// ok

ULONG CWbemCallSecurity::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CWbemCallSecurity::QueryInterface
//
//***************************************************************************
// ok

HRESULT CWbemCallSecurity::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IServerSecurity)
    {
        *ppv = (IServerSecurity *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemCallSecurity)
    {
        *ppv = (IWbemCallSecurity *) this;
        AddRef();
        return S_OK;
    }

    else return E_NOINTERFACE;
}


//***************************************************************************
//
// CWbemCallSecurity:QueryBlanket
//
//***************************************************************************
// ok

HRESULT STDMETHODCALLTYPE CWbemCallSecurity::QueryBlanket( 
    /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
    /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
    /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
    /* [out] */ DWORD __RPC_FAR *pImpLevel,
    /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
    /* [out] */ DWORD __RPC_FAR *pCapabilities
    )
{
    if (m_bWin9x)
        return E_NOTIMPL;

    if (m_dwPotentialImpLevel == 0 )
        return E_FAIL;

    // Return DWORD parameters, after checking.
    // ========================================

    if (pAuthnSvc)
        *pAuthnSvc = m_dwAuthnSvc;

    if (pAuthzSvc)
        *pAuthzSvc = m_dwAuthzSvc ;

    if (pImpLevel)
        *pImpLevel = m_dwActiveImpLevel ;

    if (pAuthnLevel)
        *pAuthnLevel = m_dwAuthnLevel;

    if (pServerPrincName)
    {
        *pServerPrincName = 0;
        
        if (m_pServerPrincNam)
        {        
            *pServerPrincName = (LPWSTR) CoTaskMemAlloc((wcslen(m_pServerPrincNam) + 1) * 2);
            wcscpy(*pServerPrincName, m_pServerPrincNam);
        }
    }        

    if (pPrivs)
    {
        *pPrivs = m_pIdentity;  // Documented to point to an internal!!
    }

    return S_OK;
}

//***************************************************************************
//
//  CWbemCallSecurity::ImpersonateClient
//
//***************************************************************************
// ok
        
HRESULT STDMETHODCALLTYPE CWbemCallSecurity::ImpersonateClient(void)
{
    if (m_bWin9x)
        return E_NOTIMPL;

    if (m_dwActiveImpLevel != 0)        // Already impersonating
        return S_OK;

	if(m_hThreadToken == NULL)
	{
		return WBEM_E_INVALID_CONTEXT;
	}
	
    if (m_dwPotentialImpLevel == 0)
        return (ERROR_CANT_OPEN_ANONYMOUS | 0x80070000);

    BOOL bRes;

    bRes = SetThreadToken(NULL, m_hThreadToken);

    if (bRes)
    {
        m_dwActiveImpLevel = m_dwPotentialImpLevel; 
        return S_OK;
    }

    return E_FAIL;
}


//***************************************************************************
//
//  CWbemCallSecurity::RevertToSelf
//
//  Returns S_OK or E_FAIL.
//  Returns E_NOTIMPL on Win9x platforms.
//
//***************************************************************************        
// ok

HRESULT STDMETHODCALLTYPE CWbemCallSecurity::RevertToSelf( void)
{
    if (m_bWin9x)
        return E_NOTIMPL;

    if (m_dwActiveImpLevel == 0)
        return S_OK;

    if (m_dwPotentialImpLevel == 0)
        return (ERROR_CANT_OPEN_ANONYMOUS | 0x80070000);

    // If here,we are impersonating and can definitely revert.
    // =======================================================

    BOOL bRes = SetThreadToken(NULL, NULL);

    if (bRes == FALSE)
        return E_FAIL;

    m_dwActiveImpLevel = 0;        // No longer actively impersonating

    return S_OK;
}


//***************************************************************************
//
//  CWbemCallSecurity::IsImpersonating
//
//***************************************************************************
        
BOOL STDMETHODCALLTYPE CWbemCallSecurity::IsImpersonating( void)
{
    if (m_hThreadToken && m_dwActiveImpLevel != 0)
        return TRUE;

    return FALSE;
}

        

//***************************************************************************
//
//  CWbemCallSecurity::CreateInst
//
//  Creates a new instance 
//***************************************************************************
// ok

IWbemCallSecurity * CWbemCallSecurity::CreateInst()
{
    return (IWbemCallSecurity *) new CWbemCallSecurity;   // Constructed with ref count of 1
}


//***************************************************************************
//
//  CWbemCallSecurity::GetPotentialImpersonation
//
//  Returns 0 if no impersonation is currently possible or the
//  level which would be active during impersonation:
//
//  RPC_C_IMP_LEVEL_ANONYMOUS    
//  RPC_C_IMP_LEVEL_IDENTIFY     
//  RPC_C_IMP_LEVEL_IMPERSONATE  
//  RPC_C_IMP_LEVEL_DELEGATE     
//  
//***************************************************************************
// ok

HRESULT CWbemCallSecurity::GetPotentialImpersonation()
{
    return m_dwPotentialImpLevel;
}


//***************************************************************************
//
//  CWbemCallSecurity::GetActiveImpersonation
//
//  Returns 0 if no impersonation is currently active or the
//  currently active level:
//
//  RPC_C_IMP_LEVEL_ANONYMOUS    
//  RPC_C_IMP_LEVEL_IDENTIFY     
//  RPC_C_IMP_LEVEL_IMPERSONATE  
//  RPC_C_IMP_LEVEL_DELEGATE     
//  
//***************************************************************************
// ok
       
HRESULT CWbemCallSecurity::GetActiveImpersonation()
{
    return m_dwActiveImpLevel;
}


//***************************************************************************
//
//  CWbemCallSecurity::CloneThreadContext
//
//  Call this on a thread to retrieve the potential impersonation info for
//  that thread and set the current object to be able to duplicate it later.
//
//  Return codes:
//
//  S_OK
//  E_FAIL
//  E_NOTIMPL on Win9x
//  E_ABORT if the calling thread is already impersonating a client.
//
//***************************************************************************

HRESULT CWbemCallSecurity::CloneThreadContext(BOOL bInternallyIssued)
{

    // If on Win9x, don't bother.
    // ==========================

    if (m_bWin9x)
        return E_NOTIMPL;

    if (m_hThreadToken)     // Already called this
        return E_ABORT; 

    // Get the current context.
    // ========================

    IServerSecurity *pSec = 0;
    HRESULT hRes = WbemCoGetCallContext(IID_IServerSecurity, (LPVOID *) &pSec);
    CReleaseMe rmSec(pSec);

    if (hRes != S_OK)
    {
        // There is no call context --- this must be an in-proc object calling
        // us from its own thread.  Initialize from current thread token
        // ===================================================================

        return CloneThreadToken();
    }

    // Figure out if the call context is ours or RPCs
    // ==============================================

    IWbemCallSecurity* pInternal = NULL;
    if(SUCCEEDED(pSec->QueryInterface(IID_IWbemCallSecurity, 
                                        (void**)&pInternal)))
    {
        CReleaseMe rmInt(pInternal);
        // This is our own call context --- this must be ab in-proc object
        // calling us from our thread.  Behave depending on the flags
        // ===============================================================
        if(bInternallyIssued)
        {
            // Internal requests always propagate context. Therefore, we just
            // copy the context that we have got
            // ==============================================================

            *this = *(CWbemCallSecurity*)pInternal;
            return S_OK;
        }
        else
        {
            // Provider request --- Initialize from the current thread token
            // =============================================================
            return CloneThreadToken();
        }
    }

    // If here, we are not impersonating and we want to gather info
    // about the client's call.
    // ============================================================

    RPC_AUTHZ_HANDLE hAuth;

    // Ensures auto release of the mutex if we crash
    CAutoSecurityMutex  autosm;

	DWORD t_ImpLevel = 0 ;

    hRes = pSec->QueryBlanket(
        &m_dwAuthnSvc,
        &m_dwAuthzSvc,
        &m_pServerPrincNam,
        &m_dwAuthnLevel,
        &t_ImpLevel,
        &hAuth,              // RPC_AUTHZ_HANDLE
        NULL                    // Capabilities; not used
        );

    if(FAILED(hRes))
    {
        
        // In some cases, we cant get the name, but the rest is ok.  In particular
        // the temporary SMS accounts have that property.  Or nt 4 after IPCONFIG /RELEASE

        hRes = pSec->QueryBlanket(
        &m_dwAuthnSvc,
        &m_dwAuthzSvc,
        &m_pServerPrincNam,
        &m_dwAuthnLevel,
        &t_ImpLevel,
        NULL,              // RPC_AUTHZ_HANDLE
        NULL                    // Capabilities; not used
        );
        hAuth = NULL;
    }

    // We don't need this anymore.
    autosm.Release();

    if(FAILED(hRes))
    {
        // THIS IS A WORKAROUND FOR COM BUG:
        // This failure is indicative of an anonymous-level client. 
        // ========================================================

        m_dwPotentialImpLevel = 0;
        return S_OK;
    }
        
    if (hAuth)
    {
        m_pIdentity = LPWSTR(CoTaskMemAlloc((wcslen(LPWSTR(hAuth)) + 1) * 2));
        if(m_pIdentity)
            wcscpy(m_pIdentity, LPWSTR(hAuth));
    }

    // Impersonate the client long enough to clone the thread token.
    // =============================================================

    BOOL bImp = pSec->IsImpersonating();
    if(!bImp)
        hRes = pSec->ImpersonateClient();

    if (FAILED(hRes))
    {
        if(!bImp)
            pSec->RevertToSelf();
        return E_FAIL;
    }

    HRESULT hres = CloneThreadToken();

    if(!bImp)
        pSec->RevertToSelf();

    return hres;
}



    
HRESULT CWbemCallSecurity::CloneThreadToken()
{
	HANDLE hPrimary = 0 ;
    HANDLE hToken = 0;

    BOOL bRes = OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        TRUE,
        &hToken
        );

    if (bRes == FALSE)
    {
        m_hThreadToken = NULL;
        m_dwAuthnSvc = RPC_C_AUTHN_WINNT;
        m_dwAuthzSvc = RPC_C_AUTHZ_NONE;
        m_dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        m_pServerPrincNam = NULL;
        m_pIdentity = NULL;

        long lRes = GetLastError();
        if(lRes == ERROR_NO_IMPERSONATION_TOKEN || lRes == ERROR_NO_TOKEN)
        {
            // This is the basic process thread. 
            // =================================

			bRes = OpenProcessToken(

				GetCurrentProcess(),
				TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
				&hPrimary
			);

			if (bRes==FALSE)
			{
	            // Unknown error
    	        // =============
				m_dwPotentialImpLevel = 0;
				return E_FAIL;
			}
        }
        else if(lRes == ERROR_CANT_OPEN_ANONYMOUS)
        {
            // Anonymous call   
            // ==============

            m_dwPotentialImpLevel = 0;
            return S_OK;
        }
        else
        {
            // Unknown error
            // =============

            m_dwPotentialImpLevel = 0;
            return E_FAIL;
        }
    }


    // Find out token info.
    // =====================

	SECURITY_IMPERSONATION_LEVEL t_Level = SecurityImpersonation ;

	if ( hToken )
	{
		DWORD dwBytesReturned = 0;

		bRes = GetTokenInformation (

			hToken,
			TokenImpersonationLevel, 
			( void * ) & t_Level,
			sizeof ( t_Level ),
			&dwBytesReturned
		);

		if (bRes == FALSE)
		{
			CloseHandle(hToken);
			return E_FAIL;
		}
	}

    switch (t_Level)
    {
        case SecurityAnonymous:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
            break;
            
        case SecurityIdentification:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            break;

        case SecurityImpersonation:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            break;

        case SecurityDelegation:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
            break;

        default:
            m_dwPotentialImpLevel = 0;
            break;
    }

    // Duplicate the handle.
    // ============================

    bRes = DuplicateToken (
        hToken ? hToken : hPrimary ,
        (SECURITY_IMPERSONATION_LEVEL)t_Level,
        &m_hThreadToken
        );

	if ( hToken )
	{
		CloseHandle(hToken);
	}
	else
	{
		CloseHandle(hPrimary);
	}

    if (bRes == FALSE)
        return E_FAIL;

    return S_OK;
}

RELEASE_ME CWbemCallSecurity* CWbemCallSecurity::MakeInternalCopyOfThread()
{
    IServerSecurity* pSec;
    HRESULT hres = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pSec);
    if(FAILED(hres))
        return NULL;

    CReleaseMe rm1(pSec);

    IServerSecurity* pIntSec;
    hres = pSec->QueryInterface(IID_IWbemCallSecurity, (void**)&pIntSec);
    if(FAILED(hres))
        return NULL;

    CWbemCallSecurity* pCopy = new CWbemCallSecurity;
    
    if (pCopy)
        *pCopy = *(CWbemCallSecurity*)pIntSec;

    pIntSec->Release();
    return pCopy;
}
        

DWORD CWbemCallSecurity::GetAuthenticationId(LUID& rluid)
{
    if(m_hThreadToken == NULL)
        return ERROR_INVALID_HANDLE;

    TOKEN_STATISTICS stat;
    DWORD dwRet;
    if(!GetTokenInformation(m_hThreadToken, TokenStatistics, 
            (void*)&stat, sizeof(stat), &dwRet))
    {
        return GetLastError();
    }
    
    rluid = stat.AuthenticationId;
    return 0;
}
    
HANDLE CWbemCallSecurity::GetToken()
{
    return m_hThreadToken;
}
    

//***************************************************************************
//
//***************************************************************************

void CWbemCallSecurity::DumpCurrentContext()
{
    if (m_bWin9x)
        return;

    HANDLE hThreadToken;

    BOOL bRes = OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        TRUE,
        &hThreadToken
        );

    if (!bRes)
        return;

    const DWORD dwBytes = 512;
    BYTE Buf[dwBytes], Name[dwBytes], Domain[dwBytes];
    DWORD dwBytesReturned = 0, dwDomainSize = dwBytes, dwNameSize = dwBytes;
        
    GetTokenInformation(hThreadToken, TokenUser, Buf, dwBytes, &dwBytesReturned);

    SID_NAME_USE snu;

    SetThreadToken(NULL, NULL);

    bRes = LookupAccountSidW(NULL, ((PTOKEN_USER) Buf)->User.Sid, LPWSTR(Name), &dwNameSize,
        LPWSTR(Domain), &dwDomainSize, &snu);

    SetThreadToken(NULL, hThreadToken);

    printf("User = %S\\%S\n", Domain, Name);

    CloseHandle(hThreadToken);    
}

        

CDerivedObjectSecurity::CDerivedObjectSecurity() 
{
    m_bValid = FALSE;
    m_bEnabled = TRUE;

    if(!IsNT() || !IsDcomEnabled())
    {
        m_bEnabled = FALSE;
        m_bValid = TRUE;
    }
   
    HRESULT hres = RetrieveSidFromCall(&m_sidUser);
    if(FAILED(hres))
        return;

    // Revert to self while remebering the thread token
    // ================================================

    BOOL bRes;
    HANDLE hThreadToken = NULL;
    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ | TOKEN_IMPERSONATE,
                            TRUE, &hThreadToken);

    if(bRes)
        SetThreadToken(NULL, NULL);

    // Open process token
    // ==================

    HANDLE hProcessToken;
    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, 
                                    &hProcessToken);
    if(!bRes)
    {
        if(hThreadToken)
            CloseHandle(hThreadToken);
        return;
    }

    // Retrieve our process SID
    // ========================

    hres = RetrieveSidFromToken(hProcessToken, &m_sidSystem);
    CloseHandle(hProcessToken);

    // Re-impersonate the original thread token
    // ========================================

    if(hThreadToken)
    {
        SetThreadToken(NULL, hThreadToken);
        CloseHandle(hThreadToken);
    }


    if(FAILED(hres))
        return;

    m_bValid = TRUE;
}

HRESULT CDerivedObjectSecurity::RetrieveSidFromCall(CNtSid* psid)
{
    HANDLE hToken;
    HRESULT hres;
    BOOL bRes;

    // Check if we are on an impersonated thread
    // =========================================

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        // We are --- just use this token for authentication
        // =================================================
        hres = RetrieveSidFromToken(hToken, psid);
        CloseHandle(hToken);
        return hres;
    }

    // Construct CWbemCallSecurity that will determine (according to our
    // non-trivial provider handling rules) the security context of this 
    // call
    // =================================================================

    IWbemCallSecurity* pServerSec = CWbemCallSecurity::CreateInst();
    if(pServerSec == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CReleaseMe rm1(pServerSec);

    hres = pServerSec->CloneThreadContext(FALSE);
    if(FAILED(hres))
        return hres;

    // Impersonate client
    // ==================

    hres = pServerSec->ImpersonateClient();
    if(FAILED(hres))
        return hres;

    // Open impersonated token
    // =======================

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(!bRes)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_NO_IMPERSONATION_TOKEN || lRes == ERROR_NO_TOKEN)
        {
            // Not impersonating --- get the process token instead
            // ===================================================

            bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
            if(!bRes)
            {
                pServerSec->RevertToSelf();
                return WBEM_E_ACCESS_DENIED;
            }
        }
        else
        {
            // Real problems
            // =============
            pServerSec->RevertToSelf();
            return WBEM_E_ACCESS_DENIED;
        }
    }

    hres = RetrieveSidFromToken(hToken, psid);
    CloseHandle(hToken);
    pServerSec->RevertToSelf();
    return hres;
}

HRESULT CDerivedObjectSecurity::RetrieveSidFromToken(HANDLE hToken, 
                                                    CNtSid* psid)
{
    // Retrieve the length of the user sid structure
    // =============================================

    BOOL bRes;

    DWORD dwLen = 0;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenUser,  &tu, sizeof(TOKEN_USER), &dwLen);
    DWORD dwLast = GetLastError();
    if(bRes)
    {
        // 1-length sid? I don't think so
        return WBEM_E_CRITICAL_ERROR;
    }

    // Allocate buffer to hold user sid
    // ================================

    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
        
    CVectorDeleteMe<BYTE> dm1(pBuffer);

    // Retrieve the user sid structure
    // ===============================

    bRes = GetTokenInformation(hToken, TokenUser, pBuffer, dwLen, &dwLen);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    
    TOKEN_USER* pUser = (TOKEN_USER*)pBuffer;
    
    // Set our sid to the returned one
    // ===============================

    *psid = CNtSid(pUser->User.Sid);
    
    return WBEM_S_NO_ERROR;
}

          

    
CDerivedObjectSecurity::~CDerivedObjectSecurity()
{
}

BOOL CDerivedObjectSecurity::AccessCheck()
{
    if(!m_bValid)
        return FALSE;

    if(!m_bEnabled)
        return TRUE;

    // Find out who is calling
    // =======================

    CNtSid sidCaller;
    HRESULT hres = RetrieveSidFromCall(&sidCaller);
    if(FAILED(hres))
        return FALSE;

    // Compare the caller to the issuing user and ourselves
    // ====================================================

    if(sidCaller == m_sidUser || sidCaller == m_sidSystem)
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\callsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:

    IWbemCallSecurity, IServerSecurity implementation for
    provider impersonation.

History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _CALLSEC_H_
#define _CALLSEC_H_

#include "parmdefs.h"

// {2ECF39D0-2B26-11d2-AEC8-00C04FB68820}
DEFINE_GUID(IID_IWbemCallSecurity, 
0x2ecf39d0, 0x2b26, 0x11d2, 0xae, 0xc8, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


class IWbemCallSecurity : public IServerSecurity
{
public:
    virtual HRESULT GetPotentialImpersonation() = 0;
        // Tells what the impersonation level would be if
        // this object were applied to a thread.
        
    virtual HRESULT GetActiveImpersonation() = 0;
        // Tells the true level of impersonation in the
        // executing thread.

    virtual HRESULT CloneThreadContext(BOOL bInternallyIssued) = 0;
        // Called to clone the execution context of the calling thread.
    virtual DWORD GetAuthenticationId(LUID& rluid) = 0; 
    virtual HANDLE GetToken() = 0;
};


//***************************************************************************
//
//  CWbemCallSecurity
//
//  This object is used to supply client impersonation to providers.
//
//***************************************************************************

class POLARITY CWbemCallSecurity : public IWbemCallSecurity
{
    LONG    m_lRef;                     // COM ref count
    HANDLE  m_hThreadToken;             // Client token for impersonation

    BOOL    m_bWin9x;                   // TRUE if on a Win9x platform

    DWORD   m_dwPotentialImpLevel;      // Potential RPC_C_IMP_LEVEL_ or 0
    DWORD   m_dwActiveImpLevel;         // Active RPC_C_IMP_LEVEL_ or 0
    

    // IServerSecurity::QueryBlanket values
    
    DWORD   m_dwAuthnSvc;               // Authentication service 
    DWORD   m_dwAuthzSvc;               // Authorization service
    DWORD   m_dwAuthnLevel;             // Authentication level
    LPWSTR  m_pServerPrincNam;          // 
    LPWSTR  m_pIdentity;                // User identity
    
    CWbemCallSecurity();
   ~CWbemCallSecurity();

    void operator=(const CWbemCallSecurity& Other);
    HRESULT CloneThreadToken();

public:
    static IWbemCallSecurity * CreateInst();
    const wchar_t *GetCallerIdentity() { return m_pIdentity; } 
    void DumpCurrentContext();
    virtual DWORD GetAuthenticationId(LUID& rluid);
    virtual HANDLE GetToken();

    // IUnknown.
    // =========

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();        
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);


    // IServerSecurity.
    // ================

    virtual HRESULT STDMETHODCALLTYPE QueryBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities
            );
        
    virtual HRESULT STDMETHODCALLTYPE ImpersonateClient( void);
        
    virtual HRESULT STDMETHODCALLTYPE RevertToSelf( void);
        
    virtual BOOL STDMETHODCALLTYPE IsImpersonating( void);
        


    // IWbemCallSecurity methods.
    // ============================

    virtual HRESULT GetPotentialImpersonation();
        // Tells what the impersonation level would be if
        // this object were applied to a thread.
        
    virtual HRESULT GetActiveImpersonation();
        // Tells the true level of impersonation in the
        // executing thread.

    virtual HRESULT CloneThreadContext(BOOL bInternallyIssued);
        // Called to clone the execution context of the calling thread.
        
    static RELEASE_ME CWbemCallSecurity* MakeInternalCopyOfThread();
};
            

class POLARITY CDerivedObjectSecurity
{
protected:
    CNtSid m_sidUser;
    CNtSid m_sidSystem;
    BOOL m_bValid;
    BOOL m_bEnabled;

protected:
    static HRESULT RetrieveSidFromToken(HANDLE hTokeni, CNtSid* psid);
public:
    CDerivedObjectSecurity();
    ~CDerivedObjectSecurity();

    static HRESULT RetrieveSidFromCall(CNtSid* psid);
    BOOL AccessCheck();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\cimval.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

 
#include "precomp.h"
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <wbemcli.h>
#include "cimval.h"

BOOL SecondsToInterval( long double ldbSeconds, LPWSTR wszText )
{
    int nDay, nHour, nMinute, nSecond, nMicro;

    nDay = int(ldbSeconds / 86400);
    ldbSeconds -= nDay * 86400;
    nHour = int(ldbSeconds / 3600);
    ldbSeconds -= nHour * 3600;
    nMinute = int(ldbSeconds / 60);
    ldbSeconds -= nMinute * 60;
    nSecond = int(ldbSeconds);
    ldbSeconds -= nSecond;
    nMicro = int(ldbSeconds * 1000000);
    
    swprintf( wszText, L"%08.8d%02.2d%02.2d%02.2d.%06.6d:000", 
              nDay, nHour, nMinute, nSecond, nMicro );

    return TRUE;
}

// this should be a WBEM common thing ...

BOOL FileTimeToDateTime( FILETIME* pft, LPWSTR wszText )
{
    SYSTEMTIME st;
    __int64 llnss = *(__int64*)pft;

    if ( !FileTimeToSystemTime( pft, &st ) )
    {
        return FALSE;
    }

    //
    // have to account for microseconds as well (probably a much better way
    // to do this.)
    //
    st.wMilliseconds = 0;

    FILETIME ft;
    if ( !SystemTimeToFileTime( &st, &ft ) )
    {
        return FALSE;
    }

    __int64 llnss2 = *(__int64*)&ft;
    int nMicro = int((llnss - llnss2)/10);
    
    swprintf( wszText, 
              L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d+000",
              st.wYear, st.wMonth, st.wDay, st.wHour, 
              st.wMinute, st.wSecond, nMicro );

    return TRUE;
}

BOOL SecondsToDateTime( long double ldbSeconds, LPWSTR wszText )
{
    FILETIME* pft;
    __int64 llnss = __int64(ldbSeconds * 10000000);
    pft = (FILETIME*)&llnss;
    return FileTimeToDateTime( pft, wszText );
}


BOOL IntervalToSeconds( LPCWSTR wszText, long double& rldbSeconds )
{
    int nDay, nHour, nMinute, nSecond, nMicro;

    int nRes = swscanf( wszText, L"%8d%2d%2d%2d.%6d", 
                        &nDay, &nHour, &nMinute, &nSecond, &nMicro );
    if ( nRes != 5 )
    {
        return FALSE;
    }

    rldbSeconds = nSecond + 60*nMinute + 3600*nHour + 86400*nDay;
    rldbSeconds += nMicro / 1000000.0;

    return TRUE;
}


BOOL DateTimeToSeconds( LPCWSTR wszText, long double& rldbSeconds )
{
    WORD nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf( wszText, L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
                        &nYear, &nMonth, &nDay, &nHour, &nMinute, 
                        &nSecond, &nMicro, &wchSep, &nOffset );
    if(nRes != 9)
    {
        return FALSE;
    }
    
    int nSign;
    if( wchSep == L'+' )
    {
        nSign = -1;
    }
    else if ( wchSep == L'-' )
    {
        nSign = 1;
    }
    else
    {
        return FALSE;
    }
    
    // Convert it to SYSTEMTIME
    // ========================
    
    SYSTEMTIME st;
    st.wYear = nYear;
    st.wMonth = nMonth;
    st.wDay = nDay;
    st.wHour = nHour;
    st.wMinute = nMinute;
    st.wSecond = nSecond;
    st.wMilliseconds = 0;
    
    //
    // convert SYSTEMTIME to FILETIME
    //

    FILETIME ft;
    if ( !SystemTimeToFileTime( &st, &ft ) )
    {
        return FALSE;
    }
    
    rldbSeconds = (long double)*(__int64*)&ft;
    rldbSeconds += nMicro*10;
    rldbSeconds /= 10000000;
    
    // Now adjust for the offset
    // =========================
    
    rldbSeconds += nSign * nOffset * 60;     
    return TRUE;
}

BOOL DMTFToSeconds( LPCWSTR wszText, long double& rldbSeconds )
{
    if( wcslen(wszText) != 25 )
    {
        return FALSE;
    }

    if ( wszText[21] != ':' )
    {
        return DateTimeToSeconds( wszText, rldbSeconds );
    }

    return IntervalToSeconds( wszText, rldbSeconds );
}

   
CCimValue::CCimValue( ) : m_eType( e_Int ), m_iVal( 0 ) { }
 

HRESULT CCimValue::GetValue( VARIANT& rvValue, ULONG lCimType )
{
    VariantInit( &rvValue );
    WCHAR achBuff[255];
    BOOL bRes;

    switch( lCimType )
    {
    case CIM_SINT8: 
    case CIM_SINT16:
    case CIM_SINT32:
    case CIM_BOOLEAN:
        CoerceToInt();        
        V_VT(&rvValue) = VT_I4;
        V_I4(&rvValue) = m_iVal;
        break;

    case CIM_UINT8:	
    case CIM_UINT16:
    case CIM_UINT32:
        CoerceToUnsignedInt();
        V_VT(&rvValue) = VT_I4;
        V_I4(&rvValue) = m_uiVal;
        break;
	
    case CIM_SINT64:
    case CIM_STRING:
        CoerceToLong();
        _i64tow( m_lVal, achBuff, 10 );
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    case CIM_REAL32:
        CoerceToFloat();
        V_VT(&rvValue) = VT_R4;
        V_R4(&rvValue) = m_fVal;
        break;

    case CIM_REAL64:
        CoerceToDouble();
        V_VT(&rvValue) = VT_R8;
        V_R8(&rvValue) = m_dbVal;
        break;

    case CIM_UINT64:
        CoerceToUnsignedLong();
        _ui64tow( m_ulVal, achBuff, 10 );
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    case CIM_INTERVAL:
        CoerceToLongDouble();
        bRes = SecondsToInterval( m_ldbVal, achBuff );
        if ( !bRes ) { return WBEM_E_TYPE_MISMATCH; }
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    case CIM_DATETIME:
        CoerceToLongDouble();
        bRes = SecondsToDateTime( m_ldbVal, achBuff );
        if ( !bRes ) { return WBEM_E_TYPE_MISMATCH; }
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    default:
        return WBEM_E_TYPE_MISMATCH;
    };

    return WBEM_S_NO_ERROR;
}

HRESULT CCimValue::SetValue( VARIANT& rvValue, ULONG lCimType )
{
    HRESULT hr;
    VARIANT vValue;
    VariantInit( &vValue );

    if ( lCimType == CIM_EMPTY )
    {
        //
        // must be a numeric value. 
        //
        switch( V_VT(&rvValue) )
        {
        case VT_R4:
            m_eType = e_Float;
            m_fVal = V_R4(&rvValue);
            break;
        case VT_R8:
            m_eType = e_Double;
            m_dbVal = V_R8(&rvValue);
            break;
        case VT_BSTR:
            m_lVal = (__int64)_wtoi64( V_BSTR(&rvValue) );
            break;
        default:
            hr = VariantChangeType( &vValue, &rvValue, 0, VT_I4 );
            if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
            m_eType = e_Int;
            m_iVal = V_I4(&vValue);
        };
        
        return WBEM_S_NO_ERROR;
    }
            
    switch( lCimType )
    {
    case CIM_SINT8: 
    case CIM_SINT16:
    case CIM_SINT32:
    case CIM_BOOLEAN:
        
        hr = VariantChangeType( &vValue, &rvValue, 0, VT_I4 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = e_Int;
        m_iVal = V_I4(&vValue);
        break;

    case CIM_UINT8:	
    case CIM_UINT16:
    case CIM_UINT32:

        hr = VariantChangeType( &vValue, &rvValue, 0, VT_UI4 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = e_UnsignedInt;
        m_uiVal = V_UI4(&vValue);
        break;
	
    case CIM_SINT64:
    case CIM_STRING:

        if ( V_VT(&rvValue) == VT_BSTR )
        {
            m_lVal = _wtoi64( V_BSTR(&rvValue) );
        }
        else
        {
            return WBEM_E_TYPE_MISMATCH;
        }
        m_eType = e_Long;
        break;

    case CIM_UINT64:

        if ( V_VT(&rvValue) == VT_BSTR )
        {
            m_ulVal = (unsigned __int64)_wtoi64( V_BSTR(&rvValue) );
        }
        else
        {
            return WBEM_E_TYPE_MISMATCH;
        }
        m_eType = e_UnsignedLong;
        break;

    case CIM_REAL32:

        hr = VariantChangeType( &vValue, &rvValue, 0, VT_R4 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = CCimValue::e_Float;
        m_fVal = V_R4(&vValue);
        break;

    case CIM_REAL64:

        hr = VariantChangeType( &vValue, &rvValue, 0, VT_R8 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = CCimValue::e_Double;
        m_dbVal = V_R8(&vValue);
        break;

    case CIM_DATETIME:
    case CIM_INTERVAL:
        
        if ( V_VT(&rvValue) == VT_BSTR )
        {
            BOOL bRes = DMTFToSeconds( V_BSTR(&rvValue), m_ldbVal );
        
            if ( !bRes )
            {
                return WBEM_E_TYPE_MISMATCH;
            }
        }
        else
        {
            return WBEM_E_TYPE_MISMATCH;
        }
        m_eType = e_LongDouble;
        break;

    default:
        return WBEM_E_TYPE_MISMATCH;
    };

    return WBEM_S_NO_ERROR;
}

void CCimValue::CoerceToLongDouble()
{
    switch( m_eType )
    {
    case e_Int:
        m_ldbVal = (long double)m_iVal;
        break;
    case e_UnsignedInt:
        m_ldbVal = (long double)m_uiVal;
        break;
    case e_Float:
        m_ldbVal = (long double)m_fVal;
        break;
    case e_Double:
        m_ldbVal = (long double)m_dbVal;
        break;
    case e_Long:
        m_ldbVal = (long double)m_lVal;
        break;
    case e_UnsignedLong: 
        m_ldbVal = (long double)(__int64)m_ulVal;
        break;
    };
    m_eType = e_LongDouble;
}

void CCimValue::CoerceToDouble()
{
    switch( m_eType )
    {
    case e_Int:
        m_dbVal = (double)m_iVal;
        break;
    case e_UnsignedInt:
        m_dbVal = (double)m_uiVal;
        break;
    case e_Float:
        m_dbVal = (double)m_fVal;
        break;
    case e_LongDouble:
        m_dbVal = (double)m_ldbVal;
        break;
    case e_Long:
        m_dbVal = (double)m_lVal;
        break;
    case e_UnsignedLong: 
        m_dbVal = (double)(__int64)m_ulVal;
        break;
    };
    m_eType = e_Double;
}

void CCimValue::CoerceToFloat()
{
    switch( m_eType )
    {
    case e_Int:
        m_fVal = (float)m_iVal;
        break;
    case e_UnsignedInt:
        m_fVal = (float)m_uiVal;
        break;
    case e_LongDouble:
        m_fVal = (float)m_ldbVal;
        break;
    case e_Double:
        m_fVal = (float)m_dbVal;
        break;
    case e_Long:
        m_fVal = (float)m_lVal;
        break;
    case e_UnsignedLong: 
        m_fVal = (float)(__int64)m_ulVal;
        break;
    };
    m_eType = e_Float;
}

void CCimValue::CoerceToUnsignedLong()
{
    switch( m_eType )
    {
    case e_Int:
        m_ulVal = (unsigned __int64)m_iVal;
        break;
    case e_UnsignedInt:
        m_ulVal = (unsigned __int64)m_uiVal;
        break;
    case e_Float:
        m_ulVal = (unsigned __int64)m_fVal;
        break;
    case e_Double:
        m_ulVal = (unsigned __int64)m_dbVal;
        break;
    case e_Long:
        m_ulVal = (unsigned __int64)m_lVal;
        break;
    case e_LongDouble: 
        m_ulVal = (unsigned __int64)m_ldbVal;
        break;
    };
    m_eType = e_UnsignedLong;
}

void CCimValue::CoerceToLong()
{
    switch( m_eType )
    {
    case e_Int:
        m_lVal = (__int64)m_iVal;
        break;
    case e_UnsignedInt:
        m_lVal = (__int64)m_uiVal;
        break;
    case e_Float:
        m_lVal = (__int64)m_fVal;
        break;
    case e_Double:
        m_lVal = (__int64)m_dbVal;
        break;
    case e_UnsignedLong:
        m_lVal = (__int64)m_ulVal;
        break;
    case e_LongDouble: 
        m_lVal = (__int64)m_ldbVal;
        break;
    };
    m_eType = e_Long;
}

void CCimValue::CoerceToUnsignedInt()
{
    switch( m_eType )
    {
    case e_Int:
        m_uiVal = (unsigned __int32)m_iVal;
        break;
    case e_Float:
        m_uiVal = (unsigned __int32)m_fVal;
        break;
    case e_Double:
        m_uiVal = (unsigned __int32)m_dbVal;
        break;
    case e_Long:
        m_uiVal = (unsigned __int32)m_lVal;
        break;
    case e_UnsignedLong:
        m_uiVal = (unsigned __int32)m_ulVal;
        break;
    case e_LongDouble: 
        m_uiVal = (unsigned __int32)m_ldbVal;
        break;
    };
    m_eType = e_UnsignedInt;
}

void CCimValue::CoerceToInt()
{
    switch( m_eType )
    {
    case e_Long:
        m_iVal = (__int32)m_lVal;
        break;
    case e_UnsignedInt:
        m_iVal = (__int32)m_uiVal;
        break;
    case e_Float:
        m_iVal = (__int32)m_fVal;
        break;
    case e_Double:
        m_iVal = (__int32)m_dbVal;
        break;
    case e_UnsignedLong:
        m_iVal = (__int32)m_ulVal;
        break;
    case e_LongDouble: 
        m_iVal = (__int32)m_ldbVal;
        break;
    };
    m_eType = e_Int;
}

void HandleConversion( CCimValue& rValA, CCimValue& rValB )
{
    if ( rValA.m_eType == rValB.m_eType )
    {
        return;
    }

    if ( rValA.m_eType == CCimValue::e_LongDouble )
    {
        rValB.CoerceToLongDouble();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_LongDouble )
    {
        rValA.CoerceToLongDouble();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Double )
    {
        rValB.CoerceToDouble();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_Double )
    {
        rValA.CoerceToDouble();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Float )
    {
        rValB.CoerceToFloat();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_Float )
    {
        rValA.CoerceToFloat();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_UnsignedLong )
    {
        rValB.CoerceToUnsignedLong();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_UnsignedLong )
    {
        rValA.CoerceToUnsignedLong();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Long && 
         rValB.m_eType == CCimValue::e_UnsignedInt || 
         rValB.m_eType == CCimValue::e_Long && 
         rValA.m_eType == CCimValue::e_UnsignedInt )
    {
        rValA.CoerceToUnsignedLong();
        rValB.CoerceToUnsignedLong();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Long )
    {
        rValB.CoerceToLong();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_Long )
    {
        rValA.CoerceToLong();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_UnsignedInt )
    {
        rValB.CoerceToUnsignedInt();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_UnsignedInt )
    {
        rValA.CoerceToUnsignedInt();
        return;
    }

    // this means both must be e_Int, but our check in the beginning 
    // should have handled this...

    assert( 0 );
    
}

CCimValue operator+ ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        ValA.m_iVal += ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        ValA.m_uiVal += ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        ValA.m_fVal += ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        ValA.m_dbVal += ValB.m_dbVal;
        break;
    case CCimValue::e_LongDouble:
        ValA.m_ldbVal += ValB.m_ldbVal;
        break;
    case CCimValue::e_Long:
        ValA.m_lVal += ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        ValA.m_ulVal += ValB.m_ulVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}

CCimValue operator- ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        ValA.m_iVal -= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        ValA.m_uiVal -= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        ValA.m_fVal -= ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        ValA.m_dbVal -= ValB.m_dbVal;
        break;
    case CCimValue::e_Long:
        ValA.m_lVal -= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        ValA.m_ulVal -= ValB.m_ulVal;
        break;
    case CCimValue::e_LongDouble:
        ValA.m_ldbVal -= ValB.m_ldbVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}

CCimValue operator* ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        ValA.m_iVal *= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        ValA.m_uiVal *= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        ValA.m_fVal *= ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        ValA.m_dbVal *= ValB.m_dbVal;
        break;
    case CCimValue::e_Long:
        ValA.m_lVal *= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        ValA.m_ulVal *= ValB.m_ulVal;
        break;
    case CCimValue::e_LongDouble:
        ValA.m_ldbVal *= ValB.m_ldbVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}

CCimValue operator/ ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    //
    // will raise a structured exception if div by 0.
    // caller is expected to handle this..
    //
   
    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        if ( ValB.m_iVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_iVal /= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        if ( ValB.m_uiVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_uiVal /= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        if ( ValB.m_fVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_fVal /= ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        if ( ValB.m_dbVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_dbVal /= ValB.m_dbVal;
        break;
    case CCimValue::e_Long:
        if ( ValB.m_lVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_lVal /= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        if ( ValB.m_ulVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_ulVal /= ValB.m_ulVal;
        break;
    case CCimValue::e_LongDouble:
        if ( ValB.m_ldbVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_ldbVal /= ValB.m_ldbVal;
        break;
    default:
        assert(0);
    };   

    return ValA;
}

CCimValue operator% ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    //
    // will raise a structured exception if div by 0.
    // caller is expected to handle this..
    //
   
    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        if ( ValB.m_iVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_iVal %= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        if ( ValB.m_uiVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_uiVal %= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
    case CCimValue::e_Double:
    case CCimValue::e_LongDouble:
        throw CX_InvalidFloatingPointOperationException();
    case CCimValue::e_Long:
        if ( ValB.m_lVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_lVal %= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        if ( ValB.m_ulVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_ulVal %= ValB.m_ulVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\cimval.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef __CIMVALUE_H__
#define __CIMVALUE_H__

const ULONG CIM_INTERVAL = 99;

class CCimValue
{
    union {
        __int32 m_iVal; 
        __int64 m_lVal;
        unsigned __int32 m_uiVal;
        unsigned __int64 m_ulVal;
        float m_fVal;
        double m_dbVal;
        long double m_ldbVal;
    };

public:
 
   enum { 
        e_Int, 
        e_UnsignedInt, 
        e_Float, 
        e_Double, 
        e_Long, 
        e_UnsignedLong, 
        e_LongDouble
    } m_eType;

    CCimValue();

    HRESULT GetValue( VARIANT& rvValue, ULONG lCimType );
    HRESULT SetValue( VARIANT& rvValue, ULONG lCimType );

    void CoerceToLongDouble();
    void CoerceToDouble();
    void CoerceToFloat();
    void CoerceToUnsignedLong();
    void CoerceToLong();
    void CoerceToUnsignedInt();
    void CoerceToInt();

    friend CCimValue operator+ ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator- ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator% ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator/ ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator* ( CCimValue ValA, CCimValue ValB );
};

class CX_DivideByZeroException
{
};

class CX_InvalidFloatingPointOperationException
{
};

#endif __CIMVALUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\corepol.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COREPOL.H

Abstract:

    declspec import/export helpers

History:

--*/

//#define TRACKING 

// If we are building the DLL then define the 
// class as exported otherwise as imported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including COREPOL.H..." )


#ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\corex.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    COREX.H

Abstract:

    WMI Core Services Exceptions

History:

--*/

#ifndef __COREX_H_
#define __COREX_H_

class CX_Exception {};

class CX_MemoryException : public CX_Exception {};

class CX_VarVectorException : public CX_Exception {};

class CX_ContextMarshalException : public CX_Exception {};

class Logic_Error : public CX_Exception {};

class Bad_Handle : public Logic_Error {};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\comutl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __COMUTL_H__
#define __COMUTL_H__

#include <wbemcli.h>
#include "corex.h"

/**************************************************************************
  CWbemPtr
***************************************************************************/

template<class T> class CWbemPtr
{
public :
    T* m_pObj;

    void SetPtr( T* pObj )
    {
        if ( m_pObj != NULL )
            m_pObj->Release();

        m_pObj = pObj;

        if ( m_pObj != NULL )
            m_pObj->AddRef();
    }
    
    CWbemPtr() : m_pObj(NULL) { }
    CWbemPtr( T* pObj ) : m_pObj(NULL) { SetPtr(pObj); }
    CWbemPtr( const CWbemPtr<T>& p ) : m_pObj(NULL) { SetPtr(p.m_pObj); }
    CWbemPtr<T>& operator=( const CWbemPtr<T>& p ) 
        { SetPtr(p.m_pObj); return *this; }
    ~CWbemPtr() { if ( m_pObj != NULL ) m_pObj->Release(); }
    
    operator T* () { return m_pObj; } 
    T** operator& () { return &m_pObj; } 
    T* operator-> () { return m_pObj; }
    
    void Release() { if( m_pObj != NULL ) m_pObj->Release(); m_pObj = NULL; }
};

/***************************************************************************
  CWbemBSTR
****************************************************************************/

class CWbemBSTR
{
    BSTR m_bstr;
 
    public :
    
    CWbemBSTR() : m_bstr(NULL) { }

    CWbemBSTR( LPCWSTR lpszStr ) 
    {
        if ( lpszStr != NULL )
        {
            m_bstr = ::SysAllocString(lpszStr);

            if ( m_bstr == NULL )
            {
                throw CX_MemoryException();
            }
        }
        else
        {
            m_bstr = NULL;
        }
    }

    CWbemBSTR( LPCWSTR lpszStr, ULONG cLen )
    {
        if ( cLen > 0 )
        {
            m_bstr = ::SysAllocStringLen( NULL, cLen );

            if ( m_bstr == NULL )
            {
                throw CX_MemoryException();
            }

            wcscpy( m_bstr, lpszStr );
        }
        else
        {
            m_bstr = NULL;
        }
    }

    CWbemBSTR( ULONG cLen )
    {
        m_bstr = ::SysAllocStringLen( NULL, cLen + 1);
        
        if ( m_bstr == NULL )
        {
            throw CX_MemoryException();
        }

        *m_bstr = '\0';
    }
        
    CWbemBSTR( const CWbemBSTR& m ) : m_bstr(NULL) { *this = m; }
    CWbemBSTR& operator=( const CWbemBSTR& m) 
    { 
        ::SysFreeString( m_bstr );
        m_bstr = ::SysAllocStringLen( m.m_bstr, m.MaxLength() );
            
        if ( m_bstr == NULL )
        {
            throw CX_MemoryException();
        }
            
        return *this; 
    }

    ~CWbemBSTR( ) { ::SysFreeString( m_bstr ); }
    
    operator BSTR() { return m_bstr; }
    BOOL operator!() { return m_bstr == NULL; }
    BSTR* operator& () { return &m_bstr; }
    
    void operator += ( LPCWSTR lpszStr ) 
    { 
        if ( lpszStr == NULL ) return;
        Resize( wcslen(lpszStr) + Length() + 10 );
        wcscat( m_bstr + Length(), lpszStr ); 
    }

    void Free() { ::SysFreeString( m_bstr ); m_bstr = NULL; }

    ULONG Length() const {return m_bstr!=NULL ? wcslen(m_bstr) : 0;}
    ULONG MaxLength() const {return m_bstr!=NULL ? ::SysStringLen(m_bstr) : 0;}
    
    void Resize( ULONG cLen )
    {
        if ( cLen > MaxLength() )
        {
            BSTR bstrNewStr = ::SysAllocStringLen( NULL, cLen + 1 );

            if ( bstrNewStr == NULL )
            {
                throw CX_MemoryException();
            }

            if ( m_bstr != NULL )
            {
                wcscpy( bstrNewStr, m_bstr );
                ::SysFreeString( m_bstr );
            }
            else
            {
                *bstrNewStr = '\0';
            }
            m_bstr = bstrNewStr;
        }
    }
};

/***************************************************************************
  CPropVar
****************************************************************************/

class CPropVar
{
public:
    
    VARIANT v;
    
    CPropVar() { VariantInit( &v ); }
    ~CPropVar() { VariantClear( &v ); }
    
    VARIANT* operator& () { return &v; }
    
    HRESULT CheckType( VARTYPE vt )
    {
        if ( V_VT(&v) != vt )
        {
            return DISP_E_TYPEMISMATCH;
        }
        return S_OK;
    }

    HRESULT SetType( VARTYPE vt ) 
    {
        if ( vt == V_VT(&v) ) 
        {
            return S_OK;
        }
        return VariantChangeType( &v, &v, 0, vt ); 
    }
};

/***************************************************************************
  CPropSafeArray
****************************************************************************/

template<class T> class CPropSafeArray
{
    T* m_aElems;
    SAFEARRAY* m_psa;
    
public:

    CPropSafeArray( SAFEARRAY* psa = NULL ) : m_psa(psa), m_aElems(NULL)
    {
        SafeArrayAccessData( psa, (void**)&m_aElems );
    }

    CPropSafeArray( CPropSafeArray& rOther )
    : m_psa(NULL), m_aElems(NULL)
    {
        *this = rOther.m_psa;
    }

    CPropSafeArray& operator=( SAFEARRAY* psa )
    {
        if ( m_psa != NULL )
        {
            SafeArrayUnaccessData( m_psa );
        }
        m_psa = psa;
        SafeArrayAccessData( m_psa, (void**)&m_aElems );
        return *this;
    }
            
    ~CPropSafeArray()
    {
        if ( m_psa == NULL )
        {
            return;
        }
        SafeArrayUnaccessData( m_psa );
    }

    ULONG Length()
    {
        if ( m_aElems == NULL )
        {
            return 0;
        }

        long lUBound;
        SafeArrayGetUBound( m_psa, 1, &lUBound );
        return lUBound+1;
    }

    T* GetArray() { return m_aElems; }

    T& operator[](int i) { return m_aElems[i]; }
};

/***************************************************************************
  platform independent string conversion routines.
****************************************************************************/

inline BOOL tsz2wsz( LPCWSTR tsz, WCHAR* pwch, ULONG* pcwch )
{   
    ULONG cwch = *pcwch;
    *pcwch = wcslen(tsz)+1;
    if ( cwch < *pcwch ) return FALSE;
    wcscpy( pwch, tsz );
    return TRUE;
}

inline BOOL tsz2wsz( LPCSTR tsz, WCHAR* pwch, ULONG* pcwch )
{
    ULONG cwch = *pcwch;
    *pcwch = MultiByteToWideChar(CP_ACP, 0, tsz, -1, NULL, 0 );
    if ( cwch < *pcwch ) return FALSE;
    MultiByteToWideChar(CP_ACP, 0, tsz, -1, pwch, cwch );
    return TRUE;
}

/****************************************************************************
  API Enter/Exit macros - catch out of memory conditions and return appropriate
  hresult.  Use at top level COM Interface implementations. 
*****************************************************************************/

#define ENTER_API_CALL try {
#define EXIT_API_CALL } catch(CX_MemoryException){return WBEM_E_OUT_OF_MEMORY;}
     

#endif // __COMUTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\crc64.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   crc64.h
//
//   cvadai     12-Nov-1999         created
//
//***************************************************************************

#ifndef _CRC64_H_
#define _CRC64_H_

#define TESTHSIZE	(4 * 1024 * 1024)
#define TESTHMASK	(TESTHSIZE - 1)

#define HINIT1	0xFAC432B1UL
#define HINIT2	0x0CD5E44AUL

#define POLY1	0x00600340UL
#define POLY2	0x00F0D50BUL

typedef unsigned int hint_t;	/* we want a 32 bit unsigned integer here */

typedef __int64 hash_t ;

class POLARITY CRC64
{
public:
    static hash_t GenerateHashValue(const wchar_t *p);

private:
    static void Initialize(void);    
    static void * RMalloc(int bytes);

    CRC64() {};
    ~CRC64() {};

    static BOOL   bInit;
    static hash_t CrcXor[256];
    static hash_t Poly[64+1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\clsfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CLSFAC.H

Abstract:

    Class Factory Helpers

History:

--*/

#ifndef __WBEM_CLASS_FACTORY__H_
#define __WBEM_CLASS_FACTORY__H_

#include <unk.h>
#include <sync.h>
#include <comutl.h>

/***************************************************************************
  CBaseClassFactory
****************************************************************************/

class CBaseClassFactory : public CUnkInternal
{
public:

    CBaseClassFactory( CLifeControl* pControl ) 
    : CUnkInternal( pControl ), m_XClassFactory( this ) {}

    class XClassFactory : public CImpl<IClassFactory,CBaseClassFactory>
    {
    public:

        STDMETHOD(CreateInstance)(IUnknown* pOuter, REFIID riid, void** ppv)
        {
            return m_pObject->CreateInstance( pOuter, riid, ppv );
        }

        STDMETHOD(LockServer)(BOOL fLock)
        {
            return m_pObject->LockServer( fLock );
        }

        XClassFactory( CBaseClassFactory* pOwner ) 
        : CImpl<IClassFactory,CBaseClassFactory>( pOwner ) {} 

    } m_XClassFactory;

    void* GetInterface( REFIID riid )
    {
        if ( riid == IID_IClassFactory )
        {
            return &m_XClassFactory;
        }
        return NULL;
    }

    virtual HRESULT CreateInstance( IUnknown* pOuter, 
                                    REFIID riid, 
                                    void** ppv ) = 0;

    virtual HRESULT LockServer( BOOL fLock ) = 0;
};

/****************************************************************************
  CSimpleClassFactory - does not support aggregation
*****************************************************************************/

template<class TObject>
class CSimpleClassFactory : public CBaseClassFactory
{
public:

    CSimpleClassFactory( CLifeControl* pControl = NULL )
    : CBaseClassFactory( pControl ) {} 
    
    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        HRESULT hr;
        *ppv = NULL;

        if(pOuter)
            return CLASS_E_NOAGGREGATION;
    
        // Lock
        if(m_pControl && !m_pControl->ObjectCreated(NULL))
        {
            // Shutting down
            // =============
            return CO_E_SERVER_STOPPING;
        }
            
        // Create

        try 
        {
            CWbemPtr<TObject> pObject = new TObject(m_pControl);

            if ( pObject != NULL )
            {
                hr = pObject->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        catch(...)
        {
            hr = E_FAIL;
        }

        //
        // Unlock
        //
        
        if( m_pControl != NULL )
        {
            m_pControl->ObjectDestroyed(NULL);
        }

        return hr;
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};        

/****************************************************************************
  CClassFactory - supports aggregation
*****************************************************************************/

template<class TObject>
class CClassFactory : public CSimpleClassFactory<TObject>
{
public:
    CClassFactory(CLifeControl* pControl = NULL) : 
        CSimpleClassFactory<TObject>(pControl){}

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        HRESULT hr;
        *ppv = NULL;

        //
        // Lock
        //
        if(m_pControl && !m_pControl->ObjectCreated(NULL))
        {
            // Shutting down
            // =============

            return CO_E_SERVER_STOPPING;
        }

        //
        // Create
        //        
        TObject * pNewObject = 0;
        try
        {          
            pNewObject = new TObject(m_pControl, pOuter);
        }
        catch(...) // do not let exception go beyond COM
        {
            return E_OUTOFMEMORY;
        }

        CWbemPtr<TObject> pObject(pNewObject);
        //
        // Initialize
        //
        if ( pObject != NULL && pObject->Initialize() )
        {
            if ( pOuter == NULL )
            {
                hr = pObject->QueryInterface(riid, ppv);
            }
            else
            {
                if ( riid == IID_IUnknown )
                {
                    *ppv = pObject->GetInnerUnknown();
                    pObject->AddRef();
                    hr = S_OK;
                }
                else
                {
                    hr = CLASS_E_NOAGGREGATION;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        // Unlock
        if( m_pControl != NULL )
        {
            m_pControl->ObjectDestroyed(NULL);
        }

        return hr;
    }
};        

/****************************************************************************
  CSingletonClassFactory 
*****************************************************************************/

template<class T> 
class CSingletonClassFactory : public CBaseClassFactory
{
    CCritSec m_cs;
    T* m_pObj;

public:

    CSingletonClassFactory( CLifeControl* pControl ) 
      : CBaseClassFactory( pControl ), m_pObj(NULL) {}

    ~CSingletonClassFactory() 
    { 
        if ( m_pObj != NULL )
        {
            m_pObj->InternalRelease(); 
        }
    }

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        HRESULT hr;
        *ppv = NULL;
        
        if( pOuter != NULL )
        {
            return CLASS_E_NOAGGREGATION;
        }
        
        //
        // lock the server.
        //
        
        if ( !m_pControl->ObjectCreated( this ) )
        {
            return CO_E_SERVER_STOPPING;
        }

        {
            CInCritSec ics( &m_cs );

            if ( m_pObj != NULL )
            {
                hr = m_pObj->QueryInterface( riid, ppv );
            }
            else
            {
                m_pObj = new T( m_pControl );

                if ( m_pObj != NULL )
                {
                    m_pObj->InternalAddRef(); 
                    hr = m_pObj->QueryInterface( riid, ppv );
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
                
        //
        // Unlock the server and return;
        //
        
        m_pControl->ObjectDestroyed( this );
        
        return hr;
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\crc64.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   crc64.cpp
//
//   cvadai     12-Nov-99       created.
//
//***************************************************************************

#define _CRC64_CPP_

#include "precomp.h"
#include <crc64.h>

hash_t CRC64::CrcXor[256];
hash_t CRC64::Poly[64+1];
BOOL   CRC64::bInit = FALSE;

unsigned long GetHIDWord(__int64 in)
{
    unsigned long lRet = (long)(in >> 0x20);
    return lRet;
}

unsigned long GetLODWord(__int64 in)
{
    unsigned long lRet = (long)(in & 0xFFFFFFFF);
    return lRet;
}


__int64 MakeInt64( long val1, long val2)
{
    __int64 ret = 0;

    ret = ((__int64)val1 << 0x20) + val2;

    return ret;
}

//***************************************************************************
//
//  CRC64::GenerateHashValue
//
//***************************************************************************

hash_t CRC64::GenerateHashValue(const wchar_t *p)
{
    hash_t tRet = 0;

    if (!p)
        return 0;

    if (!bInit)
    {
        Initialize();
        bInit = TRUE;
    }

    long h1, h2;
    h1 = HINIT1, h2 = HINIT2;

	int s = 64-40;
	hint_t m = (hint_t)-1 >> (0);

	h1 &= m;
	while (*p) 
    {
        int char1 = towupper(*p);

	    int i = (h1 >> s) & 255;
	    h1 = ((h1 << 8) & m) ^ (int)(h2 >> 24) ^ GetHIDWord(CrcXor[i]);
	    h2 = (h2 << 8) ^ char1 ^ GetLODWord(CrcXor[i]);
	    ++p;
	}

    tRet = MakeInt64(h1, h2);

    return(tRet);

}

//***************************************************************************
//
//  CRC64::Initialize
//
//***************************************************************************

void CRC64::Initialize(void)
{
    int i;

    /*
     * Polynomials to use for various crc sizes.  Start with the 64 bit
     * polynomial and shift it right to generate the polynomials for fewer
     * bits.  Note that the polynomial for N bits has no bit set above N-8.
     * This allows us to do a simple table-driven CRC.
     */

    hint_t h1 = POLY1, h2 = POLY2;

    Poly[64] = MakeInt64(POLY1, POLY2);

    for (i = 63; i >= 16; --i) 
    {
        h1 = (GetHIDWord(Poly[i+1])) >> 1;
        h2 = (GetLODWord(Poly[i+1])) >> 1 | ((GetHIDWord(Poly[i+1] ) & 1) << 31) | 1;

        Poly[i] = MakeInt64(h1, h2);
    }

    for (i = 0; i < 256; ++i) 
    {
	    int j;
	    int v = i;
        h1 = 0, h2 = 0;

	    for (j = 0; j < 8; ++j, (v <<= 1)) {
	        h1 <<= 1;
	        if (h2 & 0x80000000UL)
		        h1 |= 1;
	        h2 = (h2 << 1);
	        if (v & 0x80) {
		        h1 ^= GetHIDWord(Poly[64]);
		        h2 ^= GetLODWord(Poly[64]);
	        }
	    }
	    CrcXor[i] = MakeInt64(h1, h2);
    }

}

//***************************************************************************
//
//  CRC64::RMalloc
//
//***************************************************************************

void * CRC64::RMalloc(int bytes)
{
    static wchar_t *RBuf = NULL;
    static int	  RSize = 0;

    bytes = (bytes + 3) & ~3;

    if (bytes > RSize) 
    {
	    RBuf = (wchar_t *)malloc(65536);
	    RSize = 65536;
    }
    RBuf += bytes;
    RSize -= bytes;
    return(RBuf - bytes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\csspi.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CSSPI.H

Abstract:

    SSPI wrapper implementation for NTLM/MSN network authentication.

History:

    raymcc      15-Jul-97       Created

--*/

 
#include "precomp.h"
#include <tchar.h>

#include <stdio.h>


#include <csspi.h>

// #define trace(x) printf x
#define trace(x) 


static BOOL IsNt(void);


//***************************************************************************
//
//  String helper macros
//
//***************************************************************************

#define Macro_CloneLPWSTR(x) \
    (x ? _wcsdup(x) : 0)

#define Macro_CloneLPSTR(x) \
    (x ? _strdup(x) : 0)

#ifdef _UNICODE
	#define Macro_CloneLPTSTR(x) (x ? _wcsdup(x) : 0)
#else
	#define Macro_CloneLPTSTR(x) (x ? _strdup(x) : 0)
#endif


//***************************************************************************
//
//  BOOL IsNt
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************
// ok
static BOOL IsNt(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

//***************************************************************************
//
//  CSSPI Static Data Members
//
//***************************************************************************

ULONG                   CSSPI::m_uNumPackages = 0;
PSecPkgInfo             CSSPI::m_pEnumPkgInfo = 0;
PSecurityFunctionTable  CSSPI::pVtbl = 0;

//***************************************************************************
//
//  CSSPI::Initialize
//
//  This must be called prior to any other operations, but may be
//  called multiple times.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CSSPI::Initialize()
{
    static HMODULE hLib = 0;

    // If we have already called this function and everything
    // is already ok, short-circuit.
    // ======================================================

    if (hLib != 0 && pVtbl != 0)
    {
        return TRUE;
    }

    if (IsNt())
    {
        hLib = LoadLibrary(__TEXT("SECURITY.DLL"));
    }
    else
    {
        hLib = LoadLibrary(__TEXT("SECUR32.DLL"));
    }

    if (hLib == 0)
    {
        trace(("CSSPI::Startup() Library failed to load\n"));
        return FALSE;
    }

#ifdef _UNICODE
    INIT_SECURITY_INTERFACE_W pInitFn =
        (INIT_SECURITY_INTERFACE_W)
        GetProcAddress(hLib, "InitSecurityInterfaceW");
#else
    INIT_SECURITY_INTERFACE_A pInitFn =
        (INIT_SECURITY_INTERFACE_A)
        GetProcAddress(hLib, "InitSecurityInterfaceA");
#endif

    if (pInitFn == 0)
    {
        trace(("CSSPI::Startup() ERROR : Unable to locate function InitSecurityInterface()\n"
            ));
        FreeLibrary(hLib);
        hLib = 0;
        return FALSE;
    }

    pVtbl = pInitFn();

    if (pVtbl == 0)
    {
        trace(("CSSPI::Startup() ERROR : Function table not found\n"));
        FreeLibrary(hLib);
        hLib = 0;
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  CSSPI::TranslateError
//
//  Translates an error code to a displayable message.
//  Treat the return value as read-only (you must, since it is 'const').
//
//***************************************************************************
// ok

const LPTSTR CSSPI::TranslateError(
    ULONG uCode
    )
{
    LPTSTR p = 0;

    switch (uCode)
    {
    case SEC_E_INSUFFICIENT_MEMORY: p = _T("SEC_E_INSUFFICIENT_MEMORY"); break;
    case SEC_E_INVALID_HANDLE : p = _T("SEC_E_INVALID_HANDLE"); break;

    case SEC_E_UNSUPPORTED_FUNCTION : p = _T("SEC_E_UNSUPPORTED_FUNCTION"); break;

    case SEC_E_TARGET_UNKNOWN : p = _T("SEC_E_TARGET_UNKNOWN"); break;
    case SEC_E_INTERNAL_ERROR : p = _T("SEC_E_INTERNAL_ERROR"); break;
    case SEC_E_SECPKG_NOT_FOUND : p = _T("SEC_E_SECPKG_NOT_FOUND"); break;
    case SEC_E_NOT_OWNER : p = _T("SEC_E_NOT_OWNER"); break;
    case SEC_E_CANNOT_INSTALL : p = _T("SEC_E_CANNOT_INSTALL"); break;
    case SEC_E_INVALID_TOKEN : p = _T("SEC_E_INVALID_TOKEN"); break;
    case SEC_E_CANNOT_PACK : p = _T("SEC_E_CANNOT_PACK"); break;
    case SEC_E_QOP_NOT_SUPPORTED : p = _T("SEC_E_QOP_NOT_SUPPORTED"); break;
    case SEC_E_NO_IMPERSONATION : p = _T("SEC_E_NO_IMPERSONATION"); break;
    case SEC_E_LOGON_DENIED : p = _T("SEC_E_LOGON_DENIED"); break;
    case SEC_E_UNKNOWN_CREDENTIALS : p = _T("SEC_E_UNKNOWN_CREDENTIALS"); break;
    case SEC_E_NO_CREDENTIALS : p = _T("SEC_E_NO_CREDENTIALS"); break;
    case SEC_E_MESSAGE_ALTERED : p = _T("SEC_E_MESSAGE_ALTERED"); break;
    case SEC_E_OUT_OF_SEQUENCE : p = _T("SEC_E_OUT_OF_SEQUENCE"); break;
    case SEC_E_NO_AUTHENTICATING_AUTHORITY : p = _T("SEC_E_NO_AUTHENTICATING_AUTHORITY"); break;
    case SEC_I_CONTINUE_NEEDED : p = _T("SEC_I_CONTINUE_NEEDED"); break;
    case SEC_I_COMPLETE_NEEDED : p = _T("SEC_I_COMPLETE_NEEDED"); break;
    case SEC_I_COMPLETE_AND_CONTINUE : p = _T("SEC_I_COMPLETE_AND_CONTINUE"); break;
    case SEC_I_LOCAL_LOGON : p = _T("SEC_I_LOCAL_LOGON"); break;
    case SEC_E_BAD_PKGID : p = _T("SEC_E_BAD_PKGID"); break;
    case SEC_E_CONTEXT_EXPIRED : p = _T("SEC_E_CONTEXT_EXPIRED"); break;
    case SEC_E_INCOMPLETE_MESSAGE : p = _T("SEC_E_INCOMPLETE_MESSAGE"); break;
    case SEC_E_INCOMPLETE_CREDENTIALS : p = _T("SEC_E_INCOMPLETE_CREDENTIALS"); break;
    case SEC_E_BUFFER_TOO_SMALL : p = _T("SEC_E_BUFFER_TOO_SMALL"); break;
    case SEC_I_INCOMPLETE_CREDENTIALS : p = _T("SEC_I_INCOMPLETE_CREDENTIALS"); break;
    case SEC_I_RENEGOTIATE : p = _T("SEC_I_RENEGOTIATE"); break;

    default:
        p = _T("<UNDEFINED ERROR CODE>");
    }

    return (const LPTSTR) p;
}


//***************************************************************************
//
//  CSSPI::DisplayContextAttributes
//
//  Display authentication context attribute bits in readable form.
//
//***************************************************************************
// ok

void CSSPI::DisplayContextAttributes(
    ULONG uAttrib
    )
{
    if (uAttrib & ISC_RET_DELEGATE)
        printf("ISC_RET_DELEGATE\n");

    if (uAttrib & ISC_RET_MUTUAL_AUTH)
        printf("ISC_RET_MUTUAL_AUTH\n");

    if (uAttrib & ISC_RET_REPLAY_DETECT)
        printf("ISC_RET_REPLAY_DETECT\n");

    if (uAttrib & ISC_RET_SEQUENCE_DETECT)
        printf("ISC_RET_SEQUENCE_DETECT\n");

    if (uAttrib & ISC_RET_CONFIDENTIALITY)
        printf("ISC_RET_CONFIDENTIALITY\n");

    if (uAttrib & ISC_RET_USE_SESSION_KEY)
        printf("ISC_RET_USE_SESSION_KEY\n");

    if (uAttrib & ISC_RET_USED_COLLECTED_CREDS)
        printf("ISC_RET_USED_COLLECTED_CREDS\n");

    if (uAttrib & ISC_RET_USED_SUPPLIED_CREDS)
        printf("ISC_RET_USED_SUPPLIED_CREDS\n");

    if (uAttrib & ISC_RET_ALLOCATED_MEMORY)
        printf("ISC_RET_ALLOCATED_MEMORY\n");

    if (uAttrib & ISC_RET_USED_DCE_STYLE)
        printf("ISC_RET_USED_DCE_STYLE\n");

    if (uAttrib & ISC_RET_DATAGRAM)
        printf("ISC_RET_DATAGRAM\n");

    if (uAttrib & ISC_RET_CONNECTION)
        printf("ISC_RET_CONNECTION\n");

    if (uAttrib & ISC_RET_INTERMEDIATE_RETURN)
        printf("ISC_RET_INTERMEDIATE_RETURN\n");

    if (uAttrib & ISC_RET_CALL_LEVEL)
        printf("ISC_RET_CALL_LEVEL\n");

    if (uAttrib & ISC_RET_EXTENDED_ERROR)
        printf("ISC_RET_EXTENDED_ERROR\n");

    if (uAttrib & ISC_RET_STREAM)
        printf("ISC_RET_STREAM\n");

    if (uAttrib & ISC_RET_INTEGRITY)
        printf("ISC_RET_INTEGRITY\n");
}



//***************************************************************************
//
//  CSSPI::DisplayPkgInfo
//
//  Dumps package information to console.
//
//***************************************************************************
// ok

void CSSPI::DisplayPkgInfo(PSecPkgInfo pPkg)
{
    printf("---------------------------------------------\n");
    printf("Name            = <%s>\n", pPkg->Name);
    printf("Comment         = <%s>\n", pPkg->Comment);
    printf("Version         = 0x%X\n", pPkg->wVersion);
    printf("Max token       = %d bytes\n", pPkg->cbMaxToken);
    printf("DCE RPC Id      = 0x%X\n", pPkg->wRPCID);

    printf("Capabilities = \n");

    if (pPkg->fCapabilities & SECPKG_FLAG_INTEGRITY)
        printf("    SECPKG_FLAG_INTEGRITY\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_PRIVACY)
        printf("    SECPKG_FLAG_PRIVACY\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_TOKEN_ONLY)
        printf("    SECPKG_FLAG_TOKEN_ONLY\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_DATAGRAM)
        printf("    SECPKG_FLAG_DATAGRAM\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_CONNECTION)
        printf("    SECPKG_FLAG_CONNECTION\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_MULTI_REQUIRED)
        printf("    SECPKG_FLAG_MULTI_REQUIRED\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_CLIENT_ONLY)
        printf("    SECPKG_FLAG_CLIENT_ONLY\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_EXTENDED_ERROR)
        printf("    SECPKG_FLAG_EXTENDED_ERROR\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_IMPERSONATION)
        printf("    SECPKG_FLAG_IMPERSONATION\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_ACCEPT_WIN32_NAME)
        printf("    SECPKG_FLAG_ACCEPT_WIN32_NAME\n");

    if (pPkg->fCapabilities & SECPKG_FLAG_STREAM)
        printf("    SECPKG_FLAG_STREAM\n");

    printf("---------------------------------------------\n");
}


//***************************************************************************
//
//  CSSPI::GetNumPkgs
//
//  Gets the number of SSPI packages available on the current machine.
//
//  Returns 0 if none available.
//
//***************************************************************************
// ok

ULONG CSSPI::GetNumPkgs()
{
    // Short-circuit to see if this function has been called before.
    // It is not possible for new SSPI packages to appear between
    // reboots, so we cache all info.
    // =============================================================

    if (m_uNumPackages != 0 && m_pEnumPkgInfo)
        return m_uNumPackages;

    // Enumerate security packages.
    // ============================

    SECURITY_STATUS SecStatus =
         pVtbl->EnumerateSecurityPackages(&m_uNumPackages, &m_pEnumPkgInfo);

    if (SecStatus)
    {
        trace(("EnumerateSecurityPackages() failed. Error = %s\n", TranslateError(SecStatus)
            ));
        return 0;
    }

    return m_uNumPackages;
}


//***************************************************************************
//
//  CSSPI::GetPkgInfo
//
//  Retrieves a single read-only PSecPkgInfo pointer, describing the
//  requested package. This is to be used in conjunction with GetNumPkgs()
//  in order to iterate through the SSPI package list.
//
//  Returns NULL on error or a read-only PSecPkgInfo pointer.
//
//***************************************************************************
// ok

const PSecPkgInfo CSSPI::GetPkgInfo(ULONG ulPkgNum)
{
    if (ulPkgNum >= m_uNumPackages)
        return 0;

    if (m_pEnumPkgInfo == 0)
        return 0;

    return &m_pEnumPkgInfo[ulPkgNum];
}



//***************************************************************************
//
//  CSSPI::DumpSecurityPackages
//
//  Dumps all available security packages to the console.
//
//***************************************************************************
// ok

BOOL CSSPI::DumpSecurityPackages()
{
    // Enumerate security packages.
    // ============================

    unsigned long lNum = 0;
    PSecPkgInfo pPkgInfo;

    lNum = GetNumPkgs();
    if (lNum == 0)
        return FALSE;

    trace(("SSPI Supports %d security packages\n", lNum));

    for (unsigned long i = 0; i < lNum; i++)
    {
        pPkgInfo = GetPkgInfo(i);

        if (pPkgInfo)
            DisplayPkgInfo(pPkgInfo);
    }

    return TRUE;
}

//***************************************************************************
//
//  CSSPI::ServerSupport
//
//  Determines whether the a server-side package can be expected to work.
//
//  Parameters:
//  <pszPkgName>            The authentication package. Usually "NTLM"
//
//  Return value:
//  TRUE if the package will support a server-side authentication, FALSE
//  if not supported.
//
//***************************************************************************
BOOL CSSPI::ServerSupport(LPTSTR pszPkgName)
{
    if (pszPkgName == 0 || lstrlen(pszPkgName) == 0)
        return FALSE;

    if (Initialize() == FALSE)
        return FALSE;

    CSSPIServer Server(pszPkgName);

    if (Server.GetStatus() != CSSPIServer::Waiting)
        return FALSE;

    return TRUE;
}

//***************************************************************************
//
//  CSSPI::ClientSupport
//
//  Determines whether the a client-side package can be expected to work.
//
//  Parameters:
//  <pszPkgName>            The authentication package. Usually "NTLM"
//
//  Return value:
//  TRUE if the package will support a client-side authentication, FALSE
//  if not supported.
//
//***************************************************************************

BOOL CSSPI::ClientSupport(LPTSTR pszPkgName)
{
    if (pszPkgName == 0 || lstrlen(pszPkgName) == 0)
        return FALSE;

    if (Initialize() == FALSE)
        return FALSE;

    CSSPIClient Client(pszPkgName);

    if (Client.GetStatus() != CSSPIClient::Waiting)
        return FALSE;

    return TRUE;
}



//***************************************************************************
//
//  CSSPIClient constructor
//
//  Parameters:
//  <pszPkgName>        A valid SSPI package.  Usually "NTLM".
//
//  After construction has completed, GetStatus() should return
//  CSSPIClient::Waiting.   CSSPIClient::InvalidPackage indicates that
//  the object will not function.
//
//***************************************************************************

CSSPIClient::CSSPIClient(LPTSTR pszPkgName)
{
    // Initialize variables.
    // =====================

    m_dwStatus = InvalidPackage;
    memset(&m_ClientCredential, 0, sizeof(CredHandle));

    m_pPkgInfo   = 0;
    m_pszPkgName = 0;
    m_cbMaxToken = 0;
    m_bValidCredHandle = FALSE;

    memset(&m_ClientContext, 0, sizeof(CtxtHandle));
    m_bValidContextHandle = FALSE;

    // Copy package name.
    // ===================

    m_pszPkgName = Macro_CloneLPTSTR(pszPkgName);

    if (!m_pszPkgName)
    {
        trace(("CSSPIClient failed to construct (out of memory).\n"));
        m_dwStatus = InvalidPackage;
        return;
    }

    // Init the requested package.
    // ===========================

    SECURITY_STATUS SecStatus = 0;

    SecStatus = CSSPI::pVtbl->QuerySecurityPackageInfo(pszPkgName, &m_pPkgInfo);

    if (SecStatus != 0)
    {
        trace(("CSSPIClient fails to construct. Error = %s\n", 
            CSSPI::TranslateError(SecStatus)
            ));
        m_dwStatus = InvalidPackage;
        return;
    }

    // If here, things are ok.  We are waiting
    // for client to set login information.
    // ========================================

    m_cbMaxToken = m_pPkgInfo->cbMaxToken;
    m_dwStatus = Waiting;
}


//***************************************************************************
//
//  CSSPIClient
//
//  Destructor
//
//***************************************************************************

CSSPIClient::~CSSPIClient()
{
    if (m_pPkgInfo)
        CSSPI::pVtbl->FreeContextBuffer(m_pPkgInfo);

    if (m_pszPkgName)
        delete [] m_pszPkgName;

    if (m_bValidCredHandle)
        CSSPI::pVtbl->FreeCredentialHandle(&m_ClientCredential);

    if (m_bValidContextHandle)
        CSSPI::pVtbl->DeleteSecurityContext(&m_ClientContext);
}


//***************************************************************************
//
//  CSSPIClient::SetLoginInfo
//
//  Sets login info prior to beginning a login session.
//  pszUser, pszDomain, pszPassword must be either all NULL or all not
//  NULL.  If NULLs are used, the current user's security context
//  is propagated.
//
//  This must be the first call after constructing the CSSPIClient.
//  If this returns NoError, then ContinueLogin must be called next
//  before communicating with the server process.
//
//  Parameters:
//  <pszUser>           The user name
//  <pszDomain>         The NTLM domain
//  <pszPassword>       The cleartext password
//  <dwLoginFlags>      Reserved
//
//  Return value:
//  <NoError> if the caller can immediately proceed to ContinueLogin().
//  <InvalidParameter> if one or more parameters were not valid.
//  <InvalidPackage> if the SSPI package is not operational
//
//  <InvalidUser> if the user/domain/password parameters are 
//                of the wrong format.
//  
//  After successful completion, <NoError> is returned and
//  GetStatus() will return CSSPIClient::LoginContinue.
//
//***************************************************************************

DWORD CSSPIClient::SetLoginInfo(
    IN LPTSTR pszUser,
    IN LPTSTR pszDomain,
    IN LPTSTR pszPassword,
    IN DWORD dwLoginFlags
    )
{
    if (m_dwStatus != Waiting)
        return m_dwStatus = InvalidPackage;

    // If the user specifies any of one {user,password,domain}, they
    // all must be specified.
    // =============================================================

    if (pszUser || pszDomain || pszPassword)
    {
        if (!pszUser || !pszDomain || !pszPassword)
            return InvalidParameter;
    }

    // Acquire a credentials handle for subsequent calls.
    // ==================================================

    SEC_WINNT_AUTH_IDENTITY AdditionalCredentials;
    BOOL bSupplyCredentials = FALSE;
    TimeStamp Expiration;

    AdditionalCredentials.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // Due to the parameter validation, we know that if
    // a user was specified, the other parameters have been, too.
    // ==========================================================

    if (pszUser != 0)
    {
        bSupplyCredentials = TRUE;
        AdditionalCredentials.User =  pszUser;
        AdditionalCredentials.UserLength = lstrlen(pszUser);
        AdditionalCredentials.Password =  pszPassword;
        AdditionalCredentials.PasswordLength = lstrlen(pszPassword);
        AdditionalCredentials.Domain =  pszDomain;
        AdditionalCredentials.DomainLength = lstrlen(pszDomain);
    }

    // Get client credentials handle.
    // ==============================

    SECURITY_STATUS SecStatus = CSSPI::pVtbl->AcquireCredentialsHandle(
        NULL,
        m_pszPkgName,
        SECPKG_CRED_OUTBOUND,
        NULL,
        bSupplyCredentials ? &AdditionalCredentials : 0,
        NULL,
        NULL,
        &m_ClientCredential,
        &Expiration
        );


    if (SecStatus)
    {
        trace(("AcquireCredentialsHandle() failed.  Error=%s\n",
            CSSPI::TranslateError(SecStatus) ));
        return m_dwStatus = InvalidUser;
    }

    m_bValidCredHandle = TRUE;

    // Signal to caller that login must continue.
    // ==========================================

    m_dwStatus = LoginContinue;
    return NoError;
}


//***************************************************************************
//
//  CSSPIClient::SetDefaultLogin
//
//  Convenience method to login using 'current' credentials.
//
//  Return values same as for SetLoginInfo().
//
//***************************************************************************

DWORD CSSPIClient::SetDefaultLogin(DWORD dwFlags)
{
    return SetLoginInfo(0, 0, 0, dwFlags);
}

//***************************************************************************
//
//  CSSPIClient::ContinueLogin
//
//  Called immediately after SetDefaultLogin() or SetLoginInfo() or 
//  after prior calls to ContinueLogin after receiving binary tokens
//  from the server-side of the conversation.
//
//  This is used for both to prepare the logon request and the
//  response to the challenge from the server.
//
//  Parameters:
//  <pInToken>              A token received from the server.  If no
//                          token has been received yet, then use NULL.
//                          This is treated as read-only.
//
//  <dwInTokenSize>         The number of bytes in the token pointed
//                          to by <dwInTokenSize>, or 0 if the above
//                          token is NULL.
//
//  <pToken>                Receives a pointer to a memory buffer
//                          containing the token to transfer to the
//                          server.  Deallocate with operator delete.
//
//  <pdwTokenSize>          Points to a DWORD to receive the size
//                          of the above token.
//
//  Return value:
//  <NoError>       Returned when no more calls to ContinueLogin
//                  are completed.  <pToken> and <pdwTokenSize>
//                  are still returned in this case.
//                  This completes the 'response' portion
//                  in the challenge-response sequence.  The server
//                  will return an 'access denied' status through
//                  private means.  Note that <NoError> does not
//                  imply successful logon or that 'access denied' will 
//                  not occur.  It merely completes the response
//                  to the 'challenge'.
//
//                  After the login request phase (the first call to
//                  this function) GetStatus() should return 
//                  CSSPIClient::LoginContinue, to indicate that
//                  another call to this function will be required.
//                  If GetStatus() CSSPIClient::LoginComplete is
//                  returned, no more SSPI operations will occur.
//                  Final success or denial by the server will
//                  be privately indicated by the server.
//
//  <Failed>        Internal error.  No out-parms are returned in this
//                  case.
//
//***************************************************************************


DWORD CSSPIClient::ContinueLogin(
    IN LPBYTE pInToken,
    IN DWORD dwInTokenSize,
    OUT LPBYTE *pToken,
    OUT DWORD  *pdwTokenSize
    )
{
    // If here, we are ready to build up a token.
    // ==========================================

    SecBufferDesc   OutputBufferDescriptor;
    SecBuffer       OutputSecurityToken;
    ULONG           uContextRequirements = 0;
    ULONG           uContextAttributes;
    TimeStamp       Expiration;

    // Set up the output buffers and out params by
    // default.  On errors, we simply null the out params.
    // ===================================================

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = &OutputSecurityToken;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    LPBYTE pTokenBuf = new BYTE[m_cbMaxToken];

    OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
    OutputSecurityToken.cbBuffer   = m_cbMaxToken;
    OutputSecurityToken.pvBuffer   = pTokenBuf;

    // Build up the input buffer, if required.
    // =======================================

    SecBufferDesc   InputBufferDescriptor;
    SecBuffer       InputSecurityToken;

    if (pInToken)
    {
        InputBufferDescriptor.cBuffers = 1;
        InputBufferDescriptor.pBuffers = &InputSecurityToken;
        InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

        InputSecurityToken.BufferType = SECBUFFER_TOKEN;
        InputSecurityToken.cbBuffer   = dwInTokenSize;
        InputSecurityToken.pvBuffer   = pInToken;
    }

    PSecBufferDesc pInBuf = pInToken ? &InputBufferDescriptor : 0;

    // Determine if this is first-time or continued call.
    // ==================================================

    PCtxtHandle pTmp = m_bValidContextHandle ? &m_ClientContext : 0;

    SECURITY_STATUS SecStatus =
        CSSPI::pVtbl->InitializeSecurityContext(
            &m_ClientCredential,
            pTmp,                       // Context handle pointer(
            NULL,                       // Target name (server)

            uContextRequirements,       // Requirements
            0,                          // Reserved
            SECURITY_NATIVE_DREP,       // Target data representation

            pInBuf,                     // Input buffer for continued calls
            0,                          // Reserved
            &m_ClientContext,           // Receives client context handle
            &OutputBufferDescriptor,
            &uContextAttributes,
            &Expiration
            );


    // Determine the next step.
    // ========================

    if (SecStatus == SEC_E_OK)
    {
        *pToken = pTokenBuf;
        *pdwTokenSize = OutputSecurityToken.cbBuffer;
        m_dwStatus = LoginCompleted;
        return NoError;
    }

    if (SecStatus == SEC_I_CONTINUE_NEEDED)
    {
        // Set up the output parameters.
        // =============================
        *pToken = pTokenBuf;
        *pdwTokenSize = OutputSecurityToken.cbBuffer;
        m_bValidContextHandle = TRUE;
        m_dwStatus = LoginContinue;
        return NoError;
    }

    // If here, an error occurred.
    // ===========================

    trace(("CSSPIClient::ContinueLogin failed. Status code = %s",
            CSSPI::TranslateError(SecStatus)
            ));

    CSSPI::pVtbl->DeleteSecurityContext(pTmp);

    // Deallocate useless return buffer and NULL the out-parameters.
    // =============================================================

    delete [] pTokenBuf;
    *pToken = 0;
    *pdwTokenSize = 0;

    m_dwStatus = Failed;
    return Failed;
}



//***************************************************************************
//
//  CSSPIServer constructor
//
//  Parameters:
//  <pszPkgName>            The SSPI package to use, usually "NTLM".
//
//  After construction, CSSPIServer::GetStatus() should return 
//  CSSPIServer::Waiting.  Any other value indicates that the object
//  is invalid and cannot be used.
//
//***************************************************************************

CSSPIServer::CSSPIServer(LPTSTR pszPkgName)
{
    m_dwStatus      = 0;
    m_cbMaxToken    = 0;
    m_pPkgInfo      = 0;

    m_bValidCredHandle = FALSE;
    m_bValidContextHandle = FALSE;

    memset(&m_ServerCredential, 0, sizeof(CredHandle));
    memset(&m_ServerContext, 0, sizeof(CtxtHandle));

    m_pszPkgName = Macro_CloneLPTSTR(pszPkgName);

    if (!m_pszPkgName)
    {
        trace(("CSSPIServer failed to construct (out of memory).\n"));
        m_dwStatus = InvalidPackage;
        return;
    }

    // Init the requested package.
    // ===========================

    SECURITY_STATUS SecStatus = 0;

    SecStatus = CSSPI::pVtbl->QuerySecurityPackageInfo(pszPkgName, &m_pPkgInfo);

    if (SecStatus != 0)
    {
        trace(("CSSPIServer failed to construct. Error = %s\n",
            CSSPI::TranslateError(SecStatus)
            ));
        m_dwStatus = InvalidPackage;
        return;
    }

    m_cbMaxToken = m_pPkgInfo->cbMaxToken;

    // Now acquire a default credentials handle for this machine.
    // ==========================================================

    TimeStamp   Expiration;

    SecStatus = CSSPI::pVtbl->AcquireCredentialsHandle(
        NULL,                       // No principal
        m_pszPkgName,               // Authentication package to use
        SECPKG_CRED_INBOUND,        // We are a 'server'
        NULL,                       // No logon identifier
        NULL,                       // No pkg specific data
        NULL,                       // No GetKey function
        NULL,                       // No GetKey function arg
        &m_ServerCredential,        // Server credential
        &Expiration                 // Expiration timestamp
        );

    if (SecStatus != 0)
    {
        trace(("CSSPIServer failed in AcquireCredentialsHandle(). Error = %s\n",
            CSSPI::TranslateError(SecStatus)
            ));

        m_dwStatus = Failed;
        return;
    }

    m_bValidCredHandle = TRUE;
    m_dwStatus = Waiting;
}

//***************************************************************************
//
//  CSSPIServer destructor
//  
//***************************************************************************

CSSPIServer::~CSSPIServer()
{
    if (m_pPkgInfo)
        CSSPI::pVtbl->FreeContextBuffer(m_pPkgInfo);

    delete [] m_pszPkgName;

    if (m_bValidCredHandle)
        CSSPI::pVtbl->FreeCredentialHandle(&m_ServerCredential);

    if (m_bValidContextHandle)
        CSSPI::pVtbl->DeleteSecurityContext(&m_ServerContext);
}

//***************************************************************************
//
//  CSSPIServer::ContinueClientLogin
//
//  Used to 
//
//  (1) Receive the client's logon request, and compute the challenge as
//      the out-parameter <pToken>
//
//  (2) Verify the response to the challenge.
//
//  Parameters:
//  <pInToken>      A read-only pointer to the response (on the second call).
//                  NULL on the initial call.
//
//  <dwInTokenSize> The number of bytes pointed to by the above pointers.
//
//  <pToken>        On the first call, receives a pointer to the
//                  challenge to send to the client.
//  
//  <pdwTokenSize>  The size of the above challenge.
//
//  Return values:
//
//  <LoginContinue> Sent back on the first call to indicate that a 
//                  challenge has been computed and returned to the
//                  client in <pToken>.
//
//  <Failed>        No out-params assigned.  Indicates internal failure.
// 
//  <NoError>       Only possible on the second call. Indicates the
//                  client was authenticated.
//
//  <AccessDenied>  Returned on the second call if the user was denied
//                  logon.
//
//***************************************************************************


DWORD CSSPIServer::ContinueClientLogin(
    IN LPBYTE pInToken,
    IN DWORD dwInTokenSize,
    OUT LPBYTE *pToken,
    OUT DWORD  *pdwTokenSize
    )
{
    TimeStamp       Expiration;
    SecBufferDesc   InputBufferDescriptor;
    SecBuffer       InputSecurityToken;
    SecBufferDesc   OutputBufferDescriptor;
    SecBuffer       OutputSecurityToken;
    ULONG           uContextRequirements = 0;
    ULONG           uContextAttributes;

    // Build up the input buffer.
    // ==========================

    InputBufferDescriptor.cBuffers = 1;
    InputBufferDescriptor.pBuffers = &InputSecurityToken;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InputSecurityToken.BufferType = SECBUFFER_TOKEN;
    InputSecurityToken.cbBuffer   = dwInTokenSize;
    InputSecurityToken.pvBuffer   = pInToken;

    // Build the output buffer descriptor.
    // ===================================

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = &OutputSecurityToken;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    LPBYTE pOutBuf = new BYTE[m_cbMaxToken];

    OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
    OutputSecurityToken.cbBuffer   = m_cbMaxToken;
    OutputSecurityToken.pvBuffer   = pOutBuf;


    // Set up partial or final context handle.
    // =======================================

    PCtxtHandle pTmp = m_bValidContextHandle ? &m_ServerContext : 0;

    // Process the client's initial token and see what happens.
    // ========================================================

    SECURITY_STATUS SecStatus = 0;

    SecStatus = CSSPI::pVtbl->AcceptSecurityContext(
        &m_ServerCredential,
        pTmp,                           // No context handle yet
        &InputBufferDescriptor,
        uContextRequirements,           // No context requirements
        SECURITY_NATIVE_DREP,
        &m_ServerContext,
        &OutputBufferDescriptor,
        &uContextAttributes,
        &Expiration
        );

    *pToken = pOutBuf;
    *pdwTokenSize = OutputSecurityToken.cbBuffer;

    if (SecStatus == SEC_I_CONTINUE_NEEDED)
    {
        m_dwStatus = LoginContinue;
        m_bValidContextHandle = TRUE;
        return LoginContinue;
    }

    if (SecStatus == SEC_E_OK)
    {
        m_bValidContextHandle = TRUE;
        delete [] pOutBuf;
        *pToken = 0;
        *pdwTokenSize = 0;
        m_dwStatus = LoginCompleted;
        return NoError;
    }

    // If here, an error occurred.
    // ===========================

    trace(("CSSPIClient::ContinueLogin failed. Status code = %s",
            CSSPI::TranslateError(SecStatus)
            ));

    *pToken = 0;
    *pdwTokenSize = 0;
    delete [] pOutBuf;

    if (SecStatus == SEC_E_LOGON_DENIED)
    {
        m_dwStatus = AccessDenied;
        return AccessDenied;
    }

    return Failed;
}


//***************************************************************************
//
//  CSSPIServer::QueryUserInfo
//
//  Gets information about a client after authentication.
//
//  Parameters:
//  <pszUser>       Receives a pointer to the user name if TRUE is
//                  returned.  Use operator delete to deallocate.
//
//  Return value:
//  TRUE if the user name was returned, FALSE if not.
//
//***************************************************************************

BOOL CSSPIServer::QueryUserInfo(
    OUT LPTSTR *pszUser         // Use operator delete
    )
{
    SecPkgContext_Names Names;
    memset(&Names, 0, sizeof(SecPkgContext_Names));
    *pszUser = 0;

    SECURITY_STATUS SecStatus = CSSPI::pVtbl->QueryContextAttributes(
        &m_ServerContext,
        SECPKG_ATTR_NAMES,
        &Names
        );

    if (SecStatus != 0)
    {
        trace(("QueryContextAttributes() for Name fails with %s ",
            CSSPI::TranslateError(SecStatus)
            ));
        return FALSE;
    }

    if (pszUser)
        *pszUser = Macro_CloneLPTSTR(Names.sUserName);

    CSSPI::pVtbl->FreeContextBuffer(LPVOID(Names.sUserName));
    
    return TRUE;
}


//***************************************************************************
//
//  CSSPIServer::IssueLoginToken
//
//  Issues a login token for the client to use in subsequent access.
//  This will only succeed if the client successfully computed the
//  reponse to the challenge and <NoError> was returned from
//  ContinueClientLogin.
//
//  Parameters:
//  <ClsId>         Receives the CLSID which becomes the WBEM access token.
//
//  Return value:
//  NoError, Failed
//
//***************************************************************************

DWORD CSSPIServer::IssueLoginToken(
    OUT CLSID &ClsId
    )
{
    if (m_dwStatus == LoginCompleted)
    {
        if (SUCCEEDED(CoCreateGuid(&ClsId)))
            return NoError;
        else
            return Failed;
    }        

    memset(&ClsId, 0, sizeof(CLSID));
    return Failed;                
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\datepart.cpp ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   datepart.cpp
//
//   a-davcoo     28-Feb-00       Implements the SQL datepart operation.
//
//***************************************************************************

#include "precomp.h"
#include "datepart.h"
#include <stdio.h>
#include "wbemcli.h"


CDatePart::CDatePart ()
{
	m_date=NULL;
}


CDatePart::~CDatePart (void)
{
	delete m_date;
}

HRESULT CDatePart::SetDate (LPCWSTR lpDate)
{
    HRESULT hr = 0;

	delete m_date;
	m_date=NULL;
    m_date = new CDMTFParser(lpDate);
    if (!m_date)
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

HRESULT CDatePart::SetDate (LPCSTR lpDate)
{
    HRESULT hr = 0;

	delete m_date;
	m_date=NULL;
    wchar_t *pNew = new wchar_t [(strlen(lpDate)*4)+1];
    if (pNew)
    {
        swprintf(pNew, L"%S", lpDate);
        m_date = new CDMTFParser(pNew);
        delete pNew;
    }
    
    if (!m_date)
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}


HRESULT CDatePart::GetPart (int datepart, int *value)
{
	HRESULT hr=WBEM_S_NO_ERROR;

	int part;
	switch (datepart)
	{
		case DATEPART_YEAR:
		{
			part=CDMTFParser::YEAR;
			break;
		}

		case DATEPART_MONTH:
		{
			part=CDMTFParser::MONTH;
			break;
		}

		case DATEPART_DAY:
		{
			part=CDMTFParser::DAY;
			break;
		}

		case DATEPART_HOUR:
		{
			part=CDMTFParser::HOUR;
			break;
		}

		case DATEPART_MINUTE:
		{
			part=CDMTFParser::MINUTE;
			break;
		}

		case DATEPART_SECOND:
		{
			part=CDMTFParser::SECOND;
			break;
		}

		case DATEPART_MILLISECOND:
		{
			part=CDMTFParser::MICROSECOND;
			break;
		}

		default:
		{
			hr=WBEM_E_NOT_AVAILABLE;
			*value=0;
			break;
		}
	}

	if (SUCCEEDED(hr))
	{
		if (!m_date->IsValid())
		{
			hr=WBEM_E_INVALID_PARAMETER;
		}
		else if (!m_date->IsUsed (part) || m_date->IsWildcard (part))
		{
			hr=WBEM_E_NOT_AVAILABLE;
		}
		else
		{
			*value=m_date->GetValue (part);
			if (datepart==DATEPART_MILLISECOND) *value/=1000;
		}
	}

	return hr;
}


CDMTFParser::CDMTFParser (LPCWSTR date)
{
	ParseDate (date);
}

		
CDMTFParser::~CDMTFParser (void)
{
}


void CDMTFParser::ParseDate (LPCWSTR date)
{
	m_valid=true;

	for (int index=0; index<NUMPARTS; index++)
	{
		m_status[index]=NOTUSED;
		m_part[index]=0;
	}

	int length=wcslen (date);
	if (length!=25 || date[14]!=L'.')
	{
		m_valid=false;
	}
	else
	{
		m_interval=!wcscmp (&date[21], L":000");
		if (m_interval)
		{
			ParseInterval (date);
		}
		else
		{
			ParseAbsolute (date);
		}
	}

	for (index=0; index<NUMPARTS; index++)
	{
		if (m_status[index]==INVALID)
		{
			m_valid=false;
			break;
		}
	}
}


void CDMTFParser::ParseInterval (LPCWSTR date)
{
	m_status[DAY]=ParsePart (date, 0, 8, &m_part[DAY], 0, 999999999);
	m_status[HOUR]=ParsePart (date, 8, 2, &m_part[HOUR], 0, 23);
	m_status[MINUTE]=ParsePart (date, 10, 2, &m_part[MINUTE], 0, 59);
	m_status[SECOND]=ParsePart (date, 12, 2, &m_part[SECOND], 0, 59);
	m_status[MICROSECOND]=ParsePart (date, 15, 6, &m_part[MICROSECOND], 0, 999999);
}


void CDMTFParser::ParseAbsolute (LPCWSTR date)
{
	m_status[YEAR]=ParsePart (date, 0, 4, &m_part[YEAR], 0, 9999);
	m_status[MONTH]=ParsePart (date, 4, 2, &m_part[MONTH], 1, 12);
	m_status[DAY]=ParsePart (date, 6, 2, &m_part[DAY], 1, 31);
	m_status[HOUR]=ParsePart (date, 8, 2, &m_part[HOUR], 0, 23);
	m_status[MINUTE]=ParsePart (date, 10, 2, &m_part[MINUTE], 0, 59);
	m_status[SECOND]=ParsePart (date, 12, 2, &m_part[SECOND], 0, 59);
	m_status[MICROSECOND]=ParsePart (date, 15, 6, &m_part[MICROSECOND], 0, 999999);
	m_status[OFFSET]=ParsePart (date, 22, 3, &m_part[OFFSET], 0, 999);

	if (date[21]==L'-')
		m_part[OFFSET]*=(-1);
	else if (date[21]!=L'+')
		m_status[OFFSET]=INVALID;
}


int CDMTFParser::ParsePart (LPCWSTR date, int pos, int length, int *result, int min, int max)
{
	*result=0;

	bool digits=false, wildcard=false;
	for (int index=pos; index<pos+length; index++)
	{
		if (iswdigit (date[index]))
		{
			if (wildcard) return INVALID;

			*result*=10;
			*result+=date[index]-L'0';

			digits=true;
		}
		else if (date[index]==L'*')
		{
			if (digits) return INVALID;
			wildcard=true;
		}
		else
		{
			return INVALID;
		}
	}

	if (!wildcard && (*result<min || *result>max)) return INVALID;

	return VALID;
}


bool CDMTFParser::IsValid (void)
{
	return m_valid;
}


bool CDMTFParser::IsInterval (void)
{
	return m_interval;
}


bool CDMTFParser::IsUsed (int part)
{
	return m_valid && !(m_status[part] & NOTUSED);
}


bool CDMTFParser::IsWildcard (int part)
{
	return m_valid && (m_status[part] & NOTSUPPLIED);
}


int CDMTFParser::GetValue (int part)
{
	return m_valid ? m_part[part] : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\csspi.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CSSPI.H

Abstract:

    SSPI wrapper implementation

History:

    raymcc      15-Jul-97       Created

--*/

#ifndef _CSSPI_H_
#define _CSSPI_H_

#define SECURITY_WIN32  
//#include "corepol.h"

extern "C"
{
#include <sspi.h>
};

class CSSPIClient;
class CSSPIServer;

//***************************************************************************
//
//  CSSPI is the basic 'utility' class.
//
//***************************************************************************

class CSSPI
{
    static ULONG       m_uNumPackages;
    static PSecPkgInfo m_pEnumPkgInfo; 

public:
    enum { NoError, InvalidPackage, Idle, Busy, Failed, Continue };

    static PSecurityFunctionTable pVtbl;    
        // Used by client classes to access the SSPI v-table.
        
    
    static BOOL Initialize();
        // Called by all clients to initialize SSPI.
        
    // Helpers.
    // ========

    static const LPTSTR TranslateError(
        ULONG uCode
        );

    static void DisplayContextAttributes(
        ULONG uAttrib
        );

    static void DisplayPkgInfo(
        PSecPkgInfo pPkg
        );

    // To enumerate through the packages.
    // ==================================        

    static ULONG GetNumPkgs();
        // Returns 0 if none available or an error occurred.

    static const PSecPkgInfo GetPkgInfo(ULONG lPkgNum);        
        // Returns NULL on error
    
    static BOOL DumpSecurityPackages();        // Debug dump of packages

    // Query for support 
    // =================
    static BOOL ServerSupport(LPTSTR pszPkgName);
    static BOOL ClientSupport(LPTSTR pszPkgName);
};        

//***************************************************************************
//
//  CSSPIClient
//
//  Used for client-side authentication.
//
//***************************************************************************

class  CSSPIClient
{
    DWORD        m_dwStatus;
    ULONG        m_cbMaxToken;
    PSecPkgInfo  m_pPkgInfo;
    LPTSTR        m_pszPkgName;

    BOOL         m_bValidCredHandle;
    CredHandle   m_ClientCredential;    

    CtxtHandle   m_ClientContext;
    BOOL         m_bValidContextHandle;
         
public:
    enum 
    { 
        NoError = 0,
        LoginCompleted, 
        LoginContinue, 
        InvalidUser, 
        InternalError, 
        AccessDenied = 5,   // don't change
        InvalidPackage,
        Waiting,
        InvalidParameter,
        LoginCompleteNeeded,
        LoginCompleteAndContinue,
        Failed
    };

    CSSPIClient(LPTSTR pszPkgName);
    
   ~CSSPIClient(); 

    DWORD GetStatus() { return m_dwStatus; }
    
    ULONG MaxTokenSize() { return  m_cbMaxToken; }
    
    DWORD SetLoginInfo(
        IN LPTSTR pszUser,
        IN LPTSTR pszDomain,
        IN LPTSTR pszPassword,
        IN DWORD dwFlags = 0
        );
        // Returns LoginContinue, AccessDenied, InvalidUser, InternalError
        // InvalidParameter

    DWORD SetDefaultLogin(DWORD dwFlags = 0);
                
    DWORD ContinueLogin(
        IN LPBYTE pInToken,
        IN DWORD dwInTokenSize,
        OUT LPBYTE *pToken,
        OUT DWORD  *pdwTokenSize        
        );        
        // Returns LoginContinue, LoginCompleted, AccessDenied, InternalError

    DWORD BuildLoginToken(
        OUT LPBYTE *pToken,
        OUT DWORD *pdwToken
        );
};


//***************************************************************************
//
//  CSSPIClient
//
//  Used for client-side authentication.
//
//***************************************************************************

class  CSSPIServer
{
    DWORD m_dwStatus;
    ULONG        m_cbMaxToken;
    PSecPkgInfo  m_pPkgInfo;
    LPTSTR        m_pszPkgName;

    CredHandle   m_ServerCredential;
    BOOL         m_bValidCredHandle;

    CtxtHandle   m_ServerContext;
    BOOL         m_bValidContextHandle;

public:
    enum 
    { 
        NoError = 0,
        LoginCompleted,
        InvalidPackage,
        Failed,
        Waiting,
        AccessDenied = 5,   // don't change
        LoginCompleteNeeded,
        LoginCompleteAndContinue,
        LoginContinue
    };

    CSSPIServer(LPTSTR pszPkgName);
   ~CSSPIServer(); 

    DWORD GetStatus() { return m_dwStatus; }
    
    ULONG MaxTokenSize() { return  m_cbMaxToken; }

    DWORD ContinueClientLogin(
        IN LPBYTE pInToken,
        IN DWORD dwInTokenSize,
        OUT LPBYTE *pToken,
        OUT DWORD  *pdwTokenSize        
        );        

    DWORD IssueLoginToken(
        OUT CLSID &ClsId
        );

    BOOL QueryUserInfo(
        OUT LPTSTR *pszUser         // Use operator delete
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\datepart.h ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   datepart.h
//
//   a-davcoo     28-Feb-00       Implements the SQL datepart operation.
//
//***************************************************************************

#ifndef _DATEPART_H_
#define _DATEPART_H_


#include <strutils.h>
#include <datetimeparser.h>


#define DATEPART_YEAR			1			// "yy", "year"
#define DATEPART_MONTH			3			// "mm", "month"
#define DATEPART_DAY			5			// "dd", "day"
#define DATEPART_HOUR			8			// "hh", "hour"
#define DATEPART_MINUTE			9			// "mi", "minute"
#define DATEPART_SECOND         10          // "ss", "second"
#define DATEPART_MILLISECOND	11			// "ms", "millisecond"


class CDMTFParser;


// The CDatePart class implements the SQL "datepart" operation.  To use
// this class, construct an instance, supplying the date string you wish
// to parse.  Then use the GetPart() method to extract the specified part.
// Contants for the "parts" are presented above.  The class makes it's own
// copy of the date string supplied during construction.
class POLARITY CDatePart
{
	public:
        CDatePart ();
		~CDatePart ();

        HRESULT SetDate (LPCWSTR lpDate);
        HRESULT SetDate (LPCSTR lpDate);
		HRESULT GetPart (int datepart, int *value);

	protected:
		CDMTFParser *m_date;
};


class POLARITY CDMTFParser
{
	public:
		enum {YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MICROSECOND, OFFSET};

		CDMTFParser (LPCWSTR date);
		~CDMTFParser (void);

		bool IsValid (void);
		bool IsInterval (void);

		bool IsUsed (int part);
		bool IsWildcard (int part);
		int GetValue (int part);

	protected:
		enum {INVALID=0x0, VALID=0x1, NOTSUPPLIED=0x2, NOTUSED=0x4};
		enum {NUMPARTS=8};

		bool m_valid;
		bool m_interval;

		int m_status[NUMPARTS];
		int m_part[NUMPARTS];

	    void ParseDate (LPCWSTR date);
		void ParseInterval (LPCWSTR date);
		void ParseAbsolute (LPCWSTR date);
		int ParsePart (LPCWSTR date, int pos, int length, int *result, int min, int max);
};


#endif // _DATEPART_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\cwbemtime.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMTIME.CPP

Abstract:

    Time helper

History:

--*/

#include "precomp.h"

#include "CWbemTime.h"
#include <stdio.h>

static void i64ToFileTime( const __int64 *p64, FILETIME *pft )
{
    __int64 iTemp = *p64;
    pft->dwLowDateTime = (DWORD)iTemp;
    iTemp = iTemp >> 32;
    pft->dwHighDateTime = (DWORD)iTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

CWbemTime CWbemTime::GetCurrentTime()
{
    SYSTEMTIME st;
    ::GetSystemTime(&st);

    CWbemTime CurrentTime;
    CurrentTime.SetSystemTime(st);
    return CurrentTime;
}

BOOL CWbemTime::SetSystemTime(const SYSTEMTIME& st)
{
    FILETIME ft;
    if(!SystemTimeToFileTime(&st, &ft))
        return FALSE;

    __int64 i64Time = ft.dwHighDateTime;
    i64Time = (i64Time << 32) + ft.dwLowDateTime;
    Set100nss(i64Time);
    return TRUE;
}

BOOL CWbemTime::SetFileTime(const FILETIME& ft)
{
    __int64 i64Time = ft.dwHighDateTime;
    i64Time = (i64Time << 32) + ft.dwLowDateTime;
    Set100nss(i64Time);
    return TRUE;
}

BOOL CWbemTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{

    FILETIME t_ft;

    if (GetFILETIME(&t_ft))
    {
        if (!FileTimeToSystemTime(&t_ft, pst))
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CWbemTime::GetFILETIME(FILETIME * pft) const
{
    if ( pft == NULL )
    {
        return FALSE;
    }

	i64ToFileTime( &m_i64, pft );
    return TRUE;
}


CWbemInterval CWbemTime::RemainsUntil(const CWbemTime& Other) const
{
    __int64 i64Diff = Other.m_i64 - m_i64;
    if(i64Diff < 0) i64Diff = 0;

    return CWbemInterval((DWORD)(i64Diff/10000));
}

CWbemTime CWbemTime::operator+(const CWbemInterval& ToAdd) const
{
    return CWbemTime(m_i64 + 10000*(__int64)ToAdd.GetMilliseconds());
}

BOOL CWbemTime::SetDMTF(LPCWSTR wszText)
{
    if(wcslen(wszText) != 25)
        return FALSE;

    // Parse it
    // ========

    int nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf(wszText, L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
                &nYear, &nMonth, &nDay, &nHour, &nMinute, &nSecond, &nMicro, 
                &wchSep, &nOffset);
    if(nRes != 9)
        return FALSE;

    int nSign;
    if(wchSep == L'+')
        nSign = -1;
    else if(wchSep == L'-')
        nSign = 1;
    else if(wchSep == L':')
        nSign = 0;
    else 
        return FALSE;

    // Convert it to SYSTEMTIME
    // ========================

    SYSTEMTIME st;
    st.wYear = (WORD)nYear;
    st.wMonth = (WORD)nMonth;
    st.wDay = (WORD)nDay;
    st.wHour = (WORD)nHour;
    st.wMinute = (WORD)nMinute;
    st.wSecond = (WORD)nSecond;
    st.wMilliseconds = nMicro / 1000;

    // NOTE: ignored timezone for now
    // ==============================

    if(!SetSystemTime(st))
        return FALSE;

    // Now adjust for the offset
    // =========================

    m_i64 += (__int64)nSign * (__int64)nOffset * 60 * 10000000;

    return TRUE;
}

LONG CWbemTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            //ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}
    
BOOL CWbemTime::GetDMTF( BOOL bLocal, DWORD dwBuffLen, LPWSTR pwszBuff )
{

    SYSTEMTIME t_Systime;
    wchar_t chsign = L'-';
    int offset = 0;

	// Need to Localize the offset
	if ( dwBuffLen < WBEMTIME_LENGTH + 1 )
	{
		return FALSE;
	}

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
    ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
    t_ConversionZone = t_ConversionZone * 10000000L ;
    if ( !bLocal || ( m_i64 < t_ConversionZone ) )
    {
        if(!GetSYSTEMTIME(&t_Systime))
        {
            return NULL;
        }
    }
	else
    {
        if (GetSYSTEMTIME(&t_Systime))
        {
            offset = GetLocalOffsetForDate(&t_Systime);

            CWbemTime wt;
            if (offset >= 0)
            {
                chsign = '+';
                wt = *this + CWbemTimeSpan(0, 0, offset, 0);
            }
            else
            {
                offset *= -1;
                wt = *this - CWbemTimeSpan(0, 0, offset, 0);
            }
            wt.GetSYSTEMTIME(&t_Systime);
        }
        else
        {
            return NULL;
        }
    }

    LONGLONG tmpMicros = m_i64%10000000;
    LONG micros = (LONG)(tmpMicros / 10);

    swprintf(

        pwszBuff,
        L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d%c%03.3ld",
        t_Systime.wYear,
        t_Systime.wMonth, 
        t_Systime.wDay,
        t_Systime.wHour,
        t_Systime.wMinute,
        t_Systime.wSecond,
        micros, 
        chsign, 
        offset
    );

    return TRUE ;

}

CWbemTime CWbemTime::operator+(const CWbemTimeSpan &uAdd) const
{
    CWbemTime ret;
    ret.m_i64 = m_i64 + uAdd.m_Time;

    return ret;
}

CWbemTime CWbemTime::operator-(const CWbemTimeSpan &uSub) const
{
    CWbemTime ret;
    ret.m_i64 = m_i64 - uSub.m_Time;

    return ret;
}

CWbemTimeSpan::CWbemTimeSpan(int iDays, int iHours, int iMinutes, int iSeconds, 
                int iMSec, int iUSec, int iNSec)
{
    m_Time = 0;        //todo, check values!!!
    m_Time += iSeconds;
    m_Time += iMinutes * 60;
    m_Time += iHours * 60 * 60;
    m_Time += iDays * 24 * 60 * 60;
    m_Time *= 10000000;
    m_Time += iNSec / 100;  // Nanoseconds
    m_Time += iUSec*10;   // Microseconds
    m_Time += iMSec*10000; // Milliseconds
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\datetimeparser.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DATETIMEPARSER.CPP

Abstract:

    Parses a date/time string and converts it into it's component values.

History:

    raymcc  25-Jul-99       Updated to bypass strict checks on DMTF
                            formats due to backward compatibility issues
                            and breaks reported by other teams.  See
                            NOT_USED_IN_WIN2000 #idndef bracketed code.


--*/

//=============================================================================
//
//  CDateTimeParser
//
//  Parses a date/time string and converts it into it's component values.
//
//  Supported DMTF date/time formats:
//  1:  yyyymmddhhmmss.uuuuuu+UTC
//  2:  yyyymmddhhmmss.uuuuuu-UTC
//
//  Supported date formats:
//  1:  Mon[th] dd[,] [yy]yy
//  2:  Mon[th][,] yyyy
//  3:  Mon[th] [yy]yy dd
//  4:  dd Mon[th][,][ ][yy]yy
//  5:  dd [yy]yy Mon[th]
//  6:  [yy]yy Mon[th] dd
//  7:  yyyy Mon[th]
//  8:  yyyy dd Mon[th]
//  9:  [M]M{/-.}dd{/-,}[yy]yy      ->Has to be same separator!
//  10: dd{/-.}[M]M{/-.}[yy]yy      ->Has to be same separator!
//  11: [M]M{/-.}[yy]yy{/-.}dd      ->Has to be same separator!
//  12: dd{/-.}[yy]yy{/-.}[M]M      ->Has to be same separator!
//  13: [yy]yy{/-.}dd{/-.}[M]M      ->Has to be same separator!
//  14: [yy]yy{/-.}[M]M{/-.}dd      ->Has to be same separator!
//  15: [yy]yyMMdd and yyyy[MM[dd]]
//
//  Supported Time formats:
//  1:  hh[ ]{AP}M
//  2:  hh:mm
//  3:  hh:mm[ ]{AP}M
//  4:  hh:mm:ss
//  5:  hh:mm:ss[ ]{AP}M
//  6:  hh:mm:ss:uuu
//  7:  hh:mm:ss.[[u]u]u
//  8:  hh:mm:ss:uuu[ ]{AP}M
//  9:  hh:mm:ss.[[u]u]u[ ]{AP}M
//=============================================================================

#include "precomp.h"
#include <string.h>
#include <stdio.h>
#include "DateTimeParser.h"
#include <TCHAR.h>

//=============================================================================
//  Constructor. This takes a DateTime string and parses it.
//=============================================================================
CDateTimeParser::CDateTimeParser(const TCHAR *pszDateTime)
:   m_nDayFormatPreference(mdy)
{
    // Get the prefered date format by using NLS locale call
    GetPreferedDateFormat();

    //Get the localised long month strings
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME1, m_pszFullMonth[0]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME2, m_pszFullMonth[1]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME3, m_pszFullMonth[2]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME4, m_pszFullMonth[3]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME5, m_pszFullMonth[4]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME6, m_pszFullMonth[5]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME7, m_pszFullMonth[6]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME8, m_pszFullMonth[7]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME9, m_pszFullMonth[8]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME10, m_pszFullMonth[9]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME11, m_pszFullMonth[10]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME12, m_pszFullMonth[11]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME13, m_pszFullMonth[12]);

    //Get the localised short month strings
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME1, m_pszShortMonth[0]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME2, m_pszShortMonth[1]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME3, m_pszShortMonth[2]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME4, m_pszShortMonth[3]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME5, m_pszShortMonth[4]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME6, m_pszShortMonth[5]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME7, m_pszShortMonth[6]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME8, m_pszShortMonth[7]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME9, m_pszShortMonth[8]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME10, m_pszShortMonth[9]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME11, m_pszShortMonth[10]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME12, m_pszShortMonth[11]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME13, m_pszShortMonth[12]);

    //Get the localised AM/PM strings
    GetLocalInfoAndAlloc(LOCALE_S1159, m_pszAmPm[0]);
    GetLocalInfoAndAlloc(LOCALE_S2359, m_pszAmPm[1]);

    //Decode the date time string.
    SetDateTime(pszDateTime);
}

CDateTimeParser::CDateTimeParser( void )
:   m_nDayFormatPreference(mdy),
    m_bValidDateTime( FALSE ),
    m_nDay( 0 ),
    m_nMonth( 0 ),
    m_nYear( 0 ),
    m_nHours( 0 ),
    m_nMinutes( 0 ),
    m_nSeconds( 0 ),
    m_nMicroseconds( 0 ),
    m_nUTC( 0 )
{
    ZeroMemory( m_pszFullMonth, sizeof(m_pszFullMonth) );
    ZeroMemory( m_pszShortMonth, sizeof(m_pszShortMonth) );
    ZeroMemory( m_pszAmPm, sizeof(m_pszAmPm) );
}

//=============================================================================
//  Destructor.  Tidies up after itself.
//=============================================================================
CDateTimeParser::~CDateTimeParser()
{
    if ( NULL != m_pszFullMonth[0] ) delete [] m_pszFullMonth[0];
    if ( NULL != m_pszFullMonth[1] ) delete [] m_pszFullMonth[1];
    if ( NULL != m_pszFullMonth[2] ) delete [] m_pszFullMonth[2];
    if ( NULL != m_pszFullMonth[3] ) delete [] m_pszFullMonth[3];
    if ( NULL != m_pszFullMonth[4] ) delete [] m_pszFullMonth[4];
    if ( NULL != m_pszFullMonth[5] ) delete [] m_pszFullMonth[5];
    if ( NULL != m_pszFullMonth[6] ) delete [] m_pszFullMonth[6];
    if ( NULL != m_pszFullMonth[7] ) delete [] m_pszFullMonth[7];
    if ( NULL != m_pszFullMonth[8] ) delete [] m_pszFullMonth[8];
    if ( NULL != m_pszFullMonth[9] ) delete [] m_pszFullMonth[9];
    if ( NULL != m_pszFullMonth[10] ) delete [] m_pszFullMonth[10];
    if ( NULL != m_pszFullMonth[11] ) delete [] m_pszFullMonth[11];
    if ( NULL != m_pszFullMonth[12] ) delete [] m_pszFullMonth[12];

    if ( NULL != m_pszShortMonth[0] ) delete [] m_pszShortMonth[0];
    if ( NULL != m_pszShortMonth[1] ) delete [] m_pszShortMonth[1];
    if ( NULL != m_pszShortMonth[2] ) delete [] m_pszShortMonth[2];
    if ( NULL != m_pszShortMonth[3] ) delete [] m_pszShortMonth[3];
    if ( NULL != m_pszShortMonth[4] ) delete [] m_pszShortMonth[4];
    if ( NULL != m_pszShortMonth[5] ) delete [] m_pszShortMonth[5];
    if ( NULL != m_pszShortMonth[6] ) delete [] m_pszShortMonth[6];
    if ( NULL != m_pszShortMonth[7] ) delete [] m_pszShortMonth[7];
    if ( NULL != m_pszShortMonth[8] ) delete [] m_pszShortMonth[8];
    if ( NULL != m_pszShortMonth[9] ) delete [] m_pszShortMonth[9];
    if ( NULL != m_pszShortMonth[10] ) delete [] m_pszShortMonth[10];
    if ( NULL != m_pszShortMonth[11] ) delete [] m_pszShortMonth[11];
    if ( NULL != m_pszShortMonth[12] ) delete [] m_pszShortMonth[12];

    if ( NULL != m_pszAmPm[0] ) delete [] m_pszAmPm[0];
    if ( NULL != m_pszAmPm[1] ) delete [] m_pszAmPm[1];
}

TCHAR* CDateTimeParser::AllocAmPm()
{
    TCHAR* pszAP = new TCHAR[4];

    if (pszAP)
    {
        pszAP[0] = ' ';
        pszAP[1] = m_pszAmPm[0][0];
        pszAP[2] = m_pszAmPm[1][0];
        pszAP[3] = 0;
    }

    return pszAP;
}

//=============================================================================
//  Does a GetLocalInfo and allocates the buffer large enough for the item.
//=============================================================================
void CDateTimeParser::GetLocalInfoAndAlloc(LCTYPE LCType, LPTSTR &lpLCData)
{
    int nSize;
    nSize = GetLocaleInfo(LOCALE_USER_DEFAULT, LCType, NULL, 0);
    lpLCData =  new TCHAR[nSize];

    if (lpLCData)
        GetLocaleInfo(LOCALE_USER_DEFAULT, LCType, lpLCData, nSize);
}

//=============================================================================
//  Uses locale call to work out the prefered date format.
//=============================================================================
void CDateTimeParser::GetPreferedDateFormat()
{
    int nSize;
    if (!(nSize = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, NULL, 0)))
        return;     // will use default of mdy
    TCHAR* lpLCData =  new TCHAR[nSize];
    if(lpLCData == NULL)
        return;

    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, lpLCData, nSize))
    {
        delete [] lpLCData;
        return;     // will use default of mdy
    }

    nSize -= 2;     // index of last character

    // It is only necessary to check first and last character to determine format
    if (lpLCData[0] == 'M')
    {
        if (lpLCData[nSize] == 'y')
            m_nDayFormatPreference = mdy;
        else // lpLCData[nSize] == 'd'
            m_nDayFormatPreference = myd;
    }
    else if (lpLCData[0] == 'd')
    {
        if (lpLCData[nSize] == 'y')
            m_nDayFormatPreference = dmy;
        else // lpLCData[nSize] == 'M'
            m_nDayFormatPreference = dym;
    }
    else // lpLCPata[0] == 'y'
    {
        if (lpLCData[nSize] == 'd')
            m_nDayFormatPreference = ymd;
        else // lpLCData[nSize] == 'M'
            m_nDayFormatPreference = ydm;
    }
    delete [] lpLCData;
}


//=============================================================================
//  Tidies up and parses a new date and time.
//=============================================================================
BOOL CDateTimeParser::SetDateTime(const TCHAR *pszDateTime)
{
    ResetDateTime(TRUE);

    if (CheckDMTFDateTimeFormatInternal(pszDateTime) == TRUE)
        return TRUE;

    if (CheckDateFormat(pszDateTime, TRUE) == TRUE)
        return TRUE;

    if (CheckTimeFormat(pszDateTime, TRUE) == TRUE)
        return TRUE;

    return TRUE;
}

//=============================================================================
//  Resets all the date/time values to the default values.
//  If bSQL is TRUE it sets to the SQL default.  Otherwise
//  sets to the DMTF default.
//=============================================================================
void CDateTimeParser::ResetDateTime(BOOL bSQL)
{
    ResetDate(bSQL);
    ResetTime(bSQL);
}

void CDateTimeParser::ResetDate(BOOL bSQL)
{
    m_bValidDateTime = FALSE;
    m_nDay = 1;
    m_nMonth = 1;
    m_nYear = 1990;
}

void CDateTimeParser::ResetTime(BOOL bSQL)
{
    m_bValidDateTime = FALSE;
    m_nHours = 0;
    m_nMinutes = 0;
    m_nSeconds = 0;
    m_nMicroseconds = 0;
    m_nUTC = 0;
}

//=============================================================================
//  Checks the date time for a valid DMTF string
//  1:  yyyymmddhhmmss.uuuuuu+UTC
//  2:  yyyymmddhhmmss.uuuuuu-UTC
// Note, this code is a near duplicate of the checks used to test the interval format.
//=============================================================================
BOOL CDateTimeParser::CheckDMTFDateTimeFormatInternal(const TCHAR *pszDateTime)
{
    if (lstrlen(pszDateTime) != 25)
        return FALSE;

    //Validate digits and puntuation...
    for (int i = 0; i < 14; i++)
    {
        if (!isdigit(pszDateTime[i]))
            return FALSE;
    }
    if (pszDateTime[i] != '.')
        return FALSE;
    for (i++;i < 21; i++)
    {
        if (!isdigit(pszDateTime[i]))
            return FALSE;
    }
    if ((pszDateTime[i] != '+') && (pszDateTime[i] != '-'))
        return FALSE;
    for (i++; i < 25; i++)
    {
        if (!isdigit(pszDateTime[i]))
            return FALSE;
    }

    m_nYear = ((pszDateTime[0] - '0') * 1000) +
              ((pszDateTime[1] - '0') * 100) +
              ((pszDateTime[2] - '0') * 10) +
               (pszDateTime[3] - '0');

    if (m_nYear < 1601)
        return FALSE;

    m_nMonth = ((pszDateTime[4] - '0') * 10) +
                (pszDateTime[5] - '0');

    if (m_nMonth < 1 || m_nMonth > 12)
        return FALSE;

    m_nDay = ((pszDateTime[6] - '0') * 10) +
              (pszDateTime[7] - '0');

    if (m_nDay < 1 || m_nDay > 31)
        return FALSE;

    m_nHours = ((pszDateTime[8] - '0') * 10) +
                (pszDateTime[9] - '0');

    if (m_nHours > 23)
        return FALSE;

    m_nMinutes = ((pszDateTime[10] - '0') * 10) +
                  (pszDateTime[11] - '0');

    if (m_nMinutes > 59)
        return FALSE;

    m_nSeconds = ((pszDateTime[12] - '0') * 10) +
                  (pszDateTime[13] - '0');

    if (m_nSeconds > 59)
        return FALSE;

    //14 is '.'

    m_nMicroseconds = ((pszDateTime[15] - '0') * 100000) +
                      ((pszDateTime[16] - '0') * 10000) +
                      ((pszDateTime[17] - '0') * 1000) +
                      ((pszDateTime[18] - '0') * 100) +
                      ((pszDateTime[19] - '0') * 10) +
                       (pszDateTime[20] - '0');

    //21 is '+' or '-'

    m_nUTC = ((pszDateTime[22] - '0') * 100) +
             ((pszDateTime[23] - '0') * 10) +
              (pszDateTime[24] - '0');

    if (pszDateTime[21] == '-')
        m_nUTC = 0 - m_nUTC;

    m_bValidDateTime = TRUE;

    return TRUE;
}

//=============================================================================
//  Static helper function so outside code can do quick DMTF format checks.
//=============================================================================
BOOL CDateTimeParser::CheckDMTFDateTimeFormat(
    const TCHAR *wszDateTime,
    BOOL bFailIfRelative,
    BOOL bFailIfUnzoned
    )
{

    if (wszDateTime == 0)
        return FALSE;

    int nLen = lstrlen(wszDateTime);
    if (nLen != 25)
        return FALSE;

    // Do two quick checks.  Ensure that the . and : are in
    // the right places or at least that * chars are there.

    wchar_t c1 = wszDateTime[14];
    wchar_t c2 = wszDateTime[21];
    if (!(c1 == L'.' || c1 == L'*'))
        return FALSE;
    if (!(c2 == L'+' || c2 == L'*' || c2 == '-'))
        return FALSE;

    return TRUE;

#ifdef NOT_USED_IN_WIN2000

    BOOL    bReturn = FALSE;

    // Temporary buffer for conversion
    char    szTemp[64];
    int     nNumChars = WideCharToMultiByte( CP_ACP, 0L, wszDateTime, -1, NULL, 0, NULL, NULL );

    if ( nNumChars < sizeof(szTemp) - 1 )
    {
        // We know it will fit, so do the conversion and use the date/time parser to
        // perform a conversion
        WideCharToMultiByte( CP_ACP, 0L, wszDateTime, -1, szTemp, sizeof(szTemp), NULL, NULL );

        // Check for use of asterisks for relative date/time
        if (!bFailIfRelative)
        {
            // Check year and if ALL asterisks then replace with a valid number
            if (szTemp[0] == '*' && szTemp[1] == '*' && szTemp[2] == '*' && szTemp[3] == '*')
            {
                szTemp[0] = '1'; szTemp[1] = '9'; szTemp[2] = '9'; szTemp[3] = '0';
            }
            // Check month and if ALL asterisks then replace with a valid number
            if (szTemp[4] == '*' && szTemp[5] == '*')
            {
                szTemp[4] = '0'; szTemp[5] = '1';
            }
            // Check day and if ALL asterisks then replace with a valid number
            if (szTemp[6] == '*' && szTemp[7] == '*')
            {
                szTemp[6] = '0'; szTemp[7] = '1';
            }
            // Check hour and if ALL asterisks then replace with a valid number
            if (szTemp[8] == '*' && szTemp[9] == '*')
            {
                szTemp[8] = '0'; szTemp[9] = '0';
            }
            // Check minutes and if ALL asterisks then replace with a valid number
            if (szTemp[10] == '*' && szTemp[11] == '*')
            {
                szTemp[10] = '0'; szTemp[11] = '0';
            }
            // Check seconds and if ALL asterisks then replace with a valid number
            if (szTemp[12] == '*' && szTemp[13] == '*')
            {
                szTemp[12] = '0'; szTemp[13] = '0';
            }
            // Check microseconds and if ALL asterisks then replace with a valid number
            if (szTemp[15] == '*' && szTemp[16] == '*' && szTemp[17] == '*' &&
                szTemp[18] == '*' && szTemp[19] == '*' && szTemp[20] == '*')
            {
                szTemp[15] = '0'; szTemp[16] = '0'; szTemp[17] = '0';
                szTemp[18] = '0'; szTemp[19] = '0'; szTemp[20] = '0';
            }
        }

        // Check for use of asterisks for unzoned date/time
        if (!bFailIfUnzoned)
        {
            // Check UTC and if ALL asterisks then replace with a valid number
            if (szTemp[22] == '*' && szTemp[23] == '*' && szTemp[24] == '*')
            {
                szTemp[22] = '0'; szTemp[23] = '0'; szTemp[24] = '0';
            }
        }

        CDateTimeParser dtParse;

        bReturn = dtParse.CheckDMTFDateTimeFormatInternal( szTemp );
    }

    return bReturn;
#endif

}

//=============================================================================
//  Static helper function so outside code can do quick DMTF format checks.
//  Currently, a time interval can only be validated, it cannot be used
//  to initialize a CDateTimeParser instance.
//=============================================================================
BOOL CDateTimeParser::CheckDMTFDateTimeInterval(
    LPCTSTR wszInterval
    )
{

    if (wszInterval == 0)
        return FALSE;

    int nLen = lstrlen(wszInterval);
    if (nLen != 25)
        return FALSE;

    // Do two quick checks.  Ensure that the . and : are in
    // the right places or at least that * chars are there.

    wchar_t c1 = wszInterval[14];
    wchar_t c2 = wszInterval[21];
    if (!(c1 == L'.' || c1 == L'*'))
        return FALSE;
    if (!(c2 == L':' || c2 == L'*'))
        return FALSE;


    return TRUE;

#ifdef NOT_USED_IN_WIN2000

    // Temporary buffer for conversion
    char    szTemp[64];
    int     nNumChars = WideCharToMultiByte( CP_ACP, 0L, wszInterval, -1, NULL, 0, NULL, NULL );

    if ( nNumChars < sizeof(szTemp) - 1 )
    {
        // We know it will fit, so do the conversion and use the date/time parser to
        // perform a conversion
        WideCharToMultiByte( CP_ACP, 0L, wszInterval, -1, szTemp, sizeof(szTemp), NULL, NULL );

        // =======================================================================================
        // Check the date time for a valid DMTF interval string:
        //   ddddddddHHMMSS.mmmmmm:000
        // Note, this code is a near duplicate of the checks used to test the non-interval format.
        // =======================================================================================

        if (strlen(szTemp) != 25)
            return FALSE;

        //Validate digits and puntuation...
        for (int i = 0; i < 14; i++)
        {
            if (!isdigit(szTemp[i]))
                return FALSE;
        }
        if (szTemp[i] != '.')
            return FALSE;
        for (i++;i < 21; i++)
        {
            if (!isdigit(szTemp[i]))
                return FALSE;
        }
        if (szTemp[i] != ':')
            return FALSE;
        for (i++; i < 25; i++)
        {
            if (szTemp[i] != '0')
                return FALSE;
        }

        int nHours = ((szTemp[8] - '0') * 10) +
                    (szTemp[9] - '0');

        if (nHours > 23)
            return FALSE;

        int nMinutes = ((szTemp[10] - '0') * 10) +
                      (szTemp[11] - '0');

        if (nMinutes > 59)
            return FALSE;

        int nSeconds = ((szTemp[12] - '0') * 10) +
                      (szTemp[13] - '0');

        if (nSeconds > 59)
            return FALSE;

        return TRUE;
    }

    return FALSE;
#endif

}

//=============================================================================
//  Goes through each of the date formats checking to see if any are valid
//=============================================================================
BOOL CDateTimeParser::CheckDateFormat(const TCHAR *pszDate, BOOL bCheckTimeAfter)
{
    if (DateFormat1(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat2(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat3(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat4(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat5(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat6(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat7(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat8(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat15(pszDate, bCheckTimeAfter))
        return TRUE;

    switch(m_nDayFormatPreference)
    {
    case dmy:
        if (DateFormat10(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case dym:
        if (DateFormat12(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case mdy:
        if (DateFormat9(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case myd:
        if (DateFormat11(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case ydm:
        if (DateFormat13(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case ymd:
        if (DateFormat14(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, __TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    default:
        return FALSE;
    }

    return FALSE;
}

//=============================================================================
//  Goes through each of the time formats checking to see if any are valid
//  Order is important here.  Re-arranged to properly recognize AM/PM - mdavis.
//=============================================================================
BOOL CDateTimeParser::CheckTimeFormat(const TCHAR *pszTime, BOOL bCheckDateAfter)
{
    if (TimeFormat1(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat3(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat2(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat5(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat4(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat8(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat6(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat9(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat7(pszTime, bCheckDateAfter))
        return TRUE;

    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'Mon[th] dd[,] [yy]yy'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat1(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidMonthString(pszString, __TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidDayNumber(NULL, __TEXT(" ,")) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'Mon[th][,] yyyy'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat2(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidMonthString(pszString, __TEXT(" ,"), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), TRUE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'Mon[th] [yy]yy dd'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat3(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidMonthString(pszString, __TEXT(" ,"), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), FALSE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, __TEXT(" ")) != ok)
        goto error;


    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }
    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'dd Mon[th][,][ ][yy]yy'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat4(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidDayNumber(pszString, __TEXT(" ")) != ok)
        goto error;

    if (IsValidMonthString(NULL, __TEXT(" ,"), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'dd [yy]yy Mon[th]'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat5(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidDayNumber(pszString, __TEXT(" ")) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), FALSE) != ok)
        goto error;

    if (IsValidMonthString(NULL, __TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  '[yy]yy Mon[th] dd'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat6(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidYearNumber(pszString, __TEXT(" "), FALSE) != ok)
        goto error;

    if (IsValidMonthString(NULL, __TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidDayNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == ' ')
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != '\0')
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  yyyy Mon[th]
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat7(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];


    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidYearNumber(pszString, __TEXT(" "), TRUE) != ok)
        goto error;

    if (IsValidMonthString(NULL, __TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  yyyy dd Mon[th]
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat8(const TCHAR *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidYearNumber(pszString, __TEXT(" "), TRUE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (IsValidMonthString(NULL, __TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != '\0')
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  '[M]M{/-.}dd{/-.}[yy]yy         -> Separators have to be the same
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat9(const TCHAR *pszDateTime,
                                  const TCHAR *pszDateSeparator,
                                  BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];


    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidMonthNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidDayNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  dd{/-.}[M]M{/-.}[yy]yy      -> Separators have to be the same
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat10(const TCHAR *pszDateTime,
                                   const TCHAR *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidDayNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, __TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [M]M{/-.}[yy]yy{/-.}dd      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat11(const TCHAR *pszDateTime,
                                   const TCHAR *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidMonthNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  dd{/-.}[yy]yy{/-.}[M]M      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat12(const TCHAR *pszDateTime,
                                   const TCHAR *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidDayNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [yy]yy{/-.}dd{/-.}[M]M      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat13(const TCHAR *pszDateTime,
                                   const TCHAR *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidYearNumber(pszString, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [yy]yy{/-.}[M]M{/-.}dd      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat14(const TCHAR *pszDateTime,
                                   const TCHAR *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidYearNumber(pszString, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidDayNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [yy]yyMMdd
//  yyyy[MM[dd]]
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat15(const TCHAR *pszDateTime,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidYearMonthDayNumber(pszString) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}


//=============================================================================
//  Checks for time in the following format...
//  hh[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat1(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1],
          *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, __TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat2(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat3(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1],
          *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, __TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat4(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat5(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1],
          *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, __TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss:uuu
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat6(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidColonMillisecond(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss.[[u]u]u
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat7(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1];

    if (!pszString)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, __TEXT(".")) != ok)
        goto error;

    if (IsValidDotMillisecond(NULL, __TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss:uuu[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat8(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1],
          *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidColonMillisecond(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, __TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss.[[u]u]u[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat9(const TCHAR *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    TCHAR *pszString = new TCHAR[lstrlen(pszDateTime) + 1],
          *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    lstrcpy(pszString, pszDateTime);

    if (IsValidHourNumber(pszString, __TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, __TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, __TEXT(".")) != ok)
        goto error;

    if (IsValidDotMillisecond(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, __TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        TCHAR *pszRemainingString = _tcstok(NULL, __TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == __TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != __TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}


//=========================================================================
//Check the month.
//=========================================================================
int CDateTimeParser::IsValidMonthString(TCHAR *pszString,
                                           const TCHAR *pszSeparator,
                                           TCHAR *pszFullMonth[],
                                           TCHAR *pszShortMonth[])
{
    BOOL bOK = FALSE;

    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip spaces
    while (*pszToken == __TEXT(' '))
        pszToken++;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Work through the possible months...
    for (int i = 0; i < 12; i++)
    {
        if ((lstrcmpi(pszShortMonth[i], pszToken) == 0) ||
            (lstrcmpi(pszFullMonth[i], pszToken) == 0))
        {
            //That is valid...
            bOK = TRUE;
            break;
        }
    }

    //Is this a valid month?
    if (!bOK)
    {
        return failed;
    }

    m_nMonth = i + 1;

    return ok;
}

//=========================================================================
//Check the month as a number.
//=========================================================================
int CDateTimeParser::IsValidMonthNumber(TCHAR *pszString,
                                        const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip spaces...
    while (*pszToken == __TEXT(' '))
        pszToken++;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _ttoi(pszToken);

    if ((i < 1) || (i > 12))
        return failed;

    m_nMonth = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the day.
//=========================================================================
int CDateTimeParser::IsValidDayNumber(TCHAR *pszString,
                                      const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip spaces...
    while (*pszToken == __TEXT(' '))
        pszToken++;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _ttoi(pszToken);

    if ((i < 1) || (i > 31))
        return failed;

    m_nDay = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the year.
//=========================================================================
int CDateTimeParser::IsValidYearNumber(TCHAR *pszString,
                                       const TCHAR *pszSeparator,
                                       BOOL bFourDigitsOnly)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip space
    while (*pszToken == __TEXT(' '))
        pszToken++;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //Needs to be 2 or 4 digits
    if ((i != 2) && (i != 4))
        return failed;

    if ((i == 2) && bFourDigitsOnly)
        return failed;

    //convert it to a number
    m_nYear = _ttoi(pszToken);

    //Do any conversions for 2 digit years...
    if ((i == 2) && (m_nYear < 50))
    {
        m_nYear += 2000;
    }
    else if (i == 2)
    {
        m_nYear += 1900;
    }

    return ok;
}

//=========================================================================
//Check the hours.
//=========================================================================
int CDateTimeParser::IsValidHourNumber(TCHAR *pszString,
                                       const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip space
    while (*pszToken == __TEXT(' '))
        pszToken++;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _ttoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 23))
        return failed;

    m_nHours = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the Minutes.
//=========================================================================
int CDateTimeParser::IsValidMinuteNumber(TCHAR *pszString,
                                         const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _ttoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 59))
        return failed;

    m_nMinutes = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the Seconds.
//=========================================================================
int CDateTimeParser::IsValidSecondNumber(TCHAR *pszString,
                                         const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _ttoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 59))
        return failed;

    m_nSeconds = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the milliseconds.  This is a colon prefix version
//=========================================================================
int CDateTimeParser::IsValidColonMillisecond(TCHAR *pszString,
                                             const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _ttoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 999))
        return failed;

    //milliseconds to microseconds
    m_nMicroseconds = i * 1000;

    return ok;
}

//=========================================================================
//Check the milliseconds.  This is a dot prefix (decimal) version
//=========================================================================
int CDateTimeParser::IsValidDotMillisecond(TCHAR *pszString,
                                           const TCHAR *pszSeparator)
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    int nVal = _ttoi(pszToken);

    //Convert the value into thousandths of a second.
    if (i < 3)
        nVal *= 10;

    if (i < 2)
        nVal *= 10;

    //Validate a little
    if ((nVal < 0) || (nVal > 999))
        return failed;

    //milliseconds to microseconds
    m_nMicroseconds = nVal * 1000;

    return ok;
}

//=========================================================================
//Check the AM/PM part.
//=========================================================================
int CDateTimeParser::IsValidAmPmString(TCHAR *pszString,
                                       const TCHAR *pszSeparator,
                                       TCHAR *pszAmPm[])
{
    TCHAR *pszToken = _tcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    BOOL bOK = FALSE;

    //Skip spaces
    while (*pszToken == __TEXT(' '))
    {
        pszToken++;
    }

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    //Work through the possible AM/PM items...
    for (int i = 0; i < 2; i++)
    {
        if (lstrcmpi(pszAmPm[i], pszToken) == 0)
        {
            //That is valid...
            bOK = TRUE;
            break;
        }
    }

    if (!bOK)
        return failed;

    if (i == 1)
    {
        //PM adds 12 hours
        m_nHours += 12;
    }
    else if (m_nHours == 12)
    {
        //for AM, 12 o'clock equals 0 in 24 hour time.
        m_nHours = 0;
    }


    //Does this make the number too large now?
    if (m_nHours > 23)
        return failed;

    return ok;
}

//=========================================================================
//  Check the purely numeric year, month, day format...
//  [yy]yyMMdd
//  yyyy[MMdd]
//  NOTE:   6 and 8 digit dates are always ymd.
//          4 digits is always year
//=========================================================================
int CDateTimeParser::IsValidYearMonthDayNumber(TCHAR *pszString)
{
    int j;
    TCHAR *pszToken = _tcstok(pszString, __TEXT(" "));
    if (pszToken == NULL)
        return nothingLeft;

    BOOL bOK = FALSE;

    //Skip spaces
    while (*pszToken == __TEXT(' '))
    {
        pszToken++;
    }

    if (*pszToken == __TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != __TEXT('\0'); i++)
    {
        if (!isdigit(pszToken[i]))
            return failed;
    }

    //We support 4, 6 and 8 digits
    if ((i != 4) && (i != 6) && (i != 8))
        return failed;

    //4 digit years...
    if ((i == 4) || (i == 8))
    {
        m_nYear = 0;
        for (j = 0;j < 4; j++)
        {
            m_nYear *= 10;
            m_nYear += (*pszToken - '0');
            pszToken++;
        }
    }
    else
    {
        //2 digit years
        m_nYear = 0;
        for (j = 0;j < 2; j++)
        {
            m_nYear *= 10;
            m_nYear += (*pszToken - '0');
            pszToken++;
        }

        if (m_nYear >= 50)
        {
            m_nYear += 1900;
        }
        else
        {
            m_nYear += 2000;
        }
    }

    //If we have month and year...
    if (i > 4)
    {
        m_nMonth = ((*pszToken - __TEXT('0')) * 10) + (*(pszToken+1) - __TEXT('0'));
        pszToken += 2;

        if ((m_nMonth < 0) && (m_nMonth > 12))
            return failed;

        m_nDay = ((*pszToken - __TEXT('0')) * 10) + (*(pszToken+1) - __TEXT('0'));
        if ((m_nDay < 0) && (m_nDay > 31))
            return failed;
    }

    return ok;
}

int CDateTimeParser::FillDMTF(WCHAR* pwszBuffer)
{
    if(!IsValidDateTime())
        return failed;

    swprintf(pwszBuffer, L"%04d%02d%02d%02d%02d%02d.%06d%c%03d",
        m_nYear, m_nMonth, m_nDay, m_nHours, m_nMinutes, m_nSeconds,
        m_nMicroseconds,
        ((m_nUTC >= 0)?L'+':L'-'),
        ((m_nUTC >= 0)?m_nUTC:-m_nUTC));

    return ok;
}

BOOL NormalizeCimDateTime(
    IN  LPCWSTR pszSrc,
    OUT BSTR *strAdjusted
    )
{
    int yr = 0, mo = 0, da = 0, hh = 0, mm = 0, ss = 0, micro = 0, utcOffset = 0;
    wchar_t wcSign = 0;

    if (pszSrc == 0 || strAdjusted == 0)
        return FALSE;

    // Parse DMTF format.
    // yyyymmddhhmmss.mmmmmmsuuu
    // =========================

    swscanf(pszSrc, L"%04d%02d%02d%02d%02d%02d.%06d%C%03d",
        &yr, &mo, &da, &hh, &mm, &ss, &micro, &wcSign, &utcOffset
        );

    if (wcSign == 0)
        return FALSE;

    // Convert to Win32 time for adjustment.
    // =====================================

    SYSTEMTIME st;
    FILETIME ft;

    st.wYear = WORD(yr);
    st.wMonth = WORD(mo);
    st.wDay = WORD(da);
    st.wDayOfWeek = 0;
    st.wHour = WORD(hh);
    st.wMinute = WORD(mm);
    st.wSecond = WORD(ss);
    st.wMilliseconds = WORD(micro / 1000);

    BOOL bRes = SystemTimeToFileTime(&st, &ft);
    if (!bRes)
        return bRes;

    ULARGE_INTEGER ul;
    ul.HighPart = ft.dwHighDateTime;
    ul.LowPart = ft.dwLowDateTime;
    unsigned __int64 u64 = ul.QuadPart;

    // Adjust rest of time so that we normalize to UTC

    if (wcSign == L'-')
        u64 += (unsigned __int64) 600000000 * (unsigned __int64) utcOffset;
    else
        u64 -= (unsigned __int64) 600000000 * (unsigned __int64) utcOffset;

    ul.QuadPart = u64;
    ft.dwHighDateTime = ul.HighPart;
    ft.dwLowDateTime = ul.LowPart;

    bRes = FileTimeToSystemTime(&ft, &st);
    if (!bRes)
        return bRes;

    wchar_t buf[128];
    swprintf(buf, L"%04d%02d%02d%02d%02d%02d.%06d+000",
        st.wYear, st.wMonth, st.wDay,
        st.wHour, st.wMinute, st.wSecond, st.wMilliseconds*1000
        );

    *strAdjusted = SysAllocString(buf);
    if (*strAdjusted == 0)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\datetimeparser.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DATETIMEPARSER.H

Abstract:

    Validates a date/time string and converts into it's component values.

History:

--*/

#ifndef _datetimeparser_
#define _datetimeparser_

#include "corepol.h"

class POLARITY CDateTimeParser
{
public:
    enum { ok = 0, failed, nothingLeft };

    //nDayFormatPreference values
    typedef enum { dmy, dym, mdy, myd, ydm, ymd } DayFormatPreference;

    //Constructor. This takes a DateTime string and parses it.
    CDateTimeParser(const TCHAR *pszDateTime);

    //Destructor.  Tidies up after itself.
    ~CDateTimeParser();

    //Tidies up and parses a new date and time.
    BOOL SetDateTime(const TCHAR *pszDateTime);

    //Returns the status of the currently parsed date/time.
    BOOL IsValidDateTime()          { return m_bValidDateTime; }

    //Retrieves the bits and pieces we found.  Zero means it was not
    //found or was zero!  This may change!
    unsigned char GetDay()          { return m_nDay; }
    unsigned char GetMonth()        { return m_nMonth; }
    unsigned int  GetYear()         { return m_nYear; }
    unsigned char GetHours()        { return m_nHours; }
    unsigned char GetMinutes()      { return m_nMinutes; }
    unsigned char GetSeconds()      { return m_nSeconds; }
    unsigned int  GetMicroseconds() { return m_nMicroseconds; }
    int  GetUTC()           { return m_nUTC; }

    int FillDMTF(WCHAR* pwszBuffer);

    // Static helper functions to allow other code to perform quick DMTF DateTime validation
    // without executing a lot of unnecessary NLS code.

    static BOOL CheckDMTFDateTimeFormat(const TCHAR *wszDateTime, BOOL bFailIfRelative = FALSE,
                    BOOL bFailIfUnzoned = FALSE);
    static BOOL CheckDMTFDateTimeInterval(const TCHAR *wszInterval);

protected:

    // Protected constructor, to keep outside code from instantiating us in a half-initialized
    // state.  This constructor is used by a static helper function for validating DMTF formats.
    CDateTimeParser(void);

    // Prevents others from accessing
    //Resets all the date/time values to the default values.
    //If bSQL is TRUE it sets to the SQL default.  Otherwise
    //sets to the DMTF default.
    void ResetDateTime(BOOL bSQL);
    void ResetDate(BOOL bSQL);
    void ResetTime(BOOL bSQL);

    //Does a check to make sure the date/time is in the DMTF
    //date/time format.
    //Fills in the class date/time elements.
    BOOL CheckDMTFDateTimeFormatInternal(const TCHAR *pszDateTime);

    //Does a check from the start of the string specified.  If
    //bCheckTimeAfter set a call to CheckTimeFormat is called
    //after each successful parse of the date.
    //Fills in the class date/time elements.
    BOOL CheckDateFormat(const TCHAR *pszDate, BOOL bCheckTimeAfter);

    //Does a check from the start of the string specified.  If
    //bCheckDateAfter set a call to CheckDateFormat is called
    //after each successful parse of the time.
    //Fills in the class date/time elements.
    BOOL CheckTimeFormat(const TCHAR *pszTime, BOOL bCheckDateAfter);

    BOOL DateFormat1(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat2(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat3(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat4(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat5(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat6(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat7(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat8(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat9(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat10(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat11(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat12(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat13(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat14(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat15(const TCHAR *pszDate, BOOL bCheckTimeAfter);

    BOOL TimeFormat1(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat2(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat3(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat4(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat5(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat6(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat7(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat8(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat9(const TCHAR *pszTime, BOOL bCheckDateAfter);

    //Checks for long and short month string.  Leading spaces allowed.
    int IsValidMonthString(TCHAR *pszString,
                           const TCHAR *pszSeparator,
                           TCHAR *pszFullMonth[13],
                           TCHAR *pszShortMonth[13]);

    //Checks for a month as a numeric string.  Leading spaces allowed.
    //Checks to make sure month is in range 1-12
    int IsValidMonthNumber(TCHAR *pszString,
                           const TCHAR *pszSeparator);

    //Checks for valid day number.  Does no validation of
    //number except checking it is in range of 1-31
    //Leading spaces allowed.
    int IsValidDayNumber(TCHAR *pszString,
                         const TCHAR *pszSeparator);

    //Checks for valid year number.  Does conversion for
    //2 digit years.  Leading spaces allowed.
    int IsValidYearNumber(TCHAR *pszString,
                          const TCHAR *pszSeparator,
                          BOOL bFourDigitsOnly);

    //Checks for valid hours.  Validates for range 0-23
    //Leading spaces allowed.
    int IsValidHourNumber(TCHAR *pszString,
                          const TCHAR *pszSeparator);

    //Checks for valid minutes.  Validates for range 0-59.
    //No leading spaces allowed.
    int IsValidMinuteNumber(TCHAR *pszString,
                            const TCHAR *pszSeparator);

    //Checks for valid minutes.  Validates for range 0-59.
    //No leading spaces allowed.
    int IsValidSecondNumber(TCHAR *pszString,
                            const TCHAR *pszSeparator);

    //treats the number as thousandth of a second.
    int IsValidColonMillisecond(TCHAR *pszString,
                                const TCHAR *pszSeparator);

    //converts value to a thousandth of a second based on number
    //of digits included.
    int IsValidDotMillisecond(TCHAR *pszString,
                              const TCHAR *pszSeparator);

    //Checks for valid AM/PM string.  Leading space is allowed.  If
    //PM, adds 12 onto hours.  Validates hours so it is < 23.
    BOOL IsValidAmPmString(TCHAR *pszString,
                           const TCHAR *pszSeparator,
                           TCHAR *pszAmPm[2]);

    //Checks for a valid [yy]yyMMdd or yyyy day.  Validates
    //month to 1..12 and day to 1..31
    BOOL IsValidYearMonthDayNumber(TCHAR *pszString);

    void GetLocalInfoAndAlloc(LCTYPE LCType, LPTSTR &lpLCData);
    void GetPreferedDateFormat();
    TCHAR* AllocAmPm();

private:
    //Localised strings retrieved from GetLocalInfo which holds the long month strings
    TCHAR * m_pszFullMonth[13];

    //Localised strings retrieved from GetLocalInfo which holds the short month strings
    TCHAR * m_pszShortMonth[13];

    //Localised strings retrieved from GetLocalInfo which holds the short am/pm strings
    TCHAR *m_pszAmPm[2];

    //Lets us know if the string is valid or not.
    BOOL m_bValidDateTime;

    //These are the values which get filled in as we find then throughout the
    //parsing.
    unsigned char m_nDay;
    unsigned char m_nMonth;
    unsigned int  m_nYear;
    unsigned char m_nHours;
    unsigned char m_nMinutes;
    unsigned char m_nSeconds;
    unsigned int  m_nMicroseconds;
    int  m_nUTC;

    //Preference for date decoding
    DayFormatPreference m_nDayFormatPreference;
};

BOOL POLARITY NormalizeCimDateTime(
    IN  LPCWSTR pszSrc,
    OUT BSTR *strAdjusted
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\cwbemtime.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CWBEMTIME.H

Abstract:

    Time helper

History:

--*/

#ifndef __WBEM_TIME__H_
#define __WBEM_TIME__H_

#include "corepol.h"

#define WBEMTIME_LENGTH	25

class POLARITY CWbemInterval
{
protected:
    DWORD m_dwMs;

    CWbemInterval(DWORD dwMs) : m_dwMs(dwMs){}
    friend class CWbemTime;
public:
    CWbemInterval() : m_dwMs(0){}

    static CWbemInterval GetInfinity() {return CWbemInterval(INFINITE);}
    BOOL IsFinite() const {return m_dwMs != INFINITE;}
    BOOL IsZero() const {return m_dwMs == 0;}

    DWORD GetMilliseconds() const {return m_dwMs;}
    DWORD GetSeconds() const {return m_dwMs/1000;}
    void SetMilliseconds(DWORD dwMs) {m_dwMs = dwMs;}

    BOOL operator<(const CWbemInterval Other)
        {return m_dwMs < Other.m_dwMs;}
    BOOL operator>(const CWbemInterval Other)
        {return m_dwMs > Other.m_dwMs;}
    
    CWbemInterval operator*(double dblFactor) const
        {return CWbemInterval((DWORD)(m_dwMs * dblFactor));}

    CWbemInterval operator+(const CWbemInterval Other) const
        {return CWbemInterval(m_dwMs + Other.m_dwMs);}

    void operator+=(const CWbemInterval Other)
        {m_dwMs += Other.m_dwMs;}
};

#define I64_INFINITY 0x7FFFFFFFFFFFFFFF

class POLARITY CWbemTimeSpan 
{
private:

    ULONGLONG m_Time;
    friend class CWbemTime;

public:

    CWbemTimeSpan ( 

        int iDays , 
        int iHours , 
        int iMinutes ,  
        int iSeconds , 
        int iMSec=0 , 
        int iUSec=0, 
        int iNSec=0 
    ) ;

};

class POLARITY CWbemTime
{
protected:
    __int64 m_i64;

    CWbemTime(__int64 i64) : m_i64(i64){}
    friend class CWbemInterval;
public:
    CWbemTime() : m_i64(0){}
    CWbemTime(const CWbemTime& Other) : m_i64(Other.m_i64){}
    void operator=(const CWbemTime& Other)
    {
        m_i64 = Other.m_i64;
    }

    static CWbemTime GetCurrentTime();
    static CWbemTime GetInfinity() {return CWbemTime(I64_INFINITY);}
    static CWbemTime GetZero() {return CWbemTime(0);}

    BOOL SetSystemTime(const SYSTEMTIME& st);
    BOOL SetFileTime(const FILETIME& ft);
    BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
    BOOL GetFILETIME ( FILETIME *pst ) const;

    __int64 Get100nss() const {return m_i64;}
    void Set100nss(__int64 i64) {m_i64 = i64;}

    CWbemInterval RemainsUntil(const CWbemTime& Other) const;
    BOOL IsFinite() const {return m_i64 != I64_INFINITY;}
    BOOL IsZero() const {return m_i64 == 0;}
   
    CWbemTime        operator+ ( const CWbemTimeSpan &uAdd ) const ;
    CWbemTime        operator- ( const CWbemTimeSpan &sub ) const;

    BOOL operator <(const CWbemTime& Other) const 
        {return m_i64 < Other.m_i64;}
    BOOL operator >(const CWbemTime& Other) const 
        {return m_i64 > Other.m_i64;}
    BOOL operator <=(const CWbemTime& Other) const 
        {return m_i64 <= Other.m_i64;}
    BOOL operator >=(const CWbemTime& Other) const 
        {return m_i64 >= Other.m_i64;}
    CWbemTime operator+(const CWbemInterval& ToAdd) const;
    CWbemInterval operator-(const CWbemTime& ToSubtract) const
        {return ToSubtract.RemainsUntil(*this);}

    BOOL SetDMTF(LPCWSTR wszText);
	BOOL GetDMTF( BOOL bLocal, DWORD dwBuffLen, LPWSTR pwszBuff );

	static LONG GetLocalOffsetForDate(const SYSTEMTIME *pst);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\dothrow.cpp ===
#include "precomp.h"
#include <dothrow.h>
const CX_MemoryException wmibad_alloc;

void dothrow_t::raise_bad_alloc()
{
	throw wmibad_alloc;
}

void dothrow_t::raise_lock_failure()
{
	throw wmibad_alloc;
}

const dothrow_t dothrow;
const wminothrow_t wminothrow;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\evtlog.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EVTLOG.CPP

Abstract:

    Event Log helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "CWbemTime.h"
#include <evtlog.h>
#include <genutils.h>

CInsertionString::CInsertionString(long l) : m_bEmpty(FALSE)
{
    WCHAR wsz[100];
    swprintf(wsz, L"%d", l);
    m_ws = wsz;
}

CInsertionString::CInsertionString(CHex h) : m_bEmpty(FALSE)
{
    WCHAR wsz[100];
    swprintf(wsz, L"0x%x", (long)h);
    m_ws = wsz;
}

CEventLogRecord::CEventLogRecord(WORD wType, DWORD dwEventID, 
                    CInsertionString s1,
                    CInsertionString s2,
                    CInsertionString s3,
                    CInsertionString s4,
                    CInsertionString s5,
                    CInsertionString s6,
                    CInsertionString s7,
                    CInsertionString s8,
                    CInsertionString s9,
                    CInsertionString s10)
{
    m_wType = wType;
    m_dwEventID = dwEventID;
    m_CreationTime = CWbemTime::GetCurrentTime();
   
    AddInsertionString(s10);
    AddInsertionString(s9);
    AddInsertionString(s8);
    AddInsertionString(s7);
    AddInsertionString(s6);
    AddInsertionString(s5);
    AddInsertionString(s4);
    AddInsertionString(s3);
    AddInsertionString(s2);
    AddInsertionString(s1);
}

void CEventLogRecord::AddInsertionString(CInsertionString& s)
{
    if(!s.IsEmpty() || m_awsStrings.Size() > 0)
        m_awsStrings.InsertAt(0, s.GetString());
}

LPCWSTR CEventLogRecord::GetStringAt(int nIndex)
{
    if(nIndex >= m_awsStrings.Size())
        return NULL;
    else 
        return m_awsStrings[nIndex];
}

BOOL CEventLogRecord::operator==(const CEventLogRecord& Other)
{
    if(m_wType != Other.m_wType)
        return FALSE;
    if(m_dwEventID != Other.m_dwEventID)
        return FALSE;
    if(m_awsStrings.Size() != Other.m_awsStrings.Size())
        return FALSE;

    for(int i = 0;  i < m_awsStrings.Size(); i++)
    {
        if(wcscmp(m_awsStrings[i], Other.m_awsStrings[i]))
        {
            return FALSE;
        }
    }

    return TRUE;
}

    


CEventLog::CEventLog(LPCWSTR wszUNCServerName, LPCWSTR wszSourceName, 
                        DWORD dwTimeout)
    : m_wsServerName(wszUNCServerName), m_wsSourceName(wszSourceName),
        m_hSource(NULL), m_fLog(NULL), m_dwTimeout(dwTimeout)
{
    m_pRecords = new LogRecords;
    m_bNT = IsNT();
}

CEventLog::~CEventLog()
{
    delete m_pRecords;
    Close();
}

BOOL CEventLog::Close()
{
    if(m_bNT)
    {
        if(m_hSource != NULL)
        {
            DeregisterEventSource(m_hSource);
            m_hSource = NULL;
        }
    }

    return TRUE;
}

BOOL CEventLog::Open()
{
    if(m_bNT)
    {
        if(m_hSource == NULL)
        {
            m_hSource = RegisterEventSourceW(m_wsServerName, m_wsSourceName);
        }
        return (m_hSource != NULL);
    }
    else return TRUE;
}

BOOL CEventLog::SearchForRecord(CEventLogRecord* pRecord)
{
    for(int i = 0; i < m_pRecords->GetSize(); i++)
    {
        // Check if this record is still current
        // =====================================

        CWbemInterval Age = 
            CWbemTime::GetCurrentTime() - (*m_pRecords)[i]->GetCreationTime();
        if(Age.GetSeconds() > m_dwTimeout)
        {
            m_pRecords->RemoveAt(i);
            i--;
            continue;
        }

        // Compare the data
        // ================

        if( *(*m_pRecords)[i] == *pRecord)
            return TRUE;
    }
    return FALSE;
}

void CEventLog::AddRecord(CEventLogRecord* pRecord)
{
    m_pRecords->Add(pRecord);
}

BOOL CEventLog::Report(WORD wType, DWORD dwEventID, 
                CInsertionString s1,
                CInsertionString s2,
                CInsertionString s3,
                CInsertionString s4,
                CInsertionString s5,
                CInsertionString s6,
                CInsertionString s7,
                CInsertionString s8,
                CInsertionString s9,
                CInsertionString s10)
{
    CInCritSec ics(&m_cs);

    // Create a record
    // ===============

    CEventLogRecord* pRecord = new CEventLogRecord(wType, dwEventID, 
        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10);
    if(!pRecord)
        return FALSE;

    // Search for it
    // =============

    BOOL bDuplicate = SearchForRecord(pRecord);
    if(bDuplicate)
    {
        delete pRecord;
        return TRUE;
    }

    AddRecord(pRecord);

    WORD wNumStrings = pRecord->GetNumStrings();

    // Log it
    // ======

    if(m_bNT)
    {
        if(m_hSource == NULL)
            return FALSE;

        LPCWSTR* awszStrings = new LPCWSTR[wNumStrings];
        if(!awszStrings)
            return FALSE;
        for(int i = 0; i < wNumStrings; i++)
            awszStrings[i] = pRecord->GetStringAt(i);
    
        BOOL bRes = ReportEventW(m_hSource, wType, 0, dwEventID, NULL, 
                        wNumStrings, 0, awszStrings, NULL);

        delete [] awszStrings;
        return bRes;
    }
    else
    {
        Registry r(HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_WINMGMT);
        TCHAR* szInstDir;
        if(r.GetStr(__TEXT("Working Directory"), &szInstDir) != Registry::no_error)
        {
            ERRORTRACE((LOG_EVENTLOG, "Logging is unable to read the system "
                                            "registry!\n"));
            return FALSE;
        }
        CDeleteMe<TCHAR> dm1(szInstDir);
        TCHAR* szDllPath = new TCHAR[lstrlen(szInstDir) + 100];
        if(!szDllPath)
            return FALSE;
        wsprintf(szDllPath, __TEXT("%s\\WinMgmtR.dll"), szInstDir);
        HINSTANCE hDll = LoadLibrary(szDllPath);
        delete [] szDllPath;
        if(hDll == NULL)
        {
            ERRORTRACE((LOG_EVENTLOG, "Logging is unable to open the message "
                            "DLL. Error code %d\n", GetLastError()));
            return FALSE;
        }
        

        LPSTR* aszStrings = new LPSTR[wNumStrings];
        if(!aszStrings)
            return FALSE;
        int i;
        for(i = 0; i < wNumStrings; i++)
            aszStrings[i] = WString(pRecord->GetStringAt(i)).GetLPSTR();
    
        char* szMessage;
        DWORD dwRes = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                            FORMAT_MESSAGE_FROM_HMODULE | 
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            hDll, dwEventID, 0, (char*)&szMessage,
                            0, (va_list*)aszStrings);

        for(i = 0; i < wNumStrings; i++)
            delete [] aszStrings[i];
        delete [] aszStrings;

        if(dwRes == 0)
        {
            ERRORTRACE((LOG_EVENTLOG, "Logging is unable to format the message "
                            "for event 0x%X. Error code: %d\n", 
                    dwEventID, GetLastError()));
            return FALSE;
        }
                        
        switch(wType)
        {
        case EVENTLOG_ERROR_TYPE:
        case EVENTLOG_WARNING_TYPE:
        case EVENTLOG_AUDIT_FAILURE:
            ERRORTRACE((LOG_EVENTLOG, "%s\n", szMessage));
        default:
            DEBUGTRACE((LOG_EVENTLOG, "%s\n", szMessage));
        }
        
        LocalFree(szMessage);

        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\dothrow.h ===
#ifndef DOTHROW_H
#define DOTHROW_H
#include <new>
#include <corex.h>


struct dothrow_t 
{
	static void raise_bad_alloc();
	static void raise_lock_failure();
};

struct wminothrow_t 
{
	static void raise_bad_alloc(){};
	static void raise_lock_failure(){};
};

extern const dothrow_t dothrow;
extern const wminothrow_t wminothrow;

typedef wminothrow_t NOTHROW;
typedef dothrow_t DOTHROW;

/*
#if _MSC_VER > 1400

void * _cdecl operator new[](size_t size, const dothrow_t& ex_spec)
{
	void * p = ::operator new[](size);
	if (p) return p;
	dothrow_t::raise_bad_alloc();
	return p;

};

void _cdecl operator delete[](void * p, const dothrow_t&)
{
	::operator delete[](p);
};

#endif
*/

inline void * _cdecl operator new(size_t size,const dothrow_t&  ex_spec)
{
	void * p = operator new(size);
	if (p) return p;
	dothrow_t::raise_bad_alloc();
    return p;
};

inline void _cdecl operator delete(void * p, const dothrow_t&)
{
	operator delete(p);
};


// TEMPLATE CLASS allocator
template<class Ty>
	class throw_allocator {
public:
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef Ty *pointer;
	typedef const Ty *const_pointer;
	typedef Ty & reference;
	typedef const Ty & const_reference;
	typedef Ty value_type;
	pointer address(reference X) const
		{return (&X); }
	const_pointer address(const_reference X) const
		{return (&X); }
	pointer allocate(size_type N, const void *)
		{return (Allocate((difference_type)N, (pointer)0)); }
	char *_Charalloc(size_type N)
		{return (Allocate((difference_type)N,
			(char *)0)); }
	void deallocate(void *P, size_type)
		{operator delete(P,dothrow); }
	void construct(pointer P, const Ty& V)
		{Construct(P, V); }
	void destroy(pointer P)
		{Destroy(P); }
	size_t max_size() const
		{size_t N = (size_t)(-1) / sizeof (Ty);
		return (0 < N ? N : 1); }
	// TEMPLATE FUNCTION _Construct
	template<class T1, class T2> inline
		void Construct(T1 *P, const T2& V)
		{new ((void *)P) T1(V); }

	// TEMPLATE FUNCTION _Destroy
	template<class Ty> inline
	void Destroy(Ty *P)
		{_DESTRUCTOR(Ty, P); }

	inline void Destroy(char *)
	{}
	inline void Destroy(wchar_t *)
	{}
	// TEMPLATE FUNCTION _Allocate
	template<class Ty> inline
	Ty *Allocate(ptrdiff_t N, Ty *)
	{if (N < 0)
		N = 0;
	return ((Ty *)operator new(
		(size_t)N * sizeof (Ty),dothrow)); }

	};

template<class Ty, class U> inline
	bool operator==(const throw_allocator<Ty>&, const throw_allocator<U>&)
	{return (true); }
template<class Ty, class U> inline
	bool operator!=(const throw_allocator<Ty>&, const throw_allocator<U>&)
	{return (false); }

// CLASS allocator<void>
template<> class _CRTIMP throw_allocator<void> {
public:
	typedef void Ty;
	typedef Ty *pointer;
	typedef const Ty *const_pointer;
	typedef Ty value_type;
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexarry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.CPP

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.
  24-Apr-96   a-raymcc    Updated for CArena support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <flexarry.h>
#include <corex.h>
#include "strutils.h"

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowByPercent
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowByPercent = nGrowByPercent;
    if(nSize > 0)
    {
        m_pArray = 
            (void**)CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * nSize);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            m_nExtent = 0;
            throw CX_MemoryException();
        }
    }
    else
        m_pArray = NULL;
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    CWin32DefaultArena::WbemMemFree(m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowByPercent = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowByPercent = Src.m_nGrowByPercent;

    CWin32DefaultArena::WbemMemFree(m_pArray);
    if(m_nExtent > 0)
    {
        m_pArray = 
           (void**)CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            m_nExtent = m_nSize = 0;
            throw CX_MemoryException();
        }

    }
    else
        m_pArray = NULL;
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nSize);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;

    // Account for the index being 0 based and size being 1 based
    MoveMemory( &m_pArray[nIndex], &m_pArray[nIndex+1], ( ( m_nSize - nIndex ) - 1 ) * sizeof(void *) );
    
    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

int CFlexArray::EnsureExtent(int nExtent)
{
    if(m_nExtent < nExtent)
    {
        m_nExtent = nExtent;
        if(m_pArray)
        {
            register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
        }
        else
        {
            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    
            if (!m_pArray)
            {
                m_nExtent = 0;
                return out_of_memory;                
            }
        }
    }

    return no_error;
}
        
    
//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // TEMP: fix for sparse functionality in stdprov
    // =============================================

    while(nIndex > m_nSize)
        Add(NULL);

    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) {
        if (m_nGrowByPercent == 0)
            return array_full;
        register nTmpExtent = m_nExtent;
        m_nExtent += 1;
        m_nExtent *= (100 + m_nGrowByPercent);
        m_nExtent /= 100;

        if(m_pArray)
        {
            register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
            {
                m_nExtent = nTmpExtent; //Change it back, otherwise the extent could constantly grow even though  it keeps failing...
                return out_of_memory;
            }
            m_pArray =  pTmp;
        }
        else
        {
            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    

            if (!m_pArray)
            {
                m_nExtent = 0;
                return out_of_memory;                
            }
        }
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================

    // Account for nIndex being 0 based and m_nSize being 1 based
    MoveMemory( &m_pArray[nIndex+1], &m_pArray[nIndex], ( m_nSize - nIndex ) * sizeof(void *) );

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

void CFlexArray::Sort()
{
    if(m_pArray)
        qsort((void*)m_pArray, m_nSize, sizeof(void*), CFlexArray::CompareEls);
}

int __cdecl CFlexArray::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(int*)pelem1 - *(int*)pelem2;
}
//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%p\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowByPercent = %d\n", m_nGrowByPercent);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%d] = %p\n", i, m_pArray[i]);
        else
            printf("?[%d] = %p\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while ( nRightCursor < m_nSize && m_pArray[nRightCursor] == 0 )
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    Trim();
}    

void CFlexArray::Trim()
{
    while (m_nSize >  0 && m_pArray[m_nSize - 1] == NULL) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    CWin32DefaultArena::WbemMemFree(m_pArray);
    m_pArray = NULL;
    m_nSize = 0;
    m_nExtent = 0;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    m_pArray = NULL;
    Empty();
    return pp;
}

//***************************************************************************
//
//  CFlexArray::CopyData
//
//  Copies the data but not the settings of another flexarray
//
//***************************************************************************

int CFlexArray::CopyDataFrom(const CFlexArray& aOther)
{
    // Check if there is enough room
    // =============================

    if(aOther.m_nSize > m_nExtent)
    {
        // Extend the array to the requisite size
        // ======================================

        m_nExtent = aOther.m_nSize;
        if(m_pArray)
        {
            register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
        }
        else
        {
            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    
            if (!m_pArray)
            {
                m_nExtent = 0;
                return out_of_memory;                
            }
        }
    }

    // Copy the data
    // =============

    m_nSize = aOther.m_nSize;
    memcpy(m_pArray, aOther.m_pArray, sizeof(void*) * m_nSize);
    return no_error;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
    CWin32DefaultArena::WbemMemFree(m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(const wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wbem_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);

        // Check for allocation failures
        if ( NULL == pCopy )
        {
            throw CX_MemoryException();
        }

        wcscpy(pCopy, pSrc);

        if ( m_Array.Add(pCopy) != CFlexArray::no_error )
        {
            throw CX_MemoryException();
        }
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wcscpy(pNewStr, pSrc);
    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wcscpy(pNewStr, pSrc);
    int iRet = m_Array.InsertAt(nIndex, pNewStr);

    if (iRet == array_full)
        CWin32DefaultArena::WbemMemFree(pNewStr);        

    return iRet;
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    CWin32DefaultArena::WbemMemFree(pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);
    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
        CWin32DefaultArena::WbemMemFree(pDoomedString);

    wcscpy(pNewStr, pSrc);
    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
        CWin32DefaultArena::WbemMemFree(m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               wbem_wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) == -1)
        {
            if ( Diff.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) != -1)
        {
            if ( Output.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }

    }
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
    {
        if (Output.FindStr(Src2[i], no_case) == not_found)
        {
            if ( Output.Add(Src2[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\genlex.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\execq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.H

Abstract:

  Defines classes related to execution queues.

  Classes defined:

      CExecRequest    An abstract request.
      CExecQueue      A queue of requests with an associated thread

History:

      23-Jul-96   a-raymcc    Created.
      3/10/97     a-levn      Fully documented
      9/6/97      a-levn      Rewrote for thread pool

--*/

#ifndef __EXECQUEUE__H_
#define __EXECQUEUE__H_

#include "sync.h"
#include "wbemutil.h"

#ifdef __COLLECT_ALLOC_STAT
   #include "stackcom.h"
#endif
//******************************************************************************
//******************************************************************************
//
//  class CExecRequest
//
//  Abstract base class for any schedulable request
//
//******************************************************************************
//
//  Execute
//
//  Primary method. Executes the request, whatever that means. 
//
//  Returns:
//
//      int:    return code. 0 means success, everything else --- failure.
//              Exact error codes are request-specific.
//
//******************************************************************************

class POLARITY CExecRequest
{
protected:
#ifdef WINMGMT_THREAD_DEBUG
    static CCritSec mstatic_cs;
    static CPointerArray<CExecRequest> mstatic_apOut;
#endif
#ifdef __COLLECT_ALLOC_STAT
public:
    CStackRecord m_Stack;
protected:
#endif
    HANDLE m_hWhenDone;
    CExecRequest* m_pNext;
    long m_lPriority;
	bool	m_fOk;


public:
    void SetWhenDoneHandle(HANDLE h) {m_hWhenDone = h;}
    HANDLE GetWhenDoneHandle() {return m_hWhenDone;}
    void SetNext(CExecRequest* pNext) {m_pNext = pNext;}
    CExecRequest* GetNext() {return m_pNext;}
    void SetPriority(long lPriority) {m_lPriority = lPriority;}
    long GetPriority() {return m_lPriority;}
    virtual void DumpError(){   DEBUGTRACE((LOG_WBEMCORE,
        "No additional info\n"));};
	bool IsOk( void ) { return m_fOk; }

public:
    CExecRequest();
    virtual ~CExecRequest();
    virtual HRESULT Execute() = 0;
};

class CDavidsRequest
{
protected:
    LPTHREAD_START_ROUTINE m_pfn;
    void* m_pParam;
public:
    CDavidsRequest(LPTHREAD_START_ROUTINE pFunctionToExecute, void* pParam)
        : m_pfn(pFunctionToExecute), m_pParam(pParam)
    {}
    HRESULT Execute()
    {
        return (HRESULT)m_pfn(m_pParam);
    }
};

//******************************************************************************
//******************************************************************************
//
//  class CExecQueue
//
//  CExecQueue represents the concept of a queue of requests with an associated
//  thread to execute those requests. In a lot of respects, it is similar to
//  a message queue. Requests are added to the queue (which is represented by
//  an array) and the thread (created by the Run function) picks them up one
//  by one and executes them.
//
//  The trick is what to do if while processing one request, another one
//  is generated and needs to be processed before the first one succeeds. This
//  is similar to a SendMessage, but trickier: the thread generating the new
//  request may not be the thread attached to the queue!
//
//  To overcome this problem, we make all our waits interruptible in the
//  following sense. Whenever the thread attached to the queue needs to block
//  waiting for something to happen (which is when another thread may post a 
//  new request and deadlock the system), it uses QueueWaitForSingleObject
//  instead. This function will wait for the object that the thread wanted to
//  wait for but it will also wake up if a new Critical request is added to 
//  the queue and process any such request while waiting.
//
//  See QueueWaitForSingleObject for details.
//
//  Operations of CExecQueue are protected by a critical section, so multiple
//  threads can add requests simultaneously.
//
//******************************************************************************
//
//  Constructor
//
//  Creates and initializes all the synchronization objects, as well as the
//  thread local storage required by QueueWaitForSingleObject.
//
//******************************************************************************
//
//  Destructor
//
//  Deletes synchronization objects.
//
//******************************************************************************
//
//  virtual Enqueue
//
//  Adds a request to the queue. The acction depends on whether the request is
//  critical or not.  If not, it is added to the queue and the semaphor of
//  non-critical requests is incremented. The processing thread will pick it up
//  in FIFO order. If critical, request is added to the front of the queye and
//  the semaphor of critical requests is incremented. This will cause the
//  processing thread to take this request the next time it enters into a 
//  waiting state (see QueueWaitForSingleObject).
//
//******************************************************************************
//
//  QueueWaitForSingleObject
//
//  The core of the trick. In WINMGMT, whenever a thread needs to wait for an
//  object, it calls this function instead. This function checks if the calling
//  thread is the registered processing thread for any CExecQueue object (by
//  looking up the m_dwTlsIndex thread local variable for the thread). If it
//  is not, the function simply calls WaitForSingleObject.
//
//  If it is, the function queries the queue for the semaphore indicating the
//  number of critical requests on the queue. It then calls 
//  WaitForMultipleObjects with the original handle and the semaphore. If the
//  semaphore is signaled during the wait (or was singlaled when we came in),
//  this function picks up the first requests on the queue and executes it;
//  once that request is complete, it resumes the wait (with adjusted timeout).
//
//  Parameters:
//
//      HANDLE hHandle      The handle of synchronization object to wait for.
//      DWORD dwTimeout     Timeout in milliseconds.
//
//  Returns:
//
//      Same values as WaitForSingleObject:
//          WAIT_OBJECT_0   hHandle became signaled
//          WAIT_TIMEOUT    Timed out.
//
//******************************************************************************
//**************************** protected ***************************************
//
//  Register
//
//  Registers the calling thread as the processing thread of this queue by
//  storing the pointer to the queue in the m_dwTlsIndex thread local storage
//  variable. QueueWaitForSingleObject reads this index to interrupt waits 
//  when needed (see QueueWaitForSingleObject).
//
//  Returns:
//
//      CExecQueue*:    the previous CExecQueue this thread was registered for,
//                      or NULL if none. The caller MUST not delete this object.
//
//******************************************************************************
//
//  ThreadMain
//
//  This is the function that the thread created by Run executes.  It sits in
//  an infinite loop, retrieving requests and executing them one by one.
//  This function never returns.
//
//******************************************************************************
//
//  Dequeue
//
//  Retrieves the request at the head of the queue and removes it from the
//  queue.
//
//  Returns:
//
//      CExecRequest*:  the request that was at the head of the queue, or NULL
//                      if the queue was empty. The caller must delete this
//                      object when no longer needed.
//
//******************************************************************************
//
//  static _ThreadEntry
//
//  Stub function used to create the tread. Calls ThreadEntry on the real 
//  CExecQueue.
//
//  Parameters:
//
//      LPVOID pObj     Actually CExecQueue* to the queue this thread is 
//                      supposed to serve.
//
//  Returns:
//
//      never.
//
//******************************************************************************
//
//  static InitTls
//
//  Invoked only once during the life of the system (not the life of a queue),
//  creates a thread local storage location where the pointer to the queue is
//  stored for the attached threads (see Register and QueueWaitForSingleObject)
//  
//******************************************************************************
//
//  GetNormalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  non-critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  GetCriticalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  Execute
//
//  Dequeues and executes a single request.
//
//******************************************************************************

    

class POLARITY CExecQueue
{
protected:
    class CThreadRecord
    {
    public:
        CExecQueue* m_pQueue;
        CExecRequest* m_pCurrentRequest;
        BOOL m_bReady;
        BOOL m_bExitNow;
        HANDLE m_hThread;
        HANDLE m_hAttention;
    
    public:
        CThreadRecord(CExecQueue* pQueue);
        ~CThreadRecord();
        void Signal();
    };

protected:
    static long mstatic_lNumInits;

    long m_lRef;
    CRITICAL_SECTION m_cs;

    CFlexArray m_aThreads;
    CExecRequest* m_pHead;
    CExecRequest* m_pTail;

    long m_lNumThreads;
    long m_lNumIdle;
    long m_lNumRequests;

    long m_lMaxThreads;
    long m_lHiPriBound;
    long m_lHiPriMaxThreads;

    long m_lStartSlowdownCount;
    long m_lAbsoluteLimitCount;
    long m_lOneSecondDelayCount;

    double m_dblAlpha;
    double m_dblBeta;

    DWORD m_dwTimeout;
    DWORD m_dwOverflowTimeout;


protected:    
    virtual void ThreadMain(CThreadRecord* pRecord);

    virtual void LogError(CExecRequest* pRequest, int nRes);

    static DWORD WINAPI _ThreadEntry(LPVOID pObj);
    static void InitTls();

    virtual void InitializeThread();
    virtual void UninitializeThread();
    virtual BOOL CreateNewThread();
    static void Register(CThreadRecord* pRecord);
    virtual void ShutdownThread(CThreadRecord* pRecord);

    virtual BOOL IsSuitableThread(CThreadRecord* pRecord, CExecRequest* pReq);
    virtual BOOL DoesNeedNewThread(CExecRequest* pReq);
    virtual BOOL IsIdleTooLong(CThreadRecord* pRecord, DWORD dwIdle);
    virtual DWORD GetIdleTimeout(CThreadRecord* pRecord);
    virtual BOOL IsAppropriateThread();
    virtual DWORD WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

	virtual DWORD UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

    virtual BOOL Execute(CThreadRecord* pRecord);
    virtual BOOL IsSTA() {return FALSE;}
    virtual CExecRequest* SearchForSuitableRequest(CThreadRecord* pRecord);
    virtual void SitOutPenalty(long lRequestIndex);
    virtual DWORD CalcSitOutPenalty(long lRequestIndex);

    virtual void AdjustInitialPriority(CExecRequest* pRequest){}
    virtual void AdjustPriorityForPassing(CExecRequest* pRequest){}
public:
    CExecQueue();
    ~CExecQueue();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}
    static DWORD GetTlsIndex();
    void Enter();
    void Leave();

    virtual HRESULT Enqueue(CExecRequest* pRequest, HANDLE* phWhenDone = NULL);
	HRESULT EnqueueWithoutSleep(CExecRequest* pRequest, HANDLE* phWhenDone = NULL );
    HRESULT EnqueueAndWait(CExecRequest* pRequest);

    virtual LPCWSTR GetType() {return L"";}

    void SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads = -1,
                            long lHiPriBound = 0);
    void SetIdleTimeout(DWORD dwTimeout) {m_dwTimeout = dwTimeout;}
    void SetOverflowIdleTimeout(DWORD dwTimeout) 
        {m_dwOverflowTimeout = dwTimeout;}
    void SetRequestLimits(long lAbsoluteLimitCount, 
            long lStartSlowdownCount = -1, long lOneSecondDelayCount = -1);
    
    void Shutdown();

	DWORD GetSitoutPenalty( void ) { return CalcSitOutPenalty( m_lNumRequests ); }

    static DWORD QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static DWORD QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static BOOL IsSTAThread();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\execq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.CPP

Abstract:

  Implements classes related to abstract execution queues.

  Classes implemeted:

      CExecRequest    An abstract request.
      CExecQueue      A queue of requests with an associated thread

History:

      23-Jul-96   raymcc    Created.
      3/10/97     levn      Fully documented (heh, heh)
      14-Aug-99   raymcc    Changed timeouts
      30-Oct-99   raymcc    Critsec changes for NT Wksta Stress Oct 30 1999
--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <execq.h>
#include <cominit.h>
#include <sync.h>
#include "genutils.h"

#define IDLE_THREAD_TIMEOUT     12000
#define OVERLFLOW_TIMEOUT        5000


//***************************************************************************

// Local wrapper class.  Does not initialize or clean up the critsec.  Simply
// used as a wrapper for scoping so that AV and exception stack unwinding will
// cause the critsec to be exited properly once it is entered.

class CCritSecWrapper
{
    BOOL m_bIn;
    CRITICAL_SECTION *m_pcs;
public:
    CCritSecWrapper(CRITICAL_SECTION *pcs) { m_pcs = pcs; m_bIn = FALSE; }
   ~CCritSecWrapper() { if (m_bIn) Leave(); }
    void Enter() { EnterCriticalSection(m_pcs); m_bIn = TRUE; }
    void Leave() { LeaveCriticalSection(m_pcs); m_bIn = FALSE; }
};


//***************************************************************************

long CExecQueue::mstatic_lNumInits = -1;
POLARITY DWORD mstatic_dwTlsIndex = 0xFFFFFFFF;

class CTlsStaticCleanUp
{
public:
    CTlsStaticCleanUp() {}
    ~CTlsStaticCleanUp() { if (mstatic_dwTlsIndex != 0xFFFFFFFF) TlsFree(mstatic_dwTlsIndex); }
};
CTlsStaticCleanUp g_tlsStaticCleanup;

#ifdef WINMGMT_THREAD_DEBUG
    CCritSec CExecRequest::mstatic_cs;
    CPointerArray<CExecRequest> CExecRequest::mstatic_apOut;

    #define THREADDEBUGTRACE DEBUGTRACE
#else
    #define THREADDEBUGTRACE(X)
#endif


CExecRequest::CExecRequest() : m_hWhenDone(NULL), m_pNext(NULL), m_lPriority(0), m_fOk( true )
{
#ifdef WINMGMT_THREAD_DEBUG
    CInCritSec ics(&mstatic_cs);
    mstatic_apOut.Add(this);
#endif
}

CExecRequest::~CExecRequest()
{
#ifdef WINMGMT_THREAD_DEBUG
    CInCritSec ics(&mstatic_cs);
    for(int i = 0; i < mstatic_apOut.GetSize(); i++)
    {
        if(mstatic_apOut[i] == this)
        {
            mstatic_apOut.RemoveAt(i);
            break;
        }
    }
#endif
}

DWORD CExecQueue::GetTlsIndex()
{
    return mstatic_dwTlsIndex;
}

CExecQueue::CThreadRecord::CThreadRecord(CExecQueue* pQueue)
    : m_pQueue(pQueue), m_pCurrentRequest(NULL), m_bReady(FALSE),
        m_bExitNow(FALSE)
{
    m_hAttention = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CExecQueue::CThreadRecord::~CThreadRecord()
{
    CloseHandle(m_hAttention);
    CloseHandle(m_hThread);
}

void CExecQueue::CThreadRecord::Signal()
{
    SetEvent(m_hAttention);
}


//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CExecQueue::CExecQueue() : m_lNumThreads(0), m_lMaxThreads(1), m_lNumIdle(0),
    m_lNumRequests(0), m_pHead(NULL), m_pTail(NULL), m_dwTimeout(IDLE_THREAD_TIMEOUT),
    m_dwOverflowTimeout(OVERLFLOW_TIMEOUT), m_lHiPriBound(-1), m_lHiPriMaxThreads(1),
    m_lRef(0)
{
    InitTls();

    InitializeCriticalSection(&m_cs);

    SetRequestLimits(4000);
}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CExecQueue::~CExecQueue()
{
    Shutdown();
    DeleteCriticalSection(&m_cs);
}

void CExecQueue::Shutdown()
{
    CCritSecWrapper cs(&m_cs);

    // Get all member thread handles
    // =============================

    cs.Enter();
    int nNumHandles = m_aThreads.Size();
    HANDLE* ah = new HANDLE[nNumHandles];
    DEBUGTRACE((LOG_WBEMCORE, "Queue is shutting down!\n"));

    int i, j=0;
    for(i = 0; i < nNumHandles; i++)
    {
        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

        if ( pRecord->m_hThread )
        {
            ah[j++] = pRecord->m_hThread;
        }
        
        // Inform the thread it should go away when ready
        // ==============================================

        pRecord->m_bExitNow = TRUE;

        // Wake it up if necessary
        // =======================

        pRecord->Signal();
    }
    cs.Leave();

    // Make sure all our threads are gone
    // ==================================

    if(j > 0)
    {
        DWORD dwRet = WaitForMultipleObjects(j, ah, TRUE, INFINITE);
        _DBG_ASSERT( dwRet != WAIT_FAILED );
    }

    for(i = 0; i < j; i++)
        CloseHandle(ah[i]);

    delete [] ah;

    // Remove all outstanding requests
    // ===============================

    while(m_pHead)
    {
        CExecRequest* pReq = m_pHead;
        m_pHead = m_pHead->GetNext();
        delete pReq;
    }

}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
// static
void CExecQueue::InitTls()
{
    if(InterlockedIncrement(&mstatic_lNumInits) == 0)
    {
        mstatic_dwTlsIndex = TlsAlloc();
    }
}

void CExecQueue::Enter()
{
    EnterCriticalSection(&m_cs);
}

void CExecQueue::Leave()
{
    LeaveCriticalSection(&m_cs);
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CExecQueue::Register(CThreadRecord* pRecord)
{
    TlsSetValue(mstatic_dwTlsIndex, (void*)pRecord);
}

BOOL CExecQueue::IsSuitableThread(CThreadRecord* pRecord, CExecRequest* pReq)
{
    if(pRecord->m_pCurrentRequest == NULL)
        return TRUE;

    // This thread is in the middle of something. By default, ignore it
    // ================================================================

    return FALSE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CExecQueue::Enqueue(CExecRequest* pRequest, HANDLE* phWhenDone)
{
    CCritSecWrapper cs(&m_cs);

    // Check if the request has a problem with it.  If so, return the
    // appropriate error code.

    if ( !pRequest->IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

#ifdef __COLLECT_ALLOC_STAT
    pRequest->m_Stack.Create(0, FALSE);
#endif
    // Create an event handle to signal when request is finished, if required
    // ======================================================================

    if(phWhenDone)
    {
        *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        pRequest->SetWhenDoneHandle(*phWhenDone);
    }

    cs.Enter();

    // Search for a suitable thread
    // ============================

    for(int i = 0; i < m_aThreads.Size(); i++)
    {
        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

        if(pRecord->m_bReady)
        {
            // Free. Check if suitable
            // =======================

            if(IsSuitableThread(pRecord, pRequest))
            {
                THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto a "
                    "thread record %p. Previous request: %p\n", pRequest,
                    pRecord, pRecord->m_pCurrentRequest));

                pRecord->m_pCurrentRequest = pRequest;
                THREADDEBUGTRACE((LOG_WBEMCORE, "In Enqueue, changing m_bReady "
                    "for thread %p to 0. Was: %d\n", pRecord,
                    pRecord->m_bReady));
                pRecord->m_bReady = FALSE;
                pRecord->Signal();
                m_lNumIdle--;

                // Done!
                // =====

                cs.Leave();
                return WBEM_S_NO_ERROR;
            }
        }
    }

    THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto the queue\n",
        pRequest));

    // No suitable thread found. Add to the queue
    // ==========================================

    if(m_lNumRequests >= m_lAbsoluteLimitCount)
    {
        cs.Leave();
        return WBEM_E_FAILED;
    }

    // Search for insert position based on priority
    // ============================================

    AdjustInitialPriority(pRequest);

    CExecRequest* pCurrent = m_pHead;
    CExecRequest* pLast = NULL;

    while(pCurrent && pCurrent->GetPriority() <= pRequest->GetPriority())
    {
        pLast = pCurrent;
        pCurrent = pCurrent->GetNext();
    }

    // Insert
    // ======

    if(pCurrent)
    {
        pRequest->SetNext(pCurrent);
    }
    else
    {
        m_pTail = pRequest;
    }

    if(pLast)
    {
        pLast->SetNext(pRequest);
    }
    else
    {
        m_pHead= pRequest;
    }

    m_lNumRequests++;

    // Adjust priorities of the loosers
    // ================================

    while(pCurrent)
    {
        AdjustPriorityForPassing(pCurrent);
        pCurrent = pCurrent->GetNext();
    }

    // Create a new thread, if required
    // ================================

    if(DoesNeedNewThread(pRequest))
        CreateNewThread();

    long lIndex = m_lNumRequests;
    cs.Leave();

    // Sit out whatever penalty is imposed
    // ===================================

    SitOutPenalty(lIndex);
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CExecQueue::EnqueueWithoutSleep(CExecRequest* pRequest, HANDLE* phWhenDone)
{
    CCritSecWrapper cs(&m_cs);

    // Check if the request has a problem with it.  If so, return the
    // appropriate error code.

    if ( !pRequest->IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

#ifdef __COLLECT_ALLOC_STAT
    pRequest->m_Stack.Create(0, FALSE);
#endif
    // Create an event handle to signal when request is finished, if required
    // ======================================================================

    if(phWhenDone)
    {
        *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        pRequest->SetWhenDoneHandle(*phWhenDone);
    }

    cs.Enter();

    // Search for a suitable thread
    // ============================

    for(int i = 0; i < m_aThreads.Size(); i++)
    {
        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

        if(pRecord->m_bReady)
        {
            // Free. Check if suitable
            // =======================

            if(IsSuitableThread(pRecord, pRequest))
            {
                THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto a "
                    "thread record %p. Previous request: %p\n", pRequest,
                    pRecord, pRecord->m_pCurrentRequest));

                pRecord->m_pCurrentRequest = pRequest;
                THREADDEBUGTRACE((LOG_WBEMCORE, "In Enqueue, changing m_bReady "
                    "for thread %p to 0. Was: %d\n", pRecord,
                    pRecord->m_bReady));
                pRecord->m_bReady = FALSE;
                pRecord->Signal();
                m_lNumIdle--;

                // Done!
                // =====

                cs.Leave();
                return WBEM_S_NO_ERROR;
            }
        }
    }

    THREADDEBUGTRACE((LOG_WBEMCORE, "Enqueueing request %p onto the queue\n",
        pRequest));

    // No suitable thread found. Add to the queue
    // ==========================================

    if(m_lNumRequests >= m_lAbsoluteLimitCount)
    {
        cs.Leave();
        return WBEM_E_FAILED;
    }

    // Search for insert position based on priority
    // ============================================

    AdjustInitialPriority(pRequest);

    CExecRequest* pCurrent = m_pHead;
    CExecRequest* pLast = NULL;

    while(pCurrent && pCurrent->GetPriority() <= pRequest->GetPriority())
    {
        pLast = pCurrent;
        pCurrent = pCurrent->GetNext();
    }

    // Insert
    // ======

    if(pCurrent)
    {
        pRequest->SetNext(pCurrent);
    }
    else
    {
        m_pTail = pRequest;
    }

    if(pLast)
    {
        pLast->SetNext(pRequest);
    }
    else
    {
        m_pHead= pRequest;
    }

    m_lNumRequests++;

    // Adjust priorities of the loosers
    // ================================

    while(pCurrent)
    {
        AdjustPriorityForPassing(pCurrent);
        pCurrent = pCurrent->GetNext();
    }

    // Create a new thread, if required
    // ================================

    if(DoesNeedNewThread(pRequest))
        CreateNewThread();

    long lIndex = m_lNumRequests;
    cs.Leave();

    // Sit out whatever penalty is imposed
    // ===================================

//  DWORD dwSleep = CalcSitOutPenalty(lIndex);

    return WBEM_S_NO_ERROR;
}

DWORD CExecQueue::CalcSitOutPenalty(long lRequestIndex)
{
    if(lRequestIndex <= m_lStartSlowdownCount)
        return 0; // no penalty

    if(lRequestIndex >= m_lAbsoluteLimitCount)
        lRequestIndex = m_lAbsoluteLimitCount;

    // Calculate the timeout
    // =====================

    double dblTimeout =
        m_dblAlpha / (m_lAbsoluteLimitCount - lRequestIndex) +
            m_dblBeta;

    // Return penalty
    // ===========

    return ((DWORD) dblTimeout);
}

void CExecQueue::SitOutPenalty(long lRequestIndex)
{
    DWORD   dwSitOutPenalty = CalcSitOutPenalty( lRequestIndex );

    // Sleep on it
    // ===========

    if ( 0 != dwSitOutPenalty )
    {
        Sleep( dwSitOutPenalty );
    }
}


HRESULT CExecQueue::EnqueueAndWait(CExecRequest* pRequest)
{
    if(IsAppropriateThread())
    {
        pRequest->Execute();
        delete pRequest;
        return WBEM_S_NO_ERROR;
    }

    HANDLE hWhenDone;
    HRESULT hr = Enqueue(pRequest, &hWhenDone);

    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwRes = WbemWaitForSingleObject(hWhenDone, INFINITE);
    CloseHandle(hWhenDone);
    return ( dwRes == WAIT_OBJECT_0 ? WBEM_S_NO_ERROR : WBEM_E_FAILED );
}


BOOL CExecQueue::DoesNeedNewThread(CExecRequest* pRequest)
{
    if(m_lNumIdle > 0 || m_lNumRequests == 0)
        return FALSE;

    if(m_lNumThreads < m_lMaxThreads)
        return TRUE;
    else if(pRequest->GetPriority() <= m_lHiPriBound &&
            m_lNumThreads < m_lHiPriMaxThreads)
        return TRUE;
    else
        return FALSE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CExecQueue::Execute(CThreadRecord* pRecord)
{
    CExecRequest* pReq = pRecord->m_pCurrentRequest;

#ifdef __COLLECT_ALLOC_STAT
    CStackContinuation Cont;
    Cont.m_pPrevStack = &pReq->m_Stack;
    CStackContinuation* pPrev = CStackContinuation::Set(&Cont);
#endif

    HRESULT hres = pReq->Execute();

#ifdef __COLLECT_ALLOC_STAT
    CStackContinuation::Set(pPrev);
#endif

    if(hres == RPC_E_RETRY)
    {
        // The request has been postponed
        // ==============================

        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p postponed request %p\n",
                    pRecord, pReq));
    }
    else
    {
        if(hres != WBEM_NO_ERROR)
        {
            LogError(pReq, hres);
        }

        HANDLE hWhenDone = pReq->GetWhenDoneHandle();
        if(hWhenDone != NULL)
        {
            SetEvent(hWhenDone);
        }

        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p done with request %p\n",
                        pRecord, pReq));
        delete pReq;
    }

    pRecord->m_pCurrentRequest = NULL;
    return TRUE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CExecQueue::LogError(CExecRequest* pRequest, int nRes)
{
    DEBUGTRACE((LOG_WBEMCORE,
        "Error %X occured executing queued request\n", nRes));
    pRequest->DumpError();
}

void CExecQueue::InitializeThread()
{
    InitializeCom();
}

void CExecQueue::UninitializeThread()
{
    if(IsDcomEnabled() || IsNT())
        CoUninitialize();
}


CExecRequest* CExecQueue::SearchForSuitableRequest(CThreadRecord* pRecord)
{
    // Assumes in critical section
    // ===========================

    CExecRequest* pCurrent = m_pHead;
    CExecRequest* pPrev = NULL;

    while(pCurrent)
    {
        if(IsSuitableThread(pRecord, pCurrent))
        {
            // Found one --- take it
            // =====================

            if(pPrev)
                pPrev->SetNext(pCurrent->GetNext());
            else
                m_pHead = pCurrent->GetNext();

            if(pCurrent == m_pTail)
                m_pTail = pPrev;

            m_lNumRequests--;
            break;
        }
        pPrev = pCurrent;
        pCurrent = pCurrent->GetNext();
    }

    return pCurrent;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CExecQueue::ThreadMain(CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    InitializeThread();

    // Register this queue with this thread, so any further wait would be
    // interruptable
    // ==================================================================

    Register(pRecord);

    while (1)
    {
        // Returning from work. At this point, our event is not signaled,
        // our m_pCurrentRequest is NULL and our m_bReady is FALSE
        // ====================================================================

        // Search for work in the queue
        // ============================

        cs.Enter();

        CExecRequest* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent)
        {
            // Found some. Take it
            // ===================

            pRecord->m_pCurrentRequest = pCurrent;
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            THREADDEBUGTRACE((LOG_WBEMCORE, "ThreadMain of %p is setting Ready to "
                "TRUE. Was: %d\n", pRecord, pRecord->m_bReady));
            pRecord->m_bReady = TRUE;
            m_lNumIdle++;
            DWORD dwTimeout = GetIdleTimeout(pRecord);
            cs.Leave();
            DWORD dwRes = WbemWaitForSingleObject(pRecord->m_hAttention,
                                        dwTimeout);
            cs.Enter();

            if(dwRes != WAIT_OBJECT_0)
            {
                // Check if someone managed to place a request in our record
                // after the timeout.
                // =========================================================

                if(WbemWaitForSingleObject(pRecord->m_hAttention, 0) ==
                    WAIT_OBJECT_0)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "AMAZING: Thread %p received "
                        "request %p after timing out. Returning to the "
                        "queue\n", pRecord, pRecord->m_pCurrentRequest));

					if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
					{
						THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p being stopped --- %d "
							"requests in the queue (head = %p)\n", pRecord,
							pRecord->m_pQueue->m_lNumRequests,
							pRecord->m_pQueue->m_pHead));
						ShutdownThread(pRecord);
						cs.Leave();
						return;
					}
                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = NULL;
                }

                // Timeout. See if it is time to quit
                // ==================================

                THREADDEBUGTRACE((LOG_WBEMCORE, "ThreadMain of %p is setting Ready "
                    " to FALSE on timeout. Was: %d\n",
                    pRecord, pRecord->m_bReady));

                pRecord->m_bReady = FALSE;
                if(IsIdleTooLong(pRecord, dwTimeout))
                {
                    THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p timing out --- %d "
                        "requests in the queue (head = %p)\n", pRecord,
                        pRecord->m_pQueue->m_lNumRequests,
                        pRecord->m_pQueue->m_pHead));
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // Go and wait a little more
                // =========================

                m_lNumIdle--;
                cs.Leave();
                continue;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p being stopped --- %d "
                        "requests in the queue (head = %p)\n", pRecord,
                        pRecord->m_pQueue->m_lNumRequests,
                        pRecord->m_pQueue->m_pHead));
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // We have a request. Enqueue already adjusted lNumIdle and
                // our m_bReady;
            }
        }

        // Execute the request
        // ===================

#ifdef WINMGMT_THREAD_DEBUG
        if(pRecord->m_bReady)
            DebugBreak();
#endif

        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p picking up normal request %p\n",
            pRecord, pRecord->m_pCurrentRequest));
        cs.Leave();
        Execute(pRecord);

#ifdef WINMGMT_THREAD_DEBUG
        if(pRecord->m_bReady)
            DebugBreak();
#endif
    }
}

DWORD CExecQueue::GetIdleTimeout(CThreadRecord* pRecord)
{
    if(m_lNumThreads > m_lMaxThreads)
        return m_dwOverflowTimeout;
    else
        return m_dwTimeout;
}

BOOL CExecQueue::IsIdleTooLong(CThreadRecord* pRecord, DWORD dwTimeout)
{
    if(m_lNumThreads > m_lMaxThreads)
        return TRUE;
    else if(dwTimeout < m_dwTimeout)
        return FALSE;
    else
        return TRUE;
}

void CExecQueue::ShutdownThread(CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    cs.Enter();
    TlsSetValue(mstatic_dwTlsIndex, NULL);
    for(int i = 0; i < m_aThreads.Size(); i++)
    {
        if(m_aThreads[i] == pRecord)
        {
            m_aThreads.RemoveAt(i);

            // Make sure we don't close the handle if the queue's Shutdown is
            // waiting on it
            // ==============================================================

            if(pRecord->m_bExitNow)
                pRecord->m_hThread = NULL;
            delete pRecord;
            m_lNumIdle--;
            m_lNumThreads--;

            break;
        }
    }
    UninitializeThread();
    cs.Leave();
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
DWORD WINAPI CExecQueue::_ThreadEntry(LPVOID pObj)
{
    CThreadRecord* pRecord = (CThreadRecord*)pObj;
    pRecord->m_pQueue->ThreadMain(pRecord);
    return 0;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CExecQueue::CreateNewThread()
{
    CCritSecWrapper cs(&m_cs);
    BOOL            bRet;

    cs.Enter();

    // Create new thread record
    // ========================

    CThreadRecord* pNewRecord = new CThreadRecord(this);
    if (pNewRecord)
    {
        m_aThreads.Add(pNewRecord);

        DWORD dwId;
        pNewRecord->m_hThread = CreateThread(0, 0, _ThreadEntry, pNewRecord, 0,
                                                &dwId);

        if(pNewRecord->m_hThread == NULL)
        {
            m_aThreads.RemoveAt(m_aThreads.Size()-1);
            delete pNewRecord;
            bRet = FALSE;
        }
        else
        {
            m_lNumThreads++;
            bRet = TRUE;
        }
    }
    else
        bRet = FALSE;

    cs.Leave();

    return bRet;
}

DWORD CompensateForBug(DWORD dwOriginal, DWORD dwElapsed)
{
    if(dwOriginal == 0xFFFFFFFF)
        return 0xFFFFFFFF;

    DWORD dwLeft = dwOriginal - dwElapsed;
    if(dwLeft > 0x7FFFFFFF)
        dwLeft = 0x7FFFFFFF;

    return dwLeft;
}

DWORD CExecQueue::WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    CExecRequest* pOld = pRecord->m_pCurrentRequest;
    DWORD dwStart = GetTickCount();
    while (dwWait > GetTickCount() - dwStart)
    {
        // Search for work in the queue
        // ============================

        cs.Enter();
        CExecRequest* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent != NULL)
        {
            THREADDEBUGTRACE((LOG_WBEMCORE, "QUEUE: While busy, found work in the "
                "queue: thread %p, request %p, old request %p\n", pRecord,
                pCurrent, pRecord->m_pCurrentRequest));
            pRecord->m_pCurrentRequest = pCurrent;

            if(pRecord->m_pCurrentRequest == pOld)
            {
                // Something is very wrong
                // =======================

#ifdef WINMGMT_THREAD_DEBUG
                DebugBreak();
#endif
            }
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            THREADDEBUGTRACE((LOG_WBEMCORE, "While Busy thread %p is setting Ready "
                "to TRUE. Was: %d\n", pRecord, pRecord->m_bReady));

            pRecord->m_bReady = TRUE;

            // Block until a request comes through.
            // ====================================

            HANDLE ahSems[2];
            ahSems[0] = hHandle;
            ahSems[1] = pRecord->m_hAttention;

            cs.Leave();
            DWORD dwLeft = CompensateForBug(dwWait, (GetTickCount() - dwStart));
            DWORD dwRes = WbemWaitForMultipleObjects(2, ahSems, dwLeft);

            cs.Enter();
            THREADDEBUGTRACE((LOG_WBEMCORE, "While Busy thread %p is setting Ready "
                "to FALSE. Was: %d\n", pRecord, pRecord->m_bReady));
            pRecord->m_bReady = FALSE;
            if(dwRes != WAIT_OBJECT_0 + 1)
            {
                // Either our target handle is ready or we timed out
                // =================================================

                // Check if anyone placed a request in our record
                // ==============================================

                if(pRecord->m_pCurrentRequest != pOld)
                {
                    // Re-issue it to the queue
                    // ========================

                    DEBUGTRACE((LOG_WBEMCORE, "SURPRIZE: Somebody placed "
                        "request %p into thread record %p while it was getting "
                        "ready to continue. Reissuing\n",
                        pRecord->m_pCurrentRequest, pRecord));

                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = pOld;

                    // Decrement our semaphore
                    // =======================

                    dwRes = WaitForSingleObject(pRecord->m_hAttention, 0);
                    if(dwRes != WAIT_OBJECT_0)
                    {
                        // Internal error --- whoever placed the request had
                        // to have upped the semaphore
                        // =================================================

                        ERRORTRACE((LOG_WBEMCORE, "Internal error: queue "
                            "semaphore is too low\n"));
                    }
                }

                cs.Leave();
                return dwRes;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    // Can't exit in the middle of a request. Leave it for later
                    // =========================================================

                    pRecord->Signal();
                    cs.Leave();
                    DWORD dwLeft2 = CompensateForBug(dwWait,
                                        (GetTickCount() - dwStart));
                    return WbemWaitForSingleObject(hHandle, dwLeft2);
                }

                // We've got work to do
                // ====================

                if(pRecord->m_pCurrentRequest == pOld)
                {
                    // Something is very wrong
                    // =======================

#ifdef WINMGMT_THREAD_DEBUG
                    DebugBreak();
#endif
                }
            }
        }

        // Execute the request
        // ===================

        THREADDEBUGTRACE((LOG_WBEMCORE, "Switching to a dependent request %p. "
                "Previous was %p\n", pRecord->m_pCurrentRequest, pOld));
        cs.Leave();
        Execute(pRecord);
        pRecord->m_pCurrentRequest = pOld;
        THREADDEBUGTRACE((LOG_WBEMCORE, "Going back to request %p\n", pOld));
    }
    return WAIT_TIMEOUT;
}

DWORD CExecQueue::UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    // Silently bump the max threads count.  We will not allow the queue to reuse
    // this thread, so we need to account for this missing thread while we
    // are blocked.  Essentially, we are hijacking the code that was hijacking
    // the thread

    cs.Enter();
        m_lMaxThreads++;
        m_lHiPriMaxThreads++;
    cs.Leave();

    DWORD   dwRet = WbemWaitForSingleObject( hHandle, dwWait );

    // The thread is back, so bump down the max threads number.  If extra threads were in
    // fact created, they should eventually peter out and go away.
    cs.Enter();
        m_lMaxThreads--;
        m_lHiPriMaxThreads--;
    cs.Leave();

    return dwRet;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
DWORD CExecQueue::QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    InitTls();

    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
    {
        // No queue is registered with this thread. Just wait
        // ==================================================

        return WbemWaitForSingleObject(hHandle, dwWait);
    }

    CExecQueue* pQueue = pRecord->m_pQueue;

    return pQueue->WaitForSingleObjectWhileBusy(hHandle, dwWait, pRecord);
}

// static
DWORD CExecQueue::QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    InitTls();

    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
    {
        // No queue is registered with this thread. Just wait
        // ==================================================

        return WbemWaitForSingleObject(hHandle, dwWait);
    }

    CExecQueue* pQueue = pRecord->m_pQueue;

    return pQueue->UnblockedWaitForSingleObject(hHandle, dwWait, pRecord);
}

void CExecQueue::SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads,
                                    long lHiPriBound)
{
    m_lMaxThreads = lMaxThreads;
    if(lHiPriMaxThreads == -1)
        m_lHiPriMaxThreads = lMaxThreads * 1.1;
    else
        m_lHiPriMaxThreads = lHiPriMaxThreads;
    m_lHiPriBound = lHiPriBound;

    while(DoesNeedNewThread(NULL))
        CreateNewThread();
}

BOOL CExecQueue::IsAppropriateThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
        return FALSE;

    CExecQueue* pQueue = pRecord->m_pQueue;
    if(pQueue != this)
        return FALSE;

    return TRUE;
}

BOOL CExecQueue::IsSTAThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL) return FALSE;

    return pRecord->m_pQueue->IsSTA();
}

void CExecQueue::SetRequestLimits(long lAbsoluteLimitCount,
                              long lStartSlowdownCount,
                              long lOneSecondDelayCount)
{
    CCritSecWrapper cs(&m_cs);

    cs.Enter();

    m_lAbsoluteLimitCount = lAbsoluteLimitCount;

    m_lStartSlowdownCount = lStartSlowdownCount;
    if(m_lStartSlowdownCount < 0)
    {
        m_lStartSlowdownCount = m_lAbsoluteLimitCount / 2;
    }

    m_lOneSecondDelayCount = lOneSecondDelayCount;

    if(m_lOneSecondDelayCount < 0)
    {
        m_lOneSecondDelayCount =
            m_lAbsoluteLimitCount * 0.2 + m_lStartSlowdownCount * 0.8;
    }

    // Calculate coefficients
    // ======================

    m_dblBeta =
        1000 *
        ((double)m_lAbsoluteLimitCount - (double)m_lOneSecondDelayCount) /
        ((double)m_lStartSlowdownCount - (double)m_lOneSecondDelayCount);

    m_dblAlpha = m_dblBeta *
        ((double)m_lStartSlowdownCount - (double)m_lAbsoluteLimitCount);
    cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXQ.CPP

Abstract:

  CFlexQueue.

History:

--*/

#include "precomp.h"
//#include <dbgalloc.h>
#include <flexq.h>

CFlexQueue::CFlexQueue(int nInitialSize) :
    m_nSize(nInitialSize), m_nHeadIndex(0), m_nTailIndex(0)
{
    if(m_nSize)
        m_ppData = new void*[m_nSize];
    else
        m_ppData = NULL;
}

CFlexQueue::~CFlexQueue()
{
    delete [] m_ppData;
}

bool CFlexQueue::Grow()
{
    int nNewSize = (m_nSize + 1) * 2;

    // Allocate new memory block
    // =========================

    void** ppNewData = new void*[nNewSize];
    if(ppNewData == NULL)
        return false;

    // Copy the queue data to the beginning of the array
    // =================================================

    if(m_nHeadIndex <= m_nTailIndex)
    {
        memcpy(ppNewData, m_ppData + m_nHeadIndex,
                    (m_nTailIndex - m_nHeadIndex) * sizeof(void*));
    }
    else
    {
        memcpy(ppNewData, m_ppData + m_nHeadIndex,
                    (m_nSize - m_nHeadIndex) * sizeof(void*));
        memcpy(ppNewData + (m_nSize - m_nHeadIndex), m_ppData,
                    m_nTailIndex * sizeof(void*));
    }

    m_nTailIndex = GetQueueSize();
    m_nHeadIndex = 0;
    m_nSize = nNewSize;
    delete [] m_ppData;
    m_ppData = ppNewData;

    return true;
}

bool CFlexQueue::Enqueue(void* pNew)
{
    if(GetQueueSize() >= m_nSize - 1)
    {
        if(!Grow()) return false;
    }

    m_ppData[m_nTailIndex] = pNew;
    IncrementIndex(m_nTailIndex);
    return true;
}

void* CFlexQueue::Dequeue()
{
    if(GetQueueSize() == 0)
        return NULL;
    void* pRet = m_ppData[m_nHeadIndex];
    IncrementIndex(m_nHeadIndex);
    return pRet;
}

void* CFlexQueue::Peek()
{
    if(GetQueueSize() == 0)
        return NULL;
    return m_ppData[m_nHeadIndex];
}


bool CFlexQueue::Requeue(void* pNew)
{
    if(GetQueueSize() >= m_nSize - 1)
    {
        if(!Grow()) return false;
    }

    DecrementIndex(m_nHeadIndex);
    m_ppData[m_nHeadIndex] = pNew;
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\evtlog.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EVTLOG.H

Abstract:

    Event Log helpers

History:

--*/

#ifndef __WBEM_EVENT_LOG__H_
#define __WBEM_EVENT_LOG__H_

#define WBEM_EVENT_LOG_SOURCE L"WinMgmt"
#define WBEM_EVENT_LOG_DUPLICATE_TIMEOUT 10

#include "sync.h"

class POLARITY CHex
{
protected:
    long m_l;
public:
    CHex(long l) : m_l(l){}
    operator long() {return m_l;}
};

class POLARITY CInsertionString
{
protected:
    BOOL m_bEmpty;
    WString m_ws;

public:
    CInsertionString() : m_bEmpty(TRUE){}
    CInsertionString(LPCWSTR wsz) : m_bEmpty(FALSE), m_ws(wsz){}
    CInsertionString(LPCSTR sz) : m_bEmpty(FALSE), m_ws(sz){}
    CInsertionString(long l);
    CInsertionString(CHex h);

    LPCWSTR GetString() {return m_ws;}
    BOOL IsEmpty() {return m_bEmpty;}
};
    
class POLARITY CEventLogRecord
{
protected:
    WORD m_wType;
    DWORD m_dwEventID;
    CWStringArray m_awsStrings;
    CWbemTime m_CreationTime;

protected:
    void AddInsertionString(CInsertionString& s);

public:
    CEventLogRecord(WORD wType, DWORD dwEventID, 
                    CInsertionString s1 = CInsertionString(),
                    CInsertionString s2 = CInsertionString(),
                    CInsertionString s3 = CInsertionString(),
                    CInsertionString s4 = CInsertionString(),
                    CInsertionString s5 = CInsertionString(),
                    CInsertionString s6 = CInsertionString(),
                    CInsertionString s7 = CInsertionString(),
                    CInsertionString s8 = CInsertionString(),
                    CInsertionString s9 = CInsertionString(),
                    CInsertionString s10 = CInsertionString());
    ~CEventLogRecord(){}

    WORD GetNumStrings() {return (WORD) m_awsStrings.Size();}
    LPCWSTR GetStringAt(int nIndex);
    CWbemTime GetCreationTime() {return m_CreationTime;}

    BOOL operator==(const CEventLogRecord& Other);
};
    
POLARITY typedef CUniquePointerArray<CEventLogRecord> LogRecords;


class POLARITY CEventLog
{
private:
    WString m_wsServerName;
    WString m_wsSourceName;

    HANDLE m_hSource;
    FILE* m_fLog;

    BOOL m_bNT;
    DWORD m_dwTimeout;
    LogRecords* m_pRecords;
    CCritSec m_cs;
    
protected:
    BOOL SearchForRecord(CEventLogRecord* pRecord);
    void AddRecord(CEventLogRecord* pRecord);

public:
    CEventLog(LPCWSTR wszUNCServerName = NULL, 
                LPCWSTR wszSourceName = WBEM_EVENT_LOG_SOURCE,
                DWORD dwTimeout = WBEM_EVENT_LOG_DUPLICATE_TIMEOUT);
    ~CEventLog();

    BOOL Close();
    BOOL Open();

    BOOL Report(WORD wType, DWORD dwEventID, 
                    CInsertionString s1 = CInsertionString(),
                    CInsertionString s2 = CInsertionString(),
                    CInsertionString s3 = CInsertionString(),
                    CInsertionString s4 = CInsertionString(),
                    CInsertionString s5 = CInsertionString(),
                    CInsertionString s6 = CInsertionString(),
                    CInsertionString s7 = CInsertionString(),
                    CInsertionString s8 = CInsertionString(),
                    CInsertionString s9 = CInsertionString(),
                    CInsertionString s10 = CInsertionString());
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexarry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.H

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.

--*/

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

#include "corepol.h"

#include <arena.h>
#include <sync.h>

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class POLARITY CFlexArray
{
protected:
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowByPercent;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 0, 
        IN int nGrowByPercent = 100
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    int CopyDataFrom(const CFlexArray& aOther);
    int EnsureExtent(int nExtent);

    // Gets an element at a particular location.
    // =========================================
    inline void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    inline void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    inline void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void inline SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Removes all zero entries from the end of the array and shrinks it
    // =================================================================

    void Trim();

    // Adds a new element to the end of the array.
    // ===========================================
    int inline Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int inline Size() const { return m_nSize; }

    // Sets the apparent size of the array
    // ===================================
    void inline SetSize(int nNewSize) { m_nSize = nNewSize;}

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    inline void**  GetArrayPtr() { return m_pArray; }
    inline void* const*  GetArrayPtr() const { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();

    void Sort();

protected:
    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class POLARITY CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 0, 
        int nGrowBy = 100
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    inline wchar_t *GetAt(int nIndex) const { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    inline wchar_t *operator[](int nIndex) const{ return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(const wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, const wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, const wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    inline int  Size() const { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(const wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    inline void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    inline LPCWSTR*  GetArrayPtr() { return (LPCWSTR*) m_Array.GetArrayPtr(); }

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};

class POLARITY CLockableFlexArray : public CFlexArray
{
private:
    CCritSec m_cs;
public:
	void Lock() { EnterCriticalSection(&m_cs); };
	void Unlock() { LeaveCriticalSection(&m_cs); };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXQ.H

Abstract:

  This file defines CFlexQueue.

History:

--*/
#ifndef __WBEM_FLEXQ__H_
#define __WBEM_FLEXQ__H_

class POLARITY CFlexQueue
{
protected:
    void** m_ppData;
    int m_nSize;
    int m_nHeadIndex;
    int m_nTailIndex;

public:
    inline int GetQueueSize() const
    {
        if(m_nHeadIndex <= m_nTailIndex)
            return m_nTailIndex - m_nHeadIndex;
        else
            return m_nTailIndex - m_nHeadIndex + m_nSize;
    }
protected:
    inline void IncrementIndex(int& nIndex)
    {
        if(++nIndex == m_nSize)
            nIndex = 0;
    }
    inline void DecrementIndex(int& nIndex)
    {
        if(nIndex-- == 0)
            nIndex = m_nSize - 1;
    }

    bool Grow();

public:
    CFlexQueue(int nInitialSize = 1);
    ~CFlexQueue();

    bool Enqueue(void* pNew);
    void* Dequeue();
    bool Requeue(void* pNew);
    inline void* Unqueue()
    {
        if(GetQueueSize() == 0)
            return NULL;
        DecrementIndex(m_nTailIndex);
        return m_ppData[m_nTailIndex];
    }
    void* Peek();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include "arena.h"

//
// this obj is only linked into the dll version of wbemcomn. components
// that use that static version will define their own localloc.
//

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        HANDLE hHeap;

        hHeap = HeapCreate( 0,  // will not use exceptions and will serialize
                            0x100000, // init size of 1Meg
                            0 ); // no max size

        if (hHeap == 0)
            return;     // Arena remains uninitialized and properly returns errors later on

        if ( CWin32DefaultArena::WbemHeapInitialize( hHeap ) == FALSE )
        {
            HeapDestroy ( hHeap );
        }
    }
    ~WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapFree();     // This destroys the heap
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}

void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\genutils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    GENUTILS.CPP

Abstract:

    Defines various utilities.

History:

    a-davj    21-June-97   Created.

--*/

#include "precomp.h"
#include "corepol.h"
#include "arena.h"
#include <wbemidl.h>
#include <arrtempl.h>
#include "reg.h"
#include "genutils.h"
#include "wbemutil.h"
#include "var.h"
#include <TCHAR.H>

#define IsSlash(x) (x == L'\\' || x== L'/')

#ifndef EOAC_STATIC_CLOAKING
#define EOAC_STATIC_CLOAKING 0x20
#define EOAC_DYNAMIC_CLOAKING 0x40
#endif

//***************************************************************************
//
//  BOOL IsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

POLARITY BOOL IsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

POLARITY BOOL IsWin95(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) && ( os.dwMinorVersion == 0 ) ;
}

POLARITY BOOL IsNT351(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion == 3 ) && ( os.dwMinorVersion == 51 ) ;
}

POLARITY BOOL IsW2KOrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}

POLARITY BOOL IsWinMgmt(void)
{
    //
    // Retrieve EXE path
    //

    WCHAR wszExePath[MAX_PATH+1];
    if(GetModuleFileNameW(NULL, wszExePath, MAX_PATH+1) == 0)
        return FALSE;

    //
    // Extract the file-name portion
    //

    WCHAR* pwcFileName = wcsrchr(wszExePath, L'\\');
    if(pwcFileName == NULL)
        pwcFileName = wszExePath;
    else
        pwcFileName++;

    if(_wcsnicmp(pwcFileName, FILENAME_PREFIX_EXE_W, wcslen(FILENAME_PREFIX_EXE_W)))
        return FALSE;

    return TRUE;
}

//***************************************************************************
//
//  BOOL SetObjectAccess
//
//  DESCRIPTION:
//
//  Allows global access to an object.
//
//  PARAMETERS:
//
//  hObj                Object to set access on.
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//
//***************************************************************************

POLARITY BOOL SetObjectAccess(
                        IN HANDLE hObj)
{
    PSECURITY_DESCRIPTOR pSD;
    DWORD dwLastErr = 0;
    BOOL bRet = FALSE;

    // no point if we arnt on nt

    if(!IsNT())
    {
        return TRUE;
    }

    pSD = (PSECURITY_DESCRIPTOR)CWin32DefaultArena::WbemMemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if(pSD == NULL)
        return FALSE;

    ZeroMemory(pSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if(!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto Cleanup;
   
    if(!SetSecurityDescriptorDacl(pSD, TRUE, NULL, FALSE))
        goto Cleanup;

    bRet = SetKernelObjectSecurity(hObj, DACL_SECURITY_INFORMATION, pSD);

Cleanup:
    if(bRet == FALSE)
        dwLastErr = GetLastError();
    CWin32DefaultArena::WbemMemFree(pSD);
    return bRet;
}


//***************************************************************************
//
//  void RegisterDLL
//
//  DESCRIPTION:
//
//  Adds the current dll to the registry as an inproc server.
//
//  PARAMETERS:
//
//  guid                GUILD that this supports
//  pDesc               Text description for this object.
//
//***************************************************************************

POLARITY void RegisterDLL(IN HMODULE hModule, IN GUID guid, IN TCHAR * pDesc, TCHAR * pModel,
            TCHAR * pProgID)
{
//    char       szID[128];
    TCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

    // Create the path.

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;
#ifdef UNICODE
    lstrcpy(wcID, strCLSID);
#else
    wcstombs(wcID, strCLSID, 128);
#endif

//    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, wcID);

    // Create entries under CLSID

    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1))
        return;

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc, 2*(lstrlen(pDesc)+1));
    if(ERROR_SUCCESS != RegCreateKey(hKey1,__TEXT("InprocServer32"),&hKey2))
        return;

    if(0 == GetModuleFileName(hModule, szModule,  MAX_PATH))
    return;

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        2*(lstrlen(szModule)+1));
    RegSetValueEx(hKey2, __TEXT("ThreadingModel"), 0, REG_SZ, 
                                       (BYTE *)pModel, 2*(lstrlen(pModel)+1));

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    // If there is a progid, then add it too

    if(pProgID)
    {
        wsprintf(wcID, __TEXT("SOFTWARE\\CLASSES\\%s"), pProgID);
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, wcID, &hKey1))
        {

            RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc , 2*(lstrlen(pDesc)+1));
            if(ERROR_SUCCESS == RegCreateKey(hKey1,__TEXT("CLSID"),&hKey2))
            {
//                wcstombs(szID, wcID, 128);
                RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)wcID, 
                                        2*(lstrlen(wcID)+1));
                RegCloseKey(hKey2);
                hKey2 = NULL;
            }
            RegCloseKey(hKey1);
        }

    }
    return;
}

//***************************************************************************
//
//  void UnRegisterDLL
//
//  DESCRIPTION:
//
//  Removes an in proc guid from the clsid section
//
//  PARAMETERS:
//
//  guid                guild to be removed.
//
//***************************************************************************

POLARITY void UnRegisterDLL(GUID guid, TCHAR * pProgID)
{

//    char       szID[128];
    TCHAR      wcID[128];
    TCHAR  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;
#ifdef UNICODE
    lstrcpy(wcID, strCLSID);
#else
    wcstombs(wcID, strCLSID, 128);
#endif


//    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, __TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,wcID);
        RegCloseKey(hKey);
    }

    if(pProgID)
    {
        HKEY hKey2;
        DWORD dwRet2 = RegOpenKey(HKEY_LOCAL_MACHINE, pProgID, &hKey2);
        if(dwRet2 == NO_ERROR)
        {
            RegDeleteKey(hKey2, __TEXT("CLSID"));
            RegCloseKey(hKey2);
        }
        RegDeleteKey(HKEY_LOCAL_MACHINE, pProgID);

    }
}

//***************************************************************************
//
//  HRESULT WbemVariantChangeType
//
//  DESCRIPTION:
//
//  Just like VariantChangeType, but deals with arrays as well.
//
//  PARAMETERS:
//
//  VARIANT pvDest      Destination variant
//  VARIANT pvSrc       Source variant (can be the same as pvDest)
//  VARTYPE vtNew       The type to coerce to.
//
//***************************************************************************

POLARITY HRESULT WbemVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, 
                                        VARTYPE vtNew)
{
    HRESULT hres;

    if(V_VT(pvSrc) == VT_NULL)
    {
        return VariantCopy(pvDest, pvSrc);
    }

    if(vtNew & VT_ARRAY)
    {
        // It's an array, we have to do our own conversion
        // ===============================================

        if((V_VT(pvSrc) & VT_ARRAY) == 0)
            return DISP_E_TYPEMISMATCH;

        SAFEARRAY* psaSrc = V_ARRAY(pvSrc);

        SAFEARRAYBOUND aBounds[1];

        long lLBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);

        long lUBound;
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        SAFEARRAY* psaDest = SafeArrayCreate(vtNew & ~VT_ARRAY, 1, aBounds);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            VARIANT vSrcEl;
            V_VT(&vSrcEl) = V_VT(pvSrc) & ~VT_ARRAY;
            SafeArrayGetElement(psaSrc, &lIndex, &V_UI1(&vSrcEl));

            // Cast it to the new type
            // =======================

            hres = VariantChangeType(&vSrcEl, &vSrcEl, 0, vtNew & ~VT_ARRAY);
            if(FAILED(hres)) 
            {
                SafeArrayDestroy(psaDest);
                return hres;
            }

            // Put it into the new array
            // =========================

            if(V_VT(&vSrcEl) == VT_BSTR)
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, V_BSTR(&vSrcEl));
            }
            else
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, &V_UI1(&vSrcEl));
            }
            if(FAILED(hres)) 
            {
                SafeArrayDestroy(psaDest);
                return hres;
            }
        }

        if(pvDest == pvSrc)
        {
            VariantClear(pvSrc);
        }

        V_VT(pvDest) = vtNew;
        V_ARRAY(pvDest) = psaDest;

        return TRUE;
    }
    else
    {
        // Not an array. Can use OLE functions
        // ===================================

        return VariantChangeType(pvDest, pvSrc, VARIANT_NOVALUEPROP, vtNew);
    }
}

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

	// Check for a NULL pointer
	if ( NULL == wsz )
	{
		return FALSE;
	}

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }
        
        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}

//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

	// Check for a NULL pointer
	if ( NULL == wsz )
	{
		return FALSE;
	}

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}

POLARITY HRESULT ChangeVariantToCIMTYPE(VARIANT* pvDest, VARIANT* pvSource,
                                            CIMTYPE ct)
{
    if(ct == CIM_CHAR16)
    {
        //
        // Special case --- use CVar's code
        //

        CVar v;
        try
        {
            v.SetVariant(pvSource);
            if(!v.ToSingleChar())
                return WBEM_E_TYPE_MISMATCH;
            v.FillVariant(pvDest);            
            return WBEM_S_NO_ERROR;
        }
        catch(...)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    VARTYPE vt;
    switch(ct)
    {
    case CIM_UINT8:
        vt = VT_UI1;
        break;
    case CIM_SINT8:
    case CIM_SINT16:
        vt = VT_I2;
        break;
    case CIM_UINT16:
    case CIM_SINT32:
        vt = VT_I4;
        break;
    case CIM_UINT32:
    case CIM_UINT64:
    case CIM_SINT64:
    case CIM_STRING:
    case CIM_DATETIME:
    case CIM_REFERENCE:
        vt = VT_BSTR;
        break;
    case CIM_REAL32:
        vt = VT_R4;
        break;
    case CIM_REAL64:
        vt = VT_R8;
        break;
    case CIM_OBJECT:
        vt = VT_UNKNOWN;
        break;
    case CIM_BOOLEAN:
        vt = VT_BOOL;
        break;
    default:
        return WBEM_E_TYPE_MISMATCH;
    }

    HRESULT hres = WbemVariantChangeType(pvDest, pvSource, vt);
    if(FAILED(hres))
        return hres;

    if(ct == CIM_SINT8)
    {
        if(V_I2(pvDest) > 127 || V_I2(pvDest) < -128)
            hres = WBEM_E_TYPE_MISMATCH;
    }
    else if(ct == CIM_UINT16)
    {
        if(V_I4(pvDest) > 65535 || V_I4(pvDest) < 0)
            hres = WBEM_E_TYPE_MISMATCH;
    }
    else if(ct == CIM_UINT32)
    {
        __int64 i64;
        if(!ReadI64(V_BSTR(pvDest), i64))
            hres = WBEM_E_INVALID_QUERY;
        else if(i64 < 0 || i64 >= (__int64)1 << 32)
            hres = WBEM_E_TYPE_MISMATCH;
    }
    else if(ct == CIM_UINT64)
    {
        unsigned __int64 ui64;
        if(!ReadUI64(V_BSTR(pvDest), ui64))
            hres = WBEM_E_INVALID_QUERY;
    }
    else if(ct == CIM_SINT64)
    {
        __int64 i64;
        if(!ReadI64(V_BSTR(pvDest), i64))
            hres = WBEM_E_INVALID_QUERY;
    }

    if(FAILED(hres))
    {
        VariantClear(pvDest);
    }
    return hres;
}

static HANDLE g_hSecurityMutex = NULL;
static BOOL g_bUseSecurityMutex = FALSE;
static DWORD g_dwSecurityMutexThreadId = 0xFFFFFFFF;

POLARITY void SecurityMutexRequest()
{
    if (g_bUseSecurityMutex)
    {
        WaitForSingleObject(g_hSecurityMutex, INFINITE);

        // Store the owning Thread Id
        g_dwSecurityMutexThreadId = GetCurrentThreadId();
    }
}

POLARITY void SecurityMutexClear()
{
    if (g_bUseSecurityMutex)
    {

        // Clear the owning thread id for debugging
        g_dwSecurityMutexThreadId = 0xFFFFFFFF;
        ReleaseMutex(g_hSecurityMutex);
    }
}

//***************************************************************************
//
//  bool IsStandAloneWin9X
//
//  DESCRIPTION:
//
//  returns true if we are a win95 box and we want standalone security.
//
//***************************************************************************

POLARITY bool IsStandAloneWin9X()
{
    if(IsNT())
        return false;

    Registry r(HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_WINMGMT);
    DWORD dwEnabled = 0;
    int iRes = r.GetDWORDStr(__TEXT("EnableAnonConnections"), &dwEnabled);
    if(iRes == 0 && dwEnabled == 1)
        return true;
    else
        return false;
}
//***************************************************************************
//
//  WCHAR *ExtractMachineName
//
//  DESCRIPTION:
//
//  Takes a path of form "\\machine\xyz... and returns the
//  "machine" portion in a newly allocated WCHAR.  The return value should
//  be freed via delete. NULL is returned if there is an error.
//
//
//  PARAMETERS:
//
//  pPath               Path to be parsed.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

POLARITY WCHAR *ExtractMachineName ( IN BSTR a_Path )
{
    WCHAR *t_MachineName = NULL;

    //todo, according to the help file, the path can be null which is
    // default to current machine, however Ray's mail indicated that may
    // not be so.

    if ( a_Path == NULL )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
        {
           wcscpy ( t_MachineName , L"." ) ;
        }

        return t_MachineName ;
    }

    // First make sure there is a path and determine how long it is.

    if ( ! IsSlash ( a_Path [ 0 ] ) || ! IsSlash ( a_Path [ 1 ] ) || wcslen ( a_Path ) < 3 )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
        {
             wcscpy ( t_MachineName , L"." ) ;
        }

        return t_MachineName ;
    }

    WCHAR *t_ThirdSlash ;

    for ( t_ThirdSlash = a_Path + 2 ; *t_ThirdSlash ; t_ThirdSlash ++ )
    {
        if ( IsSlash ( *t_ThirdSlash ) )
            break ;
    }

    if ( t_ThirdSlash == &a_Path [2] )
    {
        return NULL;
    }

    // allocate some memory

    t_MachineName = new WCHAR [ t_ThirdSlash - a_Path - 1 ] ;
    if ( t_MachineName == NULL )
    {
        return t_MachineName ;
    }

    // temporarily replace the third slash with a null and then copy

    WCHAR t_SlashCharacter = *t_ThirdSlash ;
    *t_ThirdSlash = NULL;

    wcscpy ( t_MachineName , a_Path + 2 ) ;

    *t_ThirdSlash  = t_SlashCharacter ;        // restore it.

    return t_MachineName ;
}

//***************************************************************************
//
//  BOOL bAreWeLocal
//
//  DESCRIPTION:
//
//  Determines if the connection is to the current machine.
//
//  PARAMETERS:
//
//  pwcServerName       Server name as extracted from the path.
//
//  RETURN VALUE:
//
//  True if we are local
//
//***************************************************************************

POLARITY BOOL bAreWeLocal(WCHAR * pServerMachine)
{
    BOOL bRet = FALSE;
    if(pServerMachine == NULL)
        return TRUE;
    if(!wbem_wcsicmp(pServerMachine,L"."))
        return TRUE;

	if ( IsNT () )
	{
		wchar_t wczMyName[MAX_PATH];
		DWORD dwSize = MAX_PATH;

		if(!GetComputerNameW(wczMyName,&dwSize))
			return FALSE;

		bRet = !wbem_wcsicmp(wczMyName,pServerMachine);
	}
	else
	{
		TCHAR tcMyName[MAX_PATH];
		DWORD dwSize = MAX_PATH;
		if(!GetComputerName(tcMyName,&dwSize))
			return FALSE;

#ifdef UNICODE
		bRet = !wbem_wcsicmp(tcMyName,pServerMachine);
#else
		WCHAR wWide[MAX_PATH];
		mbstowcs(wWide, tcMyName, MAX_PATH-1);
		bRet = !wbem_wcsicmp(wWide,pServerMachine);
#endif
	}

    return bRet;
}

POLARITY HRESULT WbemSetDynamicCloaking(IUnknown* pProxy, 
                    DWORD dwAuthnLevel, DWORD dwImpLevel)
{
    HRESULT hres;

    if(!IsW2KOrMore())
    {
        // Not NT5 --- don't bother
        // ========================

        return WBEM_S_FALSE;
    }

    // Try to get IClientSecurity from it
    // ==================================

    IClientSecurity* pSec;
    hres = pProxy->QueryInterface(IID_IClientSecurity, (void**)&pSec);
    if(FAILED(hres))
    {
        // Not a proxy --- not a problem
        // =============================

        return WBEM_S_FALSE;
    }

    hres = pSec->SetBlanket(pProxy, RPC_C_AUTHN_WINNT, 
                    RPC_C_AUTHZ_NONE, NULL, dwAuthnLevel, 
                    dwImpLevel, NULL, EOAC_DYNAMIC_CLOAKING);
    pSec->Release();

    return hres;
}

POLARITY DWORD GetCurrentImpersonationLevel()
{
    // Open thread token
    // =================

    HANDLE hThreadToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
                                &hThreadToken);

    if (bRes == FALSE)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_NO_IMPERSONATION_TOKEN || lRes == ERROR_NO_TOKEN)
        {
            // This is the basic process thread. 
            // =================================

            return RPC_C_IMP_LEVEL_DELEGATE;
        }
        else if(lRes == ERROR_CANT_OPEN_ANONYMOUS)
        {
            // Anonymous call   
            // ==============

            return RPC_C_IMP_LEVEL_ANONYMOUS;
        }
        else
        {
            // Unknown error
            // =============

            return RPC_C_IMP_LEVEL_ANONYMOUS;
        }
    }

    // Find out token info.
    // =====================

    DWORD dwTmp = 0, dwBytesReturned = 0;

    bRes = GetTokenInformation(
        hThreadToken,
        TokenImpersonationLevel, 
        &dwTmp,
        sizeof(DWORD),
        &dwBytesReturned
        );

    // We don't need this anymore
    CloseHandle(hThreadToken);
    hThreadToken = NULL;

    if (bRes == FALSE)
    {
        return RPC_C_IMP_LEVEL_ANONYMOUS;
    }


    switch (dwTmp)
    {
        case SecurityAnonymous:
            return RPC_C_IMP_LEVEL_ANONYMOUS;
            
        case SecurityIdentification:
            return RPC_C_IMP_LEVEL_IDENTIFY;

        case SecurityImpersonation:
            return RPC_C_IMP_LEVEL_IMPERSONATE;

        case SecurityDelegation:
            return RPC_C_IMP_LEVEL_DELEGATE;

        default:
            return RPC_C_IMP_LEVEL_ANONYMOUS;
    }
}

POLARITY HRESULT EnableAllPrivileges(DWORD dwTokenType)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
    BOOL bRes;

    switch (dwTokenType)
    {
    case TOKEN_THREAD:
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken); 
        break;
    case TOKEN_PROCESS:
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
        break;
    }
    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, 
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}


POLARITY bool IsPrivilegePresent(HANDLE hToken, LPCTSTR pName)
{
    if(pName == NULL)
        return false;
    LUID PrivilegeRequired ;

    if(!LookupPrivilegeValue(NULL, pName, &PrivilegeRequired))
        return FALSE;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    BOOL bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
        return false;
    CDeleteMe<BYTE> dm(pBuffer);
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, 
                                &dwLen);
    if(!bRes)
        return false;

    // Iterate through all the privileges and look for the one in question.
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        if(pPrivs->Privileges[i].Luid.LowPart == PrivilegeRequired.LowPart &&
           pPrivs->Privileges[i].Luid.HighPart == PrivilegeRequired.HighPart )
            return true;
    }
    return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\like.h ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   like.h
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************

#ifndef _LIKE_H_
#define _LIKE_H_


#include <string.h>

//
// The CLike class implements the SQL "like" operation.  To compare test 
// strings to an expression, construct an instance of the CLike class using 
// the expression and an optional escape character.  Then use the Match() 
// method on that instance to test each string.  Note, this class makes it's
// own copy of the expression used to construct it.  This implementation 
// supports the '%' and '_' wildard characters as well as the [] and [^] 
// constructs for matching sets of characters and ranges of characters.
//
class POLARITY CLike
{
public:
    CLike() : m_expression(NULL) {} 
    CLike( LPCWSTR expression, WCHAR escape='\0' );
    CLike( const CLike& rOther ) : m_expression(NULL) { *this = rOther; }
    CLike& operator= ( const CLike& rOther );
    ~CLike();
    
    bool Match (LPCWSTR string);
    LPCWSTR GetExpression() { return m_expression; }
    void SetExpression( LPCWSTR string, WCHAR escape='\0' );

protected:
    LPWSTR m_expression;
    WCHAR m_escape;
    
    // Recursive function and helpers for performing like operation.
    bool DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape);
    bool MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip);
};


#endif // _LIKE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\genutils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    GENUTILS.H

Abstract:

    Declares various utilities.

History:

    a-davj    21-June-97   Created.

--*/

#ifndef _genutils_H_
#define _genutils_H_

#include "corepol.h"
#include "strutils.h"
#include <wbemidl.h>

// These are some generally useful routines
// ========================================

POLARITY BOOL IsW2KOrMore(void);
POLARITY BOOL IsNT(void);
POLARITY BOOL IsWin95(void);
POLARITY BOOL IsNT351(void);
POLARITY BOOL IsWinMgmt(void);
POLARITY BOOL SetObjectAccess(HANDLE hObj);
POLARITY void RegisterDLL(HMODULE hModule, GUID guid, TCHAR * pDesc, TCHAR * pModel, TCHAR * progid);
POLARITY void UnRegisterDLL(GUID guid, TCHAR * progid);
POLARITY HRESULT WbemVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, 
            VARTYPE vtNew);
POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& i64);
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& ui64);
POLARITY HRESULT ChangeVariantToCIMTYPE(VARIANT* pvDest, VARIANT* pvSource,
                                            CIMTYPE ct);
POLARITY void SecurityMutexRequest();
POLARITY void SecurityMutexClear();
POLARITY bool IsStandAloneWin9X();
POLARITY BOOL bAreWeLocal(WCHAR * pServerMachine);
POLARITY WCHAR *ExtractMachineName ( IN BSTR a_Path );
POLARITY DWORD GetCurrentImpersonationLevel();
POLARITY HRESULT WbemSetDynamicCloaking(IUnknown* pProxy, 
                    DWORD dwAuthnLevel, DWORD dwImpLevel);

class POLARITY CAutoSecurityMutex
{
    BOOL    m_fLocked;

public:
    CAutoSecurityMutex() : m_fLocked( FALSE )
    {
        SecurityMutexRequest();
        m_fLocked = TRUE;
    }

    ~CAutoSecurityMutex()
    {
        if ( m_fLocked ) SecurityMutexClear();
    }

    void Release( void )
    {
        if ( m_fLocked ) SecurityMutexClear();
        m_fLocked = FALSE;
    }
};

#define TOKEN_THREAD    0
#define TOKEN_PROCESS   1
POLARITY HRESULT EnableAllPrivileges(DWORD dwTokenType = TOKEN_THREAD);
POLARITY bool IsPrivilegePresent(HANDLE hToken, LPCTSTR pName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\locks.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <precomp.h>
#include <locks.h>
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400

ReaderWriter::ReaderWriter(bool can_throw) : initialized_(false), can_throw_(can_throw)
{
  C_ASSERT(sizeof(::RTL_RESOURCE)==sizeof(ReaderWriter::RTL_RESOURCE));
  __try
  {
	RtlInitializeResource((::RTL_RESOURCE*)&lock_);
	initialized_ = true;
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  }
  if (initialized_ != true)
    raise_exception();
}

ReaderWriter::~ReaderWriter (void)
{ if (initialized_) RtlDeleteResource((::RTL_RESOURCE*)&lock_);}

bool 
ReaderWriter::acquire (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,TRUE)==TRUE);}

bool 
ReaderWriter::tryacquire (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,FALSE)==TRUE);}

bool 
ReaderWriter::release (void) 
{ RtlReleaseResource((::RTL_RESOURCE*)&lock_); return 0;}


bool 
ReaderWriter::acquire_read (void) 
{ return (RtlAcquireResourceShared((::RTL_RESOURCE*)&lock_,TRUE)==TRUE);}

bool 
ReaderWriter::acquire_write (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,TRUE)==TRUE);}

bool 
ReaderWriter::tryacquire_read (void) 
{ return (RtlAcquireResourceShared((::RTL_RESOURCE*)&lock_,FALSE)==TRUE);}

bool 
ReaderWriter::tryacquire_write (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,FALSE)==TRUE);}

void 
ReaderWriter::downgrade() 
{ RtlConvertExclusiveToShared((::RTL_RESOURCE*)&lock_);}

void
ReaderWriter::upgrade() 
{ RtlConvertSharedToExclusive((::RTL_RESOURCE*)&lock_);}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\like.cpp ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   like.cpp
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************


#include "precomp.h"
#include "like.h"
#include "corex.h"

#define WILDCARD		L'%'
#define ANYSINGLECHAR	L'_'

CLike::CLike (LPCWSTR expression, WCHAR escape)
: m_expression(NULL)
{
    SetExpression( expression, escape );
}

CLike& CLike::operator=( const CLike& rOther )
{
    if ( rOther.m_expression != NULL )
    {
        SetExpression( rOther.m_expression, rOther.m_escape );
    }
    else
    {
        delete [] m_expression;
        m_expression = NULL;
    }

    return *this;
}
                             
CLike::~CLike (void)
{
    delete [] m_expression;
}

void CLike::SetExpression( LPCWSTR string, WCHAR escape ) 
{
    delete [] m_expression;
    m_expression = new WCHAR[wcslen(string)+1];
    if ( m_expression == NULL )
    {
        throw CX_MemoryException();
    }
    wcscpy( m_expression, string );
    m_escape = escape;
}

bool CLike::Match( LPCWSTR string )
{
    bool bRes;

    if ( m_expression != NULL )
    {
        bRes = DoLike( m_expression, string, m_escape );
    }
    else
    {
        bRes = false;
    }

    return bRes; 
}


bool CLike::DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape)
{
	bool like=false;
	while (!like && *pattern && *string)
	{
		// Wildcard match.
		if (*pattern==WILDCARD)
		{
			pattern++;

			do
			{
				like=DoLike (pattern, string, escape);
				if (!like) string++;
			}
			while (*string && !like);
		}
		// Set match.
		else if (*pattern=='[')
		{
			int skip;
			if (MatchSet (pattern, string, skip))
			{
				pattern+=skip;
				string++;
			}
			else
			{
				break;
			}
		}
		// Single character match.
		else
		{
			if (escape!='\0' && *pattern==escape) pattern++;
			if (towupper(*pattern)==towupper(*string) || *pattern==ANYSINGLECHAR)
			{
				pattern++;
				string++;
			}
			else
			{
				break;
			}
		}
	}

	// Skip any trailing wildcard characters.
	while (*pattern==WILDCARD) pattern++;

	// It's a match if we reached the end of both strings, or a recursion 
	// succeeded.
	return (!(*pattern) && !(*string)) || like;
}


bool CLike::MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip)
{
	// Skip the opening '['.
	LPCWSTR pos=pattern+1;

	// See if we are matching a [^] set.
	bool notinset=(*pos=='^');
	if (notinset) pos++;

	// See if the target character matches any character in the set.
	bool matched=false;
	WCHAR lastchar='\0';
	while (*pos && *pos!=']' && !matched)
	{
		// A range of characters is indicated by a '-' unless it's the first
		// character in the set (in which case it's just a character to be
		// matched.
		if (*pos=='-' && lastchar!='\0')
		{
			pos++;
			if (*pos && *pos!=']')
			{
				matched=(towupper(*string)>=lastchar && towupper(*string)<=towupper(*pos));
				lastchar=towupper(*pos);
				pos++;
			}
		}
		else
		{
			// Match a normal character in the set.
			lastchar=towupper(*pos);
			matched=(towupper(*pos)==towupper(*string));
			if (!matched) pos++;
		}
	}

	// Skip the trailing ']'.  If the set did not contain a closing ']'
	// we return a failed match.
	while (*pos && *pos!=']') pos++;
	if (*pos==']') pos++;
	if (!*pos) matched=false;

	// Done.
	skip=(int)(pos-pattern);
	return matched==!notinset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\locks.h ===
#ifndef __LOCKS_H__
#define __LOCKS_H__

#include <windows.h>
#include <dothrow.h>
# pragma once

const bool THROW_LOCK = true;
const bool NOTHROW_LOCK = false;

class CriticalSection
{
public:
  CriticalSection (bool can_throw , DWORD count = 0 );
  // Initialize the CRITICAL_SECTION.

  ~CriticalSection (void);
  // Implicitly destroy the CRITICAL_SECTION.
  bool close (void);
  // dummy call
  bool acquire (void);
  // Acquire lock ownership ( block if necessary).

  bool tryacquire (void);
  // Conditionally acquire lock ( non blocking ).  Returns
  // false on failure

  bool release (void);

  // Release lock 

  bool acquire_read (void);
  bool acquire_write (void);

  bool tryacquire_read (void);
  bool tryacquire_write (void);

  bool valid() const { return initialized_;}

  const CRITICAL_SECTION &lock (void) const;
  // Return the underlying mutex.

  void dump( void ) const ;

private:

  CRITICAL_SECTION lock_;
  bool initialized_;
  bool can_throw_;
  void raise_exception();

private:
  // = Prevent assignment and initialization.
  void operator= (CriticalSection &);
  CriticalSection (const CriticalSection &);
};

template <class Lock> 
bool SleepAndLock( Lock& lock, int timeout )
{
    if (lock.valid())
	for (;!lock.locked();)
	{
	Sleep(timeout);
	lock.acquire();
	}	
    return lock.locked();	
}

inline 
CriticalSection::CriticalSection (bool can_throw,DWORD count):initialized_(false),can_throw_(can_throw)
{
  __try
  {
    if(!count)
        InitializeCriticalSection(&lock_);
    else
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400
        InitializeCriticalSectionAndSpinCount(&lock_,count);
#else
	InitializeCriticalSection(&lock_);
#endif
#else
	InitializeCriticalSection(&lock_);
#endif
    initialized_ = true;
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  }
  if (initialized_ != true)
    raise_exception();
};

inline 
CriticalSection::~CriticalSection ()
{
  if (initialized_)
    DeleteCriticalSection(&lock_);
}

inline void 
CriticalSection::raise_exception()
{
  if (can_throw_)
	throw CX_MemoryException();
};

inline bool
CriticalSection::acquire(void)
{
  return acquire_write();
};

inline bool
CriticalSection::acquire_read(void)
{
  return acquire_write();
};

#ifndef STATUS_POSSIBLE_DEADLOCK
#define STATUS_POSSIBLE_DEADLOCK         (0xC0000194L)
#endif

inline bool
CriticalSection::acquire_write(void)
{
  if (initialized_)
  {
      bool bBreak = false;
	  __try
	  {
	    EnterCriticalSection(&lock_);
	    return true;
	  }
	  __except((GetExceptionCode() == STATUS_NO_MEMORY)?
	  	         EXCEPTION_EXECUTE_HANDLER:
	  	         ((bBreak = (GetExceptionCode() == STATUS_POSSIBLE_DEADLOCK))?
	  	             EXCEPTION_EXECUTE_HANDLER:
	  	             EXCEPTION_CONTINUE_SEARCH))
	  {
	    if (bBreak)
	    	DebugBreak();
	  }
  }
  return false;
};

inline bool
CriticalSection::release(void)
{
  if (initialized_)
  {
    LeaveCriticalSection(&lock_);
    return true;
  }
  return false;
}

inline bool
CriticalSection::tryacquire()
{
  return tryacquire_write();
};

inline bool
CriticalSection::tryacquire_read()
{
  return tryacquire_write();
};

inline bool
CriticalSection::tryacquire_write()
{
  __try
  {
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400
    return TRUE == TryEnterCriticalSection(&lock_);
#else
    return false;
#endif
#else
    return false;
#endif      
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  };
  return false;
};

inline bool
CriticalSection::close()
{
  return false;
};

#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400

class ReaderWriter
{
   struct RTL_RESOURCE {
    struct RTL_RESOURCE_DEBUG;
    RTL_CRITICAL_SECTION CriticalSection;
    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;
    LONG NumberOfActive;
    HANDLE ExclusiveOwnerThread;
    ULONG Flags;        // See RTL_RESOURCE_FLAG_ equates below.
    RTL_RESOURCE_DEBUG* DebugInfo;
   };

public:
  ReaderWriter (bool can_throw);

  ~ReaderWriter (void);

  bool close (void);

  bool acquire (void);

  bool tryacquire (void);

  bool release (void);

  // Release lock 

  bool acquire_read (void);
  bool acquire_write (void);

  bool tryacquire_read (void);
  bool tryacquire_write (void);

  void upgrade();
  void downgrade();

  bool valid() const { return initialized_;}

  const ReaderWriter &lock (void) const;
  // Return the underlying mutex.

  void dump( void ) const;

private:

  RTL_RESOURCE lock_;
  bool initialized_;
  bool can_throw_;
  void raise_exception();

private:
  // = Prevent assignment and initialization.
  void operator= (ReaderWriter &);
  ReaderWriter (const ReaderWriter &);
};

inline void 
ReaderWriter::raise_exception()
{
  if (can_throw_)
	throw CX_MemoryException();
};
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\lockst.h ===
#ifndef __LOCKST_H__
#define __LOCKST_H__

#include "locks.h"
#include <assert.h>
# pragma once

#define CS_GUARD(name_of_lock , source_of_lock ) \
LockGuard<CriticalSection> name_of_lock(source_of_lock); 

#define CS_GUARD_RETURN(name_of_lock , source_of_lock, return_code_of_lock ) \
LockGuard<CriticalSection> name_of_lock(source_of_lock); \
if (name_of_lock.locked() == false) \
	return (return_code_of_lock); 

#define CS_GUARD_RETURN_VOID(name_of_lock , source_of_lock) \
LockGuard<CriticalSection> name_of_lock(source_of_lock); \
if (name_of_lock.locked() == false) \
	return ; 
 
template <class LOCK, class EXCEPTION_STRATEGY = wminothrow_t>
class LockGuard
{
  //     It performs automatic aquisition and release of
  //     a parameterized synchronization object <LOCK>.
public:

  // = Initialization and termination methods.
  LockGuard (LOCK &l);
  LockGuard (LOCK &l, bool block);
  // Implicitly and automatically acquire (or try to acquire) the
  // lock.

  ~LockGuard (void);
  // Implicitly release the lock.
  // = Lock accessors.
  bool acquire (void);
  // Explicitly acquire the lock.

  bool tryacquire (void);
  // Conditionally acquire the lock (i.e., won't block).

  bool release (void);
  // Explicitly release the lock, but only if it is held!

  bool locked (void);
  // true if locked, false if couldn't acquire the lock
  bool valid() { return lock_->valid();};

  void dump (void) const;
  // Dump the state of an object.

protected:
  bool raise_exception(void)
  {
	if (!owner_)
		EXCEPTION_STRATEGY::raise_lock_failure();
	return owner_;
  }
  LockGuard (LOCK *lock): lock_ (lock) { }
  // Helper, meant for subclass only.

  LOCK *lock_;
  // Pointer to the LOCK we're LockGuarding.
  bool owner_;
  // Keeps track of whether we acquired the lock or failed.
private:
  // = Prevent assignment and initialization.
  void operator= (const LockGuard<LOCK,EXCEPTION_STRATEGY> &);
  LockGuard (const LockGuard<LOCK,EXCEPTION_STRATEGY> &);
};

template <class LOCK, class EXCEPTION_STRATEGY = wminothrow_t>
class ReadLockGuard : public LockGuard<LOCK,EXCEPTION_STRATEGY>
{
public:
	ReadLockGuard(LOCK& lock):LockGuard(&lock){ aquire();}
	ReadLockGuard(LOCK& lock, bool block);
	~ReadLockGuard(){ release() }
  bool acquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->acquire_read ();
	return raise_exception();
  };
  bool tryacquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->tryacquire_read ();
	return raise_exception();
  }
  bool release (void)
  { if (owner_) 
	{
		owner_ = false;
		lock_->release();
	}else
		return false;
  }
};

template <class LOCK, class EXCEPTION_STRATEGY = wminothrow_t>
class WriteLockGuard : public LockGuard<LOCK,EXCEPTION_STRATEGY>
{
public:
	WriteLockGuard(LOCK& lock):LockGuard(&lock){ aquire();}
	WriteLockGuard(LOCK& lock, bool block);
	~WriteLockGuard(){ release(); }
  bool acquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->acquire_write ();
	return raise_exception();
  };
  bool tryacquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->tryacquire_write ();
	return raise_exception();
  }
  bool release (void)
  { if (owner_) 
	{
		owner_ = false;
		lock_->release ();
	}else
		return false;
  }
};

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::acquire (void)
{
  assert(owner_==false);
  owner_ = lock_->acquire ();
  return raise_exception();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::tryacquire (void)
{
  assert(owner_==false);
  owner_ = lock_->tryacquire ();
  return raise_exception();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::release (void)
{
  if (owner_)
    {
      owner_ = false;
      return lock_->release ();
    }
  else
    return 0;
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
LockGuard<LOCK,EXCEPTION_STRATEGY>::LockGuard (LOCK &l)
  : lock_ (&l),
    owner_ (false)
{
  acquire ();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
LockGuard<LOCK,EXCEPTION_STRATEGY>::LockGuard (LOCK &l, bool block)
  : lock_ (&l),   owner_ (false)
{
  if (block)
    acquire ();
  else
    tryacquire ();
}


template <class LOCK, class EXCEPTION_STRATEGY> inline
LockGuard<LOCK>::~LockGuard (void)
{
  release ();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::locked (void)
{
  return owner_;
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
ReadLockGuard<LOCK,EXCEPTION_STRATEGY>::ReadLockGuard (LOCK &l, bool block)
  : LockGuard (&l),   owner_ (false)
{
  if (block)
    acquire ();
  else
    tryacquire ();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
WriteLockGuard<LOCK,EXCEPTION_STRATEGY>::WriteLockGuard (LOCK &l, bool block)
  : LockGuard (&l),   owner_ (false)
{
  if (block)
    acquire ();
  else
    tryacquire ();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\md5wbem.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

#include "md5.h"
#include "md5wbem.h"




void MD5::Transform(
    IN  LPVOID  pInputValue,
    IN  UINT    uValueLength,
    OUT BYTE    MD5Buffer[16]
    )
{
    MD5_CTX Ctx;
    MD5Init(&Ctx);

    MD5Update(
        &Ctx,
        (unsigned char *) pInputValue,
        uValueLength
    );

    MD5Final(&Ctx);
    CopyMemory(MD5Buffer, Ctx.digest, 16);
}

void MD5::ContinueTransform(
    IN  LPVOID  pInputValue,
    IN  UINT    uValueLength,
    IN OUT BYTE    MD5Buffer[16]
    )
{
    MD5_CTX Ctx;
    MD5Init(&Ctx);      // zeros buffer, and counts

    CopyMemory( Ctx.buf, MD5Buffer, 16 );

    MD5Update(
        &Ctx,
        (unsigned char *) pInputValue,
        uValueLength
    );

    MD5Final(&Ctx);
    CopyMemory(MD5Buffer, Ctx.digest, 16);
}


#ifdef TESTEXE

void main()
{
    char buf[128];
    printf("Enter a string to be digested:");
    gets(buf);

    BYTE MD5Digest[16];

    MD5::Transform(buf, strlen(buf), MD5Digest);

    for (int i = 0; i < 16; i++)
        printf("%02x", MD5Digest[i]);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\md5wbem.h ===
//***************************************************************************
//
//  MD5.H
//
//  MD5 Message Digest 
//
//  raymcc  21-Apr-97   Adapted Ron Rivest's source from RFC 1321.
//
//  This implementation was checked against a reference suite
//  on 24-Apr-97.  Do NOT ALTER the source code for any reason!
//
//  ------------------------------------------------------------------
//
//  Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
//  rights reserved.
//
//  License to copy and use this software is granted provided that it
//  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
//  Algorithm" in all material mentioning or referencing this software
//  or this function.
//
//  License is also granted to make and use derivative works provided
//  that such works are identified as "derived from the RSA Data
//  Security, Inc. MD5 Message-Digest Algorithm" in all material
//  mentioning or referencing the derived work.
//
//  RSA Data Security, Inc. makes no representations concerning either
//  the merchantability of this software or the suitability of this
//  software for any particular purpose. It is provided "as is"
//  without express or implied warranty of any kind.
//
//***************************************************************************

#ifndef _MD5WBEM_H_
#define _MD5WBEM_H_
#include "corepol.h"

class POLARITY MD5
{
public:
    static void Transform(
        IN  LPVOID pInputValue,         // Value to be digested
        IN  UINT   uValueLength,        // Length of value, 0 is legal
        OUT BYTE   MD5Buffer[16]        // Receives the MD5 hash
        );    
    static void ContinueTransform(
        IN  LPVOID  pInputValue, 
        IN  UINT    uValueLength,
        IN OUT BYTE    MD5Buffer[16]
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrciclass.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MRCICLASS.CPP

Abstract:

   Implements the Wrapper class for MRCI 1 & MRCI 2 maxcompress 
   and decompress functions

History:

  paulall       1-Jul-97    Created

--*/

#include "precomp.h"

#include <io.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys\stat.h>
#include "MRCIclass.h"
#include <TCHAR.H>

class CMRCICompressionHeaderV1
{
public:
    char     cVersion;          //Compression file format
    char     compressionLevel;  //Is this a level 1 or level 2 compression
    DWORD    dwReadBufferSize;  //Buffer size used to read original file
    FILETIME ftCreateTime;      //Time and date file created
    __int64  dwOriginalSize;    //Original file length
//  ... for each buffer
//  CMRCICompressionBlockV1 block;
//  ... until dwNextBufferSize is 0
};

class CMRCICompressionBlockV1
{
public:
    char    bCompressed;        //Was this block compressed
    DWORD   dwNextBufferSize;   //Size of the proceeding buffer
    DWORD   dwUncompressedBufferSize;   //Size needed for uncompress buffer
    //char[dwNextBufferSize];   //next block is the compression part
};


CMRCICompression::CMRCICompression()
{
}

CMRCICompression::~CMRCICompression()
{
}

BOOL CMRCICompression::GetCompressedFileInfo(const TCHAR *pchFile, 
                    CompressionLevel &compressionLevel,
                    DWORD &dwReadBufferSize,
                    FILETIME &ftCreateTime,
                    __int64  &dwOriginalSize)
{
    BOOL bStatus = FALSE;
    int hFile = _topen(pchFile,_O_BINARY | _O_RDONLY, 0);
    if (hFile != -1)
    {
        CMRCICompressionHeaderV1 header;

        if (_read(hFile, &header, sizeof(CMRCICompressionHeaderV1)) ==
            sizeof(CMRCICompressionHeaderV1))
        {    
            compressionLevel = (CompressionLevel)header.cVersion;
            dwReadBufferSize = header.dwReadBufferSize;
            ftCreateTime = header.ftCreateTime;
            dwOriginalSize = header.dwOriginalSize;

            //If the version is 0xFF, the file is not valid!
            if (header.cVersion != 0xFF)
                bStatus = TRUE;
        }

        _close(hFile);
    }

    return bStatus;
}

BOOL CMRCICompression::CompressFile(const TCHAR *pchFileFrom, 
                                    const TCHAR *pchFileTo, 
                                    DWORD dwBufferSize,
                                    CompressionLevel compressionLevel,
                                    CMRCIControl *pControlObject)
{
    BOOL bStatus = FALSE;
    int fileFrom;
    int fileTo;

    //Open the files for processing
    //=============================
    fileFrom = _topen(pchFileFrom,_O_BINARY | _O_RDONLY, 0);
    fileTo = _topen(pchFileTo, _O_BINARY | _O_TRUNC | _O_CREAT | _O_WRONLY, _S_IREAD | _S_IWRITE);

    //If open sucessful
    //=================
    if ((fileFrom != -1) && (fileTo != -1))
    {
        //DO the compression using the latest and greatest version
        //========================================================
        bStatus = CompressFileV1(fileFrom, fileTo, dwBufferSize, compressionLevel, pControlObject);
    }

    //Close the files
    //===============
    if (fileFrom != -1)
        _close(fileFrom);
    if (fileTo != -1)
        _close(fileTo);

    if (pControlObject && pControlObject->AbortRequested())
    {
        //User requested an abort, so we need to delete the compressed file...
        _tunlink(pchFileTo);
        bStatus = FALSE;
    }

    return bStatus;
}

BOOL CMRCICompression::CompressFileV1(int hFileFrom, 
                                      int hFileTo, 
                                      DWORD dwBufferSize,
                                      CompressionLevel compressionLevel,
                                      CMRCIControl *pControlObject)
{
    BOOL bStatus = FALSE;
    unsigned char *pBufferFrom = new unsigned char[dwBufferSize + 4];
    unsigned char *pBufferTo   = new unsigned char[dwBufferSize + 4];

    if (pBufferFrom && pBufferTo)
    {
        //Write the header to the new file
        //================================
        CMRCICompressionHeaderV1 header;

        header.cVersion = char(0xFF);       //INVALID.  We write the header back when we have
                                    //finished!  When we read this, we check to see
                                    //if this is invalid.  We do not uncompress if it is
                                    //this value....
        header.compressionLevel = compressionLevel;
        header.dwReadBufferSize = dwBufferSize;

        SYSTEMTIME sysTime;
        GetSystemTime(&sysTime);
        SystemTimeToFileTime(&sysTime, &header.ftCreateTime);

        header.dwOriginalSize = _filelengthi64(hFileFrom);

        if (_write(hFileTo, &header, sizeof(CMRCICompressionHeaderV1)) != sizeof(CMRCICompressionHeaderV1))
        {
            delete [] pBufferFrom;
            delete [] pBufferTo;
            bStatus = FALSE;
            return bStatus;
        }

        __int64 remainingFileSize = header.dwOriginalSize;
        unsigned cbChunk;
        unsigned cbCompressed;

        bStatus = TRUE;

        //While we have some file to write...
        //===================================
        while (remainingFileSize)
        {
            //See if we need to abort the compression...
            if (pControlObject && pControlObject->AbortRequested())
            {
                break;
            }

            //Calculate the size of this buffer to compress
            //=============================================
            if (remainingFileSize > dwBufferSize)
            {
                cbChunk = dwBufferSize;
            }
            else
            {
                cbChunk = (unsigned) remainingFileSize;
            }

            //Read from the source file
            //=========================
            if (_read(hFileFrom, pBufferFrom, cbChunk) != (int) cbChunk)
            {
                bStatus = FALSE;
                break;
            }

            //Calculate what is left to read
            //==============================
            remainingFileSize -= cbChunk;

            //Compress the buffer
            //===================
            cbCompressed = CompressBuffer(pBufferFrom, cbChunk, pBufferTo, dwBufferSize, compressionLevel);

            //Create the compression block header
            CMRCICompressionBlockV1 block;
            unsigned char *pWriteBuffer;
            unsigned thisBufferSize;

            if ((cbCompressed == (unsigned) -1) || (cbCompressed >= cbChunk))
            {
                //This means compression failed or there was no compression...
                block.bCompressed = FALSE;
                pWriteBuffer = pBufferFrom;
                thisBufferSize = cbChunk;
            }
            else
            {
                block.bCompressed = TRUE;
                pWriteBuffer = pBufferTo;
                thisBufferSize = cbCompressed;
            }
            block.dwNextBufferSize = thisBufferSize;
            block.dwUncompressedBufferSize = cbChunk;

            //Write the block header
            //======================
            if (_write(hFileTo, &block, sizeof(CMRCICompressionBlockV1)) != sizeof(CMRCICompressionBlockV1))
            {
                bStatus = FALSE;
                break;
            }

            //Write the compressed block
            //==========================
            if (_write(hFileTo, pWriteBuffer, thisBufferSize) != (int)thisBufferSize)
            {
                bStatus = FALSE;
                break;
            }
        }

        if (pControlObject && pControlObject->AbortRequested())
        {
            //User requested an abort...
        }
        else
        {
            //Write final block header with zero length buffer marker
            CMRCICompressionBlockV1 block;
            block.dwNextBufferSize = 0;
            block.bCompressed = FALSE;
            if (_write(hFileTo, &block, sizeof(CMRCICompressionBlockV1)) != -1 &&
                _lseek(hFileTo, 0, SEEK_SET) != -1)
            {
                //Write a valid block header to the start with a correct version number
                header.cVersion = 1;        //Set this to the correct version
                bStatus =
                    _write(hFileTo, &header, sizeof(CMRCICompressionHeaderV1)) != -1;
            }
            else
                bStatus = FALSE;
        }

    }

    //Tidy up
    delete [] pBufferFrom;
    delete [] pBufferTo;

    return bStatus;
}
unsigned CMRCICompression::CompressBuffer(unsigned char *pFromBuffer,
                        DWORD dwFromBufferSize,
                        unsigned char *pToBuffer,
                        DWORD dwToBufferSize, 
                        CompressionLevel compressionLevel)
{
    unsigned cbCompressed;
    if (compressionLevel == level1)
    {
        cbCompressed = Mrci1MaxCompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }
    else
    {
        cbCompressed = Mrci2MaxCompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }

    return cbCompressed;
}


BOOL CMRCICompression::UncompressFile(const TCHAR *pchFromFile, const TCHAR *pchToFile)
{
    BOOL bStatus = FALSE;
    int fileFrom;
    int fileTo;

    //Open the files
    //==============
    fileFrom = _topen(pchFromFile,_O_BINARY | _O_RDONLY, 0);
    fileTo = _topen(pchToFile, _O_BINARY | _O_TRUNC | _O_CREAT | _O_WRONLY, _S_IREAD | _S_IWRITE);

    if ((fileFrom != -1) && (fileTo != -1))
    {
        //Read the version...
        //===================
        char cVer;

        if (_read(fileFrom, &cVer, sizeof(char)) == sizeof(char))
        {
            //Reset the file position to the start
            //====================================
            if (_lseek(fileFrom, 0, SEEK_SET) != -1)
            {
                //Call the uncompress with the equivelant method which created
                //the compression
                //============================================================
                switch(cVer)
                {
                case 1:
                    bStatus = UncompressFileV1(fileFrom, fileTo);
                    break;
                case 0xFF:
                    //INVALID FILE!
                default:
                    //Unsupported version
                    break;
                }
            }
        }
    }

    //CLose the files
    //===============
    if (fileFrom != -1)
        _close(fileFrom);
    if (fileTo != -1)
        _close(fileTo);

    return bStatus;
}

BOOL CMRCICompression::UncompressFileV1(int hFileFrom, int hFileTo)
{
    BOOL bStatus = FALSE;
    unsigned char *pBufferFrom = NULL;
    unsigned char *pBufferTo   = NULL;

    //Read the header
    //===============
    CMRCICompressionHeaderV1 header;

    if (_read(hFileFrom, &header, sizeof(CMRCICompressionHeaderV1)) !=
        sizeof(CMRCICompressionHeaderV1))
        return FALSE;    

    //Allocate buffers.  The read buffer is never buffer than the write buffer
    //cos if it would have been we saved the uncompressed version!
    pBufferFrom = new unsigned char[header.dwReadBufferSize + 4];
    if (pBufferFrom == 0)
        return FALSE;

    pBufferTo   = new unsigned char[header.dwReadBufferSize + 4];

    if (pBufferTo == 0)
    {
        delete [] pBufferFrom;
        return FALSE;
    }

    bStatus = TRUE;

    while (1)
    {
        //Read the block header
        //=====================
        CMRCICompressionBlockV1 block;
        if (_read(hFileFrom, &block, sizeof(CMRCICompressionBlockV1)) !=
            sizeof(CMRCICompressionBlockV1))
        {
            bStatus = FALSE;
            break;
        }
            
        if (block.dwNextBufferSize == 0)
        {
            bStatus = TRUE;
            break;
        }
        
        //Read the block data
        //===================
        if (_read(hFileFrom, pBufferFrom, block.dwNextBufferSize) != (int)block.dwNextBufferSize)
        {
            bStatus = FALSE;
            break;
        }

        unsigned char *pWriteBuffer;
        unsigned cbChunk, cbUncompressed;

        //If this block was compressed
        //============================
        if (block.bCompressed)
        {
            //Uncompress the block
            //====================
            if ((cbUncompressed = UncompressBuffer(pBufferFrom, block.dwNextBufferSize, pBufferTo, block.dwUncompressedBufferSize, (CompressionLevel)header.compressionLevel)) == (unsigned) -1)
            {
                bStatus = FALSE;
                break;
            }
            pWriteBuffer = pBufferTo;
            cbChunk = cbUncompressed;
        }
        else
        {
            //Otherwise we use the existing block
            pWriteBuffer = pBufferFrom;
            cbChunk = block.dwNextBufferSize;
        }

        //Write the file data
        _write(hFileTo, pWriteBuffer, cbChunk);
    }

    //Sanity check the file.  It should be the same size as the original
    //compressed file
    if (_filelengthi64(hFileTo) != header.dwOriginalSize)
    {
        bStatus = FALSE;
    }

    //Tidy up
    delete [] pBufferFrom;
    delete [] pBufferTo;

    return bStatus;
}

unsigned  CMRCICompression::UncompressBuffer(unsigned char *pFromBuffer,
                                             DWORD dwFromBufferSize,
                                             unsigned char *pToBuffer,
                                             DWORD dwToBufferSize, 
                                             CompressionLevel compressionLevel)
{
    unsigned cbCompressed;
    if (compressionLevel == level1)
    {
        cbCompressed = Mrci1Decompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }
    else
    {
        cbCompressed = Mrci2Decompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }

    return cbCompressed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrcicode.cpp ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.CPP

Abstract:

    MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#include "precomp.h"
#include "mrcicode.h"                   /* prototype verification */

#ifndef NDEBUG
#define NDEBUG                          /* turn off assertions */
#endif
#include <assert.h>                     /* use NDEBUG to inhibit */


#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/*
 *  (compress) Reset the hash tables between blocks.
 */

void CBaseMrciCompression::inithash(void)
{
    unsigned *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

void CBaseMrciCompression::charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        throw 1;						/* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

void CBaseMrciCompression::putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

void CBaseMrciCompression::outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

void CBaseMrciCompression::mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

void CBaseMrciCompression::mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

void CBaseMrciCompression::mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

void CBaseMrciCompression::mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned CBaseMrciCompression::Mrci1MaxCompress(unsigned char *pchbase,unsigned cchunc,
        unsigned char *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char *pch;             /* Char pointer */
    unsigned char *pch2;            /* Char pointer */
    unsigned char *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

	try
	{
		cchbest = 0;                        /* no match yet */
		icur = 0;                           /* Initialize */

		for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
		{
			assert(cchbest == 0);           /* must always start with no match */

			if (cch > cchunc)
			{
				cch = cchunc;               /* limit to exact req count */
			}

			pchend = &pchbase[cch];         /* Remember end of buffer */

			while (icur < cch)              /* While at least two chars left */
			{
				/* update hash tables for this character */

				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */

				/* walk hash chain looking for matches */

				while (ilink < icur && icur - ilink <= DISPMAX)
				{                           /* While link is valid and in range */
					pch = &pchbase[icur];   /* Point at first byte */
					pch2 = &pchbase[ilink]; /* Point at first byte */

					if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
					{                       /* If we have a possible best match */
						pch += 2;           /* Skip first pair */
						pch2 += 2;          /* Skip first pair */

						while (pch <= pchend)  /* Loop to find end of match */
						{
							if (*pch != *pch2++)
							{
								break;      /* Break if mismatch */
							}
							pch++;          /* Skip matching character */
						}

						if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
						{                   /* If new best match */
							cchbest = cchmatch;  /* Remember length */
							ibest = ilink;  /* Remember position */

							assert((pch-1) <= pchend);

							if (pch > pchend)
							{
								break;      /* Break if we can't do any better */
							}
						}
					}

					assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
							(alink[ilink % MAXDISPBIG] < ilink));

					ilink = alink[ilink % MAXDISPBIG];
											/* Get next link */
				}   /* until end of hash chain reached */

				if (cchbest >= MINMATCH1)   /* If we have a string match */
				{
					mrci1outstring(icur - ibest,cchbest);
											/* Describe matching string */
	#ifdef VXD
					if (icur + cchbest >= cch )  /* If end of sector reached */
	#else
					if (icur + cchbest >= cchunc)  /* If end of buffer reached */
	#endif
					{
						icur += cchbest;    /* Advance the index */
						cchbest = 0;        /* reset for next match */
						break;              /* Done if buffer exhausted */
					}

					icur++;                 /* Skip to first unhashed pair */
	#ifdef VXD
					/* avoid re-seeding all of a big match */

					if (cchbest > MAXDISPSMALL)
					{                       /* If big match */
						icur += cchbest - MAXDISPSMALL - 1;
											/* Skip ahead */
						cchbest = MAXDISPSMALL + 1;
											/* Use shorter length */
					}
	#endif
					/* update hash tables for each add't char in string */

					ibest = icur % MAXDISPBIG;  /* Get current link table index */

					while (--cchbest != 0)  /* Loop to reseed link table */
					{
						ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
						ilink = ahash[ihash];  /* Get link index */
						ahash[ihash] = icur++;  /* Remember position */
						alink[ibest] = ilink;  /* Chain on rest of list */

						if (++ibest < MAXDISPBIG)
						{
							continue;       /* Loop if we haven't wrapped yet */
						}

						ibest = 0;          /* Wrap to zero */
					}

					assert(cchbest == 0);   /* Counter must be 0 */
				}
				else
				{
					mrci1outsingle(pchbase[icur++]);
											/* Else output single character */
					cchbest = 0;            /* Reset counter */
				}
			}

			assert(icur == cch || icur == cch + 1);
											/* Must be at or past last character */
			if (icur == cch)
			{
	#ifndef VXD
				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */
	#endif
				mrci1outsingle(pchbase[icur++]);  /* Output last character */
			}

			assert(icur == cch + 1);        /* Must be past last character */

			mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
		}

		if (cbitsleft != 8)
		{
			charbuf(abits);                 /* Flush bit buffer */
		}

		if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
		{
			return((unsigned) -1);          /* data expanded or not smaller */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned CBaseMrciCompression::Mrci2MaxCompress(unsigned char *pchbase,unsigned cchunc,
        unsigned char *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char *pch;             /* Char pointer */
    unsigned char *pch2;            /* Char pointer */
    unsigned char *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    try
	{
		cchbest = 0;                        /* no match yet */
		icur = 0;                           /* Initialize */

		for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
		{
			assert(cchbest == 0);           /* must always start with no match */

			if (cch > cchunc)
			{
				cch = cchunc;               /* limit to exact req count */
			}

			pchend = &pchbase[cch];         /* Remember end of buffer */

			while (icur < cch)              /* While at least two chars left */
			{
				/* update hash tables for this character */

				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */

				/* walk hash chain looking for matches */

				while (ilink < icur && icur - ilink <= DISPMAX)
				{                           /* While link is valid and in range */
					pch = &pchbase[icur];   /* Point at first byte */
					pch2 = &pchbase[ilink]; /* Point at first byte */

					if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
					{                       /* If we have a possible best match */
						pch += 2;           /* Skip first pair */
						pch2 += 2;          /* Skip first pair */

						while (pch <= pchend)  /* Loop to find end of match */
						{
							if (*pch != *pch2++)
							{
								break;      /* Break if mismatch */
							}
							pch++;          /* Skip matching character */
						}

						if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
						{                   /* If new best match */
							cchbest = cchmatch;  /* Remember length */
							ibest = ilink;  /* Remember position */

							assert((pch-1) <= pchend);

							if (pch > pchend)
							{
								break;      /* Break if we can't do any better */
							}
						}
					}

					assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
							(alink[ilink % MAXDISPBIG] < ilink));

					ilink = alink[ilink % MAXDISPBIG];
											/* Get next link */
				}   /* until end of hash chain reached */

				if (cchbest >= MINMATCH2)   /* If we have a string match */
				{
					mrci2outstring(icur - ibest,cchbest);
											/* Describe matching string */
	#ifdef VXD
					if (icur + cchbest >= cch )  /* If end of sector reached */
	#else
					if (icur + cchbest >= cchunc)  /* If end of buffer reached */
	#endif
					{
						icur += cchbest;    /* Advance the index */
						cchbest = 0;        /* reset for next match */
						break;              /* Done if buffer exhausted */
					}

					icur++;                 /* Skip to first unhashed pair */
	#ifdef VXD
					/* avoid re-seeding all of a big match */

					if (cchbest > MAXDISPSMALL)
					{                       /* If big match */
						icur += cchbest - MAXDISPSMALL - 1;
											/* Skip ahead */
						cchbest = MAXDISPSMALL + 1;
											/* Use shorter length */
					}
	#endif
					/* update hash tables for each add't char in string */

					ibest = icur % MAXDISPBIG;  /* Get current link table index */

					while (--cchbest != 0)  /* Loop to reseed link table */
					{
						ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
						ilink = ahash[ihash];  /* Get link index */
						ahash[ihash] = icur++;  /* Remember position */
						alink[ibest] = ilink;  /* Chain on rest of list */

						if (++ibest < MAXDISPBIG)
						{
							continue;       /* Loop if we haven't wrapped yet */
						}

						ibest = 0;          /* Wrap to zero */
					}

					assert(cchbest == 0);   /* Counter must be 0 */
				}
				else
				{
					mrci2outsingle(pchbase[icur++]);
											/* Else output single character */
					cchbest = 0;            /* Reset counter */
				}
			}

			assert(icur == cch || icur == cch + 1);
											/* Must be at or past last character */
			if (icur == cch)
			{
	#ifndef VXD
				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */
	#endif
				mrci2outsingle(pchbase[icur++]);  /* Output last character */
			}

			assert(icur == cch + 1);        /* Must be past last character */

			mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
		}

		if (cbitsleft != 8)
		{
			charbuf(abits);                 /* Flush bit buffer */
		}

		if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
		{
			return((unsigned) -1);          /* data expanded or not smaller */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

unsigned CBaseMrciCompression::getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            throw 1;					/* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

unsigned CBaseMrciCompression::getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    throw 1;			/* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

void CBaseMrciCompression::expandstring(unsigned char **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char *source;
    unsigned char *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned CBaseMrciCompression::Mrci1Decompress(unsigned char *pchin,unsigned cchin,
        unsigned char *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    try
	{
		for (;;)
		{
			b = getbits(2);                 /* get two bits */

			if (b == 1)                     /* If single byte 128..255 */
			{                               /* Get the rest of byte */
				*pchout++ = (unsigned char) (getbits(7) | 0x80);
				continue;                   /* Next token */
			}

			if (b == 2)                     /* If single byte 0..127 */
			{                               /* Get the rest of byte */
				*pchout++ = (unsigned char) getbits(7);
				continue;                   /* Next token */
			}

			if (b == 0)
			{
				disp = getbits(6) + MINDISPSMALL;
			}
			else  /* b == 3 */
			{
				if (getbit() == 0)
				{
					disp = getbits(8) + MINDISPMED;
				}
				else
				{
					disp = getbits(12) + MINDISPBIG;
				}
			}

			if (disp == MAXDISPBIG)
			{
				if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
				{
					break;                  /* End marker found */
				}
				else
				{
					continue;               /* End sector found */
				}
			}

			length = 0;                     /* Initialize */

			while (getbit() == 0)
			{
				length++;                   /* Count the leading zeroes */
			}

			assert(b <= 15);                /* Cannot be too big */

			if (length)
			{
				length = getbits(length) + (1 << length) + 1;
			}
			else
			{
				length = 2;
			}

			expandstring(&pchout,disp,length);  /* Copy the match */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned CBaseMrciCompression::Mrci2Decompress(unsigned char *pchin,unsigned cchin,
        unsigned char *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    try
	{
		for (;;)
		{
			if (getbit() == 0)              /* literal 00..7F */
			{
				*pchout++ = (unsigned char) getbits(7);

				continue;                   /* Next token */
			}

			if (getbit() == 1)              /* literal 80..FF */
			{
				*pchout++ = (unsigned char)(getbits(7) | 0x80);

				continue;                   /* Next token */
			}

			if (getbit() == 0)
			{
				disp = getbits(6) + MINDISPSMALL;
			}
			else
			{
				if (getbit() == 0)
				{
					disp = getbits(8) + MINDISPMED;
				}
				else
				{
					disp = getbits(12) + MINDISPBIG;
				}
			}

			if (disp == MAXDISPBIG)
			{
				if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
				{
					break;                  /* End marker found */
				}
				else
				{
					continue;               /* End sector found */
				}
			}

			length = 0;                     /* Initialize */

			while (getbit() == 0)
			{
				length++;                   /* Count the leading zeroes */
			}

			assert(length <= 15);           /* Cannot be too big */

			if (length)
			{
				length = getbits(length) + (1 << length) + 1;
			}
			else
			{
				length = 2;
			}

			expandstring(&pchout,disp,length + 1);  /* Copy the match */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\mkdir.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MKDIR.CPP

Abstract:

    Creates directories

History:

--*/
#include "precomp.h"

#include "corepol.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <mbstring.h>
#include <tchar.h>

class CTmpStrException
{
};

class TmpStr
{
private:
    TCHAR *pString;
public:
    TmpStr() : 
        pString(NULL)
    {
    }
    ~TmpStr() 
    { 
        delete [] pString; 
    }
    TmpStr &operator =(const TCHAR *szStr)
    {
        delete [] pString;
        pString = NULL;
        if (szStr)
        {
            pString = new TCHAR[lstrlen(szStr) + 1];
            
            if (!pString)
                throw CTmpStrException();

            lstrcpy(pString, szStr);
        }
        return *this;
    }
    operator const TCHAR *() const
    {
        return pString;
    }
    TCHAR Right(int i)
    {
        if (pString && (lstrlen(pString) >= i))
        {
            return pString[lstrlen(pString) - i];
        }
        else
        {
            return '\0';
        }
    }
    TmpStr &operator +=(const TCHAR ch)
    {
        if (pString)
        {
            TCHAR *tmpstr = new TCHAR[lstrlen(pString) + 2];
            
            if (!tmpstr)
                throw CTmpStrException();

            lstrcpy(tmpstr, pString);
            tmpstr[lstrlen(pString)] = ch;
            tmpstr[lstrlen(pString) + 1] = __TEXT('\0');

            delete [] pString;
            pString = tmpstr;
        }
        else
        {
            TCHAR *tmpstr = new TCHAR[2];

            if (!tmpstr)
                throw CTmpStrException();

            tmpstr[0] = ch;
            tmpstr[1] = __TEXT('\0');
            pString = tmpstr;
        }
        return *this;
    }
    TmpStr &operator +=(const TCHAR *sz)
    {
        if (sz && pString)
        {
            TCHAR *tmpstr = new TCHAR[lstrlen(pString) + lstrlen(sz) + 1];

            if (!tmpstr)
                throw CTmpStrException();

            lstrcpy(tmpstr, pString);
            lstrcat(tmpstr, sz);

            delete [] pString;
            pString = tmpstr;
        }
        else if (sz)
        {
            TCHAR *tmpstr = new TCHAR[lstrlen(sz) + 1];

            if (!tmpstr)
                throw CTmpStrException();

            lstrcpy(tmpstr, sz);
            pString = tmpstr;
        }
        return *this;
    }



};

BOOL POLARITY WbemCreateDirectory(const TCHAR *pszDirName)
{
    BOOL bStat = TRUE;
    TCHAR *pCurrent = NULL;
    TCHAR *pDirName = new TCHAR[lstrlen(pszDirName) + 1];

    if (!pDirName)
        return FALSE;

    lstrcpy(pDirName, pszDirName);

    try
    {
        TmpStr szDirName;
        pCurrent = _tcstok(pDirName, __TEXT("\\"));
        szDirName = pCurrent;

        while (pCurrent)
        {
            if ((pCurrent[lstrlen(pCurrent)-1] != ':') &&   //This is "<drive>:\\"
                (pCurrent[0] != __TEXT('\\')))  //There is double slash in name 
            {

                struct _stat stats;
                int dwstat = _tstat(szDirName, &stats);
                if ((dwstat == 0) &&
                    !(stats.st_mode & _S_IFDIR))
                {
                    bStat = FALSE;
                    break;
                }
                else if (dwstat == -1)
                {
                    DWORD dwStatus = GetLastError();
                    if (!CreateDirectory(szDirName, 0))
                    {
                        bStat = FALSE;
                        break;
                    }
                }
                // else it exists already
            }

            szDirName += __TEXT('\\');
            pCurrent = _tcstok(0, __TEXT("\\"));
            szDirName += pCurrent;
        }
    }
    catch(...)
    {
        bStat = FALSE;
    }

    delete [] pDirName;

    return bStat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\olewrap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.CPP

Abstract:

    Wrapper classes for COM data type functions.  

    If a COM data function is required to allocate memory and fails to do 
    so, then a CX_MemoryException exception is thrown.  All COM data type 
    functions are wrapped, regardless if they allocate memory, for the sake  
    of completeness.

History:

    a-dcrews    19-Mar-99   Created.

--*/

#include "precomp.h"
#include <corex.h>
#include <oleauto.h>

#include "OleWrap.h"
#include "genutils.h"

//***************************************************************************
//
//  SafeArray wrappers
//
//***************************************************************************


HRESULT COleAuto::_SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData)
{
    return SafeArrayAccessData(psa, ppvData);
}

HRESULT COleAuto::_SafeArrayAllocData(SAFEARRAY FAR* psa)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayAllocData(psa);
    return hRes;
}

HRESULT COleAuto::_SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY FAR* FAR* ppsaOut)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayAllocDescriptor(cDims, ppsaOut);
    return hRes;
}

HRESULT COleAuto::_SafeArrayCopy(SAFEARRAY FAR* psa, SAFEARRAY FAR* FAR* ppsaOut)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayCopy(psa, ppsaOut);
    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SafeArrayCopyData(SAFEARRAY FAR* psaSource, SAFEARRAY FAR* psaTarget)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayCopyData(psaSource, psaTarget);
    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

SAFEARRAY* COleAuto::_SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND FAR* rgsabound)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreate(vt, cDims, rgsabound);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}

SAFEARRAY* COleAuto::_SafeArrayCreateVector(VARTYPE vt, long lLbound, unsigned int cElements)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreateVector(vt, lLbound, cElements);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}

HRESULT COleAuto::_SafeArrayDestroy(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroy(psa);
}

HRESULT COleAuto::_SafeArrayDestroyData(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroyData(psa);
}

HRESULT COleAuto::_SafeArrayDestroyDescriptor(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroyDescriptor(psa);
}

UINT COleAuto::_SafeArrayGetDim(SAFEARRAY FAR* psa)
{
    return SafeArrayGetDim(psa);
}

HRESULT COleAuto::_SafeArrayGetElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayGetElement(psa, rgIndices, pv);
}

UINT COleAuto::_SafeArrayGetElemsize(SAFEARRAY FAR* psa)
{
    return SafeArrayGetElemsize(psa);
}

HRESULT COleAuto::_SafeArrayGetLBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plLbound)
{
    return SafeArrayGetLBound(psa, nDim, plLbound);
}

HRESULT COleAuto::_SafeArrayGetUBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plUbound)
{
    return SafeArrayGetUBound(psa, nDim, plUbound);
}

HRESULT COleAuto::_SafeArrayLock(SAFEARRAY FAR* psa)
{
    return SafeArrayLock(psa);
}

HRESULT COleAuto::_SafeArrayPtrOfIndex(SAFEARRAY FAR* psa, long FAR* rgIndices, void HUGEP* FAR* ppvData)
{
    return SafeArrayPtrOfIndex(psa, rgIndices, ppvData);
}

HRESULT COleAuto::_SafeArrayPutElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayPutElement(psa, rgIndices, pv);
}

HRESULT COleAuto::_SafeArrayRedim(SAFEARRAY FAR* psa, SAFEARRAYBOUND FAR* psaboundNew)
{
    return SafeArrayRedim(psa, psaboundNew);
}

HRESULT COleAuto::_SafeArrayUnaccessData(SAFEARRAY FAR* psa)
{
    return SafeArrayUnaccessData(psa);
}

HRESULT COleAuto::_SafeArrayUnlock(SAFEARRAY FAR* psa)
{
    return SafeArrayUnlock(psa);
}

//***************************************************************************
//
//  Variant wrappers
//
//***************************************************************************


HRESULT COleAuto::_WbemVariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, VARTYPE vt)
{
    HRESULT hRes = WbemVariantChangeType(pvargDest, pvarSrc, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeType(pvargDest, pvarSrc, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeTypeEx(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeTypeEx(pvargDest, pvarSrc, lcid, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantClear(VARIANTARG FAR* pvarg)
{
    return VariantClear(pvarg);
}

HRESULT COleAuto::_VariantCopy(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopy(pvargDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantCopyInd(VARIANT FAR* pvarDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopyInd(pvarDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

void COleAuto::_VariantInit(VARIANTARG FAR* pvarg)
{
    VariantInit(pvarg);
}


//***************************************************************************
//
//  BSTR wrappers
//
//***************************************************************************


BSTR COleAuto::_SysAllocString(const OLECHAR* sz)
{
    BSTR bstr = SysAllocString(sz);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringByteLen(LPCSTR psz, UINT len)
{
    BSTR bstr = SysAllocStringByteLen(psz, len);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringLen(const OLECHAR* pch, UINT cch)
{
    BSTR bstr = SysAllocStringLen(pch, cch);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

void COleAuto::_SysFreeString(BSTR bstr)
{
    SysFreeString(bstr);
}

HRESULT COleAuto::_SysReAllocString(BSTR* pbstr, const OLECHAR* sz)
{
    HRESULT hRes = SysReAllocString(pbstr, sz);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch)
{
    HRESULT hRes = SysReAllocStringLen(pbstr, pch, cch);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysStringByteLen(BSTR bstr)
{
    return SysStringByteLen(bstr);
}

HRESULT COleAuto::_SysStringLen(BSTR bstr)
{
    return SysStringLen(bstr);
}


//***************************************************************************
//
//  Conversion wrappers
//
//***************************************************************************


HRESULT COleAuto::_VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa)
{
    HRESULT hRes = VectorFromBstr(bstr, ppsa);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_BstrFromVector (SAFEARRAY *psa, BSTR *pbstr)
{
    HRESULT hRes = BstrFromVector(psa, pbstr);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrcicode.h ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.H

Abstract:

    MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#include <setjmp.h>
#include "corepol.h"

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

class POLARITY CBaseMrciCompression
{
public:
    unsigned int Mrci1MaxCompress(unsigned char *pchbase, unsigned int cchunc,
            unsigned char *pchcmpBase, unsigned int cchcmpMax);

    unsigned Mrci1Decompress(unsigned char *pchin, unsigned cchin,
            unsigned char *pchdecBase, unsigned cchdecMax);

    unsigned Mrci2MaxCompress(unsigned char *pchbase, unsigned cchunc,
            unsigned char *pchcmpBase, unsigned cchcmpMax);

    unsigned Mrci2Decompress(unsigned char *pchin, unsigned cchin,
            unsigned char *pchdecBase, unsigned cchdecMax);

private:
    /* compression internal functions */

    void inithash(void);
    void charbuf(unsigned c);
    void putbits(unsigned bits, unsigned cbits);
    void outlength(unsigned cb);

    void mrci1outsingle(unsigned ch);
    void mrci1outstring(unsigned disp, unsigned cb);

    void mrci2outsingle(unsigned ch);
    void mrci2outstring(unsigned disp, unsigned cb);


    /* decompression internal functions */

    unsigned getbit(void);
    unsigned getbits(unsigned cbits);
    void  expandstring(unsigned char **ppchout, unsigned disp, unsigned cb);

private:
    unsigned abits;                  /* Array of bits */
    unsigned cbitsleft;              /* Number of bits in abits */
    unsigned char *pCompressed;  /* pointer into compressed data */
    unsigned cCompressed;            /* # bytes remaining @ pCompressed */

    unsigned ahash[CHASH];    /* Hash table */
    unsigned alink[MAXDISPBIG];  /* Links */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrciclass.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MRCICLASS.H

Abstract:

    Wrapper class for MRCI 1 & MRCI 2 maxcompress 
   and decompress functions

History:

  paulall       1-Jul-97    Created

--*/

#include "MRCIcode.h"

#include "corepol.h"
#define DEFAULT_MRCI_BUFFER_SIZE (32*1024)

class POLARITY CMRCIControl
{
private:
    BOOL bStop;                                 //Do we need to abort compression...

public:
    CMRCIControl() : bStop(FALSE) {}            //Constructor
    void AbortCompression() { bStop = TRUE; }   //Abort the compression request
    BOOL AbortRequested() { return bStop; }     //Queries if an abort was requested
    void Reset() { bStop = FALSE; }             //Reset everything to the norm
};

class POLARITY CMRCICompression : public CBaseMrciCompression
{
public:
    enum CompressionLevel { level1 = 1, 
                            level2 = 2 };

    CMRCICompression();
    ~CMRCICompression();

    BOOL CompressFile(const TCHAR *pchFromFile, 
                      const TCHAR *pchToFile, 
                      DWORD dwBufferSize = DEFAULT_MRCI_BUFFER_SIZE, 
                      CompressionLevel compressionLevel = level1,
                      CMRCIControl *pControlObject = NULL);
    BOOL UncompressFile(const TCHAR *pchFromFile, const TCHAR *pchToFile);

    unsigned CompressBuffer(unsigned char *pFromBuffer,
                        DWORD dwFromBufferSize,
                        unsigned char *pToBuffer,
                        DWORD dwToBufferSize, 
                        CompressionLevel compressionLevel = level1);
    unsigned UncompressBuffer(unsigned char *pFromBuffer,
                          DWORD dwFromBufferSize,
                          unsigned char *pToBuffer,
                          DWORD dwToBufferSize, 
                          CompressionLevel compressionLevel = level1);

    static BOOL GetCompressedFileInfo(const TCHAR *pchFile, 
                    CompressionLevel &compressionLevel,
                    DWORD &dwReadBufferSize,
                    FILETIME &ftCreateTime,
                    __int64  &dwOriginalSize);
                        


protected:
    BOOL CompressFileV1(int hFileFrom, 
                        int hFileTo, 
                        DWORD dwBufferSize, 
                        CompressionLevel compressionLevel,
                        CMRCIControl *pControlObject);
    BOOL UncompressFileV1(int hFileFrom, int hFileTo);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\msgsig.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <ntsecapi.h>
#include <wbemcli.h>
#include "msgsig.h"

CSignMessage::CSignMessage() : m_bSign(FALSE), CUnk(NULL) { }

CSignMessage::CSignMessage( HCRYPTKEY hKey, HCRYPTHASH hProv ) 
: m_hKey( hKey ), m_hProv( hProv ), m_bSign( TRUE ), CUnk(NULL)
{

}

CSignMessage::~CSignMessage()
{
    if ( !m_bSign )
    {
        return;
    }

    CryptDestroyKey( m_hKey );
    CryptReleaseContext( m_hProv, 0 );
}

HRESULT CSignMessage::Sign( BYTE* pMsg, DWORD cMsg, BYTE* pSig, DWORD& rcSig )
{
    BOOL bRes;
    HCRYPTHASH hHash;
    
    if ( !m_bSign )
    {
        rcSig = 0;
        return S_OK;
    }

    HMAC_INFO hmac;
    ZeroMemory( &hmac, sizeof(HMAC_INFO) );
    hmac.HashAlgid = CALG_MD5;
  
    bRes = CryptCreateHash( m_hProv, CALG_HMAC, m_hKey, 0, &hHash );

    if ( !bRes )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    bRes = CryptSetHashParam( hHash, HP_HMAC_INFO, LPBYTE(&hmac), 0 );

    if ( !bRes )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    bRes = CryptHashData( hHash, pMsg, cMsg, 0 );    

    if ( !bRes )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    bRes = CryptGetHashParam( hHash, HP_HASHVAL, pSig, &rcSig, 0 );      

    if ( !bRes )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    CryptDestroyHash( hHash );

    return S_OK;
}

HRESULT CSignMessage::Verify( BYTE* pMsg, DWORD cMsg, BYTE* pSig, DWORD cSig )
{
    HRESULT hr;

    if ( !m_bSign )
    {
        return cSig == 0 ? S_OK : S_FALSE;
    }

    BYTE achCheckSig[256];
    DWORD cCheckSig = 256;

    hr = Sign( pMsg, cMsg, achCheckSig, cCheckSig );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( cSig != cCheckSig )
    {
        return S_FALSE;
    }

    return memcmp( achCheckSig, pSig, cSig ) == 0 ? S_OK : S_FALSE; 
}

#define PRIV_DATA_SZ 256

HRESULT CSignMessage::Create( LPCWSTR wszName, CSignMessage** ppSignMsg )
{
    BOOL bRes;
    HCRYPTHASH hHash;
    HCRYPTPROV hProv;
    HCRYPTKEY hKey;
    
    *ppSignMsg = NULL;

    //
    // First get OS version.  If win9x, no signing will actually be done.
    // Only thing keeping from doing win9x is we need a place to securely
    // store private data.  For NT, we use an LSA secret.
    //

    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bRes = GetVersionEx(&os);
    
    if ( !bRes )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( os.dwPlatformId != VER_PLATFORM_WIN32_NT )
    {
        *ppSignMsg = new CSignMessage();
        
        if ( *ppSignMsg == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        (*ppSignMsg)->AddRef();
        return S_OK;
    }

    //
    // Now obtain (or create) the secret data to derive private signing key
    //

    bRes = CryptAcquireContext( &hProv, 
                                NULL, 
                                NULL, 
		 	        PROV_RSA_FULL, 
                                CRYPT_VERIFYCONTEXT );
    if ( !bRes )
    {       
	return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // need to create a hash object.  This will be used for deriving 
    // keys for encryption/decryption. The hash object will be initialized
    // with the 'secret' random bytes.
    //

    bRes = CryptCreateHash( hProv, CALG_MD5, 0, 0, &hHash );

    if ( !bRes )
    {
        CryptReleaseContext( hProv, 0 );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Open lsa policy. This is where we store our 'secret' bytes.  
    //

    NTSTATUS stat;
    PLSA_UNICODE_STRING pPrivateData;
    LSA_OBJECT_ATTRIBUTES ObjectAttr;
    LSA_HANDLE hPolicy;

    ZeroMemory( &ObjectAttr, sizeof(LSA_OBJECT_ATTRIBUTES) );

    stat = LsaOpenPolicy( NULL, &ObjectAttr, POLICY_ALL_ACCESS, &hPolicy );

    if ( !NT_SUCCESS(stat) )
    {
        CryptDestroyHash( hHash );
        CryptReleaseContext( hProv, 0 );
        return stat;
    }

    //
    // now need to get Private Data, which is just stored random bytes. 
    //

    LSA_UNICODE_STRING PrivateKeyName;
    PrivateKeyName.Length = wcslen(wszName)*2;
    PrivateKeyName.MaximumLength = PrivateKeyName.Length + 2;
    PrivateKeyName.Buffer = (WCHAR*)wszName;

    stat = LsaRetrievePrivateData( hPolicy, 
                                   &PrivateKeyName, 
                                   &pPrivateData );
    if ( NT_SUCCESS(stat) )
    {
        //
        // we've obtained the private data, fill the hash obj with it.
        //

        bRes = CryptHashData( hHash, 
                              PBYTE(pPrivateData->Buffer), 
                              pPrivateData->Length, 
                              0 );
	if ( !bRes )
        {
            stat = GetLastError();
        }

        ZeroMemory( PBYTE(pPrivateData->Buffer), pPrivateData->Length );
        LsaFreeMemory( pPrivateData );
    }
    else if ( stat == STATUS_OBJECT_NAME_NOT_FOUND )
    {
        BYTE achPrivateData[PRIV_DATA_SZ];

        //
        // generate the private data and fill the hash obj with it.
        //
            
        if ( CryptGenRandom( hProv, PRIV_DATA_SZ, achPrivateData ) )
        {
            if ( CryptHashData( hHash, achPrivateData, PRIV_DATA_SZ, 0 ) )
            {
                //
                // now store the randomly generated bytes as private data ... 
                //
                
                LSA_UNICODE_STRING PrivateData;
                PrivateData.Length = PRIV_DATA_SZ;
                PrivateData.MaximumLength = PRIV_DATA_SZ;
                PrivateData.Buffer = (WCHAR*)achPrivateData;
                
                stat = LsaStorePrivateData( hPolicy, 
                                            &PrivateKeyName, 
                                            &PrivateData );
                 
                ZeroMemory( achPrivateData, sizeof(achPrivateData) );
            }
            else
            {
                stat = GetLastError();
            }
        }
        else
        {
            stat = GetLastError();
        }
    }

    LsaClose( hPolicy );
    
    if ( !NT_SUCCESS(stat) )
    {
        CryptDestroyHash( hHash );
        CryptReleaseContext( hProv, 0 );
        return HRESULT_FROM_WIN32( stat );
    }

    //
    // now derive the key from the hash object.  for MAC, key must use
    // RC2 with a CBC mode (default for RC2).
    //

    bRes = CryptDeriveKey( hProv, CALG_RC2, hHash, 0, &hKey );

    CryptDestroyHash( hHash );

    if ( !bRes )
    {
        CryptReleaseContext( hProv, 0 );
	return HRESULT_FROM_WIN32( GetLastError() );
    }
     
    //
    // we have successfully derived our private signing key.
    //
    
    *ppSignMsg = new CSignMessage( hKey, hProv );
    
    if ( *ppSignMsg == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    (*ppSignMsg)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\olewrap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.H

Abstract:

    Wrapper classes for COM data type functions.  

	If a COM data function is required to allocate memory and fails to do 
	so, then a CX_MemoryException exception is thrown.  All COM data type 
	functions are wrapped, regardless if they allocate memory, for the sake  
	of completeness.

History:

	a-dcrews	19-Mar-99	Created.

--*/

#ifndef _OLEWRAP_H_
#define _OLEWRAP_H_

class COleAuto
{
public:

	// Safe array methods
	// ==================

	static HRESULT _SafeArrayAccessData(SAFEARRAY* psa, void HUGEP** ppvData);
	static HRESULT _SafeArrayAllocData(SAFEARRAY* psa);
	static HRESULT _SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY** ppsaOut);
	static HRESULT _SafeArrayCopy(SAFEARRAY* psa, SAFEARRAY** ppsaOut);
	static HRESULT _SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget);
	static SAFEARRAY* _SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND* rgsabound);
	static SAFEARRAY* _SafeArrayCreateVector(VARTYPE vt, long lLbound, unsigned int cElements);
	static HRESULT _SafeArrayDestroy(SAFEARRAY* psa);
	static HRESULT _SafeArrayDestroyData(SAFEARRAY* psa);
	static HRESULT _SafeArrayDestroyDescriptor(SAFEARRAY* psa);
	static UINT _SafeArrayGetDim(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static UINT _SafeArrayGetElemsize(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetLBound(SAFEARRAY* psa, unsigned int nDim, long* plLbound);
	static HRESULT _SafeArrayGetUBound(SAFEARRAY* psa, unsigned int nDim, long* plUbound);
	static HRESULT _SafeArrayLock(SAFEARRAY* psa);
	static HRESULT _SafeArrayPtrOfIndex(SAFEARRAY* psa, long* rgIndices, void HUGEP** ppvData);
	static HRESULT _SafeArrayPutElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static HRESULT _SafeArrayRedim(SAFEARRAY* psa, SAFEARRAYBOUND* psaboundNew);
	static HRESULT _SafeArrayUnaccessData(SAFEARRAY* psa);
	static HRESULT _SafeArrayUnlock(SAFEARRAY* psa);

	// Variant methods
	// ===============

	static HRESULT _WbemVariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, VARTYPE vt);
	static HRESULT _VariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantChangeTypeEx(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantClear(VARIANTARG* pvarg);
	static HRESULT _VariantCopy(VARIANTARG* pvargDest, VARIANTARG* pvargSrc);
	static HRESULT _VariantCopyInd(VARIANT* pvarDest, VARIANTARG* pvargSrc);
	static void _VariantInit(VARIANTARG* pvarg);

	// BSTR methods
	// ============

	static BSTR _SysAllocString(const OLECHAR* sz);
	static BSTR _SysAllocStringByteLen(LPCSTR psz, UINT len);
	static BSTR _SysAllocStringLen(const OLECHAR* pch, UINT cch);
	static void _SysFreeString(BSTR bstr);
	static HRESULT _SysReAllocString(BSTR* pbstr, const OLECHAR* sz);
	static HRESULT _SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch);
	static HRESULT _SysStringByteLen(BSTR bstr);
	static HRESULT _SysStringLen(BSTR bstr);

	// Conversion methods
	// ==================

	static HRESULT _VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa);
	static HRESULT _BstrFromVector (SAFEARRAY *psa, BSTR *pbstr);
};

#endif	//_OLEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\objcache.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   objcache.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _OBJCACHE_H_
#define _OBJCACHE_H_

typedef __int64 SQL_ID;

#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#define NUM_BUCKETS 100
//***************************************************************************
//  CHashCache
//***************************************************************************

class POLARITY CListElement
{
public:

    CListElement() {};
    ~CListElement() {};

    void         *m_pObj;
    SQL_ID       m_dId;
};

#define CHASHCACHE_INLINED
#ifndef CHASHCACHE_INLINED
class POLARITY CHashCache 
{
    typedef std::map <SQL_ID, void *> CacheInfo;

public:
    CHashCache();
    ~CHashCache();

    HRESULT Insert(SQL_ID dId, void *pNew);
    HRESULT Delete(SQL_ID dId);
    bool    Exists (SQL_ID dId);
    HRESULT Get(SQL_ID dId, void **ppObj);
    HRESULT Empty();
    CListElement *FindFirst();
    CListElement *FindNext(SQL_ID dLast);

private:
    CacheInfo m_info;   
};

#else

class _WMILockit11
{	
public:
	_WMILockit11(CRITICAL_SECTION *pCS)
	{
		EnterCriticalSection(pCS);
        m_cs = pCS;
	}
	~_WMILockit11()
	{
		LeaveCriticalSection(m_cs);
	}
private:
    CRITICAL_SECTION *m_cs;
};


template <class T> 
class POLARITY CHashCache 
{
public:
    CHashCache();
    ~CHashCache();

    HRESULT Insert(SQL_ID dId, T pNew);
    HRESULT Delete(SQL_ID dId);
    bool    Exists (SQL_ID dId);
    HRESULT Get(SQL_ID dId, T *ppObj);
    HRESULT Empty();
    CListElement *FindFirst();
    CListElement *FindNext(SQL_ID dLast);

private:
    std::map <SQL_ID, T> m_info;   
    CRITICAL_SECTION m_cs;
};


//***************************************************************************
//
//  CHashCache::CHashCache
//
//***************************************************************************

template <class T>
CHashCache<T>::CHashCache()
{
    InitializeCriticalSection(&m_cs);

}
//***************************************************************************
//
//  CHashCache::~CHashCache
//
//***************************************************************************
template<class T>
CHashCache<T>::~CHashCache()
{
    Empty();
    DeleteCriticalSection(&m_cs);
}
//***************************************************************************
//
//  CHashCache::Insert
//
//***************************************************************************

template<class T>
HRESULT CHashCache<T>::Insert(SQL_ID dId, T pUnk)
{
    _WMILockit11 _Lk(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    T pTmp = m_info[dId];
    if (pTmp != pUnk)
        delete pTmp;

    m_info[dId] = pUnk;

    return hr;
}

//***************************************************************************
//
//  CHashCache::Delete
//
//***************************************************************************

template<class T>
HRESULT CHashCache<T>::Delete(SQL_ID dId)
{
    _WMILockit11 _Lk(&m_cs);
    
    HRESULT hr = WBEM_S_NO_ERROR;

    delete m_info[dId];
    m_info[dId] = NULL;
    std::map <SQL_ID, T>::iterator it = m_info.find(dId);
    if (it != m_info.end())
        m_info.erase(it);

    return hr;
}

//***************************************************************************
//
//  CHashCache::Exists
//
//***************************************************************************

template<class T>
bool CHashCache<T>::Exists (SQL_ID dId)
{
    _WMILockit11 _Lk(&m_cs);

    bool bRet = false;

    std::map <SQL_ID, T>::iterator it = m_info.find(dId);    
    if (it != m_info.end())
        bRet = true;

    return bRet;
}

//***************************************************************************
//
//  CHashCache::Get
//
//***************************************************************************

template<class T>
HRESULT CHashCache<T>::Get(SQL_ID dId, T *ppObj)
{
    _WMILockit11 _Lk(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    std::map <SQL_ID, T>::iterator it = m_info.find(dId);    
    if (it != m_info.end())
    {
        *ppObj = (*it).second;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CHashCache::FindFirst
//
//***************************************************************************

template<class T>
CListElement *CHashCache<T>::FindFirst()
{
    _WMILockit11 _Lk(&m_cs);
    CListElement *pRet = NULL;

    std::map <SQL_ID, T>::iterator it = m_info.begin();
    while (it != m_info.end())
    {
        if ((*it).second)
        {
            pRet = new CListElement;
            if (pRet)
            {
                pRet->m_dId = (*it).first;
                pRet->m_pObj = (*it).second;
            }
            break;
        }

        it++;
    }

    return pRet;   
}

//***************************************************************************
//
//  CHashCache::FindNext
//
//***************************************************************************

template<class T>
CListElement *CHashCache<T>::FindNext(SQL_ID dId)
{
    _WMILockit11 _Lk(&m_cs);
    CListElement *pRet = NULL;

    std::map <SQL_ID, T>::iterator it = m_info.find(dId);    

    if (it == m_info.end())
    {
        it = m_info.begin();
        while (it != m_info.end() && (*it).first < dId)
        {
            it++;
        }
    }

    if (it != m_info.end())
        it++;

    while (it != m_info.end())
    {
        if ((*it).second)
        {
            pRet = new CListElement;
            if (pRet)
            {
                pRet->m_dId = (*it).first;
                pRet->m_pObj = (*it).second;
            }
            break;
        }
        it++;
    }

    return pRet;
}

//***************************************************************************
//
//  CHashCache::Empty
//
//***************************************************************************

template<class T>
HRESULT CHashCache<T>::Empty()
{
    _WMILockit11 _Lk(&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    CListElement *pRet = NULL;

    std::map <SQL_ID, T>::iterator it = m_info.begin();
    while (it != m_info.end())
    {
        delete (*it).second;
        it++;
    }

    m_info.clear();

    return hr;
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\msgsig.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSGSIG_H__
#define __MSGSIG_H__

#include <unk.h>

class CSignMessage : public CUnk
{
    BOOL m_bSign;
    HCRYPTKEY m_hKey;
    HCRYPTPROV m_hProv;

    CSignMessage();
    CSignMessage( HCRYPTKEY hKey, HCRYPTPROV hProv );

    void* GetInterface( REFIID ) { return NULL; }

public:

    ~CSignMessage();

    HRESULT Sign( BYTE* achMsg, DWORD cMsg, BYTE* achSig, DWORD& cSig );
    HRESULT Verify( BYTE* achMsg, DWORD cMsg, BYTE* achSig, DWORD cSig );
    
    static HRESULT Create( LPCWSTR wszName, CSignMessage** ppSignMsg );  
};

#endif __MSGSIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\objcache.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   objcache.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _REPDRVR_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#define _WIN32_DCOM

#include "precomp.h"
#include <comutil.h>
#include <map>
#include <reposit.h>
#include <wbemcli.h>
#include <objcache.h>
#include <corepol.h>
#include <crc64.h>

#ifndef CHASHCACHE_INLINED
typedef std::map <SQL_ID, void *> CacheInfo;

CRITICAL_SECTION g_csCache;

class _WMILockit
{
public:
	_WMILockit();
	~_WMILockit();
};


_WMILockit::_WMILockit()
{
    EnterCriticalSection(&g_csCache);
}

_WMILockit::~_WMILockit()
{
    LeaveCriticalSection(&g_csCache);
}
    
//***************************************************************************
//
//  CHashCache::CHashCache
//
//***************************************************************************

CHashCache::CHashCache()
{
    if (!g_csCache.DebugInfo)
	    InitializeCriticalSection(&g_csCache);

}
//***************************************************************************
//
//  CHashCache::~CHashCache
//
//***************************************************************************
CHashCache::~CHashCache()
{
    Empty();
    if (!g_csCache.DebugInfo)
	    DeleteCriticalSection(&g_csCache);
}
//***************************************************************************
//
//  CHashCache::Insert
//
//***************************************************************************

HRESULT CHashCache::Insert(SQL_ID dId, void *pUnk)
{
    _WMILockit _Lk;

    HRESULT hr = WBEM_S_NO_ERROR;

    void *pTmp = m_info[dId];
    if (pTmp != pUnk)
        delete pTmp;

    m_info[dId] = pUnk;

    return hr;
}

//***************************************************************************
//
//  CHashCache::Delete
//
//***************************************************************************

HRESULT CHashCache::Delete(SQL_ID dId)
{
    _WMILockit _Lk;
    
    HRESULT hr = WBEM_S_NO_ERROR;

    delete m_info[dId];
    m_info[dId] = NULL;
    CacheInfo::iterator it = m_info.find(dId);
    if (it != m_info.end())
        m_info.erase(it);

    return hr;
}

//***************************************************************************
//
//  CHashCache::Exists
//
//***************************************************************************

bool CHashCache::Exists (SQL_ID dId)
{
    _WMILockit _Lk;

    bool bRet = false;

    CacheInfo::iterator it = m_info.find(dId);    
    if (it != m_info.end())
        bRet = true;

    return bRet;
}

//***************************************************************************
//
//  CHashCache::Get
//
//***************************************************************************

HRESULT CHashCache::Get(SQL_ID dId, void **ppObj)
{
    _WMILockit _Lk;

    HRESULT hr = WBEM_S_NO_ERROR;

    CacheInfo::iterator it = m_info.find(dId);    
    if (it != m_info.end())
    {
        *ppObj = (*it).second;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CHashCache::FindFirst
//
//***************************************************************************

CListElement *CHashCache::FindFirst()
{
    _WMILockit _Lk;
    CListElement *pRet = NULL;

    CacheInfo::iterator it = m_info.begin();
    while (it != m_info.end())
    {
        if ((*it).second)
        {
            pRet = new CListElement;
            if (pRet)
            {
                pRet->m_dId = (*it).first;
                pRet->m_pObj = (*it).second;
            }
            break;
        }

        it++;
    }

    return pRet;   
}

//***************************************************************************
//
//  CHashCache::FindNext
//
//***************************************************************************

CListElement *CHashCache::FindNext(SQL_ID dId)
{
    _WMILockit _Lk;
    CListElement *pRet = NULL;

    CacheInfo::iterator it = m_info.find(dId);    

    if (it == m_info.end())
    {
        it = m_info.begin();
        while ((*it).first < dId)
        {
            it++;
            if (it == m_info.end())
                break;
        }
    }

    if (it != m_info.end())
        it++;

    while (it != m_info.end())
    {
        if ((*it).second)
        {
            pRet = new CListElement;
            if (pRet)
            {
                pRet->m_dId = (*it).first;
                pRet->m_pObj = (*it).second;
            }
            break;
        }
        it++;
    }

    return pRet;
}

//***************************************************************************
//
//  CHashCache::Empty
//
//***************************************************************************

HRESULT CHashCache::Empty()
{
    _WMILockit _Lk;
    HRESULT hr = WBEM_S_NO_ERROR;

    m_info.clear();

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\parmdefs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

   PARMDEFS.H

Abstract:

  This file defines parameter modifier constants used throughout the system.
  These constants are defined to nothing and are used as reading aides only.

History:

  11/96   a-levn  Created.

--*/

#ifndef __PARMDEFS__H_
#define __PARMDEFS__H_

#define IN
#define OUT
#define OLE_MODIFY  // This object will be modified through the interface
#define MODIFY      // This object will be modified as a C++ object.
#define READ_ONLY   // This parameter is read-only
#define NEW_OBJECT  // New object will be returned in this parameter
#define RELEASE_ME  // The caller must release once the object is not needed.
#define DELETE_ME   // The caller must delete once the object is not needed.
#define SYSFREE_ME  // The caller must SysFreeString when no longer needed.
#define INTERNAL    // Internal pointer is returned. Do not delete. Lifetime
                    // is limited to that of the object.
#define COPY        // The function will make a copy of this object. The
                    // caller can do as it wishes with the original 
#define ACQUIRE     // The function acquires the pointer --- the caller may
                    // never delete it, the object will do it.
#define ADDREF      // This IN parameter is AddRef'ed by the function.
#define DELETE_IF_CHANGE // If the contents of this reference is changed by
                        // the caller, the old contents must be deleted
#define RELEASE_IF_CHANGE // If the contents of this reference is changed by
                        // the caller, the old contents must be Released
#define INIT_AND_CLEAR_ME  // This variant parameter must be VariantInit'ed
                            // by the caller before and VariantClear'ed after
#define STORE       // The function will store this pointer and assume that
                    // it will live long enough.

#define MODIFIED MODIFY
#define OLE_MODIFIED OLE_MODIFY
#define NOCS const  // This function does not acquire any resources
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\oahelp.inl ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OAHELP.INL

Abstract:

   OLE Automation Helpers for client code

History:

   raymcc  21-Jul-97

--*/

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { SetStr(pSrc);}
   ~CBSTR() { Clear(); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
    void Clear()  {if (m_pStr) SysFreeString(m_pStr);}
    void SetStr(LPWSTR pSrc) {m_pStr = SysAllocString(pSrc); }
};

class CVARIANT
{
	protected:
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\pathutl.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include "pathutl.h"

CRelativeObjectPath::CRelativeObjectPath()
: m_pPath(NULL), m_wszRelPath(NULL), m_Parser( e_ParserAcceptAll )
{

}

CRelativeObjectPath::~CRelativeObjectPath()
{
    delete m_wszRelPath;
 
    if ( m_pPath != NULL )
    {
        m_Parser.Free( m_pPath );
    }
}

LPCWSTR CRelativeObjectPath::GetPath( )
{
    assert( m_pPath != NULL );

    if ( m_wszRelPath != NULL )
    {
        return m_wszRelPath;
    }

    int nRes = m_Parser.Unparse( m_pPath, &m_wszRelPath );
    assert( nRes == CObjectPathParser::NoError );

    return m_wszRelPath;
}

BOOL CRelativeObjectPath::Parse( LPCWSTR wszPath )
{
    int nRes;

    // 
    // cannot save this relpath because it may not be normalized yet.
    //
    LPWSTR wszRelPath = CObjectPathParser::GetRelativePath( (LPWSTR)wszPath );

    if ( wszRelPath == NULL )
    {
        nRes = m_Parser.Parse( wszPath, &m_pPath );
    }
    else
    {
        nRes = m_Parser.Parse( wszRelPath, &m_pPath );
    }

    if ( nRes == CObjectPathParser::NoError )
    {
        if ( m_pPath->m_dwNumKeys == 1 )
        {
            delete m_pPath->m_paKeys[0]->m_pName;
            m_pPath->m_paKeys[0]->m_pName = NULL;
        }
        return TRUE;
    }

    return FALSE;
}

BOOL CRelativeObjectPath::operator==( CRelativeObjectPath& rOther )
{
    LPCWSTR wszRelPathA = GetPath();
    LPCWSTR wszRelPathB = rOther.GetPath();

    assert( wszRelPathA != NULL ); 
    assert( wszRelPathB != NULL );

    if (!wszRelPathA || !wszRelPathB)
        return FALSE;

    return _wcsicmp( wszRelPathA, wszRelPathB ) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\pathutl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef __PATHUTL_H__
#define __PATHUTL_H__

#include <genlex.h>
#include <objpath.h>

class CRelativeObjectPath
{
    CObjectPathParser m_Parser;
    LPWSTR m_wszRelPath;

    CRelativeObjectPath( const CRelativeObjectPath& );
    CRelativeObjectPath& operator=( const CRelativeObjectPath& );
    
public:
    
    ParsedObjectPath* m_pPath;

    CRelativeObjectPath();
    ~CRelativeObjectPath();

    BOOL Parse( LPCWSTR wszPath );

    BOOL operator== ( CRelativeObjectPath& rPath );
    LPCWSTR GetPath();
};

#endif // __PATHUTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\perfhelp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PERFHELP.H

Abstract:

History:

--*/

#ifndef __HOWLONG__H_
#define __HOWLONG__H_

#include <wbemutil.h>
class CHowLong
{
protected:
    DWORD m_dwStart;
    LPWSTR m_wszText1;
    LPWSTR m_wszText2;
    int m_n;

public:
    CHowLong(LPWSTR wszText1 = L"", LPWSTR wszText2 = L"", int n = 0)
        : m_wszText1(wszText1), m_wszText2(wszText2), m_n(n)
    {
        m_dwStart = GetTickCount();
    }
    ~CHowLong()
    {
        DEBUGTRACE((LOG_WBEMCORE,"%S (%S, %d) took %dms\n", m_wszText1, m_wszText2, m_n, 
            GetTickCount() - m_dwStart));
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "corepol.h"

#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\provinit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVINIT.H

Abstract:

  This file implements the provider init sink

History:

--*/

#ifndef __WBEM_PROVINIT__H_
#define __WBEM_PROVINIT__H_

class POLARITY CProviderInitSink : public IWbemProviderInitSink
{
protected:
    CCritSec m_cs;
    long m_lRef;
    long m_lStatus;
    HANDLE m_hEvent;

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT STDMETHODCALLTYPE SetStatus(long lStatus, long lFlags);

public:
    CProviderInitSink();
    ~CProviderInitSink();

    HRESULT WaitForCompletion();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\persistcfg.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PERSISTCFG.H

Abstract:

  This file implements the WinMgmt persistent configuration operations. 

  Classes implemented: 
      CPersistentConfig      persistent configuration manager

History:

  1/13/98       paulall     Created.

--*/

#ifndef _persistcfg_h_
#define _persistcfg_h_

#include "corepol.h"
#include "sync.h"
//****** UPDATE PERSIST_CFGVAL_MAX_NUM_EVENTS *******
//              WHEN ADDING A NEW VALUE
//****** UPDATE PERSIST_CFGVAL_MAX_NUM_EVENTS *******
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
#define PERSIST_CFGVAL_CORE_DATABASE_DIRTY      0
#define PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING   1
#define PERSIST_CFGVAL_CORE_NEEDSBACKUPCHECK    2
#define PERSIST_CFGVAL_CORE_FSREP_VERSION		3
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//****** UPDATE PERSIST_CFGVAL_MAX_NUM_EVENTS *******
//              WHEN ADDING A NEW VALUE
//****** UPDATE PERSIST_CFGVAL_MAX_NUM_EVENTS *******
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
#define PERSIST_CFGVAL_MAX_NUM_EVENTS           4
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//****** UPDATE PERSIST_CFGVAL_MAX_NUM_EVENTS *******
//              WHEN ADDING A NEW VALUE
//****** UPDATE PERSIST_CFGVAL_MAX_NUM_EVENTS *******

class CDirectoryPath
{
    TCHAR *pszDirectory ;
public:
    CDirectoryPath();

    ~CDirectoryPath(){if(pszDirectory) delete pszDirectory;};
    TCHAR * GetStr(void){return pszDirectory;};
};

/*=============================================================================
 *
 * class CPersistentConfig
 *
 * Retrieves and stores persistent configuration in the $WinMgmt.CFG file.
 * All writes are going to be committed to disk by the return of the
 * operation. 
 *=============================================================================
 */
#pragma warning (disable : 4251)

class POLARITY CPersistentConfig
{
public:
    //Number of items in the config array.  Requesting/setting values
    //outside this range will fail the operation.
    enum { MaxNumberConfigEntries = PERSIST_CFGVAL_MAX_NUM_EVENTS };

    //Constructor.  Initialises the structure.
    CPersistentConfig();

    //Retrieves the configuration from the configuration file if it
    //has not yet been retrieved into memory, or retrieves it from a 
    //memory cache.
    // dwOffset needs to be less than MaxNumberConfigEntries and specifies
    //          the configuration entry required.
    // dwValue  if sucessful this will contain the value.  If the value
    //          has not been set this will return 0.
    // BOOL     returns TRUE if successful.
    BOOL GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue);

    //Stores the value into the configuration file and to the 
    //memory cache if it exists.  The replacment of the original
    //file (if it exists) is the last thing it does.
    //  dwOffset    needs to be less than MaxNumberConfigEntries and specifies
    //          the configuration entry required.
    //  dwValue is the value to set the configuration to.
    //  BOOL        returns TRUE if successful.
    BOOL SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue);

    //Should be called once at startup to make sure the configuration files are
    //in a stable state.
    void CPersistentConfig::TidyUp();

protected:

    //Reads the $WinMgmt.CFG file into the memory cache.
    //  BOOL        returns TRUE if successful.
    BOOL ReadConfig();

    //Writes the $WinMgmt.CFG file into the memory cache and to the file.  It
    //protects the existing file until the last minute.
    //  BOOL        returns TRUE if successful.
    BOOL WriteConfig();

private:
    //This is the memory cache of the configuration.
    static DWORD m_ConfigValues[PERSIST_CFGVAL_MAX_NUM_EVENTS];
    static bool m_bInitialized;
    //Directory of persistent date

    static CDirectoryPath m_Directory ;

    static CCritSec m_cs;

    //Returns a filename with a full DB path prepended to the 
    //specified filename.  Need to delete[] the string returned.
    TCHAR *GetFullFilename(const TCHAR *pszFilename);
    
    //Returns TRUE if the file exists, FALSE otherwise (or if an error
    //occurs while opening the file.
    BOOL FileExists(const TCHAR *pszFilename);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\persistcfg.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PERSISTCFG.cpp

Abstract:

  This file implements the WinMgmt persistent configuration operations. 

  Classes implemented: 
      CPersistentConfig      persistent configuration manager

History:

  1/13/98       paulall     Created.

--*/

#include "precomp.h"
#include <memory.h>
#include <stdio.h>
#include "PersistCfg.h"
#include "reg.h"

#define WinMgmt_CFG_ACTUAL  __TEXT("$WinMgmt.CFG")
#define WinMgmt_CFG_PENDING __TEXT("$WinMgmt.$FG")
#define WinMgmt_CFG_BACKUP  __TEXT("$WinMgmt.CFG.BAK")

CCritSec CPersistentConfig::m_cs;
bool CPersistentConfig::m_bInitialized = false;
CDirectoryPath CPersistentConfig::m_Directory;
DWORD CPersistentConfig::m_ConfigValues[PERSIST_CFGVAL_MAX_NUM_EVENTS];


/*=============================================================================
 *  Constructor.  Initialises the structure.
 *=============================================================================
 */
CPersistentConfig::CPersistentConfig()
{
    EnterCriticalSection(&m_cs);
    if((m_bInitialized == false) && (m_Directory.GetStr()))
    {
        memset(m_ConfigValues, 0, sizeof(DWORD) * MaxNumberConfigEntries);
        ReadConfig();
        m_bInitialized = true;
    }
    LeaveCriticalSection(&m_cs);
}

/*=============================================================================
 *  GetPersistentCfgValue
 *
 *  Retrieves the configuration from the configuration file if it
 *  has not yet been retrieved into memory, or retrieves it from a 
 *  memory cache.
 *
 *  Parameters:
 *      dwOffset    needs to be less than MaxNumberConfigEntries and specifies
 *                  the configuration entry required.
 *      dwValue     if sucessful this will contain the value.  If the value
 *                  has not been set this will return 0.
 *
 *  Return value:
 *      BOOL        returns TRUE if successful.
 *=============================================================================
 */
BOOL CPersistentConfig::GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue)
{
    if (dwOffset >= MaxNumberConfigEntries)
        return FALSE;

    EnterCriticalSection(&m_cs);

    dwValue = m_ConfigValues[dwOffset];

    LeaveCriticalSection(&m_cs);

    return TRUE;
}

/*=============================================================================
 *  SetPersistentCfgValue
 *
 *  Stores the value into the configuration file and to the 
 *  memory cache if it exists.  The replacment of the original
 *  file (if it exists) is the last thing it does.
 *
 *  Parameters:
 *      dwOffset    needs to be less than MaxNumberConfigEntries and specifies
 *                  the configuration entry required.
 *      dwValue     is the value to set the configuration to.
 *
 *  return value:
 *      BOOL        returns TRUE if successful.
 *=============================================================================
 */
BOOL CPersistentConfig::SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue)
{
    if (dwOffset >= MaxNumberConfigEntries)
        return FALSE;

    EnterCriticalSection(&m_cs);

    //Do a check to make sure this is not what it is already set to.  If it
    //is we do nothing.  The write operation is slow!  We do not want to do
    //unnecessary writes.
    DWORD dwCurValue;
    GetPersistentCfgValue(dwOffset, dwCurValue);
    if (dwValue == dwCurValue)
    {
        LeaveCriticalSection(&m_cs);
        return TRUE;
    }

    m_ConfigValues[dwOffset] = dwValue;

    BOOL bRet = WriteConfig();

    LeaveCriticalSection(&m_cs);

    return bRet;
}

/*=============================================================================
 *  CDirectoryPath::CDirectoryPath
 *
 *  Initialised the directory path
 *
 *=============================================================================
 */
CDirectoryPath::CDirectoryPath()
{
    Registry r(WBEM_REG_WINMGMT);
    Registry r1(WBEM_REG_WBEM);
    if (r.GetStr(__TEXT("Repository Directory"), &pszDirectory))
    {
        TCHAR *pszWorkDir = NULL;
        if (r1.GetStr(__TEXT("Installation Directory"), &pszWorkDir))
        {
            pszDirectory = NULL;
            return;
        }        
        pszDirectory = new TCHAR [lstrlen(pszWorkDir) + lstrlen(__TEXT("\\Repository")) +1];
        if (pszDirectory)
        {
            wsprintf(pszDirectory, __TEXT("%s\\REPOSITORY"), pszWorkDir); 

            r.SetStr(__TEXT("Repository Directory"), pszDirectory);
        }
        
        delete [] pszWorkDir;
    }
}

/*=============================================================================
 *  ReadConfig
 *
 *  Reads the $WinMgmt.CFG file into the memory cache
 *
 *  return value:
 *      BOOL        returns TRUE if successful.
 *=============================================================================
 */
BOOL CPersistentConfig::ReadConfig()
{
    //Try and read the file if it exists, otherwise it does not matter, we just 
    //return.
    TCHAR *pszFilename;
    pszFilename = GetFullFilename(WinMgmt_CFG_ACTUAL);

    HANDLE hFile = CreateFile(pszFilename,  //Name of file
                                GENERIC_READ,   //Read only at
                                0,              //Don't need to allow anyone else in
                                0,              //Shouldn't need security
                                OPEN_EXISTING,  //Only open the file if it exists
                                0,              //No attributes needed
                                0);             //No template file required
    BOOL   bRet = FALSE;

    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwNumBytesRead;
        
        bRet =
            ReadFile(hFile, 
                     m_ConfigValues, 
                     sizeof(DWORD) * MaxNumberConfigEntries, 
                     &dwNumBytesRead, 
                     NULL);

        CloseHandle(hFile);
    }

    if (pszFilename)
        delete [] pszFilename;

    return bRet;
}

/*=============================================================================
 *  WriteConfig
 *
 *  Writes the $WinMgmt.CFG file into the memory cache and to the file.  It
 *  protects the existing file until the last minute.
 *
 *  return value:
 *      BOOL        returns TRUE if successful.
 *=============================================================================
 */
BOOL CPersistentConfig::WriteConfig()
{
    TCHAR *pszActual = GetFullFilename(WinMgmt_CFG_ACTUAL);
    TCHAR *pszPending = GetFullFilename(WinMgmt_CFG_PENDING);
    TCHAR *pszBackup = GetFullFilename(WinMgmt_CFG_BACKUP);

    //Create a new file to write to...
    HANDLE hFile = CreateFile(pszPending,       //Name of file
                                GENERIC_WRITE,  //Write only 
                                0,              //Don't need to allow anyone else in
                                0,              //Shouldn't need security
                                CREATE_ALWAYS,  //Always create a new file
                                0,              //No attributes needed
                                0);             //No template file required

    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwNumBytesWritten;
        if (!WriteFile(hFile, 
                       m_ConfigValues, 
                       sizeof(DWORD) * MaxNumberConfigEntries, 
                       &dwNumBytesWritten, 
                       NULL) || 
            (dwNumBytesWritten != (sizeof(DWORD) * MaxNumberConfigEntries)))
        {
            //OK, this failed!!!
            CloseHandle(hFile);

            //Delete the file...
            DeleteFile(pszPending);

            delete [] pszPending;
            delete [] pszActual;
            delete [] pszBackup;

            return FALSE;
        }

        //Make sure it really is flushed to the disk
        FlushFileBuffers(hFile);

        CloseHandle(hFile);

        //Rename the existing file
        DeleteFile(pszBackup);
        MoveFile(pszActual, pszBackup);

        //Move the new file here
        MoveFile(pszPending, pszActual);

        //Delete the old file
        DeleteFile(pszBackup);

        delete [] pszPending;
        delete [] pszActual;
        delete [] pszBackup;

        return TRUE;
    }
    delete [] pszPending;
    delete [] pszActual;
    delete [] pszBackup;
    return FALSE;
}

TCHAR *CPersistentConfig::GetFullFilename(const TCHAR *pszFilename)
{
    TCHAR *pszPathFilename = new TCHAR[lstrlen(m_Directory.GetStr()) + lstrlen(pszFilename) + 2];
    
    if (pszPathFilename)
    {
        lstrcpy(pszPathFilename, m_Directory.GetStr());
        if ((lstrlen(pszPathFilename)) && (pszPathFilename[lstrlen(pszPathFilename)-1] != __TEXT('\\')))
        {
            lstrcat(pszPathFilename, __TEXT("\\"));
        }
        lstrcat(pszPathFilename, pszFilename);
    }

    return pszPathFilename;
}

void CPersistentConfig::TidyUp()
{
    //Recover the configuration file.
    //-------------------------------
    TCHAR *pszOriginalFile = GetFullFilename(WinMgmt_CFG_ACTUAL);
    TCHAR *pszPendingFile = GetFullFilename(WinMgmt_CFG_PENDING);
    TCHAR *pszBackupFile = GetFullFilename(WinMgmt_CFG_BACKUP);

    if (FileExists(pszOriginalFile))
    {
        if (FileExists(pszPendingFile))
        {
            if (FileExists(pszBackupFile))
            {
                //BAD - Unexpected situation.
                DeleteFile(pszPendingFile);
                DeleteFile(pszBackupFile);
                //Back to the point where the interrupted operation did not 
                //happen
            }
            else
            {
                //Pending file with original file means we cannot guarentee
                //the integrety of the pending file so the last operation
                //will be lost.
                DeleteFile(pszPendingFile);
                //Back to the point where the interrupted operation did not 
                //happen
            }
        }
        else
        {
            if (FileExists(pszBackupFile))
            {
                //Means we successfully copied the pending file to the original
                DeleteFile(pszBackupFile);
                //Everything is now normal.  Interrupted Operation completed!
            }
            else
            {
                //Nothing out of the ordinary here.
            }
        }
    }
    else
    {
        if (FileExists(pszPendingFile))
        {
            if (FileExists(pszBackupFile))
            {
                //This is an expected behaviour at the point we have renamed
                //the original file to the backup file.
                MoveFile(pszPendingFile, pszOriginalFile);
                DeleteFile(pszBackupFile);
                //Everything is now normal.  Interrupted operation completed!
            }
            else
            {
                //BAD - Unexpected situation.
                DeleteFile(pszPendingFile);
                //There are now no files!  Operation did not take place
                //and there are now no files left.  This should be a
                //recoverable scenario!
            }
        }
        else
        {
            if (FileExists(pszBackupFile))
            {
                //BAD - Unexpected situation.
                DeleteFile(pszBackupFile);
                //There are now no files!  Operation did not take place
                //and there are now no files left.  This should be a
                //recoverable scenario!
            }
            else
            {
                //May be BAD!  There are no files!  This should be a
                //recoverable scenario!
            }
        }
    }

    delete [] pszOriginalFile;
    delete [] pszPendingFile;
    delete [] pszBackupFile;
}

//*****************************************************************************
//
//  FileExists()
//
//  Returns TRUE if the file exists, FALSE otherwise (or if an error
//  occurs while opening the file.
//*****************************************************************************
BOOL CPersistentConfig::FileExists(const TCHAR *pszFilename)
{
    BOOL bExists = FALSE;
    HANDLE hFile = CreateFile(pszFilename, 0, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        bExists = TRUE;
        CloseHandle(hFile);
    }
    else
    {
        //If the file does not exist we should have a LastError of ERROR_NOT_FOUND
        DWORD dwError = GetLastError();
        if (dwError != ERROR_FILE_NOT_FOUND)
        {
//          DEBUGTRACE((LOG_WBEMCORE,"File %s could not be opened for a reason other than not existing\n", pszFilename));
        }
    }
    return bExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\qllex.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    QLLEX.CPP

Abstract:

    QL Level 1 DFA Table

History:

    raymcc    24-Jun-95       Created.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>             

#define ST_STRING       24
#define ST_IDENT        29
#define ST_GE           35
#define ST_LE           37
#define ST_NE           40
#define ST_NUMERIC      42
#define ST_REAL         47
#define ST_STRING2      53
#define ST_STRING_ESC   58
#define ST_STRING2_ESC  61   
#define ST_DOT          64
#define ST_NEGATIVE_NUM 66
#define ST_POSITIVE_NUM 69

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  QL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA, GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,               GLEX_CONSUME,

    // Unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 24 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 26 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 27 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 28 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 29 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 35 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 37 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 38 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 40 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 41 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 42 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 43 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 44 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 45 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 49 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 50 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 53 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 54 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 55 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 56 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 57 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 58 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 61 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 62 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 63 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 64 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 65 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 66 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 67 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 68 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 69 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 70 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 71 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\ql.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QL.H

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    a-raymcc, a-tomasp    21-Jun-96       Created.

--*/

#ifndef _QL__H_
#define _QL__H_
#include <wbemidl.h>
#include <wbemint.h>
#include <qllex.h>
#include <corepol.h>
#include <parmdefs.h>
#include <stdio.h>

class POLARITY CPropertyName : public WBEM_PROPERTY_NAME
{
protected:
    long m_lAllocated;
    void* m_pvHandle;
    void EnsureAllocated(long lElements);
public:
    void Init();
    CPropertyName() {Init();}
    CPropertyName(const CPropertyName& Other);
    void operator=(const CPropertyName& Other);
    void operator=(const WBEM_PROPERTY_NAME& Other);
    BOOL operator==(const WBEM_PROPERTY_NAME& Other);

    void Empty();
    ~CPropertyName() {Empty();}

    long GetNumElements() const {return m_lNumElements;}
    LPCWSTR GetStringAt(long lIndex) const;
    void AddElement(LPCWSTR wszElement);
    DELETE_ME LPWSTR GetText();

    //
    // for convienience, a prop handle can be stored with this struct. example
    // of such a handle is the one used for fast access to properties on wbem
    // class objects. The handle is not used in any way by this implementation 
    // but will be treated as a regular member var in that it will be nulled,
    // copied, etc.. 
    //
    void* GetHandle() { return m_pvHandle; }
    void SetHandle( void* pvHandle ) { m_pvHandle = pvHandle; }
};

class POLARITY CQl1ParseSink
{
public:
    virtual void SetClassName(LPCWSTR wszClass) = 0;
    virtual void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance) = 0;
    virtual void AddToken(const WBEM_QL1_TOKEN& Token) = 0;
    virtual void AddProperty(const CPropertyName& Property) = 0;
    virtual void AddAllProperties() = 0;
    virtual void SetCountQuery() = 0;
    virtual void SetAggregated() = 0;
    virtual void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance)= 0;
    virtual void AddAggregationProperty(const CPropertyName& Property) = 0;
    virtual void AddAllAggregationProperties() = 0;
    virtual void AddHavingToken(const WBEM_QL1_TOKEN& Token) = 0;

    virtual void InOrder(long lOp){}
};

class POLARITY CAbstractQl1Parser
{
protected:
    // Controls keyword parsing in Next().
    // ===================================
    enum { 
        NO_KEYWORDS = 0,
        ALL_KEYWORDS,
        EXCLUDE_GROUP_KEYWORD,
        EXCLUDE_EXPRESSION_KEYWORDS
        };

    CQl1ParseSink* m_pSink;
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    BOOL       m_bQuoted;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    CPropertyName m_PropertyName;
    BOOL       m_bInAggregation;
    CPropertyName m_PropertyName2;
    BOOL       m_bPropComp;
        
    // Parsing functions.
    // ==================
    virtual BOOL Next(int nFlags = ALL_KEYWORDS);
    LPCWSTR GetSinglePropertyName();
    void DeletePropertyName();
    int FlipOperator(int nOp);
    void AddAppropriateToken(const WBEM_QL1_TOKEN& Token);

    int parse_property_name(CPropertyName& Prop);
    
    int parse(int nFlags);

    int prop_list();
    int class_name();
    int tolerance();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int trailing_ident_expr();
    int unknown_func_expr();
    int typed_constant();
    int opt_aggregation();
    int aggregation_params();
    int aggregate_by();
    int aggregate_within();
    int opt_having();

    static DWORD TranslateIntrinsic(LPCWSTR pFuncName);
    static void InitToken(WBEM_QL1_TOKEN* pToken);
public:
    enum { 
        SUCCESS = 0,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        OUT_OF_MEMORY
        };

    enum {
        FULL_PARSE = 0,
        NO_WHERE,
        JUST_WHERE
    };

    CAbstractQl1Parser(CGenLexSource *pSrc);
    virtual ~CAbstractQl1Parser();

    int Parse(CQl1ParseSink* pSink, int nFlags);
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
};



struct POLARITY QL_LEVEL_1_TOKEN
{
    enum 
    { 
        OP_EXPRESSION = QL1_OP_EXPRESSION, 
        TOKEN_AND = QL1_AND, 
        TOKEN_OR = QL1_OR, 
        TOKEN_NOT = QL1_NOT
    };
    enum 
    { 
        IFUNC_NONE = QL1_FUNCTION_NONE, 
        IFUNC_UPPER = QL1_FUNCTION_UPPER, 
        IFUNC_LOWER = QL1_FUNCTION_LOWER 
    };    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum 
    { 
        OP_EQUAL = QL1_OPERATOR_EQUALS, 
        OP_NOT_EQUAL = QL1_OPERATOR_NOTEQUALS, 
        OP_EQUALorGREATERTHAN = QL1_OPERATOR_GREATEROREQUALS,
        OP_EQUALorLESSTHAN = QL1_OPERATOR_LESSOREQUALS, 
        OP_LESSTHAN = QL1_OPERATOR_LESS, 
        OP_GREATERTHAN = QL1_OPERATOR_GREATER, 
        OP_LIKE  = QL1_OPERATOR_LIKE,
        OP_UNLIKE  = QL1_OPERATOR_UNLIKE
    };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    CPropertyName PropertyName;  
                   // Name of the property on which the operator is applied
    int     nOperator;      // Operator that is applied on property
    VARIANT vConstValue;    // Value applied by operator
    BOOL bQuoted; // FALSE if the string should not have quotes around it.

    CPropertyName PropertyName2; // Property to compare, if applicable.
    BOOL m_bPropComp;        // TRUE if this is a property-to-property compare.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "

    QL_LEVEL_1_TOKEN();
    QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN&);
   ~QL_LEVEL_1_TOKEN(); 
    QL_LEVEL_1_TOKEN& operator=(const QL_LEVEL_1_TOKEN &Src);
    QL_LEVEL_1_TOKEN& operator=(const WBEM_QL1_TOKEN &Src);
    
    void Dump(FILE *);
    DELETE_ME LPWSTR GetText();
};


// Contains RPN version of expression.
// ===================================

struct POLARITY QL_LEVEL_1_RPN_EXPRESSION : public CQl1ParseSink
{
    int nNumTokens;
    int nCurSize;
    QL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;
    WBEM_QL1_TOLERANCE Tolerance;

    int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
    BOOL bStar;
    CPropertyName *pRequestedPropertyNames;  
                // Array of property names which values are to be returned if
    
    BOOL bAggregated;
    BOOL bCount;
    WBEM_QL1_TOLERANCE AggregationTolerance;
    BOOL bAggregateAll;
    int nNumAggregatedProperties;   
    int nCurAggPropSize;
    CPropertyName *pAggregatedPropertyNames;  

    int nNumHavingTokens;
    int nCurHavingSize;
    QL_LEVEL_1_TOKEN *pArrayOfHavingTokens;
    
    long lRefCount;

    QL_LEVEL_1_RPN_EXPRESSION();
    QL_LEVEL_1_RPN_EXPRESSION(const QL_LEVEL_1_RPN_EXPRESSION& Other);
   ~QL_LEVEL_1_RPN_EXPRESSION();    
    void AddRef();
    void Release();

    void SetClassName(LPCWSTR wszName);
    void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddToken(const WBEM_QL1_TOKEN& Tok);
    void AddToken(const QL_LEVEL_1_TOKEN& Tok);
    void AddProperty(const CPropertyName& Prop);
    void AddAllProperties();
    void SetCountQuery();

    void SetAggregated();
    void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddAggregationProperty(const CPropertyName& Property);
    void AddAllAggregationProperties();
    void AddHavingToken(const WBEM_QL1_TOKEN& Tok);

    void Dump(const char *pszTextFile);
    DELETE_ME LPWSTR GetText();
};


class POLARITY QL1_Parser : public CAbstractQl1Parser
{
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpression;
    BOOL m_bPartiallyParsed;

public:
    QL1_Parser(CGenLexSource *pSrc);
   ~QL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput);
    static LPWSTR ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
        LPCWSTR wszClassName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\provinit.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVINIT.CPP

Abstract:

  This file implements the provider init sink

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <sync.h>
#include <cominit.h>
#include "provinit.h"

ULONG STDMETHODCALLTYPE CProviderInitSink::AddRef()
{
    CInCritSec ics(&m_cs);
    return ++m_lRef;
}

ULONG STDMETHODCALLTYPE CProviderInitSink::Release()
{
    EnterCriticalSection(&m_cs);
    --m_lRef;
    if(m_lRef == 0)
    {
        LeaveCriticalSection(&m_cs);
        delete this;
    }
    else LeaveCriticalSection(&m_cs);

    return 99;
}

HRESULT STDMETHODCALLTYPE CProviderInitSink::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    CInCritSec ics(&m_cs);
    if(riid == IID_IUnknown || riid == IID_IWbemProviderInitSink)
    {
        *ppv = (IWbemProviderInitSink*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

HRESULT STDMETHODCALLTYPE CProviderInitSink::SetStatus(long lStatus, 
                                                            long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(SUCCEEDED(lStatus) && lStatus != WBEM_S_INITIALIZED)
    {
        // Partial initialization is not supported in this version
        // =======================================================
        return WBEM_S_NO_ERROR;
    }

    m_lStatus = lStatus;
    SetEvent(m_hEvent);

    return WBEM_S_NO_ERROR;
}

CProviderInitSink::CProviderInitSink() : m_lRef(0)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CProviderInitSink::~CProviderInitSink()
{
    CloseHandle(m_hEvent);
}

HRESULT CProviderInitSink::WaitForCompletion()
{
    // Wait
    // ====

    DWORD dwRes = WbemWaitForSingleObject(m_hEvent, 300000);

    if(dwRes != WAIT_OBJECT_0)
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider initialization phase timed out\n"));
    
        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }

    return m_lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\ql.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QL.CPP

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL_1.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    a-raymcc    21-Jun-96       Created.
    mdavis      23-Apr-99       Changed to allow 'group' as a property name
                              for Raid 47767.  Also fixed GetText() for
                              property comparisons and improved Dump().

--*/

#include "precomp.h"
#include <stdio.h>
#include <errno.h>

#include <math.h>

#include <corepol.h>
#include <genlex.h>
#include <qllex.h>
#include <ql.h>
//#include <wbemstr.h>
#include <wbemcomn.h>
#include <wbemutil.h>
#include <genutils.h>
#include <corex.h>

#define trace(x) //printf x

WBEM_WSTR WbemStringAlloc(unsigned long lNumChars)
{
    return (WBEM_WSTR)CoTaskMemAlloc(lNumChars+1);
}

void WbemStringFree(WBEM_WSTR String)
{
    CoTaskMemFree(String);
}

unsigned long WbemStringLen(const WCHAR* String)
{
    return wcslen(String);
}

WBEM_WSTR WbemStringCopy(const WCHAR* String)
{
    if(String == NULL) return NULL;
    WBEM_WSTR NewString = (WBEM_WSTR)CoTaskMemAlloc(2*(wcslen(String)+1));
    if(NewString == NULL) return NULL;
    wcscpy(NewString, String);
    return NewString;
}

//***************************************************************************
//
//  WCHARToDOUBLE
//
//  Converts a wchar to a double, but does it using the english locale rather
//  than whatever local the process is running in.  This allows us to support
//  all english queries even on German machines.
//
//***************************************************************************

DOUBLE WCHARToDOUBLE(WCHAR * pConv, bool & bSuccess)
{
    bSuccess = false;
    if(pConv == NULL)
        return 0.0;

    VARIANT varTo, varFrom;
    VariantInit(&varTo);

    varFrom.vt = VT_BSTR;
    varFrom.bstrVal = SysAllocString(pConv);

    if ( varFrom.bstrVal == NULL )
    {
        return 0.0;
    }

    SCODE sc = VariantChangeTypeEx(&varTo, &varFrom, 0x409, 0, VT_R8);

    SysFreeString(varFrom.bstrVal);

    if ( FAILED(sc) )
    {
        return 0.0;
    }

    bSuccess = true;

    return varTo.dblVal;
}

CPropertyName::CPropertyName(const CPropertyName& Other)
{
    Init();
    *this = Other;
}

void CPropertyName::Init()
{
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_aElements = NULL;
    m_pvHandle = NULL;
}

void CPropertyName::operator=(const CPropertyName& Other)
{
    *this = (const WBEM_PROPERTY_NAME&)Other;
    m_pvHandle = Other.m_pvHandle;
}

void CPropertyName::operator=(const WBEM_PROPERTY_NAME& Other)
{
    Empty();

    if ( Other.m_lNumElements > 0)
    {
        m_aElements = new WBEM_NAME_ELEMENT[Other.m_lNumElements];

        if ( m_aElements == NULL )
        {
            throw CX_MemoryException();
        }
    }

    m_lAllocated = Other.m_lNumElements;

    for( long l=0 ; l < Other.m_lNumElements; l++ )
    {
        if(Other.m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            m_aElements[l].Element.m_wszPropertyName =
                WbemStringCopy(Other.m_aElements[l].Element.m_wszPropertyName);

            if ( m_aElements[l].Element.m_wszPropertyName == NULL )
            {
                break;
            }
        }
        else
        {
            m_aElements[l].Element.m_lArrayIndex =
                Other.m_aElements[l].Element.m_lArrayIndex;
        }

        m_aElements[l].m_nType = Other.m_aElements[l].m_nType;
    }

    m_lNumElements = l;

    if ( m_lNumElements != Other.m_lNumElements )
    {
        throw CX_MemoryException();
    }
}

BOOL CPropertyName::operator==(const WBEM_PROPERTY_NAME& Other)
{
    if(m_lNumElements != Other.m_lNumElements)
        return FALSE;

    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType != Other.m_aElements[l].m_nType)
            return FALSE;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            if(wbem_wcsicmp(m_aElements[l].Element.m_wszPropertyName,
                        Other.m_aElements[l].Element.m_wszPropertyName))
            {
                return FALSE;
            }
        }
        else
        {
            if(m_aElements[l].Element.m_lArrayIndex !=
                Other.m_aElements[l].Element.m_lArrayIndex)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

void CPropertyName::Empty()
{
    if ( m_aElements!=NULL )
    {   
        for(long l = 0; l < m_lNumElements; l++)
        {
            if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            {
                WbemStringFree(m_aElements[l].Element.m_wszPropertyName);
            }
        }
        delete [] m_aElements;
        m_aElements = NULL;
    }
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_pvHandle = NULL;
}

LPCWSTR CPropertyName::GetStringAt(long lIndex) const
{
    if(m_aElements[lIndex].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return m_aElements[lIndex].Element.m_wszPropertyName;
    }
    else return NULL;
}

void CPropertyName::AddElement(LPCWSTR wszElement)
{
    EnsureAllocated(m_lNumElements+1);

    LPWSTR wszTemp = WbemStringCopy(wszElement);

    if ( wszTemp == NULL )
    {
        throw CX_MemoryException();
    }

    m_aElements[m_lNumElements].m_nType = WBEM_NAME_ELEMENT_TYPE_PROPERTY;
    m_aElements[m_lNumElements].Element.m_wszPropertyName = wszTemp;
    m_lNumElements++;
}

void CPropertyName::EnsureAllocated(long lElements)
{
    if(m_lAllocated < lElements)
    {
        m_lAllocated = lElements+5;

        WBEM_NAME_ELEMENT* pTemp = new WBEM_NAME_ELEMENT[m_lAllocated];
        if (!pTemp)
            throw CX_MemoryException();

        memcpy(pTemp, m_aElements, sizeof(WBEM_NAME_ELEMENT) * m_lNumElements);
        delete [] m_aElements;
        m_aElements = pTemp;
    }
}

DELETE_ME LPWSTR CPropertyName::GetText()
{
    WString wsText;
    for(int i = 0; i < m_lNumElements; i++)
    {
        if(m_aElements[i].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return NULL;
        if(i > 0)
            wsText += L".";
        wsText += m_aElements[i].Element.m_wszPropertyName;
    }
    return wsText.UnbindPtr();
}




//***************************************************************************
//***************************************************************************


DWORD CAbstractQl1Parser::TranslateIntrinsic(LPCWSTR pFuncName)
{
    if (wbem_wcsicmp(pFuncName, L"UPPER") == 0)
        return QL1_FUNCTION_UPPER;
    if (wbem_wcsicmp(pFuncName, L"LOWER") == 0)
        return QL1_FUNCTION_LOWER;
    return QL1_FUNCTION_NONE;
}

void CAbstractQl1Parser::InitToken(WBEM_QL1_TOKEN* pToken)
{
    pToken->m_lTokenType = QL1_NONE;
    pToken->m_PropertyName.m_lNumElements = 0;
    pToken->m_PropertyName.m_aElements = NULL;

    pToken->m_PropertyName2.m_lNumElements = 0;
    pToken->m_PropertyName2.m_aElements = NULL;

    VariantInit(&pToken->m_vConstValue);
}


CAbstractQl1Parser::CAbstractQl1Parser(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(Ql_1_LexTable, pSrc);

    if ( m_pLexer == NULL )
    {
        throw CX_MemoryException();
    }

    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
    m_PropertyName2.m_lNumElements = 0;
    m_PropertyName2.m_aElements = NULL;
    m_bPropComp = FALSE;
}

CAbstractQl1Parser::~CAbstractQl1Parser()
{
    VariantClear(&m_vTypedConst);
    DeletePropertyName();
    delete m_pLexer;
}


int CAbstractQl1Parser::Parse(CQl1ParseSink* pSink, int nFlags)
{
    m_pSink = pSink;
    int nRes = parse(nFlags);
    m_pSink = NULL;
    return nRes;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL CAbstractQl1Parser::Next(int nFlags)
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == QL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == QL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == QL_1_TOK_IDENT && nFlags != NO_KEYWORDS)
    {
        if (wbem_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = QL_1_TOK_SELECT;
        else if (wbem_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = QL_1_TOK_FROM;
        else if (wbem_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = QL_1_TOK_WHERE;
        else if (wbem_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = QL_1_TOK_LIKE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = QL_1_TOK_OR;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = QL_1_TOK_AND;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = QL_1_TOK_NOT;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = QL_1_TOK_IS;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = QL_1_TOK_NULL;
        else if (wbem_wcsicmp(m_pTokenText, L"WITHIN") == 0)
            m_nCurrentToken = QL_1_TOK_WITHIN;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"ISA") == 0)
            m_nCurrentToken = QL_1_TOK_ISA;
        else if (nFlags != EXCLUDE_GROUP_KEYWORD && wbem_wcsicmp(m_pTokenText, L"GROUP") == 0)
            m_nCurrentToken = QL_1_TOK_GROUP;
        else if (wbem_wcsicmp(m_pTokenText, L"BY") == 0)
            m_nCurrentToken = QL_1_TOK_BY;
        else if (wbem_wcsicmp(m_pTokenText, L"HAVING") == 0)
            m_nCurrentToken = QL_1_TOK_HAVING;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"TRUE") == 0)
            m_nCurrentToken = QL_1_TOK_TRUE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"FALSE") == 0)
            m_nCurrentToken = QL_1_TOK_FALSE;
    }

    return TRUE;
}

LPCWSTR CAbstractQl1Parser::GetSinglePropertyName()
{
    if(m_PropertyName.m_lNumElements < 1)
        return NULL;

    if(m_PropertyName.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        return NULL;

    return m_PropertyName.m_aElements[0].Element.m_wszPropertyName;
}

void CAbstractQl1Parser::DeletePropertyName()
{
    for(long l = 0; l < m_PropertyName.m_lNumElements; l++)
    {
        if(m_PropertyName.m_aElements[l].m_nType ==
                                             WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_PropertyName.m_aElements[l].
                                Element.m_wszPropertyName);
        }
    }
    delete [] m_PropertyName.m_aElements;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
}

int CAbstractQl1Parser::FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

void CAbstractQl1Parser::AddAppropriateToken(const WBEM_QL1_TOKEN& Token)
{
    if(m_bInAggregation)
        m_pSink->AddHavingToken(Token);
    else
        m_pSink->AddToken(Token);
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int CAbstractQl1Parser::parse(int nFlags)
{
    int nRes;

    m_bInAggregation = FALSE;
    if(nFlags != JUST_WHERE)
    {
        m_pLexer->Reset();

        // SELECT
        // ======
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != QL_1_TOK_SELECT)
            return SYNTAX_ERROR;
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        // <prop_list>
        // ===========
        if (nRes = prop_list())
            return nRes;

        // FROM
        // ====
        if (m_nCurrentToken != QL_1_TOK_FROM)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;

        // <classname>
        // ===========
        if (nRes = class_name())
            return nRes;

        // <tolerance>
        // ===========

        if(nRes = tolerance())
            return nRes;
    }

    if(nFlags != NO_WHERE)
    {
        // WHERE clause.
        // =============
        if(nRes = opt_where())
            return nRes;

        // GROUP BY clause
        // ===============
        if(nRes = opt_aggregation())
            return nRes;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int CAbstractQl1Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == QL_1_TOK_EOF || m_nCurrentToken == QL_1_TOK_GROUP)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != QL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is QL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != QL_1_TOK_EOF && m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != QL_1_TOK_ASTERISK &&
        m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list_2()
{
    if (m_nCurrentToken == QL_1_TOK_COMMA)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


int CAbstractQl1Parser::parse_property_name(CPropertyName& Prop)
{
    int nCount = 0;
    Prop.Empty();

    try
    {
        while(m_nCurrentToken == QL_1_TOK_IDENT)
        {
            // VERY TEMPORARY: See if this is a count query
            // that should be forwarded to the repository.

            BOOL bSkipNext = FALSE;
            if (!_wcsicmp(L"count", m_pTokenText))
            {
                if (Next() && m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
                {
                    if (!Next() || m_nCurrentToken != QL_1_TOK_ASTERISK)
                        return LEXICAL_ERROR;
                    if (!Next() || m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
                        return LEXICAL_ERROR;
                    Prop.AddElement(L"count(*)");
                    m_pSink->SetCountQuery();
                }
                else
                {
                    bSkipNext = TRUE;
                    Prop.AddElement(L"count");
                }
            }
            else
                Prop.AddElement(m_pTokenText);

            nCount++;

            if (!bSkipNext)
            {
                if(!Next())
                    return LEXICAL_ERROR;
            }

            if(m_nCurrentToken != QL_1_TOK_DOT)
                break;

            if(!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;
        }
    }
    catch (CX_MemoryException)
    {
        return OUT_OF_MEMORY;
    }
    catch (...)
    {
        return FAILED;
    }

    if (nCount)
        return SUCCESS;
    else
        return SYNTAX_ERROR;
}

//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int CAbstractQl1Parser::property_name()
{
    try
    {
        if (m_nCurrentToken == QL_1_TOK_ASTERISK)
        {
            trace(("Asterisk\n"));

            if(m_bInAggregation)
                m_pSink->AddAllAggregationProperties();
            else
                m_pSink->AddAllProperties();

            if(!Next())
                return LEXICAL_ERROR;

            return SUCCESS;
        }

        // Else a list of property names
        // =============================

        CPropertyName Prop;
        int nRes = parse_property_name(Prop);
        if(nRes != SUCCESS)
            return nRes;

        if(m_bInAggregation)
            m_pSink->AddAggregationProperty(Prop);
        else
            m_pSink->AddProperty(Prop);
    }
    catch (CX_MemoryException)
    {
        return OUT_OF_MEMORY;
    }
    catch (...)
    {
        return FAILED;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int CAbstractQl1Parser::class_name()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pSink->SetClassName(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <tolerance> ::= <>;
//  <tolerance> ::= WITHIN duration;
//
//***************************************************************************

int CAbstractQl1Parser::tolerance()
{
    LPWSTR wszGarbage;
    WBEM_QL1_TOLERANCE Tolerance;
    if(m_nCurrentToken != QL_1_TOK_WITHIN)
    {
        Tolerance.m_bExact = TRUE;
        m_pSink->SetTolerance(Tolerance);
        return SUCCESS;
    }

    if(!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        Tolerance.m_bExact = FALSE;
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(Tolerance.m_fTolerance <= 0 || bSuccess == false)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_bExact = FALSE;
        Tolerance.m_fTolerance = wcstol(m_pTokenText, &wszGarbage, 10);
        if(Tolerance.m_fTolerance < 0)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int CAbstractQl1Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int CAbstractQl1Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_OR)
        {
            trace(("Token OR\n"));
            m_pSink->InOrder(QL1_OR);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_OR;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int CAbstractQl1Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_AND)
        {
            trace(("Token AND\n"));
            m_pSink->InOrder(QL1_AND);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_AND;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        WBEM_QL1_TOKEN NewTok;
        InitToken(&NewTok);
        NewTok.m_lTokenType = QL1_NOT;
        AddAppropriateToken(NewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        if(nRes = parse_property_name(m_PropertyName))
            return nRes;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == QL_1_TOK_INT ||
             m_nCurrentToken == QL_1_TOK_REAL ||
             m_nCurrentToken == QL_1_TOK_TRUE ||
             m_nCurrentToken == QL_1_TOK_FALSE ||
             m_nCurrentToken == QL_1_TOK_NULL ||
             m_nCurrentToken == QL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        // dont allow const followed by isa!

        if(m_nRelOp == QL1_OPERATOR_ISA)
            return SYNTAX_ERROR;

        // Since we always view the token as IDENT <rel> constant, we need
        // to invert this operator, e.g. replace > with <
        // ================================================================

        m_nRelOp = FlipOperator(m_nRelOp);

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    int nRes = parse_property_name(m_PropertyName);
    return nRes;
}

//***************************************************************************
//
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::leading_ident_expr()
{
    int nRes;
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != QL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int CAbstractQl1Parser::trailing_or_null()
{
    if (m_nCurrentToken == QL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//  <trailing_const_expr> ::= <trailing_ident_expr>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_const_expr()
{
    int nRes;
    nRes = typed_constant();
    if (nRes != SUCCESS)
        nRes = trailing_ident_expr();
    return nRes;
}

//***************************************************************************
//
//  <trailing_ident_expr> ::= <property_name>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_ident_expr()
{
    int nRes = parse_property_name(m_PropertyName2) ;
    if (nRes == SUCCESS)
        m_bPropComp = TRUE;
    return nRes;
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the QL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int CAbstractQl1Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    WBEM_QL1_TOKEN NewTok;
    InitToken(&NewTok);

    NewTok.m_lTokenType = QL1_OP_EXPRESSION;
    VariantInit(&NewTok.m_vConstValue);

    memcpy((void*)&NewTok.m_PropertyName,
           (void*)(WBEM_PROPERTY_NAME*)&m_PropertyName,
           sizeof(WBEM_PROPERTY_NAME));

    if (m_bPropComp)
    {
        NewTok.m_bPropComp = true;
        memcpy((void*)&NewTok.m_PropertyName2,
               (void*)(WBEM_PROPERTY_NAME*)&m_PropertyName2,
               sizeof(WBEM_PROPERTY_NAME));
    }
    else
    {
        NewTok.m_bPropComp = false;
        if ( FAILED(VariantCopy(&NewTok.m_vConstValue, &m_vTypedConst) ))
        {
            return OUT_OF_MEMORY;
        }
    }

    NewTok.m_lOperator = m_nRelOp;
    NewTok.m_lPropertyFunction = m_dwPropFunction;
    NewTok.m_lConstFunction = m_dwConstFunction;
    NewTok.m_bQuoted = m_bQuoted;

    AddAppropriateToken(NewTok);

//    m_PropertyName.m_lNumElements = 0;
//    m_PropertyName.m_aElements = NULL;
    m_PropertyName.Empty();
    m_PropertyName2.Empty();

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    VariantClear(&NewTok.m_vConstValue);
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bPropComp = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int CAbstractQl1Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bQuoted = FALSE;

    if (m_nCurrentToken == QL_1_TOK_INT)
    {
        trace((" Integer\n"));

        // Read it in as a 64-bit one
        // ==========================

        __int64 i64;
        unsigned __int64 ui64;
        BOOL b32bits = FALSE;
        if(ReadI64(m_pTokenText, i64))
        {
            // Check if it is within range of I4
            // =================================

            if(i64 >= - (__int64)0x80000000 && i64 <= 0x7FFFFFFF)
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = (long)i64;
                b32bits = TRUE;
            }
        }
        else if(!ReadUI64(m_pTokenText, ui64))
        {
            // Not a valid number
            // ==================

            return LEXICAL_ERROR;
        }

        if(!b32bits)
        {
            // Valid 64-bit number but not 32-bit
            // ==================================

            BSTR bstr = SysAllocString(m_pTokenText);
            if ( bstr == NULL )
            {
                return OUT_OF_MEMORY;
            }
            V_VT(&m_vTypedConst) = VT_BSTR;
            V_BSTR(&m_vTypedConst) = bstr;
            m_bQuoted = FALSE;
        }
    }
    else if (m_nCurrentToken == QL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        BSTR bstr = SysAllocString(m_pTokenText);
        if ( bstr == NULL )
        {
            return OUT_OF_MEMORY;
        }
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = bstr;
        m_bQuoted = TRUE;
    }
    else if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        bool bSuccess;
        V_R8(&m_vTypedConst) = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(bSuccess == false)
            return LEXICAL_ERROR;
    }
    else if(m_nCurrentToken == QL_1_TOK_TRUE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
    }
    else if(m_nCurrentToken == QL_1_TOK_FALSE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    else if (m_nCurrentToken == QL_1_TOK_NULL)
        V_VT(&m_vTypedConst) = VT_NULL;

    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int CAbstractQl1Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == QL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != QL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_GREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else if (m_nCurrentToken == QL_1_TOK_ISA)
    {
        trace(("    REL OP 'isa' \n"));
        m_nRelOp = QL1_OPERATOR_ISA;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::opt_aggregation()
{
    if(m_nCurrentToken == QL_1_TOK_EOF)
        return SUCCESS;

    if(m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    m_pSink->SetAggregated();

    int nRes = aggregation_params();
    if(nRes)
        return nRes;

    if(nRes = opt_having())
        return nRes;

    // Make sure we've reached the end
    // ===============================

    if(m_nCurrentToken != QL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::aggregation_params()
{
    int nRes;
    WBEM_QL1_TOLERANCE Exact;
    Exact.m_bExact = TRUE;

    if(m_nCurrentToken == QL_1_TOK_BY)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        if(nRes = aggregate_by())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_WITHIN)
        {
            if (!Next())
                return LEXICAL_ERROR;

            if(nRes = aggregate_within())
                return nRes;
        }
        else
        {
            m_pSink->SetAggregationTolerance(Exact);
        }
    }
    else if(m_nCurrentToken == QL_1_TOK_WITHIN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        if(nRes = aggregate_within())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_BY)
        {
            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if(nRes = aggregate_by())
                return nRes;
        }
    }
    else
    {
        return SYNTAX_ERROR;
    }

    return SUCCESS;
}

int CAbstractQl1Parser::aggregate_within()
{
    WBEM_QL1_TOLERANCE Tolerance;
    Tolerance.m_bExact = FALSE;
    LPWSTR wszGarbage;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(!bSuccess)
            return SYNTAX_ERROR;
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_fTolerance = (double)wcstol(m_pTokenText, &wszGarbage, 10);
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

int CAbstractQl1Parser::aggregate_by()
{
    m_bInAggregation = TRUE;
    int nRes = prop_list();
    m_bInAggregation = FALSE;
    return nRes;
}

int CAbstractQl1Parser::opt_having()
{
    if(m_nCurrentToken == QL_1_TOK_HAVING)
    {
        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        m_bInAggregation = TRUE;
        int nRes = expr();
        m_bInAggregation = FALSE;
        return nRes;
    }
    else return SUCCESS;
}


//***************************************************************************
//***************************************************************************
//
//  class QL1_Parser
//
//  A derivative of CAbstractQlParser for backward compatibility
//
//***************************************************************************
//
//

QL1_Parser::QL1_Parser(CGenLexSource *pSrc)
    : m_pExpression(NULL), CAbstractQl1Parser(pSrc), m_bPartiallyParsed(FALSE)
{
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;

    if ( m_pExpression == NULL )
    {
        throw CX_MemoryException();
    }
}

QL1_Parser::~QL1_Parser()
{
    delete m_pExpression;
}

int QL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Get the underlying parser to parse the first part of the query
    // ==============================================================

    if(!m_bPartiallyParsed)
    {
        int nRes = CAbstractQl1Parser::Parse(m_pExpression, NO_WHERE);
        if(nRes != SUCCESS) return nRes;
    }

    if (!m_pExpression->bsClassName)
        return SYNTAX_ERROR;

    m_bPartiallyParsed = TRUE;
    if(wcslen(m_pExpression->bsClassName) >= (unsigned int)nBufLen)
        return BUFFER_TOO_SMALL;

    wcscpy(pDestBuf, m_pExpression->bsClassName);
    return WBEM_S_NO_ERROR;
}

int QL1_Parser::Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    *pOutput = NULL;

    // Get the underying parser to completely parse the query. If
    // GetQueryClass was called in the past, no sense in duplcating
    // the work
    // ============================================================

    QL_LEVEL_1_RPN_EXPRESSION* pTemp = NULL;

	try
	{
		pTemp = new QL_LEVEL_1_RPN_EXPRESSION;
    }
    catch (CX_MemoryException)
    {
        return OUT_OF_MEMORY;
    }

    if ( pTemp == NULL )
    {
       return OUT_OF_MEMORY;
    }

    int nRes = CAbstractQl1Parser::Parse(m_pExpression,
        m_bPartiallyParsed?JUST_WHERE:FULL_PARSE);

    if ( nRes == SUCCESS )
    {
        *pOutput = m_pExpression;
        m_pExpression = pTemp;
        m_bPartiallyParsed = FALSE;
    }
    else
    {
        delete pTemp;
    }

    return nRes;
}

DELETE_ME LPWSTR QL1_Parser::ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                                LPCWSTR wszClassName)
{
    QL_LEVEL_1_RPN_EXPRESSION NewExpr(*pExpr);

    if (NewExpr.bsClassName)
        SysFreeString(NewExpr.bsClassName);

    NewExpr.bsClassName = SysAllocString(wszClassName);

    if ( NewExpr.bsClassName == NULL )
    {
        return NULL;
    }

    LPWSTR wszNewQuery = NewExpr.GetText();
    return wszNewQuery;
}


//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    bsClassName = 0;
    bCount = FALSE;
    nNumberOfProperties = 0;
    bStar = FALSE;
    pRequestedPropertyNames = 0;
    nCurSize = 1;
    nCurPropSize = 1;
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];

    bAggregated = FALSE;
    bAggregateAll = FALSE;
    nNumAggregatedProperties = 0;
    nCurAggPropSize = 1;
    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];

    nNumHavingTokens = 0;
    nCurHavingSize = 1;
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];

    if ( pArrayOfTokens == NULL || pRequestedPropertyNames == NULL ||
         pAggregatedPropertyNames == NULL || pArrayOfHavingTokens == NULL )
    {
        delete [] pArrayOfTokens;
        delete [] pRequestedPropertyNames;
        delete [] pAggregatedPropertyNames;
        delete [] pArrayOfHavingTokens;
        throw CX_MemoryException();
    }

    lRefCount = 0;
}

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION(
                                const QL_LEVEL_1_RPN_EXPRESSION& Other)
{
    nNumTokens = Other.nNumTokens;

    nNumberOfProperties = Other.nNumberOfProperties;
    bStar = Other.bStar;
    bCount = Other.bCount;
    pRequestedPropertyNames = 0;
    nCurSize = Other.nCurSize;
    nCurPropSize = Other.nCurPropSize;

    bAggregated = Other.bAggregated;
    bAggregateAll = Other.bAggregateAll;
    nNumAggregatedProperties = Other.nNumAggregatedProperties;
    nCurAggPropSize = Other.nCurAggPropSize;
    nNumHavingTokens = Other.nNumHavingTokens;
    nCurHavingSize = Other.nCurHavingSize;

    bsClassName = SysAllocString(Other.bsClassName);
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];

    if ( pArrayOfTokens == NULL || pRequestedPropertyNames == NULL ||
         pAggregatedPropertyNames == NULL || pArrayOfHavingTokens == NULL ||
         bsClassName == NULL )
    {
        delete [] pArrayOfTokens;
        delete [] pRequestedPropertyNames;
        delete [] pAggregatedPropertyNames;
        delete [] pArrayOfHavingTokens;
        if ( bsClassName != NULL ) SysFreeString( bsClassName );
        throw CX_MemoryException();
    }

    int i;
    for(i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i] = Other.pArrayOfTokens[i];

    for(i = 0; i < nNumberOfProperties; i++)
        pRequestedPropertyNames[i] = Other.pRequestedPropertyNames[i];

    for(i = 0; i < nNumAggregatedProperties; i++)
        pAggregatedPropertyNames[i] = Other.pAggregatedPropertyNames[i];

    for(i = 0; i < nNumHavingTokens; i++)
        pArrayOfHavingTokens[i] = Other.pArrayOfHavingTokens[i];

    lRefCount = 0;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddRef()
{
    InterlockedIncrement(&lRefCount);
}

void QL_LEVEL_1_RPN_EXPRESSION::Release()
{
    if(InterlockedDecrement(&lRefCount) == 0)
        delete this;
}


QL_LEVEL_1_RPN_EXPRESSION::~QL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    delete [] pAggregatedPropertyNames;
    delete [] pArrayOfHavingTokens;
    delete [] pRequestedPropertyNames;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetClassName(LPCWSTR wszClassName)
{
    if ( bsClassName != NULL )
    {
        SysFreeString( bsClassName );
    }

    bsClassName = SysAllocString(wszClassName);

    if ( bsClassName == NULL )
    {
        throw CX_MemoryException();
    }
}

void QL_LEVEL_1_RPN_EXPRESSION::SetTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    Tolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregationTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    AggregationTolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(const WBEM_QL1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;

        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(const QL_LEVEL_1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;

        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddHavingToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurHavingSize == nNumHavingTokens)
    {
        nCurHavingSize += 1;
        nCurHavingSize *= 2;

        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurHavingSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for (int i = 0; i < nNumHavingTokens; i++)
            pTemp[i] = pArrayOfHavingTokens[i];
        delete [] pArrayOfHavingTokens;
        pArrayOfHavingTokens = pTemp;
    }

    pArrayOfHavingTokens[nNumHavingTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddProperty(const CPropertyName& Prop)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 1;
        nCurPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurPropSize];

        if (!pTemp)
            throw CX_MemoryException();

        for(int i = 0; i < nNumberOfProperties; i++)
            pTemp[i] = pRequestedPropertyNames[i];
        delete [] pRequestedPropertyNames;
        pRequestedPropertyNames = pTemp;
    }

    pRequestedPropertyNames[nNumberOfProperties++] = Prop;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllProperties()
{
    bStar = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetCountQuery()
{
    bCount = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregated()
{
    bAggregated = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAggregationProperty(
                                    const CPropertyName& Property)
{
    if(pAggregatedPropertyNames == NULL)
    {
        // '*' requested
        return;
    }
    if (nCurAggPropSize == nNumAggregatedProperties)
    {
        nCurAggPropSize += 1;
        nCurAggPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurAggPropSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for(int i = 0; i < nNumAggregatedProperties; i++)
            pTemp[i] = pAggregatedPropertyNames[i];
        delete [] pAggregatedPropertyNames;
        pAggregatedPropertyNames = pTemp;
    }

    pAggregatedPropertyNames[nNumAggregatedProperties++] = Property;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllAggregationProperties()
{
    bAggregateAll = TRUE;
}

DELETE_ME LPWSTR QL_LEVEL_1_RPN_EXPRESSION::GetText()
{
    WString wsText;

    wsText += L"select ";
    for(int i = 0; i < nNumberOfProperties; i++)
    {
        if(i != 0) wsText += L", ";
        wsText += (LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
    }
    if(bStar)
    {
        if(nNumberOfProperties > 0)
            wsText += L", ";
        wsText += L"*";
    }

    wsText += L" from ";
    if (bsClassName)
        wsText += bsClassName;

    if(nNumTokens > 0)
    {
        wsText += L" where ";

        CWStringArray awsStack;
        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if(wszTokenText == NULL)
                return NULL;

            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }
        }

        if(awsStack.Size() != 1) return NULL;
        wsText += awsStack[0];
    }

    return wsText.UnbindPtr();
}

void QL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pRequestedPropertyNames[i].GetStringAt(0));
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;

    *this = Src;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const QL_LEVEL_1_TOKEN &Src)
{
    if ( FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.vConstValue)) )
    {
        throw CX_MemoryException();
    }

    nTokenType = Src.nTokenType;
    PropertyName = Src.PropertyName;
    if (Src.m_bPropComp)
        PropertyName2 = Src.PropertyName2;
    nOperator = Src.nOperator;
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bQuoted = Src.bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;

}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const WBEM_QL1_TOKEN &Src)
{
    if ( FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.m_vConstValue) ) )
    {
        throw CX_MemoryException();
    }

    nTokenType = Src.m_lTokenType;
    PropertyName = Src.m_PropertyName;
    if (Src.m_bPropComp)
        PropertyName2 = Src.m_PropertyName2;
    nOperator = Src.m_lOperator;
    dwPropertyFunction = Src.m_lPropertyFunction;
    dwConstFunction = Src.m_lConstFunction;
    bQuoted = Src.m_bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN::~QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantClear(&vConstValue);
}

DELETE_ME LPWSTR QL_LEVEL_1_TOKEN::GetText()
{
    WString wsText;
    LPWSTR wszPropName;
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            wszPropName = PropertyName.GetText();
            if(wszPropName == NULL)
                return NULL;
            wsText += wszPropName;
            delete [] wszPropName;
            wsText += L" ";

            WCHAR* wszOp;
            switch (nOperator)
            {
            case OP_EQUAL: wszOp = L"="; break;
            case OP_NOT_EQUAL: wszOp = L"<>"; break;
            case OP_EQUALorGREATERTHAN: wszOp = L">="; break;
            case OP_EQUALorLESSTHAN: wszOp = L"<="; break;
            case OP_LESSTHAN: wszOp = L"<"; break;
            case OP_GREATERTHAN: wszOp = L">"; break;
            case OP_LIKE: wszOp = L"LIKE"; break;
            case QL1_OPERATOR_ISA: wszOp = L"ISA"; break;
            default: wszOp = NULL;
            }
            if(wszOp)
                wsText += wszOp;
            wsText += L" ";

            if (m_bPropComp)
            {
                // property comparison (e.g., prop1 > prop2)
                wszPropName = PropertyName2.GetText();
                if(wszPropName == NULL)
                    return NULL;
                wsText += wszPropName;
                delete [] wszPropName;
            }
            else
            {
                // expression with constant (e.g., prop1 > 5)
                WCHAR wszConst[100];
                switch (V_VT(&vConstValue))
                {
                case VT_NULL:
                    wsText += L"NULL";
                    break;
                case VT_I4:
                    swprintf(wszConst, L"%d", V_I4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_I2:
                    swprintf(wszConst, L"%d", (int)V_I2(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_UI1:
                    swprintf(wszConst, L"%d", (int)V_UI1(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BSTR:
                {
                    if(bQuoted)
                        wsText += L"\"";
                    //If we need to parse the string we do it the hard way
                    WCHAR* pwc = V_BSTR(&vConstValue);
                    BOOL bLongMethod = FALSE;
                    for (int tmp = 0; pwc[tmp]; tmp++)
                        if ((pwc[tmp] == L'\\') || (pwc[tmp] == L'"'))
                            bLongMethod = TRUE;
                    if (bLongMethod)
                    {
                        for(pwc; *pwc; pwc++)
                        {
                            if(*pwc == L'\\' || *pwc == L'"')
                                wsText += L'\\';
                            wsText += *pwc;
                        }
                    }
                    else
                    {
                        //otherwise we do it the fast way...
                        wsText += pwc;
                    }
                    if(bQuoted)
                        wsText += L"\"";
                }
                    break;
                case VT_R4:
                    swprintf(wszConst, L"%G", V_R4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_R8:
                    swprintf(wszConst, L"%lG", V_R8(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BOOL:
                    wsText += (V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                }
            }

            break;
        case TOKEN_AND:
            wsText = "AND";
            break;
        case TOKEN_OR:
            wsText = "OR";
            break;
        case TOKEN_NOT:
            wsText = "NOT";
            break;
    }

    return wsText.UnbindPtr();
}

void QL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        LPWSTR wszPropName = PropertyName.GetText();
        if(wszPropName == NULL)
            return;
        fprintf(f, "    Property = %S\n", wszPropName);
        delete [] wszPropName;
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");

        if (m_bPropComp)
        {
            wszPropName = PropertyName2.GetText();
            if(wszPropName == NULL)
                return;
            fprintf(f, "   <Property:%S>\n", wszPropName);
            delete [] wszPropName;
        }
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_I2:
                    fprintf(f, "VT_I2 = %d\n", (int)V_I2(&vConstValue));
                    break;
                case VT_UI1:
                    fprintf(f, "VT_UI1 = %d\n", (int)V_UI1(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R4:
                    fprintf(f, "VT_R4 = %f\n", V_R4(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "%S\n", V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                case VT_NULL:
                    fprintf(f, "%S\n", L"NULL");
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }

            switch (dwPropertyFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to property\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to property\n");
                    break;
            }
            switch (dwConstFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                    break;
            }
        }
    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of QL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\reg.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REG.H

Abstract:

  Utility Registry classes

History:

  a-raymcc    30-May-96   Created.

--*/

#ifndef _REG_H_
#define _REG_H_
#include "corepol.h"

#define WBEM_REG_WBEM __TEXT("Software\\Microsoft\\WBEM")
#define WBEM_REG_WINMGMT __TEXT("Software\\Microsoft\\WBEM\\CIMOM")

class POLARITY Registry
{
    HKEY hPrimaryKey;
    HKEY hSubkey;
    int nStatus;
    LONG m_nLastError;


public:
    enum { no_error, failed };

    int Open(HKEY hStart, TCHAR *pszStartKey);
    Registry(TCHAR *pszLocalMachineStartKey);

    // This create a special read only version which is usefull for marshalling
    // clients which are running with a lower priviledge set.

    Registry();
    Registry(HKEY hRoot, REGSAM flags, TCHAR *pszStartKey);
    Registry(HKEY hRoot, DWORD dwOptions, REGSAM flags, TCHAR *pszStartKey);
   ~Registry();

    int MoveToSubkey(TCHAR *pszNewSubkey);
    int GetDWORD(TCHAR *pszValueName, DWORD *pdwValue);
    int GetDWORDStr(TCHAR *pszValueName, DWORD *pdwValue);
    int GetStr(TCHAR *pszValue, TCHAR **pValue);

    // It is the callers responsibility to delete pData

    int GetBinary(TCHAR *pszValue, byte ** pData, DWORD * pdwSize);
    int SetBinary(TCHAR *pszValue, byte * pData, DWORD dwSize);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    TCHAR* GetMultiStr(TCHAR *pszValueName, DWORD &dwSize);

    int SetDWORD(TCHAR *pszValueName, DWORD dwValue);
    int SetDWORDStr(TCHAR *pszValueName, DWORD dwValue);
    int SetStr(TCHAR *pszValueName, TCHAR *psvValue);
    int SetExpandStr(TCHAR *pszValueName, TCHAR *psvValue);

    //pData should be passed in with the last entry double null terminated.
    //(i.e. the registry format for a REG_MULTI_SZ).
    int SetMultiStr(TCHAR *pszValueName, TCHAR* pData, DWORD dwSize);

    LONG GetLastError() { return m_nLastError; }
    int DeleteValue(TCHAR *pszValueName);
    int GetType(TCHAR *pszValueName, DWORD *pdwType);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\qllex.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    QLLEX.CH

Abstract:

	QL Level 1 DFA Table & Tokens

History:

	raymcc    24-Jun-95       Created.

--*/

#ifndef _QLLEX_H_

#include <genlex.h>
#define QL_1_TOK_EOF       0
#define QL_1_TOK_ERROR     1
#define QL_1_TOK_IDENT     100
#define QL_1_TOK_QSTRING   101
#define QL_1_TOK_INT       102
#define QL_1_TOK_REAL      103
#define QL_1_TOK_CHAR      104

#define QL_1_TOK_LE        105
#define QL_1_TOK_LT        106
#define QL_1_TOK_GE        107
#define QL_1_TOK_GT        108
#define QL_1_TOK_EQ        109
#define QL_1_TOK_NE        110

#define QL_1_TOK_DOT           111
#define QL_1_TOK_OPEN_PAREN    112
#define QL_1_TOK_CLOSE_PAREN   113
#define QL_1_TOK_ASTERISK      114
#define QL_1_TOK_COMMA         115

#define QL_1_TOK_SELECT        120
#define QL_1_TOK_WHERE         121
#define QL_1_TOK_FROM          122
#define QL_1_TOK_LIKE          123
#define QL_1_TOK_OR            124
#define QL_1_TOK_AND           125
#define QL_1_TOK_NOT           126
#define QL_1_TOK_IS            127
#define QL_1_TOK_NULL          128
#define QL_1_TOK_WITHIN        129
#define QL_1_TOK_ISA           130
#define QL_1_TOK_GROUP         131
#define QL_1_TOK_BY            132
#define QL_1_TOK_HAVING        133

#define QL_1_TOK_TRUE        140
#define QL_1_TOK_FALSE        141

extern LexEl Ql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\servutil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.H

Abstract:

	Declares a set of general purpose service utilitils.

History:

  a-davj  04-Mar-97   Created.

--*/

#ifndef _SERVUTIL_H_
#define _SERVUTIL_H_

BOOL StopService(LPCTSTR pServiceName, DWORD dwMaxWait=0);
BOOL StartService(LPCTSTR pServiceName, DWORD dwMaxWait=0);
BOOL InstallService(LPCTSTR pServiceName,LPCTSTR pDisplayName, LPCTSTR pBinary);
BOOL RemoveService(LPCTSTR pServiceName);
BOOL SetDependency(LPCTSTR pServiceName, LPCTSTR pDependency);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\reg.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REG.CPP

Abstract:

  Utility Registry classes

History:

  raymcc    30-May-96   Created.
  raymcc    26-Jul-99   Updated for TCHAR.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include <stdio.h>
#include <reg.h>
#include <tchar.h>
#include <malloc.h>

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::Open(HKEY hStart, TCHAR *pszStartKey)
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

    m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
                                    0, 0, 0,
                                    KEY_ALL_ACCESS, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(HKEY hRoot, REGSAM flags, TCHAR *pszStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = RegOpenKeyEx(hRoot, pszStartKey,
                        0, flags, &hPrimaryKey
                        );
    hSubkey = hPrimaryKey;
    m_nLastError = nStatus;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(HKEY hRoot, DWORD dwOptions, REGSAM flags, TCHAR *pszStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;

    int nStatus = no_error;
    DWORD dwDisp = 0;

    m_nLastError = RegCreateKeyEx(hRoot, pszStartKey,
                                    0, 0, dwOptions,
                                    flags, 0, &hPrimaryKey, &dwDisp
                                    );

    hSubkey = hPrimaryKey;
}


//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(TCHAR *pszLocalMachineStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey);
    hSubkey = hPrimaryKey;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry()
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = 0;
    hSubkey = 0;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::MoveToSubkey(TCHAR *pszNewSubkey)
{
    DWORD dwDisp = 0;
    m_nLastError = RegCreateKeyEx(hPrimaryKey, pszNewSubkey, 0, 0, 0, KEY_ALL_ACCESS,
                                    0, &hSubkey, &dwDisp);
    if (m_nLastError != 0)
            return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetDWORD(TCHAR *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetType(TCHAR *pszValueName, DWORD *pdwType)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, pdwType,
                                NULL, NULL);
    if (m_nLastError != 0)
            return failed;
    return no_error;
}
//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetDWORDStr(TCHAR *pszValueName, DWORD *pdwValue)
{
    TCHAR cTemp[25];
    DWORD dwSize = 25;
    DWORD dwType = 0;
    TCHAR * pEnd = NULL;    // gets set to character that stopped the scan    
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
        (LPBYTE)cTemp, &dwSize);

    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ)
        return failed;

    *pdwValue = wcstoul(cTemp, &pEnd, 10);
    if(pEnd == NULL || pEnd == cTemp)
        return failed;
    else
        return no_error;
}


//***************************************************************************
//
//  Use operator delete on the returned pointer!!
//
//***************************************************************************
// ok

int Registry::GetBinary(TCHAR *pszValue, byte ** pData, DWORD * pdwSize)
{
    *pData = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    if(m_nLastError)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValue, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_BINARY)
        return failed;

    byte *p = new byte[dwSize];
    if (p == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValue, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        return failed;
    }

    *pdwSize = dwSize;
    *pData = p;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetBinary(TCHAR *pszValue, byte * pData, DWORD dwSize)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValue, 0, REG_BINARY, pData, dwSize);

    if (m_nLastError != 0)
        return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetDWORD(TCHAR *pszValueName, DWORD dwValue)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_DWORD, LPBYTE(&dwValue),
                                    sizeof(DWORD));
    if (m_nLastError != 0)
        return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetDWORDStr(TCHAR *pszValueName, DWORD dwVal)
{
    TCHAR cTemp[30];
    _stprintf(cTemp,__TEXT("%d"),dwVal);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(cTemp),
        (_tcslen(cTemp)+1) * sizeof(TCHAR));

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok

int Registry::DeleteValue(TCHAR *pszValueName)
{
    if(hSubkey == NULL)
        return failed;

    return RegDeleteValue(hSubkey, pszValueName);
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetMultiStr(TCHAR *pszValueName, TCHAR * pszValue, DWORD dwSize)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey,
                                 pszValueName,
                                 0,
                                 REG_MULTI_SZ,
                                 LPBYTE(pszValue),
                                 dwSize);

    if (m_nLastError != 0)
        return failed;
    return no_error;
}


//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetStr(TCHAR *pszValueName, TCHAR *pszValue)
{

    int nSize = (_tcslen(pszValue)+1) * sizeof(TCHAR);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue), nSize);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}


//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetExpandStr(TCHAR *pszValueName, TCHAR *pszValue)
{
    int nSize = (_tcslen(pszValue)+1) * sizeof(TCHAR);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_EXPAND_SZ, LPBYTE(pszValue), nSize);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
//  ok

TCHAR* Registry::GetMultiStr(TCHAR *pszValueName, DWORD &dwSize)
{
    //Find out the size of the buffer required
    DWORD dwType;
    if(hSubkey == NULL)
        return NULL;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

    if ((m_nLastError == ERROR_SUCCESS) && (dwType != REG_MULTI_SZ))
    {
        m_nLastError = WBEM_E_TYPE_MISMATCH;
        dwSize = 0;
        return NULL;
    }

    //If the error is an unexpected one bail out
    if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
    {
        dwSize = 0;
        return NULL;
    }

    if (dwSize == 0)
    {
        dwSize = 0;
        return NULL;
    }

    // Allocate the buffer required. Will be twice as big as required
    // in _UNICODE versions.
    // ===============================================================
    TCHAR *pData = new TCHAR[dwSize];
    if (pData == 0)
        return NULL;
    
    //get the values
    m_nLastError = RegQueryValueEx(hSubkey,
                                   pszValueName,
                                   0,
                                   &dwType,
                                   LPBYTE(pData),
                                   &dwSize);

    //if an error bail out
    if (m_nLastError != 0)
    {
        delete [] pData;
        dwSize = 0;
        return NULL;
    }

    return pData;
}


//***************************************************************************
//
/// Use operator delete on returned value.
//
//***************************************************************************
// ok

int Registry::GetStr(TCHAR *pszValueName, TCHAR **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    //
    // length will not include the null terminated character when you don't 
    // pass the buffer and the reg value was not already null terminated, 
    // so make up for it.  If you give RegQueryValueEx enough room in the buff
    // it will add the null terminator for you.
    // 
    dwSize += sizeof(TCHAR);

    TCHAR *p = new TCHAR[dwSize];  // May be twice as big as required when _UNICODE
                                    // is defined, but harmless nonetheless.
    if (p == 0)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
        TCHAR tTemp;

        // Get the initial length

        DWORD nSize = ExpandEnvironmentStrings((TCHAR *)p,&tTemp,1) + 1;
        TCHAR * pTemp = new TCHAR[nSize+1];
        if (pTemp == 0)
        {
            delete [] p;
            return failed;
        }
        ExpandEnvironmentStrings((TCHAR *)p,pTemp,nSize+1);
        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\safearry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.H

Abstract:

  CSafeArray implementation.

History:

    08-Apr-96   a-raymcc    Created.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#ifndef _SAFEARRY_H_
#define _SAFEARRY_H_

#include <stdio.h>
#include "corepol.h"
#include "corex.h"

typedef union 
{ 
    double dblVal; 
    float fltVal; 
    short iVal; 
    long lVal; 
    BYTE bVal; 
    VARIANT_BOOL boolVal;
}   SA_ArrayScalar;            

// Conversion functions due to VC 5.0 Optimizer Problems
inline SA_ArrayScalar ToSA_ArrayScalar( double dblVal )
{   SA_ArrayScalar sa;  sa.dblVal = dblVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( float fltVal )
{   SA_ArrayScalar sa;  sa.fltVal = fltVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( short iVal )
{   SA_ArrayScalar sa;  sa.iVal = iVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( long lVal )
{   SA_ArrayScalar sa;  sa.lVal = lVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( BYTE bVal )
{   SA_ArrayScalar sa;  sa.bVal = bVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalarBool( VARIANT_BOOL boolVal )
{   SA_ArrayScalar sa;  sa.boolVal = boolVal;   return sa;  }


class POLARITY CSafeArray
{
    int m_nMaxElementUsed;
    int m_nFlags;
    int m_nGrowBy;
    int m_nStatus;
    int m_nVarType;
	int m_nElementSize;
    SAFEARRAYBOUND m_bound;    
    SAFEARRAY *m_pArray;
    
    void Empty();                    // Empty array
    void Fatal(const char *);
    void CheckType(int n);
    int  AddScalar(IN SA_ArrayScalar val);
    int  SetScalarAt(IN int nIndex, IN SA_ArrayScalar val);
    SA_ArrayScalar GetScalarAt(IN int nIndex);
        
public:
    enum { no_error, failed, range_error };
    enum { no_delete = 0x1, auto_delete = 0x2, bind = 0x4 };

    
    // Construction, destruction, and assignment.
    // ==========================================
        
    CSafeArray(
        IN int vt, 
        IN int nFlags,          // no_delete|auto_delete
        IN int nSize = 32, 
        IN int nGrowBy = 32
        );

    CSafeArray(
        IN SAFEARRAY *pSrc, 
        IN int nType,           // VT_ type of SAFEARRAY.
        IN int nFlags,          // no_delete|auto_delete [|bind]
        IN int nGrowBy = 32
        );

    CSafeArray &operator =(IN CSafeArray &Src);
    CSafeArray(IN CSafeArray &Src);
   ~CSafeArray();
    
    // Get functions.
    // ==============    

    BYTE    GetByteAt(IN int nIndex)
        { return GetScalarAt(nIndex).bVal; }
    LONG    GetLongAt(IN int nIndex)
        { return GetScalarAt(nIndex).lVal; }
    SHORT   GetShortAt(IN int nIndex)
        { return GetScalarAt(nIndex).iVal; }
    double  GetDoubleAt(IN int nIndex)
        { return GetScalarAt(nIndex).dblVal; }
    float   GetFloatAt(IN int nIndex)
        { return GetScalarAt(nIndex).fltVal; }
    VARIANT_BOOL GetBoolAt(IN int nIndex)
        { return GetScalarAt(nIndex).boolVal; }        

    BSTR    GetBSTRAt(IN int nIndex);          // Caller must use SysFreeString
    BSTR    GetBSTRAtThrow(int nIndex);        // Caller must use SysFreeString
    VARIANT GetVariantAt(IN int nIndex);      // 
    IDispatch* GetDispatchAt(IN int nIndex);
    IUnknown* GetUnknownAt(IN int nIndex);

    // Set functions.
    // ==============
        
    int SetByteAt(IN int nIndex, IN BYTE byVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(byVal)); }
    int SetLongAt(IN int nIndex, IN LONG lVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(lVal)); }
    int SetFloatAt(IN int nIndex, IN float fltVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(fltVal)); }
    int SetDoubleAt(IN int nIndex, IN double dVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(dVal)); }    
    int SetShortAt(IN int nIndex, IN SHORT iVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(iVal)); }        
    int SetBoolAt(IN int nIndex, IN VARIANT_BOOL boolVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalarBool(boolVal)); }        

    int SetBSTRAt(IN int nIndex, IN BSTR Str);     // A copy of the BSTR is made
    int SetVariantAt(IN int nIndex, IN VARIANT *pSrc);
    int SetDispatchAt(IN int nIndex, IN IDispatch* pDisp);
    int SetUnknownAt(IN int nIndex, IN IUnknown* pUnk);
    
    // Add (append) functions.
    // =======================
    
    int AddByte(IN BYTE byVal)  { return AddScalar(ToSA_ArrayScalar(byVal)); }
    int AddLong(IN LONG lVal)   { return AddScalar(ToSA_ArrayScalar(lVal)); }
    int AddFloat(IN float fltVal) { return AddScalar(ToSA_ArrayScalar(fltVal)); }
    int AddDouble(IN double dVal) { return AddScalar(ToSA_ArrayScalar(dVal)); }
    int AddShort(IN SHORT iVal)  { return AddScalar(ToSA_ArrayScalar(iVal)); }
    int AddBool(IN VARIANT_BOOL boolVal) { return AddScalar(ToSA_ArrayScalarBool(boolVal)); }
    int AddBSTR(IN BSTR Str);
    int AddVariant(IN VARIANT *pData);
    int AddDispatch(IN IDispatch* pDisp);
    int AddUnknown(IN IUnknown* pUnk);
    
    // Operations the array as a whole. 
    // ================================

    int RemoveAt(IN int nIndex);                    
    int Size()    { return m_nMaxElementUsed + 1; }
    int GetType() { return m_nVarType; }
    int Status()  { return m_nStatus; }
	int ElementSize()	{ return m_nElementSize; }
    int Trim();                    
    void SetGrowGranularity(IN int n)  { m_nGrowBy = n; }
    void SetDestructorPolicy(IN int n) { m_nFlags = n; }   // auto_delete|no_delete
	int GetActualVarType( VARTYPE* pvt );
            
    SAFEARRAY *GetArrayCopy();                 // Returns a copy of the array
    SAFEARRAY *GetArray() { return m_pArray; }

    int TextDump(IN FILE *fStream);

	HRESULT Access( void** ppv )	{ return SafeArrayAccessData( m_pArray, ppv ); }
	HRESULT Unaccess( void )	{ return SafeArrayUnaccessData( m_pArray ); }
	int SetRawData( void* pvSource, int nNumElements, int nElementSize );
	int GetRawData( void* pvDest, int nBuffSize );
	void SetRawArrayMaxElement( int nMaxElement )	{ m_nMaxElementUsed = nMaxElement; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\ql_test.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    QL_TEST.CPP

Abstract:

    Test driver for Level 1 Syntax QL Parser

    Takes the filename of a file containing one or more WQL queries.  Writes
    the output to the console.

History:

    mdavis    23-Apr-99    Created from sql_test.cpp in Stdlibrary

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>


void xmain(int argc, char **argv)
{
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: ql_test WQL-query-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: ql_test WQL-query-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // get rid of newline
        char* ptr;
        if ((ptr = strchr(buf, '\n')) != NULL)
        {
            *ptr = '\0';
        }

        // get start of text
        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // ignore blank lines
        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            CTextLexSource src(buf2);
            QL1_Parser parser(&src);
            QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;

            // get the class (parse to WHERE clause)
            wchar_t classbuf[128];
            *classbuf = 0;
            printf("----GetQueryClass----\n");
            int nRes = parser.GetQueryClass(classbuf, 128);
            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                goto ContinueRead;
            }
            printf("Query class is %S\n", classbuf);

            // parse the rest of the query
            nRes = parser.Parse(&pExp);

            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                //goto ContinueRead;
            }
            else
            {
                printf("No errors.\n");
            }

            // call Dump function to display tokens and GetText function to show 
            // query passed to providers
            if (pExp)
            {
                pExp->Dump("CON");
                LPWSTR wszText = pExp->GetText();
                printf("--WQL passed to provider--\n");
                printf("%S\n", wszText);
                printf("----end of WQL----\n");
                delete [] wszText;
            }

ContinueRead:
            delete pExp;
            printf("%S\n", buf2);
            printf("=================================================EOL %d=======================================================\n", nLine);
        }
        nLine++;
    }

    if (ferror(f) != 0)
    {
        printf("\nError: line %d", nLine);
    }

    fclose(f);
}

void main(int argc, char **argv)
{
    xmain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\selfinst.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __WMI_SELFINST__H_
#define __WMI_SELFINST__H_

// BUGBUG
#define WMI_REPORT(X)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\safearry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.CPP

Abstract:

  CSafeArray implementation.

  Notes:
  (1) Support only for arrays with origin at 0 or 1.
      Can VB deal with a SAFEARRAY of origin zero?

  (2) Support only for the following OA types:
        VT_BSTR, VT_VARIANT,
        VT_UI1, VT_I2, VT_I4, VT_R8

History:

    08-Apr-96   a-raymcc    Created.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <safearry.h>
#include <arrtempl.h>
#include <olewrap.h>

typedef struct 
{
    DWORD m_nMaxElementUsed;
    DWORD m_nFlags;
    DWORD m_nGrowBy;
    DWORD m_nStatus;
    DWORD m_nVarType;
    SAFEARRAYBOUND m_bound;    
}   PersistHeaderBlock;


//***************************************************************************
//  
//  CSafeArray::CheckType
//
//  Verifies that the constructor is being invoked with a supported type.
//
//  PARAMETERS:
//  nTest
//      One of the supported OLE VT_ constants.
//
//***************************************************************************
void CSafeArray::CheckType(int nTest)
{
    if (nTest != VT_BSTR &&
        nTest != VT_VARIANT &&
        nTest != VT_UI1 &&
        nTest != VT_I2 &&
        nTest != VT_I4 &&
        nTest != VT_R4 &&
        nTest != VT_R8 &&
        nTest != VT_BOOL &&
        nTest != VT_DISPATCH &&
        nTest != VT_UNKNOWN        
        )
        Fatal("Caller attempted to use unsupported OLE Automation Type (VT_*)");
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor which creates a new SAFEARRAY.
//
//  PARAMETERS:
//  vt
//      An OLE VT_ type indicator, indicating the element type.
//  nFlags
//      The destruct policy, either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//  nSize
//      The initial size of the SAFEARRAY.
//  nGrowBy
//      The amount the SAFEARRAY should grow by when the user attempts to
//      add elements to a full array.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN int vt,
    IN int nFlags,
    IN int nSize,
    IN int nGrowBy
    )
{
    CheckType(vt);

    m_nMaxElementUsed = -1;
    m_nFlags = nFlags;
    m_nGrowBy = nGrowBy;
    m_nVarType = vt;

    // Allocate the array.
    // ===================

    m_bound.cElements = nSize;
    m_bound.lLbound = 0;

    m_pArray = COleAuto::_SafeArrayCreate((VARENUM) vt, 1, &m_bound);

    if (m_pArray == 0)
        m_nStatus = failed;
    else
        m_nStatus = no_error;

	m_nElementSize = SafeArrayGetElemsize( m_pArray );
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor based on an existing SAFEARRAY.
//
//  PARAMETERS:
//  pSrc
//      A pointer to an existing SAFEARRAY which is used as a source
//      during object construction.
//  nType
//      One of the OLE VT_ type indicators.
//  nFlags
//      OR'ed Bit flags indicating the bind vs. copy, and the 
//      object destruct policy.
//
//      The destruct policy is either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//
//      Binding is indicated by <bind>, in which case the SAFEARRAY
//      pointed to by <pSrc> becomes the internal SAFEARRAY of the
//      object.  Otherwise, this constructor makes a new copy of the
//      SAFEARRAY for internal use.
//  nGrowBy
//      How much to grow the array by when it fills and the user attempts
//      to add more elements.  This allows the array to grow in chunks
//      so that continuous Add() operations do not operate slowly on
//      large arrays.
//
//***********************************