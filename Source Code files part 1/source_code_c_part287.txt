= get_int64_arg(&argptr);
                else
#endif  /* _INTEGRAL_MAX_BITS >= 64        */

#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

#if _INTEGRAL_MAX_BITS >= 64
                if ( (flags & FL_I64) == 0 ) {
                    /*
                     * Unless printing a full 64-bit value, insure values
                     * here are not in cananical longword format to prevent
                     * the sign extended upper 32-bits from being printed.
                     */
                    number &= 0xffffffff;
                }
#endif  /* _INTEGRAL_MAX_BITS >= 64        */

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif


#if _INTEGRAL_MAX_BITS >= 64
LOCAL(__int64) get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif  /* _INTEGRAL_MAX_BITS >= 64    */

/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}


const wchar_t a_wcDigits[] = L"0123456789ABCDEF";

//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNum
//
//  Synopsis:   Given a value, and a count of characters, translate
//		the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//		[chChars] -- Number of characters to format
//		[pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    5-31-95   t-stevan  Copied and Modified for use in debug output function
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
	while(chChars--)
	{
		pchStr[chChars] = (char) a_wcDigits[ulValue & 0xF];
		ulValue = ulValue >> 4;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   StrFromGUID     (private)
//
//  Synopsis:   Converts a GUID into a string (duh!)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax)  // internal
{
    if (cbMax < OUTPUT_GUIDSTR_MAX)
	return 0;


//   Make the GUID into"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",

    *lpsz++ = '{';
    FormatHexNum( rguid->Data1, 8 , lpsz);
    lpsz += 8;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data2, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data3, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[0], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[1], 2 , lpsz);
    lpsz += 2;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[2], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[3], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[4], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[5], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[6], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[7], 2 , lpsz);
    lpsz += 2;

    *lpsz++ = '}';
    /* We don't want to tag on a NULL char because we don't need to print one out *\
    /* *lpsz = 0; */


    return OUTPUT_GUIDSTR_MAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\secret.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       secret.cxx
//
//  Contents:   Tiny object for wrapping creation & access to a 
//              guid "secret" for various uses.
//
//  History:    09-Oct-02   JSimmons      Created
//
//+-------------------------------------------------------------------------

#include <ole2int.h>
#include "secret.hxx"

CProcessSecret gProcessSecret;

// Definitions of statics
GUID CProcessSecret::s_guidOle32Secret = GUID_NULL;
BOOL CProcessSecret::s_fSecretInit = FALSE;
COleStaticMutexSem CProcessSecret::s_SecretLock;         // Prevent races on block init

HRESULT CProcessSecret::VerifyMatchingSecret(GUID guidOutsideSecret)
{
    GUID guidProcessSecret;

    HRESULT hr = GetProcessSecret(&guidProcessSecret);
    if (SUCCEEDED(hr))
    {
        hr = (guidProcessSecret == guidOutsideSecret) ? S_OK : E_INVALIDARG;
    }
    return hr;
}

HRESULT CProcessSecret::GetProcessSecret(GUID* pguidProcessSecret)
{
    HRESULT hr = S_OK;

    if (!s_fSecretInit)
    {
        COleStaticLock lock(s_SecretLock);
        if (!s_fSecretInit)
        {
            hr = CoCreateGuid(&s_guidOle32Secret);
            if (SUCCEEDED(hr))
            {
                s_fSecretInit = TRUE;	
            }
        }
    }

    if (s_fSecretInit)
    {
        *pguidProcessSecret = s_guidOle32Secret;
        Win4Assert(s_guidOle32Secret != GUID_NULL);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	proto.h
//
//  Contents:	File used to spoof idl generated h files. Used by NT1x and
//		Chicago builds.
//
//  History:	10-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"
#ifdef _W4DPRINTF_
#include "outfuncs.h"
#endif

#if defined(_W4PRINTF_)
    static HANDLE fh;
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == INVALID_HANDLE_VALUE)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = GetStdHandle(ldummy)) == 0 || fh == INVALID_HANDLE_VALUE)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        CallOutputFunctions(f->pchstart); // funnel through outfuncs
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\rwlock.cxx ===
//+-------------------------------------------------------------------
//
//  File:       RWLock.cxx
//
//  Contents:   Reader writer lock implementation that supports the
//              following features
//                  1. Cheap enough to be used in large numbers
//                     such as per object synchronization.
//                  2. Supports timeout. This is a valuable feature
//                     to detect deadlocks
//                  3. Supports caching of events. This allows
//                     the events to be moved from least contentious
//                     regions to the most contentious regions.
//                     In other words, the number of events needed by
//                     Reader-Writer lockls is bounded by the number
//                     of threads in the process.
//                  4. Supports nested locks by readers and writers
//                  5. Supports spin counts for avoiding context switches
//                     on  multi processor machines.
//                  6. Supports functionality for upgrading to a writer
//                     lock with a return argument that indicates
//                     intermediate writes. Downgrading from a writer
//                     lock restores the state of the lock.
//                  7. Supports functionality to Release Lock for calling
//                     app code. RestoreLock restores the lock state and
//                     indicates intermediate writes.
//                  8. Recovers from most common failures such as creation of
//                     events. In other words, the lock mainitains consistent
//                     internal state and remains usable
//
//
//  Classes:    CRWLock
//              CStaticRWLock
//
//  History:    19-Aug-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include "RWLock.hxx"

// Reader increment
#define READER                 0x00000001
// Max number of readers
#define READERS_MASK           0x000003FF
// Reader being signaled
#define READER_SIGNALED        0x00000400
// Writer being signaled
#define WRITER_SIGNALED        0x00000800
#define WRITER                 0x00001000
// Waiting reader increment
#define WAITING_READER         0x00002000
// Note size of waiting readers must be less
// than or equal to size of readers
#define WAITING_READERS_MASK   0x007FE000
#define WAITING_READERS_SHIFT  13
// Waiting writer increment
#define WAITING_WRITER         0x00800000
// Max number of waiting writers
#define WAITING_WRITERS_MASK   0xFF800000
// Events are being cached
#define CACHING_EVENTS         (READER_SIGNALED | WRITER_SIGNALED)

// Reader lock was upgraded
#define INVALID_COOKIE         0x01
#define UPGRADE_COOKIE         0x02
#define RELEASE_COOKIE         0x04
#define COOKIE_NONE            0x10
#define COOKIE_WRITER          0x20
#define COOKIE_READER          0x40

DWORD gdwDefaultTimeout = INFINITE;
DWORD gdwDefaultSpinCount = 0;
DWORD gdwNumberOfProcessors = 1;
DWORD gdwLockSeqNum = 0;
const DWORD gdwReasonableTimeout = 120000;
const DWORD gdwMaxReaders = READERS_MASK;
const DWORD gdwMaxWaitingReaders = (WAITING_READERS_MASK >> WAITING_READERS_SHIFT);

BOOL IsKDPresent()
{
    return USER_SHARED_DATA->KdDebuggerEnabled;
}

BOOL fBreakOnErrors ()
{
   return (IsDebuggerPresent() || IsKDPresent()); 
}

#ifdef __NOOLETLS__
DWORD gLockTlsIdx = -1;
#endif

#define RWLOCK_FATALFAILURE  1000
#define HEAP_SERIALIZE       0 

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::InitDefaults     public
//
//  Synopsis:   Reads default values from registry
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::InitDefaults()
{
    SYSTEM_INFO system;

    // Obtain number of processors on the system
    GetSystemInfo(&system);
    gdwNumberOfProcessors = system.dwNumberOfProcessors;
    gdwDefaultSpinCount = (gdwNumberOfProcessors > 1) ? 500 : 0;

    // Obtain system wide timeout value
    HKEY hKey;
    LONG lRetVal = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                 "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                                 NULL,
                                 KEY_READ,
                                 &hKey);
    if(lRetVal == ERROR_SUCCESS)
    {
        DWORD dwTimeout, dwSize = sizeof(dwTimeout);

        lRetVal = RegQueryValueExA(hKey,
                                   "CriticalSectionTimeout",
                                   NULL,
                                   NULL,
                                   (LPBYTE) &dwTimeout,
                                   &dwSize);
        if(lRetVal == ERROR_SUCCESS)
        {
            if (dwTimeout <= 1*24*60*60) // less than a day, usually ntstress case
            {
               gdwDefaultTimeout = dwTimeout * 20000; // 20 times the critsec timeout
            }
            // otherwise lock timeout is INFINITE.
        }
        RegCloseKey(hKey);
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::Cleanup    public
//
//  Synopsis:   Cleansup state
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::Cleanup()
{

#if DBG==1

    if (g_fDllState != DLL_STATE_PROCESS_DETACH)
    {
        // Perform sanity checks if we're not shutting down
        Win4Assert(_dwState == 0);
        Win4Assert(_dwWriterID == 0);
        Win4Assert(_wWriterLevel == 0);
    }
#endif

    if(_hWriterEvent)
        CloseHandle(_hWriterEvent);
    if(_hReaderEvent)
        CloseHandle(_hReaderEvent);

#if LOCK_PERF==1
    gLockTracker.ReportContention(this,
                                  _dwWriterEntryCount,
                                  _dwWriterContentionCount,
                                  _dwReaderEntryCount,
                                  _dwReaderContentionCount);
#endif

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertWriterLockHeld    public
//
//  Synopsis:   Asserts that writer lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertWriterLockHeld()
{
    DWORD dwThreadID = GetCurrentThreadId();

    if(_dwWriterID != dwThreadID)
        Win4Assert(!"Writer lock not held by the current thread");

    return(_dwWriterID == dwThreadID);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertWriterLockNotHeld    public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertWriterLockNotHeld()
{
    DWORD dwThreadID = GetCurrentThreadId();

    if(_dwWriterID == dwThreadID)
        Win4Assert(!"Writer lock held by the current thread");

    return(_dwWriterID != dwThreadID);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderLockHeld    public
//
//  Synopsis:   Asserts that reader lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertReaderLockHeld()
{
    HRESULT hr;
    WORD *pwReaderLevel;
    BOOL fLockHeld = FALSE;

    hr = GetTLSLockData(&pwReaderLevel);
    if((hr == S_OK) && (*pwReaderLevel != 0))
        fLockHeld = TRUE;

    if(fLockHeld == FALSE)
        Win4Assert(!"Reader lock not held by the current thread");

    return(fLockHeld);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderLockNotHeld    public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertReaderLockNotHeld()
{
    HRESULT hr;
    WORD *pwReaderLevel;
    BOOL fLockHeld = FALSE;

    hr = GetTLSLockData(&pwReaderLevel);
    if((hr == S_OK) && (*pwReaderLevel != 0))
        fLockHeld = TRUE;

    if(fLockHeld == TRUE)
        Win4Assert(!"Reader lock held by the current thread");

    return(fLockHeld == FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderOrWriterLockHeld   public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertReaderOrWriterLockHeld()
{
    BOOL fLockHeld = FALSE;

    if(_dwWriterID == GetCurrentThreadId())
    {
        fLockHeld = TRUE;
    }
    else
    {
        HRESULT hr;
        WORD *pwReaderLevel;

        hr = GetTLSLockData(&pwReaderLevel);
        if((hr == S_OK) && (*pwReaderLevel != 0))
            fLockHeld = TRUE;
    }

    Win4Assert(fLockHeld && "Neither Reader nor Writer lock held");

    return(fLockHeld);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ModifyState    public
//
//  Synopsis:   Helper function for updating the state inside the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline DWORD CRWLock::ModifyState(DWORD dwModifyState)
{
    return(InterlockedExchangeAdd((LONG *) &_dwState, dwModifyState));
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWSetEvent    public
//
//  Synopsis:   Helper function for setting an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWSetEvent(HANDLE event)
{
    if(!SetEvent(event))
    {
        Win4Assert(!"SetEvent failed");
        if(fBreakOnErrors())
            DebugBreak();
        TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWResetEvent    public
//
//  Synopsis:   Helper function for resetting an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWResetEvent(HANDLE event)
{
    if(!ResetEvent(event))
    {
        Win4Assert(!"ResetEvent failed");
        if(fBreakOnErrors())
            DebugBreak();
        TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
   }
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWSleep    public
//
//  Synopsis:   Helper function for calling Sleep. Useful for debugging
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWSleep(DWORD dwTime)
{
    Sleep(dwTime);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseEvents    public
//
//  Synopsis:   Helper function for caching events
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef RWLOCK_FULL_FUNCTIONALITY
void CRWLock::ReleaseEvents()
{
    // Sanity check
    Win4Assert(_wFlags & RWLOCKFLAG_CACHEEVENTS);

    // Ensure that reader and writers have been stalled
    Win4Assert((_dwState & CACHING_EVENTS) == CACHING_EVENTS);

    // Save writer event
    HANDLE hWriterEvent = _hWriterEvent;
    _hWriterEvent = NULL;

    // Save reader event
    HANDLE hReaderEvent = _hReaderEvent;
    _hReaderEvent = NULL;

    // Allow readers and writers to continue
    ModifyState(-(CACHING_EVENTS));

    // Cache events
    // REVIEW: I am closing events for now. What is needed
    //         is an event cache to which the events are
    //         released using InterlockedCompareExchange64
    if(hWriterEvent)
    {
        ComDebOut((DEB_TRACE, "Releasing writer event\n"));
        CloseHandle(hWriterEvent);
    }
    if(hReaderEvent)
    {
        ComDebOut((DEB_TRACE, "Releasing reader event\n"));
        CloseHandle(hReaderEvent);
    }

    return;
}
#endif

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetWriterEvent    public
//
//  Synopsis:   Helper function for obtaining a auto reset event used
//              for serializing writers. It utilizes event cache
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HANDLE CRWLock::GetWriterEvent()
{
    if(_hWriterEvent == NULL)
    {
        HANDLE hWriterEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(hWriterEvent)
        {
            if(InterlockedCompareExchangePointer(&_hWriterEvent, hWriterEvent, NULL))
            {
                CloseHandle(hWriterEvent);
            }
        }
    }

    return(_hWriterEvent);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetReaderEvent    public
//
//  Synopsis:   Helper function for obtaining a manula reset event used
//              by readers to wait when a writer holds the lock.
//              It utilizes event cache
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HANDLE CRWLock::GetReaderEvent()
{
    if(_hReaderEvent == NULL)
    {
        HANDLE hReaderEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if(hReaderEvent)
        {
            if(InterlockedCompareExchangePointer(&_hReaderEvent, hReaderEvent, NULL))
            {
                CloseHandle(hReaderEvent);
            }
        }
    }

    return(_hReaderEvent);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AcquireReaderLock    public
//
//  Synopsis:   Makes the thread a reader. Supports nested reader locks.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   BOOL fReturnErrors,
                                   DWORD dwDesiredTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   const char *pszFile,
                                   DWORD dwLine,
                                   const char *pszLockName
#endif
                                  )
{
    HRESULT hr;
#ifndef RWLOCK_FULL_FUNCTIONALITY
    DWORD dwDesiredTimeout = gdwDefaultTimeout;
#endif

    // Ensure that the lock was initialized
    if(!IsInitialized())
        Initialize();

    // Check if the thread already has writer lock
    if(_dwWriterID == GetCurrentThreadId())
    {
        hr = AcquireWriterLock();
    }
    else
    {
        WORD *pwReaderLevel;

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            if(*pwReaderLevel != 0)
            {
                ++(*pwReaderLevel);
            }
            else
            {
                DWORD dwCurrentState, dwKnownState;
                DWORD dwSpinCount;

                // Initialize
                hr = S_OK;
                dwSpinCount = 0;
                dwCurrentState = _dwState;
                do
                {
                    dwKnownState = dwCurrentState;

                    // Reader need not wait if there are only readers and no writer
                    if((dwKnownState < READERS_MASK) ||
                       (((dwKnownState & READER_SIGNALED) && ((dwKnownState & WRITER) == 0)) &&
                        (((dwKnownState & READERS_MASK) +
                          ((dwKnownState & WAITING_READERS_MASK) >> WAITING_READERS_SHIFT)) <=
                         (READERS_MASK - 2))))
                    {
                        // Add to readers
                        dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                    (dwKnownState + READER),
                                                                    dwKnownState);
                        if(dwCurrentState == dwKnownState)
                        {
                            // One more reader
                            break;
                        }
                    }
                    // Check for too many Readers, or waiting readers
                    else if(((dwKnownState & READERS_MASK) == READERS_MASK) ||
                            ((dwKnownState & WAITING_READERS_MASK) == WAITING_READERS_MASK) ||
                            ((dwKnownState & CACHING_EVENTS) == READER_SIGNALED))
                    {
                        RWSleep(1000);
                        dwSpinCount = 0;
                        dwCurrentState = _dwState;
                    }
                    // Check if events are being cached
#ifdef RWLOCK_FULL_FUNCTIONALITY
                    else if((dwKnownState & CACHING_EVENTS) == CACHING_EVENTS)
                    {
                        if(++dwSpinCount > gdwDefaultSpinCount)
                        {
                            RWSleep(10);
                            dwSpinCount = 0;
                        }
                        dwCurrentState = _dwState;
                    }
#endif
                    // Check spin count
                    else if(++dwSpinCount > gdwDefaultSpinCount)
                    {
                        // Add to waiting readers
                        dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                    (dwKnownState + WAITING_READER),
                                                                    dwKnownState);
                        if(dwCurrentState == dwKnownState)
                        {
                            HANDLE hReaderEvent;
                            DWORD dwStatus;
                            DWORD dwModifyState;
                            
                            // One more waiting reader
#ifdef RWLOCK_STATISTICS
                            InterlockedIncrement((LONG *) &_dwReaderContentionCount);
#endif
#if LOCK_PERF==1
                            gLockTracker.ReaderWaiting(pszFile, dwLine, pszLockName, this);
#endif
                            
                            hReaderEvent = GetReaderEvent();
                            if(hReaderEvent)
                            {
                                dwStatus = WaitForSingleObject(hReaderEvent, dwDesiredTimeout);
                            }
                            else
                            {
                                ComDebOut((DEB_WARN,
                                           "AcquireReaderLock failed to create reader "
                                           "event for RWLock 0x%x\n", this));
                                dwStatus = WAIT_FAILED;
                                hr = RPC_E_OUT_OF_RESOURCES;
                            }

                            if(dwStatus == WAIT_OBJECT_0)
                            {
                                Win4Assert(_dwState & READER_SIGNALED);
                                Win4Assert((_dwState & READERS_MASK) < READERS_MASK);
                                dwModifyState = READER - WAITING_READER;
                            }
                            else
                            {
                                dwModifyState = -WAITING_READER;
                                if(dwStatus == WAIT_TIMEOUT)
                                {
                                    ComDebOut((DEB_WARN,
                                               "Timed out trying to acquire reader lock "
                                               "for RWLock 0x%x\n", this));
                                    hr = RPC_E_TIMEOUT;
                                }
                                else if(SUCCEEDED(hr))
                                {
                                    ComDebOut((DEB_ERROR,
                                               "WaitForSingleObject Failed for "
                                               "RWLock 0x%x\n", this));
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                }
                            }

                            // One less waiting reader and he may have become a reader
                            dwKnownState = ModifyState(dwModifyState);

                            // Check for last signaled waiting reader
                            if(((dwKnownState & WAITING_READERS_MASK) == WAITING_READER) &&
                               (dwKnownState & READER_SIGNALED))
                            {
                                dwModifyState = -READER_SIGNALED;
                                if(dwStatus != WAIT_OBJECT_0)
                                {
                                    if(hReaderEvent == NULL)
                                        hReaderEvent = GetReaderEvent();
                                    Win4Assert(hReaderEvent);
                                    dwStatus = WaitForSingleObject(hReaderEvent, INFINITE);
                                    Win4Assert(dwStatus == WAIT_OBJECT_0);
                                    Win4Assert((_dwState & READERS_MASK) < READERS_MASK);
                                    dwModifyState += READER;
                                    hr = S_OK;
                                }

                                RWResetEvent(hReaderEvent);
                                dwKnownState = ModifyState(dwModifyState);
                            }

                            // Check if the thread became a reader
                            if(dwStatus == WAIT_OBJECT_0)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        dwCurrentState = _dwState;
                    }

                    if (RPC_E_TIMEOUT == hr) 
                    {
                        DbgPrint("%x:%x> Timed out trying to acquire reader lock 0x%p, WriterID = %x. Switch to the WriterID thread and examine why it is blocked.\n", 
                                 GetCurrentProcessId(), GetCurrentThreadId(), this, _dwWriterID);
#if DBG==1
                        _dwDeadLockCounter++;
#endif             
                        hr = S_OK;
                        if(fBreakOnErrors())
                            DebugBreak();
                    }
#ifdef _X86_
                    _asm { pause }
#endif
                } while(SUCCEEDED(hr));

                // Sanity checks
                if(SUCCEEDED(hr))
                {
                    Win4Assert((_dwState & WRITER) == 0);
                    Win4Assert(_dwState & READERS_MASK);
                    *pwReaderLevel = 1;
#ifdef RWLOCK_STATISTICS
                    InterlockedIncrement((LONG *) &_dwReaderEntryCount);
#endif
#if LOCK_PERF==1
                    gLockTracker.ReaderEntered(pszFile, dwLine, pszLockName, this);
#endif
                }
            }
        }
        
        // Check failure return
#if RWLOCK_FULL_FUNCTIONALITY
        if(FAILED(hr) && (fReturnErrors == FALSE))
#else
        if(FAILED(hr))
#endif
        {
            Win4Assert(!"Failed to acquire reader lock");
            if(fBreakOnErrors())
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }
    
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AcquireWriterLock    public
//
//  Synopsis:   Makes the thread a writer. Supports nested writer
//              locks
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::AcquireWriterLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   BOOL fReturnErrors,
                                   DWORD dwDesiredTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   const char *pszFile,
                                   DWORD dwLine,
                                   const char *pszLockName
#endif
                                  )
{
    HRESULT hr = S_OK;
    DWORD dwThreadID = GetCurrentThreadId();
#ifndef RWLOCK_FULL_FUNCTIONALITY
    DWORD dwDesiredTimeout = gdwDefaultTimeout;
#endif

    // Ensure that the lock was initialized
    if(!IsInitialized())
        Initialize();

    // Check if the thread already has writer lock
    if(_dwWriterID == dwThreadID)
    {
        ++_wWriterLevel;
    }
    else
    {
        DWORD dwCurrentState, dwKnownState;
        DWORD dwSpinCount = 0;
        
        dwCurrentState = _dwState;
        do
        {
            dwKnownState = dwCurrentState;
            
            // Writer need not wait if there are no readers and writer
            if(dwKnownState == 0)
            {
                // Can be a writer
                dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                            WRITER,
                                                            dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    // Only writer
                    break;
                }
            }
            // Check for too many waiting writers
            else if(((dwKnownState & WAITING_WRITERS_MASK) == WAITING_WRITERS_MASK))
            {
                RWSleep(1000);
                dwSpinCount = 0;
                dwCurrentState = _dwState;
            }
            // Check if events are being cached
#ifdef RWLOCK_FULL_FUNCTIONALITY
            else if((dwKnownState & CACHING_EVENTS) == CACHING_EVENTS)
            {
                if(++dwSpinCount > gdwDefaultSpinCount)
                {
                    RWSleep(10);
                    dwSpinCount = 0;
                }
                dwCurrentState = _dwState;
            }
#endif
            // Check spin count
            else if(++dwSpinCount > gdwDefaultSpinCount)
            {
                // Add to waiting writers
                dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                            (dwKnownState + WAITING_WRITER),
                                                            dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    HANDLE hWriterEvent;
                    DWORD dwStatus;
                    DWORD dwModifyState;
                    BOOL fLoopback;
                    
                    // One more waiting writer
#ifdef RWLOCK_STATISTICS
                    InterlockedIncrement((LONG *) &_dwWriterContentionCount);
#endif
#if LOCK_PERF==1
                    gLockTracker.WriterWaiting(pszFile, dwLine, pszLockName, this);
#endif
                    do
                    {
                        fLoopback = FALSE;
                        hr = S_OK;
                        hWriterEvent = GetWriterEvent();
                        if(hWriterEvent)
                        {
                            dwStatus = WaitForSingleObject(hWriterEvent, dwDesiredTimeout);
                        }
                        else
                        {
                            ComDebOut((DEB_WARN,
                                       "AcquireWriterLock failed to create writer "
                                       "event for RWLock 0x%x\n", this));
                            dwStatus = WAIT_FAILED;
                            hr = RPC_E_OUT_OF_RESOURCES;
                        }
                        
                        if(dwStatus == WAIT_OBJECT_0)
                        {
                            Win4Assert(_dwState & WRITER_SIGNALED);
                            dwModifyState = WRITER - WAITING_WRITER - WRITER_SIGNALED;
                        }
                        else
                        {
                            dwModifyState = -WAITING_WRITER;
                            if(dwStatus == WAIT_TIMEOUT)
                            {
                                ComDebOut((DEB_WARN,
                                           "Timed out trying to acquire writer "
                                           "lock for RWLock 0x%x\n", this));
                                hr = RPC_E_TIMEOUT;
                            }
                            else if(SUCCEEDED(hr))
                            {
                                ComDebOut((DEB_ERROR,
                                           "WaitForSingleObject Failed for "
                                           "RWLock 0x%x\n", this));
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }

                        // One less waiting writer and he may have become a writer
                        dwKnownState = ModifyState(dwModifyState);
                        
                        // Check for last timing out signaled waiting writer
                        if((dwStatus != WAIT_OBJECT_0) &&
                           (dwKnownState & WRITER_SIGNALED) &&
                           ((dwKnownState & WAITING_WRITERS_MASK) == WAITING_WRITER))
                        {
                            fLoopback = TRUE;
                            dwCurrentState = _dwState;
                            do
                            {
                                dwKnownState = dwCurrentState;
                                if(((dwKnownState & WAITING_WRITERS_MASK) == 0) &&
                                   (dwKnownState & WRITER_SIGNALED))
                                {
                                    dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                                (dwKnownState + WAITING_WRITER),
                                                                                dwKnownState);
                                }
                                else
                                {
                                    Win4Assert(FAILED(hr));
                                    fLoopback = FALSE;
                                    break;
                                }
#ifdef _X86_
                                // Try to avoid pausing when we won't loop.
                                if (dwCurrentState != dwKnownState)
                                {
                                    _asm { pause }
                                }
#endif
                            } while(dwCurrentState != dwKnownState);
                        }

                        if(fLoopback)
                        {
                            ComDebOut((DEB_WARN,
                                       "Retry of timing out writer for RWLock 0x%x\n",
                                       this));
                            // Reduce the timeout value for retries
                            dwDesiredTimeout = 100;
                        }
                    } while(fLoopback);

                    // Check if the thread became a writer
                    if(dwStatus == WAIT_OBJECT_0)
                        break;
                }
            }
            else
            {
                dwCurrentState = _dwState;
            }

            if (RPC_E_TIMEOUT == hr) 
            {
                DbgPrint("%x:%x> Timed out trying to acquire writer lock 0x%p, WriterID = %x. If WriterID is not zero, switch to the WriterID thread and examine why it is blocked.\n ", 
                         GetCurrentProcessId(), GetCurrentThreadId(), this, _dwWriterID);
#if DBG==1
                _dwDeadLockCounter++;
#endif             
                hr = S_OK;
                if(fBreakOnErrors())
                    DebugBreak();
            }

#ifdef _X86_
            _asm { pause }
#endif
        } while(SUCCEEDED(hr));
        
        // Sanity checks
        if(SUCCEEDED(hr))
        {
            Win4Assert(_dwState & WRITER);
            Win4Assert((_dwState & WRITER_SIGNALED) == 0);
            Win4Assert((_dwState & READERS_MASK) == 0);
            Win4Assert(_dwWriterID == 0);
            
            // Save threadid of the writer
            _dwWriterID = dwThreadID;
            _wWriterLevel = 1;
            ++_dwWriterSeqNum;
#ifdef RWLOCK_STATISTICS
            ++_dwWriterEntryCount;
#endif
#if LOCK_PERF==1
            gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this);
#endif
        }
#ifdef RWLOCK_FULL_FUNCTIONALITY
        else if(fReturnErrors == FALSE)
#else
        else
#endif
        {
            Win4Assert(!"Failed to acquire writer lock");
            if(fBreakOnErrors())
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseWriterLock    public
//
//  Synopsis:   Removes the thread as a writer if not a nested
//              call to release the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::ReleaseWriterLock()
{
    HRESULT hr = S_OK;
    DWORD dwThreadID = GetCurrentThreadId();

    // Check validity of caller
    if(_dwWriterID == dwThreadID)
    {
        // Sanity check
        Win4Assert(IsInitialized());

        // Check for nested release
        if(--_wWriterLevel == 0)
        {
            DWORD dwCurrentState, dwKnownState, dwModifyState;
            BOOL fCacheEvents;
            HANDLE hReaderEvent = NULL, hWriterEvent = NULL;

            // Not a writer any more
#if LOCK_PERF==1
            gLockTracker.WriterLeaving(this);
#endif
            _dwWriterID = 0;
            dwCurrentState = _dwState;
            do
            {
                dwKnownState = dwCurrentState;
                dwModifyState = -WRITER;
                fCacheEvents = FALSE;
                if(dwKnownState & WAITING_READERS_MASK)
                {
                    hReaderEvent = GetReaderEvent();
                    if(hReaderEvent == NULL)
                    {
                        ComDebOut((DEB_WARN,
                                   "ReleaseWriterLock failed to create "
                                   "reader event for RWLock 0x%x\n", this));
                        RWSleep(100);
                        dwCurrentState = _dwState;
                        dwKnownState = 0;
                        Win4Assert(dwCurrentState != dwKnownState);
#ifdef _X86_
                        _asm { pause }
#endif
                        continue;
                    }
                    dwModifyState += READER_SIGNALED;
                }
                else if(dwKnownState & WAITING_WRITERS_MASK)
                {
                    hWriterEvent = GetWriterEvent();
                    if(hWriterEvent == NULL)
                    {
                        ComDebOut((DEB_WARN,
                                   "ReleaseWriterLock failed to create "
                                   "writer event for RWLock 0x%x\n", this));
                        RWSleep(100);
                        dwCurrentState = _dwState;
                        dwKnownState = 0;
                        Win4Assert(dwCurrentState != dwKnownState);
#ifdef _X86_
                        _asm { pause }
#endif
                        continue;
                    }
                    dwModifyState += WRITER_SIGNALED;
                }
#ifdef RWLOCK_FULL_FUNCTIONALITY
                else if((_wFlags & RWLOCKFLAG_CACHEEVENTS) &&
                        (dwKnownState == WRITER) &&
                        (_hReaderEvent || _hWriterEvent) &&
                        ((dwKnownState & CACHING_EVENTS) == 0))
                {
                    fCacheEvents = TRUE;
                    dwModifyState += CACHING_EVENTS;
                }
#endif

                // Sanity checks
                Win4Assert((dwKnownState & CACHING_EVENTS) == 0);
                Win4Assert((dwKnownState & READERS_MASK) == 0);

                dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                            (dwKnownState + dwModifyState),
                                                            dwKnownState);
#ifdef _X86_
                _asm { pause }
#endif
            } while(dwCurrentState != dwKnownState);

            // Check for waiting readers
            if(dwKnownState & WAITING_READERS_MASK)
            {
                Win4Assert(_dwState & READER_SIGNALED);
                Win4Assert(hReaderEvent);
                RWSetEvent(hReaderEvent);
            }
            // Check for waiting writers
            else if(dwKnownState & WAITING_WRITERS_MASK)
            {
                Win4Assert(_dwState & WRITER_SIGNALED);
                Win4Assert(hWriterEvent);
                RWSetEvent(hWriterEvent);
            }
#ifdef RWLOCK_FULL_FUNCTIONALITY
            // Check for the need to release events
            else if(fCacheEvents)
            {
                ReleaseEvents();
            }
#endif
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
        Win4Assert(!"Attempt to release writer lock on a wrong thread");
#ifdef RWLOCK_FULL_FUNCTIONALITY
        if((_wFlags & RWLOCKFLAG_RETURNERRORS) == 0)
#endif
        {
            if(fBreakOnErrors())
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseReaderLock    public
//
//  Synopsis:   Removes the thread as a reader
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::ReleaseReaderLock()
{
    HRESULT hr = S_OK;

    // Check if the thread has writer lock
    if(_dwWriterID == GetCurrentThreadId())
    {
        hr = ReleaseWriterLock();
    }
    else
    {
        WORD *pwReaderLevel;

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            if(*pwReaderLevel > 1)
            {
                --(*pwReaderLevel);
            }
            else if(*pwReaderLevel == 1)
            {
                DWORD dwCurrentState, dwKnownState, dwModifyState;
                BOOL fLastReader, fCacheEvents;
                HANDLE hReaderEvent = NULL, hWriterEvent = NULL;

                // Sanity checks
                Win4Assert((_dwState & WRITER) == 0);
                Win4Assert(_dwState & READERS_MASK);

                // Not a reader any more
                *pwReaderLevel = 0;
                dwCurrentState = _dwState;
                do
                {
                    dwKnownState = dwCurrentState;
                    dwModifyState = -READER;
                    if((dwKnownState & (READERS_MASK | READER_SIGNALED)) == READER)
                    {
                        fLastReader = TRUE;
                        fCacheEvents = FALSE;
                        if(dwKnownState & WAITING_WRITERS_MASK)
                        {
                            hWriterEvent = GetWriterEvent();
                            if(hWriterEvent == NULL)
                            {
                                ComDebOut((DEB_WARN,
                                           "ReleaseReaderLock failed to create "
                                           "writer event for RWLock 0x%x\n", this));
                                RWSleep(100);
                                dwCurrentState = _dwState;
                                dwKnownState = 0;
                                Win4Assert(dwCurrentState != dwKnownState);
#ifdef _X86_
                                _asm { pause }
#endif
                                continue;
                            }
                            dwModifyState += WRITER_SIGNALED;
                        }
                        else if(dwKnownState & WAITING_READERS_MASK)
                        {
                            hReaderEvent = GetReaderEvent();
                            if(hReaderEvent == NULL)
                            {
                                ComDebOut((DEB_WARN,
                                           "ReleaseReaderLock failed to create "
                                           "reader event\n", this));
                                RWSleep(100);
                                dwCurrentState = _dwState;
                                dwKnownState = 0;
                                Win4Assert(dwCurrentState != dwKnownState);
#ifdef _X86_
                                _asm { pause }
#endif
                                continue;
                            }
                            dwModifyState += READER_SIGNALED;
                        }
#ifdef RWLOCK_FULL_FUNCTIONALITY
                        else if((_wFlags & RWLOCKFLAG_CACHEEVENTS) &&
                                (dwKnownState == READER) &&
                                (_hReaderEvent || _hWriterEvent))
                        {
                            fCacheEvents = TRUE;
                            dwModifyState += (WRITER_SIGNALED + READER_SIGNALED);
                        }
#endif
                    }
                    else
                    {
                        fLastReader = FALSE;
                    }

                    // Sanity checks
                    Win4Assert((dwKnownState & WRITER) == 0);
                    Win4Assert(dwKnownState & READERS_MASK);

                    dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                (dwKnownState + dwModifyState),
                                                                dwKnownState);

#ifdef _X86_
                    // Try to avoid pausing when we won't loop.
                    if (dwCurrentState != dwKnownState)
                    {
                        _asm { pause }
                    }
#endif
                } while(dwCurrentState != dwKnownState);

#if LOCK_PERF==1
                gLockTracker.ReaderLeaving(this);
#endif
                // Check for last reader
                if(fLastReader)
                {
                    // Check for waiting writers
                    if(dwKnownState & WAITING_WRITERS_MASK)
                    {
                        Win4Assert(_dwState & WRITER_SIGNALED);
                        Win4Assert(hWriterEvent);
                        RWSetEvent(hWriterEvent);
                    }
                    // Check for waiting readers
                    else if(dwKnownState & WAITING_READERS_MASK)
                    {
                        Win4Assert(_dwState & READER_SIGNALED);
                        Win4Assert(hReaderEvent);
                        RWSetEvent(hReaderEvent);
                    }
#ifdef RWLOCK_FULL_FUNCTIONALITY
                    // Check for the need to release events
                    else if(fCacheEvents)
                    {
                        ReleaseEvents();
                    }
#endif
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
        }

        if(FAILED(hr))
        {
#ifdef RWLOCK_FULL_FUNCTIONALITY
            if((_wFlags & RWLOCKFLAG_RETURNERRORS) == 0)
#endif
            {
                Win4Assert(!"Attempt to release reader lock on a wrong thread");
                if(fBreakOnErrors())
                    DebugBreak();
                TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
            }
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::UpgradeToWriterLock    public
//
//  Synopsis:   Upgrades to a writer lock. It returns a BOOL that
//              indicates intervening writes.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::UpgradeToWriterLock(LockCookie *pLockCookie,
                                     BOOL *pfInterveningWrites
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                     ,
                                     BOOL fReturnErrors,
                                     DWORD dwDesiredTimeout
#endif
#if LOCK_PERF==1
                                     ,
                                     const char *pszFile,
                                     DWORD dwLine,
                                     const char *pszLockName
#endif
                                     )
{
    HRESULT hr;
    DWORD dwThreadID;

    // Initialize the cookie
    memset(pLockCookie, 0, sizeof(LockCookie));
    if(pfInterveningWrites)
        *pfInterveningWrites = TRUE;
    dwThreadID = GetCurrentThreadId();

    // Check if the thread is already a writer
    if(_dwWriterID == dwThreadID)
    {
        // Update cookie state
        pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_WRITER;
        pLockCookie->wWriterLevel = _wWriterLevel;
        
        // No intevening writes
        if(pfInterveningWrites)
            *pfInterveningWrites = FALSE;
        
        // Acquire the writer lock again
        hr = AcquireWriterLock();
    }
    else
    {
        WORD *pwReaderLevel;

        // Ensure that the lock was initialized
        if(!IsInitialized())
            Initialize();

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            BOOL fAcquireWriterLock;
            DWORD dwWriterSeqNum = 0;

            // Check if the thread is a reader
            if(*pwReaderLevel != 0)
            {
                // Sanity check
                Win4Assert(_dwState & READERS_MASK);

                // Save lock state in the cookie
                pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_READER;
                pLockCookie->pwReaderLevel = pwReaderLevel;
                pLockCookie->wReaderLevel = *pwReaderLevel;

                // If there is only one reader, try to convert reader to a writer
                DWORD dwKnownState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                WRITER,
                                                                READER);
                if(dwKnownState == READER)
                {
                    // Thread is no longer a reader
                    *pwReaderLevel = 0;

                    // Save threadid of the writer
                    _dwWriterID = dwThreadID;
                    _wWriterLevel = 1;
                    ++_dwWriterSeqNum;
                    fAcquireWriterLock = FALSE;

                    // No intevening writes
                    if(pfInterveningWrites)
                        *pfInterveningWrites = FALSE;
#if RWLOCK_STATISTICS
                    ++_dwWriterEntryCount;
#endif
#if LOCK_PERF==1
                    gLockTracker.ReaderLeaving(this);
                    gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this);
#endif
                }
                else
                {
                    // Note the current sequence number of the writer lock
                    dwWriterSeqNum = _dwWriterSeqNum;

                    // Release the reader lock
                    *pwReaderLevel = 1;
                    hr = ReleaseReaderLock();
                    Win4Assert(SUCCEEDED(hr));
                    fAcquireWriterLock = TRUE;
                }
            }
            else
            {
                fAcquireWriterLock = TRUE;
                pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_NONE;
            }

            // Check for the need to acquire the writer lock
            if(fAcquireWriterLock)
            {
                hr = AcquireWriterLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                       TRUE, dwDesiredTimeout
#if LOCK_PERF==1
                                       ,
#endif
#endif
#if LOCK_PERF==1
                                       pszFile, dwLine, pszLockName
#endif
                                      );
                if(SUCCEEDED(hr))
                {
                    // Check for intevening writes
                    if((_dwWriterSeqNum == (dwWriterSeqNum + 1)) &&
                       pfInterveningWrites)
                        *pfInterveningWrites = FALSE;
                }
                else
                {
                    if(pLockCookie->dwFlags & COOKIE_READER)
                    {
#ifdef RWLOCK_FULL_FUNCTIONALITY
                        DWORD dwTimeout = (dwDesiredTimeout > gdwReasonableTimeout)
                                          ? dwDesiredTimeout
                                          : gdwReasonableTimeout;
#endif

                        HRESULT hr1 = AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                                        FALSE, dwTimeout
#if LOCK_PERF==1
                                                        ,
#endif
#endif
#if LOCK_PERF==1
                                                        pszFile, dwLine, pszLockName
#endif
                                                       );
                        if(SUCCEEDED(hr1))
                        {
                            *pwReaderLevel = pLockCookie->wReaderLevel;
                        }
                        else
                        {
                            Win4Assert(!"Failed to reacquire reader lock");
                            if(fBreakOnErrors())
                                DebugBreak();
                            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
                        }
                    }
                }
            }
        }
    }

    // Check failure return
    if(FAILED(hr))
    {
        pLockCookie->dwFlags = INVALID_COOKIE;
#ifdef RWLOCK_FULL_FUNCTIONALITY
        if(fReturnErrors == FALSE)
        {
            Win4Assert(!"Failed to upgrade the lock");
            if(fBreakOnErrors())
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
#endif
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::DowngradeFromWriterLock   public
//
//  Synopsis:   Downgrades from a writer lock.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::DowngradeFromWriterLock(LockCookie *pLockCookie
#if LOCK_PERF==1
                                         ,
                                         const char *pszFile,
                                         DWORD dwLine,
                                         const char *pszLockName
#endif
                                        )
{
    HRESULT hr = S_OK;

    // Ensure that the cookie is valid
    if(pLockCookie->dwFlags & UPGRADE_COOKIE)
    {
        DWORD dwThreadID = GetCurrentThreadId();

        // Sanity check
        Win4Assert((pLockCookie->pwReaderLevel == NULL) ||
                   (*pLockCookie->pwReaderLevel == 0));

        // Ensure that the thread is a writer
        if(_dwWriterID == dwThreadID)
        {
            // Release the writer lock
            hr = ReleaseWriterLock();
            if(SUCCEEDED(hr))
            {
                // Check if the thread was a writer
                if(_dwWriterID == dwThreadID)
                {
                    // Ensure that the thread was a writer and that
                    // nesting level was restored to the previous
                    // value
                    if(((pLockCookie->dwFlags & COOKIE_WRITER) == 0) ||
                       (pLockCookie->wWriterLevel != _wWriterLevel))
                    {
                        Win4Assert(!"Writer lock incorrectly nested");
                        hr = E_FAIL;
                    }
                }
                // Check if the thread was a reader
                else if(pLockCookie->dwFlags & COOKIE_READER)
                {
#ifdef RWLOCK_FULL_FUNCTIONALITY
                    DWORD dwTimeout = (gdwDefaultTimeout > gdwReasonableTimeout)
                                      ? gdwDefaultTimeout
                                      : gdwReasonableTimeout;
#endif
                    hr = AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                           TRUE, dwTimeout
#if LOCK_PERF==1
                                           ,
#endif
#endif
#if LOCK_PERF==1
                                           pszFile, dwLine, pszLockName
#endif
                                          );
                    if(SUCCEEDED(hr))
                    {
                        *pLockCookie->pwReaderLevel = pLockCookie->wReaderLevel;
                    }
                    else
                    {
                        Win4Assert(!"Failed to reacquire reader lock");
                    }
                }
                else
                {
                    Win4Assert(pLockCookie->dwFlags & COOKIE_NONE);
                }
            }
        }
        else
        {
            Win4Assert(!"Attempt to downgrade writer lock on a wrong thread");
            hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
        }

        // Check failure return
        if(FAILED(hr))
        {
            if(fBreakOnErrors())
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseLock    public
//
//  Synopsis:   Releases the lock held by the current thread
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::ReleaseLock(LockCookie *pLockCookie)
{
    HRESULT hr;

    // Initialize the cookie
    memset(pLockCookie, 0, sizeof(LockCookie));

    // Check if the thread is a writer
    if(_dwWriterID == GetCurrentThreadId())
    {
        // Save lock state in the cookie
        pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_WRITER;
        pLockCookie->dwWriterSeqNum = _dwWriterSeqNum;
        pLockCookie->wWriterLevel = _wWriterLevel;

        // Release the writer lock
        _wWriterLevel = 1;
        hr = ReleaseWriterLock();
        Win4Assert(SUCCEEDED(hr));
    }
    else
    {
        WORD *pwReaderLevel;

        // Ensure that the lock was initialized
        if(!IsInitialized())
            Initialize();

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            // Check if the thread is a reader
            if(*pwReaderLevel != 0)
            {
                // Save lock state in the cookie
                pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_READER;
                pLockCookie->pwReaderLevel = pwReaderLevel;
                pLockCookie->wReaderLevel = *pwReaderLevel;
                pLockCookie->dwWriterSeqNum = _dwWriterSeqNum;

                // Release the reader lock
                *pwReaderLevel = 1;
                hr = ReleaseReaderLock();
                Win4Assert(SUCCEEDED(hr));
            }
            else
            {
                pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_NONE;
            }
        }
        else
        {
            hr = S_OK;
            pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_NONE;
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RestoreLock    public
//
//  Synopsis:   Restore the lock held by the current thread
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::RestoreLock(LockCookie *pLockCookie,
                             BOOL *pfInterveningWrites
#if LOCK_PERF==1
                             ,
                             const char *pszFile,
                             DWORD dwLine,
                             const char *pszLockName
#endif
                            )
{
    HRESULT hr = S_OK;

    // Initialize
    if(pfInterveningWrites)
        *pfInterveningWrites = TRUE;

    // Ensure that the cookie is valid
    if(pLockCookie->dwFlags & RELEASE_COOKIE)
    {
        DWORD dwThreadID = GetCurrentThreadId();
#ifdef RWLOCK_FULL_FUNCTIONALITY
        DWORD dwTimeout = (gdwDefaultTimeout > gdwReasonableTimeout)
                          ? gdwDefaultTimeout
                          : gdwReasonableTimeout;
#endif

        // Check if the thread holds reader or writer lock
        if(((pLockCookie->pwReaderLevel != NULL) && (*pLockCookie->pwReaderLevel > 0)) ||
           (_dwWriterID == dwThreadID))
        {
            Win4Assert(!"Thread holds reader or writer lock");
        if(fBreakOnErrors())
        DebugBreak();
        TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
        // Check if the thread was a writer
        else if(pLockCookie->dwFlags & COOKIE_WRITER)
        {
            // Acquire writer lock
            hr = AcquireWriterLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   FALSE, dwTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   pszFile, dwLine, pszLockName
#endif
                                  );
            Win4Assert(SUCCEEDED(hr));
            _wWriterLevel = pLockCookie->wWriterLevel;
            if((_dwWriterSeqNum == (pLockCookie->dwWriterSeqNum + 1)) &&
               pfInterveningWrites)
                *pfInterveningWrites = FALSE;
        }
        // Check if the thread was a reader
        else if(pLockCookie->dwFlags & COOKIE_READER)
        {
            hr = AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   FALSE, dwTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   pszFile, dwLine, pszLockName
#endif
                                  );
            Win4Assert(SUCCEEDED(hr));
            *pLockCookie->pwReaderLevel = pLockCookie->wReaderLevel;
            if((_dwWriterSeqNum == (pLockCookie->dwWriterSeqNum + 1)) &&
               pfInterveningWrites)
                *pfInterveningWrites = FALSE;
        }
        else
        {
            Win4Assert(pLockCookie->dwFlags & COOKIE_NONE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticRWLock::Initialize     public
//
//  Synopsis:   Initializes state. It is important that the
//              default constructor only Zero out the memory
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
extern CRITICAL_SECTION g_OleMutexCreationSem;
void CStaticRWLock::Initialize()
{
    // Acquire lock creation critical section
    EnterCriticalSection (&g_OleMutexCreationSem);

    // Prevent second initialization
    if(!IsInitialized())
    {
        _dwLockNum = gdwLockSeqNum++;
#if LOCK_PERF==1
        gLockTracker.RegisterLock(this, TRUE);
#endif

        // The initialization should be complete
        // before delegating to the base class
        CRWLock::Initialize();
    }

    // Release lock creation critical section
    LeaveCriticalSection (&g_OleMutexCreationSem);

    return;
}


LockEntry * GetLockEntryFromTLS()
{
    LockEntry *pLockEntry = NULL;
#ifdef __NOOLETLS__
    pLockEntry = (LockEntry *) TlsGetValue(gLockTlsIdx);
    if (!pLockEntry)
    {
        pLockEntry = (LockEntry *) PrivMemAlloc(sizeof(LockEntry));
        if (pLockEntry)
        {
            memset(pLockEntry, 0, sizeof(LockEntry));
            TlsSetValue(gLockTlsIdx, pLockEntry);
        }

    }
#else
    HRESULT hr;
    COleTls Tls(hr);

    if(SUCCEEDED(hr))
    {
        pLockEntry = &(Tls->lockEntry);
    }
#endif
    return pLockEntry;
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticRWLock::GetTLSLockData     private
//
//  Synopsis:   Obtains the data mainitained in TLS for the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStaticRWLock::GetTLSLockData(WORD **ppwReaderLevel)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Ensure that the lock was initialized
    if(IsInitialized())
    {
        LockEntry *pLockEntry = GetLockEntryFromTLS();
        if (pLockEntry)
        {
            // Compute the quotient and remainder
            DWORD dwSkip = _dwLockNum / LOCKS_PER_ENTRY;
            DWORD dwIndex = _dwLockNum % LOCKS_PER_ENTRY;


            // Skip quotient entries
            while(dwSkip && pLockEntry)
            {
                // Allocate the lock entries if needed
                if(pLockEntry->pNext == NULL)
                {
                    LockEntry *pEntry;
                    pEntry = (LockEntry *) PrivMemAlloc(sizeof(LockEntry));
                    if(pEntry)
                    {
                        memset(pEntry, 0 , sizeof(LockEntry));
                        pEntry = (LockEntry *) InterlockedCompareExchangePointer((void **) &(pLockEntry->pNext),
                                                                                 pEntry,
                                                                                 NULL);
                        if(pEntry)
                            PrivMemFree(pEntry);
                    }
                }

                // Skip to next lock entry
                pLockEntry = pLockEntry->pNext;
                --dwSkip;
            }

            // Check for OOM
            if(pLockEntry)
            {
                *ppwReaderLevel = &(pLockEntry->wReaderLevel[dwIndex]);
                hr = S_OK;
            }
            else
            {
                *ppwReaderLevel = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        *ppwReaderLevel = NULL;
        hr = S_FALSE;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF


TARGETNAME=   common
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\ih;..;..\..\com\inc;\
              ..\..\idl\public\$(DEST_TREE)\$(O);\
              ..\..\idl\internal\$(DEST_TREE)\$(O);\
              ..\..\idl\private\$(DEST_TREE)\$(O);\
              $(BASE_INC_PATH)

C_DEFINES=    \
              $(C_DEFINES) \
              /D_TRACKLINK_=1

SOURCES=      \
              ..\assert.cxx   \
              ..\ccompapi.cxx \
              ..\dprintf.c    \
              ..\eqguid.cxx   \
              ..\lockperf.cxx \
              ..\olesem.cxx   \
              ..\output.c     \
              ..\printf.c     \
              ..\sprintf.c    \
              ..\buffer.cxx   \
              ..\oleprint.cxx \
              ..\oletype.cxx  \
              ..\dynload.cxx  \
              ..\catinit.cxx  \
              ..\outfuncs.c   \
              ..\trace.cxx    \
              ..\olescm.cxx   \
              ..\secret.cxx   \
              ..\stdcf.cxx    \
              ..\comsrgt.cxx  \
              ..\stdidx.cxx

UMTYPE=       windows
NTTARGETFILES=all_common
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\stdidx.cxx ===
#include <ole2int.h>
#include <stdidx.h>

const IID IID_IRemUnknown = {0x00000131,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern "C" BOOL IsInterfaceImplementedByProxy(REFIID riid)
{
    return (
            InlineIsEqualGUID(riid, IID_IMarshal)           ||
            InlineIsEqualGUID(riid, IID_IMarshal2)          ||
            InlineIsEqualGUID(riid, IID_IMultiQI)           ||
            InlineIsEqualGUID(riid, IID_IRemUnknown)        ||
            InlineIsEqualGUID(riid, IID_IClientSecurity)    ||
            InlineIsEqualGUID(riid, IID_ICallFactory)       ||
            InlineIsEqualGUID(riid, IID_IStdIdentity)       ||
            InlineIsEqualGUID(riid, IID_IServerSecurity)    ||
            InlineIsEqualGUID(riid, IID_IRpcOptions)        ||
            InlineIsEqualGUID(riid, IID_IProxyManager)      ||
            InlineIsEqualGUID(riid, IID_IInternalUnknown)
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\stdcf.cxx ===
//+-------------------------------------------------------------------
//
//  File:       stdcf.cxx
//
//  Contents:   class implementing standard CF for internal OLE classes
//
//  Classes:    CStdClassFactory
//
//  History:    Rickhi      06-24-97    Created
//
//+-------------------------------------------------------------------
#include <ole2int.h>
#include <stdcf.hxx>

// CreateInstance functions for each of the internal classes.
extern HRESULT CGIPTableCF_CreateInstance        (IUnknown *pUnkOuter, REFIID riid, void **ppv);
extern HRESULT CAccessControlCF_CreateInstance   (IUnknown *pUnkOuter, REFIID riid, void **ppv);
extern HRESULT CAsyncActManagerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void **ppv);
extern HRESULT CComCatCF_CreateInstance          (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CComCatCSCF_CreateInstance        (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CItemMonikerCF_CreateInstance     (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CCompositeMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CPackagerMonikerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CAntiMonikerCF_CreateInstance     (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CPointerMonikerCF_CreateInstance  (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CErrorObjectCF_CreateInstance     (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CRpcHelperCF_CreateInstance       (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CObjectContextCF_CreateInstance   (IUnknown *pUnkOuter, REFIID riid, void** ppv);

extern HRESULT CComCatalogCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);

extern HRESULT CStdEventCF_CreateInstance              (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CManualResetEventCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CSynchronizeContainerCF_CreateInstance  (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CFreeThreadedMarshalerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);

extern HRESULT CActivationPropertiesInCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CActivationPropertiesOutCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CInprocActpropsUnmarshallerCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CComActivatorCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CAddrControlCF_CreateInstance       (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CStackWalkerCF_CreateInstance       (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CLocalMachineNamesCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CGlobalOptionsCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);

//+-------------------------------------------------------------------
//  Entry in the global calss objects table. Contains a ptr to a clsid
//  and a ptr to the corresponding CreateInstance function for that
//  clsid.
//+-------------------------------------------------------------------
typedef struct tagCFEntry
{
    const CLSID        *pclsid;         // ptr to clsid
    LPFNCREATEINSTANCE  pfnCI;          // ptr to CreateInstance fn
    DWORD               dwFlags;        // misc flags. see CCF_FLAGS
} CFEntry;

typedef enum tagCCF_FLAGS
{
    CCF_NONE           = 0x0,
    CCF_AGGREGATABLE   = 0x1,           // class is aggregatable
} CCF_FLAGS;


//+-------------------------------------------------------------------
//
//  gInternalClassObjects - table of clsids and the corresponding
//  CreateInstance functions for those clsids. The CI function is
//  passed to the standard implementation of the class factory object.
//
//+-------------------------------------------------------------------
const CFEntry gInternalClassObjects[] =
{
    {&CLSID_StdEvent,                     CStdEventCF_CreateInstance,         CCF_AGGREGATABLE},
    {&CLSID_ManualResetEvent,             CManualResetEventCF_CreateInstance, CCF_AGGREGATABLE},
    {&CLSID_SynchronizeContainer,         CSynchronizeContainerCF_CreateInstance, CCF_AGGREGATABLE},
    {&CLSID_StdGlobalInterfaceTable,      CGIPTableCF_CreateInstance,         CCF_NONE},
    {&CLSID_DCOMAccessControl,            CAccessControlCF_CreateInstance,    CCF_AGGREGATABLE},
    {&CLSID_ErrorObject,                  CErrorObjectCF_CreateInstance,      CCF_NONE},
    {&CLSID_COMCatalog,                   CComCatalogCF_CreateInstance,       CCF_NONE},
    {&CLSID_ItemMoniker,                  CItemMonikerCF_CreateInstance,      CCF_NONE},
    {&CLSID_CompositeMoniker,             CCompositeMonikerCF_CreateInstance, CCF_NONE},
    {&CLSID_PackagerMoniker,              CPackagerMonikerCF_CreateInstance,  CCF_NONE},
    {&CLSID_AntiMoniker,                  CAntiMonikerCF_CreateInstance,      CCF_NONE},
    {&CLSID_PointerMoniker,               CPointerMonikerCF_CreateInstance,   CCF_NONE},
    {&CLSID_StdComponentCategoriesMgr,    CComCatCF_CreateInstance,           CCF_AGGREGATABLE},
    {&CLSID_GblComponentCategoriesMgr,    CComCatCSCF_CreateInstance,         CCF_AGGREGATABLE},
    {&CLSID_RpcHelper,                    CRpcHelperCF_CreateInstance,        CCF_NONE},
    {&CLSID_ObjectContext,                CObjectContextCF_CreateInstance,    CCF_NONE},
    {&CLSID_InProcFreeMarshaler,          CFreeThreadedMarshalerCF_CreateInstance,      CCF_AGGREGATABLE},
    {&CLSID_ActivationPropertiesIn,       CActivationPropertiesInCF_CreateInstance,     CCF_NONE},
    {&CLSID_ActivationPropertiesOut,      CActivationPropertiesOutCF_CreateInstance,    CCF_NONE},
    {&CLSID_InprocActpropsUnmarshaller,   CInprocActpropsUnmarshallerCF_CreateInstance, CCF_NONE},
    {&CLSID_ComActivator,                 CComActivatorCF_CreateInstance,     CCF_NONE},
    {&CLSID_AddrControl,                  CAddrControlCF_CreateInstance,    CCF_NONE},
    {&CLSID_StackWalker,                  CStackWalkerCF_CreateInstance,    CCF_NONE},
    {&CLSID_LocalMachineNames,            CLocalMachineNamesCF_CreateInstance,   CCF_NONE},
    {&CLSID_GlobalOptions,                CGlobalOptionsCF_CreateInstance,   CCF_NONE},

    {NULL, NULL}
};


//+-------------------------------------------------------------------
//
//  Function:   ComDllGetClassObject
//
//  Synopsis:   Function to return internal class objects.
//
//  Notes:      Uses the gInternalClassObjects table and the
//              CStdClassFactory implementation.
//
//+-------------------------------------------------------------------
INTERNAL ComDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    ComDebOut((DEB_ACTIVATE, "ComDllGetClassObject rclsid:%I riid:%I ppv:%x\n",
              &rclsid, &riid, ppv));

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    int i=0;
    while (gInternalClassObjects[i].pclsid)
    {
        if (InlineIsEqualGUID(*gInternalClassObjects[i].pclsid, rclsid))
        {
            // found a matching CLSID. Create an instance of the std class factory
            // passing in the creatinstance function from the table.
            hr = E_OUTOFMEMORY;
            CStdClassFactory *pCF = new CStdClassFactory(i);
            if (pCF)
            {
                hr = pCF->QueryInterface(riid, ppv);
                pCF->Release();
            }

            break;
        }
        i++;
    }

    ComDebOut((DEB_ACTIVATE, "ComDllGetClassObject hr:%x pv:%x\n", hr, *ppv));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdClassFactory::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::Release, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdClassFactory::Release(void)
{
    ULONG cRefs = (ULONG) InterlockedDecrement((LONG *)&_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class by calling
//              the creation function member variable.
//
//  Notes:      Does the parameter checking here to avoid having to
//              replicate it in all the creation functions.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdClassFactory::CreateInstance(IUnknown *pUnkOuter,
                                              REFIID riid,
                                              void **ppv)
{
    ComDebOut((DEB_ACTIVATE,
       "CStdClassFactory::CreateInstance _dwIndex:%x pUnkOuter:%x riid:%I ppv:%x\n",
       _dwIndex, pUnkOuter, &riid, ppv));

    // Validate the parameters.
    HRESULT hr = E_INVALIDARG;
    if (ppv != NULL)
    {
        *ppv = NULL;

        // If the caller wants to aggregate, only IID_IUnknown may be requested.
        if (pUnkOuter == NULL || IsEqualGUID(IID_IUnknown, riid))
        {
            // check if aggregation desired and supported.
            hr = CLASS_E_NOAGGREGATION;
            if ( pUnkOuter == NULL ||
                (gInternalClassObjects[_dwIndex].dwFlags & CCF_AGGREGATABLE))
            {
                // Create the object instance
                IUnknown *pUnk=NULL;
                hr = (gInternalClassObjects[_dwIndex].pfnCI)(pUnkOuter, riid, (void **)&pUnk);
                if (SUCCEEDED(hr))
                {
                    // get the requested interface
                    hr = pUnk->QueryInterface(riid, ppv);
                    pUnk->Release();
                }
            }
        }
    }

    ComDebOut((DEB_ACTIVATE, "CStdClassFactory::CreateInstance hr:%x *ppv:%x\n",
              hr, *ppv));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\stackwlk.cxx ===
#include <ole2int.h>
#include "stackwlk.hxx"

char * mystrdup(const char * sz)
{
	int nLen = lstrlenA(sz) + 1;
    char * tmp = new char[nLen];
	lstrcpyA(tmp, sz);
	return tmp;
}


StackWalker::SymGetModuleInfoFunc		StackWalker::_SymGetModuleInfo;
StackWalker::SymGetSymFromAddrFunc		StackWalker::_SymGetSymFromAddr;
StackWalker::SymLoadModuleFunc			StackWalker::_SymLoadModule;
StackWalker::StackWalkFunc				StackWalker::_StackWalk;
StackWalker::UndecorateSymbolNameFunc	StackWalker::_UndecorateSymbolName;
PFUNCTION_TABLE_ACCESS_ROUTINE				StackWalker::_SymFunctionTableAccess;

StackWalker::StackWalker(HANDLE hProcess)
	: _imageHlpDLL(NULL),
	  _hProcess(hProcess)
{
	_imageHlpDLL = LoadLibrary(L"imagehlp.dll");
	if (_imageHlpDLL != NULL) {
		// Get commonly used Sym* functions.
		if (_StackWalk == NULL) {
			// If one of them are null, assume
			// they all are.  Benign race here.

			_StackWalk = (StackWalkFunc)GetProcAddress(_imageHlpDLL, "StackWalk");
			if (_StackWalk == NULL)
				return;
			_SymGetModuleInfo = (SymGetModuleInfoFunc)GetProcAddress(_imageHlpDLL,
																	 "SymGetModuleInfo");
			if (_SymGetModuleInfo == NULL)
				return;
			_SymGetSymFromAddr = (SymGetSymFromAddrFunc)GetProcAddress(_imageHlpDLL,
																	   "SymGetSymFromAddr");
			if (_SymGetSymFromAddr == NULL)
				return;
			_SymLoadModule = (SymLoadModuleFunc)GetProcAddress(_imageHlpDLL,
															   "SymLoadModule");
			if (_SymLoadModule == NULL)
				return;
			_UndecorateSymbolName = (UndecorateSymbolNameFunc)GetProcAddress(_imageHlpDLL,
																			 "UnDecorateSymbolName");
			if (_UndecorateSymbolName == NULL)
				return;
			_SymFunctionTableAccess = (PFUNCTION_TABLE_ACCESS_ROUTINE)GetProcAddress(_imageHlpDLL,
																						 "SymFunctionTableAccess");
			if (_SymFunctionTableAccess == NULL)
				return;
		}

		// Sym* functions that we're only going to use locally.
		typedef BOOL (__stdcall *SymInitializeFunc)(HANDLE hProcess,
													LPSTR path,
													BOOL invadeProcess);
		typedef DWORD (__stdcall *SymSetOptionsFunc)(DWORD);

		SymInitializeFunc SymInitialize = (SymInitializeFunc)GetProcAddress(_imageHlpDLL,
																			"SymInitialize");
		if (SymInitialize == NULL)
			return;
		SymSetOptionsFunc SymSetOptions = (SymSetOptionsFunc)GetProcAddress(_imageHlpDLL,
																			"SymSetOptions");
		if (SymSetOptions == NULL)
			return;

		if (SymInitialize(hProcess, NULL, FALSE))
			SymSetOptions(0);
	}
}


StackWalker::~StackWalker() {
	if (_imageHlpDLL != NULL) {
		typedef BOOL (__stdcall *SymCleanupFunc)(HANDLE hProcess);

		SymCleanupFunc SymCleanup = (SymCleanupFunc)GetProcAddress(_imageHlpDLL,
																   "SymCleanup");
		if (SymCleanup != NULL)
			SymCleanup(_hProcess);

		FreeLibrary(_imageHlpDLL);
	}
}

DWORD_PTR StackWalker::LoadModule(HANDLE hProcess, DWORD_PTR address) {
    MEMORY_BASIC_INFORMATION mbi;

    if (VirtualQueryEx(hProcess, (void*)address, &mbi, sizeof mbi)) {
        if (mbi.Type & MEM_IMAGE) {
            char module[MAX_PATH];
            DWORD cch = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase,
                                           module,
                                           MAX_PATH);

            // Ignore the return code since we can't do anything with it.
            (void)_SymLoadModule(hProcess,
                                 NULL,
                                 ((cch) ? module : NULL),
                                 NULL,
                                 (DWORD_PTR) mbi.AllocationBase,
                                 0);
            return (DWORD_PTR) mbi.AllocationBase;
        }
    }

    return 0;
}

Symbol* StackWalker::ResolveAddress(DWORD_PTR addr) {
	if (_imageHlpDLL == NULL)
		return NULL;

	// Find out what module the address lies in.
	char* module = NULL;
	IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;

	if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo)) {
		module = moduleInfo.ModuleName;
	}
	else {
		// First attempt failed, load the module info.
		LoadModule(_hProcess, addr);
		if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo))
			module = moduleInfo.ModuleName;
	}

	char* symbolName = NULL;
    char undecoratedName[512];
	IMAGEHLP_SYMBOL* symbolInfo = (IMAGEHLP_SYMBOL*)_alloca(sizeof(IMAGEHLP_SYMBOL) + 512);
	symbolInfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL) + 512;
	symbolInfo->MaxNameLength = 512;
	DWORD_PTR displacement = 0;
	if (_SymGetSymFromAddr(_hProcess, addr, &displacement, symbolInfo)) {
		DWORD flags = UNDNAME_NO_MS_KEYWORDS 
			| UNDNAME_NO_ACCESS_SPECIFIERS
			| UNDNAME_NO_FUNCTION_RETURNS
			| UNDNAME_NO_MEMBER_TYPE;
		if (_UndecorateSymbolName(symbolInfo->Name, undecoratedName, 512, flags))
			symbolName = undecoratedName;
		else
			symbolName = symbolInfo->Name;
	}
	else {
		displacement = addr - moduleInfo.BaseOfImage;
	}

	return new Symbol(module, symbolName, displacement);
}



DWORD_PTR __stdcall StackWalker::GetModuleBase(HANDLE hProcess, DWORD_PTR address) {
    IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;
	
    if (_SymGetModuleInfo(hProcess, address, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
		return LoadModule(hProcess, address);

}

Symbol* StackWalker::CreateStackTrace(CONTEXT* context) {
	if (_imageHlpDLL == NULL)
		return NULL;

	HANDLE hThread = GetCurrentThread();

	DWORD dwMachineType;
	STACKFRAME frame = {0};
	frame.AddrPC.Mode = AddrModeFlat;

#if defined(_M_IX86)
	dwMachineType          = IMAGE_FILE_MACHINE_I386;
	frame.AddrPC.Offset    = context->Eip;  // Program Counter
	frame.AddrStack.Offset = context->Esp;  // Stack Pointer
	frame.AddrStack.Mode   = AddrModeFlat;
	frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer

#elif defined(_M_AMD64)
    dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
    frame.AddrPC.Offset    = context->Rip;
    frame.AddrPC.Mode      = AddrModeFlat;
    frame.AddrStack.Offset = context->Rsp;
    frame.AddrStack.Mode   = AddrModeFlat;

#elif defined(_M_IA64)
    dwMachineType          = IMAGE_FILE_MACHINE_IA64;
    frame.AddrPC.Offset    = context->StIIP;
    frame.AddrPC.Mode      = AddrModeFlat;
    frame.AddrStack.Offset = context->IntSp;
    frame.AddrStack.Mode   = AddrModeFlat;

#else
#error Unknown Target Machine
#endif
	
	// These variables are used to count the number of consecutive frames 
	// with the exact same PC returned by StackWalk().  On the Alpha infinite
	// loops (and infinite lists!) were being caused by StackWalk() never 
	// returning FALSE (see Raid Bug #8354 for details).
	const DWORD dwMaxNumRepetitions = 40;
	DWORD dwRepetitions	= 0;
	ADDRESS addrRepeated = {0, 0, AddrModeFlat};

	// Walk the stack...
	Symbol* prev = NULL;
	Symbol* head = NULL;

	for (;;) {
		if (!_StackWalk(dwMachineType,
						_hProcess,
						hThread,
						&frame,
						&context,
						NULL,
						_SymFunctionTableAccess,
						GetModuleBase,
						NULL))
			break;
		if (frame.AddrPC.Offset == 0)
			break;

		// Check for repeated addresses;  if dwMaxNumRepetitions are found,
		// then we break out of the loop and exit the stack walk
		if (addrRepeated.Offset == frame.AddrPC.Offset &&
			addrRepeated.Mode == frame.AddrPC.Mode) {
			dwRepetitions ++;
			if (dwRepetitions == dwMaxNumRepetitions) {
				break;
			}
		} else {
			dwRepetitions = 0;
			addrRepeated.Offset = frame.AddrPC.Offset;
			addrRepeated.Mode = frame.AddrPC.Mode;
		}

		// There have been reports of StackWalk returning an offset of
		// -1, which SymLoadModule later av's on.   If this happens,
		// we simply skip that frame.
		if (frame.AddrPC.Offset == -1)
			continue;
		
		Symbol* sym = ResolveAddress(frame.AddrPC.Offset);
		if (sym == NULL)
			break;

		// Append this symbol to the previous one, if any.
		if (prev == NULL) {
			prev = sym;
			head = sym;
		}
		else {
			prev->Append(sym);
			prev = sym;
		}
	}

	return head;
}

SIZE_T StackWalker::GetCallStackSize(Symbol* symbol)
{
	SIZE_T nSize = 2; // Start with a "\r\n".
	const char* module = NULL;
	const char* symbolName = NULL;	
	Symbol * sym = symbol;
	while (sym != NULL)
	{
		module = sym->moduleName();
		symbolName = sym->symbolName();	
		nSize += lstrlenA(module);
		nSize += lstrlenA(symbolName);
		nSize += 32; // displacement, spaces, etc.
		sym = sym -> next();
	}

	return nSize;
}
BOOL StackWalker::GetCallStack(Symbol * symbol, SIZE_T nChars, WCHAR * sz, SIZE_T nMaxLines)
{
	if (!symbol || !nChars)
		return FALSE;

	Symbol* sym = symbol;
	
	//	for (int i=0;i<3;i++)
	//	{
	//		Symbol* tmp = sym;
	//		sym = sym->next();
	//		delete tmp;
	//		if (!sym)
	//			break;
	//	}

	const char* module = NULL;
	const char* symbolName = NULL;	
	char * szStack = (char * )PrivMemAlloc(nChars);
	ZeroMemory(szStack, nChars);
	lstrcpyA(szStack, "\r\n"); // Start with a CR-LF.
	Symbol* tmp  = NULL;
	while (sym != NULL && nMaxLines-- > 0) 
	{	
		module = sym->moduleName();
		symbolName = sym->symbolName();			
		if (module != NULL) 
		{
			lstrcatA(szStack, module);
			if (symbolName != NULL)
				lstrcatA(szStack, "!");
		}

		if (symbolName != NULL)
			lstrcatA(szStack, symbolName);

		sym -> AppendDisplacement(szStack);

		lstrcatA(szStack, "\r\n");
		tmp = sym;
		sym = sym->next();
		delete tmp;
	}

	SIZE_T nLen = lstrlenA(szStack);
	nLen++;		
	MultiByteToWideChar(CP_ACP, 0, szStack, (int) nLen, sz, (int) nLen);
	PrivMemFree(szStack);
	return TRUE;
	
}



Symbol::Symbol(const char* moduleName, const char* symbolName, DWORD_PTR displacement)
	: _moduleName(NULL),
	  _symbolName(NULL),
	  _displacement(displacement),
	  _next(NULL)
{
	if (moduleName != NULL)
		_moduleName = mystrdup(moduleName);
	if (symbolName != NULL)
		_symbolName = mystrdup(symbolName);
}

Symbol::~Symbol() {
	delete [] _moduleName;
    delete [] _symbolName;
}

void Symbol::Append(Symbol* sym) {
	_next = sym;
}


#if 0
#include <iostream.h>
DWORD filter(EXCEPTION_POINTERS* exp) {
	StackWalker resolver(GetCurrentProcess());
	Symbol* symbol = resolver.CreateStackTrace(exp->ContextRecord);
	if (symbol == NULL) {
		cout << "Couldn't get stack trace" << endl;
	}
	else {
		cout << "Stack trace:" << endl;

		Symbol* sym = symbol;
		while (sym != NULL) {
			const char* module = sym->moduleName();
			const char* symbolName = sym->symbolName();

			if (module != NULL) {
				cout << module;
				if (symbolName != NULL)
					cout << '!';
			}
			if (symbolName != NULL)
				cout << symbolName;
			cout << "+0x" << hex << sym->displacement() << dec << endl;

			Symbol* tmp = sym;
			sym = sym->next();

			delete tmp;
		}
	}

	return EXCEPTION_EXECUTE_HANDLER;
}


int bar(int x, int* p) {
	*p = x;
	return 5;
}

void foo(int* p) {
	bar(5, p);
}

int main() {
	__try {
		int* p = (int*)0xdeadbeef;
		foo(p);
	}
	__except (filter(GetExceptionInformation())) {

	}

	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\dcomss.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dcomss.h

Abstract:

    Common services provided by core the orpcss service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     06-14-95    Bits 'n pieces

--*/

#ifndef __DCOMSS_H
#define __DCOMSS_H

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <winsvc.h>
#include <winsafer.h>
#include <wincrypt.h>
#include <wtsapi32.h>
#include <userenv.h>
#include <winnetwk.h>
#include <lm.h>

#ifdef __cplusplus
extern "C" {
#endif

#if DBG
#if !defined(DEBUGRPC)
#define DEBUGRPC
#endif
#endif // DBG

// Endpoint related functions
RPC_STATUS InitializeEndpointManager(VOID);
USHORT     GetProtseqId(PWSTR Protseq);
USHORT     GetProtseqIdAnsi(PSTR Protseq);
PWSTR      GetProtseq(USHORT ProtseqId);
PWSTR      GetEndpoint(USHORT ProtseqId);
RPC_STATUS UseProtseqIfNecessary(USHORT id);
RPC_STATUS DelayedUseProtseq(USHORT id);
VOID       CompleteDelayedUseProtseqs();
BOOL       IsLocal(USHORT ProtseqId);
void       RegisterAuthInfoIfNecessary();

// Must be given dedicated a thread after startup.
DWORD      ObjectExporterWorkerThread(PVOID);

// Update service state
VOID UpdateState(DWORD dwNewState);

extern BOOL s_fEnableDCOM; // Set by StartObjectExporter.

DWORD StartEndpointMapper(VOID);
DWORD StartMqManagement(VOID);
DWORD StartObjectExporter(VOID);
DWORD InitializeSCMBeforeListen(VOID);
DWORD InitializeSCM(VOID);
void  InitializeSCMAfterListen(VOID);
NTSTATUS ConnectToLsa();
BOOL GetDefaultDomainName();

// Shared by wrapper\epts.c and olescm\clsdata.cxx.

typedef enum {
    STOPPED = 1,
    START,
    STARTED
    } PROTSEQ_STATE;

typedef struct {
    PROTSEQ_STATE state;
    PWSTR         pwstrProtseq;
    PWSTR         pwstrEndpoint;
    } PROTSEQ_INFO;


#if DBG==1 && defined(WIN32)
#define SCMVDATEHEAP() if(!HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define SCMVDATEHEAP()
#endif  //  DBG==1 && defined(WIN32)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\blist.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    BList.cxx

Abstract:

    Implements out of line methods on blists.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     95-03-02    Bits 'n pieces
    MarioGo     95-09-07    Was blist.inl, change from template to generic class for PPC.
--*/

#include<or.hxx>

ULONG
CBList::Hash(PVOID p)
{
    ULONG t = PtrToUlong(p);

    return ( ((t << 9) ^ (t >> 5) ^ (t >> 15)) % _ulmaxData);
}

ORSTATUS
CBList::Insert(PVOID p)
{
    if (   _data == 0
        || _ulcElements > (_ulmaxData - (_ulmaxData/8 + 1)))
        {
        // Table getting full, grow it.
        // See Kenuth on linear probe hash performance as the table fills.

        ULONG i, ulmaxOldData = _ulmaxData;
        PVOID *ppOldData = _data;
        _data = new PVOID[_ulmaxData * 2];

        if (0 == _data)
            {
            _data = ppOldData;
            return(OR_NOMEM);
            }

        _ulmaxData *= 2;
        _ulcElements = 0;

        OrMemorySet(_data, 0, _ulmaxData*sizeof(PVOID));

        if (ppOldData)
            {
            for(i = 0; i < ulmaxOldData; i++)
                {
                if (ppOldData[i])
                    {
                    ORSTATUS status = Insert(ppOldData[i]);
                    ASSERT(status == OR_OK);
                    }
                }

            delete ppOldData;
            }
        }

    register ULONG i = Hash(p);

    while(_data[i])
        {
        i = (i + 1) % _ulmaxData;
        }
    
    _data[i] = p;
    _ulcElements++;

    return(OR_OK);
}

PVOID 
CBList::Remove(PVOID p)
{
    register ULONG i, hash;

    if (_data)
        {
        i = hash = Hash(p);
    
        if (_data[i] != p)
            {
            do
                {
                i = (i + 1) % _ulmaxData;
                }
            while(_data[i] != p && i != hash);
            }

        if (_data[i] == p)
            {
            _data[i] = 0;
            _ulcElements--;
            return(p);
            }

        ASSERT(i == hash);
        }

    return(0);
}

BOOL
CBList::Member(PVOID p)
{
    int i, hash;

    if (0 == _data)
        return(FALSE);

    i = hash = Hash(p);
    if (_data[i] == p)
        return(TRUE);

    do
        {
        i = (i + 1) % _ulmaxData;
        }
    while(_data[i] != p && i != hash);

    return(_data[i] == p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\locks.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Locks.cxx

Abstract:

    Out of line methods for some of the syncronization classes
    defined in locks.hxx.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-14-95    Moved from misc.cxx.
    MarioGo     01-27-96    Changed from busy (Sleep(0)) wait to event

--*/

#include <or.hxx>

//
// CShareLock methods
//

CSharedLock::CSharedLock(ORSTATUS &status)
{
	csinitokay = FALSE;
    exclusive_owner = 0;
    hevent = 0;
    
    status = OR_NOMEM;

    if (NT_SUCCESS(RtlInitializeCriticalSection(&lock)))
        {
        csinitokay = TRUE;
        hevent = CreateEvent(0, FALSE, FALSE, 0);
        if (hevent)
            {
            status = OR_OK;
            }
        }
}

CSharedLock::~CSharedLock()
{
    if (csinitokay)
    {
        NTSTATUS status = RtlDeleteCriticalSection(&lock);
        ASSERT(NT_SUCCESS(status));
    }
    if (hevent) CloseHandle(hevent);
}

void
CSharedLock::LockShared()
{
    AssertValid();

    readers++;

    if (writers)
        {
        if ((readers--) == 0)
            {
            SetEvent(hevent);
            }

        EnterCriticalSection(&lock);
        readers++;
        LeaveCriticalSection(&lock);
        }

    exclusive_owner = 0;
}

void
CSharedLock::UnlockShared(void)
{
    AssertValid();
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers)
        {
        SetEvent(hevent);
        }
}

void
CSharedLock::LockExclusive(void)
{
    AssertValid();
    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}

void
CSharedLock::UnlockExclusive(void)
{
    AssertValid();
    ASSERT(HeldExclusive());
    ASSERT(writers);
    writers--;
    exclusive_owner = 0;
    LeaveCriticalSection(&lock);
}

void
CSharedLock::Unlock()
{
    AssertValid();
    // Either the lock is held exclusively by this thread or the thread
    // has a shared lock. (or the caller has a bug).

    if (HeldExclusive())
        {
        UnlockExclusive();
        }
    else
        {
        UnlockShared();
        }
}

void
CSharedLock::ConvertToExclusive(void)
{
    AssertValid();
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers )
        SetEvent(hevent);

    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\trace.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       trace.cxx
//
//  Contents:   TraceInfo functions
//
//  History:    14-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
#include <stdarg.h>
#include <ole2int.h>
#if DBG==1

#ifdef FLAT
#include <sem.hxx>
#include <dllsem.hxx>
#endif // FLAT

#include "oleprint.hxx"
#include "sym.hxx"

// *** Global data ***
DWORD g_dwInfoLevel = INF_OFF;
extern CSym *g_pSym;
extern char gPidString[];

//+---------------------------------------------------------------------------
//
//  Function:   TraceInfoEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              trace information is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int TraceInfoEnabled()
{
    return g_dwInfoLevel & INF_BASE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceCmnEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              cmn api information is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int TraceCmnEnabled()
{
    return g_dwInfoLevel & INF_CMN;
}

//+---------------------------------------------------------------------------
//
//  Function:   SymInfoEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              symbol information is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int SymInfoEnabled()
{
    return g_dwInfoLevel & INF_SYM;
}

//+---------------------------------------------------------------------------
//
//  Function:   StructInfoEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              expanded structures is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int StructInfoEnabled()
{
    return g_dwInfoLevel & INF_STRUCT;
}

//+---------------------------------------------------------------------------
//
//  Function:   TLSIncTraceNestingLevel
//
//  Synopsis:   Returns the current nesting level, then increments it
//
//  Returns:    nesting level for OLETRACE
//
//  History:    13-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
inline LONG TLSIncTraceNestingLevel()
{
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        return (tls->cTraceNestingLevel)++;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   TLSDecTraceNestingLevel
//
//  Synopsis:   Decrement and return nesting level
//
//  Returns:    nesting level for OLETRACE
//
//  History:    13-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
inline LONG TLSDecTraceNestingLevel()
{
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        return --(tls->cTraceNestingLevel);
    }

    return 0;
}

// *** Inline Functions
//+---------------------------------------------------------------------------
//
//  Function:   IsAPIID
//
//  Synopsis:   Returns whether or not an 32-bit ID is a API ID
//
//  Arguments:  [dwID]  -   32-bit ID
//
//  Returns:    TRUE if it is an API ID, FALSE otherwise
//
//  History:    04-Aug-95   t-stevan   Created
//
//----------------------------------------------------------------------------
BOOL IsAPIID(DWORD dwID)
{
    return !(dwID>>16);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNameFromAPIID
//
//  Synopsis:   Returns a pointer to a string containing the API name
//
//  Arguments:  [dwID]  -   API ID
//
//  Returns:    Pointer to a string
//
//  History:    04-Aug-95   t-stevan   Created
//
//----------------------------------------------------------------------------
const char *GetNameFromAPIID(DWORD dwID)
{
    return (g_ppNameTables[dwID>>16])[dwID&0xffff];
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNameFromOBJID
//
//  Synopsis:   Returns a pointer to a string containing the object/method name
//
//  Arguments:  [dwID]  -   32-bit ID
//
//  Returns:    Pointer to a string
//
//  History:    04-Aug-95   t-stevan   Created
//
//----------------------------------------------------------------------------
const char *GetNameFromOBJID(DWORD dwID, IUnknown *pUnk, char *pBuf)
{
    wsprintfA(pBuf, "%s(%x)->%s", g_pscInterfaceNames[dwID>>16], pUnk, (g_ppNameTables[dwID>>16])[dwID&0xffff]);

    return pBuf;
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracein
//
//  Synopsis:   Prints trace information for API/Method-entry
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracein(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    va_start(args, dwID);

    iNestingLevel = TLSIncTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                        GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracecmnin
//
//  Synopsis:   Prints trace information for API/Method-entry
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracecmnin(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    if (!TraceCmnEnabled())
    {
        return;
    }

    va_start(args, dwID);

    iNestingLevel = TLSIncTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                        GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletraceout
//
//  Synopsis:   Prints trace information for API/Method-exit. assuming
//                return value is an HRESULT
//
//  Arguments:  [dwID]            -    API/Method ID
//              [hr]              -    return value
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletraceout(DWORD dwID, HRESULT hr)
{
    _oletraceoutex(dwID, RETURNFMT("%x"), hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracecmnout
//
//  Synopsis:   Prints trace information for API/Method-exit. assuming
//                return value is an HRESULT
//
//  Arguments:  [dwID]            -    API/Method ID
//              [hr]              -    return value
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracecmnout(DWORD dwID, HRESULT hr)
{
    _oletracecmnoutex(dwID, RETURNFMT("%x"), hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletraceoutex
//
//  Synopsis:   Prints trace information for API/Method-exit, using given
//                format string for return value
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletraceoutex(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    va_start(args, dwID);

    iNestingLevel = TLSDecTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                       GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracecmnoutex
//
//  Synopsis:   Prints trace information for API/Method-exit, using given
//                format string for return value
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracecmnoutex(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    if (!TraceCmnEnabled())
    {
        return;
    }

    va_start(args, dwID);

    iNestingLevel = TLSDecTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                       GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeTraceInfo
//
//  Synopsis:   Initializes the trace information's global variables,
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void InitializeTraceInfo()
{
    // get Pid string once
    _itoa(GetCurrentProcessId(), gPidString, 10);

    if(TraceInfoEnabled() && SymInfoEnabled())
    {
        // Initialize the symbol information
        // CAUTION:  This is very expensive to turn on!
        g_pSym = new CSym();
    }

}

void SetTraceInfoLevel(DWORD dwLevel)
{
    g_dwInfoLevel = dwLevel;

    if(TraceInfoEnabled() && (g_pSym == NULL) && SymInfoEnabled())
    {
        // Initialize the symbol information
        g_pSym = new CSym();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupTraceInfo
//
//  Synopsis:   Cleans up trace information's global variables
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void CleanupTraceInfo()
{
    if(g_pSym != NULL)
    {
        delete g_pSym;
    }
    WriteToLogFile(NULL); // Stop writing to log file
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\gentable.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Table.cxx

Abstract:

    Implementation of the CHashTable and CTableElement.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-15-95    Bits 'n pieces
    MarioGo     12-18-95    Changed from UUID to generic object keys

--*/

#include<or.hxx>

CTableElement *
CTableElement::RemoveMatching(
    IN CTableKey &tk,
    OUT CTableElement **ppRemoved)
/*++

Routine Description:

    Helper function used to remove an element from a
    bucket in the hash table.

Arguments:

    tk - Key to find the element being removed.

    ppRemoved - Contains the element removed or NULL upon return.

Return Value:

    Pointer to the remaining elements in the list if any.  Use
    to replace the current pointer in the bucket.

--*/
{
    CTableElement *pcurrent = this;
    CTableElement *psaved = 0;
    CTableElement *pfirst = this;

    while(pcurrent)
        {
        if (pcurrent->Compare(tk))
            {
            *ppRemoved = pcurrent;
            if (0 != psaved)
                {
                psaved->_pnext = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(pfirst);
                }
            else
                {
                // removing the first element in the list
                ASSERT(pcurrent == pfirst);
                psaved = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(psaved);
                }
            }

        psaved = pcurrent;
        pcurrent = pcurrent->_pnext;
        }

    *ppRemoved = 0;
    return(pfirst);
}


CTableElement *
CTableElement::RemoveMatching(
    IN CTableElement *pte,
    OUT CTableElement **ppRemoved)
/*++

Routine Description:

    Helper function used to remove an element from a bucket in the hash table.

Arguments:

    pte - Element to be removed, compared by pointer value.

    ppRemoved - Contains the element removed or NULL upon return.

Return Value:

    Pointer to the remaining elements in the list if any.  Use
    to replace the current pointer in the bucket.

--*/
{
    CTableElement *pcurrent = this;
    CTableElement *psaved = 0;
    CTableElement *pfirst = this;

    while(pcurrent)
        {
        if (pcurrent == pte)
            {
            *ppRemoved = pcurrent;
            if (0 != psaved)
                {
                psaved->_pnext = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(pfirst);
                }
            else
                {
                // removing the first element in the list
                ASSERT(pcurrent == pfirst);
                psaved = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(psaved);
                }
            }

        psaved = pcurrent;
        pcurrent = pcurrent->_pnext;
        }

    *ppRemoved = 0;
    return(pfirst);
}

CHashTable::CHashTable(ORSTATUS &status, UINT start_size)
{
    _cBuckets = start_size;
    _cElements = 0;
    _last = 0;

    _buckets = new CTableElement *[start_size];

    if (0 == _buckets)
        {
        status = OR_NOMEM;
        return;
        }

    for(UINT i = 0; i < _cBuckets; i++)
        {
        _buckets[i] = NULL;
        }

    status = OR_OK;
}


CHashTable::~CHashTable()
{
#if 0
#if DBG
    for(UINT i = 0; i < _cBuckets; i++)
        ASSERT(_buckets[i] == 0);
#endif
    delete _buckets;
#endif
    ASSERT(0);  // D'tor unused 12/95
}

CTableElement *
CHashTable::Lookup(
    IN CTableKey &id
    )
{
    DWORD hash = id.Hash();
    CTableElement *it;

    it = _buckets[hash % _cBuckets];

    while(it)
        {
        if (it->Compare(id))
            {
            return(it);
            }

        it = it->Next();
        }

    return(0);
}

void
CHashTable::Add(
    IN CTableElement *pElement
    )
{
    DWORD hash = pElement->Hash();

    hash %= _cBuckets;

    _buckets[hash] = _buckets[hash]->Insert(pElement);

    _cElements++;

    if (_cElements > _cBuckets)
        {
        // Try to grow the table.  If the allocation fails no need to worry,
        // everything still works but might be a bit slower.

        CTableElement **ppte = new CTableElement *[_cBuckets * 2];

        if (ppte)
            {
            UINT i, uiBucketsOld = _cBuckets;
            CTableElement *pteT1, *pteT2;
            CTableElement **ppteOld = _buckets;

            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Growing table: %p\n",
                       this));

            // Change to the larger array of buckets.
            _cBuckets *= 2;
            for(i = 0; i < _cBuckets; i++)
                {
                ppte[i] = NULL;
                }
            _buckets = ppte;

            // Move every element from the old table into the large table.
            for(i = 0; i < uiBucketsOld; i++)
                {
                pteT1 = ppteOld[i];

                while(pteT1)
                    {
                    pteT2 = pteT1->Next();
                    pteT1->Unlink();

                    // Same as calling Add() but don't update _cElements.
                    hash = pteT1->Hash();
                    hash %= _cBuckets;
                    _buckets[hash] = _buckets[hash]->Insert(pteT1);

                    pteT1 = pteT2;
                    }
                }

                // Delete the old buckets
                delete [] ppteOld;
            }
        }

    return;
}

CTableElement *
CHashTable::Remove(
    IN CTableKey &id
    )
/*++

Routine Description:

    Looks up and removes an element from the table.

Arguments:

    id - The key to match the element to be removed

Return Value:

    NULL - The element was not in the table

    non-NULL - A pointer to the element which was removed.

--*/

{
    DWORD hash = id.Hash();
    CTableElement *pte;

    hash %= _cBuckets;

    _buckets[hash] = (_buckets[hash])->RemoveMatching(id, &pte);

    if (pte)
        {
        _cElements--;

        if (_last == pte)
            {
            _last = _buckets[hash];
            }
        }

    return pte;
}

void
CHashTable::Remove(
    IN CTableElement *pElement
    )
/*++

Routine Description:

    Used to remove an element from the table given a pointer to it.

Arguments:

    pElement - the element to be removed.  This pointer value,
        keys are not compared.

Return Value:

    None

--*/

{
    DWORD hash = pElement->Hash();
    CTableElement *pte;

    hash %= _cBuckets;

    _buckets[hash] = (_buckets[hash])->RemoveMatching(pElement, &pte);

    if (pte)
        {
        ASSERT(pte == pElement);

        _cElements--;

        if (_last == pElement)
            {
            _last = _buckets[hash];
            }
        }

    return;
}

CTableElement *
CHashTable::Another(
    )
/*++

Routine Description:

    Returns an element from the table.  Usually this will be
    element found after the element last returned from this
    function.  It may, due to races not solved here, repeat
    an element or skip an element.

       Races occur when accessing the "_last" memeber; this
    function is called while holding a shared lock. (More
    then one thread may call it at a time.)

    This isn't as bad as it sounds.  _last can only
    be set to null in Remove() which requires exclusive
    access.

Arguments:

    None

Return Value:

    NULL or a pointer to an element in the table.

--*/

{
    CTableElement *panother;
    int i, end;

    if (_cElements == 0)
        {
        return(0);
        }

    if (_last)
        {
        if (panother = _last->Next())
            {
            if (panother)
                {
                _last = panother;
                return(panother);
                }
            }

        ASSERT(panother == 0);

        // no next, start looking from just after last's hash.

        i = _last->Hash();

        // Exersise for the reader  (x + y) mod n == ( x mod n + y mod n ) mod n

        end = i = (i + 1) % _cBuckets;
        }
    else
        {
        // no last, start from the start.
        i = 0;
        end = _cBuckets - 1;
        }

    do
        {
        if (_buckets[i])
            {
            panother = _buckets[i];
            ASSERT(panother);
            _last = panother;
            return(panother);
            }
        i = (i + 1) % _cBuckets;
        }
    while (i != end);

    // Doesn't mean the table is empty, just that we didn't find
    // another element.  These are not the same thing.
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\callid.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    callid.cxx

Abstract:

    Implements a cache of callids used for running down OIDs

    This is almost twice as fast as UuidCreate() but that doesn't
    mean much.  UuidCreate takes 3 microseconds, this 1.4 (hit) or
    4.2 (miss) on a P90.

    This codes real advantage would be on MP machines.  But it is
    not performance critical and is probably overkill.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     1/18/1996    Bits 'n pieces

--*/

#include <or.hxx>

enum CacheState { CallidEmpty = 0,
                  CallidAllocated = 1,
                  CallidFree = -1 };
                  
struct CacheElement
    {
    CacheState  _state;
    UUID        _callid;
    };

CacheElement CallidCache[4] = { CallidEmpty, {0},
                                CallidEmpty, {0},
                                CallidEmpty, {0},
                                CallidEmpty, {0} };


INT
AllocateCallId(
    OUT UUID &Callid
    )
{
    INT i;
    LONG l;
    RPC_STATUS status;

    for (i = 0; i < 4; i++)
        {
        if (CallidCache[i]._state != CallidAllocated)
            {
            l = InterlockedExchange((PLONG)&CallidCache[i]._state, CallidAllocated);

            switch(l)
                {
                case CallidAllocated:
                    continue;

                case CallidFree:
                    Callid = CallidCache[i]._callid;
                    return(i);

                case CallidEmpty:
                    status = UuidCreate(&Callid);
                    VALIDATE((status, RPC_S_UUID_LOCAL_ONLY, RPC_S_OK, 0));
                    CallidCache[i]._callid = Callid;
                    return(i);
                }
            }
        }
    status = UuidCreate(&Callid);
    VALIDATE((status, RPC_S_UUID_LOCAL_ONLY, RPC_S_OK, 0));
    return(-1);
    }


void
FreeCallId(
    IN INT hint
    )
/*++

Routine Description:

    Frees a callid previously allcoated with AllocateCallId().

Arguments:

    hint - The hint value returned by the previous call to AllocateCallId().

Return Value:

    None

--*/
{
    ASSERT((hint > -2) && (hint < 4));

    if (hint >= 0)
        {
        CallidCache[hint]._state = CallidFree;;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\mid.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Mid.cxx

Abstract:

    Implements the CMid class.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     12-13-95    Bits 'n pieces
    MarioGo     02-01-96    Move binding handles out of mid

--*/


#include<or.hxx>

class CObjexPPing : public CParallelPing
{
public:
    CObjexPPing(WCHAR *pBindings, CMid *pMid) :
        _pBindings(pBindings),
        _pMid(pMid)
        {}


    BOOL NextCall(PROTSEQINFO *pProtseqInfo)
    {
        if (*_pBindings)
        {
            pProtseqInfo->pvUserInfo = _pBindings;
            pProtseqInfo->hRpc     = _pMid->MakeBinding(_pBindings);
            _pBindings =  OrStringSearch(_pBindings, 0) +1;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void ReleaseCall(PROTSEQINFO *pProtseqInfo)
    {
        if (pProtseqInfo->hRpc)
        {
            RpcBindingFree(&pProtseqInfo->hRpc);
        }
    }
private:
    WCHAR *    _pBindings;
    CMid  *    _pMid;
};

void dsaProtocolMerge(DUALSTRINGARRAY *pdsaSrc, DUALSTRINGARRAY **ppdsaDest)
/*++

Routine Description:

    Gives string bindings intersected with the allowed string bindings
    for this machine.

Arguments:

    pdsaSrc - string bindings to intersect
    ppdsaDest - generated string bindings

Return Value:

    none

--*/

{

    *ppdsaDest =  (DUALSTRINGARRAY *)PrivMemAlloc(pdsaSrc->wNumEntries*sizeof(WCHAR) + sizeof(DUALSTRINGARRAY));
    if (!*ppdsaDest)
    {
        return;
    }

    LPWSTR pTempDest = (*ppdsaDest)->aStringArray;


    // NOTE: Do not change the order of these loops
    // It is pertinent to correctly order the final
    // string.

    for (ULONG i=0; i<cMyProtseqs; i++)
    {
        for (LPWSTR pTempSrc = pdsaSrc->aStringArray;
            *pTempSrc;
            pTempSrc = OrStringSearch(pTempSrc, 0) + 1)
        {
            if (aMyProtseqs[i] == *pTempSrc)
            {
                // tower ids are the same
                wcscpy(pTempDest, pTempSrc);
                pTempDest = OrStringSearch(pTempDest, 0) + 1;
            }
        }
    }

    ULONG_PTR len = pTempDest - (*ppdsaDest)->aStringArray;
    if ( len  == 0)
    {
        *pTempDest = 0;
        pTempDest++;
        len++;
    }

    // copy sec bindings
    *pTempDest = 0;
    pTempDest++;
    len++;

    (*ppdsaDest)->wSecurityOffset = (USHORT) len;

    memcpy(pTempDest, pdsaSrc->aStringArray + pdsaSrc->wSecurityOffset,
           (pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset)*sizeof(WCHAR));

    len += pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset;
    (*ppdsaDest)->wNumEntries = (USHORT) len;

}

CMid::CMid( DUALSTRINGARRAY *pdsa, BOOL fLocal, ID OldMid, BOOL* pfInitOkay) :
    _fLocal(fLocal),
    _fStale(FALSE),
    _fDynamic(FALSE),
    _fInitialized(FALSE),
    _StringBinding(NULL),
    _fSecure(FALSE),
    _pdsaValidStringBindings(0)
/*++

Routine Description:

    Constructs a CMid object.

Arguments:

    pdsa - The dual string array of the server rpcss.
    fLocal - TRUE if the mid represents this machine.
    OldMid - Optional reassigned machine id.

Return Value:

    none

--*/
{
    DWORD i;

    // this must be allocated to include the size of the embedded dsa.
    dsaCopy(&_dsa, pdsa);

    // Set _fSecure iff we find an authentication service in the
    // dual string array that we are willing to use.
    _wAuthnSvc = RPC_C_AUTHN_NONE;
    _ulMarshaledTargetInfoLength = 0;
    _pMarshaledTargetInfo = NULL;
    for (i = 0; i < s_cRpcssSvc; i++)
    {
        if (ValidAuthnSvc( &_dsa, s_aRpcssSvc[i].wId ))
        {
            _fSecure = TRUE;
        break;
        }
    }

    if (OldMid)
    {
        _id = OldMid;
        ASSERT(fLocal);
        *pfInitOkay = TRUE;
    }
    else
    {
        *pfInitOkay = AllocateId(&_id);
    }
}

RPC_BINDING_HANDLE
CMid::MakeBinding(WCHAR *pBinding)
/*++

Routine Description:

    Creates a binding handle from a specified string binding or a default
    string binding with or without an endpoint.

Arguments:

    pBinding - The string binding to use or NULL for the default.

Return Value:

    binding handle

--*/
{
    if (!pBinding)
    {
        pBinding = _StringBinding;
    }
    if (pBinding)
    {
        if (_fDynamic)
        {
            // Create binding without an endpoint.
            return ::GetBinding(pBinding);
        }
        else
        {
            return GetBindingToOr(pBinding);
        }
    }
    return 0;
}


RPC_BINDING_HANDLE
CMid::GetBinding()
/*++

Routine Description:

    Gets an RPC binding handle to the remote machine.

Arguments:

    None
    
Return Value:

    0 - when no more binding are available.

    non-zero - A binding to the machine.

--*/
{

    if (IsLocal())
    {
        return(0);
    }

    //
    // if the Mid is already initialized, then just
    // return the binding.
    //

    if (_fInitialized)
    {
        return MakeBinding();
    }

    //
    // merge the strings 
    //
    DUALSTRINGARRAY *pdsaValidStringBindings = 0;

    if (!_pdsaValidStringBindings)
    {
        // merge with valid protocols for this server

        gpClientLock->LockExclusive();

        if (!_pdsaValidStringBindings)
        {
          dsaProtocolMerge(&_dsa, &pdsaValidStringBindings);
 
          if (!pdsaValidStringBindings)
          {
            gpClientLock->UnlockExclusive();
            return 0;
          }
          
          ASSERT(pdsaValidStringBindings);
          _pdsaValidStringBindings = pdsaValidStringBindings;          
        }
        
        gpClientLock->UnlockExclusive();
    }

    // Ping the server on all bindings in parallel to get
    // the correct binding for this server.  This loop executes
    // twice to try the bindings w/o the endpoint.
    //

    ULONG ndx;
    BOOL bNoEndpoint = FALSE;
    RPC_BINDING_HANDLE hserver = NULL;
    RPC_STATUS status;


    { // scope the parallel ping object

        CObjexPPing ping(_pdsaValidStringBindings->aStringArray, this);

        for (;;)
        {
            status = ping.Ping();

            if ( RPC_S_UNKNOWN_IF == status )
            {
                if ( ! bNoEndpoint )
                {
                    for ( unsigned int ProtseqIndex = 0; ProtseqIndex < ping.HandleCount(); ProtseqIndex++ )
                    {
                        RPC_BINDING_HANDLE tmpBinding;
                        status = RpcBindingCopy( ping.Info(ProtseqIndex)->hRpc, &tmpBinding);                        
                        if (status != RPC_S_OK)
                            break;
                            
                        status = RpcBindingFree( &(ping.Info(ProtseqIndex)->hRpc));                        
                        if (status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }
                            
                        status = RpcBindingReset(tmpBinding);
                        if (status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }
                        
                        ping.Info(ProtseqIndex)->hRpc = tmpBinding;
                    }
                    bNoEndpoint = TRUE;
                    continue;
                }
            }
            if (status == RPC_S_OK && bNoEndpoint)
            {
                _fDynamic = TRUE;
            }
            break;
        }
        if (status == RPC_S_OK)
        {
            hserver = ping.GetWinner()->hRpc;
            ping.GetWinner()->hRpc = NULL;
          
            if (!_StringBinding)
            {
              gpClientLock->LockExclusive();
              if (!_StringBinding)
              {
                  _StringBinding = (WCHAR *) ping.GetWinner()->pvUserInfo;
              }
              gpClientLock->UnlockExclusive();
            }
       }

        ping.Reset();
    } // end scope for ping object

    //
    // the mid is initialized now
    //
    if (RPC_S_OK == status)
       _fInitialized = TRUE;

    return hserver;
}
//keeps a copy of the passed in creds
ORSTATUS CMid::SetMarshaledTargetInfo(unsigned long ulMarshaledTargetInfoLength, unsigned char *pMarshaledTargetInfo)
{
         
   if (_pMarshaledTargetInfo)
   {
           MIDL_user_free(_pMarshaledTargetInfo);
   }      
   _ulMarshaledTargetInfoLength = 0;
   _pMarshaledTargetInfo = NULL;
   ORSTATUS status=OR_OK;
   if (ulMarshaledTargetInfoLength) 
   {
      _pMarshaledTargetInfo = (unsigned char *) MIDL_user_allocate(ulMarshaledTargetInfoLength * sizeof(char));
      if (_pMarshaledTargetInfo) 
      {
         memcpy(_pMarshaledTargetInfo, pMarshaledTargetInfo, ulMarshaledTargetInfoLength);
         _ulMarshaledTargetInfoLength = ulMarshaledTargetInfoLength;
      }
      else
         status = ERROR_NOT_ENOUGH_MEMORY;
   }
   return status;
   
}
// hands out a copy of my creds
ORSTATUS CMid::GetMarshaledTargetInfo(unsigned long *pulMarshaledTargetInfoLength, unsigned char **pucMarshaledTargetInfo)
{
   ORSTATUS status=OR_OK;
   *pulMarshaledTargetInfoLength = 0;
   *pucMarshaledTargetInfo = NULL;
   if (_ulMarshaledTargetInfoLength) 
   {
      *pucMarshaledTargetInfo = (unsigned char *) MIDL_user_allocate(_ulMarshaledTargetInfoLength * sizeof(char));
      if (*pucMarshaledTargetInfo) 
      {
         memcpy(*pucMarshaledTargetInfo, _pMarshaledTargetInfo, _ulMarshaledTargetInfoLength);
         *pulMarshaledTargetInfoLength = _ulMarshaledTargetInfoLength;
      }
      else
         status = ERROR_NOT_ENOUGH_MEMORY;
   }
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\manager.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Manager.cxx

Abstract:

    Stub/OR interface

Author:

    Mario Goertzel    [mariogo]       Feb-02-1995

Revision Hist:

        MarioGo         02-10-95      Bits 'n pieces
        MarioGo         01-31-96      New local and remote interfaces
        TarunA          10-12-98      OXIDs are referenced on OID basis (Client side)
        TarunA          10-31-98      Added PID of the process connecting

        a-sergiv        07-09-99      Impersonate for the entire duration of
                                      ResolveClientOXID for ncacn_http protocol
                                      (to fix a bad COM Internet Services bug)
--*/

#include <or.hxx>
extern "C"
{
#include <inc.hxx>
#define SECURITY_WIN32 // Used by security.h
#include <security.h>
}

// These variables hold the list of channel hooks registered for the machine.
// They are updated as the registry changes.
LONG       s_cChannelHook    = 0;
GUID      *s_aChannelHook    = NULL;
HANDLE     s_hChannelHook    = NULL;

// Definition of single instance of this class:
CRpcSecurityCallbackManager* gpCRpcSecurityCallbackMgr;
CPingSetQuotaManager* gpPingSetQuotaManager;

extern BOOL gbDynamicIPChangesEnabled;

// forward declaration
error_status_t
AllocateReservedIdsInternal(IN ULONG cIdsToAlloc,
				                  OUT ID aIdsAllocated[],
				                  OUT ULONG* pcIdsAllocated);
				
BOOL
CheckLocalCall(
    IN  handle_t hClient
    )
/*++

Routine Description:

    Checks that the RPC client calling us on the specified
    binding handle is calling from a process on the local
    machine.

Arguments:

    hClient - Rpc binding handle of the call in progress.

Return Value:

    TRUE -- client is local to this machine
    FALSE -- client is not local or an error occurred
    
--*/
    
{
    UINT type;
    RPC_STATUS status;

    if (!hClient)
        return FALSE;
    
    status = I_RpcBindingInqTransportType(hClient, &type);
    if (status != RPC_S_OK)
        return FALSE;

    // The original CheckLocalCall implementation allowed for 
    // TRANSPORT_TYPE_WMSG.  I'm sure we shouldn't accept them, 
    // but I'd like to know if we ever receive such a call so
    // I can investigate.  Hence this assert.
    ASSERT(type != TRANSPORT_TYPE_WMSG);
    
    if (type != TRANSPORT_TYPE_LPC)
        return FALSE;

    return TRUE;
}

BOOL
RetrievePIDForLocalClient(
                  IN handle_t  hClient,
                  IN DWORD* pdwPid)
/*++

Routine Description:

    Queries RPC for the process id of a local client.

Arguments:

    hClient - Rpc binding handle of the call in progress. 

    pdwPid - where to store the process id of the client

Return Value:

    TRUE -- success, client's pid is stored in *pdwPid
    
    FALSE -- error occurred

--*/
{
    RPC_STATUS status;
    
    ASSERT(pdwPid);
        
    status = I_RpcBindingInqLocalClientPID(hClient, pdwPid);
    if (status != RPC_S_OK)
        return FALSE;

    return TRUE;
}

CProcess*
CheckLocalSecurity(
                  IN handle_t  hClient,
                  IN PHPROCESS phProcess,
                  IN BOOL fNotContext
                  )
/*++

Routine Description:

    Checks that a local client is correctly calling one of RPCSS RPC
    entry points.  "Correct" is defined by:  1) is using a local
    transport, ie, LPC, and 2) is a registered COM client (ie, has 
    previously called _Connect and obtained a valid context handle).

Arguments:

    hClient - Rpc binding handle of the call in progress.

    pProcess - Context handle passed in by the client. Must not be zero.

    fNotContext - should be FALSE if the context handle was not passed as an
      explicit context_handle attribute in an RPC call to RPCSS.  It should be
      TRUE otherwise.   If TRUE is passed here, the returned CProcess* ptr will
      have an extra refcount added to it which the client must later release
      using the ReleaseProcess function.

Return Value:

    Either 
    
    A validated CProcess* pointer for the client.  

    -- OR -- 
    
    NULL -- something is wrong or client cannot be trusted.

--*/
{
    //
    // RPC security callback function has already checked by this point that
    // the call is coming from a local client.
    //
    ASSERT(hClient);

    // Validate client's context handle.
    CProcess* pProcess = ReferenceProcess(phProcess, fNotContext);
    if (pProcess)
    {
        DWORD dwPid;

        if (!RetrievePIDForLocalClient(hClient, &dwPid))
        {
            if (fNotContext)
                ReleaseProcess(pProcess);
            return NULL;
        }
        
        // This check is overkill, RPC does something much like 
        // this in their internal context_handle checks.  But
        // hey, defense-in-depth right?  (and it's cheap to check)
        if (dwPid != pProcess->GetPID())
        {
            ASSERT(!"Should not get here");
            if (fNotContext)
                ReleaseProcess(pProcess);
            return NULL;
        }
    }

    return pProcess;
}

//
// LocalInterfaceOnlySecCallback
//
// RPC security callback function for RPC interfaces that should
// only ever be called by local clients (this is our semantic, not
// RPC's).
//
RPC_STATUS RPC_ENTRY LocalInterfaceOnlySecCallback(
                                IN RPC_IF_HANDLE Interface,
                                IN void *Context
                                ) 
{
    ASSERT(Interface);
    ASSERT(Context);

    if (!CheckLocalCall(Context))
        return RPC_S_ACCESS_DENIED;

    return RPC_S_OK;    
}

//
// Update the channel hook list if it has changed in the registry.
//
void UpdateChannelHooks( LONG *pcChannelHook, GUID **paChannelHook )
{
    BOOL   fSuccess;
    BOOL   fUpdate = FALSE;
    DWORD  result;
    HKEY   hKey;
    DWORD  lType;
    DWORD  lDataSize;
    GUID  *aChannelHook;
    LONG   cChannelHook;
    DWORD  i;
    DWORD  lExtent;
    WCHAR  wExtent[39];
    DWORD  j;

    // Lock
    gpClientLock->LockExclusive();

    // If the handle hasn't been created, create it.
    if (s_hChannelHook == NULL)
    {
        // Nothing can be done if the event can't be created.
        s_hChannelHook = CreateEvent(NULL, FALSE, FALSE, NULL);
        fUpdate = TRUE;
    }

    // If the handle has been created, see if it has been signalled.
    else
    {
        result = WaitForSingleObject(s_hChannelHook, 0);
        fUpdate = result == WAIT_OBJECT_0;
    }

    // Reread the registry if necessary.
    if (fUpdate)
    {
        // Register for changes.
        RegNotifyChangeKeyValue( s_hOle, TRUE,
                                 REG_NOTIFY_CHANGE_NAME       |
                                 REG_NOTIFY_CHANGE_ATTRIBUTES |
                                 REG_NOTIFY_CHANGE_LAST_SET   |
                                 REG_NOTIFY_CHANGE_SECURITY,
                                 s_hChannelHook, TRUE );

        // Open the channel hook key.
        result = RegOpenKeyEx( s_hOle, L"ChannelHook",
                               NULL, KEY_QUERY_VALUE, &hKey );
        if (result == ERROR_SUCCESS)
        {
            // Find out how many values exist.
            cChannelHook = 0;
            RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                             (DWORD *) &cChannelHook, NULL, NULL, NULL, NULL );

            // If there are no channel hooks, throw away the old data.
            if (cChannelHook == 0)
            {
                delete s_aChannelHook;
                s_aChannelHook = NULL;
                s_cChannelHook = 0;
                aChannelHook   = NULL;
            }

            // Reuse the existing array.
            else if (cChannelHook <= s_cChannelHook)
                aChannelHook = s_aChannelHook;

            // Allocate memory for them.
            else
                aChannelHook = new GUID[cChannelHook];

            // If there is not enough memory, don't make changes.
            if (aChannelHook != NULL)
            {

                // Enumerate over the channel hook ids.
                j = 0;
                for (i = 0; i < (DWORD)cChannelHook; i++)
                {

                    // Get the next key.
                    lExtent = sizeof(wExtent) / sizeof(WCHAR);
                    result = RegEnumValueW( hKey, i, wExtent, &lExtent, NULL,
                                           &lType, NULL, NULL );

                    // Convert it to a GUID.  Note that lExtent is set to
                    // the length in characters not bytes despite what
                    // the documentation says.
                    if (result == ERROR_SUCCESS && lExtent == 38 &&
                        lType == REG_SZ &&
                        GUIDFromString( wExtent, &aChannelHook[j] ))
                        j += 1;
                }

                // Save the new channel hook array.
                if (aChannelHook != s_aChannelHook)
                    delete s_aChannelHook;
                s_aChannelHook = aChannelHook;
                s_cChannelHook = j;
            }

            // Close the registry key.
            RegCloseKey( hKey );
        }

        // There are no channel hooks.  Throw away the old data.
        else
        {
            delete s_aChannelHook;
            s_aChannelHook = NULL;
            s_cChannelHook = 0;
        }
    }

    // Return the current channel hook list.
    *paChannelHook = (GUID *) MIDL_user_allocate( s_cChannelHook * sizeof(GUID) );
    if (*paChannelHook != NULL)
    {
        *pcChannelHook = s_cChannelHook;
        memcpy( *paChannelHook, s_aChannelHook, s_cChannelHook * sizeof(GUID) );
    }
    else
        *pcChannelHook = 0;

    // Unlock
    gpClientLock->UnlockExclusive();
}

//
//    Manager (server-side) calls to the local OR interface. lclor.idl
//

error_status_t
_Connect(
    IN  handle_t          hClient,
    IN  WCHAR            *pwszWinstaDesktop,
    OUT PHPROCESS        *phProcess,
    OUT DWORD            *pTimeoutInSeconds,
    OUT DUALSTRINGARRAY **ppdsaOrBindings,
    OUT MID              *pLocalMid,
    IN	ULONG             cIdsToReserve,
    OUT	ID                aIdsReserved[],
    OUT ULONG            *pcIdsReserved,    
    OUT DWORD            *pfConnectFlags,
    OUT WCHAR           **pLegacySecurity,
    OUT DWORD            *pAuthnLevel,
    OUT DWORD            *pImpLevel,
    OUT DWORD            *pcServerSvc,
    OUT USHORT          **aServerSvc,
    OUT DWORD            *pcClientSvc,
    OUT SECPKG          **aClientSvc,
    OUT LONG             *pcChannelHook,
    OUT GUID            **paChannelHook,
    OUT DWORD            *pThreadID,
    OUT DWORD            *pScmProcessID,
    OUT ULONG64          *pSignature,
    OUT GUID             *pguidRPCSSProcessIdentifier
    )
{
    ORSTATUS status;
    CProcess *pProcess;
    CToken *pToken;
    BOOL fRet;
    DWORD dwClientPid;

    // Ensure this is a local client calling
    if (!CheckLocalCall(hClient))
    	return OR_NOACCESS;

    // Get PID of the caller
    if (!RetrievePIDForLocalClient(hClient, &dwClientPid))
    	return OR_NOACCESS;

    // Parameter validation
    if (!pwszWinstaDesktop || !phProcess || !pTimeoutInSeconds ||
        !ppdsaOrBindings || !pLocalMid || !aIdsReserved || !pcIdsReserved ||
        !pfConnectFlags || !pLegacySecurity || !pAuthnLevel ||
        !pImpLevel || !pcServerSvc || !aServerSvc || !pcClientSvc ||
        !aClientSvc ||!pcChannelHook || !paChannelHook || !pThreadID ||
        !pScmProcessID || !pSignature)
    {
        return OR_BADPARAM;
    }

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_INFO_LEVEL,
               "OR: Client connected\n"));

    *pfConnectFlags = 0;
    *pSignature = 0;

    // Fill in security parameters.
    if (s_fEnableDCOM == FALSE)   *pfConnectFlags |= CONNECT_DISABLEDCOM;
    if (s_fCatchServerExceptions) *pfConnectFlags |= CONNECT_CATCH_SERVER_EXCEPTIONS;
    if (s_fBreakOnSilencedServerExceptions) *pfConnectFlags |= CONNECT_BREAK_ON_SILENCED_SERVER_EXCEPTIONS;
    if (s_fMutualAuth) *pfConnectFlags |= CONNECT_MUTUALAUTH;
    if (s_fSecureRefs) *pfConnectFlags |= CONNECT_SECUREREF;

    *pAuthnLevel       = s_lAuthnLevel;
    *pImpLevel         = s_lImpLevel;
	
    // Get legacy security settings
    fRet = GetLegacySecurity(pLegacySecurity);
    if (!fRet)
    {
        return OR_NOMEM;
    }

    // Get client\server svcs
    fRet = GetClientServerSvcs(pcClientSvc, aClientSvc, pcServerSvc, aServerSvc);
    if (!fRet)
    {
        return OR_NOMEM;
    }

    // Fill in channel hooks.
    UpdateChannelHooks( pcChannelHook, paChannelHook );

    // This fails during setup but RPCSS can function anyway.
    RegisterAuthInfoIfNecessary();

    status = StartListeningIfNecessary();
    if (status != OR_OK)
    {
        return(status);
    }

    // Do client specific stuff
    status = CopyMyOrBindings(ppdsaOrBindings, NULL);
    if (status != OR_OK)
    {
        return(status);
    }

    status = LookupOrCreateTokenForRPCClient(hClient, FALSE, &pToken, NULL);
    if (status != OR_OK)
    {
        MIDL_user_free(*ppdsaOrBindings);
        *ppdsaOrBindings = 0;
        return(status);
    }

    pProcess = new CProcess(pToken, pwszWinstaDesktop, dwClientPid, status);
    if (pProcess && status == OR_OK)
    {
        *phProcess = (void *)pProcess;
    }
    else
    {
        if (pProcess)
        {
            ReleaseProcess(pProcess);
        }
        else
        {
            status = OR_NOMEM;
        }
    }

    if (status != OR_OK)
    {
        MIDL_user_free(*ppdsaOrBindings);
        *ppdsaOrBindings = 0;
        *phProcess = 0;
        *pSignature = 0;
        if (pToken)
            pToken->Release();
        return(status);
    }

    *pSignature = (ULONG64)pProcess;
    *pTimeoutInSeconds = BaseTimeoutInterval;
    *pLocalMid = gLocalMid;

    ASSERT( (*phProcess == 0 && *ppdsaOrBindings == 0) || status == OR_OK);

    AllocateReservedIdsInternal(cIdsToReserve,
                                aIdsReserved,
                                pcIdsReserved);

    *pThreadID = InterlockedExchangeAdd((long *)&gNextThreadID,1);
    *pScmProcessID = GetCurrentProcessId();
    *pguidRPCSSProcessIdentifier =  *(pProcess->GetGuidProcessIdentifier());

    return(status);
}


error_status_t
AllocateReservedIdsInternal(
				IN ULONG cIdsToAlloc,
				OUT ID aIdsAllocated[],
				OUT ULONG* pcIdsAllocated)
{
    DWORD i;
    BOOL fResult;
        
    if (cIdsToAlloc > 10) // || cIdsToAlloc < 0)
    {
        cIdsToAlloc = 10;
    }

    for (i = 0; i < cIdsToAlloc; i++)
    {
        fResult = AllocateId(&(aIdsAllocated[i]));
        if (!fResult)
            break;
    }

    *pcIdsAllocated = i;

    // Return OR_OK as long as we were able to allocate 
    // at least one id.  Callers must recognize via *pcIdsAllocated
    // that not all requested ids were allocated.
    return (i > 0) ? OR_OK : OR_NOMEM;    
}


error_status_t
_AllocateReservedIds(
                    IN handle_t hClient,
                    IN PHPROCESS phProcess,
                    IN ULONG cIdsToAlloc,
                    OUT ID aIdsAllocated[],
                    OUT ULONG *pcIdsAllocated
                    )
/*++

Routine Description:

    // Called by local clients to reserve a range of IDs which will
    // not conflict with any other local IDs.

Arguments:

    hClient - the connection of the client.

    phProcess - context handle of the caller

    cIdsToReserve - Number of IDs to reserve.

    pidReservedBase - Starting value of the reserved IDs.  The
        lower DWORD of this can be increatmented to generate
        cIdsToReserve unique IDs.

Return Value:

    OR_OK

--*/
{
    // Ensure this is a local client calling
    CProcess* pProcess = CheckLocalSecurity(hClient, phProcess);
    if (!pProcess)
    	return OR_NOACCESS;

    // Parameter validation
    if (!aIdsAllocated || !pcIdsAllocated)
        return OR_BADPARAM;

    return AllocateReservedIdsInternal(
                        cIdsToAlloc,
                        aIdsAllocated,
                        pcIdsAllocated);                        
}



RPC_STATUS
NegotiateDCOMVersion(
                    IN OUT  COMVERSION *pVersion
                    )
/*++

Routine Description:

    // Called when we receive a COMVERSION from a remote machine
    // to determine which DCOM protocol level to talk.

Arguments:

    pVersion - version of the remote machine. Modified if necessary
               by this routine to be the lower of the two versions.

Return Value:

    OR_OK

--*/
{
    // Parameter validation
    if (!pVersion)
        return OR_BADPARAM;

    if (pVersion->MajorVersion == COM_MAJOR_VERSION)
    {
        if (pVersion->MinorVersion > COM_MINOR_VERSION)
        {
            // since the client has a lower minor version number,
            // use the lower of the two.
            pVersion->MinorVersion = COM_MINOR_VERSION;
        }

        return OR_OK;
    }
    return RPC_E_VERSION_MISMATCH;
}



error_status_t
_ClientResolveOXID(
                  IN  handle_t hClient,
                  IN  PHPROCESS phProcess,
                  IN  OXID *poxidServer,
                  IN  DUALSTRINGARRAY *pdsaServerBindings,
                  IN  LONG fApartment,
                  OUT OXID_INFO *poxidInfo,
                  OUT MID *pDestinationMid,
                  OUT unsigned long *pulMarshaledTargetInfoLength,
                  OUT unsigned char **pucMarshaledTargetInfo,
                  OUT USHORT *pusAuthnSvc
                  )
/*++

Routine Description:

    Discovers the OXID_INFO for an oxid.  Will find local
    OXIDs without any help.  It needs OR bindings in order
    to discover remote OXIDs.

Arguments:

    phProcess - The context handle of the process.

    poxidServer - The OXID (a uuid) to resolve.

    pdsaServerBindings - Compressed string bindings to
        the OR on the server's machine.

    fApartment - non-zero if the client is aparment model.
                REVIEW: What to do with mixed model clients?
                What to do when auto registering an OID?


    poxidInfo - If successful this will contain information about the oxid and
        an expanded string binding to the server oxid's process.


    pulAuthnSvc - if successful this will contain the exact id (ie, will not be snego)
        of the authn svc used to talk to the server.

Return Value:

    OR_NOMEM - Common.

    OR_BADOXID - Unable to resolve it.

    OR_OK - Success.

--*/
{
    CProcess* pProcess = CheckLocalSecurity(hClient, phProcess);
    if (!pProcess)
    	return OR_NOACCESS;
	
    // Parameter validation done below in ResolveClientOXID

    return ResolveClientOXID( hClient,
                              poxidServer,
                              pdsaServerBindings,
                              fApartment,
                              0,
                              NULL,
                              poxidInfo,
                              pDestinationMid,
                              FALSE,
                              RPC_C_AUTHN_NONE,
                              0,
			      NULL,
			      NULL,
			      pulMarshaledTargetInfoLength,
			      pucMarshaledTargetInfo,
                              pusAuthnSvc);
}

error_status_t
ResolveClientOXID(
                 handle_t hClient,
                 OXID *poxidServer,
                 DUALSTRINGARRAY *pdsaServerBindings,
                 LONG fApartment,
                 USHORT wProtseqId,
                 WCHAR  *pMachineName,
                 OXID_INFO *poxidInfo,
                 MID *pDestinationMid,
                 BOOL   fUnsecure,
                 USHORT wAuthnSvc,
                 unsigned long ulMarshaledTargetInfoLengthIn,
                 unsigned char *pMarshaledTargetInfoIn,
                 BOOL* pIsLocalOxid,
                 unsigned long *pulMarshaledTargetInfoLength,
                 unsigned char **pucMarshaledTargetInfo,
                 USHORT* pusAuthnSvc
                 )
/*++

Routine Description:

    Discovers the OXID_INFO for an oxid.  Will find local
    OXIDs without any help.  It needs OR bindings in order
    to discover remote OXIDs.

Arguments:

    hClient - rpc handle of the client (caller has already been verified
        as being a valid local client)
		
	poxidServer - The OXID (a uuid) to resolve.

    pdsaServerBindings - Compressed string bindings to
        the OR on the server's machine.

    fApartment - non-zero if the client is aparment model.
                REVIEW: What to do with mixed model clients?
                What to do when auto registering an OID?


    poxidInfo - If successful this will contain information about the oxid and
        an expanded string binding to the server oxid's process.

    fUnsecure - if TRUE, activation was done unsecurely so set
        MID appropriately.

    wAuthnSvc - Hint of authentication service that might work or
        RPC_C_AUTHN_NONE if no hint.

    pusAuthnSvc - if successful this will contain the exact id (ie, will not be snego)
        of the authn svc used to talk to the server.

Return Value:

    OR_NOMEM - Common.

    OR_BADOXID - Unable to resolve it.

    OR_OK - Success.

--*/
{
    CClientOxid *pOxid = NULL;
    CServerOxid *pServerOxid;
    CMid        *pMid;
    ORSTATUS     status = OR_OK;
    BOOL         fReference;
    BOOL         fServerApartment = FALSE;
    BOOL         fResolved = FALSE;
    BOOL         fLazyReleaseNewCopyOfpOxid = FALSE;
    DWORD        i          = 0;
    WCHAR       *pPrincipal = NULL;
    WCHAR       *pMachineNameFromBindings = NULL;
    BOOL         fImpersonating = FALSE;
    unsigned long ulMarshaledTargetInfoLength = 0;
    unsigned char* pMarshaledTargetInfo = NULL;

    // Parameter validation
    if (!poxidServer || !pdsaServerBindings || !poxidInfo ||
        !pDestinationMid || !pusAuthnSvc)
    {
        return OR_BADPARAM;
    }

    if (! dsaValid(pdsaServerBindings))
    {
        return(OR_BADPARAM);
    }

    // If wProtseqId == ID_DCOMHTTP, we should impersonate
    // because RPC will read some info from HKEY_CURRENT_USER.
    // Sometimes ole32 will call us with 0 wProtseqId, in
    // which cases we'll have to look at pdsaServerBindings.

    if(wProtseqId == ID_DCOMHTTP)
    {
        fImpersonating = (RpcImpersonateClient(hClient) == RPC_S_OK);
    }
    else if(wProtseqId == 0)
    {
        if(pdsaServerBindings && pdsaServerBindings->aStringArray
            && *(pdsaServerBindings->aStringArray) == ID_DCOMHTTP)
        {
            fImpersonating = (RpcImpersonateClient(hClient) == RPC_S_OK);
        }
    }

    // Attempt to lookup MID and OXID

    gpClientLock->LockExclusive();

    CMidKey midkey(pdsaServerBindings);

    pMid = (CMid *)gpMidTable->Lookup(midkey);

    if (0 == pMid)
    {
        BOOL fMidInitOkay = FALSE;

        fReference = TRUE;
        pMid = new(pdsaServerBindings->wNumEntries * sizeof(WCHAR)) CMid(pdsaServerBindings, FALSE, 0, &fMidInitOkay);
        if (pMid && fMidInitOkay)
        {
            gpMidTable->Add(pMid);
            pMid->SetAuthnSvc(wAuthnSvc);
            status = pMid->SetMarshaledTargetInfo(ulMarshaledTargetInfoLengthIn, pMarshaledTargetInfoIn);
        }
        else
        {
            // No mem, or failed to init
            if (pMid)
            {
                delete pMid;
                pMid = NULL;
            }
            status = OR_NOMEM;
        }
    }
    else
    {
        fReference = FALSE;
    }

    if (status == OR_OK)
    {
        CId2Key oxidkey(*poxidServer, pMid->Id());

        pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);

        if (0 == pOxid)
        {
            if (!fReference)
            {
                pMid->Reference();
                fReference = TRUE;
            }

            // Need to allocate the OXID.  First step is too resolve it
            // either locally or remotely.

            gpClientLock->UnlockExclusive();

            if (pMid->IsLocal())
            {
                // Local OXID, lookup directly

                gpServerLock->LockShared();

                CIdKey key(*poxidServer);
                pServerOxid = (CServerOxid *)gpServerOxidTable->Lookup(key);

                if (pServerOxid)
                {
                    status = pServerOxid->GetInfo(poxidInfo, TRUE);
                    fServerApartment = pServerOxid->Apartment();
                    // reset the protseq id so we use LRPC.
                    wProtseqId = 0;
                    pMachineName = NULL;
                }
                else
                {
                    status = OR_BADOXID;
                }
                ASSERT(status != OR_OK || dsaValid(poxidInfo->psa));
                gpServerLock->UnlockShared();

            }
            else if (0 == poxidInfo->psa)
            {
                // Remote OXID, call ResolveOxid

                handle_t hRemoteOr;
                USHORT   iBinding;

                poxidInfo->psa = 0;

                ASSERT(!pMachineName);
                status = OR_NOMEM;

                hRemoteOr = pMid->GetBinding();

                if (hRemoteOr)
                {
                    if (pMid->IsSecure())
                    {
                        i = 0;

                        // Form server principal name
                        pMachineNameFromBindings = ExtractMachineName( pMid->GetStringBinding() );
                        if (pMachineNameFromBindings)
                        {
                          pPrincipal = new WCHAR[lstrlenW(pMachineNameFromBindings) +
                                                 (sizeof(RPCSS_SPN_PREFIX) / sizeof(WCHAR)) + 1];
                          if (pPrincipal)
                          {
                            lstrcpyW(pPrincipal, RPCSS_SPN_PREFIX);
                            lstrcatW(pPrincipal, pMachineNameFromBindings);
                          }
                          delete pMachineNameFromBindings;
                        }
                        // It is possible that we already impersonated above,
                        // so it might be unnecessary to do it here.
                        if(!fImpersonating)
                        {
                            status     = RpcImpersonateClient(hClient);
                            if (status != RPC_S_OK)
                            {
                                KdPrintEx((DPFLTR_DCOMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "OR: Unable to impersonate for resolve %d\n",
                                           status));
                            }
                        }
                    }
                    else
                    {
                        i = s_cRpcssSvc+1;
                    }

                    // The loop index has the following meanings:
                    //    0                     - Try pMid->GetAuthnSvc
                    //    1 through s_cRpcssSvc - Try s_aRpcssSvc
                    //    s_cRpcssSvc+1         - Try unsecure
                    USHORT wFirstSvc = pMid->GetAuthnSvc();
                    for (; i < s_cRpcssSvc + 2; i++)
                    {
                        BOOL bSetSecurityCallBack = FALSE;
                        USHORT usAuthSvcFromCallback;

                        // Choose an authentication service.
                        if (i < s_cRpcssSvc+1)
                        {
                            if (i == 0)
                                wAuthnSvc = wFirstSvc;
                            else
                            {
                                // Skip this authentication service if already
                                // tried.
                                wAuthnSvc = s_aRpcssSvc[i-1].wId;
                                if (wAuthnSvc == wFirstSvc)
                                    continue;
                            }

                            // See if the server uses this authentication service.
                            if (ValidAuthnSvc( pMid->GetStrings(), wAuthnSvc ))
                            {
                                RPC_SECURITY_QOS  qos;
                                qos.Version           = RPC_C_SECURITY_QOS_VERSION;
                                qos.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
                                qos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
                                qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                                if (wAuthnSvc == RPC_C_AUTHN_GSS_NEGOTIATE)
                                {
                                      // if using snego, we need to know what sec pkg is eventually negotiated:
                                   if (gpCRpcSecurityCallbackMgr->RegisterForRpcAuthSvcCallBack(hRemoteOr))
                                      bSetSecurityCallBack = TRUE;
                                }

                                // Set the security info
                                // AuthnSvc is unsigned long and 0xFFFF gets 0 extended
                                status = RpcBindingSetAuthInfoEx(hRemoteOr,
                                                             pPrincipal,
                                                             RPC_C_AUTHN_LEVEL_CONNECT,
                                                             wAuthnSvc != 0xFFFF ? wAuthnSvc
                                                                                 : RPC_C_AUTHN_DEFAULT,
                                                             NULL,
                                                             0,
                                                             &qos);                                
                                if (status != RPC_S_OK)
                                {
                                    KdPrintEx((DPFLTR_DCOMSS_ID,
                                               DPFLTR_WARNING_LEVEL,
                                               "OR: RpcBindingSetAuthInfo to %d failed!! %d\n",
                                               wAuthnSvc,
                                               status));

                                    if (bSetSecurityCallBack)
                                    {
                                      // Get rid of our callback registration
                                       unsigned long ulIgnore = 0;
                                       unsigned char *pucIgnore = NULL; 
                                       // Get rid of our callback registration
                                       gpCRpcSecurityCallbackMgr->GetSecurityContextDetailsAndTurnOffCallback(hRemoteOr, NULL,
                                                                          &ulIgnore, &pucIgnore);
                                       if (ulIgnore) 
                                       {
                                          MIDL_user_free(pucIgnore);
                                       }
                                    }
                                    continue;
                                }
                            }
                            else
                                continue;
                        }

                        // Force the binding handle unsecure.
                        else if (pMid->IsSecure())
                        {
                            wAuthnSvc = RPC_C_AUTHN_NONE;
                            status = RpcBindingSetAuthInfo(hRemoteOr,
                                                           0,
                                                           RPC_C_AUTHN_LEVEL_NONE,
                                                           RPC_C_AUTHN_NONE,
                                                           0,
                                                           0);
                            if (status != RPC_S_OK)
                            {
                                KdPrintEx((DPFLTR_DCOMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "OR: RpcBindingSetAuthInfo to NONE failed!! %d\n",
                                           status));
                            }
                        }

                        // try calling ResolveOxid2 first, if that fails,
                        // try ResolveOxid.
                        status = ResolveOxid2(hRemoteOr,
                                              poxidServer,
                                              cMyProtseqs,
                                              aMyProtseqs,
                                              &poxidInfo->psa,
                                              &poxidInfo->ipidRemUnknown,
                                              &poxidInfo->dwAuthnHint,
                                              &poxidInfo->version
                                             );

                        if (status == RPC_S_PROCNUM_OUT_OF_RANGE)
                        {
                            // must be a downlevel server (COMVERSION == 5.1), try calling on
                            // the old ResolveOXID method.

                            // REVIEW if it's a downlevel server what does this mean wrt
                            // bug 406902 and the snego mess?   I think we're still okay.
                            poxidInfo->version.MajorVersion = COM_MAJOR_VERSION;
                            poxidInfo->version.MinorVersion = COM_MINOR_VERSION_1;
                            poxidInfo->dwFlags   = 0;

                            status = ResolveOxid(hRemoteOr,
                                                 poxidServer,
                                                 cMyProtseqs,
                                                 aMyProtseqs,
                                                 &poxidInfo->psa,
                                                 &poxidInfo->ipidRemUnknown,
                                                 &poxidInfo->dwAuthnHint
                                                );
                        }
                        
                        // At this point we are done making calls on the binding handle

                        // Turn off the security callback no matter what the result of
                        // the call was
                        if (bSetSecurityCallBack)
                        {
                          if (status == OR_OK)
                          {
                             if (!gpCRpcSecurityCallbackMgr->GetSecurityContextDetailsAndTurnOffCallback(hRemoteOr,
                                                                    &usAuthSvcFromCallback, &ulMarshaledTargetInfoLength,
                                                                    &pMarshaledTargetInfo))
                             {
                                // something went wrong.  Basically we don't trust what the callback
                                // told us.   Fall back on the original behavior
                                bSetSecurityCallBack = FALSE;
                             }
                          }
                          else
                          {
                            // call did not go through; just cancel the callback registration
                            gpCRpcSecurityCallbackMgr->GetSecurityContextDetailsAndTurnOffCallback(hRemoteOr, NULL,
                                                                &ulMarshaledTargetInfoLength, &pMarshaledTargetInfo);
                            bSetSecurityCallBack = FALSE;
                          }
                        }

                        if (status == OR_OK)
                        {
                            status = NegotiateDCOMVersion(&poxidInfo->version);
                        }
                        else
                        {
                           if (ulMarshaledTargetInfoLength) 
                           {
                              MIDL_user_free(pMarshaledTargetInfo);
                           }
                        }

                        if (status == OR_OK)
                        {
                            // Remember which auth.svc got used:
                            if (bSetSecurityCallBack)
                            {
                              // we should not have set it unless we're using snego, and we
                              // should have gotten something other than snego back
                              ASSERT(wAuthnSvc == RPC_C_AUTHN_GSS_NEGOTIATE &&
                                     usAuthSvcFromCallback != RPC_C_AUTHN_GSS_NEGOTIATE);

                              // Set the negotiated pkg;  if we got back Kerberos, then cache
                              // Snego.   This will partially fix the fact that we are
                              // hard-coding the authn svc for all future users of this mid
                              if (usAuthSvcFromCallback == RPC_C_AUTHN_GSS_KERBEROS)
                                pMid->SetAuthnSvc( RPC_C_AUTHN_GSS_NEGOTIATE );
                              else
                                pMid->SetAuthnSvc( usAuthSvcFromCallback );
                              pMid->SetMarshaledTargetInfo(ulMarshaledTargetInfoLength, pMarshaledTargetInfo);
                            }
                            else
                            {
                              // Just use whatever was set on the call
                              pMid->SetAuthnSvc( wAuthnSvc );
                              if (ulMarshaledTargetInfoLength) 
                              {
                                 MIDL_user_free(pMarshaledTargetInfo);
                              }
                            }

                            if (dsaValid(poxidInfo->psa))
                            {
                                wProtseqId = poxidInfo->psa->aStringArray[0];
                            }
                            else
                            {
                                KdPrintEx((DPFLTR_DCOMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "OR: Server %s returned a bogus string array: %p\n",
                                           pMid->PrintableName(),
                                           poxidInfo->psa));

                                ASSERT(0);
                                if (poxidInfo->psa)
                                {
                                    MIDL_user_free(poxidInfo->psa);
                                    poxidInfo->psa = 0;
                                }
                                status = OR_BADOXID;
                            }
                            break;
                        }
                        else if (status != RPC_S_ACCESS_DENIED         &&
                                 status != RPC_S_UNKNOWN_AUTHN_SERVICE &&
                                 status != RPC_S_UNKNOWN_AUTHZ_SERVICE &&
                                 status != RPC_S_SEC_PKG_ERROR )
                        {
                            KdPrintEx((DPFLTR_DCOMSS_ID,
                                       DPFLTR_WARNING_LEVEL,
                                       "OR: Remote resolve OXID failed %d\n",
                                       status));

                            break;
                        }
                    }

                    RpcBindingFree(&hRemoteOr);
                    delete pPrincipal;
                    pPrincipal = NULL;
                }
            }
            // Else it's a remote MID, but we were given the OXID info
            // and protseq id from the SCM after a remote activation.
            else
                fResolved = TRUE;

            gpClientLock->LockExclusive();

            ASSERT(fReference);

            if (   OR_OK == status
                   && (pMid->GetAuthnSvc() == RPC_C_AUTHN_NONE ||
                       TRUE  == fUnsecure) )
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "OR: Machine %S, unsecure retry ok, assuming no sec\n",
                           pMid->PrintableName()));
                pMid->SecurityFailed();
            }

            if (status == OR_OK)
            {
                // Lookup the oxid again to make sure it hasn't been added in the meantime.

                pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);

                if (0 == pOxid)
                {
                    ASSERT(dsaValid(poxidInfo->psa));
                    pOxid = new CClientOxid(*poxidServer,
                                            pMid,
                                            wProtseqId,
                                            pMachineName,
                                            fServerApartment);

                    if (0 != pOxid)
                    {
                        status = pOxid->UpdateInfo(poxidInfo);

                        if (OR_OK == status)
                        {
                            gpClientOxidTable->Add(pOxid);
                        }
                        else
                        {
                            // Will release mid, will also remove it (unnecessarily)
                            // from the table.
                            delete pOxid;
                            pOxid = NULL;
                        }
                    }
                    else
                    {
                        status = OR_NOMEM;
                        pMid->Release();  // May actually go away..
                    }
                }
                else
                {
                    // Release our now extra reference on the MID
                    DWORD t = pMid->Release();
                    ASSERT(t > 0);
                    pOxid->Reference();
                }

                MIDL_user_free(poxidInfo->psa);
                poxidInfo->psa = 0;
            }
            else
            {
                // Resolve failed, get rid of our extra reference.
                pMid->Release();
            }
        }
        else
        {
            // Found the OXID, must also have found the MID
            ASSERT(fReference == FALSE);

            fResolved = TRUE;

            if ( poxidInfo->psa )
            {
                MIDL_user_free(poxidInfo->psa);
                poxidInfo->psa = 0;
            }

            pOxid->Reference();
        }
    }

    ASSERT( (status != OR_OK) || (pOxid && pMid) );

    if (   status == OR_OK
           && pOxid->IsLocal() == FALSE)
    {
        if (fResolved)
            *poxidServer = 0;
    }

    if(NULL != pIsLocalOxid)
    {
        if((status == OR_OK) && pOxid->IsLocal())
            *pIsLocalOxid = TRUE;
        else
            *pIsLocalOxid = FALSE;
    }

    if (status == OR_OK)
    {
        *pDestinationMid = pMid->Id();

        *pusAuthnSvc = pMid->GetAuthnSvc();
        if (pulMarshaledTargetInfoLength && pucMarshaledTargetInfo) 
        {
           status = pMid->GetMarshaledTargetInfo(pulMarshaledTargetInfoLength, pucMarshaledTargetInfo);
        }

        // GetInfo may release the lock
        status = pOxid->GetInfo(fApartment, poxidInfo);
    }

    if (pOxid)
    {
        pOxid->Release();
    }
    gpClientLock->UnlockExclusive();

    return(status);
}


void
FreeServerOids(
               CProcess *pProcess,
               ULONG cServerOidsToFree,
               OID aServerOidsToFree[]
              )
/*++

Routine Description:

    Frees the OIDs passed in.

Arguments:

    phProcess - The context handle of the process.
        Since this is called from SCM directly this function
        CAN BE called on the same process by more then one
        thread at a time.

    cServerOidsToFree - Count of entries in aServerOidsToFree

    aServerOidsToFree - OIDs allocated by the server process
        and no longer needed.

--*/
{
//    KdPrintEx((DPFLTR_DCOMSS_ID,
//               DPFLTR_WARNING_LEVEL,
//               "OR: FreeServerOids: pProcess:%x cOids:%x pOids:%x\n",
//               pProcess,
//               cServerOidsToFree,
//               aServerOidsToFree));

    ASSERT(gpServerLock->HeldExclusive());

    if (cServerOidsToFree)
    {
        CServerOid *pOid;
        CServerOxid *pOxid;

        for (ULONG i = 0; i < cServerOidsToFree; i++)
        {
            CIdKey oidkey(aServerOidsToFree[i]);

            pOid = (CServerOid *)gpServerOidTable->Lookup(oidkey);
            if (pOid && pOid->IsRunningDown() == FALSE)
            {
                pOxid = pOid->GetOxid();
                ASSERT(pOxid);
                if (pProcess->IsOwner(pOxid))
                {
                    if (pOid->References() == 0)
                    {
                        pOid->Remove();
                        pOid->SetRundown(TRUE);
                        delete pOid;
                    }
                    else
                    {
                        pOid->Free();
                    }
                }
                else
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "OR: Process %p tried to free OID %p it didn't own\n",
                               pProcess,
                               pOid));
                }
            }
            else
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Process %p freed OID %p that didn't exist\n",
                           pProcess,
                           &aServerOidsToFree[i]));
            }
        }
    }
}


error_status_t
_BulkUpdateOIDs(
               IN handle_t hClient,
               IN PHPROCESS phProcess,
               IN ULONG cOidsToBeAdded,
               IN OXID_OID_PAIR aOidsToBeAdded[],
               OUT LONG aStatusOfAdds[],
               IN ULONG cOidsToBeRemoved,
               IN OID_MID_PAIR aOidsToBeRemoved[],
               IN ULONG cServerOidsToFree,
               IN OID aServerOidsToFree[],
               IN ULONG cServerOidsToUnPin,
               IN OID aServerOidsToUnPin[],
               IN ULONG cClientOxidsToFree,
               IN OXID_REF aClientOxidsToFree[]
               )
/*++

Routine Description:

    Updates the set of remote OIDs in use by a process.

Note:

    An OID maybe removed before it is added.  This means that
    the client was using it and is no longer using it.  In
    this case a single delete from set ping is made to keep
    the object alive.  This is only needed if the client
    has remarshalled a pointer to the object.

Arguments:

    phProcess - Context handle for the process.

    cOidsToBeAdded - Count of aOidsToBeAdded and aStatusOfAdds

    aOidsToBeAdded - OID-OXID-MID pairs representing the
        oids and the owning oxids to add.

    aStatusOfAdds - Some adds may succeed when other fail.
        OR_NOMEM - couldn't allocate storage
        OR_BADOXID - OXID doesn't exist.
        OR_OK (0) - added to set

    cOidsToBeRemoved - Count of entries in aOidsToBeRemoved.

    aOidsToBeRemoved - OID-MID pairs to be removed.

    cServerOidsToFree - Count of entries in aServerOidsToFree

    aServerOidsToFree - OIDs allocated by the client process
        and no longer needed.

    cServerOidsToUnPin - Count of entries in aServerOidsToUnPin

    aServerOidsToUnPin - OIDs that the client process previously 
	    told us were pinned\locked, and now no longer are.

    cClientOxidsToFree - COunt of enties in aClientOxidsToFree

    aClientOxidsToFree - OXIDs owned by a process (due to a direct
        or indirect call to ClientResolveOxid) which are no longer
        in use by the client.

Return Value:

    OR_OK - All updates completed ok.

    OR_PARTIAL_UPDATE - At least one entry in aStatusOfAdds is not OR_OK

--*/
{
    CProcess    *pProcess;
    CClientOxid *pOxid;
    CClientOid  *pOid;
    CClientSet  *pSet;
    CMid        *pMid;
    CToken      *pToken;
    BOOL         fPartial = FALSE;
    BOOL         fNewSet = FALSE;
    DUALSTRINGARRAY *pdsa = NULL;
    ULONG i;

    pProcess = CheckLocalSecurity(hClient, phProcess);
    if (!pProcess)
    	return OR_NOACCESS;

    // Parameter validation.  If zero is passed for the size-of-array param
    // then we don't care about the array param itself (since we never 
    // look at it)  
    if (!(cOidsToBeAdded > 0 ? (aOidsToBeAdded != NULL) : TRUE) ||
        !(cOidsToBeAdded > 0 ? (aStatusOfAdds != NULL) : TRUE) ||
        !(cOidsToBeRemoved > 0 ? (aOidsToBeRemoved != NULL) : TRUE) ||
        !(cServerOidsToFree > 0 ? (aServerOidsToFree != NULL): TRUE) ||
        !(cServerOidsToUnPin > 0 ? (aServerOidsToUnPin != NULL): TRUE) ||
        !(cClientOxidsToFree > 0 ? (aClientOxidsToFree != NULL) : TRUE))
    {
        return OR_BADPARAM;
    }

    if (cOidsToBeAdded || cOidsToBeRemoved)
    {
        ORSTATUS status = CopyMyOrBindings(&pdsa, NULL);
        if (status != RPC_S_OK)
        {
            return status;
        }
        gpClientLock->LockExclusive();
    }

    // /////////////////////////////////////////////////////////////////
    // Process Adds.

    for (i = 0; i < cOidsToBeAdded; i++)
    {
       fNewSet = FALSE;
        // Lookup up the oxid owning this new oid.

        CId2Key oxidkey(aOidsToBeAdded[i].oxid, aOidsToBeAdded[i].mid);

        pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);

        if (0 == pOxid)
        {
            OXID_INFO infoT;
            ORSTATUS  status;
            MID mid;

            gpClientLock->UnlockExclusive();

            infoT.psa = 0;

            USHORT usAuthnSvc;
            status = _ClientResolveOXID(hClient,
                                        phProcess,
                                        &aOidsToBeAdded[i].oxid,
                                        pdsa,
                                        TRUE,
                                        &infoT,
                                        &mid,
                                        NULL,
                                        NULL,
                                        &usAuthnSvc);

            gpClientLock->LockExclusive();

            if (status == OR_OK)
            {
                ASSERT(infoT.psa);
                ASSERT(mid == gLocalMid);
                MIDL_user_free(infoT.psa);
                pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);
                if (pOxid == 0)
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "OR: Auto resolving oxid %p failed, wrong machine\n",
                               &oxidkey));

                    status = OR_BADOXID;
                }
            }

            if (status != OR_OK)
            {
                aStatusOfAdds[i] = OR_BADOXID;
                fPartial = TRUE;
                continue;
            }
        }


        // Find or create the set.

        CId2Key setkey(aOidsToBeAdded[i].mid, (ID)pProcess->GetToken());

        pSet = (CClientSet *)gpClientSetTable->Lookup(setkey);

        if (pSet == 0)
        {
            pSet = new CClientSet(pOxid->GetMid(), pProcess->GetToken());

            if (pSet == 0)
            {
                aStatusOfAdds[i] = OR_NOMEM;
                fPartial = TRUE;
                continue;
            }
            else
            {
                gpClientSetTable->Add(pSet);
                pSet->Insert();
                fNewSet = TRUE;
            }
        }

        // Find or create the oid.  If we create it, add a reference
        // to the oxid for the new oid.

        CId3Key oidkey(aOidsToBeAdded[i].oid, aOidsToBeAdded[i].mid, pProcess->GetToken());

        pOid = (CClientOid *)gpClientOidTable->Lookup(oidkey);

        if (0 == pOid)
        {
            pOid = new CClientOid(aOidsToBeAdded[i].oid,
                                  aOidsToBeAdded[i].mid,
                                  pProcess->GetToken(),
                                  pOxid,
                                  pSet
                                 );
            if (fNewSet)
            {
                if (!pOid) 
                {
                   pSet->Remove();
                }
                // pOid either owns a refernce now or we need to
                // cleanup the set anyway.
                pSet->Release();
            }

            if (pOid)
            {

                aStatusOfAdds[i] = pSet->RegisterObject(pOid);

                if (aStatusOfAdds[i] == OR_OK)
                {
                    gpClientOidTable->Add(pOid);
                }
                else
                {
                    if (fNewSet)
                    {
		      pSet->Remove();
                    }
		    pOid->ClientRelease();
                    pOid->Release();
                    pOid = 0;
                    fPartial = TRUE;
                    continue;
                }
            }
            else
            {
                aStatusOfAdds[i] = OR_NOMEM;
                fPartial = TRUE;
                continue;
            }

        }
        else
        {
            ASSERT(fNewSet == FALSE);
            pOid->ClientReference();
        }

        // If this fails it will release the oid.
        aStatusOfAdds[i] = pProcess->AddOid(pOid);
        if (aStatusOfAdds[i] != OR_OK)
        {
            fPartial = TRUE;
        }
    } // for oids to add

    // /////////////////////////////////////////////////////////////////
    // Process deletes

    for (i = 0; i < cOidsToBeRemoved; i++)
    {
        CId3Key oidkey(aOidsToBeRemoved[i].oid,
                       aOidsToBeRemoved[i].mid,
                       pProcess->GetToken());

        pOid = (CClientOid *)gpClientOidTable->Lookup(oidkey);

        if (pOid)
        {
            CClientOid *pT = pProcess->RemoveOid(pOid);

            if (pT == 0)
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Client process %p tried to remove oid %p which"
                           "it didn't own\n",
                           pProcess,
                           &aOidsToBeRemoved[i]));
            }
            else
                ASSERT(pT == pOid);
        }
        else
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Client %p removed an OID that doesn't exist\n",
                       pProcess));

    } // for oids to delete


    if (cOidsToBeAdded || cOidsToBeRemoved)
    {
        gpClientLock->UnlockExclusive();
    }
	
    ///////////////////////////////////////////////////////////////////
    // Process server oid deletes
    //
    if (cServerOidsToFree > 0)
    {
        gpServerLock->LockExclusive();
        FreeServerOids(pProcess, cServerOidsToFree, aServerOidsToFree);
        gpServerLock->UnlockExclusive();
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Process server oid unpins.  We do not have an array of individual 
    // status update values for this operation; if the client gets back 
    // a success code from BulkUpdateOids, it can assume that all of the 
    // requested unpins were executed correctly.
    //
    // Also note that it is *always* safe to unpin an oid even if it should
    // remain pinned; the worse that can happen is extra rundown calls.
    //
    if (cServerOidsToUnPin > 0)
    {
        gpServerLock->LockExclusive();

        for (i = 0; i < cServerOidsToUnPin; i++)
        {
            CServerOid* pOid;

            CIdKey key(aServerOidsToUnPin[i]);

            pOid = (CServerOid *)gpServerOidTable->Lookup(key);

            // Only unpin the oid if the calling process owns it.  Don't
            // assert if we didn't find it, since under stress we may
            // be executing this code after the owning process\apt died.
            if (pOid && pProcess->IsOwner(pOid->GetOxid()))
            {
                if (pOid->IsPinned())
                {
                    pOid->SetPinned(FALSE);
                }            
            }
        }

        gpServerLock->UnlockExclusive();
    }


    // Done
    if (pdsa)
    {
        MIDL_user_free(pdsa);
    }

    if (fPartial)
    {
        return(OR_PARTIAL_UPDATE);
    }

    return(OR_OK);
}


error_status_t ServerAllocateOIDsInternal(
                                  IN  CProcess* pProcess,
                                  IN  OXID      *poxidServer,
                                  IN  ULONG     cOidsReturn,
                                  IN  OID       aOidsReturn[],
                                  IN  ULONG     cOids,
                                  OUT OID       aOids[],
                                  OUT PULONG    pOidsAllocated
                                  )
/*++
Routine Description:

    Function for registering additional OIDs on behalf of an existing 
    OXID.  

Arguments:

    pProcess - The process containing the OXID and OIDs.

    poxidServer - The OXID associated with the OIDs.

    cOidsReturn - Count of aOidsReturn

    aOidsReturn - Array of OIDs the process is no longer using.

    cOids - Count of aOids

    aOids - The OIDs to register within the OXID.

    pOidsAllocate - Contains the number of OIDs actually allocated
        when this function returns success.

Return Value:

    OR_OK - Success.   At least one OID was allocated (caller should
      check *pOidsAllocated for the actual number allocated, it may be
      less than he requested).

    OR_BADOXID - Cannot find the specified OXID

    OR_NOMEM - Out of memory resource failure

--*/
{
    ORSTATUS status = OR_OK;
    CServerOxid *pOxid;
    CServerOid *pOid;

    // Parameter validation
    if (!poxidServer || 
        !(cOidsReturn > 0 ? (aOidsReturn != NULL) : TRUE) ||
        !((cOids > 0 ? (aOids != NULL) : TRUE) ||
        !pOidsAllocated))
    {
        return OR_BADPARAM;
    }

    gpServerLock->LockExclusive();

    CIdKey oxidkey(*poxidServer);

    pOxid = (CServerOxid *)gpServerOxidTable->Lookup(oxidkey);

    if (0 == pOxid)
    {
        gpServerLock->UnlockExclusive();
        status = OR_BADOXID;
        return(status);
    }

    if (cOidsReturn)
    {
        // free the Oids returned
        FreeServerOids(pProcess, cOidsReturn, aOidsReturn);
    }

    *pOidsAllocated = 0;

    for (ULONG i = 0; i < cOids; i++)
    {
        ID id;
        if (AllocateId(&id))
        {
            pOid = new CServerOid(pOxid, id);
            if (NULL != pOid)
            {                   
                (*pOidsAllocated)++;
                aOids[i] = id;
                gpServerOidTable->Add(pOid);

                // The server doesn't want to keep the OID alive.
                // This will cause the OID to rundown in six minutes
                // unless a set references it in the meantime...
                pOid->Release();
            }
            else
            {
                // out-of-mem
                break;
            }
        }
        else
        {
            // failed to allocate id
            break;
        }
    }

    gpServerLock->UnlockExclusive();

    // If caller asked us to allocate oids, and we were able to allocate at least
    // one, return OR_OK (ole32 will handle this).   If not able to allocate any
    // of the requested oids, return OR_NOMEM.
    //
    // If caller didn't ask for any oids to be allocated, just return OR_OK.
    //
    if (cOids > 0)
    {
        return (((*pOidsAllocated) > 0) ? OR_OK : OR_NOMEM);
    }

    return OR_OK;
}


error_status_t _ServerAllocateOIDs(
                                  IN  handle_t  hClient,
                                  IN  PHPROCESS phProcess,
                                  IN  OXID      *poxidServer,
                                  IN  ULONG     cOidsReturn,
                                  IN  OID       aOidsReturn[],
                                  IN  ULONG     cOids,
                                  OUT OID       aOids[],
                                  OUT PULONG    pOidsAllocated
                                  )
/*++

Routine Description:

    RPC entry point for registering additional OIDs on behalf of an existing 
    OXID.  Does a security check and delegates to the internal helper function.
    
    See ServerAllocateOIDsInternal for parameter descriptions and a more detailed
    functional description.

--*/
{
    CProcess* pProcess = CheckLocalSecurity(hClient, phProcess);
    if (!pProcess)
        return OR_NOACCESS;

    return ServerAllocateOIDsInternal(
                        pProcess,
                        poxidServer,
                        cOidsReturn,
                        aOidsReturn,
                        cOids,
                        aOids,
                        pOidsAllocated);
}



error_status_t
_ServerAllocateOXIDAndOIDs(
                          IN handle_t hClient,
                          IN PHPROCESS phProcess,
                          OUT OXID *poxidServer,
                          IN LONG fApartment,
                          IN ULONG cOids,
                          OUT OID aOids[],
                          OUT PULONG pOidsAllocated,
                          IN OXID_INFO *poxidInfo, // No bindings
                          IN DUALSTRINGARRAY *pdsaStringBindings,   // Expanded
                          IN DUALSTRINGARRAY *pdsaSecurityBindings, // Compressed
                          OUT DWORD64 *pdwBindingsID,
                          OUT DUALSTRINGARRAY **ppdsaOrBindings
                          )
/*++

Routine Description:

    Allocates an OXID and 0 or more OIDs from the OR.

Arguments:

    phProcess - The context handle of the process containing the OXID.

    poxidServer - The OXID to register.  May only register once.

    cOids - Count of apOids

    apOid - The OIDs to register within the OXID.

    pcOidsAllocated - The number of OIDs actually allocated. Usually the
        same as cOids unless a resource failure occures.  Maybe 0.

    poxidInfo - The OXID_INFO structure for the OXID without bindings.

    pdsaStringBindings - Expanded string binding of the server.

    pdsaSecurityBindings - The compressed security bindings of the server.

    pOidsAllocated - The number of OIDs actually allocated. >= 0 and <= cOids.

    pdwBindingsID -- The id of the bindings returned in ppdsaOrBindings

    ppdsaOrBindings -- The current resolver bindings.  Normally this is not
	    ever allocated, unless dynamic address tracking is enabled.

Return Value:

    OR_OK - success.  Returned even if some OID allocations fail. See the
                      pOidsAllocated parameter.

    OR_NOMEM - Allocation of OXID failed.

    OR_ACCESS_DENIDED - Raised if non-local client

    OR_BADPARAM - if string arrays are incorrect.

--*/
{
    ORSTATUS status = OR_OK;
    CServerOxid *pNewOxid;
    CProcess *pProcess = NULL;

    pProcess = CheckLocalSecurity(hClient, phProcess);
    if (!pProcess)
    	return OR_NOACCESS;

    // Parameter validation
    if (!poxidServer ||
        !(cOids > 0 ? (aOids != NULL) : TRUE) ||
        !pOidsAllocated || !poxidInfo ||
        !pdsaStringBindings || !pdsaSecurityBindings ||
        !pdwBindingsID || !ppdsaOrBindings)
    {
        return OR_BADPARAM;
    }

    gpServerLock->LockExclusive();

    // Save the string bindings back to the process

    if (!dsaValid(pdsaStringBindings) )
    {
        status = OR_BADPARAM;
    }

    if (!dsaValid(pdsaSecurityBindings))
    {
        status = OR_BADPARAM;
    }

    if (status == OR_OK)
    {
        status = pProcess->ProcessBindings(pdsaStringBindings,
                                           pdsaSecurityBindings);
    }
	
    *pdwBindingsID = 0;
    *ppdsaOrBindings = NULL;

    VALIDATE((status, OR_NOMEM, OR_BADPARAM, 0));

    if (status != OR_OK)
    {
        gpServerLock->UnlockExclusive();
        return(status);
    }

    ID id;
    if (AllocateId(&id))
    {
        pNewOxid = new CServerOxid(pProcess,
                                   fApartment,
                                   poxidInfo,
                                   id
                                  );
        if (0 == pNewOxid)
        {
            gpServerLock->UnlockExclusive();
            return(OR_NOMEM);
        }
    }
    else
    {
        // Failed to allocate new id
        gpServerLock->UnlockExclusive();
        return(OR_NOMEM);
    }

    // Add to process and lookup table.

    status = pProcess->AddOxid(pNewOxid);

    VALIDATE((status, OR_NOMEM, 0));

    pNewOxid->Release(); // process has a reference now or failed

    gpServerLock->UnlockExclusive();

    if (status == OR_OK)
    {
        *poxidServer = pNewOxid->Id();
        
        status = ServerAllocateOIDsInternal(
                        pProcess,
                        poxidServer,
                        0,
                        NULL,
                        cOids,
                        aOids,
                        pOidsAllocated);    
    }
	
    if (status == OR_OK && gbDynamicIPChangesEnabled)
    {
        if (ppdsaOrBindings && pProcess->NeedsORBindings())
        {
            // If doing dynamic IP changes, give process the current
            // OR bindings
            status = CopyMyOrBindings(ppdsaOrBindings, pdwBindingsID);
            if (status == OR_OK)
            {
                pProcess->BindingsUpdated();
            }
        }
    }

    return(status);
}



error_status_t
_ServerFreeOXIDAndOIDs(
                      IN handle_t hClient,
                      IN PHPROCESS phProcess,
                      IN OXID oxidServer,
                      IN ULONG cOids,
                      IN OID aOids[])

{
    CServerOxid *pOxid;
    CServerOid *pOid;
    CProcess *pProcess = NULL;
    ORSTATUS status;
    UINT i;

    pProcess = CheckLocalSecurity(hClient, phProcess);
    if (!pProcess)
    	return OR_NOACCESS;

    // Parameter validation
    if (!(cOids > 0 ? (aOids != NULL) : TRUE))
        return OR_BADPARAM;

    gpServerLock->LockExclusive();

    CIdKey oxidkey(oxidServer);

    pOxid = (CServerOxid *)gpServerOxidTable->Lookup(oxidkey);

    if (0 != pOxid)
    {
        if (pProcess->RemoveOxid(pOxid) == TRUE)
        {
            // Found the OXID and this caller owns it.
            status = OR_OK;
        }
        else
        {
            // Found but not owned by this caller.
            status = OR_NOACCESS;
        }
    }
    else
    {
        // Oxid not found.
        status = OR_BADOXID;
    }

    // Note pOxid maybe invalid once the last OID is removed.

    if (status == OR_OK)
    {
        for (i = 0; i < cOids; i++)
        {
            CIdKey key(aOids[i]); // PERF REVIEW

            pOid = (CServerOid *)gpServerOidTable->Lookup(key);

            if (   (0 != pOid)
                   && (pOid->IsRunningDown() == FALSE)
                   && (pOid->GetOxid() == pOxid) )
            {
                if (pOid->References() == 0)
                {
                    // Unreferenced by any sets; run it down now..
                    pOid->Remove();
                    pOid->SetRundown(TRUE);
                    delete pOid;
                }
                // else - marking it as Free() not need as Oxid is
                //        now marked as not running.
            }
            else
            {
                ASSERT(pOid == 0 || pOxid == pOid->GetOxid());
            }
        }
    }

    gpServerLock->UnlockExclusive();

    return(status);
}


//
//  Manager (server-side) calls to the remote OR interface. objex.idl
//
error_status_t
_ResolveOxid(
            IN  handle_t          hRpc,
            IN  OXID             *poxid,
            IN  USHORT            cRequestedProtseqs,
            IN  USHORT            aRequestedProtseqs[],
            OUT DUALSTRINGARRAY **ppdsaOxidBindings,
            OUT IPID             *pipidRemUnknown,
            OUT DWORD            *pAuthnHint
            )
{
    COMVERSION  ComVersion;
	
    // just forward to the new manager routine (parameter 
    // validation done by callee)
    return _ResolveOxid2(hRpc,
                         poxid,
                         cRequestedProtseqs,
                         aRequestedProtseqs,
                         ppdsaOxidBindings,
                         pipidRemUnknown,
                         pAuthnHint,
                         &ComVersion);
}

//
//  Manager (server-side) calls to the remote OR interface. objex.idl
//

error_status_t
_ResolveOxid2(
             IN  handle_t          hRpc,
             IN  OXID             *poxid,
             IN  USHORT            cRequestedProtseqs,
             IN  USHORT            aRequestedProtseqs[],
             OUT DUALSTRINGARRAY **ppdsaOxidBindings,
             OUT IPID             *pipidRemUnknown,
             OUT DWORD            *pAuthnHint,
             OUT COMVERSION       *pComVersion
             )
{

    ORSTATUS     status;
    BOOL         fDidLazy;
    CServerOxid *pServerOxid;
    OXID_INFO    oxidInfo;

    // Parameter validation.   Note that it would be exceedingly odd for
    // a client to request zero protseqs, but we handle this anyway.
    if (!poxid || 
        !(cRequestedProtseqs > 0 ? (aRequestedProtseqs != NULL) : TRUE) || 
        !ppdsaOxidBindings || !pipidRemUnknown || 
        !pipidRemUnknown || !pAuthnHint || !pComVersion)
    {
        return OR_BADPARAM;
    }

    oxidInfo.psa = 0;

    // No security check required (possible?).  OXID info is not private.

#if DBG
    UINT         fLocal;
    status = I_RpcBindingIsClientLocal(hRpc, &fLocal);

    if (status != OR_OK)
    {
        fLocal = FALSE;
    }
    ASSERT(fLocal == FALSE);  // Shouldn't be called locally...
#endif

    fDidLazy = FALSE;

    // intersect allowed protseqs with those
    // requested by the client.
    //
    // NOTE: we are modifying memory passed in. This will not cause side
    // effects because this call is always in the context of an RPC, and
    // aRequestedProtseqs is an IN parameter and therefore will not change
    // in the calling process.

    gpClientLock->LockExclusive();
    USHORT cAllowedProtseqs = 0;
    for (USHORT iReqProtseq=0; iReqProtseq < cRequestedProtseqs; iReqProtseq++)
    {
        for (USHORT iAllowProtseq=0; iAllowProtseq < cMyProtseqs; iAllowProtseq++)
        {
            if (aRequestedProtseqs[iReqProtseq] == aMyProtseqs[iAllowProtseq])
            {
                // this protocol is in the allowed list, shift it up
                // if necessary.
                aRequestedProtseqs[cAllowedProtseqs] = aRequestedProtseqs[iReqProtseq];
                cAllowedProtseqs++;
                break;
            }
        }
    }

    cRequestedProtseqs = cAllowedProtseqs;
    gpClientLock->UnlockExclusive();


    gpServerLock->LockShared();

    for (;;)
    {
        CIdKey key(*poxid);

        pServerOxid = (CServerOxid *)gpServerOxidTable->Lookup(key);
        if (!pServerOxid)
        {
            status = OR_BADOXID;
            break;
        }

        status =  pServerOxid->GetRemoteInfo(&oxidInfo,
                                             cRequestedProtseqs,
                                             aRequestedProtseqs);
	
        // Work around: original intersection of clients requested protocols
        //              with this SCM's did'nt match. But we know that client
        //              does'nt send it's entire set, just one so break here
        //
        // Note: W2K sends all protocols on both activations and ResolveOxid
        // calls; NT4 only sends one protocol on activations, and all on
        // ResolveOxid calls.
        //
        if ((cRequestedProtseqs == 0) && (status == OR_I_NOPROTSEQ))
        {
            break;
        }

        if (   status == OR_I_NOPROTSEQ
               && FALSE == fDidLazy )
        {
            // Ask the server to start listening, but only try this once.

            fDidLazy = TRUE;

            status =
            pServerOxid->LazyUseProtseq(cRequestedProtseqs,
                                        aRequestedProtseqs
                                       );

            ASSERT(gpServerLock->HeldExclusive()); // Changed during UseProtseq!

            if (status == OR_OK)
            {
                continue;
            }
        }
        else if (status == OR_I_NOPROTSEQ)
        {
            // We didn't manage to use a matching protseq.
            // Since we can call on any protocol this is possible
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Failed to use a matching protseq: %p %p\n",
                       pServerOxid,
                       aRequestedProtseqs));

            status = OR_NOSERVER;
        }
        break;
    }

    gpServerLock->Unlock();

    if (status == OR_OK)
    {
        *pipidRemUnknown = oxidInfo.ipidRemUnknown;
        *ppdsaOxidBindings = oxidInfo.psa;
        *pAuthnHint = oxidInfo.dwAuthnHint;
        *pComVersion = oxidInfo.version;
    }
    else
    {
        // Work around: original intersection of clients requested protocols
        //              with this SCM's did'nt match. But we know that client
        //              does'nt send it's entire set, just one, so send back
        //              an empty set but o.k activation result for bindings
        //
        // Note: W2K sends all protocols on both activations and ResolveOxid
        // calls; NT4 only sends one protocol on activations, and all on
        // ResolveOxid calls.
        //
        if ((cRequestedProtseqs == 0) && (status == OR_I_NOPROTSEQ))
        {
            *pipidRemUnknown = oxidInfo.ipidRemUnknown;
            *ppdsaOxidBindings = NULL;
            *pAuthnHint = oxidInfo.dwAuthnHint;
            *pComVersion = oxidInfo.version;
            status = OR_OK;
        }
    }
    return(status);
}

error_status_t
_SimplePing(
           IN handle_t hRpc,
           IN SETID    *pSetId
           )
{
    ORSTATUS status;
    CServerSet *pServerSet;
    BOOL fShared = TRUE;

    // Parameter validation
    if (!pSetId)
        return OR_BADPARAM;

    if (*pSetId == 0)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Client %p simple pinged with a setid of 0\n",
                   hRpc,
                   pSetId));

        return(OR_BADSET);
    }

    gpServerLock->LockShared();

    pServerSet = (CServerSet *)gpServerSetTable->Lookup(*pSetId);

    if (pServerSet)
    {
        fShared = pServerSet->Ping(TRUE);
        // The lock maybe exclusive now.
        status = OR_OK;
    }
    else
    {
        status = OR_BADSET;
    }

    // See if another set in the table needs to rundown.
    // PERF REVIEW - how often should I do this?  0 mod 4?

    // Similar code in worker threads.

    ID setid  = gpServerSetTable->CheckForRundowns();

    if (setid)
    {
        if (fShared)
        {
            gpServerLock->ConvertToExclusive();
            fShared = FALSE;
        }

        gpServerSetTable->RundownSetIfNeeded(setid);
    }

    gpServerLock->Unlock();

    return(status);
}

error_status_t
ComplexPingInternal(
            IN  handle_t hRpc,
            IN  SETID   *pSetId,
            IN  USHORT   SequenceNum,
            IN  ULONG    cAddToSet,
            IN  ULONG    cDelFromSet,
            IN  OID      AddToSet[],
            IN  OID      DelFromSet[],
            OUT USHORT  *pPingBackoffFactor
            )
/*++

Routine Description:

    Processes a complex (delta to set) ping for a given set.  This call
    will create the set if necessary.  The call will only be processed
    if the caller is in fact the creator of the set.

    algorithm:

        if set is not allocated
            lookup security info if possible
            allocate set
        else
            lookup set


        if found or created a set
           do a standard ping, updating time stamp and sequence number.
        else return failure.

        if oids to add, add each one.
            ignore unknown OIDs
            if resource allocation fails, abort.

        if oids to delete, process each one.
            ignore unknown OIDs

        if resource failure in adds, return OR_BADOID
        else return success.

Arguments:

    hRpc - Handle (SCONN/SCALL) of client.  Used to check security. If it is
        NULL the call is local and is assumed to be secure.

        REVIEW:
        Since the OR _only_ uses NT system security providers it is assumed
        that impersonation will work.  Other security providers will not.

        We need a generic way to ask for a token and compare tokens in a
        security provider independent way.

    pSetId - The setid to ping.  If it is NULL a new set will be created,
        otherwise, it is assumed to be a set previously allocated by a
        call with a NULL setid to this server.

    SequenceNum - A sequence number shared between the client and server
        to make sure old and out-of-order pings are not processed in a
        non-healthy way.  Note that pings are usually datagram RPC calls
        which are marked as idempotent.

    cAddToSet
    cDelFromSet - The count of element in AddTo/DelFromSet parameter.

    AddToSet
    DelFromSet - OID mostly likly belonging to servers on this machine
        to Add/Remove from the set of OIDs in use by this client.

    pPingBackoffFactor - Maybe set by servers which want to reduce the
        ping load on the server.  Serves only as a HINT for the client.
        Clients do not to ping more offten then:
                (1<<*pPingBackoffFactor)*BasePingInterval seconds.
        Clients may choose to assume this parameter is always 0.

Return Value:

    OR_OK - completed normally

    OR_BADSET - non-zero and unknown setid.

    OR_NOMEM - unable to allocate a resource.  Note that
        on the first ping a set maybe allocated (setid is non-zero
        after call) but some OIDs failed to be allocated.

    OR_BADOID - everything went okay, but some OIDs added where
        not recognized.

--*/

{
    CServerSet    *pServerSet;
    BOOL           fProcessPing;
    BOOL           fBad = FALSE;
    PSID           psid = 0;
    ORSTATUS       status = OR_OK;

    // Parameter validation.
    if (!pSetId || 
        !(cAddToSet > 0 ? (AddToSet != NULL) : TRUE) ||
        !(cDelFromSet > 0 ? (DelFromSet != NULL) : TRUE) ||
        !pPingBackoffFactor)
    {
        return OR_BADPARAM;
    }

    gpServerLock->LockExclusive();

    // Lookup the set

    if (0 != *pSetId)
    {
        pServerSet = (CServerSet *)gpServerSetTable->Lookup(*pSetId);
        if (0 == pServerSet)
        {
            status = OR_BADSET;
        }

        if (status == OR_OK)
        {
            if (pServerSet->CheckSecurity(hRpc) != TRUE)
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Security check on set failed! (%d)\n",
                           GetLastError()));

                status = OR_NOACCESS;
            }
        }
    }
    else if (hRpc == 0)
    {
        // Local client
        psid = 0;
        pServerSet = gpServerSetTable->Allocate(SequenceNum,
                                                psid,
                                                hRpc == 0,
                                                *pSetId);

        if (0 == pServerSet)
            status = OR_NOMEM;
        else
            status = OR_OK;

    }
    else
    {
        HANDLE hT;
        BOOL f;
        // Unallocated set, lookup security info and allocate the set.

        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: New client started pinging: %p\n",
                   hRpc));

        status = RpcImpersonateClient(hRpc);

        if (status == RPC_S_OK)
        {
            f = OpenThreadToken(GetCurrentThread(),
                                TOKEN_IMPERSONATE | TOKEN_QUERY,
                                TRUE,
                                &hT);

            if (!f)
            {
                status = GetLastError();
            }
            else
            {
                status = RPC_S_OK;
            }

        }

        if (status != RPC_S_OK)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Unsecure client started pinging: %d %p\n",
                       status,
                       hRpc));

            status = OR_OK;
        }
        else
        {
            ULONG needed = DEBUG_MIN(1, 24);
            PTOKEN_USER ptu;

            do
            {
                ptu = (PTOKEN_USER)alloca(needed);
                ASSERT(ptu);

                f = GetTokenInformation(hT,
                                        TokenUser,
                                        (PBYTE)ptu,
                                        needed,
                                        &needed);

            } while ( f == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

            if (f)
            {
                ASSERT(needed > sizeof(SID));
                psid = new(needed - sizeof(SID)) SID;
                if (psid)
                {
                    f = CopySid(needed, psid, ptu->User.Sid);
                    ASSERT(f == TRUE);
                }
                else
                {
                    status = OR_NOMEM;
                }
            }
            else
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Error %d from GetTokenInformation\n",
                           GetLastError()));

                ASSERT(0);
                // Why did this happen. Either return failure to client or
                // continue and make the set unsecure.
                status = OR_NOMEM;
            }

            CloseHandle(hT);
        }

        // Allocate the set

        if (status == OR_OK)
        {
            ASSERT(gpPingSetQuotaManager);
            if (gpPingSetQuotaManager->IsUserQuotaExceeded(psid))
               status = OR_NORESOURCE;
            
            if (OR_OK == status) 
            {
               if (!gpPingSetQuotaManager->ManageQuotaForUser(psid, TRUE))
               {
                  status = OR_NOMEM;
               }
               else
               {
                  pServerSet = gpServerSetTable->Allocate(SequenceNum,
                                                          psid,
                                                          hRpc == 0,
                                                          *pSetId);
      
                  if (0 == pServerSet)
                  {
                      gpPingSetQuotaManager->ManageQuotaForUser(psid, FALSE);
                      status = OR_NOMEM;
                  }
               }
            }
        }
    }

    if (status != OR_OK)
    {
        VALIDATE((status, OR_NOMEM, OR_BADSET, OR_NOACCESS, OR_NORESOURCE, 0));
        gpServerLock->UnlockExclusive();

        if (psid)
            delete psid;

        return(status);
    }

    ASSERT(pServerSet);

    fProcessPing = pServerSet->CheckAndUpdateSequenceNumber(SequenceNum);

    if (fProcessPing)
    {
        // Do regular ping

        pServerSet->Ping(FALSE);

        *pPingBackoffFactor = 0;

        // Process Add's
        for (int i = cAddToSet; i ; i--)
        {
            status = pServerSet->AddObject(AddToSet[i - 1]);

            if (status == OR_BADOID)
            {
                fBad = TRUE;
            }
            else if ( status != OR_OK )
            {
                break;
            }
        }

        // Process Deletes - even some adds failed!

        for (i = cDelFromSet; i; i--)
        {
            // Removing can't fail, no way to cleanup.
            pServerSet->RemoveObject(DelFromSet[i - 1]);
        }
    }

    gpServerLock->UnlockExclusive();

    if (status == OR_OK && fBad)
    {
        return(OR_BADOID);
    }

    return(status);
}

error_status_t
_ComplexPing(
            IN  handle_t hRpc,
            IN  SETID   *pSetId,
            IN  USHORT   SequenceNum,
            IN  USHORT   cAddToSet,
            IN  USHORT   cDelFromSet,
            IN  OID      AddToSet[],
            IN  OID      DelFromSet[],
            OUT USHORT  *pPingBackoffFactor
            )
/*--
Routine Description:

      This is the exposed RPC entry point for this function.  We 
      simply call the internal function below.  See description 
      for ComplexPingInternal.   The reason for a separate function
      is because the RPC method is typed to to take USHORT's, but 
      internally it is more convienent to pass ULONG's.

Arguments:
    
      See argument list for ComplexPingInternal

--*/
{
    return ComplexPingInternal(hRpc,
                               pSetId,
                               SequenceNum,
                               cAddToSet,
                               cDelFromSet,
                               AddToSet,
                               DelFromSet,
                               pPingBackoffFactor);
}



error_status_t
_ServerAlive(
            RPC_ASYNC_STATE *pAsync,
            RPC_BINDING_HANDLE hServer
            )
/*++

Routine Description:

    Ping API for the client to validate a binding.  Used when the client
    is unsure of the correct binding for the server.  (Ie. If the server
    has multiple IP addresses).

Arguments:

    hServer - RPC call binding

Return Value:

    OR_OK

--*/
{
    error_status_t RetVal = OR_OK;
    RPC_STATUS rpcstatus;
    RegisterAuthInfoIfNecessary();
    rpcstatus = RpcAsyncCompleteCall(pAsync, &RetVal);
    return (rpcstatus == RPC_S_OK) ? RetVal : rpcstatus;
}



error_status_t
_ServerAlive2(
            RPC_ASYNC_STATE *pAsync,
            RPC_BINDING_HANDLE hServer,
            COMVERSION      *pComVersion,
            DUALSTRINGARRAY **ppdsaOrBindings,
            DWORD           *pReserved
            )
/*++

Routine Description:

    Ping API for the client to validate a binding.  Used when the client
    is unsure of the correct binding or authentication service for the server.
    (Ie. If the server has multiple IP addresses).

Arguments:

    hServer - RPC call binding

Return Value:

    OR_OK

--*/
{
    error_status_t RetVal     = OR_OK;
    RPC_STATUS rpcstatus = RPC_S_OK;

    // Parameter validation
    if (!pComVersion || !ppdsaOrBindings || !pReserved)
        return OR_BADPARAM;

    RegisterAuthInfoIfNecessary();
    pComVersion->MajorVersion = COM_MAJOR_VERSION;
    pComVersion->MinorVersion = COM_MINOR_VERSION;
    *pReserved                 = 0;

    RetVal = CopyMyOrBindings(ppdsaOrBindings, NULL);
    if (RetVal == OR_OK)
    {
        rpcstatus = RpcAsyncCompleteCall(pAsync, &RetVal);
    }
    
    return (rpcstatus == RPC_S_OK) ? RetVal : rpcstatus;
}



error_status_t
_Disconnect(
                handle_t        hClient,
                PHPROCESS      *pphProcess
            )
/*++

Routine Description:

    Ole32 disconnect api.  Used by ole32 to tell us they are being
    completely uninitialized in the calling process.   This lets us
    cleanup the context handle in an orderly fashion w/o waiting 
    around for a context rundown (which would happen, eventually, but 
    might be much later).

Arguments:

    hClient    -- [in] RPC call binding handle
    pphProcess -- [in,out] context handle.

Return Value:

    RPC_S_OK -- context handle cleaned up
    other    -- error occurred

--*/
{
    // Ensure this is a local client calling
    CProcess* pProcess = CheckLocalSecurity(hClient, *pphProcess);
    if (!pProcess)
        return OR_NOACCESS;

    //
    // Call the rundown routine (Disconnect is effectively an 
    // orderly context rundown).
    //
    PHPROCESS_rundown(*pphProcess);

    // Note: don't touch pProcess after this point, it may have 
    // already been freed.
    pProcess = NULL;

    //
    // Zero out the context handle so that RPC knows that
    // it has been freed.
    //
    *pphProcess = NULL;

    return RPC_S_OK;    
};



void __RPC_USER PHPROCESS_rundown(LPVOID ProcessKey)
{
    CProcess *pProcess = ReferenceProcess(ProcessKey, FALSE);

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_INFO_LEVEL,
               "OR: Client died\n"));

    ASSERT(pProcess);

    pProcess->NotifyRPCRundown();
		
    //
    // This revokes OLE class registrations which were not revoked by this
    // dead process.  This must be done here rather then CProcess::Rundown
    // because these things have references to the CProcess object.
    //
    pProcess->RevokeClassRegs();

    pProcess->Cleanup();

    ReleaseProcess(pProcess);

    return;
}


void CRpcSecurityCallback::SetMarshaledTargetInfo(unsigned long ulMarshaledTargetInfoLength, unsigned char *pMarshaledTargetInfo)
{
   // I don't expect any existing creds
   ASSERT( (_ulMarshaledTargetInfoLength == 0) && (_pMarshaledTargetInfo == NULL));
   //clear any existing creds (just in case)
   if (_ulMarshaledTargetInfoLength)
   {
           SECURITY_STATUS status = FreeContextBuffer(_pMarshaledTargetInfo);
#if DBG == 1
           if (SEC_E_OK != status) 
                   KdPrintEx((DPFLTR_DCOMSS_ID, DPFLTR_INFO_LEVEL,"SCM: FreeContextBuffer Failed %0x%x\n"));
#endif
                   
   }      
   _ulMarshaledTargetInfoLength = ulMarshaledTargetInfoLength;
   _pMarshaledTargetInfo = pMarshaledTargetInfo;
   ASSERT( 
             ((_ulMarshaledTargetInfoLength == 0) && (_pMarshaledTargetInfo == NULL)) ||
             ((_ulMarshaledTargetInfoLength != 0) && (_pMarshaledTargetInfo != NULL))        
         );
}

ORSTATUS CRpcSecurityCallback::GetMarshaledTargetInfo(unsigned long *pulMarshaledTargetInfoLength, unsigned char **pucMarshaledTargetInfo)
{
   ASSERT( 
             ((_ulMarshaledTargetInfoLength == 0) && (_pMarshaledTargetInfo == NULL)) ||
             ((_ulMarshaledTargetInfoLength != 0) && (_pMarshaledTargetInfo != NULL))        
         );
   ORSTATUS status=OR_OK;
   *pulMarshaledTargetInfoLength = 0;
   *pucMarshaledTargetInfo = NULL;
   if (_ulMarshaledTargetInfoLength) 
   {
      *pucMarshaledTargetInfo = (unsigned char *) MIDL_user_allocate(_ulMarshaledTargetInfoLength * sizeof(char));
      if (*pucMarshaledTargetInfo) 
      {
         memcpy(*pucMarshaledTargetInfo, _pMarshaledTargetInfo, _ulMarshaledTargetInfoLength);
         *pulMarshaledTargetInfoLength = _ulMarshaledTargetInfoLength;
         SECURITY_STATUS status = FreeContextBuffer(_pMarshaledTargetInfo);
#if DBG == 1
         if (SEC_E_OK != status) 
                 KdPrintEx((DPFLTR_DCOMSS_ID, DPFLTR_INFO_LEVEL,"SCM: FreeContextBuffer Failed %0x%x\n"));
#endif
         _pMarshaledTargetInfo = NULL;
         _ulMarshaledTargetInfoLength = 0;
      
      }
      else
         status = ERROR_NOT_ENOUGH_MEMORY;
   }
   return status;
   
}
CRpcSecurityCallback::~CRpcSecurityCallback()  
{
   if (_ulMarshaledTargetInfoLength)
   {
           SECURITY_STATUS status = FreeContextBuffer(_pMarshaledTargetInfo);
#if DBG == 1
           if (SEC_E_OK != status) 
                   KdPrintEx((DPFLTR_DCOMSS_ID, DPFLTR_INFO_LEVEL,"SCM: FreeContextBuffer Failed %0x%x\n"));
#endif
                   
   }      
   _ulMarshaledTargetInfoLength = 0;
   _pMarshaledTargetInfo = NULL;
   
}


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::RegisterForRpcAuthSvcCallBack
//
//  Synopsis:   Register the security callback with RPC.  A return value of
//              TRUE means the calling thread may make a call on the supplied
//              binding handle, then call the the RetrieveAuthSvc method
//              for the negotiated authentication svc used on the rpc call.
//
//  Parameters: hRpc -- the binding handle for which the calling thread wants
//                      the negotiated auth. svc.
//
//  Algorithm:  Register the security callback with RPC.    Create a new list
//              element to represent this particular callback, and add to to
//              the list of callbacks.
//
//  Notes:      There is a limitation:  a thread can only be registered for one
//              callback at a time.   This should be ok for expected usage.
//
//----------------------------------------------------------------------------
BOOL CRpcSecurityCallbackManager::RegisterForRpcAuthSvcCallBack(handle_t hRpc)
{
  RPC_STATUS status;
  CRpcSecurityCallback* pNewCallback;

  ASSERT(hRpc != 0 && "Callbacks are meant to be used only for remote calls!");

  // Create a new list element to represent this callback
  pNewCallback = new CRpcSecurityCallback(hRpc, GetCurrentThreadId());
  if (!pNewCallback)
    return FALSE; // out-of-memory, not much we can do

  // Try to register the callback
  status = RpcBindingSetOption(hRpc,
                               RPC_C_OPT_SECURITY_CALLBACK,
                               (ULONG_PTR)CRpcSecurityCallbackManager::RpcSecurityCallbackFunction);
  ASSERT(status == RPC_S_OK); // this should never fail AFAIK
  if (status != RPC_S_OK)
  {
    // again, not much we can do
    delete pNewCallback;
    return FALSE;
  }

  // Okay now we got all we need; add it to the list
  _plistlock->LockExclusive();
  _CallbackList.Insert(pNewCallback);
  _plistlock->UnlockExclusive();

  return TRUE;
};


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::GetSecurityContextDetailsAndTurnOffCallback
//
//  Synopsis:   Tries to retrieve the negotiated authentication service for the
//              call just completed on the supplied binding handle.   Also
//              turns off callbacks on the binding handle.
//
//  Parameters: pusAuthSvc -- if the rpc call was made, this must be a valid ptr;
//                  if that is the case, then upon a return value of TRUE, it
//                  will contain the auth. svc used for the call;  a value of NULL
//                  passed here means the caller doesn't care about the result, he
//                  just wants things cleaned up (typically this means either the
//                  call failed or was never made).
//
//  Returns:    TRUE -- if everything worked
//              FALSE -- something is wrong or you passed a NULL pusAuthSvc
//
//  Algorithm:  Use the caller's thread id to search for the callback result
//
//----------------------------------------------------------------------------
BOOL CRpcSecurityCallbackManager::GetSecurityContextDetailsAndTurnOffCallback(handle_t hRpc, USHORT* pusAuthSvc, 
                                    unsigned long *pulMarshaledTargetInfoLength, unsigned char **pucMarshaledTargetInfo)
{
  RPC_STATUS status;
  CRpcSecurityCallback* pCallback;
  DWORD dwCurrentThread = GetCurrentThreadId();
  USHORT usAuthSvc;
  BOOL bRet = FALSE;
  _plistlock->LockExclusive();

  // No matter what happens after this, we should turn off callbacks for the handle
  TurnOffCallback(hRpc);

  // Look for the callback result for the calling thread
  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (dwCurrentThread == pCallback->GetRegisteredThreadId())
    {
      // found it
      break;
    }
  };

  // Given the normal usage of this stuff, we should always find a result
  ASSERT(pCallback && "Didn't find rpc sec. callback result; this is unexpected");
  if (!pCallback)
  {
    _plistlock->UnlockExclusive();
    return FALSE;
  };

  usAuthSvc = pCallback->GetAuthSvcResult();
  if (pusAuthSvc)
  {
    ASSERT(pCallback->WasAuthSvcSet() && "Caller is retrieving auth svc before it was set");
    *pusAuthSvc = usAuthSvc;
  }
  status = pCallback->GetMarshaledTargetInfo(pulMarshaledTargetInfoLength, pucMarshaledTargetInfo);
  
  // The callback's work is done, so remove it from the list and delete it
  _CallbackList.Remove(pCallback);
  delete pCallback;

  // Check list to see if other threads also had registered callbacks on the
  // same handle.  We will record the result for them in case we turned off the
  // callback above before they got recorded.  In fact, any time two or more threads
  // register for a callback on the same handle we will hit this scenario.
  //
  // I don't think this is 100% foolproof, but it constitutes a best-faith effort
  //
  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (hRpc == pCallback->RegisteredHandle())
    {
      // found a match
      ASSERT(dwCurrentThread != pCallback->GetRegisteredThreadId());
      pCallback->SetAuthSvc(usAuthSvc);
    }
  };

  _plistlock->UnlockExclusive();
  bRet = ((status == OR_OK) && (pusAuthSvc ? (*pusAuthSvc != ERROR_AUTHNSVC_VALUE) : FALSE));
  if (!bRet) 
  {
     if(*pucMarshaledTargetInfo)
     {
        MIDL_user_free(*pucMarshaledTargetInfo);
        *pucMarshaledTargetInfo = NULL;
        *pulMarshaledTargetInfoLength = 0;
     }
  }
  return bRet;
};

//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::TurnOffCallback
//
//  Synopsis:   Function to turn off the callback on an rpc binding handle
//
//  Parameters: hRpc -- the binding handle to turn off callbacks on
//
BOOL CRpcSecurityCallbackManager::TurnOffCallback(handle_t hRpc)
{
  RPC_STATUS status;
  status = RpcBindingSetOption(hRpc,
                               RPC_C_OPT_SECURITY_CALLBACK,
                               (ULONG_PTR) NULL );

  ASSERT(status == RPC_S_OK && "RpcBindingSetOption failed when turning off security callback");

  return TRUE;
};


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::StoreCallbackResult
//
//  Synopsis:   This is a helper function for the callback function; no one
//              else should use it obviously.
//
//  Parameters: usAuthSvc -- the negotiated authentication service for the rpc
//                call that the calling thread presumably just completed.
//
void CRpcSecurityCallbackManager::StoreCallbackResult(USHORT usAuthSvc)
{
  CRpcSecurityCallback* pCallback;
  DWORD dwCurrentThread = GetCurrentThreadId();

  // Only need a shared lock for this
   _plistlock->LockShared();

  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (dwCurrentThread == pCallback->GetRegisteredThreadId())
    {
      // found it
      break;
    }
  };

  ASSERT(pCallback);  // we should always find it

  pCallback->SetAuthSvc(usAuthSvc);
   _plistlock->UnlockShared();

  return;
};

void CRpcSecurityCallbackManager::StoreMarshaledTargetInfo(unsigned long ulMarshaledTargetInfoLength, unsigned char *pMarshaledTargetInfo)
{
  CRpcSecurityCallback* pCallback;
  DWORD dwCurrentThread = GetCurrentThreadId();

  // Only need a shared lock for this
   _plistlock->LockShared();

  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (dwCurrentThread == pCallback->GetRegisteredThreadId())
    {
      // found it
      break;
    }
  };

  ASSERT(pCallback);  // we should always find it

  pCallback->SetMarshaledTargetInfo(ulMarshaledTargetInfoLength, pMarshaledTargetInfo);
   _plistlock->UnlockShared();

  return;
};


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::RpcSecurityCallbackFunction
//
//  Synopsis:   This is a callback function; we use this by setting it on a
//              binding handle (using the RPC_C_OPT_SECURITY_CALLBACK option)
//              so that RPC will call us back;  this gives us a chance to
//              determine what authentication svc was negotiated when using
//              snego. Also used to obtain the credman creds used in the call
//
//  Parameters: pvContext -- an opaque parameter
//
//  Algorithm:  call I_RpcBindingInqWireIdForSnego, I_RpcBindingInqMarshalledTargetInfo 
//              passing it the opaque pvContext parameter.
//
//  Notes:      it would be nice if we could get some info in this callback
//              as to *which* handle the callback is for, but unfortunately
//              kamenm was explicit on this point: pvContext is to remain
//              opaque.  :)
//
//----------------------------------------------------------------------------
void RPC_ENTRY CRpcSecurityCallbackManager::RpcSecurityCallbackFunction(void* pvContext)
{
  RPC_STATUS      status;
  UCHAR           ucWireId;
  unsigned char   *pMarshaledTargetInfo = NULL;
  unsigned long   ulMarshaledTargetInfoLength = 0;
  
  // Call back to get the authsvc:
  status = I_RpcBindingInqWireIdForSnego((RPC_BINDING_HANDLE)pvContext, &ucWireId);

  ASSERT(status != RPC_S_SEC_PKG_ERROR);   // RPC should not have called us back
                                           // in the first place, so assert on this

  ASSERT(status != RPC_S_INVALID_BINDING); // RPC folks say this can be returned for the
                                           // following reasons:  1) unauthenticated call;
                                           // 2) invalid context; 3) snego was not used in
                                           // the first place.  None of these should apply
                                           // to us, so assert
  if (status == RPC_S_OK)
  {
    ASSERT( (ucWireId != RPC_C_AUTHN_GSS_NEGOTIATE) && "We're supposed to get back the real deal not snego");

    gpCRpcSecurityCallbackMgr->StoreCallbackResult(ucWireId);
  }
  else
  {
    // something went wrong (most likely in the lower level security code).
    gpCRpcSecurityCallbackMgr->StoreCallbackResult(ERROR_AUTHNSVC_VALUE);
  }
  status = I_RpcBindingInqMarshalledTargetInfo((RPC_BINDING_HANDLE)pvContext, &ulMarshaledTargetInfoLength, &pMarshaledTargetInfo);
  
  ASSERT(status != RPC_S_SEC_PKG_ERROR);   
  ASSERT(status != RPC_S_INVALID_BINDING); 
  
  if (status == RPC_S_OK)
  {
     gpCRpcSecurityCallbackMgr->StoreMarshaledTargetInfo(ulMarshaledTargetInfoLength, pMarshaledTargetInfo);
  }
  return;
};

DWORD CPingSetQuotaManager::_dwPerUserPingSetQuota = 1000;

//+---------------------------------------------------------------------------
//
//  Function:   CPingSetQuotaManager::ManageQuotaForUser
//
//  Synopsis:   This function manages the pingset quota for the user indicated by 
//              pSID. fAlloc = TRUE means alloc pingset quota, else deduct quota
//
BOOL CPingSetQuotaManager::ManageQuotaForUser(PSID pSid, BOOL fAlloc)
{
   CUserPingSetCount *pNode = NULL;
   RPC_STATUS status = OR_NOMEM;
   
   // first see if have the user in the list
   _plistlock->LockExclusive();
  
  for (pNode = (CUserPingSetCount*)_UserPingSetCountList.First();
       pNode;
       pNode = (CUserPingSetCount*)pNode->Next() )
  {
    if (pNode->IsEqual(pSid))
    {
      // found it
      break;
    }
  };
  if (pNode) 
  {
     // Have one, munge count
     if (fAlloc) 
     {
        pNode->Increment();
     }
     else
     {
        pNode->Decrement();
        // last ping set for this user, delete node
        if (pNode->GetCount() == 0)
        {
           _UserPingSetCountList.Remove(pNode);
           delete pNode;
        }
     }
     status = OR_OK;
  }
  else
  {
     // Don't have one, add. 
     ASSERT( fAlloc == TRUE );
     pNode = new CUserPingSetCount(status, pSid);
     if (pNode && (status == OR_OK) ) 
     {
        // start with 1
        pNode->Increment();
        _UserPingSetCountList.Insert(pNode);
     }
  }
  _plistlock->UnlockExclusive();
  return (OR_OK == status);
}

//+---------------------------------------------------------------------------
//
//  Function:   CPingSetQuotaManager::IsUserQuotaExceeded
//
//  Synopsis:   This function determines if the quota is above limit for a given user
//              pSID. returns TRUE if the limit is reached, FALSE otherwise
//
BOOL CPingSetQuotaManager::IsUserQuotaExceeded(PSID pSid)
{
   CUserPingSetCount *pNode = NULL;
   // first see if have the user in the list
   _plistlock->LockShared();
  
  for (pNode = (CUserPingSetCount*)_UserPingSetCountList.First();
       pNode;
       pNode = (CUserPingSetCount*)pNode->Next() )
  {
    if (pNode->IsEqual(pSid))
    {
      // found it
      break;
    }
  };
  if (pNode)
  {
     DWORD dw = pNode->GetCount();
     if (dw >= _dwPerUserPingSetQuota ) 
     {
        _plistlock->UnlockShared();
        return TRUE;
     }
  }
  _plistlock->UnlockShared();
  return FALSE;
}

void CPingSetQuotaManager::SetPerUserPingSetQuota(DWORD dwQuota)
{
   _dwPerUserPingSetQuota = dwQuota;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\misc.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Misc.cxx

Abstract:

    Initalization, Heap, debug, thread manager for OR

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-11-95    Bits 'n pieces

--*/

#include <or.hxx>
#include <mach.hxx>
#include <excladdr.hxx>
#include <addrrefresh.hxx>

extern "C"
{
#define SECURITY_WIN32 // Used by security.h
#include <security.h>
}

BOOL fListened            = FALSE;
BOOL gfRegisteredAuthInfo = FALSE;

extern BOOL  gbDynamicIPChangesEnabled;
extern DWORD gdwTimeoutPeriodForStaleMids;

const UINT IP_MAXIMUM_RAW_NAME    = 16;   // xxx.xxx.xxx.xxx
const UINT IP_MAXIMUM_PRETTY_NAME = 256;  // DNS limit

// Contains compressed remote protseqs and network addresses 
// for this process, minus any addresses in the current
// exclusion list.  This is a refcounted object
CDualStringArray* gpdsaMyBindings = 0;

// Contains all compressed remote protseqs and network addresses 
// for this process.  Not refcounted.  We maintain this one
// to help when building a new gpdsaMyBindings above.
DUALSTRINGARRAY* gpdsaFullBindings = 0;

//  Contains initial DNS name for TCP
WCHAR  gwszInitialDNSName[IP_MAXIMUM_PRETTY_NAME];

// Authentication services successfully registered.
DWORD      s_cRpcssSvc      = 0;
SECPKG    *s_aRpcssSvc      = NULL;

// Unique ID used to track which global resolver bindings
// are currently in use.  Note that this starts at one, and
// everybody else starts theirs at zero.  Therefore any
// updates that originate from PushCurrentBindings should
// take precedence.  This should be looked at\modified only
// when gpClientLock is taken, in sync with modifying
// gpdsaMyBindings.  In addition, this should be incremented
// whenever gpdsaMyBindings is updated with new bindings.
DWORD64 g_dwResolverBindingsID = 1;

// Definitions used for asynchronous mid releases
const DWORD ASYNCMIDRELEASEARGS_SIG = 0xFEDCBA02;

typedef struct _ASYNCMIDRELEASEARGS
{
    DWORD dwAMRASig; // see ASYNCMIDRELEASEARGS_SIG
    HANDLE hTimer;
    CMid* pMidToRelease;
} ASYNCMIDRELEASEARGS;

// Crypt context for generating random #'s
HCRYPTPROV ghCryptCtx = NULL;

ORSTATUS
StartListeningIfNecessary()
/*++

Routine Description:

    If the process has not successfully listened to remote
    protocols this routine will try do to so.

Note:

    Will not add ncacn_np to the list of supported Network OLE
    protocols because RpcBindingServerFromClient() doesn't
    work on named pipes and is required to unmarshal an in
    interface pointer.

Arguments:

    n/a

Return Value:

    OR_OK - Success.

    OR_NOMEM - Resource problems.

--*/
{
    RPC_STATUS status;
    PWSTR pwstr = gpwstrProtseqs;
    USHORT id;
    CIPAddrs* pIPAddrs = NULL;
    BOOL bPushNewBindings = FALSE;

    if (fListened == TRUE)
    {
        return(OR_OK);
    }

    gpClientLock->LockExclusive();

    if (fListened == TRUE)
    {
        gpClientLock->UnlockExclusive();
        return(OR_OK);
    }

    OrStringCopy(gwszInitialDNSName, L"");

    if (pwstr)
    {
        while (*pwstr)
        {

            // skip leading white space
            while ((*pwstr == L' ') || (*pwstr == L'\t'))
            {
                pwstr++;
            }

            if (*pwstr)
            {
                id = GetProtseqId(pwstr);

                // ronans - DCOMHTTP
                // we want to add http to the list of bindings even if listening does not
                // succeed as this machine could still be a client of http without being a server
                if (0 != id)
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "OR: Trying to listen to [%d]\n",
                               id));

                    if (id == ID_DCOMHTTP )
                        g_fClientHttp = TRUE;

                    status = UseProtseqIfNecessary(id);
                    if (status == RPC_S_OK)
                    {
                        if (id == ID_TCP)
                        {
                            gAddrRefreshMgr.SetListenedOnTCP();
                            gAddrRefreshMgr.RegisterForAddressChanges();

                            // There may have been processes which connected before
                            // we were able to listen on tcp.  To make sure they 
                            // have the correct bindings, we must refresh them now.
                            bPushNewBindings = TRUE;
                        }

                        // if listening succeeded - no need to special case http as its in the normal
                        // list of protocols
                        if (id == ID_DCOMHTTP )
                            g_fClientHttp = FALSE;

                        fListened = TRUE;
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Listen succeeded on [%d]\n",
                                   id));
                    }
                    else
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Listen failed on [%d]\n",
                                   id));
                }
            }

            pwstr = OrStringSearch(pwstr, 0) + 1;
        }
    }

    if (   FALSE == fListened
           && 0 != gLocalMid)
    {
        // Didn't manage to listen to anything new, no need to
        // recompute all the global arrays.

        gpClientLock->UnlockExclusive();
        return(OR_OK);
    }

    // ??? limit to only those protseqs listed in the registry,
    // if the another service used more protseqs they would show up here.

    RPC_BINDING_VECTOR *pbv;
    PWSTR pwstrT;
    DUALSTRINGARRAY *pdsaT;
    PWSTR *aAddresses;
    USHORT *aProtseqs;
    unsigned short psaLen;
    DWORD i;
    DWORD iProtseq;

    status = RpcServerInqBindings(&pbv);

    if (RPC_S_OK == status)
    {
        aAddresses = new PWSTR[pbv->Count];
        aProtseqs = new USHORT[pbv->Count];

        if (   !aAddresses
               || !aProtseqs)
        {
            RpcBindingVectorFree(&pbv);
            delete aAddresses; // 0 or allocated.
            delete aProtseqs;  // 0 or allocated.
            status = OR_NOMEM;
        }
    }
    else
        status = OR_NOMEM;

    if (status != OR_OK)
    {
        gpClientLock->UnlockExclusive();
        return(status);
    }

    // Build array of protseqs id's and addresses we're listening to.
    pwstr = gpwstrProtseqs;
    if (pwstr)
    {
        psaLen = 0;
        iProtseq = 0;
        // start with the list of allowed protocols
        // listed in the registry.  For each protocol, in order,
        // check to see if there is an endpoint registered for it.

        // NOTE: Do not change the order of these loops
        // It is pertinent to correctly order the final
        // string.
        while (*pwstr)
        {
            id = GetProtseqId(pwstr);

            if (0 != id)
            {
                for (i = 0; i < pbv->Count; i++)
                {
                    PWSTR pwstrStringBinding;

                    status = RpcBindingToStringBinding(pbv->BindingH[i], &pwstrStringBinding);
                    if (status != RPC_S_OK)
                    {
                        break;
                    }
                    ASSERT(pwstrStringBinding);

                    status = RpcStringBindingParse(pwstrStringBinding,
                                                   0,
                                                   &pwstrT,
                                                   &aAddresses[iProtseq],
                                                   0,
                                                   0);

                    RPC_STATUS statusT = RpcStringFree(&pwstrStringBinding);
                    ASSERT(statusT == RPC_S_OK && pwstrStringBinding == 0);

                    if (status != RPC_S_OK)
                    {
                        break;
                    }

                    //
                    // if the protocol name matches we can use this one
                    //

                    if (lstrcmpW(pwstrT, pwstr) == 0)
                    {
                        aProtseqs[iProtseq] = id;

                        status = RpcStringFree(&pwstrT);
                        ASSERT(status == RPC_S_OK && pwstrT == 0);

                        // Disallow datagram protocols till they
                        // support SSL and snego.
                        if (!IsLocal(aProtseqs[iProtseq]) && aProtseqs[iProtseq] != ID_NP &&
                            aProtseqs[iProtseq] != ID_UDP && aProtseqs[iProtseq] != ID_IPX)
                        {
                            // Only hand out remote non-named pipes protseqs.

                            // Save the dns name RPC gave us;  we will need this in future
                            // if the IP's change and we need to rebuild the bindings
                            //
                            // In some cases RPC may give us 127.0.0.1.  Don't use that address.
                            //
                            if (aProtseqs[iProtseq] == ID_TCP &&
                                lstrcmpi(aAddresses[iProtseq], L"127.0.0.1"))
                            {
                                OrStringCopy(gwszInitialDNSName, aAddresses[iProtseq]);
                                psaLen += (unsigned short) (1 + OrStringLen(aAddresses[iProtseq]) + 1);
                            }
                            else if (aProtseqs[iProtseq] != ID_TCP) 
                            {
                                psaLen += (unsigned short) (1 + OrStringLen(aAddresses[iProtseq]) + 1);
                            }

                            // compute length w/IP address(es)
                            if (aProtseqs[iProtseq] == ID_TCP || aProtseqs[iProtseq] == ID_UDP || ID_DCOMHTTP == aProtseqs[iProtseq])
                            {
                                if (!pIPAddrs)
                                {
                                  pIPAddrs = gpMachineName->GetIPAddrs();
                                }
                                
                                if (pIPAddrs)
                                {
                                  NetworkAddressVector* pNetworkAddrVector = pIPAddrs->_pIPAddresses;

                                  ASSERT(pNetworkAddrVector);
                                    
                                  for (ULONG j=0; j<pNetworkAddrVector->Count; j++)
                                  {
                                    // do not include the loopback address in resolver bindings.
                                    if (lstrcmpW(L"127.0.0.1", pNetworkAddrVector->NetworkAddresses[j]) != 0)
                                    {
                                        psaLen += (unsigned short) (1 + OrStringLen(pNetworkAddrVector->NetworkAddresses[j]) + 1);
                                    }
                                  }
                                }
                            }
                        }

                        iProtseq++;
                        break;
                    }
                    else
                    {
                        status = RpcStringFree(&pwstrT);
                        ASSERT(status == RPC_S_OK && pwstrT == 0);
                        status = RpcStringFree(&aAddresses[iProtseq]);
                        ASSERT(status == RPC_S_OK && pwstrT == 0);
                    }

                }
                if (status != RPC_S_OK)
                {
                    break;
                }

            }
            pwstr = OrStringSearch(pwstr, 0) + 1;
        }
    }

    if (status != RPC_S_OK)
    {
        delete aAddresses;
        delete aProtseqs;
        RPC_STATUS status_tmp = RpcBindingVectorFree(&pbv);
        ASSERT(pbv == 0 && status_tmp == RPC_S_OK);
        gpClientLock->UnlockExclusive();
        if (pIPAddrs)
          pIPAddrs->DecRefCount();
        return(status);
    }


    // string bindings final null, authn and authz service list and
    // one final nulls

    if (psaLen == 0)
    {
        // No remote bindings, leave space for an extra NULL.
        psaLen = 1;
    }
    if (s_cRpcssSvc == 0)
    {
        // No authentication services, leave space for an extra NULL.
        psaLen += 1;
    }
    psaLen += (unsigned short)(1 + 3*s_cRpcssSvc + 1);

    pdsaT = new(psaLen * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (!pdsaT)
    {
        delete aAddresses;
        delete aProtseqs;
        status = RpcBindingVectorFree(&pbv);
        ASSERT(pbv == 0 && status == RPC_S_OK);
        gpClientLock->UnlockExclusive();
        if (pIPAddrs)
          pIPAddrs->DecRefCount();
        return OR_NOMEM;
    }

    pdsaT->wNumEntries = psaLen;
    if (s_cRpcssSvc == 0)
        pdsaT->wSecurityOffset = psaLen - 2;
    else
        pdsaT->wSecurityOffset = (unsigned short)(psaLen - 3*s_cRpcssSvc - 1);
    pwstrT = pdsaT->aStringArray;

    for (i = 0; i < iProtseq; i++)
    {
        // Disallow datagram protocols till they
        // support SSL and snego.
        if (!IsLocal(aProtseqs[i]) && aProtseqs[i] != ID_NP &&
            aProtseqs[i] != ID_UDP && aProtseqs[i] != ID_IPX)
        {
            // Make sure we don't put the localhost ip in here either.
            if ((aProtseqs[i] != ID_TCP) 
                 ||
            	((aProtseqs[i] == ID_TCP) && (lstrcmpi(aAddresses[i], L"127.0.0.1"))))
            {
                *pwstrT = aProtseqs[i];
                pwstrT++;            
                OrStringCopy(pwstrT, aAddresses[i]);
                pwstrT = OrStringSearch(pwstrT, 0) + 1;  // next
            }
        	
            // add the IP address(es)
            if (aProtseqs[i] == ID_TCP || aProtseqs[i] == ID_UDP || ID_DCOMHTTP == aProtseqs[i])
            {
                if (!pIPAddrs)
                {
                    pIPAddrs = gpMachineName->GetIPAddrs();
                }

                if (pIPAddrs)
                {
                    NetworkAddressVector* pNetworkAddrVector = pIPAddrs->_pIPAddresses;
                    ASSERT(pNetworkAddrVector);

                    for (ULONG j=0; j<pNetworkAddrVector->Count; j++)
                    {
                        // do not include the loopback address in resolver bindings.
                        if (lstrcmpW(L"127.0.0.1", pNetworkAddrVector->NetworkAddresses[j]) != 0)
                        {
                            *pwstrT = aProtseqs[i];
                            pwstrT++;
                            OrStringCopy(pwstrT, pNetworkAddrVector->NetworkAddresses[j]);
                            pwstrT = OrStringSearch(pwstrT, 0) + 1;  // next
                        }
                    }
                }
            }
        }

        status = RpcStringFree(&aAddresses[i]);
        ASSERT(status == RPC_S_OK);
    }

    if (pdsaT->wSecurityOffset == 2)
    {
        // No remote bindings, put in first null.
        pdsaT->aStringArray[0] = 0;
        pwstrT++;
    }

    // Zero final terminator
    *pwstrT = 0;
    pwstrT++;

    // Security authn services
    for (i = 0; i < s_cRpcssSvc; i++)
    {
        // Authn service, Authz service (-1 means none), NULL principal name
        *pwstrT = s_aRpcssSvc[i].wId;
        pwstrT++;
        *pwstrT = -1;
        pwstrT++;
        *pwstrT = 0;
        pwstrT++;
    }

    // If there are no authentication services, put in an extra NULL.
    if (s_cRpcssSvc == 0)
    {
        *pwstrT = 0;
        pwstrT++;
    }

    // Final NULL
    *pwstrT = 0;

    ASSERT(dsaValid(pdsaT));

    USHORT cRemoteProtseqs = 0;

    // Convert aProtseqs into remote only array of protseqs and count them.
    for (i = 0; i < iProtseq; i++)
    {
        // Disallow datagram protocols till they
        // support SSL and snego.
        if (!IsLocal(aProtseqs[i]) && aProtseqs[i] != ID_NP &&
            aProtseqs[i] != ID_UDP && aProtseqs[i] != ID_IPX)
        {
            aProtseqs[cRemoteProtseqs] = aProtseqs[i];
            cRemoteProtseqs++;
        }
    }

    delete aAddresses;
    status = RpcBindingVectorFree(&pbv);
    ASSERT(pbv == 0 && status == RPC_S_OK);

    if (pIPAddrs) pIPAddrs->DecRefCount();
    pIPAddrs = NULL;

    gAddrExclusionMgr.InitializeFromRegistry();

    // Obtain bindings filtered by exclusion list
    HRESULT hr;
    DUALSTRINGARRAY* pdsaFiltered;
    hr = gAddrExclusionMgr.BuildExclusionDSA(pdsaT, &pdsaFiltered);
    if (FAILED(hr))
    {
        delete pdsaT;
		gpClientLock->UnlockExclusive();
        return (OR_NOMEM);
    }

    // The mid object makes a copy of pdsaFiltered, it doesn't own it
    BOOL fMidInitOkay = FALSE;
    CMid *pMid = new(pdsaFiltered->wNumEntries * sizeof(WCHAR)) CMid(pdsaFiltered, TRUE, gLocalMid, &fMidInitOkay);
    if (pMid && fMidInitOkay)
    {
        CDualStringArray* pdsaWrapper = new CDualStringArray(pdsaFiltered);
        if (pdsaWrapper)
        {
            if (gpdsaFullBindings) delete gpdsaFullBindings;
            gpdsaFullBindings = pdsaT; // the full bindings
    
            ASSERT(gpClientLock->HeldExclusive());
            gpMidTable->Add(pMid);

            aMyProtseqs = aProtseqs;
            cMyProtseqs = cRemoteProtseqs;
			
            if (gpdsaMyBindings) gpdsaMyBindings->Release();
            gpdsaMyBindings = pdsaWrapper; // the filtered bindings
            gLocalMid = pMid->Id();

            // Increment id counter
            g_dwResolverBindingsID++;
	
            // Release the lock now, so we don't hold it across PushCurrentBindings.
            gpClientLock->UnlockExclusive();

            // Push new bindings if so called for.  Not fatal if this fails
            if (bPushNewBindings)
            {
                PushCurrentBindings();
            }

            return OR_OK;
        }
    }

    // Failed to get memory or mid object failed to init
    if (pMid) pMid->Release();
    delete pdsaT;
    MIDL_user_free(pdsaFiltered);
    delete aProtseqs;
    gpClientLock->UnlockExclusive();
    return(OR_NOMEM);
}

BOOL IsHttpClient()
/*++

Routine Description:

    Returns the global client http flag while holding a lock

Return Value:

    None

--*/
{
    BOOL retval;
    gpClientLock->LockExclusive();

    retval = g_fClientHttp;

    gpClientLock->UnlockExclusive();

    return retval;
}

void CALLBACK 
AsyncMidReleaseTimerCallback(void* pvParam, BOOLEAN TimerOrWaitFired)
/*++

Routine Description:

    Releases the mid object that was queued to a timer in 
    DoAsyncMidRelease below.

Return Value:

    None

--*/
{
    BOOL fResult;
    ASYNCMIDRELEASEARGS* pArgs;

    ASSERT(TimerOrWaitFired);

    pArgs = (ASYNCMIDRELEASEARGS*)pvParam;
    ASSERT(pArgs);
    ASSERT(pArgs->dwAMRASig == ASYNCMIDRELEASEARGS_SIG);
    ASSERT(pArgs->hTimer);
    ASSERT(pArgs->pMidToRelease);

    gpClientLock->LockExclusive();
    
    pArgs->pMidToRelease->Release();

    gpClientLock->UnlockExclusive();
        
    // Make a non-blocking call to delete the timer.
    fResult = DeleteTimerQueueTimer(NULL,
                                    pArgs->hTimer,
                                    NULL);
    ASSERT(fResult || (GetLastError() == ERROR_IO_PENDING));

    // Finally, delete the argument structure
    delete pArgs;

    return;
}

void 
DoAsyncMidRelease(CMid* pMid, DWORD dwReleaseInMSec)
/*++

Routine Description:

    Creates a timer callback that will call ->Release on the
    supplied mid object in the specified amount of time.  If
    the timer creation fails, does an immediate release.

Return Value:

    None

--*/
{
    BOOL bResult;
    HANDLE hNewTimer;
    ASYNCMIDRELEASEARGS* pArgs;

    ASSERT(pMid);
    ASSERT(gpClientLock->HeldExclusive());

    pArgs = new ASYNCMIDRELEASEARGS;
    if (!pArgs)
    {
        // Nothing we can do -- mid will be released synchronously
        // when this occurs.
        return;
    }
    
    // Initialize the struct
    pArgs->dwAMRASig = ASYNCMIDRELEASEARGS_SIG;
    pArgs->hTimer = NULL;
    pArgs->pMidToRelease = pMid;

    pMid->Reference();
	
    bResult = CreateTimerQueueTimer(&(pArgs->hTimer),
                                    NULL,
                                    AsyncMidReleaseTimerCallback,
                                    pArgs,
                                    dwReleaseInMSec,
                                    0,
                                    0);
    if (!bResult)
    {
        // Timer failed; release struct and mid object immediately to 
        // avoid leaking them.  Like above, mid is released sync.
        pMid->Release();
        delete pArgs;
    }
    return;
}

RPC_STATUS
ComputeNewResolverBindings(void)
/*++

Routine Description:

    Creates the local OR bindings using the current IP addresses, and
    places the results in gpdsaFullBindings.  gpdsaFullBindings is then
    passed to the address exclusion mgr object, who creates a "filtered"
    set of bindings, which omits any currently excluded addresses; these
    bindings are saved in gpdsaMyBindings.

    Caller must be holding gpClientLock.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    BOOL  fDoneTCP = FALSE;
    BOOL  fDoneUDP = FALSE;
    DWORD i;
    CIPAddrs* pIPAddrs;
    DWORD dwNumAddrs;
	
    ASSERT(gpdsaMyBindings);
    ASSERT(gpClientLock->HeldExclusive());

    pIPAddrs = gpMachineName->GetIPAddrs();
    dwNumAddrs = pIPAddrs ? pIPAddrs->_pIPAddresses->Count : 0;

    // compute size of new dsa (for each IP address, leave space
    // for two copies (one for TCP/IP and one for UDP).
    DWORD psaLen = pIPAddrs ? (pIPAddrs->_pIPAddresses->StringBufferSpace * 2) : 0;
    psaLen += sizeof(DUALSTRINGARRAY) + (gpdsaMyBindings->DSA()->wNumEntries * sizeof(USHORT));
    DWORD dwDNSLen = (DWORD) OrStringLen(gwszInitialDNSName);
    if (dwDNSLen > 0)
    {
        psaLen += dwDNSLen + 2;
    }

    // Allocate space for the new bindings
    DUALSTRINGARRAY *pdsaT = new(psaLen) DUALSTRINGARRAY;
    if (pdsaT == NULL)
    {
        if (pIPAddrs) pIPAddrs->DecRefCount();
        return RPC_S_OUT_OF_RESOURCES;
    }

    PWSTR pwstrT   = pdsaT->aStringArray;
    PWSTR pwstrSrc = gpdsaFullBindings->aStringArray;

    // copy in the information. For TCP/IP and UDP, we copy in the
    // new IP addresses. For all others, we leave as is.

    psaLen = 0;
    while (*pwstrSrc)
    {
        USHORT id = *pwstrSrc;      // current tower id
        pwstrSrc++;

        if (id == NCACN_IP_TCP)
        {
            if (!fDoneTCP)
            {
                // copy in the DNS name, if any, obtained initially from RPC
                // in StartListeningIfNecessary
                if (dwDNSLen > 0)
                {
                  *pwstrT = id;
                  pwstrT++;
                  OrStringCopy(pwstrT, gwszInitialDNSName);
                  pwstrT += dwDNSLen + 1;
                  psaLen += dwDNSLen + 2;
                }

                // copy in the new IP addresses
                fDoneTCP = TRUE;
                for (UINT i=0; i<dwNumAddrs; i++)
                {
                    *pwstrT = id;       // copy in the tower id
                    pwstrT++;
                    OrStringCopy(pwstrT, pIPAddrs->_pIPAddresses->NetworkAddresses[i]);
                    size_t len = OrStringLen(pIPAddrs->_pIPAddresses->NetworkAddresses[i]) + 1;
                    pwstrT += len;
                    psaLen += (DWORD) len + 1;
                }
            }
        }
        else if (id == NCADG_IP_UDP)
        {
            if (!fDoneUDP)
            {
                // copy in the new IP addresses
                fDoneUDP = TRUE;
                for (UINT i=0; i<dwNumAddrs; i++)
                {
                    *pwstrT = id;       // copy in the tower id
                    pwstrT++;
                    OrStringCopy(pwstrT, pIPAddrs->_pIPAddresses->NetworkAddresses[i]);
                    size_t len = OrStringLen(pIPAddrs->_pIPAddresses->NetworkAddresses[i]) + 1;
                    pwstrT += len;
                    psaLen += (DWORD) len + 1;
                }
            }
        }
        else
        {
            // just copy the existing entry unchanged.
            *pwstrT = id;               // copy in the tower id
            pwstrT++;
            OrStringCopy(pwstrT, pwstrSrc);
            size_t len = OrStringLen(pwstrSrc) + 1;
            pwstrT += len;
            psaLen += (DWORD) len + 1;
        }

        // skip to the next towerid entry
        pwstrSrc += OrStringLen(pwstrSrc) + 1;
    }

    // Zero final terminator
    if (psaLen == 0)
    {
        *((DWORD*) pwstrT) = 0;
        pwstrT += 2;
        psaLen += 2;
    }
    else
    {
        *pwstrT = 0;
        pwstrT++;
        psaLen += 1;
    }

    // Security authn services
    pdsaT->wSecurityOffset = (unsigned short) psaLen;
    for (i = 0; i < s_cRpcssSvc; i++)
    {
        // Authn service, Authz service (-1 means none), NULL principal name
        *pwstrT = s_aRpcssSvc[i].wId;
        pwstrT++;
        *pwstrT = -1;
        pwstrT++;
        *pwstrT = 0;
        pwstrT++;
    }

    // If there are no authentication services, put in an extra NULL.
    if (s_cRpcssSvc == 0)
    {
        *pwstrT = 0;
        pwstrT++;
        psaLen += 1;
    }

    // Final NULL
    psaLen += 3*s_cRpcssSvc + 1;
    *pwstrT = 0;

    // update the size
    pdsaT->wNumEntries = (unsigned short) psaLen;

    ASSERT(dsaValid(pdsaT));

    // Done with ipaddrs
    if (pIPAddrs) pIPAddrs->DecRefCount();
    pIPAddrs = NULL;

    // Always replace the current "full" bindings, so they
    // are always up-to-date.
    delete gpdsaFullBindings;
    gpdsaFullBindings = pdsaT;
    pdsaT = NULL;

    HRESULT hr;
    DUALSTRINGARRAY* pdsaFiltered;
    hr = gAddrExclusionMgr.BuildExclusionDSA(gpdsaFullBindings, &pdsaFiltered);
    if (FAILED(hr))
        return RPC_S_OUT_OF_RESOURCES;

    if (dsaCompare(gpdsaMyBindings->DSA(), pdsaFiltered))
    {
        // the old and new local resolver strings are the same
        // so don't change anything, just throw away the new one.
        MIDL_user_free(pdsaFiltered);
        return RPC_S_OK;
    }

    // The two are different.  First, let's see if an old mid entry
    // for the new bindings is still in the table.
    CMid* pNewLocalMid = NULL;
    CMid* pOldMatchingLocalMid = NULL;

    pOldMatchingLocalMid = (CMid*)gpMidTable->Lookup(CMidKey(pdsaFiltered));
    if (pOldMatchingLocalMid)
    {
        // Returned mid should be both local and stale
        ASSERT(pOldMatchingLocalMid->IsLocal());
        ASSERT(pOldMatchingLocalMid->IsStale());
    }
    else
    {
        // Not in the table already, create a new mid
        BOOL fMidInitOkay = FALSE;

        // The mid object makes a copy of pdsaFiltered, it doesn't own it
        pNewLocalMid = new(pdsaFiltered->wNumEntries * sizeof(WCHAR)) 
                        CMid(pdsaFiltered, TRUE, gLocalMid, &fMidInitOkay);
        if (!pNewLocalMid || !fMidInitOkay)
        {
            if (pNewLocalMid)
            {
                delete pNewLocalMid;
            }
            MIDL_user_free(pdsaFiltered);
            return RPC_S_OUT_OF_RESOURCES;          
        }
    }

    // Always need to construct a new gpdsaMyBindings
    CDualStringArray* pdsaWrapper = new CDualStringArray(pdsaFiltered);
    if (pdsaWrapper)
    {
        ASSERT(gpClientLock->HeldExclusive());

        if (pOldMatchingLocalMid)
        {
            // Mark the mid that's already in the table
            // as no longer stale, and reference it so it 
            // stays in the table.
            pOldMatchingLocalMid->Reference();
            pOldMatchingLocalMid->MarkStale(FALSE);
        }
        else
        {
            // Add new local mid to the table; it's "not stale" by default
            ASSERT(pNewLocalMid);
            gpMidTable->Add(pNewLocalMid);
        }
        
        // Mark the current mid as stale
        CMid* pCurrentMid = (CMid*)gpMidTable->Lookup(CMidKey(gpdsaMyBindings->DSA()));
        ASSERT(pCurrentMid);
        pCurrentMid->MarkStale(TRUE);
		
        // The old local mid object would normally be guaranteed to remain in the table 
        // for as long as gpClientLock is held.  It is possible that an activation in-flight
        // concurrent with this thread may try to look up the old local mid shortly 
        // after this code finishes, and if not found the oxid resolution will proceed
        // as if the mid was a remote machine, not local.  This leads to major problems.
        // To get around this somewhat fuzzy window, we addref the old mid (thus keeping
        // it in the table), and ask for a timer callback at a later time when we will 
        // be virtually guaranteed that all such in-flight local activations referencing 
        // the old mid will have completed.   
        DoAsyncMidRelease(pCurrentMid, gdwTimeoutPeriodForStaleMids);

        // DoAsyncMidRelease takes a reference to be released later; still need
        // to release it here.
        pCurrentMid->Release();
	
        // Release old bindings
        gpdsaMyBindings->Release();

        // Remember new ones
        gpdsaMyBindings = pdsaWrapper;
        
        // Increment id counter
        g_dwResolverBindingsID++;

        return RPC_S_OK;
    }
    
    // No mem
    if (pNewLocalMid) delete pNewLocalMid;

    MIDL_user_free(pdsaFiltered);

    return RPC_S_OUT_OF_RESOURCES;
}

RPC_STATUS
CopyMyOrBindings(DUALSTRINGARRAY **ppdsaOrBindings, DWORD64* pdwBindingsID)
/*++

Routine Description:

    Copies the current OR bindings to return to the
    caller.   

Parameters:

    ppdsaOrBindings -- where to put the bindings when done
    pdwBindingsID -- if successful, contains the binding id of the 
                     returned bindings.  Can be NULL if the client
                     does not care.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    HRESULT hr;
    RPC_STATUS status = RPC_S_OK;
    CDualStringArray* pdsaBindings;
    DWORD64 dwBindingsID;

    SCMVDATEHEAP();

    // Take lock only long enough to take a reference on
    // the current bindings
    gpClientLock->LockExclusive();
    
    pdsaBindings = gpdsaMyBindings;
    if (pdsaBindings)
        pdsaBindings->AddRef();

    // Save id now while we're under the lock
    dwBindingsID = g_dwResolverBindingsID;

    // We call this here in case we failed to register for 
    // address change notifications.  If it previously succeeded,
    // then this call is a no-op, otherwise it might succeed
    // this time around.
    gAddrRefreshMgr.RegisterForAddressChanges();

    gpClientLock->UnlockExclusive();

    ASSERT(pdsaBindings);
    if (!pdsaBindings)
        return RPC_S_OUT_OF_RESOURCES;

    hr = dsaAllocateAndCopy(ppdsaOrBindings, pdsaBindings->DSA());
    if (SUCCEEDED(hr) && pdwBindingsID)
    {
        *pdwBindingsID = dwBindingsID;
    }

    pdsaBindings->Release();

    SCMVDATEHEAP();

    return ((hr == S_OK) ? RPC_S_OK : RPC_S_OUT_OF_RESOURCES);
}

/*
// Debugging hack: for when you only want to debug the bindings
// update stuff with one process instead of every process 
// on the box.  
DWORD GetUpdateablePID()
{
    HKEY hOle;
    DWORD error;
    DWORD dwValue = -1;
    DWORD dwType;
    DWORD dwBufSize = sizeof(DWORD);

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        error = RegQueryValueEx(
                        hOle,
                        L"UpdateablePID",
                        0,
                        &dwType,
                        (BYTE*)&dwValue,
                        &dwBufSize);

        RegCloseKey(hOle);
    }
    return dwValue;
}
*/


void 
GetCurrentBindingsAndID(DWORD64* pdwBindingsID, CDualStringArray** ppDSABindings)
/*++

Routine Description:

    Returns to the caller the current bindings and their id.  *ppDSABindings 
    will have a refcount added.

Return Value:
	
    void

--*/

{
    ASSERT(!gpClientLock->HeldExclusive());
    ASSERT(pdwBindingsID && ppDSABindings);

    // Take reference on gpClientLock long enough to grab a 
    // reference on the current bindings
    gpClientLock->LockExclusive();
    
    ASSERT(gpdsaMyBindings);
    *ppDSABindings = gpdsaMyBindings;
    (*ppDSABindings)->AddRef();
    *pdwBindingsID = g_dwResolverBindingsID;
    
    gpClientLock->UnlockExclusive();
    
    return;
}

void 
PushCurrentBindings()
/*++

Routine Description:

    Propagates the current resolver bindings to all currently
    running processes.  

Return Value:
	
    void

--*/
{
    ORSTATUS status;
    DWORD64 dwBindingsID;
    CDualStringArray* pDSABindings = NULL;

    ASSERT(!gpClientLock->HeldExclusive());

    // If not enabled, don't do it
    if (!gbDynamicIPChangesEnabled)
        return;
	
    GetCurrentBindingsAndID(&dwBindingsID, &pDSABindings);
    ASSERT(pDSABindings);

    // Take a shared lock on the process list, and copy all of
    // the contained processes to a separate list, with an
    // extra refcount added.  Then we release the lock, and 
    // push the new bindings to each process.   New processes
    // that connect after we leave the lock will automatically
    // get the newest bindings.
    gpProcessListLock->LockShared();
    
    // Allocate space on the stack to remember each process in
    // the list.
    DWORD i = 0;
    DWORD dwTotalProcesses = 0;
    DWORD dwListSize = gpProcessList->Size();

    // Check for nothing to do.  This can occur early during boot.
    if (dwListSize == 0)
    {
        gpProcessListLock->UnlockShared();
        pDSABindings->Release();
        return;
    }

    CProcess* pprocess;
    CProcess** ppProcessList = 
        (CProcess**)_alloca(sizeof(CProcess*) * dwListSize);

    // Copy contents of current list
    CBListIterator all_procs(gpProcessList);  
    while (pprocess = (CProcess*)all_procs.Next())
    {
        // Only push bindings if process has not been rundown      
        if (!pprocess->HasBeenRundown())
        {
            // This is the moral equivalent of ReferenceProcess(pprocess, TRUE),
            // it will prevent the process object from being rundown while
            // we're using it.  It will be balanced out below by the 
            // ReleaseProcess call.
            pprocess->ClientReference();
            ppProcessList[dwTotalProcesses++] = pprocess;
        }
    }

    ASSERT(dwTotalProcesses <= dwListSize);

    gpProcessListLock->UnlockShared();

    // Now that we're outside the lock, update each process with 
    // the new bindings.  Note that even if another refresh
    // beats us, the process object tracks the binding id's, so 
    // the right thing will happen.
    for (i = 0; i < dwTotalProcesses; i++)
    {
        status = ppProcessList[i]->UpdateResolverBindings(dwBindingsID, pDSABindings->DSA());                                                            
        if (status != OR_OK)
        {
            // For use with the debugging hack above
            //        if (pprocess->GetPID() != GetUpdateablePID())
            //            continue;

            // Right now I'm considering this a best-case effort; it
            // can expectedly fail in some circumstances; eg, a process
            // initializes COM, does work, then uninit's COM and stops
            // listening on the ole32<->rpcss interfaces.   
            KdPrintEx((DPFLTR_DCOMSS_ID,
                    DPFLTR_WARNING_LEVEL,
                    "OR: failed to update dynamic resolver "
                    "bindings for process pid=%d\n",
                    ppProcessList[i]->GetPID()));
        }
    }

    // Release references on process objects
    for (i = 0; i < dwTotalProcesses; i++)
    {
    	ReleaseProcess(ppProcessList[i]);
    }

    pDSABindings->Release();

    return;
}



void
RegisterAuthInfoIfNecessary()
/*++

Routine Description:

    Initializes all COM authentication services.  The list is computed in
    ComputeSecurity.  Ignore failures.  On normal boots the authentication
    services register without error on the first call.  During setup the
    authentication services never register but the machine receives no
    remote secure activation requests.

Return Value:

    none

--*/
{
    DWORD   Status;
    SECPKG *pSvcList;
    DWORD   i;
    DWORD   j = 0;
    DWORD   k;
    DWORD   cClientSvcs;
    SECPKG* aClientSvcs;
    DWORD   cServerSvcs;
    USHORT* aServerSvcs;

    // Doesn't matter if we call RegisterAuthInfo more than once by chance.
    if (gfRegisteredAuthInfo)
        return;

    // Retrieve client\server services
    if (!GetClientServerSvcs(&cClientSvcs, &aClientSvcs, &cServerSvcs, &aServerSvcs))
        return;

    if (cServerSvcs == 0)
    {
        CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
        return;
    }

    // Allocate an array to hold the list of authentication services that
    // were successfully registered.
    pSvcList = new SECPKG[cServerSvcs];
    if (pSvcList == NULL)
    {
        CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
        return;
    }

    ZeroMemory(pSvcList, sizeof(SECPKG) * cServerSvcs);

    // Loop over the list of authentication services to register.
    for (i = 0; i < cServerSvcs; i++)
    {
        Status = RpcServerRegisterAuthInfo( NULL, aServerSvcs[i], NULL, NULL );
        if (Status == RPC_S_OK)
        {
            pSvcList[j].wId   = aServerSvcs[i];
            pSvcList[j].pName = NULL;
            for (k= 0; k < cClientSvcs; k++)
            {
                if (aClientSvcs[k].wId == aServerSvcs[i])
                {
                    if (aClientSvcs[k].pName)
                    {
                        DWORD dwLen = lstrlen(aClientSvcs[k].pName) + 1;
                        
                        pSvcList[j].pName = new WCHAR[dwLen];
                        if (!pSvcList[j].pName)
                        {
                            // No mem; cleanup previously-allocated stuff and return
                            for (i = 0; i < cServerSvcs; i++)
                            {
                                if (pSvcList[i].pName)
                                {
                                    delete pSvcList[i].pName;
                                }
                            }
                            delete pSvcList;
                            CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
                            return;
                        }

                        lstrcpy(pSvcList[j].pName, aClientSvcs[k].pName);
                    }
                    break;
                }
            }
            ASSERT( pSvcList[j].pName != NULL );
            j++;
        }
    }

    CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
    cClientSvcs = 0;
    aClientSvcs = NULL;
    cServerSvcs = 0;
    aServerSvcs = NULL;

    // If no authentication services were registered.
    if (j == 0)
        return;

    // Save the new service list if no other thread has.
    gpClientLock->LockExclusive();
    if (!gfRegisteredAuthInfo)
    {
        gfRegisteredAuthInfo = TRUE;
        s_cRpcssSvc          = j;
        s_aRpcssSvc          = pSvcList;
        pSvcList             = NULL;
    }
    gpClientLock->UnlockExclusive();

    // Free the service list if not saved in a global.
    if (pSvcList)
    {
        for (i = 0; i < cServerSvcs; i++)
        {
            if (pSvcList[i].pName)
            {
                delete pSvcList[i].pName;
            }
        }
        delete pSvcList;
    }

    return;
}

/*++

Routine Description:

   Return TRUE if the specified authentication service is in the
   dual string array.

--*/
BOOL ValidAuthnSvc( const DUALSTRINGARRAY *pBinding, WORD wService )
{
    const WCHAR *pwstrT = &pBinding->aStringArray[pBinding->wSecurityOffset];

    while (*pwstrT)
    {
        if (*pwstrT == wService)
        {
        return TRUE;
        }

        pwstrT = OrStringSearch((PWSTR) pwstrT, 0) + 1;
    }
    return FALSE;
}

//
// Local ID allocation
//

BOOL 
AllocateId(ID* pID)
/*++

Routine Description:

    Allocates and returns a random 64-bit integer.

Arguments:

    pID - pointer to the caller's 64-bit #

Return Value:

    TRUE  -- random # successfully generated
    FALSE -- error occurred

--*/
{
    ASSERT(pID);

    if (FAILED(gRNG.GenerateRandomNumber(pID, sizeof(*pID))))
    {
        return FALSE;
    }

    return TRUE;
}

//
// Implementation of random # generation wrapper class
//

// single global definition of the above class
CRandomNumberGenerator gRNG;

// Constructor\destructor
CRandomNumberGenerator::CRandomNumberGenerator() : _rc4SafeCtx(NULL) {}

CRandomNumberGenerator::~CRandomNumberGenerator()
{
    if (_rc4SafeCtx)
    {
        rc4_safe_shutdown(_rc4SafeCtx); // free safe rc4 resources.
        _rc4SafeCtx = NULL;
    }
}

// Initialize - not threadsafe
BOOL CRandomNumberGenerator::Initialize()
{
    if (!_rc4SafeCtx)
        rc4_safe_startup(&_rc4SafeCtx);
	
    // if this fails to init, we should find out why
    ASSERT(_rc4SafeCtx);

    return (_rc4SafeCtx) ? TRUE : FALSE;
}

#define RC4_REKEY_PARAM (500000)

// GenerateRandomNumber - threadsafe
HRESULT CRandomNumberGenerator::GenerateRandomNumber(PVOID pBuffer, ULONG ulBufSize)
{
    unsigned int KeyEntry;
    unsigned int KeyBytesUsed = 0;
    
    if (!_rc4SafeCtx)
    {
        ASSERT(!"Should not be called before Initialize\n");
        return E_OUTOFMEMORY;
    }

    rc4_safe_select(_rc4SafeCtx, &KeyEntry, &KeyBytesUsed);

    if (KeyBytesUsed >= RC4_REKEY_PARAM)
    {
        BYTE newSeed[256];

        if (!RtlGenRandom(newSeed, sizeof(newSeed)))
        {
            ASSERT(!"RtlGenRandom failure\n");
            return E_OUTOFMEMORY;
        }

        rc4_safe_key(_rc4SafeCtx, KeyEntry, sizeof(newSeed), newSeed);
    }

    // the rc4_safe fucntion is thread safe
    rc4_safe(_rc4SafeCtx, KeyEntry, ulBufSize, pBuffer);

    return S_OK;
}


//
// Debug helper(s)
//

#if DBG

int __cdecl __RPC_FAR ValidateError(
                                   IN ORSTATUS Status,
                                   IN ...)
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

    VALIDATE( (Status,
               OR_BADSET,
               // more error codes here
               OR_OK,
               0)  // list must be terminated with 0
               );

     This function is called with the OrStatus and expected errors codes
     as parameters.  If OrStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.

    ... - One or more expected status codes.  Terminated with 0 (OR_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    RPC_STATUS CurrentStatus;
    va_list Marker;

    if (Status == 0) return(TRUE);

    va_start(Marker, Status);

    while (CurrentStatus = va_arg(Marker, RPC_STATUS))
    {
        if (CurrentStatus == Status)
        {
            return(TRUE);
        }
    }

    va_end(Marker);

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR Assertion: unexpected failure %lu\n",
               (unsigned long)Status));

    return(FALSE);
}

//
// Dummy implementation to keep the linker happy
//
HRESULT CStackWalkerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    ASSERT (!"You shouldn't be calling this");
    return E_NOTIMPL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\namedobj.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    namedobj.cxx

Abstract:

    Implements table-based creation and lookup services for 
    "pseudo"-named kernel objects.   This allows unrelated bits
    of code in the same process to find the same named objects
    without actually creating a full-fledged named kernel
    object.

Revision History:

    JSimmons    02-28-02    Created

--*/

#include <or.hxx>

// Global ptr to object table
CNamedObjectTable* gpNamedObjectTable = NULL;

//
//  CNameKey
//
//  Used for lookups in the hash table.  Not exposed outside
//  this file.
//
class CNameKey : public CTableKey
{
public:

    CNameKey(LPWSTR pszName, CNamedObject::OBJTYPE type) :
                _pszName(pszName),
                _type(type)
    {
        ASSERT(pszName);
        ASSERT(CNamedObject::ValidObjType(type));
    };

    ~CNameKey() {};

    DWORD Hash()
    {
        LPCWSTR psz = _pszName;
        unsigned long hash = 0x01234567;
        while (*psz) hash = (hash << 5) + (hash >> 27) + *psz++;
        return hash;
    }

    BOOL Compare(CTableKey &tk)
    {
        CNameKey& namekey = (CNameKey&)tk;
        if (namekey._type != _type)
            return FALSE;
        return !lstrcmp(_pszName, namekey._pszName);
    }
    
private:
    const LPCWSTR         _pszName;  // someone else's ptr, we don't own it
    CNamedObject::OBJTYPE _type;    
};


CNamedObject::CNamedObject(HANDLE hHandle, OBJTYPE type, LPWSTR pszName) :
        _hHandle(hHandle),
        _type(type)
{
    ASSERT(_hHandle);
    ASSERT(ValidObjType(type));
    ASSERT(pszName);
    lstrcpy(_szName, pszName);
}

CNamedObject::~CNamedObject()
{
    ASSERT(_hHandle);
    CloseHandle(_hHandle);
}

DWORD CNamedObject::Release()
{
    LONG lRefs = gpNamedObjectTable->ReleaseAndMaybeRemove(this);
    if (lRefs == 0)
    {
        delete this;
    }
    return lRefs;
}

DWORD CNamedObject::Hash()
{
    CNameKey mykey(_szName, _type);
    return mykey.Hash();
}

BOOL CNamedObject::Compare(CTableKey &tk)
{
    CNameKey& theirkey = (CNameKey&)tk;
    CNameKey mykey(_szName, _type);
    return mykey.Compare(theirkey);
}

BOOL CNamedObject::Compare(CONST CTableElement *element)
{
    CNamedObject& namedobject = (CNamedObject&)*element;
    CNameKey theirkey(namedobject._szName, namedobject._type);
    CNameKey mykey(_szName, _type);
    return mykey.Compare(theirkey);
}

BOOL CNamedObject::ValidObjType(OBJTYPE type)
{
    return ((type >=OBJTYPE_MIN) && (type < OBJTYPE_MAX));
}

CNamedObject* CNamedObject::Create(OBJTYPE type, LPWSTR pszName)
{
    HANDLE hNew = NULL;
    CNamedObject* pObject = NULL;
    
    hNew = CNamedObject::CreateHandle(type);
    if (hNew)
    {
        DWORD dwObjectSize = (lstrlen(pszName)+1) * sizeof(WCHAR);
        pObject = new(dwObjectSize) CNamedObject(hNew, type, pszName);
        if (!pObject)
        {
            CloseHandle(hNew);
        }
    }
    return pObject;
}

HANDLE CNamedObject::CreateHandle(OBJTYPE type)
{
    HANDLE hNew = NULL;

    switch (type)
    {
    case EVENT:
        hNew = CreateEvent(NULL, FALSE, FALSE, NULL);
        break;
    case MUTEX:
        hNew = CreateMutex(NULL, FALSE, NULL);
        break;
    default:
        ASSERT(!"Caller specified incorrect object type");
        break;
    };

    return hNew;
}

//
//  GetNamedObject
//  
//  Meat of the table.   Take read lock, look for existing object, if 
//  found, return it..  Else, take write lock, look again for existing 
//  object, if found return it, else create new object, save it in the
//  table, return it.
//  
CNamedObject* CNamedObjectTable::GetNamedObject(
                            LPWSTR pszObjName, 
                            CNamedObject::OBJTYPE type) 
{
    HRESULT hr = S_OK;
    CNamedObject* pObject = NULL;
    CNameKey namekey(pszObjName, type);

    _pLock->LockShared();

    pObject = (CNamedObject*)_pHashTbl->Lookup(namekey);
    if (pObject)
    {
        pObject->Reference();
        _pLock->UnlockShared();
    }
    else
    {
        // Didn't find it. Take write lock, look again
        _pLock->ConvertToExclusive();

        pObject = (CNamedObject*)_pHashTbl->Lookup(namekey);
        if (!pObject)
        {
            pObject = CNamedObject::Create(type, pszObjName);
            if (pObject)
            {
                _pHashTbl->Add(pObject); // 1 reference keeping it alive in the table
            }
        }
        else
        {
            // found an existing one after taking the lock
            pObject->Reference();
        }

        _pLock->UnlockExclusive();
    }

    return pObject;
}

//
//  ReleaseAndMaybeRemove
//
//  CNamedObject's use this method to perform an atomic refcount 
//  decrement + potential removal from the table.
//
LONG CNamedObjectTable::ReleaseAndMaybeRemove(CNamedObject* pObject)
{
    LONG lRefs = 0;

    ASSERT(pObject);

    _pLock->LockExclusive();

    if (pObject->References() == 1)
    {
        _pHashTbl->Remove(pObject);
    }

    lRefs = pObject->Dereference();        

    _pLock->UnlockExclusive();

    return lRefs;
}

// constructor        
CNamedObjectTable::CNamedObjectTable(ORSTATUS& status) :
            _pHashTbl(NULL),
            _pLock(NULL)
{
    status = OR_NOMEM;
    _pHashTbl = new CHashTable(status);
    if (status == OR_OK)
    {
        status = OR_NOMEM;
        _pLock = new CSharedLock(status);
    }
}
            
// destructor
CNamedObjectTable::~CNamedObjectTable()
{
    // We live for the life of the RPCSS service so cleanup is
    // not a high priority.  If our lifetime is ever shortened 
    // to something less we'll need to do better.
    //delete _pHashTbl;
    //delete _pLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\objex.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ObjEx.cxx

Abstract:

    Main entry point for the object exporter service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-28-95    Bits 'n pieces
    ronans      04-14-97    HTTP support

--*/


#include <or.hxx>
#include <mach.hxx>
#include <misc.hxx>
#include <ntlsa.h>
extern "C"
{
#define SECURITY_WIN32 // Used by sspi.h
#include <sspi.h>      // EnumerateSecurityPackages
}

//
// Process globals - read-only except during init.
//

// MID of the string bindings for this machine.
MID    gLocalMid = 0;

// Contains the buffer of protseq's to listen on from the registry
PWSTR gpwstrProtseqs = 0;

// Number of remote protseqs used by this process.
USHORT cMyProtseqs = 0;

// ProtseqIds of the remote protseqs used by this process.
USHORT *aMyProtseqs = 0;

BOOL g_fClientHttp = FALSE;
//
// Process globals - read-write
//

CSharedLock *gpServerLock = 0;
CSharedLock *gpClientLock = 0;
CSharedLock *gpProcessListLock = 0;
CSharedLock *gpIPCheckLock = 0;

CHashTable  *gpServerOxidTable = 0;

CHashTable  *gpClientOxidTable = 0;
CPList      *gpClientOxidPList = 0;

CHashTable      *gpServerOidTable = 0;
CServerOidPList *gpServerOidPList = 0;
CList           *gpServerPinnedOidList = 0;

CHashTable  *gpClientOidTable = 0;

CServerSetTable  *gpServerSetTable = 0;

CHashTable  *gpClientSetTable = 0;
CPList      *gpClientSetPList = 0;

CHashTable *gpMidTable = 0;

CList *gpTokenList = 0;

DWORD gNextThreadID = 1;
HANDLE       gLSAHandle;
PSID         gSidService;
WCHAR        *gpwszDefaultDomainName;
//+-------------------------------------------------------------------------
//
//  Function:   ComputeSecurity
//
//  Synopsis:   Looks up some registry keys and enumerates the security
//              packages on this machine.
//
//--------------------------------------------------------------------------
// These variables hold values read out of the registry and cached.
// s_fEnableDCOM is false if DCOM is disabled.  The others contain
// authentication information for legacy applications.
BOOL       s_fCatchServerExceptions;
BOOL       s_fBreakOnSilencedServerExceptions;
BOOL       s_fEnableDCOM;
DWORD      s_lAuthnLevel;
DWORD      s_lImpLevel;
BOOL       s_fMutualAuth;
BOOL       s_fSecureRefs;
WCHAR     *s_pLegacySecurity;
DWORD      s_dwLegacySecurityLen; // cached length of s_pLegacySecurity

// ronans - s_fEnableDCOMHTTP is false if DCOMHTTP is disabled.
BOOL       s_fEnableDCOMHTTP;

// s_sServerSvc is a list of security providers that OLE servers can use.
// s_aClientSvc is a list of security providers that OLE clients can use.
// The difference is that Chicago only supports the client side of some
// security providers and OLE servers must know how to determine the
// principal name for the provider.  Clients get the principal name from
// the server.
DWORD      s_cServerSvc      = 0;
USHORT    *s_aServerSvc      = NULL;
DWORD      s_cClientSvc      = 0;
SECPKG    *s_aClientSvc      = NULL;

// The registry key for OLE's registry data.
HKEY       s_hOle            = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   FindSvc
//
//  Synopsis:   Returns index of the specified authentication service or -1.
//
//--------------------------------------------------------------------------
DWORD FindSvc( USHORT AuthnSvc, USHORT *aAuthnSvc, DWORD cAuthnSvc )
{
    DWORD i;

    // Look for the id in the array.
    for (i = 0; i < cAuthnSvc; i++)
        if (aAuthnSvc[i] == AuthnSvc)
            return i;
    return -1;
}

//+-------------------------------------------------------------------------
//
//  Function:   FindSvc
//
//  Synopsis:   Returns index of the specified authentication service or -1.
//
//--------------------------------------------------------------------------
DWORD FindSvc( USHORT AuthnSvc, SECPKG *aAuthnSvc, DWORD cAuthnSvc )
{
    DWORD i;

    // Look for the id in the array.
    for (i = 0; i < cAuthnSvc; i++)
        if (aAuthnSvc[i].wId == AuthnSvc)
            return i;
    return -1;
}

//+-------------------------------------------------------------------------
//
//  Function:   ComputeSecurity
//
//  Synopsis:   Looks up some registry keys and enumerates the security
//              packages on this machine.
//
//--------------------------------------------------------------------------
void ComputeSecurity()
{
    SecPkgInfo *pAllPkg;
    SecPkgInfo *pNext;
    HRESULT     hr;
    DWORD       i;
    DWORD       j;
    DWORD       lMaxLen;
    HKEY        hKey;
    DWORD       lType;
    DWORD       lData;
    DWORD       lDataSize;
    WCHAR       cBuffer[80];
    WCHAR      *pSecProt = cBuffer;
    DWORD       cServerSvc;
    USHORT     *aServerSvc = NULL;
    DWORD       cClientSvc;
    SECPKG     *aClientSvc = NULL;
    BOOL        fFiltered = FALSE;

    // Get the list of security packages.
    cClientSvc = 0;
    cServerSvc = 0;
    hr = EnumerateSecurityPackages( &lMaxLen, &pAllPkg );
    if (hr == SEC_E_OK)
    {
        // Allocate memory for both service lists.
        aServerSvc = (USHORT*)MIDL_user_allocate(sizeof(USHORT) * lMaxLen);
        aClientSvc = (SECPKG*)MIDL_user_allocate(sizeof(SECPKG) * lMaxLen);
        if (aServerSvc == NULL || aClientSvc == NULL)
        {
            hr = E_OUTOFMEMORY;
            MIDL_user_free(aServerSvc);
            MIDL_user_free(aClientSvc);
            aServerSvc = NULL;
            aClientSvc = NULL;

            // if out-of-mem, don't keep going.
            FreeContextBuffer(pAllPkg);
            return;     
        }
        else
        {
            ZeroMemory(aServerSvc, sizeof(USHORT) * lMaxLen);
            ZeroMemory(aClientSvc, sizeof(SECPKG) * lMaxLen);

            // Check all packages.
            pNext = pAllPkg;
            for (i = 0; i < lMaxLen; i++)
            {
                // Authentication services with RPC id SECPKG_ID_NONE (0xffff)
                // won't work with RPC.
                if (pNext->wRPCID != SECPKG_ID_NONE)
                {
                    // Determine if clients can use the package but don't
                    // save duplicates.
                    if ((pNext->fCapabilities & SECPKG_FLAG_CONNECTION) &&
                        FindSvc(pNext->wRPCID, aClientSvc, cClientSvc) == -1)
                    {
                        // Copy rpcid
                        aClientSvc[cClientSvc].wId = pNext->wRPCID;

                        // Copy secpkg name if there is one
                        if (pNext->Name)
                        {
                            DWORD dwBufSize = (lstrlen(pNext->Name) + 1) * sizeof(WCHAR);

                            aClientSvc[cClientSvc].pName = (WCHAR*)MIDL_user_allocate(dwBufSize);
                            if (!aClientSvc[cClientSvc].pName)
                            {
                                // No mem.  Clean up what we have, and return
                                FreeContextBuffer(pAllPkg);
                                CleanupClientServerSvcs(cClientSvc, 
                                                        aClientSvc,
                                                        cServerSvc,
                                                        aServerSvc);
                                return;
                            }
                            lstrcpy(aClientSvc[cClientSvc].pName, pNext->Name);
                        }
                        cClientSvc++;
                    }

                    // Determine if servers can use the package but don't save dups.
                    if ( (pNext->fCapabilities & SECPKG_FLAG_CONNECTION) &&
                          ~(pNext->fCapabilities & (SECPKG_FLAG_CLIENT_ONLY)) &&
                          FindSvc(pNext->wRPCID, aServerSvc, cServerSvc) == -1)
                    {
                        aServerSvc[cServerSvc++] = pNext->wRPCID;
                    }
                }
                pNext++;
            }
        }
        FreeContextBuffer(pAllPkg);
        pAllPkg = NULL;
    }

    // Sort and filter the security provider list by the security protocol value.
    hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\RPC",
                           NULL, KEY_QUERY_VALUE, &hKey );
    if (hr == ERROR_SUCCESS)
    {
        // Query the value for DCOM Security
        // Note:  this key is undocumented and is meant only for use by the test team.
        lDataSize = sizeof(cBuffer);
        hr = RegQueryValueEx( hKey, L"DCOM Security", NULL, &lType,
                              (unsigned char *) pSecProt, &lDataSize );

        // Retry with more space if necessary
        if (hr == ERROR_MORE_DATA)
        {
            pSecProt = (WCHAR *) _alloca(lDataSize);
            hr = RegQueryValueEx( hKey, L"DCOM Security", NULL, &lType,
                                  (unsigned char *) pSecProt, &lDataSize );
        }
        if (hr == ERROR_SUCCESS && lType == REG_MULTI_SZ && lDataSize > 3)
        {
            fFiltered    = TRUE;

            // Save original list
            DWORD       cServerSvcPreFilter = cServerSvc;
            USHORT     *aServerSvcPreFilter = aServerSvc;
    
            cServerSvc = 0;
            aServerSvc = NULL;

            // Allocate memory for server service list.
            aServerSvc = (USHORT*)MIDL_user_allocate(sizeof(USHORT) * cServerSvcPreFilter);
            if (!aServerSvc)
            {
                // No mem, cleanup and return
                CleanupClientServerSvcs(cClientSvc, 
                                        aClientSvc,
                                        cServerSvcPreFilter,
                                        aServerSvcPreFilter);
                return;
            }

            ZeroMemory(aServerSvc, sizeof(USHORT) * cServerSvcPreFilter);

            // Fill in filtered list
            while (*pSecProt != 0 && (cServerSvc < cServerSvcPreFilter))
            {
                i = _wtoi( pSecProt );
                ASSERT(i <= USHRT_MAX); // this would be a test bug

                if (FindSvc( (USHORT)i, aServerSvcPreFilter, (USHORT)cServerSvcPreFilter ) != -1)
                    aServerSvc[cServerSvc++] = (USHORT)i;
                pSecProt += wcslen(pSecProt)+1;
            }

            // Cleanup old server svc list.   Will save filtered list below on normal path
            MIDL_user_free(aServerSvcPreFilter);
            aServerSvcPreFilter = NULL;
            cServerSvcPreFilter = 0;
        }

        // Close the key.
        RegCloseKey( hKey );
    }

    // Find snego in the client list.
    for (i = 0; i < cClientSvc; i++)
        if (aClientSvc[i].wId == RPC_C_AUTHN_GSS_NEGOTIATE)
            break;

    // If snego exists and is not first, move it first.
    if (i < cClientSvc && i != 0)
    {
        SECPKG sSwap = s_aClientSvc[i];
        memmove( &aClientSvc[1], &aClientSvc[0], sizeof(SECPKG)*i );
        aClientSvc[0] = sSwap;
    }

    // If there is no DCOM security value, move snego first in the server list.
    if (!fFiltered)
    {
        // Find snego in the server list.
        for (i = 0; i < cServerSvc; i++)
            if (aServerSvc[i] == RPC_C_AUTHN_GSS_NEGOTIATE)
                break;

        // If snego exists and is not first, move it first.
        if (i < cServerSvc && i != 0)
        {
            USHORT usSwap = aServerSvc[i];
            memmove( &aServerSvc[1], &aServerSvc[0], sizeof(USHORT)*i );
            aServerSvc[0] = usSwap;
        }
    }

    // Save new client\server svc lists.
    SetClientServerSvcs(cClientSvc, aClientSvc, cServerSvc, aServerSvc);

    // Set all the security flags to their default values.
    s_fEnableDCOM       = FALSE;
    s_fEnableDCOMHTTP   = FALSE;
    s_fCatchServerExceptions = TRUE;
    s_fBreakOnSilencedServerExceptions = FALSE;
    s_lAuthnLevel       = RPC_C_AUTHN_LEVEL_CONNECT;
    s_lImpLevel         = RPC_C_IMP_LEVEL_IDENTIFY;
    s_fMutualAuth       = FALSE;
    s_fSecureRefs       = FALSE;

    // Open the security key.  s_hOle will only be non-NULL on the first pass
    // thru this code, after that we keep it open forever.
    if (s_hOle == NULL)
    {
        HKEY hOle = NULL;
        hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE",
                               NULL, KEY_READ, &hOle );
        if (hr != ERROR_SUCCESS)
            return;
        
        LPVOID pv = InterlockedCompareExchangePointer ( (void **) &s_hOle, (void *) hOle, NULL);
        if ( pv != NULL )
        {
            RegCloseKey(hOle);
        }
    }

    ASSERT(s_hOle);

    // Query the value for EnableDCOM.
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"EnableDCOM", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fEnableDCOM = TRUE;
    }

    // ronans - Query the value for EnableDCOMHTTP.
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"EnableDCOMHTTP", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
        {
            s_fEnableDCOMHTTP = TRUE;
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: EnableDCOMHTTP set to TRUE\n"));
        }
    }

    if (!s_fEnableDCOMHTTP)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: EnableDCOMHTTP set to FALSE\n"));
    }

    // Query the value for IgnoreServerExceptions. This value is just
    // to let some ISVs debug their servers a little easier. In normal
    // operation these exceptions should be caught.
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"IgnoreServerExceptions", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fCatchServerExceptions = FALSE;
    }

    // Allow ISVs to enable debugbreaks on all silenced exceptions if there's a debugger present
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"BreakOnSilencedServerExceptions", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fBreakOnSilencedServerExceptions = TRUE;
    }

    // Query the value for the legacy services. Note: this key is undocumented 
    // and is meant only for use by the test team.
    lDataSize = 0;
    hr = RegQueryValueEx( s_hOle, L"LegacyAuthenticationService", NULL,
                          &lType, NULL, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_BINARY &&
        lDataSize >= sizeof(SECURITYBINDING))
    {
        WCHAR* pNewLegacySecurity = (WCHAR*)MIDL_user_allocate(sizeof(BYTE) * lDataSize);

        if (pNewLegacySecurity != NULL)
        {
            hr = RegQueryValueEx( s_hOle, L"LegacyAuthenticationService", NULL,
                                  &lType, (unsigned char *) pNewLegacySecurity,
                                  &lDataSize );

            // Verify that the data is a security binding.
            if (hr != ERROR_SUCCESS                 ||
                lType != REG_BINARY                 ||
                lDataSize < sizeof(SECURITYBINDING) ||
                pNewLegacySecurity[1] != 0           ||
                pNewLegacySecurity[(lDataSize >> 1) - 1] != 0)
            {
                MIDL_user_free(pNewLegacySecurity);
                pNewLegacySecurity = NULL;
                lDataSize = 0;
            }

            // Set it whether success or not. A misconfigured registry will cause
            // us to set it back to NULL.
            SetLegacySecurity(pNewLegacySecurity, lDataSize);
        }
    }

    // Query the value for the authentication level.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacyAuthenticationLevel", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_DWORD)
    {
        s_lAuthnLevel = lData;
    }

    // Query the value for the impersonation level.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacyImpersonationLevel", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_DWORD)
    {
        s_lImpLevel = lData;
    }

    // Query the value for mutual authentication.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacyMutualAuthentication", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fMutualAuth = TRUE;
    }

    // Query the value for secure interface references.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacySecureReferences", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fSecureRefs = TRUE;
    }
    ASSERT(gpPingSetQuotaManager);
    
    // Query the value for per-user pingset quota.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"UserPingSetQuota", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_DWORD && lDataSize != 0)
    {
       gpPingSetQuotaManager->SetPerUserPingSetQuota(lData);
    }
    
}

void
CleanupClientServerSvcs(
        DWORD   cClientSvcs, 
        SECPKG* aClientSvcs,
        DWORD   cServerSvcs,  // unused
        USHORT* aServerSvcs
)
{
    DWORD i;

    for (i = 0; i < cClientSvcs; i++)
    {
        if (aClientSvcs[i].pName)
        {
            MIDL_user_free(aClientSvcs[i].pName);
        }
    }
    MIDL_user_free(aClientSvcs);

    MIDL_user_free(aServerSvcs);

    return;
}

void
SetClientServerSvcs(
        DWORD   cClientSvcs, 
        SECPKG* aClientSvcs,
        DWORD   cServerSvcs,
        USHORT* aServerSvcs
)
/*++

Routine Description:

    Saves the supplied client\server security svcs.

Return Value:

    None
         
--*/
{
    gpClientLock->LockExclusive();
        
    // Cleanup the old ones
    CleanupClientServerSvcs(s_cClientSvc, s_aClientSvc, s_cServerSvc, s_aServerSvc);

    // Save the new ones
    s_cClientSvc = cClientSvcs;
    s_aClientSvc = aClientSvcs;
    s_cServerSvc = cServerSvcs;
    s_aServerSvc = aServerSvcs;

    gpClientLock->UnlockExclusive();

    return;
}

BOOL
GetClientServerSvcs(
        DWORD*   pcClientSvcs, 
        SECPKG** paClientSvcs,
        DWORD*   pcServerSvcs,
        USHORT** paServerSvcs
)
/*++

Routine Description:

    Saves the supplied client\server security svcs.

Return Value:

    TRUE -- success
    FALSE -- no mem
         
--*/
{   
    BOOL fReturn = FALSE;
    SECPKG* aClientSvcs = NULL;
    USHORT* aServerSvcs = NULL;
    
    gpClientLock->LockShared();

    *pcClientSvcs = 0;
    *paClientSvcs = NULL;
    *pcServerSvcs = 0;
    *paServerSvcs = NULL;

    aServerSvcs = (USHORT*)MIDL_user_allocate(sizeof(USHORT) * s_cServerSvc);
    if (aServerSvcs)
    {
        // Copy server svcs
        CopyMemory(aServerSvcs, s_aServerSvc, sizeof(USHORT) * s_cServerSvc);

        aClientSvcs = (SECPKG*)MIDL_user_allocate(sizeof(SECPKG) * s_cClientSvc);
        if (aClientSvcs)
        {
            DWORD i;

            ZeroMemory(aClientSvcs, sizeof(SECPKG) * s_cClientSvc);

            // Copy client svcs
            for (i = 0; i < s_cClientSvc; i++)
            {
                // Copy the id
                aClientSvcs[i].wId = s_aClientSvc[i].wId;
            
                // Copy the name if it has one
                if (s_aClientSvc[i].pName)
                {
                    DWORD dwLen = lstrlen(s_aClientSvc[i].pName) + 1;

                    aClientSvcs[i].pName = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR) * dwLen);
                    if (!aClientSvcs[i].pName)
                    {
                        // Cleanup what we have, then return
                        CleanupClientServerSvcs(s_cClientSvc, 
                                                aClientSvcs,
                                                s_cServerSvc,
                                                aServerSvcs);
                        
                        break;
                    }
                    
                    lstrcpy(aClientSvcs[i].pName, s_aClientSvc[i].pName);
                }
            }

            if (i == s_cClientSvc)
            {
                // Success - caller will now own the memory
                *pcClientSvcs = s_cClientSvc;
                *paClientSvcs = aClientSvcs;
                *pcServerSvcs = s_cServerSvc;
                *paServerSvcs = aServerSvcs;
                fReturn = TRUE;
            }
        }
        else
        {
            MIDL_user_free(aServerSvcs);
        }
    }

    gpClientLock->UnlockShared();

    return fReturn;
}

BOOL
GetLegacySecurity(
        WCHAR** ppszLegacySecurity
)
{
    BOOL fRet = TRUE;
    DWORD dwLen;

    *ppszLegacySecurity = NULL;

    gpClientLock->LockShared();
    
    if (s_dwLegacySecurityLen)
    {
        *ppszLegacySecurity = (WCHAR*)MIDL_user_allocate(sizeof(BYTE) * s_dwLegacySecurityLen);
        if (*ppszLegacySecurity)
        {
            CopyMemory(*ppszLegacySecurity, s_pLegacySecurity, sizeof(BYTE) * s_dwLegacySecurityLen);
            fRet = TRUE;
        }
        else
            fRet = FALSE;
    }

    gpClientLock->UnlockShared();

    return fRet;
};

void
SetLegacySecurity(
		WCHAR* pszLegacySecurity,
		DWORD dwDataSize
)
{
    gpClientLock->LockExclusive();
    
    // Free the old one, save the new one
    MIDL_user_free(s_pLegacySecurity);
    s_pLegacySecurity = pszLegacySecurity;

    // Cache the size of the new data
    s_dwLegacySecurityLen = dwDataSize;

    gpClientLock->UnlockExclusive();

    return;
}

//
// Startup
//

static CONST PWSTR gpwstrProtocolsPath  = L"Software\\Microsoft\\Rpc";
static CONST PWSTR gpwstrProtocolsValue = L"DCOM Protocols";

DWORD StartObjectExporter(
    void
    )
/*++

Routine Description:

    Starts the object resolver service.

Arguments:

    None

Return Value:

    None

Notes:   This function is a bit weak on cleanup code in case of errors.  This
         is because if this function fails for any reason, RPCSS will not 
         start.   Usually this function will never fail since 1) we always
         start at machine boot, when lots of memory is available; and 2) we 
         don't support stopping or restarting of RPCSS.
         

--*/

{
    ORSTATUS status;
    int i;
    DWORD tid;
    HANDLE hThread;
    RPC_BINDING_VECTOR *pbv;
    DWORD SidSize;

    status = RtlInitializeCriticalSection(&gcsFastProcessLock);
    if (!NT_SUCCESS(status))
        return status;

    status = RtlInitializeCriticalSection(&gcsTokenLock);
    if (!NT_SUCCESS(status))
        return status;

    status = OR_OK;
    
    // Allocate PingSet quota  manager
    gpPingSetQuotaManager = new CPingSetQuotaManager(status);
    if ((status != OR_OK) || !gpPingSetQuotaManager)
        {
        delete gpPingSetQuotaManager;
        gpPingSetQuotaManager = NULL;
        return OR_NOMEM;
        }
    // Lookup security data.
    ComputeSecurity();
    UpdateState(SERVICE_START_PENDING);

    // Allocate tables

    // Assume 16 exporting processes/threads.
    gpServerOxidTable = new CHashTable(status, DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpServerOxidTable;
        gpServerOxidTable = 0;
        }

    // Assume 11 exported OIDs per process/thread.
    gpServerOidTable = new CHashTable(status, 11*(DEBUG_MIN(16,4)));
    if (status != OR_OK)
        {
        delete gpServerOidTable;
        gpServerOidTable = 0;
        }

    gpServerSetTable = new CServerSetTable(status);
    if (status != OR_OK)
        {
        delete gpServerSetTable;
        gpServerSetTable = 0;
        }

    // Assume < 16 imported OXIDs
    gpClientOxidTable = new CHashTable(status, DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpClientOxidTable;
        gpClientOxidTable = 0;
        }

    // Assume an average of 4 imported object ids per imported oxid
    gpClientOidTable = new CHashTable(status, 4*DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpClientOidTable;
        gpClientOidTable = 0;
        }

    // Assume <16 servers (remote machines) in use per client.
    gpClientSetTable = new CHashTable(status, DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpClientSetTable;
        gpClientSetTable = 0;
        }

    gpMidTable = new CHashTable(status, DEBUG_MIN(16,2));
    if (status != OR_OK)
        {
        delete gpMidTable;
        gpMidTable = 0;
        }

    // Allocate lists
    gpClientOxidPList = new CPList(status, BasePingInterval);
    if (status != OR_OK)
    {
        delete gpClientOxidPList;
        gpClientOxidPList = 0;
    }

    gpServerOidPList = new CServerOidPList(status);
    if (status != OR_OK)
    {
        delete gpServerOidPList;
        gpServerOidPList = 0;
    }

    gpClientSetPList = new CPList(status, BasePingInterval);
    if (status != OR_OK)
    {
        delete gpClientSetPList;
        gpClientSetPList = 0;
    }

    gpTokenList = new CList();
    gpProcessList = new CBList(DEBUG_MIN(128,4));
    gpServerPinnedOidList = new CList();

    // Allocate RPC security callback manager
    gpCRpcSecurityCallbackMgr = new CRpcSecurityCallbackManager(status);
    if (status != OR_OK)
        {
        delete gpCRpcSecurityCallbackMgr;
        gpCRpcSecurityCallbackMgr = NULL;
        }
    
    SidSize = SECURITY_MAX_SID_SIZE;
    gSidService = LocalAlloc(LMEM_ZEROINIT, SidSize);
    gpwszDefaultDomainName = (WCHAR*)LocalAlloc(LMEM_ZEROINIT, (DNLEN+1)*sizeof(WCHAR));
    if (   status != OR_OK
        || !gpServerLock
        || !gpClientLock
        || !gpServerOxidTable
        || !gpClientOxidTable
        || !gpClientOxidPList
        || !gpServerOidTable
        || !gpServerOidPList
        || !gpClientOidTable
        || !gpMidTable
        || !gpServerSetTable
        || !gpClientSetTable
        || !gpClientSetPList
        || !gpTokenList
        || !gpProcessList
        || !gpServerPinnedOidList
        || !gSidService
        || !gpwszDefaultDomainName
        || !gpCRpcSecurityCallbackMgr
        )
        {
        return(OR_NOMEM);
        }

    // Read protseqs from the registry

    DWORD  dwType;
    DWORD  dwLenBuffer = 118;
    HKEY hKey;

    status =
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 gpwstrProtocolsPath,
                 0,
                 KEY_READ,
                 &hKey);

    ASSERT(gpwstrProtseqs == 0);

    if (status == ERROR_SUCCESS)
        {
        do
            {
            delete gpwstrProtseqs;
            gpwstrProtseqs = new WCHAR[(dwLenBuffer + 1 )/2];
            if (gpwstrProtseqs)
                {
                status = RegQueryValueEx(hKey,
                                         gpwstrProtocolsValue,
                                         0,
                                         &dwType,
                                         (PBYTE)gpwstrProtseqs,
                                         &dwLenBuffer
                                         );
                }
            else
                {
                return(OR_NOMEM);
                }

            }
        while (status == ERROR_MORE_DATA);

        RegCloseKey(hKey);
        }

    if (  status != ERROR_SUCCESS
        || dwType != REG_MULTI_SZ )
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: No protseqs configured\n"));

        delete gpwstrProtseqs;
        gpwstrProtseqs = 0;
        }

    // Always listen to local protocols
    // If this fails, the service should fail.
    status = UseProtseqIfNecessary(ID_LPC);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    UpdateState(SERVICE_START_PENDING);

    // set g_fClientHttp to false initially
    g_fClientHttp = FALSE;

    // This fails during setup.  If it fails, only remote secure activations
    // will be affected so it is safe to ignore.
    RegisterAuthInfoIfNecessary();

    // Construct remote protseq id and compressed binding arrays.
    status = StartListeningIfNecessary();

    if (status != OR_OK)
        {
        return(status);
        }

    UpdateState(SERVICE_START_PENDING);

    // Register OR server interfaces.
    status = RpcServerRegisterIfEx(_ILocalObjectExporter_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          LocalInterfaceOnlySecCallback);
    ASSERT(status == RPC_S_OK);

    // IObjectExporter must be able to receive unauthenticated calls, hence
    // we do not specify a security callback function.
    status =
    RpcServerRegisterIfEx(_IObjectExporter_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          NULL);

    ASSERT(status == RPC_S_OK);
    if (!CreateWellKnownSid(WinServiceSid, NULL, gSidService, &SidSize)) 
    {
       status = GetLastError();
    }
    return(status);
}


NTSTATUS ConnectToLsa()
{
    NTSTATUS Status ;
    STRING LogonProcess ;
    ULONG Mode ;
    
    RtlInitString( &LogonProcess, "DCOMSCM");
    ASSERT(!gLSAHandle);
    Status = LsaRegisterLogonProcess( &LogonProcess,
                                      &gLSAHandle,
                                      &Mode );
    ASSERT(NT_SUCCESS(Status));
    ASSERT(gLSAHandle);
    return Status;
}

BOOL GetDefaultDomainName()
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;
    PUNICODE_STRING             pDomain;
    
    ASSERT(gpwszDefaultDomainName);
    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor
    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle
    if( !NT_SUCCESS( NtStatus ) )
    {
        return(FALSE);
    }
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );
    LsaClose(LsaPolicyHandle);
    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }
    CopyMemory( gpwszDefaultDomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );
    gpwszDefaultDomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';
    LsaFreeMemory( (PVOID)DomainInfo );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\or.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    or.h

Abstract:

    General include file for C things the OR.  This file is pre-compiled.

Author:

    Mario Goertzel    [mariogo]       Feb-10-95

Revision History:

--*/

#ifndef __OR_H
#define __OR_H

#include <dcomss.h>
#include <rc4.h>
#include <randlib.h>
#include <crypt.h>

#include <stddef.h>
#include <malloc.h> // alloca
#include <limits.h>
#include <math.h>

#define SAFEALLOCA_ASSERT ASSERT
#include <alloca.h>

#include <lclor.h> // Local OR if from private\dcomidl
#include <objex.h> // Remote OR if from private\dcomidl
#include <orcb.h>  // Callback if from private\dcomidl
#include <rawodeth.h> // Raw RPC -> ORPC OID rundown interface

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT
#define CONST const

#define OrStringCompare(str1, str2, len) wcscmp((str1), (str2), (len))
#define OrStringLen(str) wcslen(str)
#define OrStringCat(str1, str2) wcscat((str1), (str2))
#define OrStringCopy(str1, str2) wcscpy((str1), (str2))
#define OrMemorySet(p, value, len) memset((p), (value), (len))
#define OrMemoryCompare(p1, p2, len) memcmp((p1), (p2), (len))
#define OrMemoryCopy(dest, src, len) memcpy((dest), (src), (len))
// OrStringSearch in or.hxx

//
// The OR uses Win32 (RPC) error codes.
//

typedef LONG ORSTATUS;

// When the OR code asigns and error it uses
// one of the following mappings:
// There are no internal error codes.

#define OR_OK               RPC_S_OK
#define OR_NOMEM            RPC_S_OUT_OF_MEMORY
#define OR_NORESOURCE       RPC_S_OUT_OF_RESOURCES
#define OR_NOACCESS         ERROR_ACCESS_DENIED
#define OR_BADOXID          OR_INVALID_OXID
#define OR_BADOID           OR_INVALID_OID
#define OR_BADSET           OR_INVALID_SET
#define OR_NOSERVER         RPC_S_SERVER_UNAVAILABLE
#define OR_BADPARAM         ERROR_INVALID_PARAMETER

// Internal codes used to indicate a special event.
#define OR_I_RETRY          0xC0210051UL
#define OR_I_NOPROTSEQ      0xC0210052UL

#define UNUSED(_x_) ((void *)(_x_))

#if DBG

#define DEBUG_MIN(a,b) (min((a),(b)))

extern int __cdecl ValidateError(
    IN ORSTATUS Status,
    IN ...);


#define VALIDATE(X) if (!ValidateError X) ASSERT(0);

#if DBG_DETAIL
#undef ASSERT
#define ASSERT( exp ) \
    if (! (exp) ) \
        { \
        DbgPrintEx(DPFLTR_DCOMSS_ID, \
                   DPFLTR_ERROR_LEVEL, \
                   "OR: Assertion failed: %s(%d) %s\n", \
                   __FILE__, \
                   __LINE__, \
                   #exp); \
        DebugBreak(); \
        }
#endif // DETAIL

#else  // DBG
#define DEBUG_MIN(a,b) (max((a),(b)))
#define VALIDATE(X)
#endif // DBG

extern DWORD ObjectExporterWorkerThread(LPVOID);
extern DWORD ObjectExporterTaskThread(LPVOID);

#ifdef __cplusplus
}
#endif

#endif // __OR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\orsvr.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    OrSvr.cxx

Abstract:

    Object resolver server side class implementations.  CServerOxid, CServerOid,
    CServerSet and CServerSetTable classes are implemented here.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-03-95    Combined many smaller .cxx files
    MarioGo     01-12-96    Locally unique IDs

--*/

#include<or.hxx>

//
// ScanForOrphanedPinnedOids
//
// This function is called from CServerOxid::ProcessRelease when
// the soxid is deregistered or the server dies.  
//
void 
ScanForOrphanedPinnedOids(CServerOxid* pDeadOxid)
{
    CListElement* pLE;
    CServerOid* pOid;
    CServerOid* pNextOid;

    ASSERT(gpServerLock->HeldExclusive());

    // Walk the list, unpinning oids which were owned by the 
    // dead soxid.
    pLE = gpServerPinnedOidList->First();
    pOid = pLE ? CServerOid::ContainingRecord2(pLE) : NULL;
    while (pOid)
    {
        pLE = pLE->Next();
        pNextOid = pLE ? CServerOid::ContainingRecord2(pLE) : NULL;

        if (pOid->GetOxid() == pDeadOxid)
        {
            // This will remove it from the pinned list
            pOid->SetPinned(FALSE);
        }

        pOid = pNextOid;
    }

    ASSERT(gpServerLock->HeldExclusive());

    return;
}


//
// CServerOid methods
//

void
CServerOid::Reference()
{
    ASSERT(gpServerLock->HeldExclusive());

    BOOL fRemove = (this->References() == 0);

    // We may remove something from a PList more then once; this won't
    // hurt anything.  fRemove is used to avoid trying to remove it more
    // often then necessary without taking lock.

    this->CIdTableElement::Reference();

    if (fRemove)
    {
        CPListElement * t = Remove();
        ASSERT(t == &this->_plist || t == 0);
    }
}

DWORD
CServerOid::Release()
{
    ASSERT(gpServerLock->HeldExclusive());

    DWORD c = this->CReferencedObject::Dereference();

    if (0 == c)
    {
        // If another thread is already running this down it
        // means we got referenced and released during the rundown
        // callback.  That thread will figure out what to do.

        if (IsRunningDown())
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Oid running down in release: %p\n",
                       this));
        }
        else if (IsFreed() || this->_pOxid->IsRunning() == FALSE)
        {
            // Server freed this OID already; no need to run it down
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: OID %p freed by server so not rundown\n",
                       this));

            SetRundown(TRUE);
            delete this;
        }
        else
        {
            // All serverset (or pinned) references have been released. Put 
            // ourselves into the oid plist so we can be rundown.
            ASSERT(!IsPinned());       
            Insert();
        }
    }

    // this pointer maybe invalid.
    return(c);
}

CServerOid::~CServerOid()
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_pOxid);
    ASSERT(_fRunningDown);
    ASSERT(!IsPinned());

    _pOxid->Release();

  	gpServerOidTable->Remove(this);
}

void
CServerOid::KeepAlive()
// A client has removed this oid from its set.  This keeps
// the oid alive for another timeout period.
{
    ASSERT(gpServerLock->HeldExclusive());

    if (IsRunningDown() == FALSE && References() == 0)
        {
        // It's in the rundown list, move it to the end.
        CPListElement *pT = Remove();
        ASSERT(pT == &this->_plist);
        Insert();
        }
}

void 
CServerOid::SetPinned(BOOL fPinned)
{
    ASSERT(gpServerLock->HeldExclusive());
    
    // Assert that this is a state switch.
    ASSERT(_fPinned ? !fPinned : fPinned);

    // Set new state
    _fPinned = fPinned;

    // When we are pinned, we take an extra reference to avoid further 
    // rundown attempts.  When unpinned, we remove the reference.
    if (_fPinned)
    {
        this->Reference();

        // Now we should not be in any list
        ASSERT(_list.NotInList());
        ASSERT(_plist.NotInList());
        gpServerPinnedOidList->Insert(&_list);
    }
    else
    {
        // We should be in the gpServerPinnedOidList list, but not the plist
        ASSERT(_list.InList());
        ASSERT(_plist.NotInList());
        gpServerPinnedOidList->Remove(&_list);

        // This Release call may put us in the oidplist
        this->Release();
    }

    ASSERT(gpServerLock->HeldExclusive());

    return;
}


//
// CServerOidPList method
//
CServerOid *
CServerOidPList::RemoveEligibleOidWithMatchingOxid(
    IN CTime &when,
    IN CServerOxid* pOxid
    )
{
    CPListElement *ple;
    CServerOid *poid;

    ASSERT(pOxid->OkayForMoreRundownCalls());
	
    CMutexLock lock(&this->_lock);

    ple = (CPListElement *)CPList::First();

    // Look thru the list.  Stop when we see an oid whose
    // timeout has not yet expired, or when we find an expired
    // oid which "matches" the caller-supplied oid.
    while ((ple != NULL) && (*ple->GetTimeout() < when))
    {
        poid = CServerOid::ContainingRecord(ple);

        if (poid->GetOxid() == pOxid)
        {
            Remove(ple);
            return(poid);
        }

        ple = ple->Next();
    }
    
    return(0);
}


/*
    Routine Desciption

    This function looks for the next "eligible" oid
    in the list.  An "eligible" oid is defined as 
    1) having a timeout older than 'when'; and 
    2) belonging to an oxid which can handle additional
    rundown calls.
    
*/
CServerOid*
CServerOidPList::RemoveEligibleOid(
		IN CTime& when)
{
    CPListElement *ple;
    CServerOid *poid;

    CMutexLock lock(&this->_lock);

    ple = (CPListElement *)CPList::First();

    // Look thru the list.  Stop when we see an oid whose
    // timeout has not yet expired, or when we find an expired
    // oid whose oxid can accept another rundown call
    while ((ple != NULL) && (*ple->GetTimeout() < when))
    {
        poid = CServerOid::ContainingRecord(ple);

        if (poid->GetOxid()->OkayForMoreRundownCalls())
        {
            Remove(ple);
            return(poid);
        }

        ple = ple->Next();
    }

    return(0);
}


//
// CServerOidPList method
//
void
CServerOidPList::ResetAllOidTimeouts()
/*++

Routine Desciption

    Resets the timeout of all oids currently in the
    list to (now + _timeout)(ie, as if all oids had been
    inserted into the list just this instant).   No 
    ordering changes are made among the list elements.

Arguments:

    none

Return Value:

    void

--*/
{
    CPListElement* ple = NULL;
    CServerOid* poid = NULL;
    CTime newtimeout;
	
    CMutexLock lock(&this->_lock);

    newtimeout.SetNow();
    newtimeout += _timeout;

    ple = (CPListElement *)CPList::First();

    while (ple != NULL)
    {
        poid = CServerOid::ContainingRecord(ple);

        poid->_plist.SetTimeout(newtimeout);

        ple = ple->Next();
    }

    return;
}


BOOL
CServerOidPList::AreThereAnyEligibleOidsLyingAround(CTime& when, CServerOxid* pOxid)
/*++

Routine Desciption

    Searches the list to see if there are any oids from the specified soxid
    that are ready to be rundown.
    
Arguments:

    when - the timeout to match against
    pOxid - the server oxid from which we should match oids from

Return Value:

    TRUE - there is at least one oid from the specified server oxid which is ready
        to be rundown

    FALSE - there are no oids form the specified soxid ready to be rundown
    
--*/
{
    CPListElement *ple;
    CServerOid *poid;

    CMutexLock lock(&this->_lock);

    ple = (CPListElement *)CPList::First();

    // Look thru the list.  Stop when we see an oid whose
    // timeout has not yet expired, or we see an expired oid
    // from the specified soxid
    while ((ple != NULL) && (*ple->GetTimeout() < when))
    {
        poid = CServerOid::ContainingRecord(ple);

        if (poid->GetOxid() == pOxid)
        {
            // aha, found a winner.
            return TRUE;
        }

        ple = ple->Next();
    }

    // did not find any matching oids for the specified criteria
    return FALSE;
}



//
// CServerOxid methods
//

void
CServerOxid::ProcessRelease()
/*++

Routine Desciption

    The server process owning this OXID has either died
    or deregistered this oxid.  Releases the oxid and
    nulls the pProcess pointer.

Arguments:

    n/a

Return Value:

    n/a

--*/
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_pProcess);
    _fRunning = FALSE;

    ScanForOrphanedPinnedOids(this);

    Release();
    // This pointer may now be invalid, _pProcess pointer maybe invalid.
}

CServerOxid::~CServerOxid(void)
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_pProcess);
    ASSERT(!IsRunning()); // implies that the oxid has been removed from the table
    ASSERT(_dwRundownCallsInProgress == 0);
    if (_hRpcRundownHandle)
    {
        ASSERT(0 && "Still have binding handle despite no outstanding calls");
        RpcBindingFree(&_hRpcRundownHandle);
    }
    _pProcess->Release();
}

ORSTATUS
CServerOxid::GetInfo(
    OUT OXID_INFO *poxidInfo,
    IN  BOOL    fLocal
    )
// Server lock held shared.
{
    ORSTATUS status;
    DUALSTRINGARRAY *psa;

    if (!IsRunning())
        {
        // Server crashed, info is not needed.
        return(OR_NOSERVER);
        }

    if (fLocal)
        {
        psa = _pProcess->GetLocalBindings();
        }
    else
        {
        psa = _pProcess->GetRemoteBindings();
        }

    if (!psa)
        {
        return(OR_NOMEM);
        }

    // copy the data
    memcpy(poxidInfo, &_info, sizeof(_info));
    poxidInfo->psa = psa;

    return(OR_OK);
}

void
CServerOxid::RundownOids(ULONG cOids,
                         CServerOid* aOids[])
// Note: Returns without the server lock held.
{
    RPC_STATUS status = RPC_S_OK;

    ASSERT(cOids > 0);
    ASSERT(cOids <= MAX_OID_RUNDOWNS_PER_CALL);
    ASSERT(aOids);

    ASSERT(gpServerLock->HeldExclusive());

    // We only issue the rundown call if a) we're still running
    // and b) don't already have pending the maximum # of outstanding
    // rundown calls.

    // We check that we don't have too many calls outstanding, but this
    // should never actually happen since oids are not pulled from the 
    // rundown list if this is not true.
    ASSERT(OkayForMoreRundownCalls());
    
    if (IsRunning() && (OkayForMoreRundownCalls()))
    {
		// Make sure we have an appropriately configured binding handle
        if (!_hRpcRundownHandle)
        {
            status = EnsureRundownHandle();
        }

        if (status == RPC_S_OK)
        {
            ASSERT(_hRpcRundownHandle);

            // Note: The server lock is released during the callback.
            // Since the OID hasn't rundown yet, it will keep a reference
            // to this OXID which in turn keeps the process object alive.        
            
            // Ask our process object to issue an async call to try
            // to rundown the specified oids.  If call was sent ok,
            // return.   Otherwise fall thru and cleanup below.
            _dwRundownCallsInProgress++;

            status = _pProcess->RundownOids(_hRpcRundownHandle,
                                            this,
                                            cOids,
                                            aOids);

            ASSERT(!gpServerLock->HeldExclusive());

            if (status == RPC_S_OK)
            {
                return;
            }
            else
            {
                // Re-take the lock
                gpServerLock->LockExclusive();

                // The call is not outstanding anymore
                _dwRundownCallsInProgress--;
            }                
        }		
    }

    ASSERT(!IsRunning() || (status != RPC_S_OK));
    ASSERT(gpServerLock->HeldExclusive());

    BYTE aRundownStatus[MAX_OID_RUNDOWNS_PER_CALL];

    // If server died or apartment was unregistered, okay to run all
    // oids down.  Otherwise we make the oids wait another timeout
    // period before we try again.
    for (ULONG i = 0; i < cOids; i++)
    {
        aRundownStatus[i] = IsRunning() ? ORS_DONTRUNDOWN : ORS_OK_TO_RUNDOWN;
    }

    // Call the notify function whih will do appropriate
    // cleanup on the oids
    ProcessRundownResultsInternal(FALSE, cOids, aOids, aRundownStatus);

    ASSERT(!gpServerLock->HeldExclusive());
}


void 
CServerOxid::ProcessRundownResults(ULONG cOids, 
                                   CServerOid* aOids[], 
                                   BYTE aRundownStatus[])
/*++

Routine Desciption

    Takes the appropriate action based on the result of trying
    to rundown one or more oids.

Arguments:

    cOids -- # of oids in aOids

    aOids -- array of CServerOid*'s that we tried to rundown

    aRundownStatus -- array of status values from the 
        OID_RUNDOWN_STATUS enumeration.

Return Value:

    void

--*/
{
    ProcessRundownResultsInternal(TRUE,
                                  cOids,
                                  aOids,
                                  aRundownStatus);

    return;
}

void 
CServerOxid::ProcessRundownResultsInternal(BOOL fAsyncReturn,
                                       ULONG cOids, 
                                       CServerOid* aOids[], 
                                       BYTE aRundownStatus[])
/*++

Routine Desciption

    Takes the appropriate action based on the result of trying
    to rundown one or more oids.

    Caller must have gpServerLock exclusive when calling.  Function
    returns with gpServerLock released.

Arguments:
	
    fAsyncReturn -- TRUE if we are processing these results in response
        to a async rundown call returning, FALSE otherwise.

    cOids -- # of oids in aOids

    aOids -- array of CServerOid*'s that we tried to rundown

    aRundownStatus -- array of status values from the 
        OID_RUNDOWN_STATUS enumeration.

Return Value:

    void

--*/
{
    ULONG i;

    ASSERT(gpServerLock->HeldExclusive());

    // Ensure a reference exists for the duration of this function.
    // If this is an async return, then we know the async code is
    // keeping it warm for us.
    if (!fAsyncReturn)
    {
        Reference();
    }

    for(i = 0; i < cOids; i++)
    {
        CServerOid* pOid;

        pOid = aOids[i];
        ASSERT(pOid);
        ASSERT(this == pOid->GetOxid());

        if (aRundownStatus[i] == ORS_OID_PINNED)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Randown OID %p but the client says it's pinned\n",
                       pOid));

            // Server says that particular oid is "pinned", ie cannot
            // be rundown until we are told otherwise.  Note that we
            // check for this before we check # of references -- the
            // ORS_OID_PINNED status takes precedence.
            pOid->SetPinned(TRUE);
            pOid->SetRundown(FALSE);
        }
        else if (pOid->References() != 0)
        {
            // Added to a set while running down and still referenced.
            pOid->SetRundown(FALSE);
        }
        else if (aRundownStatus[i] == ORS_OK_TO_RUNDOWN)
        {
            delete pOid;
        }
        else
        {
            ASSERT(aRundownStatus[i] == ORS_DONTRUNDOWN);

            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Randown OID %p but the client kept it alive\n",
                       pOid));

            // Client want us to keep it alive and is still running.
            pOid->SetRundown(FALSE);
            pOid->Insert();
        }
    }

    ASSERT(gpServerLock->HeldExclusive());
	
    if (fAsyncReturn)
    {
        // One less async rundown call is now outstanding
        ASSERT(_dwRundownCallsInProgress > 0);
        ASSERT(_dwRundownCallsInProgress <= MAX_SIMULTANEOUS_RUNDOWNS_PER_APT);
        _dwRundownCallsInProgress--;

        // We no longer need gpServerLock after this point
        gpServerLock->UnlockExclusive();
        ASSERT(!gpServerLock->HeldExclusive());
	
        //
        // There may be other expired oids belonging to this
        // oxid; go check for that now, and try to run them down
        // if so.

        //
        // We used to call RundownOidsHelper directly from this point;
        // that function could then potentially make another async rpc
        // rundown call back to the server process.  Unfortunately, RPC
        // sometimes treats async LRPC calls as synchronous, and when
        // that happens it can cause deadlocks (NT 749995).  RPC will fix
        // this in Longhorn.  For now we will workaround it by initiating 
        // the new rundown call from a separate thread.
        //
        CTime now;
        if (gpServerOidPList->AreThereAnyEligibleOidsLyingAround(now, this))
        {
            //
            // Take a reference on ourself. This will be released either
            // at the end of CServerOxid::RundownHelperThreadProc, or below
            // if QueueUserWorkItem returns an error.
            Reference();
            if (!QueueUserWorkItem(CServerOxid::RundownHelperThreadProc, this, 0))
            {
                // Oops, error occurred.  This is not fatal (the worker threads
                // will retry later anyway).  Release the reference we took
                // above.
                Release();
            }
        }
    }

    // Try to clean up the rpc binding handle.  In the case where
    // we are running down a large # of objects (hence we have a
    // "chained" series of rundown calls happening), the binding
    // handle will remain cached until the last call finishes.
    //
    // jsimmons 12/04/02 - there is a race here now.  Depending on how 
    // fast an above call to RundownHelperThreadProc is processed on a 
    // worker thread, we may end up destroying and re-creating the rundown
    // handle more often than necessary.  Doesn't hurt anything, it's just
    // wasted work.  I don't want to fix this so late in the game.
    //  
    ReleaseRundownHandle();

    if (!fAsyncReturn)
    {
        // Release the safety reference we took above.  (NOTE:
        // this might be the last reference!)
        Release();
        
        // gpServerLock gets released above in the async return case, otherwise
        // in the non-async return case we need to do it here
        gpServerLock->UnlockExclusive();
    }

    return;
}


DWORD WINAPI CServerOxid::RundownHelperThreadProc(LPVOID pv)
/*++

Routine Desciption

    NT thread pool entry point used for doing extra rundown attempts.

Arguments:

    pv - pointer to the CServerOxid which initiated this rundown attempt,
       we own one reference on this object that needs to be released.

Return Value:

    0 - processing completed

--*/
{
    ASSERT(pv);
    CServerOxid* pThis = (CServerOxid*)pv;

    //
    // Attempt to do an extra rundown attempt.  
    //
    // RundownOidsHelper expects that gpServerLock is held when 
    // called, so we better take it now:
    //
    gpServerLock->LockExclusive();

    // Only call RundownOidsHelper if we are okay to accept more
    // rundown calls.   It is possible that we were okay when this 
    // piece of work was requested, but before we could run one of 
    // the normal worker threads picked up the soxid and issued
    // another rundown.
    if (pThis->OkayForMoreRundownCalls())
    {
        CTime now;
        (void)RundownOidsHelper(&now, pThis);

        //
        // However, RundownOidsHelper returns with the lock released, so
        // we assert that here.
        //
        ASSERT(!gpServerLock->HeldExclusive());

        // Retake gpServerLock for the Release call below	
        gpServerLock->LockExclusive();
    }

    // Release the extra reference on the soxid that the caller 
    // gave us; must hold gpServerLock across this in case this is
    // the last release.
    ASSERT(gpServerLock->HeldExclusive());
    pThis->Release();
    gpServerLock->UnlockExclusive();
	
    return 0;
}


RPC_STATUS 
CServerOxid::EnsureRundownHandle()
/*++

Routine Desciption

    Checks to see if we already have an _hRpcRundownHandle created,
    and if not, creates one.

Arguments:
	
    void

Return Value:

    RPC_S_OK -- _hRpcRundownHandle is present and configured correctly
    other -- error occurred and _hRpcRundownHandle is NULL

--*/
{
    RPC_STATUS status = RPC_S_OK;
    
    ASSERT(gpServerLock->HeldExclusive());    

    if (!_hRpcRundownHandle)
    {
        ASSERT(_dwRundownCallsInProgress == 0);
        
        RPC_BINDING_HANDLE hRpc = NULL;

        status = RPC_S_OUT_OF_RESOURCES;
        hRpc = _pProcess->GetBindingHandle();
        if (hRpc)
        {
            IPID ipidUnk = GetIPID();
            status = RpcBindingSetObject(hRpc, &ipidUnk);
            if (status == RPC_S_OK)
            {
                _hRpcRundownHandle = hRpc;
            }
            else
            {
                RpcBindingFree(&hRpc);
            }
        }
    }

    return status;
}



void 
CServerOxid::ReleaseRundownHandle()
/*++

Routine Desciption

    Checks to see if we should release our cached RPC
    rundown binding handle.  

Arguments:
    
    void

Return Value:

    void

--*/
{
    RPC_BINDING_HANDLE hRpcToFree = NULL;

    // May be looking at _dwRundownCallsInProgress outside
    // of the lock here.
    if ((_dwRundownCallsInProgress == 0) && _hRpcRundownHandle)
    {
        BOOL fTookLock = FALSE;
        if (!gpServerLock->HeldExclusive())
        {            
            gpServerLock->LockExclusive();
            fTookLock = TRUE;
        }

        if (_dwRundownCallsInProgress == 0)
        {
            // Now it's really okay to free it, if it's
            // still there.
            hRpcToFree = _hRpcRundownHandle;
            _hRpcRundownHandle = NULL;
        }

        if (fTookLock)
        {
            gpServerLock->UnlockExclusive();
        }
    }

    if (hRpcToFree)
    {
        RPC_STATUS status = RpcBindingFree(&hRpcToFree);
        ASSERT(status == RPC_S_OK);
    }

    return;
}


ORSTATUS
CServerOxid::GetRemoteInfo(
    OUT OXID_INFO *pInfo,
    IN  USHORT    cClientProtseqs,
    IN  USHORT    aClientProtseqs[]
    )
// Server lock held shared.
{
    ORSTATUS status;
    USHORT   protseq;

    status = GetInfo(pInfo, FALSE);

    if (OR_OK == status)
        {
        protseq = FindMatchingProtseq(cClientProtseqs,
                                      aClientProtseqs,
                                      pInfo->psa->aStringArray
                                      );
        if (0 == protseq)
            {
            MIDL_user_free(pInfo->psa);
            pInfo->psa = 0;
            status = OR_I_NOPROTSEQ;
            }
        }

    return(status);

}

ORSTATUS
CServerOxid::LazyUseProtseq(
    IN  USHORT    cClientProtseqs,
    IN  USHORT    *aClientProtseqs
    )
// Server lock held shared, returns with the server lock exclusive.
// Note: It is possible, that after this call the OXID has been deleted.
{
    ORSTATUS status;

    if (IsRunning())
        {
        // Keep this OXID process alive while making the callback. If the process
        // crashes and this OXID has no OIDs it could be released by everybody
        // else.  This keeps the OXID and process alive until we finish.

        this->Reference();

        gpServerLock->UnlockShared();

        status = _pProcess->UseProtseqIfNeeded(cClientProtseqs, aClientProtseqs);

        gpServerLock->LockExclusive();

        this->Release();
        }
    else
        {
        gpServerLock->ConvertToExclusive();
        status = OR_NOSERVER;
        }

    // Note: The this poiner maybe BAD now.

    return(status);
}


//
// CServerSet methods.
//

ORSTATUS
CServerSet::AddObject(OID &oid)
{
    ORSTATUS status = OR_OK;
    CServerOid *pOid;

    ASSERT(gpServerLock->HeldExclusive());

    CIdKey key(oid);

    pOid = (CServerOid *)gpServerOidTable->Lookup(key);

    if (pOid)
    {
        ASSERT(_blistOids.Member(pOid) == FALSE);
        
        // Don't add duplicate IDs to the set
        if (_blistOids.Member(pOid) == FALSE) 
        {
           status = _blistOids.Insert(pOid);
           if (status == OR_OK)
           {
               pOid->Reference();
           }
        }
    }
    else
        status = OR_BADOID;

    VALIDATE((status, OR_BADOID, OR_NOMEM, 0));

    return(status);
}


void
CServerSet::RemoveObject(OID &oid)
{
    CServerOid *pOid;

    ASSERT(gpServerLock->HeldExclusive());

    CIdKey key(oid);

    pOid = (CServerOid *)gpServerOidTable->Lookup(key);

    if (pOid)
        {
        CServerOid *pOidTmp = (CServerOid *)_blistOids.Remove(pOid);

        if (pOid == pOidTmp)
            {
            pOid->Release();
            }
        else
            {
            // Set doesn't contain the specified oid, treat this as an
            // add and delete by keeping the oid alive for another timeout
            // period.

            ASSERT(pOidTmp == 0);

            pOid->KeepAlive();
            }
        }
}

BOOL
CServerSet::ValidateObjects(BOOL fShared)
// fShared - Indicates if the server lock is held
//           shared (TRUE) or exclusive (FALSE).
//
// Return  - TRUE the lock is still shared, false
//           the lock is held exclusive.
{
    CServerOid *pOid;
    CBListIterator oids(&_blistOids);

    // Since we own a reference on all the Oids they must still exist.
    // No need to lock exclusive until we find something to delete.

    while(pOid = (CServerOid *)oids.Next())
        {
        if (!pOid->IsRunning())
            {
            if (fShared)
                {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Cleanup in set (%p), removing dead oids.\n",
                           this,
                           pOid));

                gpServerLock->ConvertToExclusive();
                fShared = FALSE;
                oids.Reset(&_blistOids);
                continue;
                }

            CServerOid *pOidTmp = (CServerOid *)_blistOids.Remove(pOid);

            ASSERT(pOidTmp == pOid);
            ASSERT(pOid->IsRunning() == FALSE);

            pOid->Release();
            }
        }

    return(fShared);
}

BOOL
CServerSet::Rundown()
// Rundown the whole set.
{
    CServerOid *poid;
    CTime now;

    ASSERT(gpServerLock->HeldExclusive());

    if (_timeout > now)
        {
        // Don't rundown if we've received a late ping.
        return(FALSE);
        }

    if (_fLocal && _blistOids.Size() != 0)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Premature rundown of local set ignored.\n"));

        return(FALSE);
        }

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: Set %p's client appears to have died\n",
               this));

    CBListIterator oids(&_blistOids);

    while(poid = (CServerOid *)oids.Next())
        {
        poid->Release();
        }

    return(TRUE);
}


//
// CServerSetTable implementation
//

CServerSet *
CServerSetTable::Allocate(
    IN USHORT sequence,
    IN PSID   psid,
    IN BOOL   fLocal,
    OUT ID   &setid
    )
/*++

Routine Description:

    Allocates a new CServerSet and returns the setid for the new set.

Arguments:

    sequence - initial sequence number for the new set.

    psid - pointer to an NT SID structure for the new set.

    fLocal - TRUE : set is for the local client,
             FALSE : set is for a remote client

    setid - the setid of the set returned.  Unchanged if return value 0.

Return Value:

    0 - Unable to allocate a resource

    non-zero - A pointer to the newly created set.

--*/
{
    ASSERT(gpServerLock->HeldExclusive());
    UINT i;
    LARGE_INTEGER li;

    ASSERT(_cAllocated <= _cMax);

    if (_cAllocated == _cMax)
        {
        // Table is full, realloc

        // Do this first, if it succeeds great even if
        // a later allocation fails. If not, fail now.

        IndexElement *pNew = new IndexElement[_cMax * 2];

        if (!pNew)
            {
            return(0);
            }

        for (i = 0; i < _cMax; i++)
            {
            pNew[i] = _pElements[i];
            }

        for(i = _cMax; i < _cMax*2; i++)
            {
            if FAILED(gRNG.GenerateRandomNumber(&(pNew[i]._sequence), sizeof(pNew[i]._sequence)))
               {
                  delete []pNew;
                  return 0;
               }
            pNew[i]._pSet = 0;
            }

        delete []_pElements;
        _pElements = pNew;
        _cMax *= 2;
        }

    CServerSet *pSet = new CServerSet(sequence, psid, fLocal);

    if (0 == pSet)
        {
        return(0);
        }

    ASSERT(_pElements);
    ASSERT(_cMax > _cAllocated);

    for(i = _iFirstFree; i < _cMax; i++)
        {
        if (0 == _pElements[i]._pSet)
            {
            _pElements[i]._sequence++;
            _pElements[i]._pSet = pSet;
            li.HighPart = i + 1;
            li.LowPart = _pElements[i]._sequence;
            setid = li.QuadPart;
            _iFirstFree = i + 1;
            _cAllocated++;
            return pSet;
            }
        }

    ASSERT(0);
    return(0);
}


CServerSet *
CServerSetTable::Lookup(
    IN ID setid
    )
/*++

Routine Description:

    Looks up an a set given the sets ID.

    Server lock held shared.

Arguments:

    setid - the ID of the set to lookup

Return Value:

    0 - set doesn't exist

    non-zero - the set.

--*/
{
    LARGE_INTEGER li;
    li.QuadPart = setid;
    LONG i = li.HighPart - 1;
    DWORD sequence = (DWORD)(setid & ~((ID)0));

    if (i >= 0 && (DWORD) i < _cMax)
        {
        if (_pElements[i]._sequence == sequence)
            {
            // May still be null if it is free and has not yet be reused.
            return(_pElements[i]._pSet);
            }
        }
    return(0);
}


ID
CServerSetTable::CheckForRundowns(
    )
/*++

Routine Description:

    Used by ping and worker threads to monitor for sets that should
    be rundown.  It is called with the server lock held shared.

Arguments:

    None

Return Value:

    0 - Didn't find a set to rundown

    non-zero - ID of a set which may need to be rundown.

--*/
{
    UINT i, end;
    LARGE_INTEGER id;
    id.QuadPart = 0;
    ASSERT(_iRundown < _cMax);

    if (_cAllocated == 0)
        {
        return(0);
        }

    i = _iRundown;
    do
        {
        ASSERT(_cAllocated);  // loop assumes one or more allocated elements.
        i = (i + 1) % _cMax;
        }
    while(0 == _pElements[i]._pSet);

    ASSERT(_pElements[i]._pSet);

    if (_pElements[i]._pSet->ShouldRundown())
        {
        id.HighPart = i + 1;
        id.LowPart = _pElements[i]._sequence;
        }

    _iRundown = i;

    return(id.QuadPart);
}


BOOL
CServerSetTable::RundownSetIfNeeded(
    IN ID setid
    )
/*++

Routine Description:

    Rundowns down a set (or sets) if needed. Called by
    ping and worker threads.  Server lock held exclusive.

Arguments:

    setid - An ID previously returned from CheckForRundowns.

Return Value:

    TRUE - A set was actually rundown

    FALSE - No sets actually rundown

--*/
{
    ASSERT(gpServerLock->HeldExclusive());

    if (gPowerState != PWR_RUNNING)
    {
        // Machine is or was about to be suspended.  We don't want 
        // to rundown any sets in this state.
        return(FALSE);
    }

    CServerSet *pSet = Lookup(setid);

    if (0 == pSet || FALSE == pSet->ShouldRundown())
        {
        // Set already randown or has been pinged in the meantime.
        return(FALSE);
        }

    // PERF REVIEW this function has the option of running multiple sets,
    // saving the worker thread from taking and leaving the lock many times
    // when a bunch of sets all rundown.  This feature is not used.

    LARGE_INTEGER li;
    li.QuadPart = setid;

    UINT i = li.HighPart - 1;

     if (pSet->Rundown())
        {
        delete pSet;
        _cAllocated--;
        if (i < _iFirstFree) _iFirstFree = i;
        _pElements[i]._pSet = 0;
        return(TRUE);
        }

    return(FALSE);
}


void 
CServerSetTable::PingAllSets()
/*++

Routine Description:

    Performs a ping of all sets currently in the table.

Arguments:

    none

Return Value:

    void

--*/
{
    ASSERT(gpServerLock->HeldExclusive());

    ULONG i;
    for(i = 0; i < _cMax; i++)
    {
        if (_pElements[i]._pSet)
        {
            _pElements[i]._pSet->Ping(FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\plist.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Plist.cxx

Abstract:

    Implementation of the CPList class.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-24-95    Bits 'n pieces

--*/

#include<or.hxx>

void
CPList::Insert(CPListElement *p)
{
    CMutexLock lock(&this->_lock);
    CTime time;

    time += _timeout;

    p->SetTimeout(time);

    this->CList::Insert(p);
}

BOOL
CPList::PeekMin(CTime &timeout)
    // inline?
{
    CTime *pT;
    CMutexLock lock(&this->_lock);

    CPListElement *first = (CPListElement *)this->First();

    if (first && (pT = first->GetTimeout()))
        {
        timeout = *pT;
        return(TRUE);
        }

    return(FALSE);
}

CPListElement *
CPList::Remove(CPListElement *p)
// It must be safe to remove an element not actually in a list.
{
    CMutexLock lock(&this->_lock);

    return( (CPListElement *)this->CList::Remove(p) );
}

CListElement *
CPList::MaybeRemoveMin(
    IN CTime &when
    )
{
    CMutexLock lock(&this->_lock);

    CPListElement *first = (CPListElement *)this->First();

    if (first && *first->GetTimeout() < when)
        {
        return(Remove(first));
        }

    return(0);
}

void
CPList::Reset(
    IN CPListElement *p
    )
{
    CMutexLock lock(&this->_lock);

    ASSERT(p);

    if (p->Next() == 0 && p->Previous() == 0 && First() != p)
        {
        ASSERT(Last() != p);
        return;
        }

    Remove(p);

    // Update timeout
    CTime now;
    now += _timeout;
    p->SetTimeout(now);

    Insert(p);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\orclnt.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    OrClnt.cxx

Abstract:

    Object resolver client side class implementations.  CClientOxid, CClientOid,
    CClientSet classes are implemented here.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-03-95    Combined many smaller .cxx files
    MarioGo     01-05-96    Locally unique IDs

--*/

#include<or.hxx>

extern
error_status_t
ComplexPingInternal(
            IN  handle_t hRpc,
            IN  SETID   *pSetId,
            IN  USHORT   SequenceNum,
            IN  ULONG    cAddToSet,
            IN  ULONG    cDelFromSet,
            IN  OID      AddToSet[],
            IN  OID      DelFromSet[],
            OUT USHORT  *pPingBackoffFactor
            );

class CTestBindingPPing : public CParallelPing
{
public:
    CTestBindingPPing(WCHAR *pBindings) :
        _pBindings(pBindings)
        {}


    BOOL NextCall(PROTSEQINFO *pProtseqInfo)
    {
        if (*_pBindings)
        {
            pProtseqInfo->pvUserInfo = _pBindings;
            pProtseqInfo->hRpc     = TestBindingGetHandle(_pBindings);
            _pBindings =  OrStringSearch(_pBindings, 0) + 1;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void ReleaseCall(PROTSEQINFO *pProtseqInfo)
    {
        if (pProtseqInfo->hRpc)
        {
            RpcBindingFree(&pProtseqInfo->hRpc);
        }
    }
private:
    WCHAR *    _pBindings;
};

//
// CClientOid methods
//

CClientOid::~CClientOid()
{
    ASSERT(gpClientLock->HeldExclusive());
    ASSERT(!In());
    ASSERT(Out());
    ASSERT(_pOxid);
    ASSERT(_pSet);

    _pOxid->Release();
    _pSet->Release();

    gpClientOidTable->Remove(this);
}

//
// CClientOxid methods.
//

ORSTATUS
CClientOxid::GetInfo(
                    IN  BOOL fApartment,
                    OUT OXID_INFO *pInfo
                    )
/*++

Routine Description:

    Returns the OXID_INFO structure for this oxid.

    The gpClientLock is held and there should also be
    a reference held by the calling routine upon entry to
    this method.

Arguments:

    fApartment - TRUE iif the client is apartment model.

    pInfo - Will contain the standard info, a single _expanded_
        string binding and complete security bindings.
        MIDL_user_allocated.

Return Value:

    OR_NOMEM - Unable to allocate a parameter.

    OR_OK - Normally.

--*/
{
    USHORT   protseq;
    PWSTR    pwstrT;
    ORSTATUS status = OR_OK;
    DUALSTRINGARRAY *psa;
    BOOL     bNoEndpoint = FALSE;

    ASSERT(dsaValid(_oxidInfo.psa));


    if (0 == _wProtseq)
    {
        // Local server

        protseq = ID_LPC;

        pwstrT = FindMatchingProtseq(protseq, _oxidInfo.psa->aStringArray);

        ASSERT(pwstrT != 0);

        if (0 != pwstrT)
        {
            psa =
            GetStringBinding(pwstrT,
                             _oxidInfo.psa->aStringArray + _oxidInfo.psa->wSecurityOffset);

            if (0 == psa)
            {
                status = OR_NOMEM;
            }
        }
        else
        {
            status = OR_BADOXID;
        }
    }
    else
    {
        // Remote server, find a string binding to use.

        psa = 0;
        PWSTR pwstrBinding = 0;

        // First, check if there is a known good binding to use.

        if (_iStringBinding != 0xFFFF)
        {
            pwstrBinding = &_oxidInfo.psa->aStringArray[_iStringBinding];
        }
        else
        {
            pwstrT = NULL;
            if (_pMachineName)
            {
                pwstrT = FindMatchingProtseq(_pMachineName,
                                             _wProtseq,
                                             _oxidInfo.psa->aStringArray);
            }

            if (pwstrT)
            {
                pwstrBinding = pwstrT;
                _iStringBinding = (USHORT)(pwstrT - _oxidInfo.psa->aStringArray);
            }
            else
            {
                // no stringbinding for the Protseq and machine name we succeeded on
                // previously.  Ping all these guys in parallel and see if any work
                CTestBindingPPing ping(_oxidInfo.psa->aStringArray);
		RPC_STATUS rpcstatus = RPC_S_OK;
                gpClientLock->UnlockExclusive();
                for (;;)
                {
                   rpcstatus = ping.Ping();
                   if ( RPC_S_UNKNOWN_IF == rpcstatus )
                   {
                      if ( ! bNoEndpoint )
                      {
                         for ( ULONG ProtseqIndex = 0; ProtseqIndex < ping.HandleCount(); ProtseqIndex++ )
                         {
                            RPC_BINDING_HANDLE tmpBinding;
                            rpcstatus = RpcBindingCopy( ping.Info(ProtseqIndex)->hRpc, &tmpBinding);
                            if (rpcstatus != RPC_S_OK)
                               break;
                            RpcBindingFree( &(ping.Info(ProtseqIndex)->hRpc));
                            rpcstatus = RpcBindingReset(tmpBinding);
                            if (rpcstatus != RPC_S_OK)
                            {
                               RpcBindingFree(&tmpBinding);
                               break;
                            }
                            ping.Info(ProtseqIndex)->hRpc = tmpBinding;
                         }
                         if (rpcstatus == RPC_S_OK)
                         {
                            bNoEndpoint = TRUE;
                            continue;
                         }
                      }
                    }
                    break;
                }
                gpClientLock->LockExclusive();

                if (rpcstatus == RPC_S_OK)
                {
                    pwstrBinding = (WCHAR*) ping.GetWinner()->pvUserInfo;
                    _iStringBinding = (USHORT)(pwstrBinding - _oxidInfo.psa->aStringArray);
                }

                ping.Reset();
            }

        }

        if (0 != pwstrBinding)
        {
            // Found a binding
            ASSERT(pwstrBinding == &_oxidInfo.psa->aStringArray[_iStringBinding]);
            psa = GetStringBinding(pwstrBinding,
                                   _oxidInfo.psa->aStringArray + _oxidInfo.psa->wSecurityOffset);
            if (0 == psa)
            {
                status = OR_NOMEM;
            }
        }
        else
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Unable to find a binding for oxid %p (to %S)\n",
                       this,
                       _oxidInfo.psa->aStringArray + 1));

            if (status == OR_OK)
                status = OR_BADOXID;
        }
    }

    if (status == OR_OK)
    {
        // copy all the data into the OXID_INFO
        memcpy(pInfo, &_oxidInfo, sizeof(_oxidInfo));
        pInfo->psa = psa;
    }

    return(status);
}

ORSTATUS
CClientOxid::UpdateInfo(OXID_INFO *pInfo)
{
    DUALSTRINGARRAY *pdsaT;

    ASSERT(pInfo);
    ASSERT(gpClientLock->HeldExclusive());

    if (pInfo->psa)
    {
        ASSERT(dsaValid(pInfo->psa));

        pdsaT = new(sizeof(USHORT) * pInfo->psa->wNumEntries) DUALSTRINGARRAY;

        if (!pdsaT)
        {
            return(OR_NOMEM);
        }

        dsaCopy(pdsaT, pInfo->psa);

        delete _oxidInfo.psa;
    }
    else
    {
        pdsaT = _oxidInfo.psa;
    }

    // copy in the new data
    memcpy(&_oxidInfo, pInfo, sizeof(_oxidInfo));
    _oxidInfo.psa = pdsaT;

    ASSERT(dsaValid(_oxidInfo.psa));
    return(OR_OK);
}

void
CClientOxid::Reference()
/*++

Routine Description:

    As as CReferencedObject::Reference except that it knows to
    pull the oxid out of the plist when the refcount was 0.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fRemove = (this->References() == 0);

    // We may remove something from a PList more then once;
    // it won't hurt anything.  This avoids trying to remove
    // more often then necessary.

    this->CReferencedObject::Reference();

    if (fRemove)
    {
        CPListElement * t = Remove();
        ASSERT(t == &this->_plist || t == 0);
    }
}

DWORD
CClientOxid::Release()
/*++

Routine Description:

    Overrides CReferencedObject::Release since OXIDs must wait for
    a timeout period before being deleted.

Arguments:

    None

Return Value:

    0 - object fully released.

    non-zero - object nt fully released by you.

--*/

{
    ASSERT(gpClientLock->HeldExclusive());

    LONG c = CReferencedObject::Dereference();

    if (c ==  0)
    {
        Insert();
    }

    ASSERT(c >= 0);

    return(c);
}


//
// CClientSet methods
//

ORSTATUS
CClientSet::RegisterObject(CClientOid *pOid)
/*++

Routine Description:

    Adds a new oid to the set of oids owned by this set.

Arguments:

    pOid - A pointer to the OID to add to the set.  The caller gives
        his reference to this set.

Return Value:

    None

--*/

{
    ORSTATUS status;

    ASSERT(gpClientLock->HeldExclusive());

    ASSERT(_blistOids.Member(pOid) == FALSE);

    status = _blistOids.Insert(pOid);

    if (status == OR_OK)
    {
        ObjectUpdate(pOid);
        _cFailedPings = 0;
    }

    VALIDATE((status, OR_NOMEM, 0));

    return(status);
}

ORSTATUS
CClientSet::PingServer()
/*++

Routine Description:

    Performs a nice simple ping of the remote set.

Note:

    Exactly and only one thread may call this method on
    a given instance of a CClientSet at a time.

    No lock held when called.

    Overview of state transitions on a CClientOid during
    a complex ping:

    In()  Out()   Actions before ping; after ping
    FALSE FALSE   A ; C A U
    FALSE TRUE    R ; R U
    TRUE  FALSE   N ; N
    TRUE  TRUE    R ; C R U

    Before:
    A - Added to list of IDs to be added.
    N - Ignored
    R - Added to list of IDs to be removed.

    // States may change during the call.

    After:
    C - Check if ping call was successful.  If not, skip next action.
    R - If the Out() state is still TRUE, remove it.
    N - ignored
    A - Set In() state to TRUE
    U - If Out() state changed during the call, set _fChange.

    If three pings fail in a row, all Out()==TRUE OIDs are
    actually Released() and no new pings are made until ObjectUpdate()
    is called again.

Arguments:

    None

Return Value:

    OR_OK - Pinged okay

    OR_NOMEM - Resource allocation failed

    OR_I_PARTIAL_UPDATE - Pinged okay, but more pings
        are needed to fully update the remote set.

    Other - Error from RPC.

--*/
{
    ORSTATUS status;
    ULONG cAdds = 0;
    ULONG cDels = 0;
    ULONG i;
    WCHAR* pPrincipal = NULL;
    WCHAR* pMachineNameFromBindings = NULL;
    DWORD cFailedUnsecureCPings = 0;

    CToken *pToken;

    if (_fSecure)
    {
        pToken = (CToken *)Id2();
        ASSERT(pToken != 0);
        pToken->Impersonate();
    }

    if (_fChange)
    {
        USHORT wBackoffFactor;
        OID *aAdds = 0;
        OID *aDels = 0;
        CClientOid **apoidAdds;
        CClientOid **apoidDels = 0;
        CClientOid *pOid;

        gpClientLock->LockShared();

        // Since we own a shared lock, nobody can modify the contents
        // of the set or change the references on an OID in the set
        // while we do this calculation.

        ASSERT(_fChange);
        _fChange = FALSE;

        DWORD debugSize = _blistOids.Size();
        ASSERT(debugSize);

        CBListIterator oids(&_blistOids);

        while (pOid = (CClientOid *)oids.Next())
        {
            if (pOid->Out() == FALSE)
            {
                if (pOid->In() == FALSE)
                {
                    // Referenced and not in set, add it.
                    cAdds++;
                }
            }
            else
            {
                // Not referenced, remove it.
                cDels++;
            }
        }

        ASSERT(debugSize == _blistOids.Size());
        oids.Reset(&_blistOids);

        DWORD cbAlloc = (sizeof(OID) * (cAdds + cDels)) +
                        (sizeof(CClientOid*) * (cAdds + cDels));
        PVOID pvMem;
		
        // Alloc no more than 16k on the stack.
        if (cbAlloc < 0x4000)
        {
            pvMem = NULL;
            aAdds = (OID *) alloca(cbAlloc);
        }
        else
        {
            pvMem = PrivMemAlloc(cbAlloc);
            aAdds = (OID *) pvMem;
        }

        if (!aAdds)
        {
            gpClientLock->UnlockShared();
            if (_fSecure)
            {
                pToken = (CToken *)Id2();
                ASSERT(pToken != 0);
                pToken->Revert();
            }
            return OR_NOMEM;
        }


        apoidAdds = (CClientOid **) ( aAdds + cAdds);
        aDels = (OID *)( apoidAdds + cAdds);
        apoidDels = (CClientOid **)(aDels + cDels);

        DWORD debugAdds = cAdds;
        DWORD debugDels = cDels;

        cAdds = cDels = 0;

        while (pOid = (CClientOid *)oids.Next())
        {
            if (pOid->Out() == FALSE)
            {
                if (pOid->In() == FALSE)
                {
                    // Referenced and not yet added
                    aAdds[cAdds] = pOid->Id();
                    apoidAdds[cAdds] = pOid;
                    cAdds++;
                }
            }
            else
            {
                aDels[cDels] = pOid->Id();
                apoidDels[cDels] = pOid;
                cDels++;
            }
        }

        ASSERT(debugSize == _blistOids.Size());
        ASSERT(debugAdds == cAdds);
        ASSERT(debugDels == cDels);

        gpClientLock->UnlockShared();

        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: Pinging set %p on %S, (%d, %d)\n",
                   this,
                   _pMid->PrintableName(),
                   cAdds,
                   cDels));

        // Allocate a connection if needed
        if (   FALSE == _pMid->IsLocal()
               && 0 == _hServer )
        {
            _hServer = _pMid->GetBinding();


            if (!_hServer)
            {
                _iBinding = 0;
                status = OR_NOMEM;
            }
            else
            {
                if (_pMid->IsSecure())
                {
                    // set security on the binding handle.
                    _fSecure = TRUE;
 
                    RPC_SECURITY_QOS  qos;
                    
                    pMachineNameFromBindings = ExtractMachineName( _pMid->GetStringBinding() );
                    if (pMachineNameFromBindings)
                    {
                         pPrincipal = new WCHAR[lstrlenW(pMachineNameFromBindings) +
                                             (sizeof(RPCSS_SPN_PREFIX) / sizeof(WCHAR)) + 1];
                          if (pPrincipal)
                          {
                              lstrcpyW(pPrincipal, RPCSS_SPN_PREFIX);
                              lstrcatW(pPrincipal, pMachineNameFromBindings);
                          }
                          delete pMachineNameFromBindings;
                    }  
					
                    USHORT wAuthnSvc  = _pMid->GetAuthnSvc();
                    
                    qos.Version           = RPC_C_SECURITY_QOS_VERSION;
                    qos.Capabilities      = RPC_C_QOS_CAPABILITIES_DEFAULT;
                    qos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
                    qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
                    // AuthnSvc is unsigned long and 0xFFFF will get 0 extended
                    status = RpcBindingSetAuthInfoEx(_hServer,
                                                     pPrincipal,
                                                     RPC_C_AUTHN_LEVEL_CONNECT,
                                                     wAuthnSvc != 0xFFFF ? wAuthnSvc
                                                     : RPC_C_AUTHN_DEFAULT,
                                                     NULL,
                                                     0,
                                                     &qos);
                    if (status != RPC_S_OK)
                       _fSecure = FALSE;
                    delete pPrincipal;
                }
                else
                {
                    _fSecure = FALSE;
                    status = OR_OK;
                }
            }
        }
        else
        {
            status = OR_OK;
        }

        if (OR_OK == status)
        {           
            if (_pMid->IsLocal())
            {
                // For local pings, do it all in one call.
                for (;;)
                {
                    _sequence++;
                    status = ComplexPingInternal(
                                   _hServer,
                                   &_setid,
                                   _sequence,
                                   cAdds,
                                   cDels,
                                   aAdds,
                                   aDels,
                                   &wBackoffFactor
                                   );
                    if (status == OR_BADSET)
                    {
                        // Restart loop, allocating new set 
                        ASSERT(_setid);
                        _sequence = 0;
                        _setid = 0;
                        continue;
                    }
                    else if (status == OR_BADOID)
                    {
                        // This is really okay, all Dels must be deleted,
                        // and if the add failed now, it will always fail.
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Client specified unknown OID(s). %p %p %p\n",
                                   this,
                                   aAdds,
                                   apoidAdds));

                        status = OR_OK;
                    }
                    break;
                }
            }
            else
            {
                //
                // _ComplexPing is typed as taking USHORT's for the count of Adds and
                // Dels -- astoundingly there are people in the world who seem to be
                // using more object references than a USHORT can hold.  Rather than 
                // changing the protocol, we separate the adds\dels into USHRT_MAX 
                // size chunks.
                //
                // However, this is not necessary for local pings, which is why that case
                // is handled separately above.
                //
                const ULONG MAX_PING_CHUNK_SIZE = USHRT_MAX;

                ULONG cAddsTotal = 0;
                ULONG cDelsTotal = 0;                
                ULONG cCallsNeeded;
				
                cCallsNeeded = max((ULONG)ceil((double)cAdds / (double)MAX_PING_CHUNK_SIZE), 
                                   (ULONG)ceil((double)cDels / (double)MAX_PING_CHUNK_SIZE));
				
                // Loop the necessary # of times.  Certain conditions can cause us
                // re-start the loop, eg security errors, or bad set errors.
                for (i = 0; i < cCallsNeeded; i++)
                {   
                    // Figure out how many adds\dels we are doing on this
                    // iteration.  Remember that the # of adds\dels are
                    // independent of each other.
                    USHORT cAddsPerCall;
                    USHORT cDelsPerCall;
                    OID*   pAddsPerCall;
                    OID*   pDelsPerCall;

                    
                    if (cAddsTotal < cAdds)
                    {
                        // More adds to do.  
                        cAddsPerCall = (USHORT)(min(cAdds - (i * MAX_PING_CHUNK_SIZE), 
                                           MAX_PING_CHUNK_SIZE));
                    }
                    else                        
                        cAddsPerCall = 0;  // done with adds

                    if (cDelsTotal < cDels)
                    {
                        // More dels to do.  
                        cDelsPerCall = (USHORT)(min(cDels - (i * MAX_PING_CHUNK_SIZE), 
                                           MAX_PING_CHUNK_SIZE));
                    }
                    else                        
                        cDelsPerCall = 0;  // done with dels

                    // Setup pointers
                    pAddsPerCall = (cAddsPerCall > 0) ? 
                                   aAdds + (i * MAX_PING_CHUNK_SIZE) : NULL;
                    pDelsPerCall = (cDelsPerCall > 0) ? 
                                   aDels + (i * MAX_PING_CHUNK_SIZE) : NULL;
                    
                    ASSERT(_hServer);
                    ASSERT((cAddsPerCall > 0) || (cDelsPerCall > 0));
                    ASSERT(pAddsPerCall || pDelsPerCall);

                    // Update totals
                    cAddsTotal += cAddsPerCall;
                    cDelsTotal += cDelsPerCall;
					
                    _sequence++;
                    status = ComplexPing(
                                   _hServer,
                                   &_setid,
                                   _sequence,
                                   cAddsPerCall,
                                   cDelsPerCall,
                                   pAddsPerCall,
                                   pDelsPerCall,
                                   &wBackoffFactor
                                   );
                    if (status == OR_OK)
                    {
                        // Keep going -- might have more chunks to process
                    }
                    else if (status == OR_BADOID)
                    {
                        // This is really okay, all Dels must be deleted,
                        // and if the add failed now, it will always fail.
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Client specified unknown OID(s). %p %p %p\n",
                                   this,
                                   aAdds,
                                   apoidAdds));

                        status = OR_OK;
                    }
                    else if (status == OR_NOMEM
                        || status == RPC_S_OUT_OF_RESOURCES
                        || status == RPC_S_SERVER_TOO_BUSY)
                    {
                        // On these errors we quit immediately.  No retry attempts
                        // even if there are further chunks to process.
                        break;
                    }
                    else if (status == RPC_S_ACCESS_DENIED ||
                             status == RPC_S_SEC_PKG_ERROR)
                    {
                        _fSecure = FALSE;
                        
                        // if unsecure pings fail more than once,
                        // then most likely the server rebooted
                        // and the setid was allocated to a different user
                        // on another machine. Not much we can do.
                        // Or, this is a DDOS attack.
                        // Bail in either case.
                        
                        if (cFailedUnsecureCPings++ > 3) 
                        {
                           KdPrintEx((DPFLTR_DCOMSS_ID,
                                      DPFLTR_WARNING_LEVEL,
                                      "OR: Server %S (set %p) has failed 3 complex pings...\n",
                                      _pMid->PrintableName(),
                                      this));
                           RPC_STATUS mystatus = RpcBindingFree(&_hServer);
                           ASSERT(mystatus == RPC_S_OK && _hServer == 0);
                           _sequence--;
                           break;
                        }
                        status   = RpcBindingSetAuthInfo(_hServer,
                                                       0,
                                                       RPC_C_AUTHN_LEVEL_NONE,
                                                       RPC_C_AUTHN_NONE,
                                                       0,
                                                       0);
                        if (status == RPC_S_OK)
                        {
                            // Restart loop using unsecure calls
                            i = -1;    // restart loop from beginning
                            cAddsTotal = 0;
                            cDelsTotal = 0;                         
                        }
                    }
                    else if (status == OR_BADSET)
                    {
                        // Set invalid; reallocate (don't free the binding).
                        ASSERT(_setid);
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Set %p invalid; recreating..\n",
                                   this));

                        _setid = 0;
                        _sequence = 0;
                        cAddsTotal = 0;
                        cDelsTotal = 0;                         
                        i = -1;  // reset loop
                    }
                    else
                    {
                        // Assume communication failure, free binding, and exit the
                        // loop (we'll re-allocate a new binding on the next ping)
                        RPC_STATUS mystatus = RpcBindingFree(&_hServer);
                        ASSERT(mystatus == RPC_S_OK && _hServer == 0);
                        _sequence--;
                        break;
                    }
                }
            }
        }

        pToken->Revert();

        gpClientLock->LockExclusive();

        this->Reference();         // Keep set alive until we finish

        if (status == OR_OK)
        {
            // Success, process the adds
            for (i = 0; i < cAdds; i++)
            {
                pOid = apoidAdds[i];

                pOid->Added();

                if (FALSE != pOid->Out())
                {
                    // NOT referenced now, make sure it gets deleted next period.
                    ObjectUpdate(pOid);
                }
            }

            // Process deletes.
            for (i = 0; i < cDels; i++)
            {
                pOid = apoidDels[i];

                pOid->Deleted();

                if (FALSE != pOid->Out())
                {
                    // Well what do you yah know, we can _finally_ delete an oid.

                    CClientOid *pT = (CClientOid *)_blistOids.Remove(pOid);
                    ASSERT(pT == pOid);

                    DWORD t = pOid->Release();
                    ASSERT(t == 0);
                }
                else
                {
                    // We deleted from the set but now somebody is referencing it.
                    // Make sure we re-add it next time.
                    ObjectUpdate(pOid);
                }
            }

            _cFailedPings = 0;
        }
        else
        {
            _fChange = TRUE;
        }

        DWORD c = this->Release();
        if (c)
        {
            ASSERT(_blistOids.Size());
            this->Insert();
        }
        else
        {
            ASSERT(cAdds == 0 && cDels != 0);
        }
        // Set (this) pointer maybe invalid

        gpClientLock->UnlockExclusive();
        if (pvMem)
            PrivMemFree(pvMem);
    }
    else
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: Pinging set %p on %S.\n",
                   this,
                   _pMid->PrintableName()));

        ASSERT(_setid != 0);

        if (_pMid->IsLocal())
        {
            ASSERT(_cFailedPings == 0);
            ASSERT(_hServer == 0);
            status = _SimplePing(0, &_setid);
            // Somewhat overactive assert.  We usually hit this assert when 
            // the machine is overstressed and the worker threads get 
            // behind.    Sometimes it can also be a sign of a hung process
            // on the machine.  Commenting it out until we can figure
            // out a way to make it more discerning.
            //ASSERT(status == OR_OK);
        }
        else
        {
            ASSERT(_hServer);
            if (_cFailedPings <= 3)
            {
                status = SimplePing(_hServer, &_setid);
                if (status != OR_OK)
                {
                    _cFailedPings++;
                    if (_cFailedPings > 3)
                    {
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Server %S (set %p) has failed 3 pings...\n",
                                   _pMid->PrintableName(),
                                   this));
                    }
                }
                else
                {
                    _cFailedPings = 0;
                }
            }
            else
            {
                status = OR_OK;
            }
        }
        this->Insert();
        pToken->Revert();
    }

    // Set (this) maybe invalid.
#if DBG
    if (status != OR_OK)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: ping %p failed %d\n",
                   this,
                   status));
    }
#endif

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=-DNTENV -DWIN32RPC -DNTWIN32RPC -DUNICODE -DMSWMSG

UMTYPE=console
UMAPPL=
UMTEST=t*uid
UMLIBS=$(SDK_LIB_PATH)\rpcrt4.lib \
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\libcmt.lib \
       $(O)\locks.obj \
       $(O)\callid.obj

UMRES=

INCLUDES=..;..\..
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\ih
INCLUDES=$(INCLUDES);..\..\..\com\rot
INCLUDES=$(INCLUDES);..\..\olescm
INCLUDES=$(INCLUDES);$(DS_INC_PATH)
INCLUDES=$(INCLUDES);$(DS_INC_PATH)\crypto

TARGETPATH=..\..\lib\$(DEST_TREE)\$(_OBJ_DIR)
TARGETLIBS=

PRECOMPILED_INCLUDE=..\or.hxx

SOURCES=                \
        ..\locks.cxx    \
        ..\misc.cxx     \
        ..\callid.cxx   \
        ..\string.cxx   \
        ..\plist.cxx    \
        ..\blist.cxx    \
        ..\gentable.cxx \
        ..\mid.cxx      \
        ..\token.cxx    \
        ..\process.cxx  \
        ..\objex.cxx    \
        ..\orclnt.cxx   \
        ..\orsvr.cxx    \
        ..\worker.cxx   \
        ..\manager.cxx  \
        ..\namedobj.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\process.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Process.cxx

Abstract:

    Process objects represent local clients and servers.  These
    objects live as context handles.

    There are relatively few of these objects in the universe.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-20-95    Bits 'n pieces
    Ronans      20-02-97    UseProtseqIfNeeded modified for custom endpoints
    Ronans      20-02-97    Added custom endpoints stuff to process object
    TarunA      09-Nov-98   Added process handle

--*/

#include <or.hxx>

CRITICAL_SECTION gcsFastProcessLock;
extern HRESULT FreeSPIFromCProcess(void** ppSCMProcessInfo);

const DWORD BINDINGUPDATESTUFF_SIG = 0xFEDCBA01;

typedef struct _BINDINGS_UPDATE_CALLBACK_STUFF
{
    DWORD dwSig; // see BINDINGUPDATESTUFF_SIG above

    // housekeeping stuff
    CProcess* pProcess;  // has reference while call is in-flight
    RPC_BINDING_HANDLE hBinding;
    RPC_ASYNC_STATE async;

    // out and in-out params
    DWORD64 dwBindingsID;
    DUALSTRINGARRAY* pdsaNewBindings;
    DUALSTRINGARRAY* pdsaNewSecurity;
} BINDINGS_UPDATE_CALLBACK_STUFF;


const DWORD ASYNCRUNDOWNOID_SIG = 0xFEDCBA02;

typedef struct _ASYNCRUNDOWNOID_STUFF
{
    DWORD dwSig; // see ASYNCRUNDOWNOID_SIG above

    // housekeeping stuff
    CProcess* pProcess;  // has reference while call is in-flight
    CServerOxid* pOxid;  // has reference while call is in-flight
    RPC_BINDING_HANDLE hBinding;
    RPC_ASYNC_STATE async;

    // We keep these for when we process the return
    ULONG cOids;
    CServerOid* aOids[MAX_OID_RUNDOWNS_PER_CALL];

    // The ORPC params are reference pointers, so they must
    // stay alive for the life of the call
    ORPCTHIS orpcthis;
    LOCALTHIS localthis;
    ORPCTHAT orpcthat;

    INT callIDHint;  // need to free this on return

    // in-out or out params.
    BYTE  aRundownStatus[MAX_OID_RUNDOWNS_PER_CALL];
} ASYNCRUNDOWNOID_STUFF;


void
CProcess::Rundown()
/*++

Routine Description:

    The client process has rundown.  This means there are no more
    client refernces which means we are free to clean things up
    as long as server OXIDs still holding references won't get
    upset.  They all use the server lock when accessing the process.

Arguments:

    None

Return Value:

    None

--*/
{
    ORSTATUS     status;

    gpServerLock->LockExclusive();

    ASSERT(_cClientReferences == 0);
    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_INFO_LEVEL,
               "OR: Rundown of %p: %d oxids, %d oids and %d roxids left\n",
               this,
               _blistOxids.Size(),
               _blistOids.Size()));

    // Release any OXIDs owned by this process. This may destroy the OXID.
    // This will release this CProcess, but won't release the last reference as
    // the client process still owns one.


    if (_blistOxids.Size())
    {
        CServerOxid *poxid;

        CBListIterator oxids(&_blistOxids);

        while (poxid = (CServerOxid *)oxids.Next())
        {
            gpServerOxidTable->Remove(poxid);
            poxid->ProcessRelease();
        }
    }

    // Release any OIDs is use by this processes.

    // Do this now, rather then waiting for the last server oid
    // owned by this process to get invalidated and rundown.

    gpClientLock->LockExclusive();

    // *** Both client and server lock held here. ***

    if (_blistOids.Size())
    {
        CClientOid  *poid;

        CBListIterator oids(&_blistOids);

        while (poid = (CClientOid *)oids.Next())
        {
            ASSERT(NULL != poid->GetClientOxid());

            poid->GetClientOxid()->Release();

            poid->ClientRelease();
        }
    }

    // Cleanup other process state.    Note:  it is important that the
    // release of the process and token handle never happen any later
    // than rundown time.   If the process handle is released any later, you
    // will see bugs like "can't recompile my com server" after they run
    // it once.   If the token handle is released any later, you will get
    // security bugs from the NT security folks since we will hold onto
    // the logged-on user's token until many minutes after logoff.
    //
    // Ask me how I know this...
    //
    if (_hProcHandle)
    {
        CloseHandle(_hProcHandle);
        _hProcHandle = NULL;
    }

    if (_pToken)
    {
        _pToken->Release();
        _pToken = 0;
    }

    // Free the cached SCMProcessInfo if we have one
    FreeSPIFromCProcess(&_pSCMProcessInfo);

    // Flip the dirty bit
    FlagsOn(PROCESS_SPI_DIRTY);

    // Cleanup the ROT entries associated with this process outside the lock.
    // NULL the list first, though.
    void *pvFirstROT = _pvFirstROTEntry;
    _pvFirstROTEntry = NULL;

    gpClientLock->UnlockExclusive();

    if (_cDropTargets != 0)         // check if we have any outstanding droptargets to clean up
        DragDropRunDown(this);

    // Done, release the clients' reference, this may actually delete this
    // process.  (If an OXID still exists and has OIDs it will not be deleted
    // until the OIDs all rundown).

    this->Release();

    // The this pointer maybe invalid now.

    gpServerLock->UnlockExclusive();

    // Now actually cleanup the ROT entries.  
    // Do this outside of the server lock, to avoid deadlocks.
    SCMCleanupROTEntries(pvFirstROT);
}


CProcess::CProcess(
                  IN CToken*& pToken,
                  IN WCHAR *pwszWinstaDesktop,
                  IN DWORD procID,
                  OUT ORSTATUS &status
                  ) :
_blistOxids(4),
_blistOids(16),
_listClasses()
/*++

Routine Description:

    Initalized a process object, members and add it to the
    process list.

Arguments:

    pToken - The clients token.  We assume we have a reference.

    pwszWinstaDesktop - The client's windowstation/desktop string.

    procID - The client's process ID.

    status - Sometimes the C'tor can fail with OR_NOMEM.

Return Value:

    None

--*/
{
    _cClientReferences  = 1;
    _hProcess           = NULL;
    _fCacheFree         = FALSE;
    _pdsaLocalBindings  = NULL;
    _pdsaRemoteBindings = NULL;
    _pToken             = NULL;
    _pwszWinstaDesktop  = NULL;
    _pScmProcessReg     = NULL;
    _pvRunAsHandle      = NULL;
    _procID             = 0;
    _hProcHandle        = NULL;
    _dwFlags            = PROCESS_SPI_DIRTY;  // always start out dirty
    _pSCMProcessInfo    = NULL;
    _ulClasses          = 0;
    _dwCurrentBindingsID = 0;
    _dwAsyncUpdatesOutstanding = 0;
    _pvFirstROTEntry    = NULL;
    _cDropTargets	= 0;

    // Store time of object creation.  Note that this is in UTC time.
    GetSystemTimeAsFileTime(&_ftCreated);
	
    // Generate a unique guid to represent this process
    UuidCreate(&_guidProcessIdentifier);

    // ronans - entries for custom protseqs from server
    // not used for clients
    _fReadCustomProtseqs = FALSE;
    _pdsaCustomProtseqs = NULL;

    status = OR_OK;
    if ( pwszWinstaDesktop == NULL )
    {
        status = OR_BADPARAM;
    }

    if (status == OR_OK)
    {
        _pwszWinstaDesktop = new WCHAR[OrStringLen(pwszWinstaDesktop)+1];
        if (! _pwszWinstaDesktop)
            status = OR_NOMEM;
        else
            OrStringCopy(_pwszWinstaDesktop, pwszWinstaDesktop);
    }

    if (status == OR_OK)
    {
        _pToken = pToken;
        pToken = NULL; // We've taken the token
    }

    if (status == STATUS_SUCCESS)
    {
        // Need to check that this is truly a new registration
        // before we add it to the list
        gpProcessListLock->LockExclusive();
        if (VerifyNewProcess(procID))
        {
            status = gpProcessList->Insert(this);
        }
        else
        {
            // bad baby bad
            status = OR_NOACCESS;
            ASSERT(!"Possible bogus caller");
        }
        gpProcessListLock->UnlockExclusive();
    }

    _procID = procID;

#if DBG
    _cRundowns = 0;
#endif
}

CProcess::~CProcess(void)
// You probably should be looking in the ::Rundown method.
// This process object stays alive until the last server oxid dies.
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_hProcHandle == 0);
    ASSERT(_pSCMProcessInfo == 0);

    delete _pdsaLocalBindings;
    delete _pdsaRemoteBindings;
    MIDL_user_free( _pdsaCustomProtseqs );

    delete _pwszWinstaDesktop;

    if (_hProcess)
    {
        RPC_STATUS status = RpcBindingFree(&_hProcess);
        ASSERT(status == RPC_S_OK);
        ASSERT(_hProcess == 0);
    }

    extern void RunAsRelease(void*);
    RunAsRelease(_pvRunAsHandle);

    return;
}

//
//  SetSCMProcessInfo
//
//  Swaps our old cached SCMProcessInfo* for a new one.
//
HRESULT CProcess::SetSCMProcessInfo(void* pSPI)
{
  ASSERT(gpServerLock->HeldExclusive());
  ASSERT(!(_dwFlags & PROCESS_RUNDOWN));

  if (_dwFlags & PROCESS_RUNDOWN)
    return E_UNEXPECTED;

  FreeSPIFromCProcess(&_pSCMProcessInfo);

  // set the new one
  _pSCMProcessInfo = pSPI;

  // this means we're no longer dirty
  FlagsOff(PROCESS_SPI_DIRTY);

  return S_OK;
}

void CProcess::SetProcessReadyState(DWORD dwState)
{
  ASSERT(_pScmProcessReg);

  gpServerLock->LockExclusive();

  _pScmProcessReg->ReadinessStatus = dwState;

  // we're now dirty
  FlagsOn(PROCESS_SPI_DIRTY);

  gpServerLock->UnlockExclusive();
}


void CProcess::Retire()
{
    // A process can (or should be) only retired once
    ASSERT(!IsRetired());

    // Mark ourselves as retired
    FlagsOn(PROCESS_RETIRED | PROCESS_SPI_DIRTY);
}


void CProcess::SetRunAsHandle(void *pvRunAsHandle)
{
    ASSERT(!_pvRunAsHandle);
    _pvRunAsHandle = pvRunAsHandle;
}

BOOL CProcess::SetProcessHandle(HANDLE hProcHandle, DWORD dwLaunchedPID)
{
/*++

Routine Description:

    Store the handle of the process only if the process launched by
    us and the process registering back are the same. Otherwise
    we might kill a process not launched by us on receiving certain
    error conditions (notably RPC_E_SERVERFAULT)

Arguments:

    hProcHandle - Handle of the process launched

    dwLaunchedPID - PID of the process launched

Return Value:

    TRUE - If handle is set
    FALSE - otherwise

--*/

    BOOL fRet = FALSE;
    if (dwLaunchedPID == _procID)
    {

       // if the server registers the same class twice, this handle will be non-zero if the
       // the waiting activation thread has not NULL'd the CServerTableEntry's _hProcess yet.
       if (_hProcHandle)
       {
          CloseHandle(_hProcHandle);
          _hProcHandle = 0;
       }
       // This should fail only we are out of pool.
       // If this fails, we cannot kill off servers we started
       // nor can we test them for deadness.
       if ( (fRet = DuplicateHandle(GetCurrentProcess(), hProcHandle,
                                    GetCurrentProcess(), &_hProcHandle,
                                    0, FALSE, DUPLICATE_SAME_ACCESS))  == 0)
       {
	  KdPrintEx((DPFLTR_DCOMSS_ID,
                     DPFLTR_WARNING_LEVEL,
                     "OR: DuplicateHandle failed 0x%x\n", GetLastError()));
       }
    }
    return fRet;
}

RPC_STATUS
CProcess::ProcessBindings(
                         IN DUALSTRINGARRAY *pdsaStringBindings,
                         IN DUALSTRINGARRAY *pdsaSecurityBindings
                         )
/*++

Routine Description:

    Updates the string and optionally the security
    bindings associated with this process.

Arguments:

    psaStringBindings - The expanded string bindings of the process

    psaSecurityBindings - compressed security bindings of the process.
        If NULL, the current security bindings are reused.

Environment:

    Server lock held during call or called from an OXID with an extra
    reference owned by the process and keeping this process alive.

Return Value:

    OR_NOMEM - unable to allocate storage for the new string arrays.

    OR_OK - normally.

--*/
{
    CMutexLock lock(&gcsFastProcessLock);
    USHORT wSecSize;
    PWSTR  pwstrSecPointer;

    // NULL security bindings means we should use the existing bindings.
    if (0 == pdsaSecurityBindings)
    {
        ASSERT(_pdsaLocalBindings);
        wSecSize = _pdsaLocalBindings->wNumEntries - _pdsaLocalBindings->wSecurityOffset;
        pwstrSecPointer =   _pdsaLocalBindings->aStringArray
                            + _pdsaLocalBindings->wSecurityOffset;
    }
    else
    {
        wSecSize = pdsaSecurityBindings->wNumEntries - pdsaSecurityBindings->wSecurityOffset;
        pwstrSecPointer = &pdsaSecurityBindings->aStringArray[pdsaSecurityBindings->wSecurityOffset];
    }

    DUALSTRINGARRAY *pdsaT = CompressStringArrayAndAddIPAddrs(pdsaStringBindings);
    if (!pdsaT)
    {
        return(OR_NOMEM);
    }

    // ignore security on string binding parameter
    pdsaT->wNumEntries = pdsaT->wSecurityOffset;

    DUALSTRINGARRAY *pdsaResult = new((pdsaT->wNumEntries + wSecSize) * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (0 == pdsaResult)
    {
        delete pdsaT;
        return(OR_NOMEM);
    }

    pdsaResult->wNumEntries = pdsaT->wNumEntries + wSecSize;
    pdsaResult->wSecurityOffset = pdsaT->wSecurityOffset;

    OrMemoryCopy(pdsaResult->aStringArray,
                 pdsaT->aStringArray,
                 pdsaT->wSecurityOffset*sizeof(WCHAR));

    OrMemoryCopy(pdsaResult->aStringArray + pdsaResult->wSecurityOffset,
                 pwstrSecPointer,
                 wSecSize*sizeof(WCHAR));

    ASSERT(dsaValid(pdsaResult));

    delete pdsaT;

    delete _pdsaLocalBindings;
    _pdsaLocalBindings = pdsaResult;

    delete _pdsaRemoteBindings;
    _pdsaRemoteBindings = 0;

    return(RPC_S_OK);
}

DUALSTRINGARRAY *
CProcess::GetLocalBindings(void)
// Server lock held or called within an
// OXID with an extra reference.
{
    CMutexLock lock(&gcsFastProcessLock);

    if (0 == _pdsaLocalBindings)
    {
        return(0);
    }

    DUALSTRINGARRAY *T = (DUALSTRINGARRAY *)MIDL_user_allocate(sizeof(DUALSTRINGARRAY)
                                                               + sizeof(USHORT) * _pdsaLocalBindings->wNumEntries);

    if (0 != T)
    {
        dsaCopy(T, _pdsaLocalBindings);
    }

    return(T);
}

DUALSTRINGARRAY *
CProcess::GetRemoteBindings(void)
// Server lock held.
{
    CMutexLock lock(&gcsFastProcessLock);

    ORSTATUS Status;

    if (0 == _pdsaRemoteBindings)
    {
        if (0 == _pdsaLocalBindings)
        {
            return(0);
        }

        Status = ConvertToRemote(_pdsaLocalBindings, &_pdsaRemoteBindings);

        if (Status != OR_OK)
        {
            ASSERT(Status == OR_NOMEM);
            return(0);
        }
        ASSERT(dsaValid(_pdsaRemoteBindings));
    }

    DUALSTRINGARRAY *T = (DUALSTRINGARRAY *)MIDL_user_allocate(sizeof(DUALSTRINGARRAY)
                                                               + sizeof(USHORT) * _pdsaRemoteBindings->wNumEntries);

    if (0 != T)
    {
        dsaCopy(T, _pdsaRemoteBindings);
    }

    ASSERT(dsaValid(T));
    return(T);
}


ORSTATUS
CProcess::AddOxid(CServerOxid *pOxid)
{
    ASSERT(gpServerLock->HeldExclusive());

    pOxid->Reference();

    ASSERT(_blistOxids.Member(pOxid) == FALSE);

    ORSTATUS status = _blistOxids.Insert(pOxid);

    if (status != OR_OK)
    {
        pOxid->ProcessRelease();
        return(status);
    }

    gpServerOxidTable->Add(pOxid);

    return(OR_OK);
}

BOOL
CProcess::RemoveOxid(CServerOxid *poxid)
{
    ASSERT(gpServerLock->HeldExclusive());

    CServerOxid *pit = (CServerOxid *)_blistOxids.Remove(poxid);

    if (pit)
    {
        ASSERT(pit == poxid);
        gpServerOxidTable->Remove(poxid);
        poxid->ProcessRelease();
        return(TRUE);
    }

    return(FALSE);
}


BOOL
CProcess::IsOwner(CServerOxid *poxid)
{
    ASSERT(gpServerLock->HeldExclusive());

    return(_blistOxids.Member(poxid));
}

ORSTATUS
CProcess::AddOid(CClientOid *poid)
/*++

Routine Description:

    Adds a new oid to the list of OIDs owned by this process and
    increments the reference count of the associated OXID

Arguments:

    poid - the oid to add.  It's reference is transferred to this
        function.  If this function fails, it must dereference the oid.
        The caller passed a client reference to this process.  The
        process must eventually call ClientRelease() on the parameter.

Return Value:

    OR_OK - normally

    OR_NOMEM - out of memory.

--*/

{
    ORSTATUS status;

    ASSERT(gpClientLock->HeldExclusive());

    status = _blistOids.Insert(poid);

    if (status != OR_OK)
    {
        ASSERT(status == OR_NOMEM);
        poid->ClientRelease();
    }
    else
    {
        ASSERT(NULL != poid->GetClientOxid());
        poid->GetClientOxid()->Reference();
    }

    return(status);
}

CClientOid *
CProcess::RemoveOid(CClientOid *poid)
/*++

Routine Description:

    Removes an OID from this list of OID in use by this process.

Arguments:

    poid - The OID to remove.

Return Value:

    non-zero - the pointer actually remove. (ASSERT(retval == poid))
               It will be released by the process before return,
               so you should not use the pointer unless you know you
               have another reference.

    0 - not in the list

--*/

{
    ASSERT(gpClientLock->HeldExclusive());

    CClientOid *pit = (CClientOid *)_blistOids.Remove(poid);

    if (pit)
    {
        ASSERT(pit == poid);

        pit->ClientRelease();

        ASSERT(NULL != poid->GetClientOxid());

        poid->GetClientOxid()->Release();

        return(pit);
    }

    return(0);
}

void
CProcess::AddClassReg(GUID & Guid, DWORD Reg)
{
    CClassReg * pReg;

    pReg = new CClassReg( Guid, Reg );

    if (pReg)
    {
        gpServerLock->LockExclusive();

        _listClasses.Insert( pReg );

        // flip the dirty bit
        FlagsOn(PROCESS_SPI_DIRTY);

        _ulClasses++;

        gpServerLock->UnlockExclusive();
    }
}

void
CProcess::RemoveClassReg(DWORD Reg)
{
    CClassReg * pReg;

    gpServerLock->LockExclusive();

    pReg = (CClassReg *)_listClasses.First();

    while ( (pReg != NULL) && (pReg->_Reg != Reg) )
        pReg = (CClassReg *)pReg->Next();

    if (pReg)
    {
        (void)_listClasses.Remove( pReg );
        delete pReg;

        // flip the dirty bit
        FlagsOn(PROCESS_SPI_DIRTY);

        _ulClasses--;
    }

    gpServerLock->UnlockExclusive();
}

void
CProcess::Cleanup()
{
    SCMProcessCleanup(this);
}

void
CProcess::RevokeClassRegs()
{

    if (_pScmProcessReg)
    {
        // This is a unified surrogate (COM+) server
        SCMRemoveRegistration(_pScmProcessReg);
        _pScmProcessReg = NULL;
    }

    // This is for legacy local or custom surrogate servers -- however,
    // nothing prevents someone from calling CoRegisterClassObject in
    // user code even in a COM+ (surrogate) server

    CClassReg * pReg;

    // This is only called during rundown so we don't have to take a lock.

    while ( (pReg = (CClassReg *)_listClasses.First()) != 0 )
    {
        (void)_listClasses.Remove((CListElement *)pReg);
        SCMRemoveRegistration( this,
                               pReg->_Guid,
                               pReg->_Reg );
        delete pReg;
    }
}


void CProcess::SetProcessReg(ScmProcessReg *pProcessReg)
/*++

Routine Description:

    Called by SCM to set COM+ process registration.
    This is also used as a cache during the startup protocol
    to query and set the readiness state of the server process.
    There is exactly one such registration per COM+ server process.

  CODEWORK: these should be inlined

Arguments:

    registration struct

Return Value:

    none.

--*/
{
    gpServerLock->LockExclusive();

    _pScmProcessReg = pProcessReg;

    gpServerLock->UnlockExclusive();
}

ScmProcessReg* CProcess::GetProcessReg()
/*++

Routine Description:

    Called by SCM to lookup COM+ process registration.

Arguments:

    None

Return Value:

    registration struct, if any.

--*/
{
    gpServerLock->LockShared();

    ScmProcessReg *pResult = _pScmProcessReg;

    gpServerLock->UnlockShared();

    return pResult;
}

ScmProcessReg*
CProcess::RemoveProcessReg()
/*++

Routine Description:

    Called by SCM when COM+ process revokes its activator registration.

Arguments:

    None

Return Value:

    none.

--*/
{
    gpServerLock->LockExclusive();

    ScmProcessReg *pResult = _pScmProcessReg;
	
    // Even if this process was a new-style surrogate process, _pScmProcessReg
    // may already be NULL here.   See bug 26676.  So we don't assert anymore
    // that _pScmProcessReg is non-NULL.
    // ASSERT(_pScmProcessReg);

    _pScmProcessReg = NULL;

    gpServerLock->UnlockExclusive();

    return pResult;
}

void CProcess::RevokeProcessReg()
/*++

Routine Description:

    Called during rundown to let SCM know that the COM+ process has died.

  CODEWORK: This needs to be defined.

Arguments:

    None

Return Value:

    none.

--*/
{
}

RPC_BINDING_HANDLE
CProcess::CreateBindingHandle(
                          void
                          )
/*++

Routine Description:

    Creates a new binding handle back to the process.

Arguments:

    None

Return Value:

    Binding Handle, NULL if no valid handle.

--*/
{
    RPC_STATUS status;

    CMutexLock lock(&gcsFastProcessLock);

    // Find ncalrpc binding.
    PWSTR pwstr = _pdsaLocalBindings->aStringArray;
    while (*pwstr)
    {
        if (*pwstr == ID_LPC)
        {
            break;
        }
        pwstr = OrStringSearch(pwstr, 0) + 1;
    }

    if (*pwstr == 0)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Unable to find ncalrpc binding to server: %p %p\n",
                   _pdsaLocalBindings,
                   this));

        ASSERT(0);
        return NULL;
    }

    HANDLE hRpc = GetBinding(pwstr);
    if (!hRpc)
        return NULL;

    // Set mutual auth on the binding handle
    RPC_SECURITY_QOS_V3 qos;
    ZeroMemory(&qos, sizeof(RPC_SECURITY_QOS_V3));

    qos.Version = RPC_C_SECURITY_QOS_VERSION_3;
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH | 
                       RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT;
    qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
    qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
    qos.AdditionalSecurityInfoType = 0;
    qos.Sid = _pToken->GetSid();
	
    status = RpcBindingSetAuthInfoEx(hRpc,
                                     NULL, // pass sid in QOS instead
                                     RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                     RPC_C_AUTHN_WINNT,
                                     NULL,
                                     RPC_C_AUTHZ_NONE,
                                     (RPC_SECURITY_QOS*)&qos);        
    if (status != RPC_S_OK)
    {
        status = RpcBindingFree(&hRpc);
        ASSERT(status == RPC_S_OK);
        hRpc = NULL;
    }

    return hRpc;
}

BOOL 
CProcess::EnsureBindingHandle()
{
    if (_hProcess)
        return TRUE;
    
    CMutexLock lock(&gcsFastProcessLock);

    // Fault in a handle back to the process
    // if we haven't already
    if (0 == _hProcess)
    {
        ASSERT(!_fCacheFree);
        
        _hProcess = CreateBindingHandle();
        if (!_hProcess)
            return FALSE;
        
        _fCacheFree = TRUE;
    }

    return TRUE;
}

RPC_BINDING_HANDLE
CProcess::AllocateBinding(
                         void
                         )
/*++

Routine Description:

    Allocates a unique binding handle for a call back
    to the process.  This binding handle will not be
    used by another thread until it is freed.  

Arguments:

    None

Return Value:

    0 - failure

    non-zero - a binding handle to use.

--*/
{
    if (!EnsureBindingHandle())
        return NULL;

    CMutexLock lock(&gcsFastProcessLock);

    // If the master copy is available, let
    // the caller use it.
    if (_fCacheFree)
    {
        _fCacheFree = FALSE;
        return _hProcess;
    }

    // Otherwise, create a copy
    RPC_BINDING_HANDLE hCopy;
    RPC_STATUS status;
    status = RpcBindingCopy(_hProcess, &hCopy);
    if (status != RPC_S_OK)
    {
        return NULL;
    }

    return hCopy;
}


void
CProcess::FreeBinding(
                     IN RPC_BINDING_HANDLE hBinding
                     )
/*++

Routine Description:

    Frees a binding back to the process.

Arguments:

    hBinding - A binding back to the process previously
        allocated with AllocateBinding().

Return Value:

    None

--*/
{
    if (hBinding == _hProcess)
    {
        _fCacheFree = TRUE;
    }
    else
    {
        RPC_STATUS status = RpcBindingFree(&hBinding);
        ASSERT(status == RPC_S_OK);
    }
}

RPC_BINDING_HANDLE CProcess::GetBindingHandle()
/*++

Routine Description:

    Creates and returns a binding handle that can be 
    used to call back to the process.   Caller owns the
    binding handle and should clean it up by calling
    RpcBindingFree.

Arguments:

    None

Return Value:

    0 - failure

    non-zero - a binding handle to use.

--*/
{
    if (!EnsureBindingHandle())
        return NULL;

    RPC_BINDING_HANDLE hCopy;
    RPC_STATUS status;
    status = RpcBindingCopy(_hProcess, &hCopy);
    if (status != RPC_S_OK)
    {
        return NULL;
    }

    return hCopy;
}


RPC_STATUS
CProcess::RundownOids(
                     IN RPC_BINDING_HANDLE hRpc,
                     IN CServerOxid* pOwningOxid,
                     IN ULONG cOids,
                     IN CServerOid* aOids[]
                     )
/*++

Routine Description:

    Issues an async call to the process which will rundown the OIDs.
    This is called from an OXID which will be kept alive during the
    whole call.  Multiple calls maybe made to this function by
    one or more OXIDs at the same time.  The callback itself is
    an ORPC call, ie is must have THIS and THAT pointers.

Arguments:

    hRpc -- rpc binding handle with which to make the call.  Caller owns.

    pOwningOxid - oxid that owns the specified oids.   This oxid should
        be registered from this process.

    cOids - The number of entries in aOids and afRundownOk

    aOids - An array of CServerOid's to rundown.  The OIDs must
        all be owned by pOwningOxid.  The caller will have already
        called SetRundown(TRUE) on each one.

Return Value:
    
    RPC_S_OK - the async call was issued successfully

    other -- error occurred.  call was not issued.

--*/
{
    ULONG i;
    error_status_t status = OR_OK;
    RPC_BINDING_HANDLE hBinding;
    OID aScalarOids[MAX_OID_RUNDOWNS_PER_CALL];

    ASSERT(hRpc);
    ASSERT(cOids > 0 && aOids);
    ASSERT(cOids <= MAX_OID_RUNDOWNS_PER_CALL);
    ASSERT(IsOwner(pOwningOxid));

    // Callers must be aware that the lock will be released upon return
    ASSERT(gpServerLock->HeldExclusive());
    gpServerLock->UnlockExclusive();

    // This process will be held alive by the OXID calling
    // us since it has an extra reference.

    //
    // Allocate async structure and zero it out
    //
    ASYNCRUNDOWNOID_STUFF* pArgs = new ASYNCRUNDOWNOID_STUFF;
    if (!pArgs)
        return OR_NOMEM;

    ZeroMemory(pArgs, sizeof(ASYNCRUNDOWNOID_STUFF));

    //
    // Initialize RPC async state
    //
    status = RpcAsyncInitializeHandle(&(pArgs->async), sizeof(pArgs->async));
    if (status != RPC_S_OK)
    {
        delete pArgs;
        return status;
    }

    //
    // Initialize async structure
    //
    pArgs->dwSig = ASYNCRUNDOWNOID_SIG;
    pArgs->pProcess = this;      // we take a reference further below
    pArgs->pOxid = pOwningOxid;  // we take a reference further below
    pArgs->cOids = cOids;
    CopyMemory(pArgs->aOids, aOids, cOids * sizeof(CServerOid*));

    //
    // Fill in the numeric oid values
    //
    ZeroMemory(aScalarOids, sizeof(OID) * MAX_OID_RUNDOWNS_PER_CALL);
    for (i = 0; i < cOids; i++)
    {
        ASSERT(pArgs->aOids[i]);
        ASSERT(pArgs->aOids[i]->IsRunningDown());
        ASSERT(pArgs->aOids[i]->GetOxid() == pOwningOxid);
        aScalarOids[i] = pArgs->aOids[i]->Id();
    }

    //
    // Save the binding handle.  This is not strictly necessary now that
    // the soxid supplies the handle and owns its lifetime, but might be
    // useful in a debugging situation.
    //
    pArgs->hBinding = hRpc;

    //
    // Init parts of the RPC_ASYNC_STATE struct that we care about
    //
    pArgs->async.Flags = 0;  // the absence of RPC_C_NOTIFY_ON_SEND_COMPLETE flag means
                             // notify us on call completion, and no sooner.
    pArgs->async.UserInfo = pArgs;
    pArgs->async.NotificationType = RpcNotificationTypeCallback;
    pArgs->async.u.NotificationRoutine = CProcess::AsyncRundownReturnNotification;

    //
    // Initialize other params
    //
    pArgs->orpcthis.version.MajorVersion = COM_MAJOR_VERSION;
    pArgs->orpcthis.version.MinorVersion = COM_MINOR_VERSION;
    pArgs->orpcthis.flags                = ORPCF_LOCAL;
    pArgs->orpcthis.reserved1            = 0;
    pArgs->orpcthis.extensions           = NULL;
    pArgs->callIDHint                    = AllocateCallId(pArgs->orpcthis.cid);
    pArgs->localthis.dwClientThread      = 0;
    pArgs->localthis.dwFlags             = LOCALF_NONE;
    pArgs->orpcthat.flags                = 0;
    pArgs->orpcthat.extensions           = 0;

    //
    // Take an extra reference on the owning oxid and ourself.
    // These references will be released either on the call
    // return notification, or on the failure path below.
    //
    pOwningOxid->Reference();
    this->Reference();  // non-client ref, will not stop rundown

    //
    // Finally, issue the call.  Note that this is an async call
    // from our perspective, but is a synchronous ORPC call from
    // the server's perspective.
    //
    
    status = RawRundownOid(
                          &(pArgs->async),
                          pArgs->hBinding,
                          &(pArgs->orpcthis),
                          &(pArgs->localthis),
                          &(pArgs->orpcthat),
                          pArgs->cOids,
                          aScalarOids,
                          pArgs->aRundownStatus
                          );
    if (status != RPC_S_OK)
    {
        // If we get anything other than RPC_S_OK back, that
        // means we will not receive a call completion notif-
        // ication.   So, we need to cleanup everything up
        // right here in that case.

        // Call failed, so cleanup before returning.  Caller will
        // handle the failure semantics for the oids.
        FreeCallId(pArgs->callIDHint);
        delete pArgs;

        //
        // Must hold gpServerLock in order to call Release.
        //
        ASSERT(!gpServerLock->HeldExclusive());
        gpServerLock->LockExclusive();

        pOwningOxid->Release();
        this->Release();

        gpServerLock->UnlockExclusive();
        ASSERT(!gpServerLock->HeldExclusive());
    }

    return status;
}

void
CProcess::RundownOidNotify(CServerOxid* pOwningOxid,
                           ULONG cOids,
                           CServerOid* aOids[],
                           BYTE aRundownStatus[],
                           HRESULT hrReturn)
/*++

Routine Description:

    This is the callback notification function that is invoked when
    async oid rundown calls are completed.

Arguments:

    pOwningOxid -- owning oxid of the oids we tried to rundown.

    cOids -- count of oids

    aOids -- array of oids

    aRundownStatus -- array of individual status rundowns for each oid

    hrReturn -- return value from the function

Return Value:

    void

--*/
{
    ULONG i;
    error_status_t status = OR_OK;

    ASSERT(pOwningOxid);
    ASSERT((cOids > 0) && aOids && aRundownStatus);

    //
    // If destination oxid\apartment was not found, mark all
    // oids for rundown.
    //
    if (hrReturn == RPC_E_DISCONNECTED)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Rundown returned disconnected\n"));

        for (i = 0; i < cOids; i++)
        {
            aRundownStatus[i] = ORS_OK_TO_RUNDOWN;
        }
        hrReturn = RPC_S_OK;
    }

    //
    // In case of any other error, don't rundown the oids
    //
    if (hrReturn != S_OK)
    {
        for (i = 0; i < cOids; i++)
        {
            aRundownStatus[i] = ORS_DONTRUNDOWN;
        }
    }

    //
    // Notify the server oxid of the results
    //

    gpServerLock->LockExclusive();

    pOwningOxid->ProcessRundownResults(
                                cOids,
                                aOids,
                                aRundownStatus
                                );

    ASSERT(!gpServerLock->HeldExclusive());

    return;
}

void
CProcess::ExamineRpcAsyncCompleteCallReturnCode(RPC_STATUS status)
/*++

Routine Description:

    This function adds some diagnostic asserts for the various return
    values we might get back from RpcAsyncCompleteCall.   It is still
    the caller's responsibility to appropriately handle any errors.

++*/
{
    switch (status)
    {
    case RPC_S_OK:
        // Normal case
        break;

    case RPC_S_OUT_OF_MEMORY:
        // This means that an internal RPC operation failed.  Kamenm
        // says in this case we can't depend on the state of the call's
        // out-params, but all rpc-runtime allocated resources should
        // be cleaned up, so no leaks.
        break;

    case RPC_S_ASYNC_CALL_PENDING:
    case RPC_S_INVALID_ASYNC_HANDLE:
    case RPC_S_INVALID_ASYNC_CALL:
    case RPC_S_INVALID_ARG:
        // Any of these error codes usually signify a caller coding error. So
        // we assert.  Unfortunately there is not much else we can do; also RPC
        // will likely leak resources.
        ASSERT(!"Got error back from RpcAsyncCompleteCall, possible COM bug");
        break;

    default:
        // No clue.  Most often this is because the server process died (0x6be)
        break;
    };
    return;
}

void RPC_ENTRY
CProcess::AsyncRundownReturnNotification(
                                   IN RPC_ASYNC_STATE* pAsync,
                                   IN void* pContext,
                                   IN RPC_ASYNC_EVENT Event
                                   )
/*++

Routine Description:

    This is the callback notification function that is invoked when
    async rundown calls are completed.  It unpacks the necessary
    stuff from the async args struct, forwards them on to
    RundownOidNotify, and does other necessary cleanup.

Arguments:

    pAsync -- pointer to the async rpc state struct

    pContext -- rpc thingy, we ignore it

    Event -- should always be RpcCallComplete

Return Value:

    void

--*/
{
    RPC_STATUS status;
    HRESULT hrRetVal;
    ASYNCRUNDOWNOID_STUFF* pArgs;

    pArgs = (ASYNCRUNDOWNOID_STUFF*)
            (((char*)pAsync) - offsetof(ASYNCRUNDOWNOID_STUFF, async));

    ASSERT(pArgs->async.UserInfo = pArgs);
    ASSERT(pArgs->dwSig == ASYNCRUNDOWNOID_SIG);
    ASSERT(pArgs->hBinding);
    ASSERT(pArgs->pProcess);
    ASSERT(pArgs->pOxid);
    ASSERT(pArgs->cOids > 0);
    ASSERT(pAsync->Event == RpcCallComplete);
    ASSERT(Event == RpcCallComplete);

    //
    // Free the call id
    //
    FreeCallId(pArgs->callIDHint);

    //
    // Complete the call.  Even on successful call completion,
    // hrRetVal is not necessarily S_OK.
    //
    status = RpcAsyncCompleteCall(&(pArgs->async), &hrRetVal);
    ExamineRpcAsyncCompleteCallReturnCode(status);

    //
    // Notify the process object that the call has returned
    //
    pArgs->pProcess->RundownOidNotify(
                           pArgs->pOxid,
                           pArgs->cOids,
                           pArgs->aOids,
                           pArgs->aRundownStatus,
                           (status == RPC_S_OK) ? hrRetVal : E_FAIL
                           );

    //
    // Cleanup other stuff from the call
    //
    if (status == RPC_S_OK && pArgs->orpcthat.extensions)
    {
        for (ULONG i = 0; i < pArgs->orpcthat.extensions->size; i++)
        {
            MIDL_user_free(pArgs->orpcthat.extensions->extent[i]);
        }
        MIDL_user_free(pArgs->orpcthat.extensions->extent);
        MIDL_user_free(pArgs->orpcthat.extensions);
    }

    //
    // Release the references on ourselves and the server
    // oxid.  Must hold gpServerLock while calling Release.
    //
    gpServerLock->LockExclusive();

    pArgs->pProcess->Release();
    pArgs->pOxid->Release();

    gpServerLock->UnlockExclusive();

    delete pArgs;

    return;
}

ORSTATUS
CProcess::UseProtseqIfNeeded(
                            IN USHORT cClientProtseqs,
                            IN USHORT aClientProtseqs[]
                            )
{
    ORSTATUS status;
    RPC_BINDING_HANDLE hBinding;
    UUID NullUuid = {0};
    USHORT wProtseqTowerId;

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: UseProtseqIfNeeded ==> %d\n",
               cClientProtseqs));

    // This process will be held alive by the OXID calling
    // us since it has an extra reference.

    CMutexLock process(&gcsFastProcessLock);

    // Another thread may have used the protseq in the mean time.

    ASSERT(_pdsaLocalBindings);

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: FindMatchingProtSeq from local bindings\n"));

    // ronans - initially _pdsaLocalBindings will hold bindings which have been set
    // by when the server called ServerAllocateOxidAndOids .. usually only local
    // protseqs LRPC or WMSG at that point.
    wProtseqTowerId = FindMatchingProtseq(cClientProtseqs,
                                          aClientProtseqs,
                                          _pdsaLocalBindings->aStringArray
                                         );

    if (0 != wProtseqTowerId)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Found protseq in local bindings\n"));

        return(OR_OK);
    }

    // No protseq shared between the client and the OXIDs' server.
    // Find a matching protseq.

    // check if its a solitary local protocol sequence LRPC or WMSG
    if (cClientProtseqs == 1 && IsLocal(aClientProtseqs[0]))
    {
        // if so - get it
        wProtseqTowerId = aClientProtseqs[0];
        ASSERT(wProtseqTowerId);
    }
    else
    // we have multiple protseqs - presumed to be nonlocal
    {
        // ensure we have custom protseq information
        if (!_fReadCustomProtseqs)
        {
            // use local temporary to avoid holding process lock
            DUALSTRINGARRAY *pdsaCustomProtseqs = NULL;

            // Release the lock before we call the server
            process.Unlock();

            hBinding = AllocateBinding();
            if (0 == hBinding)
                return(OR_NOMEM);
            
            status = RpcBindingSetObject(hBinding, &NullUuid);
            // get the information from the Object server
            if (status == RPC_S_OK)
            {
                status = ::GetCustomProtseqInfo(hBinding,cMyProtseqs, aMyProtseqs, &pdsaCustomProtseqs);
                
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "GetCustomProtseqInfo - status : %ld\n",
                           status));
            }

            FreeBinding(hBinding);

            if (status == RPC_S_OK)
            {
                // relock the process object
                process.Lock();

                // Make sure another thread didn't beat us.  Note that we're
                // assuming that the server (ole32) will give us back the same
                // answer each time.  If they don't, then shame on them.
                if (!_fReadCustomProtseqs)
                {
                    // Don't make any more calls to the server
                    _fReadCustomProtseqs = TRUE;

                    if (pdsaCustomProtseqs)
                    {
                        ASSERT(dsaValid(pdsaCustomProtseqs));
                    }
                    _pdsaCustomProtseqs = pdsaCustomProtseqs;
                }
                else
                {
                    // We got beat.  Free our copy
                    MIDL_user_free( pdsaCustomProtseqs );
                }
            }
            // else keep going.
            // CODEWORK: this error path should be tightened up in future --
            // ie, return an error at this point, and then re-try the
            // GetCustomProtseqInfo call until it succeeds.
        }
        USHORT i,j;

        // if there is custom protseq information - scan it for a match
        if (_pdsaCustomProtseqs)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Using custom protseq information\n"));

            wProtseqTowerId = FindMatchingProtseq(cClientProtseqs,
                                                  aClientProtseqs,
                                                  _pdsaCustomProtseqs->aStringArray);

            if (wProtseqTowerId)
            {
                ASSERT(FALSE == IsLocal(wProtseqTowerId));
            }
        }
        else
        // we don't have custom protseqs so use
        // the standard ones
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Using standard protseq information\n"));

            for (i = 0; i < cClientProtseqs && wProtseqTowerId == 0; i++)
            {
                for (j = 0; j < cMyProtseqs; j++)
                {
                    if (aMyProtseqs[j] == aClientProtseqs[i])
                    {
                        ASSERT(FALSE == IsLocal(aMyProtseqs[j]));

                        wProtseqTowerId = aMyProtseqs[j];
                        break;
                    }
                }
            }
        }
    }

    if (0 == wProtseqTowerId)
    {
        // No shared protseq, must be a bug since the client managed to call us.
        ASSERT(0 && "No shared protseq, must be a bug since the client managed to call us");
#if DBG
        if (cClientProtseqs == 0)
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Client OR not configured to use remote protseqs\n"));
        else
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Client called on an unsupported protocol:"
                       "%d %p %p \n",
                       cClientProtseqs,
                       aClientProtseqs,
                       aMyProtseqs));
#endif

        return(OR_NOSERVER);
    }

    process.Unlock();

    DUALSTRINGARRAY *pdsaBinding = 0;
    DUALSTRINGARRAY *pdsaSecurity = 0;

    hBinding = AllocateBinding();
    if (0 == hBinding)
    {
        return(OR_NOMEM);
    }

    status = RpcBindingSetObject(hBinding, &NullUuid);
    if (status == RPC_S_OK)
    {
        status = ::UseProtseq(hBinding,
                              wProtseqTowerId,
                              &pdsaBinding,
                              &pdsaSecurity);
        
    }

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: Lazy use protseq: %S (from towerid) in process %p - %d\n",
               GetProtseq(wProtseqTowerId),
               this,
               status));

    // Update this process' state to include the new bindings.
    if (!dsaValid(pdsaBinding))
    {
        if (pdsaBinding)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Use protseq returned an invalid dsa: %p\n",
                       pdsaBinding));
        }

        status = OR_NOMEM;
    }
    else
    {
        ASSERT(_pdsaLocalBindings);
        ASSERT(status == RPC_S_OK);
        status = ProcessBindings(pdsaBinding, pdsaSecurity);
    }

    if (pdsaBinding != NULL)
        MIDL_user_free(pdsaBinding);
    if (pdsaSecurity != NULL)
        MIDL_user_free(pdsaSecurity);

    FreeBinding(hBinding);
    return(status);
}


ORSTATUS CProcess::UpdateResolverBindings(DWORD64 dwBindingsID, DUALSTRINGARRAY* pdsaResolverBindings)
/*++

Routine Description:

    This function does the work of calling back into the server process
    to tell it to update its local OR bindings.   It also updates our
    cached local\remote bindings for this process object.

Arguments:

    dwBindingsID -- unique id of pdsaResolverBindings.  We use this
        to resolve what to do when async calls arrive\return in an
        out-of-order fashion.

    pdsaResolverBindings -- ptr to the new resolver bindings

Return Value:

    OR_OK -- success
    OR_NOMEM -- out of memory
    other -- unexpected error

--*/
{
    ORSTATUS status;
    RPC_BINDING_HANDLE hBinding;
    UUID NullUuid = {0};
    DUALSTRINGARRAY* pdsaBinding = NULL;
    DUALSTRINGARRAY* pdsaSecurity = NULL;
    BINDINGS_UPDATE_CALLBACK_STUFF* pArgs = NULL;

    CMutexLock process(&gcsFastProcessLock);

    if (dwBindingsID <= _dwCurrentBindingsID)
    {
        // The supplied bindings are the same or older than
        // what we already have, so ignore them.
        return OR_OK;
    }
		
    // if the server has not yet called _ServerAllocateOxidAndOids
    // then we will not yet have cached binding info for them, and
    // hence will be unable to construct a binding handle.  In
    // this case we simply do not update that process.  If this
    // happens we will give them the new bindings later, if and
    // when they do call _SAOAO.
    if (!_pdsaLocalBindings)
    {
        FlagsOn(PROCESS_NEEDSBINDINGS);
        return OR_OK;
    }
    
    // Done with the lock.
    process.Unlock();

    pArgs = new BINDINGS_UPDATE_CALLBACK_STUFF;
    if (!pArgs)
        return OR_NOMEM;

    ZeroMemory(pArgs, sizeof(BINDINGS_UPDATE_CALLBACK_STUFF));

    // Allocate binding.  We must hold onto the binding handle
    // until the async call has completed.
    status = OR_NOMEM;
    hBinding = AllocateBinding();
    if (hBinding)
    {
        status = RpcBindingSetObject(hBinding, &NullUuid);
        if (status == RPC_S_OK)
        {
            status = RpcAsyncInitializeHandle(&(pArgs->async), sizeof(pArgs->async));
        }
    }

    // Check for errors
    if (status != RPC_S_OK)
    {
        if (hBinding) FreeBinding(hBinding);
        delete pArgs;
        return status;
    }

    // Init parts of the RPC_ASYNC_STATE struct that we care about
    pArgs->async.Flags = 0;  // the absence of RPC_C_NOTIFY_ON_SEND_COMPLETE flag means
                             // notify us on call completion, and no sooner.
    pArgs->async.UserInfo = pArgs;
    pArgs->async.NotificationType = RpcNotificationTypeCallback;
    pArgs->async.u.NotificationRoutine = CProcess::AsyncRpcNotification;

    // Init other stuff
    pArgs->dwSig = BINDINGUPDATESTUFF_SIG;
    pArgs->pProcess = this;
    pArgs->dwBindingsID = dwBindingsID;
    pArgs->hBinding = hBinding;

    // Take a non-client reference (will not stop rundown) on
    // ourselves, to be owned implicitly by the async call
    this->Reference();

    // Issue async call

    status = ::UpdateResolverBindings(
                    &(pArgs->async),
                    _hProcess,
                    pdsaResolverBindings,
                    &(pArgs->dwBindingsID),
                    &(pArgs->pdsaNewBindings),
                    &(pArgs->pdsaNewSecurity));
    
    if (status != RPC_S_OK)
    {
        // If we get anything other than RPC_S_OK back, that
        // means we will not receive a call completion notif-
        // ication.   So, we need to cleanup everything up
        // right here in that case.
        FreeBinding(hBinding);
        this->Release();
        delete pArgs;
    }
    else
    {
        DWORD dwAUO = (DWORD)InterlockedIncrement((PLONG)&_dwAsyncUpdatesOutstanding);

        // This assert is somewhat arbitrary, if it fires there are
        // one of two things wrong:  1) the machine is so totally
        // overstressed that the async calls are piling up and are not
        // getting enough cpu time to complete; or 2) more likely, the
        // process in question is deadlocked somehow.
        ASSERT(dwAUO < 5000);
    }

    return status;
}

void
CProcess::BindingsUpdateNotify(RPC_BINDING_HANDLE hBinding,
                               DWORD64 dwBindingsID,
                               DUALSTRINGARRAY* pdsaNewBindings,
                               DUALSTRINGARRAY* pdsaSecBindings,
                               HRESULT hrReturn)
/*++

Routine Description:

    Private helper function.   This function is used to process a
    successful return from an async call to the process to update
    the bindings.

Arguments:

    hBinding -- binding handle used to make the call.  We now own it,
        either to keep or to cleanup.

    dwBindingsID -- unique id of the updated bindings.  We use this
        to resolve what to do when async calls arrive\return in an
        out-of-order fashion.

    pdsaNewBindings -- new bindings in use by the process.  We now own
         it, either to keep or to cleanup

    pdsaSecBindings -- new security bindings in use by the process.  We
         now own it, either to keep or to cleanup.

    hrReturn -- the result of the operation.

Return Value:

    void

--*/
{
    RPC_STATUS status;

    // Always free the binding
    FreeBinding(hBinding);

    // Only process the out-params if the operation was a success; otherwise
    // ignore everthing.
    if (hrReturn == S_OK)
    {
        // Take lock while looking at _dwCurrentBindingsID
        CMutexLock process(&gcsFastProcessLock);

        // Only process the out-params if they contain newer bindings
        // than what we currently have cached.
        if ((dwBindingsID > _dwCurrentBindingsID) &&
            pdsaNewBindings &&
            pdsaSecBindings)
        {
            // The process has the right bindings, so update our counter
            // no matter what happens in ProcessBindings.
            _dwCurrentBindingsID = dwBindingsID;

            status = ProcessBindings(pdsaNewBindings, pdsaSecBindings);
        }

        // No lock needed from here on out
        process.Unlock();

        // Cleanup allocated out-params
        if (pdsaNewBindings != NULL)
            MIDL_user_free(pdsaNewBindings);
        if (pdsaSecBindings != NULL)
            MIDL_user_free(pdsaSecBindings);
    }
    else
    {
        // Assert that on an error path we are not leaking memory.
        ASSERT(NULL == pdsaNewBindings);
        ASSERT(NULL == pdsaSecBindings);
    }

    InterlockedDecrement((PLONG)&_dwAsyncUpdatesOutstanding);

    return;
}


void RPC_ENTRY
CProcess::AsyncRpcNotification(RPC_ASYNC_STATE* pAsync,
                               void* pContext,
                               RPC_ASYNC_EVENT Event)
/*++

Routine Description:

    RPC calls this static function when an async call to a server
    process returns.

Arguments:

    pAsync -- pointer to the async rpc state struct

    pContext -- rpc thingy, we ignore it

    Event -- should always be RpcCallComplete

Return Value:

    void

--*/
{
    RPC_STATUS status;
    HRESULT hrRetVal;
    BINDINGS_UPDATE_CALLBACK_STUFF* pArgs;

    pArgs = (BINDINGS_UPDATE_CALLBACK_STUFF*)
            (((char*)pAsync) - offsetof(BINDINGS_UPDATE_CALLBACK_STUFF, async));

    ASSERT(pArgs->async.UserInfo = pArgs);
    ASSERT(pArgs->dwSig == BINDINGUPDATESTUFF_SIG);
    ASSERT(pArgs->hBinding);
    ASSERT(pArgs->pProcess);
    ASSERT(pArgs->dwBindingsID > 0);
    ASSERT(pAsync->Event == RpcCallComplete);
    ASSERT(Event == RpcCallComplete);

    // Complete the call.  Since we've asked for a direct callback upon
    // completion, we should never get back RPC_S_ASYNC_CALL_PENDING, so
    // we assert on this.  Otherwise, both RPC and the server need to
    // return success before we do further processing.
    status = RpcAsyncCompleteCall(&(pArgs->async), &hrRetVal);
    ExamineRpcAsyncCompleteCallReturnCode(status);

    // Deliver notification to process object.  Process may have
    // already been rundown, that's okay.   BindingsUpdateNotify will
    // own/cleanup the params, see code.
    pArgs->pProcess->BindingsUpdateNotify(pArgs->hBinding,
                                pArgs->dwBindingsID,
                                pArgs->pdsaNewBindings,
                                pArgs->pdsaNewSecurity,
                                (status == RPC_S_OK) ? hrRetVal : E_FAIL);

    gpServerLock->LockExclusive();

    // This may be the last release on the process object
    pArgs->pProcess->Release();

    gpServerLock->UnlockExclusive();

    delete pArgs;

    return;
}


void 
CProcess::FlagsOn(DWORD dwOn)
{
    for (;;)
    {
        DWORD dwCurrent = _dwFlags;
        DWORD dwNew = dwCurrent | dwOn;
        if (dwCurrent == (ULONG)InterlockedCompareExchange(
                                           (LONG*)&_dwFlags,
                                           dwNew,
                                           dwCurrent)) 
        {
            break;
        }
    }
}

void 
CProcess::FlagsOff(DWORD dwOff)
{
    for (;;)
    {
        DWORD dwCurrent = _dwFlags;
        DWORD dwNew = dwCurrent & ~dwOff;
        if (dwCurrent == (ULONG)InterlockedCompareExchange(
                                           (LONG*)&_dwFlags,
                                           dwNew,
                                           dwCurrent)) 
        {
            break;
        }
    }
}


CBList *gpProcessList = 0;

CProcess *
ReferenceProcess(
                IN PVOID key,
                IN BOOL fNotContext)
/*++

Routine Description:

    Used to find a CProcess and get a reference on it

Arguments:

    key - The dword key of the process allocated in _Connect.
    fNotContext - Normally the key is stored as a context handle
        which means locking is unnecessary.  There is an extra
        refernce which is released buring context rundown which
        means managers using the key as a context handle
        a) Don't need to lock the process and
        b) Don't need to call ReleaseProcess()

Return Value:

    0 - invalid key
    non-zero - The process.

--*/
{
    ASSERT(gpProcessList != 0);
    CProcess *pProcess;

    if (!key)
        return NULL;
	
    gpProcessListLock->LockShared();

    if (gpProcessList->Member(key) == FALSE)
    {
      gpProcessListLock->UnlockShared();
      return(0);
    }

    pProcess = (CProcess *)key;

    if (fNotContext)
    {
        pProcess->ClientReference();
    }

    gpProcessListLock->UnlockShared();
    return(pProcess);
}

void ReleaseProcess(CProcess *pProcess)
/*++

Routine Description:

    Releases a pProcess object.  This should only be called when
    a process object has been referenced with the fNotContext == TRUE.

Arguments:

    pProcess - the process to release.  May actually be deleted.

Return Value:

    None

--*/
{
    gpProcessListLock->LockExclusive();

    if (pProcess->ClientRelease() == 0)
    {
        // Process has been completely released,
        // we'll remove it from the list now since we
        // already have the lock.  It may not have been
        // added, so this may fail.

        PVOID t = gpProcessList->Remove(pProcess);
        ASSERT(t == pProcess || t == 0);

        gpProcessListLock->UnlockExclusive();

        // The client process owns one real reference which will be
        // released in Rundown().

        pProcess->Rundown();
    }
    else
    {
      gpProcessListLock->UnlockExclusive();
    }
}

BOOL VerifyNewProcess(DWORD dwPID)
/*++

Routine Description:

    Checks to see if we already have a registered active
    process with the specified pid.

Arguments:

    dwPID - pid of the new client

Return Value:

    TRUE - the process is not known to us
    FALSE - an existing entry already exists for this pid

Notes:   there is a tiny race between the time a process dies
    an abnormal death and the time we receive the rundown.  To
    try to account for this, we allow up to MAX_ENTRIES_PER_PID
    registrations for a single pid.

--*/
{
    ASSERT(gpProcessListLock->HeldExclusive());

    CProcess* pProcess;
    CBListIterator itor(gpProcessList);
    DWORD dwCurrentEntries = 0;
    const DWORD MAX_ENTRIES_PER_PID = 10;

    while (pProcess = (CProcess*)itor.Next())
    {
        if ((pProcess->GetPID() == dwPID) &&
            (!pProcess->HasBeenRundown()))
        {
            dwCurrentEntries++;
        }
    }

    return (dwCurrentEntries <= MAX_ENTRIES_PER_PID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\worker.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Worker.cxx

Abstract:

    Backgroup activies releated to running down and cleaning up OR and pinging
    remote OR's are handled here.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-02-95    Bits 'n pieces
    MarioGo     01-18-96    Locally unique IDs

--*/

#include <or.hxx>

static CInterlockedInteger cTaskThreads(0);

#if DBG_DETAIL
extern "C" void printf(char *, ...);
#endif

#define TASKTHREAD_STACK_PAGES  3

#define SECS_BETWEEN_FLUSHES 30

PWR_STATE gPowerState = PWR_RUNNING;

void OLESCMBindingHandleFlush();

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD WINAPI
ObjectExporterWorkerThread(LPVOID /* ignored */)
/*++

Routine Description:

    Main background thread for the object resolver.  This thread
    manages a number of background tasks:
        Cleaning up the client oxid cache.
        Running down un-pinged sets.
        Starting task threads to rundown server OIDs and ping sets.

    This thread must not block for a long time.  Task threads
    should be used for possibly blocking operations like remote
    pinging and rundown of OIDs.

Arguments:

    Ignored

Return Value:

    None - should never return.

--*/
{
    ORSTATUS status;
    CTime    now(0);
    CTime    timeout(0);
    CTime    delay(0);
    CTime    start(0);
    CTime    lastflush(0);
    BOOL     fCreateThread;
    SYSTEM_INFO si;

    // Retrieve system info so we can start task threads
    // with an appropriate initial stack size
    GetSystemInfo(&si);

    lastflush.SetNow();

    for(;;)
        {
        now.SetNow();
        delay = now;
        delay += BasePingInterval;

        // Cleanup old sets.
        //
        // Sets are usually cleaned up during processing of pings.  (As one set is
        // pinged, the next set will be checked to see if it needs to be rundown.)
        //
        // If there's exactly one set in the table, then it won't be run down except
        // by this thread.
        //
        // NOTE: Similar code in _SimplePing().

        gpServerLock->LockShared();

        ID setid = gpServerSetTable->CheckForRundowns();
        if (setid)
        {
            gpServerLock->ConvertToExclusive();

            if (gpServerSetTable->RundownSetIfNeeded(setid))
            {
                delay.SetNow();
            }

            gpServerLock->UnlockExclusive();
        }
        else
        {
            gpServerLock->UnlockShared();
        }

        //
        // Cleanup old Client OXIDs
        //
        if (gpClientOxidPList->PeekMin(timeout))
        {
            if (timeout < now)
            {
                CClientOxid *pOxid;
                CListElement *ple;

                gpClientLock->LockExclusive();

                while (ple = gpClientOxidPList->MaybeRemoveMin(now))
                {
                    pOxid = CClientOxid::ContainingRecord(ple);
                    delete pOxid;
                }
                gpClientLock->UnlockExclusive();

                delay.SetNow();
            }
            else
            {
                if (delay > timeout)
                {
                    delay = timeout;
                }
            }
        }

        //
        // Make sure pinging and rundowns are proceding
        //
        fCreateThread = FALSE;

        // We want to create an extra task thread if we've fallen
        // behind on pings.  As more threads are created the
        // requirements for "behind" become harder to meet.
        if (gpClientSetPList->PeekMin(timeout))
        {
            start = now;
            start += (BasePingInterval + 10*cTaskThreads);

            if (cTaskThreads == 0 || start < timeout)
            {
                fCreateThread = TRUE;
            }
            else
            {
                if (delay > start)
                {
                    delay = start;
                }
            }
        }

        // We want to create an extra task thread if we've fallen
        // behind in running down local objects.  As more threads are
        // created the requirements for "behind" become harder to meet.
        if (gpServerOidPList->PeekMin(timeout))
        {
            start = now;
            start -= 10*cTaskThreads;
            if (timeout < start)
            {
                fCreateThread = TRUE;
            }
            else
            {
                start = timeout;
                start += 2*10*cTaskThreads;
                if (delay > start)
                {
                    delay = start;
                }
            }
        }

        if (fCreateThread)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Creating additional task thread, we're behind..\n"));

            cTaskThreads++;

            DWORD tid;
            HANDLE hThread =  CreateThread(0,
                                           (si.dwPageSize * TASKTHREAD_STACK_PAGES),
                                           ObjectExporterTaskThread,
                                           0,
                                           0,
                                           &tid
                                           );
            if (0 != hThread)
            {
                CloseHandle(hThread);
            }
            else
            {
                cTaskThreads--;
            }
        }

#if DBG_DETAIL
        printf("================================================================\n"
               "ServerOxids: %d, ServerOids: %d, ServerSets: %d\n"
               "ClientOxids: %d, ClientOids: %d, ClientSets: %d\n"
               "Mids: %d, Processes %d, worker threads: %d\n"
               "Sleeping for %d seconds...\n",
               gpServerOxidTable->Size(),
               gpServerOidTable->Size(),
               gpServerSetTable->Size(),
               gpClientOxidTable->Size(),
               gpClientOidTable->Size(),
               gpClientSetTable->Size(),
               gpMidTable->Size(),
               gpProcessList->Size(),
               cTaskThreads,
               delay - now + 1
               );
#endif

        delay += 1;

        if (delay - lastflush > SECS_BETWEEN_FLUSHES)
        {       
            // Give olescm a chance to do other work
            OLESCMBindingHandleFlush();
            
            lastflush.SetNow();
        }

        delay.Sleep();
    }

   return(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


void 
NotifyCOMOnSuspend()
/*++

Routine Desciption

    Resets state and takes appropriate action when the machine
    goes into a standby (or, hibernate) state.

Arguments:

    none

Return Value:

    void

--*/
{
    ASSERT(gPowerState == PWR_RUNNING);

    // Set the flag immediately.  Don't need to do this 
    // under the lock, so do it right away.
    gPowerState = PWR_SUSPENDED;

    // Take and release gpServerLock.  This guarantees that no
    // worker threads are in an in-between state (eg, they didn't see
    // the gPowerState change above and are currently preempted right 
    // before checking for eligible serversets or oids to rundown).
    gpServerLock->LockExclusive();
    gpServerLock->UnlockExclusive();
	
    return;
}


void 
NotifyCOMOnResume()
/*++

Routine Desciption

    Resets state and takes appropriate action when the machine
    starts running again after being in the standby/hibernate
    state.

Arguments:

    none

Return Value:

    void

--*/
{
    // We cannot assert here that we're suspended, since the machine
    // can suspend in critical situations w/o notifying us

    //
    // First reset all of the server pingset timers.
    //
    gpServerLock->LockExclusive();

    gpServerSetTable->PingAllSets();

    gpServerLock->UnlockExclusive();

    //
    // Second reset all of the non-referenced oid timeouts,
    // so they don't get erroneously rundown.
    //
    gpServerOidPList->ResetAllOidTimeouts();

    //
    // Last, reset the power state so that future
    // rundowns will not be blocked.
    //
    gPowerState = PWR_RUNNING;

    return;
}



BOOL
RundownOidsHelper(
		IN CTime* pNow, 
		IN CServerOxid* pOxidToRundown) // can be NULL
/*++

Routine Desciption

    This function exists so that all of the oid rundown processing
    code (well most of it) is in one place.   Caller supplies his
    "now" and an optional oxid to try to rundown oids from.

    Caller must hold gpServerLock when calling.   gpServerLock will
    be released before returning.

Arguments:

    pNow -- caller's Now

    pOxidToRundown -- optional pointer to oxid from which caller
    	wants us to try to rundown oids.   If NULL, we simply
    	use the first eligible oid from any oxid.

Return Value:

    TRUE -- One or more oids was processed for rundown
    FALSE -- Zero oids were processed for rundown

--*/
{
    CServerOid*   pOid = NULL;
    ULONG         cOids = 0;
    CServerOid*   apOid[MAX_OID_RUNDOWNS_PER_CALL];

    ASSERT(pNow);
    ASSERT(gpServerLock->HeldExclusive());

    // If not running (either we're about to be suspended or we
    // we just came out of suspension) don't run anything down.
    if (gPowerState != PWR_RUNNING)
    {
        gpServerLock->UnlockExclusive();
        return FALSE;
    }
	
    if (!pOxidToRundown)
    {
        pOid = gpServerOidPList->RemoveEligibleOid(*pNow);        
    }
    else
    {
        pOid = gpServerOidPList->RemoveEligibleOidWithMatchingOxid(*pNow, pOxidToRundown);
    }

    if (!pOid)
    {
        // nothing to rundown, either in general or
        // for the specified oxid.
        gpServerLock->UnlockExclusive();
        return FALSE;
    }

    // If caller didn't supply an oxid, use the oid's oxid.
    if (!pOxidToRundown)
    {
        pOxidToRundown = pOid->GetOxid();
    }

    ASSERT(pOxidToRundown);

    ZeroMemory(apOid, sizeof(apOid));

    do
    {
        ASSERT(pOid);
        ASSERT(pOid->IsFreed() == FALSE);
        ASSERT(pOid->IsPinned() == FALSE);
        ASSERT(pOid->IsRunningDown() == FALSE);
        ASSERT(pOid->GetOxid() == pOxidToRundown);

        pOid->SetRundown(TRUE);
        apOid[cOids] = pOid;
        cOids++;

        if (cOids == MAX_OID_RUNDOWNS_PER_CALL)
        {
            break;
        }

        pOid = gpServerOidPList->RemoveEligibleOidWithMatchingOxid(*pNow, pOxidToRundown);

    } while (pOid);

    ASSERT((cOids > 0) && (cOids <= MAX_OID_RUNDOWNS_PER_CALL));

    // Note: This call will unlock the server lock. While
    // this happens the oids maybe added, deleted, added
    // and deleted, added and rundown from one or more sets.    
    pOxidToRundown->RundownOids(cOids, apOid);

    // Assert RundownOids released the lock
    ASSERT(!gpServerLock->HeldExclusive());

    return TRUE;
} 



DWORD WINAPI
ObjectExporterTaskThread(LPVOID /* ignored */)
{
    CTime          now(0);
    CTime          delay(0);
    CTime          timeout(0);
    ORSTATUS       status;
    CListElement  *ple;
    CClientSet    *pSet;
    CServerOid    *pOid;

    enum {
         Idle,     // No work to do at all.
         Waiting,  // No work to do yet.
         Busy      // Did work this iteration.
         }     eState;

    for(;;)
	{
        now.SetNow();
        delay = now;
        delay += BasePingInterval;
        eState = Idle;

        // Ping remote sets.

        if (gpClientSetPList->PeekMin(timeout))
        {
            eState = Waiting;

            if (now >= timeout)
            {
                eState = Busy;

                ple = gpClientSetPList->MaybeRemoveMin(now);

                if (ple)
                {
                    // Actually ping the set

                    pSet = CClientSet::ContainingRecord(ple);

                    pSet->PingServer();

                    // Set maybe invalid now.
                }
            }
            else
            {
                // Not ready to ping yet.
                delay = timeout;
            }
        }

        //
        // Process server OID rundowns
        //
        if (gpServerOidPList->PeekMin(timeout))
        {
            if (eState == Idle)
                eState = Waiting;

            if (now >= timeout)
            {
                eState = Busy;

                gpServerLock->LockExclusive();

                BOOL fRanSomethingDown = RundownOidsHelper(&now, NULL);
                    
                // Assert RundownOidsHelper released the lock
                ASSERT(!gpServerLock->HeldExclusive());

                // If we didn't actually try to run any oids down, reset 
                // state to Waiting so we don't spin unnecessarily.
                if (!fRanSomethingDown)
                {
                    eState = Waiting;
                }
            }
            else
            {
                // Not ready to rundown yet.
                if (delay > timeout)
                {
                    delay = timeout;
                }
            }
        }

        // Decide if this task thread should exit or sleep and loop.
        ASSERT(eState == Idle || eState == Busy || eState == Waiting);

        if ((eState == Idle) || (eState == Waiting && cTaskThreads > 2))
        {
            // No work or we're all caught up and have extra threads.
            cTaskThreads--;
            return(0);
        }
        else
        {
            if (eState == Waiting)
            {
                // Sleep until just after the next work item is ready.
                delay += 1;
                delay.Sleep();
            }
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\token.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Token.cxx

Abstract:

    Implementation for Windows NT security interfaces.

Platform:

    Windows NT user mode.

Notes:

    Not portable to non-Windows NT platforms.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     12/21/1995    Bits 'n pieces

--*/

#include <or.hxx>
#include <aclapi.h>
#include <winsaferp.h>
#include <access.hxx>

CRITICAL_SECTION gcsTokenLock;


ORSTATUS
LookupOrCreateTokenFromHandle(
    IN  HANDLE hClientToken,
    OUT CToken **ppToken
    )
/*++

Routine Description:

    Finds or allocates a new token object for the caller.

Arguments:

    hCaller - RPC binding handle of the caller of RPCSS.

    pToken - Upon a successful return this will hold the token.
             It can be destroyed by calling Release();

Return Value:


    OR_OK - success
    OR_NOMEM - Unable to allocate an object.

--*/
{
    ORSTATUS status;
    UINT type;
    LUID luid;
    PTOKEN_USER ptu;
    TOKEN_STATISTICS ts;
    BOOL fSuccess;
    DWORD needed;
    HANDLE hJobObject = NULL;
    LUID luidMod;
    
    needed = sizeof(ts);
    fSuccess  = GetTokenInformation(hClientToken,
                                    TokenStatistics,
                                    &ts,
                                    sizeof(ts),
                                    &needed
                                    );
    if (!fSuccess)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: GetTokenInfo failed %d\n",
                   GetLastError()));

        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        status = OR_NOMEM;
        goto Cleanup;
        }

    luid = ts.AuthenticationId;
    luidMod = ts.ModifiedId;
    //
    // Check if the token is already in the list
    //

    {
    CMutexLock lock(&gcsTokenLock);

    CListElement *ple;

    ple = gpTokenList->First();

    fSuccess = FALSE;
    while(ple)
        {
        CToken *pToken = CToken::ContainingRecord(ple);

        if (pToken->MatchLuid(luid) &&
	    (pToken->MatchModifiedLuid(luidMod)) &&
            (S_OK == pToken->MatchToken(hClientToken, TRUE)))
            {
            pToken->AddRef();
            *ppToken = pToken;
            status = OR_OK;
            fSuccess = TRUE;
            break;
            }
        else
            {
            ple = ple->Next();
            }
        }
    }

    if (fSuccess)
        {
        status = OR_OK;
        CloseHandle(hClientToken);
        goto Cleanup;
        }

    //
    // New user, need to allocate a token object.
    //

    // Lookup the SID to store in the new token object.

    needed = DEBUG_MIN(1, 0x2c);

    do
        {
        ptu = (PTOKEN_USER)alloca(needed);
        ASSERT(ptu);

        fSuccess = GetTokenInformation(hClientToken,
                                       TokenUser,
                                       (PBYTE)ptu,
                                       needed,
                                       &needed);

        // If this assert is hit increase the 24 both here and above
        ASSERT(needed <= 0x2c);
        }
    while (   fSuccess == FALSE
           && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

    if (!fSuccess)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: GetTokenInfo (2) failed %d\n",
                   GetLastError()));

        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        status = OR_NOMEM;
        goto Cleanup;
        }

    PSID psid;
    psid = ptu->User.Sid;
    ASSERT(IsValidSid(psid) == TRUE);

    // Allocate the token object

    needed = GetLengthSid(psid) - sizeof(SID);
    *ppToken = new(needed)  CToken(hClientToken,
                                   hJobObject,
                                   luid,
                                   psid,
                                   needed + sizeof(SID));

    if (*ppToken)
        {
        CMutexLock lock(&gcsTokenLock);

        (*ppToken)->Insert();

        status = OR_OK;

        #if DBG_DETAIL
            {
            DWORD d = 50;
            WCHAR buffer[50];
            GetUserName(buffer, &d);
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: New user connected: %S (%p)\n",
                       buffer,
                       *ppToken));
            }
        #endif

        }
    else
        {
        status = OR_NOMEM;
        }

Cleanup:

    if (OR_OK != status)
        {
        if (NULL != hJobObject)
            CloseHandle(hJobObject);
        }

    // status contains the result of the operation.

    return(status);
}


ORSTATUS
LookupOrCreateTokenForRPCClient(
    IN  handle_t hCaller,
    IN  BOOL fAllowUnsecure,
    OUT CToken **ppToken,
    OUT BOOL* pfUnsecure
    )
/*++

Routine Description:

    Finds or allocates a new token object for the caller.

Arguments:

    hCaller - RPC binding handle of the caller of RPCSS.

    fAllowUnsecure - whether to return a token for an unsecure 
           caller, or an error instead.

    pToken - Upon a successful return this will hold the token.
             It can be destroyed by calling Release();

    pfUnsecure - Upon a successful return this will determine if
             the caller was unsecure or not.

Return Value:

    OR_OK - success
    OR_NOACCESS - error occurred, or client was unsecure and !fAllowUnsecure
    OR_NOMEM - Unable to allocate an object.

--*/
{
    RPC_STATUS status = RPC_S_OK;
    HANDLE hClientToken = 0;
    BOOL fSuccess = FALSE;
    BOOL fUsedAnonymousToken = FALSE;

    if (pfUnsecure)
        *pfUnsecure = FALSE;
    
    status = RpcImpersonateClient(hCaller);
    if (status == RPC_S_CANNOT_SUPPORT)
    {
        // Check if the caller will accept an unsecure client
        if (!fAllowUnsecure)
        {
            return OR_NOACCESS;
        }
    	
        //
        // Getting back RPC_S_CANNOT_SUPPORT from RpcImpClient
        // signifies that the client is _intentionally_ making an
        // unsecure call.  Until .NET Server we had a lot of
        // custom code for handling this case in RPCSS.  Now we map
        // such users to the Anonymous identity.  This is a DCOM-specific
        // policy decision.  The reasoning behind this is that it allows
        // COM servers (that care) to allow access to such clients access 
        // in a programmatic way by granting access to Anonymous.  See
        // comments in CheckForAccess in ole32\dcomss\olescm\security.cxx.
        //
        fSuccess = ImpersonateAnonymousToken(GetCurrentThread());
        if (!fSuccess)
        {
            return OR_NOACCESS;
        }
        fUsedAnonymousToken = TRUE;

        // This caller is considered "unsecure"
        if (pfUnsecure)
            *pfUnsecure = TRUE;        
    }
    else if (status != RPC_S_OK)
    {
        return OR_NOACCESS;
    }

    fSuccess = OpenThreadToken(GetCurrentThread(),
                               TOKEN_ALL_ACCESS,
                               TRUE,
                               &hClientToken);

    if (fSuccess)
    {
        status = LookupOrCreateTokenFromHandle(hClientToken, ppToken);
        if(OR_OK == status)
        {
            // The token object now controls the life of the token handle
            hClientToken = 0;
        }
        else
        {
            CloseHandle(hClientToken);
            hClientToken = 0;
        }
    }
    else
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: OpenThreadToken failed %d\n",
                   GetLastError()));
        
        status = OR_NOMEM;
        ASSERT(hClientToken == 0);
        goto Cleanup;
    }
        
Cleanup:
	
    // status contains the result of the operation.    
    if (fUsedAnonymousToken)
    {
        fSuccess = RevertToSelf();
        ASSERT(fSuccess);
    }
    else
    {
        RPC_STATUS t = RpcRevertToSelfEx(hCaller);
        ASSERT(t == RPC_S_OK);
    }

    return(status);
}

CToken::~CToken()
{
    ASSERT(_lHKeyRefs == 0);
    ASSERT(_hHKCRKey == NULL);

    if (_hHKCRKey != NULL)
    {
        // Shouldn't happen...but close it anyway just in
        // case.  Assert above will catch this if it occurs
        RegCloseKey(_hHKCRKey);
    }

    CloseHandle(_hImpersonationToken);

    if (NULL != _hJobObject)
        {
        TerminateJobObject(_hJobObject, 0);
        CloseHandle(_hJobObject);
        }
}

STDMETHODIMP CToken::QueryInterface(REFIID riid, LPVOID* ppv)
{
    if (riid == IID_IUnknown || riid == IID_IUserToken)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CToken::AddRef()
{
    return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CToken::Release()
{
    LONG lNewRefs;

    CMutexLock lock(&gcsTokenLock);

    lNewRefs = InterlockedDecrement(&_lRefs);
    if (lNewRefs == 0)
    {
        Remove();
        delete this;
    }

    return lNewRefs;
}


STDMETHODIMP 
CToken::GetUserClassesRootKey(HKEY* phKey)
{
    CMutexLock lock(&gcsTokenLock);
    HRESULT hr = S_OK;
    
    if ( _lHKeyRefs++ == 0 )
    {
        ASSERT(_hHKCRKey == NULL);

        // The original IUserToken implementation allowed for not
        // having a token. That should never happen with a CToken.
        ASSERT(_hImpersonationToken);

        // Open per-user hive
        LONG lRet = RegOpenUserClassesRoot(_hImpersonationToken, 
                                           0, 
                                           KEY_READ, 
                                           &_hHKCRKey);
        if (lRet != ERROR_SUCCESS)
        {
           // Failed to open the user's HKCR.  We're going to use 
           // HKLM\Software\Classes.
           lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                L"Software\\Classes",
                                0,
                                KEY_READ,
                                &_hHKCRKey);
           if (lRet != ERROR_SUCCESS) 
           {
              _hHKCRKey = NULL;
              --_lHKeyRefs;
              hr = HRESULT_FROM_WIN32(lRet);
	   }
        }
    }
    *phKey = _hHKCRKey;
    return hr;
}

STDMETHODIMP 
CToken::ReleaseUserClassesRootKey()
{
    CMutexLock lock(&gcsTokenLock);
    if (_hHKCRKey && (--_lHKeyRefs == 0) )
    {
        ASSERT(_hHKCRKey != HKEY_CLASSES_ROOT);
        RegCloseKey(_hHKCRKey);
        _hHKCRKey = NULL;
    }
    return S_OK;
}

STDMETHODIMP 
CToken::GetUserSid(BYTE **ppSid, USHORT *pcbSid)
{
    // IUserToken interface assumes that sid lengths always
    // <= USHRT_MAX.  Truncating here on purpose; assert is
    // to catch cases where this is a bad idea.  GetLengthSid
    // is a very cheap call, so there's no need to cache it.
    DWORD dwSidLen = GetLengthSid(&_sid);
    ASSERT(dwSidLen <= USHRT_MAX);

    *pcbSid = (USHORT)dwSidLen;
    *ppSid = (BYTE*)&_sid;

    return S_OK;
}

STDMETHODIMP 
CToken::GetUserToken(HANDLE* phToken)
{
    *phToken = _hImpersonationToken;
    return S_OK;
}

void
CToken::Impersonate()
{
    ASSERT(_hImpersonationToken);

    BOOL f = SetThreadToken(0, _hImpersonationToken);
    ASSERT(f);

    return;
}

void
CToken::Revert()
{
    BOOL f = SetThreadToken(0, 0);
    ASSERT(f);
    return;
}

ULONG GetSessionId2(
    HANDLE hToken)
{
    BOOL  Result;
    ULONG SessionId = 0;
    ULONG ReturnLength;

    //
    // Use the _HYDRA_ extension to GetTokenInformation to
    // return the SessionId from the token.
    //

    Result = GetTokenInformation(
                 hToken,
                 TokenSessionId,
                 &SessionId,
                 sizeof(SessionId),
                 &ReturnLength
                 );

    if( !Result ) {
        SessionId = 0; // Default to console
    }

    return SessionId;
}

ULONG CToken::GetSessionId()
{
    return GetSessionId2(_hImpersonationToken);
}

BOOL CToken::MatchModifiedLuid(LUID luid)
{
   ASSERT(_hImpersonationToken);

   TOKEN_STATISTICS ts;
   BOOL fSuccess;
   DWORD needed;
   LUID luidMod;
   needed = sizeof(ts);
   fSuccess  = GetTokenInformation(_hImpersonationToken,
                                   TokenStatistics,
                                   &ts,
                                   sizeof(ts),
                                   &needed
                                   );
   if (!fSuccess)
       {
       KdPrintEx((DPFLTR_DCOMSS_ID,
                  DPFLTR_WARNING_LEVEL,
                  "OR: GetTokenInfo failed %d\n",
                  GetLastError()));

       ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
       return FALSE;
      }
   luidMod = ts.ModifiedId;
   return(   luidMod.LowPart == luid.LowPart
          && luidMod.HighPart == luid.HighPart);
}

HRESULT CompareRestrictedSids(
    HANDLE hToken1,
    HANDLE hToken2)
{
    HRESULT hr = S_OK;
    PSID pRestrictedSid1 = NULL;
    PSID pRestrictedSid2 = NULL;

#if(_WIN32_WINNT >= 0x0500)
    PTOKEN_GROUPS pSids1;
    PTOKEN_GROUPS pSids2;
    NTSTATUS error;
    ULONG needed;

    //Get restricted SIDs.
    needed = DEBUG_MIN(1, 300);
    do
    {
        pSids1 = (PTOKEN_GROUPS) alloca(needed);

        error = NtQueryInformationToken(hToken1,
                                        TokenRestrictedSids,
                                        pSids1,
                                        needed,
                                        &needed);

    }
    while (error == STATUS_BUFFER_TOO_SMALL);

    if(!error && pSids1->GroupCount > 0)
    {
        pRestrictedSid1 = pSids1->Groups[0].Sid;
    }

    //Get restricted SIDs.
    needed = DEBUG_MIN(1, 300);
    do
    {
        pSids2 = (PTOKEN_GROUPS) alloca(needed);

        error = NtQueryInformationToken(hToken2,
                                        TokenRestrictedSids,
                                        pSids2,
                                        needed,
                                        &needed);

    }
    while (error == STATUS_BUFFER_TOO_SMALL);

    if(!error && pSids2->GroupCount > 0)
    {
        pRestrictedSid2 = pSids2->Groups[0].Sid;
    }

    if(pRestrictedSid1 && pRestrictedSid2)
    {
        //We have two restricted tokens.
        //Compare the first restricted SID.
        if(EqualSid(pRestrictedSid1, pRestrictedSid2))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else if(pRestrictedSid1 || pRestrictedSid2)
    {
        //We have one restricted token and one normal token.
        hr = S_FALSE;
    }
    else
    {
        //We have two normal tokens.
        hr = S_OK;
    }

#endif //(_WIN32_WINNT >= 0x0500)
    return hr;
}


HRESULT
CToken::MatchToken(
    IN  HANDLE hToken,
    IN  BOOL bMatchRestricted)
{
    HRESULT hr;
    NTSTATUS error;
    PTOKEN_USER ptu;
    DWORD needed = DEBUG_MIN(1, 0x2c);

    //Get the user SID.
    do
    {
        ptu = (PTOKEN_USER)alloca(needed);

        error = NtQueryInformationToken(hToken,
                                        TokenUser,
                                        (PBYTE)ptu,
                                        needed,
                                        &needed);

        // If this assert is hit increase the 24 both here and above
        ASSERT(needed <= 0x2c);
    }
    while (error == STATUS_BUFFER_TOO_SMALL);

    if (error)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: GetTokenInfo (2) failed %d\n",
                   error));

        return HRESULT_FROM_WIN32(error);
    }

    //Compare the user SID.
    if(!EqualSid(ptu->User.Sid, &_sid))
        return S_FALSE;

    //Compare the Hydra session ID.
    if(GetSessionId2(hToken) != GetSessionId())
        return S_FALSE;

    //Compare the restricted SID.
    if (bMatchRestricted)
        hr = CompareRestrictedSids(hToken, _hImpersonationToken);
    else
        hr = S_OK;

    return hr;
}

HRESULT
CToken::MatchToken2(
    IN  CToken *pToken,
    IN  BOOL bMatchRestricted)
{
    HRESULT hr;

    if(!pToken)
        return S_OK;

    //Compare the user SID.
    if(!EqualSid(&pToken->_sid, &_sid))
        return S_FALSE;

    //Compare the Hydra session id.
    if(GetSessionId2(pToken->_hImpersonationToken) != GetSessionId())
        return S_FALSE;

    //Compare the restricted SID.
    if (bMatchRestricted)
        hr = CompareRestrictedSids(pToken->_hImpersonationToken, _hImpersonationToken);
    else
        hr = S_OK;

    return hr;
}

HRESULT
CToken::CompareSaferLevels(CToken *pToken)
/*++
 
Routine Description:
 
    Compare the safer trust level of the specified token with 
    our own.
 
Arguments:
 
    pToken - token to compare against

Return Value:
 
    S_FALSE: This token is of lesser authorization than the
             other token.
    S_OK: This token is of greater or equal authorization 
          than the other token.

    Anything else: An error occured.
 
--*/
{
    if (!pToken) return S_OK;

    return CompareSaferLevels(pToken->_hImpersonationToken);
}

HRESULT
CToken::CompareSaferLevels(HANDLE hToken)
/*++
 
Routine Description:
 
    Compare the safer trust level of the specified token with 
    our own.
 
Arguments:
 
    hToken - token to compare against

Return Value:
 
    S_FALSE: This token is of lesser authorization than the
             other token.
    S_OK:    This token is of greater or equal authorization 
             than the other token.

    Anything else: An error occured.
 
--*/
{
    HRESULT hr = S_OK;
    DWORD dwResult;
    BOOL bRet = SaferiCompareTokenLevels(_hImpersonationToken, hToken,
                                            &dwResult);
    if (bRet)
    {
        // -1 = Client's access token (_hImpersonationToken) is more authorized 
        //      than Server's (hToken).
        if ( ((LONG)dwResult) > 0 )
            hr = S_FALSE;
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}

//  NT #307301
//  Sometimes we just need to check the SessionID

HRESULT
CToken::MatchTokenSessionID(CToken *pToken)
{
    //Compare the Hydra session id.
    if(GetSessionId2(pToken->_hImpersonationToken) != GetSessionId())
        return S_FALSE;

    return S_OK;
}

// 
//  MatchTokenLUID
//
//   Compares this token's LUID to that of the passed in token.
//   Returns S_OK on a match, S_FALSE on a mismatch.
//
HRESULT CToken::MatchTokenLuid(CToken* pToken)
{    
    return MatchLuid(pToken->_luid) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\objex\string.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    String.cxx

Abstract:

    Methods of construction of various kinds of DUALSTRINGARRAYs.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-01-95    Bits 'n pieces
    MarioGO     01-??-96    STRINGARRAYs replaced by DUALSTRINGARRAYs

--*/

#include <or.hxx>
#include <mach.hxx>

static CONST WCHAR aCallbackSecurity[] = L"Security=Identification Dynamic True";
static CONST DWORD dwCallbackSecurityLength = sizeof(aCallbackSecurity)/sizeof(WCHAR);


HRESULT dsaAllocateAndCopy(DUALSTRINGARRAY** ppdsaDest, DUALSTRINGARRAY* pdsaSrc)
{
    ASSERT(ppdsaDest);
    ASSERT(pdsaSrc);
    ASSERT(dsaValid(pdsaSrc));
    
    *ppdsaDest = NULL;

    DWORD dwDSASize = sizeof(USHORT) + 
                      sizeof(USHORT) + 
                      (pdsaSrc->wNumEntries * sizeof(WCHAR));
    
    *ppdsaDest = (DUALSTRINGARRAY*)MIDL_user_allocate(dwDSASize);
    if (*ppdsaDest)
    {
        // copy in the string bindings
        memcpy(*ppdsaDest, pdsaSrc, dwDSASize);
        ASSERT(dsaValid(*ppdsaDest));
        return S_OK;
    }
    return E_OUTOFMEMORY;
}


RPC_BINDING_HANDLE
GetBinding(
          IN PWSTR pCompressedBinding
          )
{
    ASSERT(pCompressedBinding);

    PWSTR       pwstrStringBinding;
    PWSTR       pwstrProtseq = GetProtseq(*pCompressedBinding);
    PWSTR       pwstrT;
    RPC_STATUS  Status;
    RPC_BINDING_HANDLE bhReturn;
    BOOL        fLocal = FALSE;

    if (!pwstrProtseq)
    {
        return(0);
    }

    size_t size = OrStringLen(pwstrProtseq) + OrStringLen(pCompressedBinding);

    if (*pCompressedBinding == ID_LPC)
    {
        fLocal = TRUE;
        size += dwCallbackSecurityLength + 1; // +1 for ','
    }

    pwstrStringBinding = (PWSTR) alloca(size * sizeof(USHORT));
    if (!pwstrStringBinding)
    {
        return(0);
    }

    OrStringCopy(pwstrStringBinding, pwstrProtseq);
    pwstrT = OrStringSearch(pwstrStringBinding, 0);
    *pwstrT = L':';
    pwstrT++;
    *pwstrT = 0;
    OrStringCopy(pwstrT, pCompressedBinding + 1);

    if (fLocal)
    {
        // We assume we have an endpoint.

        pwstrT = OrStringSearch(pwstrT, 0);
        pwstrT--;
        if (*pwstrT != L']')
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Local string binding missing endpoint %S\n",
                       pwstrStringBinding));

            ASSERT(0);
            return(0);
        }

        *pwstrT = L',';
        pwstrT++;
        OrStringCopy(pwstrT, aCallbackSecurity);
        pwstrT = OrStringSearch(pwstrT, 0);
        *pwstrT = L']';
        *(pwstrT + 1) = 0;
    }

    Status =
    RpcBindingFromStringBinding( pwstrStringBinding,
                                 &bhReturn);

    if (Status != RPC_S_OK)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Unable to create binding for %S = %d\n",
                   pwstrStringBinding,
                   Status));

        bhReturn = NULL;
    }

    return(bhReturn);
}


RPC_BINDING_HANDLE
GetBindingToOr(
              IN PWSTR pwstrCompressedBinding
              )
/*++

Routine Description:

    Gets an RPC binding to a remote object resolver given
    a compressed string binding to the remote object resolver.

Arguments:

    pwstrCompressedBinding - a compressed string binding without an endpoint.

Return Value:

    0 - failed to allocate memory or RpcBindingFromStringBinding failed.

    non-NULL - completed okay

--*/
{
    PWSTR protseq, endpoint;
    PWSTR strbinding;
    size_t len;
    RPC_BINDING_HANDLE bh = 0;

    ASSERT(pwstrCompressedBinding);
    ASSERT(*pwstrCompressedBinding != 0);

    protseq  = GetProtseq(*pwstrCompressedBinding);
    endpoint = GetEndpoint(*pwstrCompressedBinding);

    if (0 == protseq || 0 == endpoint)
    {
        ASSERT(0);
        return(0);
    }

    len  = 4;  // ':' '[' ']' and '\0'
    len += OrStringLen(protseq);
    len += OrStringLen(endpoint);
    len += OrStringLen(&pwstrCompressedBinding[1]);

    strbinding = new USHORT[len];

    if (strbinding)
    {
        PWSTR pwstrT;

        OrStringCopy(strbinding, protseq);  // protseq

        pwstrT = OrStringSearch(strbinding, 0); // :
        *pwstrT = L':';
        pwstrT++;
        *pwstrT = 0;

        OrStringCat(strbinding, &pwstrCompressedBinding[1]); // network address

        pwstrT = OrStringSearch(strbinding, 0); // [
        *pwstrT = L'[';
        pwstrT++;
        *pwstrT = 0;

        OrStringCat(strbinding, endpoint);  // endpoint

        pwstrT = OrStringSearch(strbinding, 0); // ]
        *pwstrT = L']';
        pwstrT++;
        *pwstrT = 0;

        RPC_STATUS status = RpcBindingFromStringBinding(strbinding, &bh);

        ASSERT(bh == 0 || status == RPC_S_OK);

        delete strbinding;
    }

    if (bh == 0)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: Unable to bind to %S\n",
                   pwstrCompressedBinding + 1));
    }

    return(bh);
}


DUALSTRINGARRAY *
GetStringBinding(
                IN PWSTR pwstrCompressed,
                IN PWSTR pwstrSecurityBindings
                )
/*++

Routine Description:

    Converts the compressed string binding into an expanded
    string binding.  An enpoint maybe optionally specified.

Arguments:

    pwstrCompressed - a compressed string binding

    pwstrSecurityBindings - optional security bindings
        too be tacked onto the end of the expanded string binding.
        Terminated by two nulls.

Return Value:

    NULL - out of memory

    non-NULL - a string binding.  Allocated with MIDL_user_allocate.
--*/
{
    DUALSTRINGARRAY *pT;
    PWSTR protseq;
    USHORT seccount;

    PWSTR t = pwstrSecurityBindings;
    if (t && *t)
    {
        seccount = 0;
        do
        {
            seccount++;
            t++;

            if (*t == 0)
            {
                seccount++;
                t++;
            }
        }
        while (*t);

        seccount++; // final NULL
    }
    else
    {
        // Two nulls only.
        seccount = 2;
    }

    protseq = GetProtseq(*pwstrCompressed);
    if (!protseq)
        return NULL;   // not out of memory -- means bindings contained bogus tower id

    size_t l = OrStringLen(pwstrCompressed) + OrStringLen(protseq) + seccount + 1 + 1;

    pT =(DUALSTRINGARRAY *)MIDL_user_allocate(sizeof(DUALSTRINGARRAY) + l * sizeof(WCHAR));

    if (!pT)
    {
        return(0);
    }

    pT->wNumEntries = (USHORT) l;
    OrStringCopy(pT->aStringArray, protseq);
    OrStringCat(pT->aStringArray, L":");
    OrStringCat(pT->aStringArray, pwstrCompressed + 1);

    if (pwstrSecurityBindings)
    {
        PWSTR t = pT->aStringArray;
        t = OrStringSearch(t, 0);
        t++;
        *t = 0;  // Second NULL on string bindings.
        t++;
        OrMemoryCopy(t, pwstrSecurityBindings, seccount*sizeof(WCHAR));
    }
    else
    {
        // Add three NULLs, total of four.
        PWSTR t = pT->aStringArray;
        t = OrStringSearch(t, 0);
        t[1] = 0;
        t[2] = 0;
        t[3] = 0;
    }

    pT->wSecurityOffset = pT->wNumEntries - seccount;

    ASSERT(dsaValid(pT));

    return(pT);
}


ORSTATUS
ConvertToRemote(
               IN  DUALSTRINGARRAY  *pdsaLocal,
               OUT DUALSTRINGARRAY **ppdsaRemote
               )
/* ++

Parameters:
    pdsaLocal - An array of string bindings with compressed protseqs.

    ppdsaRemote - Will contain only those string bindings in pdsaLocal
        which are not "IsLocal()".

    Note: *ppdsaRemote maybe used as a flag, don't set it to non-NULL
    until it is valid.

-- */
{
    USHORT iTotalSize;
    USHORT iSize;
    USHORT *p1, *p2;
    DUALSTRINGARRAY *pdsaT;

    // Size remote array

    // Final null terminator
    iSize = 1;

    p1 = pdsaLocal->aStringArray;

    while (*p1)
    {
        if (! IsLocal(*p1) )
        {
            iSize += (USHORT) OrStringLen(p1) + 1;
        }
        p1 = OrStringSearch(p1, 0) + 1;
    }

    if (iSize == 1)
    {
        iSize = 2; // No non-local strings, need two terminators.
    }

    iTotalSize = iSize + (pdsaLocal->wNumEntries - pdsaLocal->wSecurityOffset);

    pdsaT = new(iTotalSize * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (!pdsaT)
    {
        return(OR_NOMEM);
    }

    pdsaT->wNumEntries = iTotalSize;
    pdsaT->wSecurityOffset = iSize;

    p2 = pdsaT->aStringArray;

    // Copy security bindings
    OrMemoryCopy(p2 + iSize,
                 pdsaLocal->aStringArray + pdsaLocal->wSecurityOffset,
                 (iTotalSize - iSize) * sizeof(WCHAR));

    if (iSize == 2)
    {
        // No non-local strings, fill in terminators and return.
        *p2 = 0;
        *(p2 + 1) = 0;
        *ppdsaRemote = pdsaT;

        ASSERT(dsaValid(pdsaT));
        return(OR_OK);
    }

    p1 = pdsaLocal->aStringArray;

    while (*p1)
    {
        if ( ! IsLocal(*p1) )
        {
            OrStringCopy(p2, p1);
            p2 = OrStringSearch(p2, 0) + 1;
        }

        p1 = OrStringSearch(p1, 0) + 1;
    }

    *p2 = 0; // Second terminator.

    *ppdsaRemote = pdsaT;

    ASSERT(dsaValid(pdsaT));
    return(OR_OK);
}


DUALSTRINGARRAY *
CompressStringArrayAndAddIPAddrs(
                   IN DUALSTRINGARRAY *pdsaExpanded
                   )
/*++

Routine Description:

    Converts a stringarray of regular string bindings into a
    compressed (protseq's replaced with WORD id's) array of
    string bindings.

Arguments:

    pdsaExpanded - the string array to compress.
        Security information is copied.

Return Value:

    0 - failed to allocate memory.

    non-0 - compressed string array.

--*/
{
    size_t i, size;
    USHORT *p1, *p2, *p3;
    PWSTR pwstr;
    DUALSTRINGARRAY *pdsaCompressed;
    CIPAddrs* pIPAddrs = gpMachineName->GetIPAddrs();
    ULONG cIPAddrs = 0;
	
    // Possible for gpMachineName->GetIPAddrs to return NULL.
    if (pIPAddrs)
    {
        ASSERT(pIPAddrs->_pIPAddresses);
        cIPAddrs = pIPAddrs->_pIPAddresses->Count;
    }

    // Compute size of result.

    p1 = pdsaExpanded->aStringArray;

    size = pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset;

    if (*p1 == 0)
    {
        size += 2;  // two null terminators ONLY.
    }
    else
    {
        size += 1;  // last null terminator
    }

    while (*p1)
    {
        size_t sizeT = OrStringLen(p1);

        p2 = OrStringSearch(p1, L':');  // ':' is not valid in protseq.
        if (p2)
        {
            // proseq len (p2 - p1) become 1 for Id.
            size_t newLen = (sizeT + 1 - (size_t)(p2 - p1));
            size += newLen;

            *p2 = 0; // subst NULL just for the compare
            if ((lstrcmpW(L"ncacn_ip_tcp", p1) == 0) ||
                (lstrcmpW(L"ncadg_ip_udp", p1) == 0) ||
		(lstrcmpW(L"ncacn_http", p1) == 0))
            {
                if (pIPAddrs)
                {
                    size += pIPAddrs->_pIPAddresses->StringBufferSpace;
                }
            }
            *p2 = L':'; // put the colon back in

            p1 = OrStringSearch(p2, 0) + 1;
        }
        else
        {
            // Prefix bug:  if we got here, this would mean we found a binding
            // that did not have a colon, and we would then have passed a NULL
            // p2 to OrStringSearch.   This code is so old I doubt that this
            // case ever has been or will be hit, but better to do the right thing.
            ASSERT(0 && "Malformed binding");
            if (pIPAddrs)
                pIPAddrs->DecRefCount();
            return NULL;
        }
    }

    pdsaCompressed = new(size * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (0 == pdsaCompressed)
    {
        if (pIPAddrs)
            pIPAddrs->DecRefCount();
        return(0);
    }

    p3 = pdsaCompressed->aStringArray;
    *p3 = 0;

    p1 = pdsaExpanded->aStringArray;

    if (*p1 == 0)
    {
        // Loop won't be entered, point p3 to second null terminator
        p3++;
    }

    while (*p1)
    {
        p2 = OrStringSearch(p1, L':');
        if (p2)
        {
            USHORT TowerId;

            *p2 = 0;
            *p3 = TowerId = GetProtseqId(p1);
            *p2 = L':';
            if (*p3 != 0)
            {
                p3++;
                p1 = p2 + 1; // Just after ':'
                OrStringCopy(p3, p1);
                // Move p3 to start of next string if any.
                p3 = OrStringSearch(p3, 0) + 1;

                //
                // add in IP addresses for TCP/IP and UDP/IP
                //

                if ((TowerId == ID_TCP) || (TowerId == ID_UDP) || (ID_DCOMHTTP == TowerId))
                {
                    ULONG i;
                    p2 = OrStringSearch(p1, L'[');
                    if (p2)
                    {
                        for (i=0; i<cIPAddrs; i++)
                        {
                            // do not include the loopback address in server bindings
                            if (lstrcmpW(L"127.0.0.1", pIPAddrs->_pIPAddresses->NetworkAddresses[i]) != 0)
                            {
                                *p3 = TowerId;
                                p3++;

                                // copy in IP address
                                OrStringCopy(p3, pIPAddrs->_pIPAddresses->NetworkAddresses[i]);
                                p3 = OrStringSearch(p3, 0);

                                // copy in rest of string binding
                                OrStringCopy(p3, p2);

                                // Move p3 to start of next string if any.
                                p3 = OrStringSearch(p3, 0) + 1;
                            }
                        }
                    }
                }
            }
        }

        // Move p1 to start of next string if any.
        p1 = OrStringSearch(p1, 0) + 1;
    }

    // Second terminator, p3 already points to it.
    *p3 = 0;

    pdsaCompressed->wSecurityOffset = (USHORT) (p3 + 1 - pdsaCompressed->aStringArray );
    pdsaCompressed->wNumEntries = pdsaCompressed->wSecurityOffset +
        (pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset);

    // Copy security bindings
    OrMemoryCopy(p3 + 1,
                 pdsaExpanded->aStringArray + pdsaExpanded->wSecurityOffset,
                 (pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset) * sizeof(WCHAR));

    ASSERT(dsaValid(pdsaCompressed));
	
    if (pIPAddrs)
        pIPAddrs->DecRefCount();

    return(pdsaCompressed);
}


USHORT
FindMatchingProtseq(
                   IN USHORT cClientProtseqs,
                   IN USHORT aClientProtseqs[],
                   IN PWSTR  pwstrServerBindings
                   )
/*++

Routine Description:

    Finds the first protseq id in aClientProtseqs which appears in any of
    the server bindings.

Arguments:

    cClientProtseqs - the number of entries in aClientProtseqs.
    aClientProtseqs - Protseq tower id's support by the client.
    pwstrServerBindings - compressed array of bindings supported by the server
        terminated by two NULLs.

Return Value:

    0 - no match found.
    non-0 - the matching protseq id.

--*/

// Called by server oxid's and processes when checking for lazy use protseq.
{
    ULONG i;

    if (0 == cClientProtseqs)
    {
        return(0);
    }

    while (*pwstrServerBindings)
    {
        for (i = 0; i < cClientProtseqs; i++)
        {
            if (aClientProtseqs[i] == *pwstrServerBindings)
            {
                return(aClientProtseqs[i]);
            }
        }
        pwstrServerBindings = OrStringSearch(pwstrServerBindings, 0) + 1;
    }

    return(0);
}



PWSTR
FindMatchingProtseq(
                   IN USHORT protseq,
                   IN PWSTR  pwstrCompressedBindings
                   )
/*++

Routine Description:

    Searches a compressed string array for an entry which
    matches a particular protseq.


Arguments:

    protseq - The protseq to search for.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    0 - not found

    non-0 - a pointer into the pwstrCompressedBindings

--*/
{
    ASSERT(pwstrCompressedBindings);

    while (*pwstrCompressedBindings)
    {
        if (*pwstrCompressedBindings == protseq)
        {
            return(pwstrCompressedBindings);
        }
        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
    }
    return(0);
}

PWSTR
FindMatchingProtseq(
                   IN PWSTR  pMachineName,
                   IN USHORT protseq,
                   IN PWSTR  pwstrCompressedBindings
                   )
/*++

Routine Description:

    Searches a compressed string array for an entry which
    matches a particular protseq and machine


Arguments:

    protseq - The protseq to search for.

    pMachine - the machine name to search for.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    0 - not found

    non-0 - a pointer into the pwstrCompressedBindings

--*/
{
    ASSERT(pwstrCompressedBindings);

    while (*pwstrCompressedBindings)
    {
        if (*pwstrCompressedBindings == protseq)
        {
            PWSTR pwstrMachineNameTemp = pMachineName;

            WCHAR* pwstrT = pwstrCompressedBindings + 1;
            BOOL fSkip = FALSE;
            while (*pwstrT && *pwstrMachineNameTemp && ((*pwstrT != L'[') || fSkip))
            {
                fSkip = (*pwstrT == L'\\') && !fSkip;

                if (towupper(*pwstrMachineNameTemp) != towupper(*pwstrT))
                {
                    break;
                }
                pwstrT++;
                pwstrMachineNameTemp++;
            }

            if (!*pwstrMachineNameTemp && (!*pwstrT || (*pwstrT == L'[')))
            {
                return pwstrCompressedBindings;
            }
        }

        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
    }
    return(0);
}

WCHAR *
ExtractMachineName(WCHAR *pSB)
{

    pSB++;
    WCHAR* pwstrT = pSB;

    BOOL fSkip = FALSE;
    while (*pwstrT && ((*pwstrT != L'[') || fSkip))
    {
        fSkip = (*pwstrT == L'\\') && !fSkip;
        pwstrT++;
    }
    ULONG len = (ULONG)(pwstrT - pSB);
    if (len)
    {
        WCHAR* pMachineName;
        pMachineName = new WCHAR[len + 1];
        if (pMachineName)
        {
            memcpy(pMachineName, pSB, (UINT)((pwstrT - pSB) * sizeof(WCHAR)));
            pMachineName[len] = 0;
            return pMachineName;
        }
    }

    return NULL;
}



RPC_BINDING_HANDLE
TestBindingGetHandle(
                    IN PWSTR pwstrCompressedBinding
                    )
/*++

Routine Description:

    Tests that an OR can be found on the machine identified by the
    compressed binding.

Arguments:

    pwstrCompressedBiding - A compressed stringing binding to the
        server in question.  May include an endpoint to something
        other then the endpoint mapper.

Return Value:

    None

--*/
{
    PWSTR pwstrT;
    PWSTR pwstrCopy = (PWSTR)alloca(   (OrStringLen(pwstrCompressedBinding) + 1)
                                       * sizeof(WCHAR) );

    if (pwstrCopy == 0)
    {
        return(FALSE);
    }

    OrStringCopy(pwstrCopy, pwstrCompressedBinding);

    // We need to wack the endpoint out of the string binding.
    // Go read the runtime's string parsing stuff if you're not
    // sure what this is doing.  Note: on Win9x this needs to
    // be DBCS enabled...

#ifndef NTENV
    #message "Error: string.cxx(): this won't work"
#endif
    pwstrT = pwstrCopy;

    while (*pwstrT && *pwstrT != L'[')
        pwstrT++;

    if (*pwstrT)
    {
        ASSERT(*pwstrT == L'[');
        *pwstrT = 0;
        // Endpoint gone.
    }

    return  GetBindingToOr(pwstrCopy);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDualStringArray methods
//

DWORD CDualStringArray::AddRef()
{
    ASSERT(_cRef != 0);
    DWORD cRef = InterlockedIncrement(&_cRef);
    return cRef;
}

DWORD CDualStringArray::Release()
{
    ASSERT(_cRef > 0);
    DWORD cRef = InterlockedDecrement(&_cRef);
    if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}

CDualStringArray::~CDualStringArray()
{
    ASSERT(_cRef == 0);

    // free the dual string array
    MIDL_user_free( _pdsa );
}

//
//////////////////////////////////////////////////////////////////////////////

RPC_STATUS CParallelPing::Ping()
/*++

Routine Description:

    Calls ServerAlive2 on all supplied bindings asyncronously.  First binding
    that completles succesfully is chosen. Remaining calls are cancelled.

Arguments:

    None;

Return Value:

    RPC_S_OK
    RPC_S_CALL_FAILED

--*/
{
    ULONG           cHandlesMax = 0;
    const  ULONG    cBlockSize = 10;

    _cCalls = 0;
    _cReceived = 0;
    _arAsyncCallInfo = NULL;

    //
    // First ping that succeeds sets _ndxWinner to it's index + 1
    //
    _ndxWinner = 0;
    
    //
    // send off all the calls
    //

    RPC_STATUS sc;

    ULONG i;
    for (i=0; _ndxWinner == 0; i++)
    {

        //
        // allocate/resize arrays to hold call state
        //

        if (i >= cHandlesMax)
        {
            REALLOC(MIDL_user_allocate, MIDL_user_free,
                     PRPC_ASYNC_STATE,
                     _arAsyncCallInfo, cHandlesMax, cHandlesMax+cBlockSize, sc)
            if (FAILED(sc))
            {
            	break;
            }
            memset(_arAsyncCallInfo+cHandlesMax, 0, (sizeof(PRPC_ASYNC_STATE) * cBlockSize));
            
            cHandlesMax += cBlockSize;
        }
        if (i >= _cProtseqMax)
        {
            REALLOC(MIDL_user_allocate, MIDL_user_free,
                    PROTSEQINFO, _pProtseqInfo,
                    _cProtseqMax, _cProtseqMax+cBlockSize, sc)
            if (FAILED(sc))
            {
                break;
            }
            _cProtseqMax += cBlockSize;
        }

        if (i == _cHandles)
        {
            // get more handles
            if (!NextCall(_pProtseqInfo+i))
            {
                // no more, so we're done
                break;
            }

            _cHandles++;

            //
            // turn off serialization
            //

            sc = RpcBindingSetOption(_pProtseqInfo[i].hRpc, RPC_C_OPT_BINDING_NONCAUSAL, TRUE);
            if (sc != RPC_S_OK)
            {
                break;
            }

            //
            // Initialize the COM version, to the minimum (so if the call
            // fails with RPC_S_PROCNUM_OUT_OF_RANGE, we know the right
            // answer.
            //
            _pProtseqInfo[i].comVersion.MajorVersion = 5;
            _pProtseqInfo[i].comVersion.MinorVersion = 1;
        }

        if (_pProtseqInfo[i].hRpc == NULL)
        {
            continue;
        }

        _arAsyncCallInfo[i] = (PRPC_ASYNC_STATE) MIDL_user_allocate(sizeof(RPC_ASYNC_STATE));
        if (_arAsyncCallInfo[i] == NULL)
        {
            sc = RPC_S_OUT_OF_MEMORY;
            break;
        }

        //
        // set up async information
        //

        sc = RpcAsyncInitializeHandle(_arAsyncCallInfo[i],
                                     sizeof(RPC_ASYNC_STATE));
        //
        // If this succeeds we pass the ownership of _arAsyncCallInfo[i] to the callback
        //
        if (sc != RPC_S_OK)
        {
            MIDL_user_free(_arAsyncCallInfo[i]);
            _arAsyncCallInfo[i] = NULL;
            break;
        }
        _arAsyncCallInfo[i]->NotificationType = RpcNotificationTypeApc;
        _arAsyncCallInfo[i]->u.APC.NotificationRoutine = ServerAliveAPC;
        _arAsyncCallInfo[i]->u.APC.hThread = 0;
        _arAsyncCallInfo[i]->UserInfo = (void *)this;


        _cCalls++;
        //
        // begin the call
        //

        RPC_STATUS ret = ServerAlive2( _arAsyncCallInfo[i],
                                       _pProtseqInfo[i].hRpc,
                                       &(_pProtseqInfo[i].comVersion),
                                       &_tmpOrBindings,
                                       &_tmpReserved );

        if (ret != RPC_S_OK)
        {
            ServerAliveWork(_arAsyncCallInfo[i], ret);
        }
        else
        {
            //
            // stagger the calls
            //

            SleepEx(PARALLEL_PING_STAGGER_TIME, TRUE);
        }
    }

    //
    // wait for successful ping or for all calls to
    // return
    //

    while ( (_ndxWinner == 0) && ((_cCalls - _cReceived) > 0) )
    {
        SleepEx(INFINITE, TRUE);
    }

    //
    // Cancel the calls left outstanding if there are any
    //

    if ((_cCalls - _cReceived) > 0)
    {
        for (i = 0; i<_cHandles; i++)
        {
            if (_arAsyncCallInfo[i] != NULL)
            {
                // we purposely ignore the return code here.  Even if it failed
                // there wouldn't be much we could do.
                RPC_STATUS retDontCare = RpcAsyncCancelCall(_arAsyncCallInfo[i], TRUE);
                if (retDontCare != RPC_S_OK)
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "OR:  RpcAsyncCancelCall failed - this is non-fatal; ret=%d\n",
                               retDontCare));
                }               
            }
        }

        //
        // wait for cancelled calls to return
        //

        while ( (_cCalls - _cReceived) > 0)
        {
            SleepEx(INFINITE, TRUE);
        }
    }

    // Free call infos
    if (_arAsyncCallInfo)
    {
 #if DBG
        for (i=0; i < cHandlesMax; ++i)
        {
            ASSERT(_arAsyncCallInfo[i] == NULL);
        }
 #endif
    	MIDL_user_free(_arAsyncCallInfo);
    }

    //
    // return results
    //

    _arAsyncCallInfo = NULL;

    if (_ndxWinner != 0)
    {
        _pWinner = _pProtseqInfo + _ndxWinner - 1;
        return RPC_S_OK;
    }
    else
    {
        _pWinner = NULL;

        //
        // give precedence to failure which occured while attempting
        // to make calls.
        //

        if (sc != RPC_S_OK)
        {
            return sc;
        }
        else
        {
            ASSERT(_sc != RPC_S_OK);
            return _sc;
        }
    }
}

void ServerAliveAPC( IN PRPC_ASYNC_STATE pAsyncState,
                     IN void *Context,
                     IN RPC_ASYNC_EVENT Flags)
{
    CParallelPing   *pParallelPing = (CParallelPing *)pAsyncState->UserInfo;
    
    pParallelPing->ServerAliveWork(pAsyncState, RPC_S_OK);
}


void CParallelPing::ServerAliveWork( PRPC_ASYNC_STATE pAsyncState, RPC_STATUS scBegin)
{
    RPC_STATUS tmpStatus;
    _tmpOrBindings = NULL;

    if (scBegin == RPC_S_OK)
    {
        _sc = RpcAsyncCompleteCall(pAsyncState, &tmpStatus);
    }
    else
    {
        _sc = scBegin;
    }

    // If there are no saved bindings, save these.
    if (_pdsaOrBindings == NULL && dsaValid(_tmpOrBindings))
    {
        _pdsaOrBindings = _tmpOrBindings;
        _tmpOrBindings  = NULL;
    }
    else
    {
        MIDL_user_free( _tmpOrBindings );
        _tmpOrBindings = NULL;
    }

    _cReceived++;

    ULONG uMyIndex = 0;

    for (uMyIndex=0; uMyIndex < _cHandles; ++uMyIndex)
    {
        if (_arAsyncCallInfo[uMyIndex] == pAsyncState)
        {
            MIDL_user_free(pAsyncState);
            _arAsyncCallInfo[uMyIndex] = NULL;
            break;
        }
    }

    if (uMyIndex == _cHandles)
    {
        ASSERT(uMyIndex < _cHandles);
        return;
    }

    //
    // First protocol to succeed is the winner
    //
    if (_ndxWinner == 0)
    {
        if ((_sc == RPC_S_OK) || (_sc == RPC_S_PROCNUM_OUT_OF_RANGE))
        {
            _ndxWinner = uMyIndex + 1;
            _sc = RPC_S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\activate.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  activate.cxx
//
//  Main dcom activation service routines.
//
//  History:                VinayKr     Created
//              06-Nov-98   TarunA      Changed remote/local activation logic
//
//--------------------------------------------------------------------------

#include "act.hxx"

HRESULT GetProcessInfoFromActProps(IActivationPropertiesIn* pActPropsIn, DWORD* ppid, DWORD* pdwProcessReqType);
LPWSTR GetOrigSrvrName( PACTIVATION_PARAMS pActParams );

// Global counter
LONG gThreadToken = 0;

//-------------------------------------------------------------------------
//
// CalculateActParamsClassInfo
//
// Re-calculate the classinfo in the ACTIVATION_PARAMS structure.
//
//-------------------------------------------------------------------------
HRESULT
CalculateActParamsClassInfo(
    IN OUT PACTIVATION_PARAMS pActParams
)
{
    IComClassInfo *pComClassInfo = NULL;    
    HRESULT hr = S_OK;
   
    if (pActParams->pToken)
    {
        //
        // I'm a little worried about this.  Why do we do this?
        //
        if (!(pActParams->ClsContext & CLSCTX_INPROC_SERVER))
        {
            hr = gpCatalogSCM->GetClassInfo ( pActParams->ClsContext,
                                              pActParams->pToken,
                                              pActParams->Clsid,
                                              IID_IComClassInfo,
                                              (void**) &pComClassInfo );
        }
    }
    else
        hr = gpCatalog->GetClassInfo ( pActParams->Clsid,
                                       IID_IComClassInfo,
                                       (void**) &pComClassInfo );    
    
    if (SUCCEEDED(hr) && (pComClassInfo))
    {
        if (pActParams->pComClassInfo)
            pActParams->pComClassInfo->Release();

        // Copy the reference, do not release.
        pActParams->pComClassInfo = pComClassInfo;
        
        if (pActParams->pActPropsIn)
            hr = pActParams->pActPropsIn->SetClassInfo(pComClassInfo);
    }

    
    if (hr == REGDB_E_CLASSNOTREG)
    {
        // It's OK for us to have no registration information.
        hr = S_OK;
    }

    return hr;
}


LONG ActivationExceptionFilter(LPEXCEPTION_POINTERS lpep)
{
    ASSERT(NULL && "Unexpected exception thrown");
    return EXCEPTION_EXECUTE_HANDLER;
}

//-------------------------------------------------------------------------
//
// Activation
//
// Main entry point for both local and remote activations.
//
//-------------------------------------------------------------------------
HRESULT
Activation(
    IN OUT PACTIVATION_PARAMS pActParams
    )
{
    CServerTableEntry*  pServerTableEntry = NULL;
    CClsidData*         pClsidData = NULL;
    CServerListEntry*   pServerListEntry;
    CNamedObject*       pLaunchMutex = NULL;
    HRESULT             hr;
    RPC_STATUS          Status;
    BOOL                bStatus;
    BOOL                bFirstTime = TRUE;
	CToken*             pTkn;

    //  NT #294385
    //  If REMOTE_SERVER is set, and LOCAL_SERVER is not,
    //  and we have a server name, and the server name is us,
    //  then we need to turn the LOCAL_SERVER flag on
    
    if ( (CLSCTX_REMOTE_SERVER == (pActParams->ClsContext & ( CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER ))) &&
            pActParams->pwszServer != NULL &&
            gpMachineName->Compare (pActParams->pwszServer) )
    {
        pActParams->ClsContext |= CLSCTX_LOCAL_SERVER;

#ifdef _WIN64
        // On Win64, this might change the classinfo.
        hr = CalculateActParamsClassInfo(pActParams);
        if (FAILED(hr))
            goto ActivationDone;
#endif
    }
    
#ifdef SECURITY_DBG
    {
        WCHAR dbgwszUser[MAX_PATH];
        if ( pActParams->pToken != NULL )
        {
            pActParams->pToken->Impersonate();
            ULONG cchSize = MAX_PATH;
            GetUserName( dbgwszUser, &cchSize );
            pActParams->pToken->Revert();
        }
        else
        {
            lstrcpyW( dbgwszUser, L"Anonymous" );
        }
    }
#endif
        
    if ( pActParams->pwszServer )
    {
        //
        // Some apps may unnecessarily put slashes before their
        // server names.  We'll allow this and strip them off.
        //
        if ( pActParams->pwszServer[0] == L'\\' &&
            pActParams->pwszServer[1] == L'\\' )
            pActParams->pwszServer += 2;
        
        if ( 0 == *pActParams->pwszServer )
        {
            hr = CO_E_BAD_SERVER_NAME;
            goto ActivationDone;
        }
        
        if ( ! gpMachineName->Compare( pActParams->pwszServer ) )
        {
            //
            // When a client specifies a remote server name we go straight to the
            // source, there is no need to check local configuration information.
            //
            // The CLSCTX_REMOTE_SERVER bit does not need to be specified by the
            // client, it is implied.
            //
            
            //
            // the remote activation call will null out the pointer in the ActivationPropertiesIn
            // object which caused the memory that pActParams->pwszServer is pointing to to be
            // freed.  We need this name later on to pass to the oxid resoluton phase, so
            // we copy it to some memory on the stack
            //
            
            WCHAR *pszTemp = (WCHAR *)_alloca( ( lstrlenW(pActParams->pwszServer) + 1 ) * sizeof(WCHAR) );
            lstrcpyW(pszTemp, pActParams->pwszServer);
            hr = RemoteActivationCall( pActParams, pActParams->pwszServer );
            pActParams->pwszServer = pszTemp;
            
            goto ActivationDone;
        }
    }
    
    //
    // First search for a running object.
    //
    if ( pActParams->pwszPath )
    {
        //
        // This call returns TRUE if we found a ROT object and are now done.
        // When handling a remote activation it's possible we'll find a ROT
        // object, but we still need to continue in this case to get a remote
        // marshalled interface.
        //
        if ( LookupObjectInROT( pActParams, &hr ) )
            goto ActivationDone;
    }
    
	//
	//  Try to get a CClsidData using the supplied pComClassInfo 
	// 
    pTkn =  pActParams->RemoteActivation ? NULL : pActParams->pToken;

    hr = LookupClsidData( pActParams->Clsid,
                          pActParams->pComClassInfo,
                          pTkn,
                          LOAD_NORMAL,
                          &pClsidData );   
    if (hr == REGDB_E_CLASSNOTREG)
    {
        ASSERT(!pClsidData);
        
        // No registration info for this clsid.   If the client is interested
		// in a local server activation, we still need to check the class 
        // table in case of unsolicited registrations.   For COM+ components 
        // we should never get here.
		if(pActParams->ClsContext & CLSCTX_LOCAL_SERVER)
		{
			pServerTableEntry = gpClassTable->Lookup(pActParams->Clsid);
			if (pServerTableEntry)
			{
				// Somebody on the machine registered a classfac for this
				// clsid; give it a shot:
				bStatus = pServerTableEntry->CallRunningServer( pActParams,
																0,
																0,
                                                                NULL,
																&hr);
				if (bStatus)
					goto ActivationDone;
			}
		}
		
        //
        // As a last resort we always try an atstorage activation.
        //
        ActivateAtStorage( pActParams, NULL, &hr );
        goto ActivationDone;
    }
    else if (FAILED(hr))
        goto ActivationDone;
        
    ASSERT(pClsidData && "Registration lookup succeeded but returned nothing");

    //
    // If this is a remote activation, make sure that the ClassInfo we got 
    // can be activated.
    //
    if (pActParams->RemoteActivation)
    {
        hr = pClsidData->IsEnabledRemote();
        if (FAILED(hr))
        {
            // Log it to the event log.
            if (hr == CO_E_CLASS_DISABLED)
                LogComPlusRemoteDisabled(pActParams->ClsContext, pActParams->Clsid);
            
            goto ActivationDone;
        }
    }

    // Look up an appropriate table entry if the client is interested in a
    // local activation
    if(pActParams->ClsContext & CLSCTX_LOCAL_SERVER)
    {
        if (pClsidData->DllHostOrComPlusProcess())
        {
            GUID* pAppidGuid = pClsidData->AppidGuid();
            ASSERT(pAppidGuid);
            pServerTableEntry = gpProcessTable->Lookup(*pAppidGuid);
        }
        else
            pServerTableEntry = gpClassTable->Lookup( pActParams->Clsid );
    }

    if ( !pServerTableEntry )
    {
        // At this point we have the class data but no running servers. If the 
        // client wants remote activation only then go straight to do a remote activation
        // NOTE We '&' with flags CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER to
        // filter out any other bits like CLSCTX_INPROC etc        
        if( (pActParams->ClsContext & (CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER)) == CLSCTX_REMOTE_SERVER)
        {
            // This call returns TRUE if a remote ActivateAtStorage call was
            // made, whether successful or not.
            if ( ActivateAtStorage( pActParams, pClsidData, &hr ) )
                goto ActivationDone;
            else
                goto ActivationDoneLocal;
        }
        
        // Figure out which table to create the table entry in
        if (pClsidData->DllHostOrComPlusProcess())
        {
            GUID* pAppidGuid = pClsidData->AppidGuid();
            ASSERT(pAppidGuid);
            pServerTableEntry = gpProcessTable->Create(*pAppidGuid);
        }
        else
            pServerTableEntry = gpClassTable->Create(pActParams->Clsid);
                        
        if (!pServerTableEntry)
        {
            hr = E_OUTOFMEMORY;
            goto ActivationDone;
        }
    }
    
    ASSERT(pServerTableEntry);
    
    hr = GetProcessInfoFromActProps(pActParams->pActPropsIn, &(pActParams->dwPID), &(pActParams->dwProcessReqType));
    if (FAILED(hr))
        goto ActivationDone;
    
    for (;;)
    {        
        //
        // Now check for a running server for the CLSID
        // NOTE: The fact that we reached here implies that the client wants at least a
        // local activation
        //
        CairoleDebugOut((DEB_SCM, "Calling ServerTableEntry at 0x%p\n", pServerTableEntry));
                
        // We reach here only when we are interested in at least a local activation
        ASSERT(pActParams->ClsContext & CLSCTX_LOCAL_SERVER);
        
        // We always try to use an existing running server, unless a custom 
        // activator has told us specifically to create a new server.
        if (pActParams->dwProcessReqType != PRT_CREATE_NEW)
        {
            bStatus = pServerTableEntry->CallRunningServer( pActParams,
                                                            0,
                                                            0,
                                                            pClsidData,
                                                            &hr);            
            if ( bStatus )
                goto ActivationDone;
            else
            {
                if (pActParams->dwProcessReqType == PRT_USE_THIS_ONLY)
                {
                    // A custom activator specified a specific server which was not 
                    // found.  No need to continue further.
                    hr = E_UNEXPECTED;   // REVIEW for better error code! 
                    goto ActivationDone;
                }
                else if(pActParams->dwProcessReqType == PRT_USE_THIS)
                {
                    // A custom activator hinted at a specific process, which was not
                    // found.  Eg, the process in question was killed, died, etc.  Although
                    // this should not happen much in the normal case, it would be nice if 
                    // we could somehow save the client from getting an error.   So what we
                    // do is re-try the activation using any compatible server.   If it works
                    // great, if not then we're done (we won't start a new server).
                    
                    // note we're only resetting the pertinent flags in the actparams struct,
                    // not the actprops object, but everybody downstream from here only looks 
                    // at the actparams so this is okay.
                    pActParams->dwProcessReqType = PRT_IGNORE;
                    pActParams->dwPID = 0;
                    bStatus = pServerTableEntry->CallRunningServer( pActParams,
                                                                    0,
                                                                    0,
                                                                    pClsidData,
                                                                    &hr);
                    goto ActivationDone;
                }
                // else { keep going }
            }
        }
        
        if (bFirstTime)
        {
            bFirstTime = FALSE;

            //
            //  Try to do at-storage first
            //
            if (ActivateAtStorage(pActParams, pClsidData, &hr))
                goto ActivationDone;

            // Try a remote activation if
            // (1a) Class is configured to be activated remotely
            // AND
            // (1b) Client will accept a remote activation
            // OR
            // (2)SERVERTYPE_NONE
            if( (((pClsidData->GetAcceptableContext() & (CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER)) == CLSCTX_REMOTE_SERVER)
                    &&
                    (pActParams->ClsContext & CLSCTX_REMOTE_SERVER)) 
                    ||
                    (pClsidData->ServerType() == SERVERTYPE_NONE) )
                goto ActivationDoneLocal;      
        }
        
        if ( ! pLaunchMutex )
        {
            pLaunchMutex = pClsidData->ServerLaunchMutex();           
            if (!pLaunchMutex)
            {
                hr = E_OUTOFMEMORY;
                goto ActivationDone;
            }
        }
        else
            WaitForSingleObject( pLaunchMutex->Handle(), INFINITE );
        
		// At this point we now hold the launch mutex

        //  If we've been told explicitly to launch a new server process, then
        //  there's no reason to check for one already running.
        if (pActParams->dwProcessReqType != PRT_CREATE_NEW)
        {
            // If server exists, release launch mutex and try
            // to call server
            BOOL fExists;
            hr = pServerTableEntry->ServerExists(pActParams, &fExists);
            if (hr != S_OK)
            {
                ReleaseMutex( pLaunchMutex->Handle() );
                goto ActivationDone;
            }
            
            if (fExists)
            {
                ReleaseMutex( pLaunchMutex->Handle() );
                continue;
            }
        }
        
        ASSERT(pActParams->dwProcessReqType == PRT_IGNORE ||
               pActParams->dwProcessReqType == PRT_CREATE_NEW);
        
        RpcTryExcept
        {
            LONG lLaunchThreadToken;
            //
            // This returns when the server has registered the requested CLSID or
            // we give up.
            //
            CairoleDebugOut((DEB_SCM, "Starting ServerTableEntry at 0x%p\n", pServerTableEntry));
            
            // Grab a non-zero token for the launch that we will
            // use to associate the server with on the call
            do {
                lLaunchThreadToken = InterlockedIncrement(&gThreadToken);
            }
            while (lLaunchThreadToken == 0);
            
            // Use the token to launch
            // Note that StartServerAndWait could reset the token
            // to zero in some cases.
            hr = pServerTableEntry->StartServerAndWait( pActParams,
                                                        pClsidData,
                                                        lLaunchThreadToken);
            
            // Now call the server with the LaunchMutex held but
            // with the threadtoken to guarantee first access to
            // the class in the server we launched. This takes
            // care of SINGLEUSE as well as transient error cases.
            if (SUCCEEDED(hr))
            {
                // NOTE:    if the server we just launched was an "extra" one (ie, on 
                // behalf of some custom activator), it's not guaranteed that this
                // activation will use the just-launched server.  It may get an old one.
                bStatus = pServerTableEntry->CallRunningServer(pActParams,
                                                               0,
                                                               lLaunchThreadToken,
                                                               pClsidData,
                                                               &hr);        
                if (!bStatus)
                    hr = CO_E_SERVER_EXEC_FAILURE;
            }
        }
        RpcExcept(ActivationExceptionFilter(GetExceptionInformation()))
        {
            Status = RpcExceptionCode();
            hr = HRESULT_FROM_WIN32(Status);
        }
        RpcEndExcept
            
        ReleaseMutex( pLaunchMutex->Handle() );
        
        break;
        
    }// end for(;;)
    
    goto ActivationDone;
    
ActivationDoneLocal:
    
    hr = REGDB_E_CLASSNOTREG;
    
    //
    // Server name will only be non-null if its our machine name.
    //
    if ( !pActParams->pwszServer &&
         pClsidData->RemoteServerNames() )
    {
        //
        // the remote activation call will null out the pointer in the ActivationPropertiesIn
        // object which caused the memory that pActParams->pwszServer is pointing to to be
        // freed.  We need this name later on to pass to the oxid resoluton phase, so
        // we copy it to some memory on the stack
        //
        // We don't care here since pActParams->pwszServer==NULL if we are here.
        
        if (!ActivateRemote( pActParams, pClsidData, &hr ))
        {
            hr = (CLSCTX_REMOTE_SERVER == pActParams->ClsContext) ?
                    CO_E_CANT_REMOTE : REGDB_E_CLASSNOTREG;
        }
    }

ActivationDone:
    
    if (pLaunchMutex)
    	pLaunchMutex->Release();
    
    // Registry data is not cached in any way.
    if ( pClsidData )
        delete pClsidData;
    
    if ( pServerTableEntry )
        pServerTableEntry->Release();
    
    // Don't need to resolve if we're return an inproc server.
    if ( (S_OK == hr) && ! *pActParams->ppwszDllServer )
        hr = ResolveORInfo( pActParams);
    if (pActParams->ulMarshaledTargetInfoLength)
    {
       MIDL_user_free(pActParams->pMarshaledTargetInfo);
    }
    
    return hr;
}

//-------------------------------------------------------------------------
//
// ResolveORInfo
//
// On the server side of a remote activation, gets the OXID in the
// marshalled interface pointer.
//
// For a client side activation (local or remote), calls revolve OXID.
//
//-------------------------------------------------------------------------
HRESULT
ResolveORInfo(
    IN OUT PACTIVATION_PARAMS   pActParams
    )
{
    MInterfacePointer *     pIFD;
    OBJREF *                pObjRef;
    STDOBJREF *             pStdObjRef;
    DUALSTRINGARRAY *       pORBindings;
    DWORD                   DataSize;
    RPC_STATUS              sc;
    DWORD                   n;
    BOOL                    ActivatedRemote = pActParams->activatedRemote;

    // Don't resolve if we are servicing a remote activation and
    // we also did a remote activation(i.e LB router)
    if (pActParams->RemoteActivation && ActivatedRemote)
        return S_OK;

    //
    // This routine probes the interface data returned from the server's
    // OLE during a successfull activation, but we're still going to
    // protect ourself from bogus data.
    //

    if (pActParams->pActPropsOut)
    {
        HRESULT hr;
        pActParams->pIIDs = 0;
        pActParams->pResults = 0;
        pActParams->ppIFD = 0;
        hr = pActParams->pActPropsOut->GetMarshalledResults(&pActParams->Interfaces,
                                                            &pActParams->pIIDs,
                                                            &pActParams->pResults,
                                                            &pActParams->ppIFD);
        if (hr != S_OK)
            return hr;
    }

    pIFD = 0;
    for ( n = 0; n < pActParams->Interfaces; n++ )
    {
        pIFD = pActParams->ppIFD[n];
        if ( pIFD )
            break;
    }

    ASSERT( pIFD );

    if ( pIFD->ulCntData < 2*sizeof(ULONG) )
    {
        ASSERT( !"Bad interface data returned from server" );
        return S_OK;
    }

    pObjRef = (OBJREF *)pIFD->abData;

    if ( (pObjRef->signature != OBJREF_SIGNATURE) ||
         (pObjRef->flags & ~(OBJREF_STANDARD | OBJREF_HANDLER |
                             OBJREF_CUSTOM | OBJREF_EXTENDED)) ||
         (pObjRef->flags == 0) )
    {
        ASSERT( !"Bad interface data returned from server" );
        return S_OK;
    }

    // No OR info sent back for custom marshalled interfaces.
    if ( pObjRef->flags == OBJREF_CUSTOM )
        return S_OK;

    DataSize = 2*sizeof(ULONG) + sizeof(GUID);
    pStdObjRef = (STDOBJREF *)(pIFD->abData + DataSize);

    DataSize += sizeof(STDOBJREF);
    if ( pObjRef->flags == OBJREF_HANDLER )
        DataSize += sizeof(CLSID);
    else if( pObjRef->flags == OBJREF_EXTENDED)
        DataSize += sizeof(DWORD);

    pORBindings = (DUALSTRINGARRAY *)(pIFD->abData + DataSize);
    DataSize += 2 * sizeof(USHORT);

    if ( pIFD->ulCntData < DataSize )
    {
        ASSERT( !"Bad interface data returned from server" );
        return S_OK;
    }

    // If we activated the server on this machine, we need the OXID of the server.
    if ( ! ActivatedRemote )
        *pActParams->pOxidServer = *((OXID UNALIGNED *)&pStdObjRef->oxid);

    //
    // If we're servicing a remote activation, all we need is the server's OXID.
    // The client will call ResolveClientOXID from its ResolveORInfo.
    //
    if ( pActParams->RemoteActivation )
        return S_OK;

    DataSize += pORBindings->wNumEntries * sizeof(USHORT);

    if ( (pIFD->ulCntData < DataSize) ||
         (pORBindings->wNumEntries != 0 &&
         (pORBindings->wSecurityOffset >= pORBindings->wNumEntries)) )
    {
        ASSERT( !"Bad interface data returned from server" );
        // Bug 658576 - don't send back a non-zero oxid if 
        // server bindings are empty or corrupt.
        *pActParams->pOxidServer = 0;
        return S_OK;
    }

    //
    // If empty OR bindings were supplied then the server and client are
    // both local to this machine, so use the local OR bindings.
    //
    if (pORBindings->wNumEntries == 0)
    {
        sc = CopyMyOrBindings(pActParams->ppServerORBindings, NULL);
        if (sc != RPC_S_OK)
            return HRESULT_FROM_WIN32(sc);
    }
    else
    {
        //
        // This was a local activation so use our string bindings for the OR
        // binding string.
        //
        *pActParams->ppServerORBindings = (DUALSTRINGARRAY *)
                MIDL_user_allocate( sizeof(DUALSTRINGARRAY) +
                                    pORBindings->wNumEntries*sizeof(USHORT) );

        if ( ! *pActParams->ppServerORBindings )
            return E_OUTOFMEMORY;

        dsaCopy( *pActParams->ppServerORBindings, pORBindings );
    }

    //
    // If we did a remote activation then we already have the server's OXID and
    // OR string bindings from the RemoteActivation call and pieces of the OXID
    // info have been filled in.
    //

    // Could we optimize this at all for the local case?
    USHORT usAuthnSvc;
    sc = ResolveClientOXID( pActParams->hRpc,
    	                    pActParams->pOxidServer,
                            *pActParams->ppServerORBindings,
                            pActParams->Apartment,
                            pActParams->ProtseqId,
                            pActParams->pwszServer,
                            pActParams->pOxidInfo,
                            pActParams->pLocalMidOfRemote,
                            pActParams->UnsecureActivation,
                            pActParams->AuthnSvc,
                            pActParams->ulMarshaledTargetInfoLength,
                            pActParams->pMarshaledTargetInfo,
                            &pActParams->IsLocalOxid,
                            NULL,
                            NULL,
                            &usAuthnSvc);

    return HRESULT_FROM_WIN32(sc);
}

//-------------------------------------------------------------------------
//
// ActivateAtStorage
//
// If the given CLSID is marked with ActivateAtStorage, do a remote
// activation to the machine where the path points.
//
// Returns TRUE if a remote activation was tried or a wierd error was
// encoutered.  Returns FALSE if the CLSID is not marked with
// ActivateAtStorage or the file path is determined to be local.
//
//-------------------------------------------------------------------------
BOOL
ActivateAtStorage(
    IN OUT ACTIVATION_PARAMS *  pActParams,
    IN  CClsidData *            pClsidData,
    OUT HRESULT *               phr
    )
{
    //
    // See if we need to do a remote ActivateAtStorage activation.  If
    // a server name is given, then we either made a remote activation
    // already or the server name is for the local machine in which case
    // ActivateAtStorage is ignored.
    LPWSTR              pwszOrigSrvrName=NULL;
    pwszOrigSrvrName = GetOrigSrvrName(pActParams);

    if ( pActParams->RemoteActivation ||
         pActParams->pwszServer ||
         pwszOrigSrvrName ||
         !pActParams->pwszPath )
        return FALSE;

    // Note that if we have no information at all for a CLSID, we try a
    // atstorage activation.  Part of initial dcom spec.
    //
    if ( pClsidData && ! pClsidData->ActivateAtStorage() )
        return FALSE;


    HRESULT hr;
    WCHAR   wszMachineName[MAX_COMPUTERNAME_LENGTH+1];

    //

#ifdef DFSACTIVATION
    //
    // This is for DFS support.  If the file hasn't been opened yet, we must
    // open it before trying to resolve the DFS pathname in GetMachineName.
    // This is just how DFS works.  FindFirstFile results in the fewest number
    // of network packets.
    //
    if ( ! pActParams->FileWasOpened )
    {
        HANDLE          hFile;
        WIN32_FIND_DATA Data;

        if (pActParams->pToken != NULL)
            pActParams->pToken->Impersonate();

        hFile = FindFirstFile( pActParams->pwszPath, &Data );

        if ( hFile != INVALID_HANDLE_VALUE )
            (void) FindClose( hFile );

        if (pActParams->pToken != NULL)
            pActParams->pToken->Revert();

        if ( INVALID_HANDLE_VALUE == hFile )
        {
            *phr = CO_E_BAD_PATH;
            return TRUE;
        }
    }
#endif

    hr = GetMachineName(
                pActParams->pwszPath,
                wszMachineName
#ifdef DFSACTIVATION
                ,TRUE
#endif
                );

    if ( hr == S_FALSE )
    {
        // We couldn't get the machine name, path must be local.
        return FALSE;
    }
    else if ( hr != S_OK )
    {
        // We got an error while trying to find the UNC machine name.
        *phr = hr;
        return TRUE;
    }

    if ( gpMachineName->Compare( wszMachineName ) )
        return FALSE;

    *phr = RemoteActivationCall( pActParams, wszMachineName );

    return TRUE;
}

//-------------------------------------------------------------------------
//
// ActivateRemote
//
// Does a remote activation based off of the RemoteServerName registry key
// for the given CLSID.
//
// Returns TRUE if a remote activation was tried, FALSE if not.
//
//-------------------------------------------------------------------------
BOOL
ActivateRemote(
    IN OUT ACTIVATION_PARAMS *  pActParams,
    IN  CClsidData *            pClsidData,
    OUT HRESULT *               phr
    )
{
    WCHAR * pwszServerName;
    BOOL    bBadServerName;
    BOOL    bMyServerName;

    *phr = S_OK;

    //
    // The CClsidData class puts the remote server name(s) into a REG_MULTI_SZ
    // format.
    //
    pwszServerName = pClsidData->RemoteServerNames();

    // jsimmons 3/11/00 prefix bug fix.    We would crash below if RemoteServerNames
    // returned NULL (which is possible).   The only caller of this function checks 
    // that before calling us, though.   However, it doesn't hurt to make sure.
    if (!pwszServerName)
    {
        ASSERT(0);
        *phr = E_UNEXPECTED;
        return FALSE;
    }

    bBadServerName = TRUE;
    bMyServerName = TRUE;

    for ( ; *pwszServerName; pwszServerName += lstrlenW(pwszServerName) + 1 )
    {
        if ( pwszServerName[0] == L'\\' && pwszServerName[1] == L'\\' )
            pwszServerName += 2;

        while ( *pwszServerName &&
                (*pwszServerName == L' ' || *pwszServerName == L'\t') )
            pwszServerName++;

        if ( pwszServerName[0] == L'\0' )
            continue;

        bBadServerName = FALSE;

        if ( gpMachineName->Compare( pwszServerName ) )
            continue;

        bMyServerName = FALSE;

        *phr = RemoteActivationCall( pActParams, pwszServerName );

        if ( S_OK == *phr )
            break;
    }

    if ( bBadServerName || bMyServerName )
        return FALSE;

    return TRUE;
}

//-------------------------------------------------------------------------
//
// LookupObjectInROT
//
// Looks for an object (file path in this activation) in the Running Object
// Table.
//
// Returns TRUE if we found the object in the ROT and can pass its
// marshalled interface pointer directly back to the client.
//
//-------------------------------------------------------------------------
BOOL
LookupObjectInROT(
    IN  PACTIVATION_PARAMS  pActParams,
    OUT HRESULT *           phr )
{
    SCMREGKEY   Key;
    MNKEQBUF *  pMnkEqBuf;
    BYTE        Buffer[sizeof(DWORD)+ROT_COMPARE_MAX];

    pMnkEqBuf = (MNKEQBUF *) Buffer;

    *phr = CreateFileMonikerComparisonBuffer(
            pActParams->pwszPath,
            &pMnkEqBuf->abEqData[0],
            ROT_COMPARE_MAX,
            &pMnkEqBuf->cdwSize );

    if ( *phr != S_OK )
        return FALSE;

    *phr = gpscmrot->GetObject(
            pActParams->pToken,
            pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL,
            0,
            pMnkEqBuf,
            &Key,
            (InterfaceData **)&pActParams->pIFDROT );

    if ( *phr != S_OK )
        return FALSE;

    //
    // If our activation call is from a local client and for a single
    // interface then we can return success.  Otherwise we return failure
    // because we must call the server either to get more interface
    // pointers or because we are servicing a remote activation and must get
    // a normal marshalled interface pointer rather than the table marshalled
    // interface pointer sitting in the ROT.
    //
    if ( ! pActParams->RemoteActivation && (1 == pActParams->Interfaces) )
    {
        // Return the marshaled interface from the ROT to the caller.
        pActParams->ppIFD = (MInterfacePointer **)
                                MIDL_user_allocate(sizeof(MInterfacePointer *));
        pActParams->pResults = (HRESULT*) MIDL_user_allocate(sizeof(HRESULT));

        if ((pActParams->ppIFD==NULL) || (pActParams->pResults==NULL))
        {
            MIDL_user_free(pActParams->ppIFD);
            MIDL_user_free(pActParams->pResults);
            *phr = E_OUTOFMEMORY;
            return FALSE;
        }

        *pActParams->ppIFD = pActParams->pIFDROT;
        pActParams->pResults[0] = S_OK;

        // So we remember not to clean up the buffer
        pActParams->pIFDROT = NULL;

        // Let caller know that we got this from the ROT so
        // if it doesn't work they should try again.
        pActParams->FoundInROT = TRUE;
        *pActParams->pFoundInROT = TRUE;

        return TRUE;
    }

    //
    // REVIEW REVIEW.  Can we return success if the ROT object was marshalled
    // strong?  Do we really have to call the server if the object was
    // marshalled weak?  Is the resulting race condition any worse then for a
    // normal activation?
    //

    //
    // We can't use a tabled marshalled interface pointer to send back to a
    // remote client, so we return failure here, but keep the ROT interface
    // data in pIFDROT.
    //

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// Get the COSERVERINFO supplied by the client.  We'll use this to decide
// whether we want to do remote ActivateAtStorage.
//
//+---------------------------------------------------------------------------
LPWSTR GetOrigSrvrName(
    PACTIVATION_PARAMS pActParams
    )
{
    LPWSTR pwszOrigSrvrName = NULL;

    if (pActParams->pActPropsIn)
    {
        SecurityInfo* pLegacyInfo = pActParams->pActPropsIn->GetSecurityInfo();
        if (pLegacyInfo)
        {
            COSERVERINFO* pServerInfo = NULL;
            pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
            if (pServerInfo)
            {
                pwszOrigSrvrName = pServerInfo->pwszName;
            }
        }
    }

    return pwszOrigSrvrName;
}


//
//  Helper function.    ppid and pdwProcessReqType may be NULL if caller does not care about them.
// 
HRESULT GetProcessInfoFromActProps(IActivationPropertiesIn* pActPropsIn, DWORD* ppid, DWORD* pdwProcessReqType)
{
  HRESULT hr = E_INVALIDARG;

  ASSERT(pActPropsIn);

  if (pActPropsIn != NULL)
  {
    IServerLocationInfo *pSLInfo = NULL;

    hr = pActPropsIn->QueryInterface(IID_IServerLocationInfo, (void**) &pSLInfo);
    ASSERT(SUCCEEDED(hr) && pSLInfo);
    if (SUCCEEDED(hr) && pSLInfo != NULL)
    {
      DWORD dwPRT;
      DWORD dwPid;
      hr = pSLInfo->GetProcess(&dwPid, &dwPRT);
      ASSERT(SUCCEEDED(hr));
      ASSERT(dwPRT == PRT_IGNORE ||
             dwPRT == PRT_CREATE_NEW || 
             dwPRT == PRT_USE_THIS ||
             dwPRT == PRT_USE_THIS_ONLY);
      if (SUCCEEDED(hr))
      {
        if (ppid)
          *ppid = dwPid;

        if (pdwProcessReqType)
          *pdwProcessReqType = dwPRT;
      }
      pSLInfo->Release();
      pSLInfo = NULL;
    }
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\addrrefresh.cxx ===
//+-------------------------------------------------------------------
//
//  File:       addrrefresh.cxx
//
//  Contents:   Implements classes for handling dynamic TCP/IP address
//              changes
//
//  Classes:    CAddrRefreshMgr
//
//  History:    26-Oct-00   jsimmons      Created
//
//--------------------------------------------------------------------

#include "act.hxx"

// The single instance of this object
CAddrRefreshMgr gAddrRefreshMgr;

// Constructor
CAddrRefreshMgr::CAddrRefreshMgr() :
	_bListenedOnTCP(FALSE),
	_bCheckedForIPV6(FALSE),
	_bIPV6Installed(FALSE)
{
	InitACD(&_IPV4AddrChangeData, AF_INET);
	InitACD(&_IPV6AddrChangeData, AF_INET6);	
}

//
//  InitACD
//
//  Initializes a new ADDRESS_CHANGE_DATA structure for use.
//
void CAddrRefreshMgr::InitACD(ADDRESS_CHANGE_DATA* paddrchangedata, int addrfamily)
{
	ASSERT(paddrchangedata);
	
	ZeroMemory(paddrchangedata, sizeof(ADDRESS_CHANGE_DATA));
	paddrchangedata->dwSig = ADDRCHANGEDATA_SIG;
	paddrchangedata->socket = INVALID_SOCKET;
	paddrchangedata->socket_af = addrfamily;	
	paddrchangedata->pThis = this;
}


// 
//  RegisterForAddressChanges
//
//  Method to tell us to register with the network
//  stack to be notified of address changes.  This is
//  a best-effort, if it fails we simply return; if
//  that happens, DCOM will not handle dynamic address
//  changes.  Once this method succeeds, calling it
//  is a no-op until an address change notification
//  is signalled.
//
//  Caller must be holding gpClientLock.
//
void CAddrRefreshMgr::RegisterForAddressChanges()
{
	ASSERT(gpClientLock->HeldExclusive());
	
	// If we haven't yet listened on TCP, there is
	// no point in any of this
	if (!_bListenedOnTCP)
		return;

	// Always register for IPV4 changes (currently it's not possible
	// to install TCP/IP and not get IPV4)
	RegisterForAddrChangesHelper(&_IPV4AddrChangeData);

	// Register for IPV6 changes if it's installed
	if (IsIPV6Installed())
	{
		RegisterForAddrChangesHelper(&_IPV6AddrChangeData);
	}
	
	return;
}


//
//  RegisterForAddrChangesHelper
//
//  Registers address change notifications for a specific ADDRESS_CHANGE_DATA 
//  struct. This is a best-effort, if it fails we simply return; if that happens, 
//  DCOM will not handle dynamic address changes.  Once this method succeeds, 
//  calling it again for the same ADDRESS_CHANGE_DATA is a no-op until an address 
//  change notification is signalled.
//
void CAddrRefreshMgr::RegisterForAddrChangesHelper(ADDRESS_CHANGE_DATA* pAddrChangeData)
{
	ASSERT(gpClientLock->HeldExclusive());
	ASSERT(_bListenedOnTCP);
	
	if (pAddrChangeData->hAddressChangeEvent == NULL)
	{
		pAddrChangeData->hAddressChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!pAddrChangeData->hAddressChangeEvent)
			return;
	}

	// We do not call WSAStartup, it is the responsibility of the caller
	// to make sure WSAStartup has already been been called successfully.
	// In practice, not calling this function until after we have 
	// successfully listened on TCP satisfies this requirement.
	if (pAddrChangeData->socket == INVALID_SOCKET)
	{
        pAddrChangeData->socket = WSASocket(pAddrChangeData->socket_af,
                                             SOCK_STREAM,
                                             IPPROTO_TCP,
                                             NULL,
                                             0,
                                             WSA_FLAG_OVERLAPPED
                                             );
        if (pAddrChangeData->socket == INVALID_SOCKET)
		{
			KdPrintEx((DPFLTR_DCOMSS_ID,
					   DPFLTR_WARNING_LEVEL,
					   "Failed to create notification socket\n"));
			return;
		}
	}

	// First make sure we have successfully registered for a 
	// wait on the notification event with the NT thread pool
	if (!pAddrChangeData->bWaitRegistered)
	{
		pAddrChangeData->bWaitRegistered = RegisterWaitForSingleObject(
									&(pAddrChangeData->hWaitObject),
									pAddrChangeData->hAddressChangeEvent,
									CAddrRefreshMgr::TimerCallbackFn,
									pAddrChangeData,
									INFINITE,
									0);
		if (!pAddrChangeData->bWaitRegistered)
		{
			KdPrintEx((DPFLTR_DCOMSS_ID,
					   DPFLTR_WARNING_LEVEL,
					   "RegisterWaitForSingleObject failed\n"));
			return;
		}
	}

	// Setup the notification again if we failed to register last time,
	// or if this is the first time we've ever been here
	if (!pAddrChangeData->bRegisteredForNotifications)
	{
		// Initialize overlapped structure
		ZeroMemory(&(pAddrChangeData->WSAOverlapped), sizeof(pAddrChangeData->WSAOverlapped));
		pAddrChangeData->WSAOverlapped.hEvent = pAddrChangeData->hAddressChangeEvent;

		int err;
		DWORD dwByteCnt;
		err = WSAIoctl(
					pAddrChangeData->socket,
					SIO_ADDRESS_LIST_CHANGE,
					NULL,
					0,
					NULL,
					0,
					&dwByteCnt,
					&(pAddrChangeData->WSAOverlapped),
					NULL
					);
		pAddrChangeData->bRegisteredForNotifications =
						(err == 0) || (WSAGetLastError() == WSA_IO_PENDING);
		if (!pAddrChangeData->bRegisteredForNotifications)
		{
			KdPrintEx((DPFLTR_DCOMSS_ID,
					   DPFLTR_WARNING_LEVEL,
					   "Failed to request ip change notification on socket (WSAGetLastError=%u)\n",
					   WSAGetLastError()));
			return;
		}
	}

	// Success
	KdPrintEx((DPFLTR_DCOMSS_ID,
			   DPFLTR_INFO_LEVEL,
			   "DCOM: successfully registered for address change notifications\n"));

	return;
}

// 
//  TimerCallbackFnHelper
//
//  Helper function to handle address change notifications.
//
//  Does the following tasks:
//   1) re-registers for further address changes
//   2) recomputes current resolver bindings
//   3) pushes new bindings to currently running processes; note
//      that this is done async, so we don't tie up the thread.
//
void CAddrRefreshMgr::TimerCallbackFnHelper(ADDRESS_CHANGE_DATA* paddrchangedata)
{
	RPC_STATUS status;

	gpClientLock->LockExclusive();
	ASSERT(gpClientLock->HeldExclusive());

	paddrchangedata->dwNotifications++;

	// The fact that we we got this callback means that our
	// previous registration has been consumed.  Remember
	// that fact so we can re-register down below.
	paddrchangedata->bRegisteredForNotifications = FALSE;

	// re-register for address changes.  The ordering of when
	// we do this and when we query for the new list is impt, 
	// see docs for WSAIoctl that talk about proper ordering
	// of SIO_ADDRESS_LIST_CHANGE and SIO_ADDRESS_LIST_QUERY.
	RegisterForAddrChangesHelper(paddrchangedata);

	// Tell machine address object that addresses have changed
	gpMachineName->IPAddrsChanged(paddrchangedata->socket_af);

	// Compute new resolver bindings
	status = ComputeNewResolverBindings();

	// Release lock now, so we don't hold it across PushCurrentBindings
	ASSERT(gpClientLock->HeldExclusive());
	gpClientLock->UnlockExclusive();

	if (status == RPC_S_OK)
	{
		// Push new bindings to running processes
		PushCurrentBindings();
	}

	return;
}


// 
//  TimerCallbackFn
//
//  Static entry point that gets called by NT thread pool whenever
//  a notification event is signalled.  pvParam points to the
//  ADDRESS_CHANGE_DATA for the changed notification.
//
void CALLBACK CAddrRefreshMgr::TimerCallbackFn(void* pvParam, BOOLEAN TimerOrWaitFired)
{
	ASSERT(!TimerOrWaitFired);  // should always be FALSE, ie event was signalled

	ADDRESS_CHANGE_DATA* paddrchangedata = (ADDRESS_CHANGE_DATA*)pvParam;

	ASSERT(paddrchangedata);
	ASSERT(paddrchangedata->dwSig == ADDRCHANGEDATA_SIG);
	ASSERT(paddrchangedata->pThis == &gAddrRefreshMgr);
	
	paddrchangedata->pThis->TimerCallbackFnHelper(paddrchangedata);

	return;
}


// 
//  IsIPV6Installed
//
BOOL CAddrRefreshMgr::IsIPV6Installed()
{
	if (_bCheckedForIPV6)
		return _bIPV6Installed;

	// don't do anything until we've listened on TCP
	if (!_bListenedOnTCP)
		return FALSE;

	// Try to check again
	CheckForIPV6Installed();

	// If check was successful return answer, otherwise say no
	return _bCheckedForIPV6 ? _bIPV6Installed : FALSE;
}

// 
//  CheckForIPV6Installed
//
//  Helper function that checks to see if IPV6 is installed;
//  sets as a side-effect, upon success, _bCheckedForIPV6 and
//  _bIPV6Installed.   Note that like other configureable DCOM
//  protocols, we don't support dynamic configuration (ie, you
//  must reboot for DCOM to recognize that IPV6 is installed).
//
void CAddrRefreshMgr::CheckForIPV6Installed()
{
	BYTE* pProtocolBuffer = NULL;
	WSAPROTOCOL_INFO* lpProtocolInfos = NULL;
	DWORD dwBufLen = 0;
	int iRet = 0;
	BOOL fIPV6Installed = FALSE;

	if (_bCheckedForIPV6)
		return;
	
	// Ask for buffer size
	dwBufLen = 0;
	iRet = WSAEnumProtocols(NULL, lpProtocolInfos, &dwBufLen);
	if (iRet != SOCKET_ERROR) goto done;  // should not succeed
	if (WSAENOBUFS != WSAGetLastError()) goto done; // should fail for insuf. buffer

	// Allocate memory
	pProtocolBuffer = new BYTE[dwBufLen];
	if (!pProtocolBuffer) goto done;

	lpProtocolInfos = (WSAPROTOCOL_INFO*)pProtocolBuffer;
	
	// Make call for real this time
	iRet = WSAEnumProtocols(NULL, lpProtocolInfos, &dwBufLen);
	if (iRet == SOCKET_ERROR) goto done;

	// Enumerate thru the installed protocols, looking for IPV6
	for (int i = 0; i < iRet; i++)
	{
		if (lpProtocolInfos[i].iAddressFamily == AF_INET6)
		{
			fIPV6Installed = TRUE;
			break;
		}
	}

	// We're done
	_bCheckedForIPV6 = TRUE;
	_bIPV6Installed = fIPV6Installed;

done:
	if (pProtocolBuffer)
		delete [] pProtocolBuffer;

	return;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\class.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       class.cxx
//
//  Contents:   Server table entry implementation
//
//  History:                VinayKr     Created
//              06-Nov-98   TarunA      Launch and shutdown logic change
//              24-Feb-99   TarunA      Fix custom surrogate launch
//              17-Jun-99   a-sergiv    Support for filtering RPCSS event logs
//
//--------------------------------------------------------------------------

#include "act.hxx"

CServerTable * gpClassTable = NULL;
CServerTable * gpProcessTable = NULL;

CSharedLock * gpClassLock = 0;
CSharedLock * gpProcessLock = 0;

CInterlockedInteger gRegisterKey( 1 );

//
// Default number of milliseconds to wait for a server to register its
// class factory before giving up and forcefully terminating it.
//
DWORD gServerStartTimeout = 120000;

//
// Default number of milliseconds to wait for a class factory registration
// after we detect that the launched server has died (for supporting cases
// where the server we launch turns around and launches another, then dies
// immediately)
//
DWORD gServerStartSecondChanceTimeout = 30000;

//
// Default number of milliseconds to wait for an NT service server to register 
// before we wake up and query its status.  At most we wait for 
// gNTServiceMaxTimeouts of these periods (see code in WaitForService below).
//
DWORD gNTServiceInterrogatePeriod = 30000;
DWORD gNTServiceMaxTimeouts = 4;

//
// Default number of milliseconds that we block while waiting for a dllhost
// server to register.    There is a startup protocol here - we block for 
// thirty seconds, then check the state of the launched process. 
//
DWORD gDllhostServerStartTimeout = 30000;

//
// Maxiumum number of milliseconds we will wait while waiting for a dllhost
// server to register.  There is a protocol yes, but this is the upper time
// bound no matter what. 
//
DWORD gDllhostMaxServerStartTimeout = 90000;

//
// Default number of milliseconds to wait for a dllhost to finish 
// long-running initialization.
//
DWORD gDllhostInitializationTimeout = 90000;

void GetSessionIDFromActParams(IActivationPropertiesIn* pActPropsIn, LONG* plSessionID)
{
    *plSessionID = INVALID_SESSION_ID;

    if (pActPropsIn != NULL)
    {
        ISpecialSystemProperties *pSp = NULL;
        HRESULT hr;

        hr = pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**) &pSp);
        if (SUCCEEDED(hr) && pSp != NULL)
        {
            ULONG ulSessionID;
            BOOL bUseConsole;

            hr = pSp->GetSessionId(&ulSessionID, &bUseConsole);
            if (SUCCEEDED(hr))
            {
                if (!bUseConsole && (ulSessionID != INVALID_SESSION_ID))
                {
                    // Just use whatever was there
                    *plSessionID = (LONG) ulSessionID;
                }
                else if (bUseConsole)
                {
                    // Little bit of magic here regarding how to find the
                    // currently active NT console session ID.
                    *plSessionID = (USER_SHARED_DATA->ActiveConsoleId);
                }
            }

            pSp->Release();
            pSp = NULL;
        }
    }
}

//+-------------------------------------------------------------------------
//
// CServerTable::GetOrCreate
//
// A somewhat degenerate combination of Lookup and Create -- only creates
// empty entries -- in particular without hooking up process entry if the
// entry being created is a class entry -- used only to create process entries
// and to create class entries for unsolicited CoRegisterClassObject calls
//
//--------------------------------------------------------------------------
CServerTableEntry *
CServerTable::GetOrCreate(
    IN  GUID & ServerGuid
    )
{
    CServerTableEntry *  pEntry;

    pEntry = Lookup( ServerGuid );

    if ( pEntry )
        return pEntry;
    else
        return Create(ServerGuid);
}

//+-------------------------------------------------------------------------
//
// CServerTable::Create
//
//  Creates a new CServerTableEntry, or returns an existing one.
//
//--------------------------------------------------------------------------
CServerTableEntry *
CServerTable::Create(
    IN  GUID   &  ServerGuid
    )
{
    BOOL fEntryFoundInTable = FALSE;

    _pServerTableLock->LockExclusive();

    // Must use CGuidTable::Lookup method because it doesn't take
    // a shared lock. Already have the exclusive lock.
    CServerTableEntry *pNewEntry = (CServerTableEntry *) CGuidTable::Lookup( &ServerGuid );

    if (pNewEntry)
    {
        pNewEntry->Reference();     // Found an entry, take a reference on it
        fEntryFoundInTable = TRUE;
    }
    else
    {
        LONG Status = ERROR_SUCCESS;
        pNewEntry = new CServerTableEntry( Status, &ServerGuid, _EntryType );

        if ( ! pNewEntry )
        {
            _pServerTableLock->UnlockExclusive();
            return NULL;
        }

        if ( Status != ERROR_SUCCESS )
        {
            _pServerTableLock->UnlockExclusive();
            pNewEntry->Release();
            return NULL;
        }
    }

    if (!fEntryFoundInTable)
    {
        Add( pNewEntry );
    }

    _pServerTableLock->UnlockExclusive();
    return pNewEntry;
}


//+-------------------------------------------------------------------------
//
// CServerTable::Lookup
//
//--------------------------------------------------------------------------
CServerTableEntry *
CServerTable::Lookup(
    IN  GUID & ServerGuid
    )
{
    CServerTableEntry *  pServerTableEntry;

    _pServerTableLock->LockShared();
    pServerTableEntry = (CServerTableEntry *) CGuidTable::Lookup( &ServerGuid );
    if ( pServerTableEntry )
        pServerTableEntry->Reference();
    _pServerTableLock->UnlockShared();

    return pServerTableEntry;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::CServerTableEntry
//
//--------------------------------------------------------------------------
CServerTableEntry::CServerTableEntry(
    OUT LONG&   Status,
    IN  GUID * pServerGUID,
    IN  EnumEntryType EntryType
    ) :
    CGuidTableEntry( pServerGUID ), _EntryType(EntryType)
    ,_ServerLock( Status ), _lThreadToken(0), _hProcess(0), _pProcess(NULL)
    ,_pvRunAsHandle(NULL), _bSuspendedClsid(FALSE), _bSuspendedApplication(FALSE),
    _dwProcessId(0)
{
    switch (_EntryType)
    {
    case ENTRY_TYPE_CLASS:
        _pParentTable = gpClassTable;
        break;

    case ENTRY_TYPE_PROCESS:
        _pParentTable = gpProcessTable;
        break;

    default:
        if (Status == ERROR_SUCCESS)
			Status = E_INVALIDARG;
    }

    _pParentTableLock = _pParentTable->_pServerTableLock;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::~CServerTableEntry
//
//--------------------------------------------------------------------------
CServerTableEntry::~CServerTableEntry()
{
    ASSERT(_pParentTableLock->HeldExclusive());
	
    // Remove ourselves from the table - this will be a no-op if we 
    // we were never actually added.
    _pParentTable->Remove(this);

    if(NULL != _pProcess)
    {
        ReleaseProcess(_pProcess);
    }

    ASSERT(_pvRunAsHandle == NULL);
    ASSERT(_hProcess == NULL);
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::Release
//
//--------------------------------------------------------------------------
DWORD
CServerTableEntry::Release()
{
    DWORD Refs;
    CSharedLock* pParentTableLock = _pParentTableLock;

    CairoleDebugOut((DEB_SCM, "Releasing ServerTableEntry at 0x%p\n", this));

    pParentTableLock->LockExclusive();

    Dereference();
    if ( 0 == (Refs = References()) )
    {
        delete this;
    }

    pParentTableLock->UnlockExclusive();

    return Refs;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RegisterServer
//
//--------------------------------------------------------------------------
HRESULT
CServerTableEntry::RegisterServer(
    IN  CProcess *      pServerProcess,
    IN  IPID            ipid,
    IN  CClsidData *    pClsidData, OPTIONAL
    IN  CAppidData *    pAppidData,
    IN  UCHAR           ServerState,
    OUT DWORD *         pRegistrationKey )
{
    CServerListEntry *      pEntry;
    CSurrogateListEntry *   pSurrogateEntry;

    UCHAR Context = 0;
    UCHAR SubContext = 0;

    if (pClsidData)
    {
        if ( (pClsidData->ServerType() == SERVERTYPE_SERVICE) ||
             (pClsidData->ServerType() == SERVERTYPE_COMPLUS_SVC) )
        {
            Context = SERVER_SERVICE;
        }
        else if ( pClsidData->HasRunAs() )
        {
            Context = SERVER_RUNAS;

            if ( pClsidData->IsInteractiveUser() )
                SubContext = SUB_CONTEXT_RUNAS_INTERACTIVE;
            else
                SubContext = SUB_CONTEXT_RUNAS_THIS_USER;
        }
        // Special case of COM+ library class being loaded by VB for debugging
        else if ( pClsidData->ServerType() == SERVERTYPE_COMPLUS && pClsidData->IsInprocClass() )
        {
            Context = SERVER_RUNAS;
        }
    }

    if ( _EntryType == ENTRY_TYPE_PROCESS )
    {
        // This is the COM+/COM surrogate case
        ASSERT(NULL == pClsidData  && "Process Entry Given Clsid data");
        ASSERT(NULL != pAppidData  && "Process Entry Not Given Appid data");
        if (pAppidData->Service())
        {
            Context = SERVER_SERVICE;
        }
        else if ((pAppidData->IsInteractiveUser()) || pAppidData->RunAsUser())
        {
            Context = SERVER_RUNAS;
        }
    }

    // If none of the above applied, Context will be zero at this point -- this
    // essentially means the server should be treated as an activate-as-activator
    // server.   However, if Context is zero SubContext had better also be zero,
    // and so we assert that here.   
    if (Context == 0)
    {
        Context = SERVER_ACTIVATOR;
        ASSERT(SubContext == 0);
    }

    pEntry = new CServerListEntry(
                    this,
                    pServerProcess,
                    ipid,
                    Context,
                    ServerState,
					SubContext);

    if ( ! pEntry )
        return E_OUTOFMEMORY;

    // Add registration to the process object -- but only if we are a class entry;
    // otherwise this is a registration for a surrogate server
    if ( _EntryType == ENTRY_TYPE_CLASS )
    {
      pEntry->AddToProcess( Guid() );
    }
    
    // 
    SetSuspendedFlagOnNewServer(pServerProcess);

    //
    // NOTE: The entry should be inserted in the lists only after
    // all the registration specific stuff has been done. This will
    // ensure that anyone outside this procedure sees the complete
    // entry and not some half-baked one
    //

    ServerLock()->LockExclusive();
    // Check if process handle exists implying that a
    // launch is in progress for this class.  Try to
    // register runas,process, and threadtoken with
    // the newly created entry
    // Note that it is essential for the server lock to
    // be held since _hProcess can change otherwise.
    if (_hProcess || _pProcess)
        RegisterHandles(pEntry, pServerProcess);
    _ServerList.Insert( pEntry );
    ServerLock()->UnlockExclusive();

    //
    // It's possible that a process could register itself as a surrogate but
    // there's no CLSID info in the registry.  We might want to disallow
    // this kind of register.
    //
    // Note: We allow class registration if appid is not present but don't
    // allow surrogate registration since it'll never be found
    // The right thing to do would be to reject the call completely when
    // an appid is not present but we will take the path of least resistance
    // and preserve legacy
    if ( pClsidData && (ServerState & SERVERSTATE_SURROGATE) && pClsidData->AppidString() )
    {
        pSurrogateEntry = new CSurrogateListEntry( pClsidData->AppidString(), pEntry );

        if ( ! pSurrogateEntry )
        {
            pEntry->CReferencedObject::Release();
            return E_OUTOFMEMORY;
        }

        gpSurrogateList->Insert( pSurrogateEntry );
    }

    *pRegistrationKey = pEntry->RegistrationKey();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RevokeServer -- version 1 for class entries
//
// CODE WORK: Consider defining two separate classes for class and
//            process entries so we can avoid this sort of thing
//
//--------------------------------------------------------------------------
void
CServerTableEntry::RevokeServer(
    IN  CProcess *      pServerProcess,
    IN  DWORD           RegistrationKey
    )
{
    ASSERT(_EntryType == ENTRY_TYPE_CLASS);

    ServerLock()->LockExclusive();

    CServerListEntry *  pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( (RegistrationKey == pEntry->_RegistrationKey)
             && (pServerProcess == pEntry->_pServerProcess)
           )
            break;
    }

    if ( pEntry )
        _ServerList.Remove( pEntry );

    ServerLock()->UnlockExclusive();

    if ( pEntry )
    {
        pEntry->RemoveFromProcess();
        pEntry->Release();
    }
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RevokeServer -- version 2 for process entries
//
//--------------------------------------------------------------------------
void
CServerTableEntry::RevokeServer(
    IN  ScmProcessReg * pScmProcessReg
    )
{
    ASSERT(_EntryType == ENTRY_TYPE_PROCESS);

    ServerLock()->LockExclusive();

    CServerListEntry * pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( (pScmProcessReg->RegistrationToken == pEntry->_RegistrationKey)
           )
            break;
    }

    if ( pEntry )
        _ServerList.Remove( pEntry );

    ServerLock()->UnlockExclusive();

    if ( pEntry )
    {
        pEntry->RemoveFromProcess();
        pEntry->Release();
    }
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::LookupServer
//
//--------------------------------------------------------------------------
BOOL
CServerTableEntry::LookupServer(
    IN  CToken *            pClientToken,
    IN  BOOL                bRemoteActivation,
	IN  BOOL                bClientImpersonating,
    IN  WCHAR             * pwszWinstaDesktop,
    IN  DWORD               dwFlags,
    IN  LONG                lThreadToken,
    IN  LONG                lSessionID,
    IN  DWORD               pid,
    IN  DWORD               dwProcessReqType,
    OUT CServerListEntry ** ppServerListEntry)
{
    CServerListEntry * pEntry;
    
    *ppServerListEntry = NULL;

    // If we are suspended, no need to go any further
    if (IsSuspended())
      return FALSE;

    ServerLock()->LockShared();

    pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match( pClientToken,
                            bRemoteActivation,
							bClientImpersonating,
							pwszWinstaDesktop,
                            FALSE,
                            lThreadToken,
                            lSessionID,
                            pid,
                            dwProcessReqType,
                            dwFlags ) )
        {
            pEntry->Reference();
            break;
        }
    }

    ServerLock()->UnlockShared();

    *ppServerListEntry = pEntry;
    return (pEntry != 0);
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::LookupServer
//
//--------------------------------------------------------------------------
BOOL
CServerTableEntry::LookupServer(
    IN  DWORD           RegistrationKey,
    CServerListEntry ** ppServerListEntry )
{
    CServerListEntry * pEntry;

    ServerLock()->LockShared();

    pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( RegistrationKey == pEntry->_RegistrationKey )
            break;
    }

    if ( pEntry )
        pEntry->Reference();

    ServerLock()->UnlockShared();

    *ppServerListEntry = pEntry;
    return (pEntry != 0);
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::UnsuspendServer
//
//--------------------------------------------------------------------------
void
CServerTableEntry::UnsuspendServer(
    IN  DWORD   RegistrationKey
    )
{
    CServerListEntry * pEntry;

    LookupServer( RegistrationKey, &pEntry );

    if ( pEntry )
    {
        pEntry->_State &= ~SERVERSTATE_SUSPENDED;
        pEntry->Release();
    }
}

//+-------------------------------------------------------------------------
// CServerTableEntry::ServerExists
//+-------------------------------------------------------------------------
HRESULT
CServerTableEntry::ServerExists(
    IN  ACTIVATION_PARAMS * pActParams, BOOL *pfExist)
{
    LONG lSessionID = INVALID_SESSION_ID;
    ServerLock()->LockShared();

    GetSessionIDFromActParams(pActParams->pActPropsIn, &lSessionID);

    CServerListEntry *pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match(
               pActParams->pToken,
               pActParams->RemoteActivation,
               pActParams->bClientImpersonating,
               pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,
               FALSE,
               0,
               lSessionID ))
        {
            break;
        }
    }

    ServerLock()->UnlockShared();

    *pfExist = (pEntry != NULL);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::CallRunningServer
// Synopsis: The behavior of CallRunningServer is best described by this matrix
//
// If the call is made successfully then we return
// If CallServer() returns error then we take the following action
// ----------------------------------------------------------------------------
// |     | RPC_E_SERVERFAULT     |  CO_E_SERVER_STOPPING | Other Errors        |
// ----------------------------------------------------------------------------
// | COM | Kill the process      | Remove the list entry |Remove the list entry|
// |     | Remove the list entry | Try launching another |Try launching another|
// |     | Try launching another | process               |process              |
// |     | process               |                       |                     |
// |     |                       |                       |                     |
// -----------------------------------------------------------------------------
// | COM+| Kill the process      | Set a timeout period  |If process exists    |
// |     | Remove the list entry | If the server         |then                 |
// |     | Return the error      | stops before timeout  | return error        |
// |     |                       | then                  |else                 |
// |     |                       |  try launching        | Remove the entry    |
// |     |                       |  another process      | try launching       |
// |     |                       | else                  | another process     |
// |     |                       |   return error        |                     |
// -----------------------------------------------------------------------------

//--------------------------------------------------------------------------
BOOL
CServerTableEntry::CallRunningServer(
    IN  ACTIVATION_PARAMS * pActParams,
    IN  DWORD               dwFlags,
    IN  LONG                lLaunchThreadToken,
    IN  CClsidData *        pClsidData,
    OUT HRESULT *           phr
    )
{
    BOOL              bStatus;
    LONG              lSessionID = INVALID_SESSION_ID;
    CServerListEntry* pEntry;
    
    GetSessionIDFromActParams(pActParams->pActPropsIn, &lSessionID);

    for (;;)
    {
        BOOL bTerminatedServer;

        bStatus = LookupServer(
                    pActParams->pToken,
                    pActParams->RemoteActivation,
                    pActParams->bClientImpersonating,
                    pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,
                    dwFlags,
                    lLaunchThreadToken,
                    lSessionID,
                    pActParams->dwPID,
                    pActParams->dwProcessReqType,
                    &pEntry);
        if (!bStatus)
        {
            ASSERT(!pEntry);
            return FALSE;
        }

        *phr = S_OK;

        //
        // If the entry is "initializing", then it isn't really ready yet.
        // Wait for it to become so.
        //
        if (pEntry->IsInitializing())
        {            
            *phr = WaitForInitCompleted(pEntry, pClsidData);
            if (FAILED(*phr))
            {
                if (*phr == CO_E_SERVER_STOPPING)
                    bStatus = FALSE;
                else
                    bStatus = TRUE;
            }
        }

        //
        // Returns TRUE if we successfully make a call to this server, or
        // if an unrecoverable non-server-related error is encountered 
        // (e.g, an out-of-mem failure while allocating data before or 
        // after the call).
        //
        // The final HRESULT is not necessarily S_OK.
        //
        if (SUCCEEDED(*phr))
            bStatus = pEntry->CallServer(pActParams, phr);
        if (!bStatus)
        {
            // We were unable to talk to the server, or got back
            // CO_E_SERVER_STOPPING.
            
            // Retrieve the process handle, if we have one
            HANDLE hProcess = pEntry->GetProcess()->GetProcessHandle();

            bTerminatedServer = FALSE;

            // Try to kill the server if it returned RPC_E_SERVERFAULT (this
            // means that we caught an unhandled exception somewhere in the 
            // server, which we don't really appreciate.)
            if(*phr == RPC_E_SERVERFAULT)
            {
                if(hProcess)
                {
                    bTerminatedServer = TerminateProcess(hProcess, 0);
                }

                // Remember that the server blew up on us.  This is mostly
                // for debugging purposes
                pEntry->IncServerFaults();
            }
			            
            //
            // Determine if we need to remove the server entry.  We will do this if
            // a) we killed the server process up above; or b) the server returned
            // CO_E_SERVER_STOPPING; or c) the server process is dead already.
            //
            if (bTerminatedServer || 
                (*phr == CO_E_SERVER_STOPPING) ||
                pEntry->ServerDied())
            {
                BOOL bRemoved;

                //
                // Remove this server entry if it's still in the list.
                //
                ServerLock()->LockExclusive();

                bRemoved = _ServerList.InList(pEntry);
                if (bRemoved)
                    _ServerList.Remove(pEntry);

                ServerLock()->UnlockExclusive();
				
                // Need to remove this entry from the surrogate list as
                // well, if applicable
                (void)gpSurrogateList->RemoveMatchingEntry(pEntry);

                if (bRemoved)
                {
                    pEntry->RemoveFromProcess();
                    pEntry->Release();
                }
            }
            // 6ba => we should not retry calls into the server
            else if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(*phr)) 
            {
               bStatus = TRUE;
            }
        }

        // Now allow threads other than launching one to access
        // this entry. Exit since we matched launched server
        // regardless of result since we know that we will
        // not get any more matches.
        if (lLaunchThreadToken)
        {
            pEntry->SetThreadToken(0);
            pEntry->Release();
            return bStatus;
        }

        pEntry->Release();

        if ( bStatus )
            return TRUE;
    }
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::StartServerAndWait
//
//--------------------------------------------------------------------------
HRESULT
CServerTableEntry::StartServerAndWait(
    IN  ACTIVATION_PARAMS * pActParams,
    IN  CClsidData *        pClsidData,
    IN  LONG                &lLaunchThreadToken
    )
{
    SC_HANDLE       hService;
    HRESULT         hr;
    BOOL            bStatus;
    BOOL            bServiceAlreadyRunning = FALSE;
    DWORD           dwActvFlags;

    if ( ! pClsidData->LaunchAllowed( pActParams->pToken, pActParams->ClsContext ) )
        return E_ACCESSDENIED;

    // Check CreateProcessMemoryGate
    // [a-sergiv (Sergei O. Ivanov)  11/1/99  Implemented Memory Gates in COM Base
    if(pActParams->pActPropsIn)
    {
        BOOL bResult = TRUE;
        IClassClassicInfo *pClassicInfo = NULL;     
        hr = pActParams->pActPropsIn->GetClassInfo(IID_IClassClassicInfo, (void**) &pClassicInfo);

        if(SUCCEEDED(hr) && pClassicInfo)
        {
            IResourceGates *pResGates = NULL;
            hr = pClassicInfo->GetProcess(IID_IResourceGates, (void**) &pResGates);
            pClassicInfo->Release();

            if(SUCCEEDED(hr) && pResGates)
            {
                hr = pResGates->Test(CreateProcessMemoryGate, &bResult);
                pResGates->Release();

                if(SUCCEEDED(hr) && !bResult)
                {
                    // The gate said NO!
                    return E_OUTOFMEMORY;
                }
            }
        }
    }

    hService = 0;

    // NOTE: _hProcess, _dwProcessId, _pProcess and all other process specific
    // variables that are part of CServerTableEntry are used only during the
    // launch. Once the launch is completed either they are transferred to
    // process specific entries or discarded. See CServerTableEntry::RegisterHandles
    // for an example.
    _dwProcessId = 0;

    // _hProcess and _pProcess variables are released and set to
    // null whether
    // (1) This is the first launch
    // OR
    // (2) We succeeded in an earlier launch or failed
    ASSERT((0 == _hProcess) && (NULL == _pProcess));

    //
    // Get the register event for the server we're about to launch.  Note
    // there exists a problem in that we may launch a server, but another
    // server may register the desired clsid\appid at about the same time.
    // I think this is just something we have to live with, especially since
    // there are servers in the world that don't register with us, but instead
    // turn around and launch another process to do the registration.  So, 
    // even if we have a process handle it would be impossible to always 
    // correlate from register event back to the launching table entry.
    //
    CNamedObject* pRegisterEvent = pClsidData->ServerRegisterEvent();
    if (!pRegisterEvent)
      return E_OUTOFMEMORY;

    if (pClsidData->ServerType() == SERVERTYPE_SURROGATE)
    {
        ASSERT(_EntryType == ENTRY_TYPE_CLASS);

        LPWSTR pwszAppidString = pClsidData->AppidString();
        CSurrogateListEntry * pSurrogateListEntry = NULL;

        if(pwszAppidString)
        {
            pSurrogateListEntry = gpSurrogateList->Lookup(
                                        pActParams->pToken,
                                        pActParams->RemoteActivation,
                                        pActParams->bClientImpersonating,
                                        pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,                                    
                                        pwszAppidString );
        }

        if ( pSurrogateListEntry )
        {
            // If we find a surrogate entry and we are inside a launch
            // server then that implies that a surrogate was launched for
            // a different class' activation. We have a process entry for
            // this surrogate and we set it here. Later when RegisterServer
            // gets called we use the process object to set the state.
            // For all other cases, the state is set using the process handle.
            _pProcess =  pSurrogateListEntry->Process();
            ASSERT(NULL !=_pProcess);
            // We will release this on every path below
            ReferenceProcess( _pProcess, TRUE );

            // Remember the launching thread's token
            _lThreadToken = lLaunchThreadToken;

            // Load the dll that will service the activation request
            bStatus = pSurrogateListEntry->LoadDll( pActParams, &hr );
            pSurrogateListEntry->Release();

            // A status of TRUE implies that we successfully talked to the
            // server
            if (bStatus)
            {
                // A successful hresult implies that the server was able to
                // load the dll successfully and hence we expect it to
                // register back
                if(SUCCEEDED(hr))
                {
                    // Wait for the loaded object server to register back
                    bStatus = WaitForSingleObject( pRegisterEvent->Handle(), 30000 );
                }
                // If the server failed to load the dll or it registered back
                // within the timeout then we return immediately
                if ( FAILED(hr) || (bStatus == WAIT_OBJECT_0) )
                {
                    ReleaseProcess(_pProcess);
                    _pProcess = NULL;
                    pRegisterEvent->Release();
                    return hr;
                }
            }
            // If a launched server failed to register back in the given
            // timeout or we were not able to talk to the server then we
            // continue and try to launch a new process
            ReleaseProcess(_pProcess);
            _pProcess = NULL;
        }
    }

    if ((pClsidData->ServerType() == SERVERTYPE_SERVICE) ||
        (pClsidData->ServerType() == SERVERTYPE_COMPLUS_SVC))
    {
        // Set the token here as service does not register back
        // with us and so it cannot be set at registration time
        // unlike the activator server case below

        hr = pClsidData->LaunchService( pActParams->pToken, pActParams->ClsContext, &hService );

        if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING))
        {
            hr = S_OK;
            bServiceAlreadyRunning = TRUE;
        }
    }
    else
    {
        //When a "RunAs Interactive User" server is launched from a Hydra session,
        //the server runs in the Hydra session of the caller.  In this case,
        //we want to call LaunchActivator server instead of LaunchRunAsServer
        //so that the server runs in the appropriate Hydra session.

        _lThreadToken = lLaunchThreadToken;

        if ( pClsidData->HasRunAs())
        {
            hr = pClsidData->LaunchRunAsServer(
                                pActParams->pToken,
                                pActParams->RemoteActivation,
                                pActParams->pActPropsIn,
                                pActParams->ClsContext,
                                &_hProcess,
                                &_dwProcessId,
                                &_pvRunAsHandle);
        }
        else
        {
            // Check to see if the client requested "protected" activation. If
            // so, we refuse to launch a server using their token.
            hr = pActParams->pActPropsIn->GetActivationFlags(&dwActvFlags);            
            if (FAILED(hr) || (dwActvFlags & ACTVFLAGS_DISABLE_AAA))            	
            {
                hr = E_ACCESSDENIED;
            }

            // If client came in unsecure, reject the activation
            if (pActParams->UnsecureActivation)
            {
                hr = E_ACCESSDENIED;
            }

            if (SUCCEEDED(hr))
            {
                hr = pClsidData->LaunchActivatorServer(
                                    pActParams->pToken,
                                    pActParams->pEnvBlock,
                                    pActParams->EnvBlockLength,
                                    pActParams->RemoteActivation,
                                    pActParams->bClientImpersonating,
                                    pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL,
                                    pActParams->ClsContext,
                                    &_hProcess,
                                    &_dwProcessId);
            }
        }
    }

    if (FAILED(hr))
    {
        ASSERT(_pvRunAsHandle == NULL);
        _lThreadToken = 0;
        pRegisterEvent->Release();
        return hr;
    }


    // we got this far so it is time to wait for the server/service we just
    // launched to register itself with us appropriately and in a timely fashion

    // Retry once if we fail to get desktop resources the first time
    BOOL fSuccessful = FALSE;
    for (int i=0; i<2; i++) {

        ULONG winerr=0;
        fSuccessful = FALSE;

        switch (pClsidData->ServerType())
        {
        case SERVERTYPE_SERVICE:
        case SERVERTYPE_COMPLUS_SVC:
            ASSERT(hService && "Waiting for service with NULL handle");
            fSuccessful = WaitForService(hService, pRegisterEvent->Handle(),
                                         bServiceAlreadyRunning);
            CloseServiceHandle( hService );
            hService = 0;
            break;

        case SERVERTYPE_COMPLUS:
        case SERVERTYPE_DLLHOST:
            fSuccessful = WaitForDllhostServer(pRegisterEvent->Handle(),
                                               pActParams,
                                               winerr,
                                               lLaunchThreadToken);
            break;

        default:
            fSuccessful = WaitForLocalServer(pRegisterEvent->Handle(),
                                             winerr);
            break;
        }

        if ( (i==0) && _pvRunAsHandle && (!fSuccessful ) &&
             (winerr == ERROR_WAIT_NO_CHILDREN))
        {
            RunAsInvalidateAndRelease(_pvRunAsHandle);
            _pvRunAsHandle = NULL;
            hr = pClsidData->LaunchRunAsServer(
                                pActParams->pToken,
                                pActParams->RemoteActivation,
                                pActParams->pActPropsIn,
                                pActParams->ClsContext,
                                &_hProcess,
                                &_dwProcessId,
                                &_pvRunAsHandle);

            if (FAILED(hr))
            {
                ASSERT(_pvRunAsHandle == NULL);
                pRegisterEvent->Release();
                return hr;
            }

            continue;
        }

        break;
    }

    if ( !fSuccessful )
    {
        GUID ServerGuid = Guid();
        LogRegisterTimeout( &ServerGuid, pActParams->ClsContext, pActParams->pToken );
        hr = CO_E_SERVER_EXEC_FAILURE;
    }
    else
    {
        hr = S_OK;
    }

    // Ensure that we are serializing around
    // registration which takes an exclusive
    // before modifying this and is the only
    // one that needs to look at or modify it.
    if (_hProcess)
    {

        ServerLock()->LockShared();

        if (_hProcess)
        {
            CloseHandle(_hProcess);
            _hProcess = 0;
        }

        ServerLock()->UnlockShared();

    }


    // If we still have the token set the callers also to
    // NULL because we might have succeeded the launch but
    // the server registering back was different from
    // the one launched(this should be very rare).
    if (_lThreadToken)
    {
        _lThreadToken = 0;
        lLaunchThreadToken = 0;
    }

    if (_pvRunAsHandle)
    {
        ASSERT(pClsidData->HasRunAs());
        RunAsRelease(_pvRunAsHandle);
        _pvRunAsHandle = NULL;
    }

    pRegisterEvent->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RegisterHandles
//
// Synopsis         Register either the RunAs or the process handle with the
//                  CProcess object. Also register Single use Thread token.
//
//                  NOTE: this is called by RegisterServer
//--------------------------------------------------------------------------
BOOL CServerTableEntry::RegisterHandles(IN CServerListEntry *  pEntry,
                                        IN CProcess *pServerProcess)
{
    BOOL bStatus = TRUE;

    // Are we interested in registering the process handle
    if(_hProcess || _pProcess)
    {
        ASSERT(pServerProcess);
        // We can have either a process handle if this entry is the one
        // which was the first to launch the server or we can have a process
        // object if the server has already been launched. The two cases are
        // mutually exclusive and we assert that here.
        ASSERT((_hProcess && (NULL == _pProcess)) ||
                    (0 == _hProcess && (NULL != _pProcess)));
        if(_hProcess)
            bStatus = pServerProcess->SetProcessHandle(_hProcess,_dwProcessId);

        // If a FALSE status is returned then the PID of the process launched
        // by us did not match the PID of the process registered.
        // The only cases where this will be FALSE are if a server is
        // started by hand at the same time as a system launch or the
        // process registering was launched by the one we launched.
        // This should almost never happen
        if (!bStatus)
            goto ExitRegisterHandles;

        // If the PID matched then we are sure that this register event
        // matches the server we launched


        // If we had a process match save thread token if
        // it was passed since this thread launched the server
        if (_lThreadToken)
        {
            pEntry->SetThreadToken(_lThreadToken);
            _lThreadToken = NULL;
        }

        // Are we interested in registering the RunAs handle ?
        if (_pvRunAsHandle)
        {
        // Pass our winsta reference over to process entry which will
        // release it when it goes away so we can be rid of
        // responsibilities for it.
            RunAsSetWinstaDesktop(_pvRunAsHandle,
                                  pServerProcess->WinstaDesktop());
            pServerProcess->SetRunAsHandle(_pvRunAsHandle);

            // Given Handle away so remove our reference
            _pvRunAsHandle = NULL;
        }
    }

ExitRegisterHandles:

    return bStatus;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForLocalServer
//
//--------------------------------------------------------------------------
BOOL
CServerTableEntry::WaitForLocalServer(
    IN HANDLE       hRegisterEvent,
    IN ULONG        &winerr
    )
{
    DWORD           Status = WAIT_OBJECT_0+1;
    BOOL            bStatus = FALSE;

    HANDLE  Handles[2];

    Handles[0] = hRegisterEvent;
    Handles[1] = _hProcess;

    // Wait for process and register events
    Status = WaitForMultipleObjects( 2, Handles, FALSE, gServerStartTimeout );

    if ( Status == (WAIT_OBJECT_0 + 1) )
    {
        // Launched Process went away but this could be the case
        // where we have a launched server that starts another server
        // which registers back(Lotus or something ??)
        // So null the handle and wait for the register event for
        // a much shorter time
        GetExitCodeProcess(_hProcess, &winerr);

        HANDLE hProcess;

        CloseHandle( _hProcess );
        _hProcess = 0;

        Status = WaitForSingleObject( hRegisterEvent, gServerStartSecondChanceTimeout );
    }

    if ( Status != WAIT_OBJECT_0 && _hProcess )
        TerminateProcess( _hProcess, 0 );

    if ( Status == WAIT_OBJECT_0 )
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForDllhostServer
//
//--------------------------------------------------------------------------

BOOL
CServerTableEntry::WaitForDllhostServer(
    IN HANDLE               hRegisterEvent,
    IN ACTIVATION_PARAMS    *pActParams,
    IN ULONG        &winerr,
    IN  LONG                lThreadToken
    )
{
    DWORD  Status = WAIT_OBJECT_0+1;
    DWORD WaitedMilliSecondsToStart = 0;

    CServerListEntry *  pEntry = NULL;
    BOOL                bStatus;
    CProcess            *pProcess=NULL;

    HANDLE  Handles[2];

    Handles[0] = hRegisterEvent;
    Handles[1] = _hProcess;

    LONG lSessionID = INVALID_SESSION_ID;
    GetSessionIDFromActParams(pActParams->pActPropsIn, &lSessionID);

    for (;;)
    {
        // Wait for process and register events
        Status = WaitForMultipleObjects( 2, Handles,
                                        FALSE, gDllhostServerStartTimeout );

        if ( ( Status == WAIT_OBJECT_0 ) ||
             ( Status == (WAIT_OBJECT_0 + 1 )))
            break;

        if (pEntry == NULL)
        {
            bStatus = LookupServer(
                        pActParams->pToken,
                        pActParams->RemoteActivation,
                        pActParams->bClientImpersonating,
                        pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,
                        MATCHFLAG_ALLOW_SUSPENDED, // Dllhost is suspended now, we still want to find it!
                        lThreadToken,
                        lSessionID,
                        0,             // no need for a pid here
                        PRT_IGNORE,    // no need for prt here
                        &pEntry);  

            if (!bStatus)
                pEntry = NULL;
            else
            {
                pProcess = pEntry->_pServerProcess;
                ASSERT(pProcess != NULL);
            }
        }

        ScmProcessReg *pScmProcessReg=NULL;
        if (pProcess)
        {
            pScmProcessReg = pProcess->GetProcessReg();
        }

        // If the server died in the middle of an activationand context rundown ocured, then 
	// pScmProcessReg is NULL
	if (! pScmProcessReg )
        {
            // ProcessActivatorStarted not called yet
            WaitedMilliSecondsToStart += gDllhostServerStartTimeout;
            if (WaitedMilliSecondsToStart >= gDllhostMaxServerStartTimeout)
                break;
            else
                continue;
        }

        // ProcessActivatorStarted has been called, how long since last call from
        // initial process activator?

        // handles wraparound
        CTime CurrentTime;
        DWORD WaitedMilliSecondsToReady = CurrentTime - pScmProcessReg->TimeOfLastPing;

        if (WaitedMilliSecondsToReady >= gDllhostMaxServerStartTimeout)
            break;
        else
            continue;
    }

    if (pEntry)
        pEntry->Release();

    if ( Status == WAIT_OBJECT_0 )
        return TRUE;
    else
    {
        GetExitCodeProcess(_hProcess, &winerr);
        TerminateProcess( _hProcess, 0 );
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForService
//
//--------------------------------------------------------------------------

BOOL
CServerTableEntry::WaitForService(
    IN SC_HANDLE    hService,
    IN HANDLE       hRegisterEvent,
    IN BOOL         bServiceAlreadyRunning
    )
{
    SERVICE_STATUS  ServiceStatus;
    DWORD           Status = WAIT_FAILED;
    BOOL            bStatus;
    BOOL            bKeepLooping;
    BOOL            bStopService = FALSE;

    for (DWORD i = 0; i < gNTServiceMaxTimeouts; i++)
    {
        Status = WaitForSingleObject( hRegisterEvent, gNTServiceInterrogatePeriod );
        if (Status == WAIT_OBJECT_0)
        {
			// register event was signalled, just return
            break;
        }
        else
        {
            // Assume we are done
            bKeepLooping = FALSE;

            bStatus = ControlService( hService,
                                      SERVICE_CONTROL_INTERROGATE,
                                      &ServiceStatus );
            if (bStatus)
            {
                switch ( ServiceStatus.dwCurrentState )
                {
                case SERVICE_STOPPED :
                case SERVICE_STOP_PENDING :
                    // weirdness
                    break;

                case SERVICE_RUNNING :
                case SERVICE_START_PENDING :
                case SERVICE_CONTINUE_PENDING :
                    // the service is taking its own sweet time.  Keep
                    // looping to give it more time.
                    bKeepLooping = TRUE;
                    break;

                case SERVICE_PAUSE_PENDING :
                case SERVICE_PAUSED :
                    // more weirdness
                    if (!bServiceAlreadyRunning)
                        bStopService = TRUE;
                    break;
                }
            }
            //else quit

            if (!bKeepLooping)
                break;
        }
    }

    if ( bStopService )
    {
        (void) ControlService( hService,
                               SERVICE_CONTROL_STOP,
                               &ServiceStatus );
    }

    if ( Status == WAIT_OBJECT_0 )
        return TRUE;
    else
        return FALSE;
}



//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForInitCompleted
//
// Wait for an initializing server (dllhost) to finish initialization.
//
//--------------------------------------------------------------------------
HRESULT
CServerTableEntry::WaitForInitCompleted(
    IN CServerListEntry *pEntry,
    IN CClsidData       *pClsidData
)
{ 
    ASSERT(pClsidData); // Should NOT call this without registration info.
    if (NULL == pClsidData)
    {
        // If no clsid data, then we'll just need to return the 
        // "I'm initializing still" error code, since we have no
        // way of waiting.  I don't think this should ever happen,
        // though.
        return CO_E_SERVER_INIT_TIMEOUT;
    }

    CNamedObject* pInitEvent = pClsidData->ServerInitializedEvent();
    if (!pInitEvent)
    {
        return E_OUTOFMEMORY;
    }
    
    HRESULT hr = S_OK;
    if (pEntry->IsInitializing())
    {
        HANDLE hProcess = pEntry->_pServerProcess->GetProcessHandle();

        DWORD dwRet;            
        if (hProcess)
        {
            HANDLE handles[2] = {pInitEvent->Handle(), hProcess};
            dwRet = WaitForMultipleObjects(2, handles, FALSE, gDllhostInitializationTimeout);
        }
        else
        {
            dwRet = WaitForSingleObject(pInitEvent->Handle(), gDllhostInitializationTimeout);
        }
        
        if (dwRet == WAIT_TIMEOUT)
        {
            hr = CO_E_SERVER_INIT_TIMEOUT;
        }
        else if (dwRet == WAIT_OBJECT_0)
        {
            hr = S_OK;
        }
        else if (dwRet == WAIT_OBJECT_0+1)
        {
            hr = CO_E_SERVER_STOPPING;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    pInitEvent->Release();
    
    return hr;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::GetServerListWithLock
//
// Returns a pointer to this entry's server list.   Takes shared lock before
// returning.    Caller is expected to call ReleaseSharedListLock to release
// the lock
//
//--------------------------------------------------------------------------
CServerList* CServerTableEntry::GetServerListWithSharedLock()
{
  ServerLock()->LockShared();
  return &_ServerList;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::ReleaseSharedListLock
//
//   Releases a shared lock on this entry's list lock.
//
//--------------------------------------------------------------------------
void CServerTableEntry::ReleaseSharedListLock()
{
  ServerLock()->UnlockShared();
}


//
//  CServerTableEntry::SuspendClass
//
//  Turns on the suspended flag for this entry.
// 
void CServerTableEntry::SuspendClass()
{
  ASSERT(!_bSuspendedClsid &&   
         !_bSuspendedApplication &&  
         _EntryType == ENTRY_TYPE_CLASS);

  _bSuspendedClsid = TRUE;  

  SetSuspendOnAllServers(TRUE);
}

//
//  CServerTableEntry::UnsuspendClass
//
//  Turns off the suspended flag for this entry.
// 
void CServerTableEntry::UnsuspendClass()
{
  ASSERT(_bSuspendedClsid &&   
         !_bSuspendedApplication &&
         _EntryType == ENTRY_TYPE_CLASS);

  _bSuspendedClsid = FALSE;  

  SetSuspendOnAllServers(FALSE);
}

//
//  CServerTableEntry::RetireClass
//
//  Retires all currently registered servers for 
//  this clsid.
// 
void CServerTableEntry::RetireClass()
{
  ASSERT(_EntryType == ENTRY_TYPE_CLASS);

  RetireAllServers();
}

//
//  CServerTableEntry::SuspendApplication
//
//  Turns on the suspended flag for this entry.
// 
void CServerTableEntry::SuspendApplication()
{
  ASSERT(!_bSuspendedClsid &&   
         !_bSuspendedApplication && 
		 _EntryType == ENTRY_TYPE_PROCESS);

  _bSuspendedClsid = TRUE;  
}

//
//  CServerTableEntry::UnsuspendApplication
//
//  Turns on the suspended flag for this entry.
// 
void CServerTableEntry::UnsuspendApplication()
{
  ASSERT(!_bSuspendedClsid &&   
         _bSuspendedApplication && 
         _EntryType == ENTRY_TYPE_PROCESS);

  _bSuspendedClsid = FALSE;  
}

//
//  CServerTableEntry::RetireApplication
//
//  Marks as retired all servers registered with
//  this entry.
// 
void CServerTableEntry::RetireApplication()
{
  ASSERT(_EntryType == ENTRY_TYPE_PROCESS);
  
  RetireAllServers();
}

//
//  CServerTableEntry::IsSuspended
//
//  Returns TRUE if servers of this type are 
//  currently suspended, FALSE otherwise.
// 
BOOL CServerTableEntry::IsSuspended()
{
  ASSERT(_EntryType == ENTRY_TYPE_CLASS ||
         _EntryType == ENTRY_TYPE_PROCESS);

  if (_EntryType == ENTRY_TYPE_CLASS)
    return _bSuspendedClsid;
  else
    return _bSuspendedApplication;
}


//
//  CServerTableEntry::SetSuspendOnAllServers
//
//  Sets the suspended bit on all currently registered servers.
// 
void CServerTableEntry::SetSuspendOnAllServers(BOOL bSuspended)
{
  CServerListEntry * pEntry;

  ServerLock()->LockShared();
  
  for (pEntry = (CServerListEntry *) _ServerList.First(); 
       pEntry; 
       pEntry = (CServerListEntry *) pEntry->Next() )
  {
    if (bSuspended)
      pEntry->Suspend();
    else
      pEntry->Unsuspend();
  }

  ServerLock()->UnlockShared();
}

//
//  CServerTableEntry::RetireAllServers
//
//  Marks as retired all currently registered servers.
// 
void CServerTableEntry::RetireAllServers()
{
  CServerListEntry * pEntry;

  ServerLock()->LockShared();
  
  for (pEntry = (CServerListEntry *) _ServerList.First(); 
       pEntry; 
       pEntry = (CServerListEntry *) pEntry->Next() )
  {
    pEntry->Retire();
  }

  ServerLock()->UnlockShared();
}

//
//  CServerTableEntry::SetSuspendedFlagOnNewServer
//
//  Helper function for when a new class factory registration/app 
//  comes along.   If we are currently suspended, then we need to 
//  pass that state on to the new server.   If we're not suspended,
//  then there's nothing to do.
// 
void CServerTableEntry::SetSuspendedFlagOnNewServer(CProcess* pprocess)
{
  if ( (_EntryType == ENTRY_TYPE_CLASS) && _bSuspendedClsid)
  {
    pprocess->Suspend();
  }
  else if ( (_EntryType == ENTRY_TYPE_PROCESS) && _bSuspendedApplication)
  {
    pprocess->Suspend();
  }
}

//+-------------------------------------------------------------------------
//
// SCMRemoveRegistration Version 1: for class entries representing traditional
//      local servers including custom surrogate servers.
//
//  Called from CProcess::RevokeClassRegs() in the resolver.
//
//--------------------------------------------------------------------------


void
SCMRemoveRegistration(
    CProcess *  pProcess,
    GUID &      Guid,
    DWORD       Reg
    )
{
    CServerTableEntry * pClassTableEntry = NULL;

    pClassTableEntry = gpClassTable->Lookup( Guid );

    if ( pClassTableEntry )
    {
        pClassTableEntry->RevokeServer( pProcess, Reg );
        pClassTableEntry->Release();
    }
}





//+-------------------------------------------------------------------------
//
// SCMRemoveRegistration Version 2: for process entries representing
//      new unified surrogate servers.
//
//  Called from CProcess::RevokeClassRegs() in the resolver.
//
//--------------------------------------------------------------------------

void
SCMRemoveRegistration(
    ScmProcessReg  * pScmProcessReg
    )
{
    CServerTableEntry * pProcessTableEntry = NULL;

    pProcessTableEntry = gpProcessTable->Lookup( pScmProcessReg->ProcessGUID );

    if ( pProcessTableEntry )
    {
        pProcessTableEntry->RevokeServer( pScmProcessReg );
        pProcessTableEntry->Release();
    }
}


void
SCMProcessCleanup(
    const CProcess *pProcess
    )
{
    CSurrogateListEntry *pSurrogateEntry = gpSurrogateList->Lookup(pProcess);
    if (pSurrogateEntry)
    {
        gpSurrogateList->Remove(pSurrogateEntry);
        pSurrogateEntry->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\actmisc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       actmisc.cxx
//
//  Contents:   Miscellaneous functions.
//
//  Functions:
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"

HRESULT GetMachineName(
    WCHAR * pwszPath,
    WCHAR   wszMachineName[MAX_COMPUTERNAME_LENGTH+1]
#ifdef DFSACTIVATION
    ,BOOL   bDoDfsConversion
#endif
    )
{
    WCHAR * pwszServerName;
    BYTE    Buffer[sizeof(REMOTE_NAME_INFO)+MAX_PATH*sizeof(WCHAR)];
    DWORD   BufferSize = sizeof(Buffer);
    WCHAR   Drive[4];
    DWORD   Status;

    //
    // Extract the server name from the file's path name.
    //
    if ( pwszPath[0] != L'\\' || pwszPath[1] != L'\\' )
    {
        lstrcpynW(Drive, pwszPath, 3);
        Drive[2] = L'\\';
        Drive[3] = NULL;

        // We must impersonate around the call to GetDriveType as well, 
        // so that we have the same access to the mapped drive as the 
        // calling client.

        if ( RpcImpersonateClient((RPC_BINDING_HANDLE)0) != ERROR_SUCCESS )
            return CO_E_SCM_RPC_FAILURE;

        if (GetDriveType(Drive) != DRIVE_REMOTE )
        {
            RpcRevertToSelf();
            return S_FALSE;
        }

        Status =  WNetGetUniversalName( pwszPath,
                                        UNIVERSAL_NAME_INFO_LEVEL,
                                        Buffer,
                                        &BufferSize );

        RpcRevertToSelf();

        if ( Status != NO_ERROR )
        {
            return CO_E_BAD_PATH;
        }

        pwszPath = ((UNIVERSAL_NAME_INFO *)Buffer)->lpUniversalName;

        if ( ! pwszPath || pwszPath[0] != L'\\' || pwszPath[1] != L'\\' )
        {
            // Must be a local path.
            return S_FALSE;
        }
    }

#ifdef DFSACTIVATION
    WCHAR   wszDfsPath[MAX_PATH];
    WCHAR * pwszDfsPath = wszDfsPath;

    if ( bDoDfsConversion && ghDfs )
    {
        DWORD   DfsPathLen;

        DfsPathLen = sizeof(wszDfsPath);

        for (;;)
        {
            Status = DfsFsctl(
                        ghDfs,
                        FSCTL_DFS_GET_SERVER_NAME,
                        (PVOID) &pwszPath[1],
                        lstrlenW(&pwszPath[1]) * sizeof(WCHAR),
                        (PVOID) pwszDfsPath,
                        &DfsPathLen );

            if ( Status == STATUS_BUFFER_OVERFLOW )
            {
                ASSERT( pwszDfsPath == wszDfsPath );

                pwszDfsPath = (WCHAR *) PrivMemAlloc( DfsPathLen );
                if ( ! pwszDfsPath )
                    return E_OUTOFMEMORY;
                continue;
            }

            break;
        }

        if ( Status == STATUS_SUCCESS )
            pwszPath = pwszDfsPath;
    }
#endif

    // Skip the "\\".
    LPWSTR pwszTemp = pwszPath + 2;

    pwszServerName = wszMachineName;

    while ( *pwszTemp != L'\\' )
        *pwszServerName++ = *pwszTemp++;
    *pwszServerName = 0;

#ifdef DFSACTIVATION
    if ( pwszDfsPath != wszDfsPath )
        PrivMemFree( pwszDfsPath );
#endif

    return S_OK;
}

HRESULT GetPathForServer(
    WCHAR * pwszPath,
    WCHAR wszPathForServer[MAX_PATH+1],
    WCHAR ** ppwszPathForServer )
{
    BYTE    Buffer[sizeof(REMOTE_NAME_INFO)+MAX_PATH*sizeof(WCHAR)];
    WCHAR   Drive[4];
    DWORD   BufferSize = sizeof(Buffer);
    DWORD   PathLength;
    DWORD   Status;
    UINT    uiDriveType;

    *ppwszPathForServer = 0;

    if ( pwszPath &&
         (lstrlenW(pwszPath) >= 3) &&
         (pwszPath[1] == L':') && (pwszPath[2] == L'\\') )
    {
        lstrcpynW(Drive, pwszPath, 3);
        Drive[2] = L'\\';
        Drive[3] = NULL;

        // We must impersonate around the call to GetDriveType as well, 
        // so that we have the same access to the mapped drive as the 
        // calling client.
        if ( RpcImpersonateClient((RPC_BINDING_HANDLE)0) != ERROR_SUCCESS )
            return CO_E_SCM_RPC_FAILURE;

        uiDriveType = GetDriveType( Drive );

        RpcRevertToSelf();

        switch ( uiDriveType )
        {
        case 0 : // Drive type can not be determined
        case 1 : // The root directory does not exist
        case DRIVE_CDROM :
        case DRIVE_RAMDISK :
        case DRIVE_REMOVABLE :
            //
            // We can't convert these to file names that the server will be
            // able to access.
            //
            return CO_E_BAD_PATH;

        case DRIVE_FIXED :
            if ( !gpMachineName || !gpMachineName->NetBiosName())
            {
                return E_OUTOFMEMORY;
            }
            wszPathForServer[0] = wszPathForServer[1] = L'\\';
            lstrcpyW( &wszPathForServer[2], gpMachineName->NetBiosName() );
            PathLength = lstrlenW( wszPathForServer );
            wszPathForServer[PathLength] = L'\\';
            wszPathForServer[PathLength+1] = pwszPath[0];
            wszPathForServer[PathLength+2] = L'$';
            wszPathForServer[PathLength+3] = L'\\';
            lstrcpyW( &wszPathForServer[PathLength+4], &pwszPath[3] );
            *ppwszPathForServer = wszPathForServer;
            break;

        case DRIVE_REMOTE :
            if ( RpcImpersonateClient((RPC_BINDING_HANDLE)0) != ERROR_SUCCESS )
                return CO_E_SCM_RPC_FAILURE;

            Status =  WNetGetUniversalName( pwszPath,
                                            UNIVERSAL_NAME_INFO_LEVEL,
                                            Buffer,
                                            &BufferSize );

            RpcRevertToSelf();

            if ( Status != NO_ERROR )
            {
                return CO_E_BAD_PATH;
            }

            ASSERT( ((UNIVERSAL_NAME_INFO *)Buffer)->lpUniversalName );

            lstrcpyW( wszPathForServer, ((UNIVERSAL_NAME_INFO *)Buffer)->lpUniversalName );

            *ppwszPathForServer = wszPathForServer;

            ASSERT( wszPathForServer[0] == L'\\' &&
                        wszPathForServer[1] == L'\\' );
            break;
        }
    }
    else
    {
        *ppwszPathForServer = pwszPath;
    }

    return S_OK;
}


//
// Finds an exe name by looking for the first .exe sub string which
// is followed by any of the given delimiter chars or a null.
//
BOOL
FindExeComponent(
    IN  WCHAR *     pwszString,
    IN  WCHAR *     pwszDelimiters,
    OUT WCHAR **    ppwszStart,
    OUT WCHAR **    ppwszEnd
    )
{
    WCHAR * pwszLast;
    WCHAR * pwszSearch;
    WCHAR   wszStr[4];
    DWORD   Delimiters;

    Delimiters = lstrlenW( pwszDelimiters ) + 1;

    pwszSearch = pwszString;
    pwszLast = pwszSearch + lstrlenW( pwszSearch );

    for ( ; pwszSearch <= (pwszLast - 4); pwszSearch++ )
    {
        if ( pwszSearch[0] != L'.' )
            continue;

        for ( DWORD n = 0; n < Delimiters; n++ )
        {
            if ( pwszDelimiters[n] == pwszSearch[4] )
            {
                // Note that there is no lstrnicmpW, so we use memcpy/lstrcmpiW.

                memcpy( wszStr, &pwszSearch[1], 3 * sizeof(WCHAR) );
                wszStr[3] = 0;

                if ( lstrcmpiW( wszStr, L"exe" ) == 0 )
                    goto FoundExe;
            }
        }
    }

FoundExe:

    if ( pwszSearch > (pwszLast - 4) )
        return FALSE;

    *ppwszEnd = &pwszSearch[4];

    for ( ; pwszSearch != pwszString && pwszSearch[-1] != L'\\'; pwszSearch-- )
        ;

    *ppwszStart = pwszSearch;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword
//
//  Synopsis:   Convert a character string hex digits to a DWORD
//
//  Arguments:  [lpsz] - string to convert
//              [Value] - where to put the value
//              [cDigits] - number of digits expected
//              [chDelim] - delimiter for end of string
//
//  Returns:    TRUE - string converted to a DWORD
//              FALSE - string could not be converted
//
//  Algorithm:  For each digit in the string, shift the value and
//              add the value of the digit to the output value. When
//              all the digits are processed, if a delimiter is
//              provided, make sure the last character is the delimiter.
//
//  History:    22-Apr-93 Ricksa    Created
//
//  Notes:      Lifted from CairOLE sources so that SCM will have no
//              dependency on compobj.dll.
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(
    LPCWSTR FAR& lpsz,
    DWORD FAR& Value,
    int cDigits,
    WCHAR chDelim)
{
    int Count;

    Value = 0;

    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
        {
            Value = (Value << 4) + *lpsz - '0';
        }
        else if (*lpsz >= 'A' && *lpsz <= 'F')
        {
            Value = (Value << 4) + *lpsz - 'A' + 10;
        }
        else if (*lpsz >= 'a' && *lpsz <= 'f')
        {
            Value = (Value << 4) + *lpsz - 'a' + 10;
        }
        else
        {
            return FALSE;
        }
    }

    if (chDelim != 0)
    {
        return *lpsz++ == chDelim;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   GUIDFromString
//
//  Synopsis:   Convert a string in Registry to a GUID.
//
//  Arguments:  [lpsz] - string from registry
//              [pguid] - where to put the guid.
//
//  Returns:    TRUE - GUID conversion successful
//              FALSE - GUID conversion failed.
//
//  Algorithm:  Convert each part of the GUID string to the
//              appropriate structure member in the guid using
//              HexStringToDword. If all conversions work return
//              TRUE.
//
//  History:    22-Apr-93 Ricksa    Created
//
//  Notes:      Lifted from CairOLE sources so that SCM will have no
//              dependency on compobj.dll.
//
//--------------------------------------------------------------------------
BOOL GUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz++ != '{')
    {
        return FALSE;
    }

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))
    {
        return FALSE;
    }

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
    {
        return FALSE;
    }

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
    {
        return FALSE;
    }

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
    {
        return FALSE;
    }

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[6] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, /*(*/ '}'))
    {
        return FALSE;
    }

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\dbgprt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dbgprt.hxx
//
//  Contents:   Routines to make printing trace info for debugging easier
//
//  History:    31-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

// This file only produces code for the debug version of the SCM

#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   FormatGuid
//
//  Synopsis:   Format a binary guid for display on debugger
//
//  Arguments:  [rguid] - guid to display
//              [pwszGuid] - where to put displayable form
//
//  Returns:    pointer to guid string
//
//  History:    01-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
WCHAR *FormatGuid(const GUID& rguid, WCHAR *pwszGuid)
{

    wsprintf(pwszGuid, L"%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
        rguid.Data1, rguid.Data2, rguid.Data3, (int) rguid.Data4[0],
        (int) rguid.Data4[1], (int) rguid.Data4[2], (int) rguid.Data4[3],
        (int) rguid.Data4[4], (int) rguid.Data4[5],
        (int) rguid.Data4[6], (int) rguid.Data4[7]);

    return pwszGuid;
}



void DbgPrintFileTime(char *pszDesc, FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_SCM, "%s Low: %04X High: %04X\n",
        pszDesc, pfiletime->dwLowDateTime, pfiletime->dwHighDateTime));
}

void DbgPrintGuid(char *pszDesc, const GUID *pguid)
{
    WCHAR aszGuidStr[48];

    CairoleDebugOut((DEB_SCM, "%s %ws\n", pszDesc,
        FormatGuid(*pguid, &aszGuidStr[0])));
}

void DbgPrintIFD(char *pszDesc, InterfaceData *pifd)
{

    if (pifd != NULL)
    {
        BYTE *pb = &pifd->abData[0];

        CairoleDebugOut((DEB_SCM,
            "%s Addr %04X Len: %04X Data: %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n",
                pszDesc, pifd, pifd->ulCntData, pb[0], pb[1], pb[2], pb[3],
                    pb[4], pb[5], pb[6], pb[7], pb[8], pb[9], pb[10], pb[11]));
    }
    else
    {
        CairoleDebugOut((DEB_SCM, "%s Addr %04X", pszDesc, pifd));
    }
}

void DbgPrintMkIfList(char *pszDesc, MkInterfaceList **ppMkIFList)
{
    CairoleDebugOut((DEB_SCM, "%s Addr: %l04X Count: %04X\n",
        pszDesc, *ppMkIFList, (*ppMkIFList)->dwSize));
}

void DbgPrintMnkEqBuf(char *pszDesc, MNKEQBUF *pmkeqbuf)
{
    GUID *pguid = (GUID *) &pmkeqbuf->abEqData[0];
    WCHAR aszGuidStr[48];

    CairoleDebugOut((DEB_SCM, "%s Addr %04X Len: %04X Clsid: %ws\n",
        pszDesc, pmkeqbuf, pmkeqbuf->cdwSize,
            FormatGuid(*pguid, &aszGuidStr[0])));
}

void DbgPrintRegIn(char *pszDesc, RegInput *pregin)
{
    CairoleDebugOut((DEB_SCM, "%s Count: %04X\n", pszDesc, pregin->dwSize));

    // Loop printing the registrations
    for (DWORD i = 0; i < pregin->dwSize; i++)
    {
        DbgPrintGuid("CLSID: ", &pregin->rginent[i].clsid);
#ifdef DCOM
        ULARGE_INTEGER *puint = (ULARGE_INTEGER *)&pregin->rginent[i].oxid;
        CairoleDebugOut((DEB_SCM, "OXID: %08x %08x\n",
            puint->HighPart, puint->LowPart));
        DbgPrintGuid("IPID: ", &pregin->rginent[i].ipid);
#else
        CairoleDebugOut((DEB_SCM, "EndPoint: %ws\n",
            pregin->rginent[i].pwszEndPoint));
#endif
        CairoleDebugOut((DEB_SCM, "Flags: %04X\n",
            pregin->rginent[i].dwFlags));
    }
}

void DbgPrintRevokeClasses(char *pszDesc, RevokeClasses *prevcls)
{
    CairoleDebugOut((DEB_SCM, "%s Count: %04X\n", pszDesc, prevcls->dwSize));

    // Loop printing the registrations
    for (DWORD i = 0; i < prevcls->dwSize; i++)
    {
        DbgPrintGuid("CLSID: ", &prevcls->revent[i].clsid);
        CairoleDebugOut((DEB_SCM, "Reg: %04X\n",
            prevcls->revent[i].dwReg));
    }
}

void DbgPrintScmRegKey(char *pszDesc, SCMREGKEY *psrkRegister)
{
    CairoleDebugOut((DEB_SCM, "%s EntryLoc: %04X ScmId: %04X\n", pszDesc,
        psrkRegister->dwEntryLoc, psrkRegister->dwScmId));
}


#endif // DBG == 1

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\dscmif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      dscmif.cxx
//
//  Contents:
//      Entry points for remote activation SCM interface.
//
//  Functions:
//      SCMActivatorGetClassObject
//      SCMActivatorCreateInstance
//
//  History:  SatishT   2/10/98    Rewrote for use with ISCMActivator
//  History:  Vinaykr   3/1/98     Modified To Add Activation Properties,
//                                 SCM Stage handling and Remote handling
//
//--------------------------------------------------------------------------

#include "act.hxx"

/*********************************************************************/
/** Entry point for local GetClassObject activation requests        **/
/*********************************************************************/
HRESULT SCMActivatorGetClassObject(
    IN  handle_t              hRpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * LOCALthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    ACTIVATION_PARAMS       ActParams;

    if (ORPCthis == NULL || LOCALthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;

    memset(&ActParams, 0, sizeof(ActParams));
    ActParams.MsgType = GETCLASSOBJECT;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = LOCALthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;


    return PerformScmStage(CLIENT_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}

/*********************************************************************/
/** Entry point for local CreateInstance activation requests        **/
/*********************************************************************/
HRESULT SCMActivatorCreateInstance(
    IN  handle_t              hRpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * LOCALthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  MInterfacePointer   * pUnkOuter,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    ACTIVATION_PARAMS       ActParams;

    if (ORPCthis == NULL || LOCALthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;

    memset(&ActParams, 0, sizeof(ActParams));
    ActParams.MsgType = CREATEINSTANCE;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = LOCALthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;

    return PerformScmStage(CLIENT_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}


/*********************************************************************/
/** Dummy IUnknown functions                                        **/
/*********************************************************************/
HRESULT DummyQueryInterfaceISCMActivator(
    IN  handle_t              rpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * localthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  DWORD                 dummy
    )
{
    CairoleDebugOut((DEB_ERROR, "SystemActivator Dummy function should never be called!\n"));
    ORPCthat->flags = 0;
    ORPCthat->extensions = NULL;
    return E_FAIL;
}


/*********************************************************************/
/** Dummy IUnknown functions                                        **/
/*********************************************************************/
HRESULT DummyAddRefISCMActivator(
    IN  handle_t              rpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * LOCALthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  DWORD                 dummy
    )
{
    CairoleDebugOut((DEB_ERROR, "SystemActivator Dummy function should never be called!\n"));
    ORPCthat->flags = 0;
    ORPCthat->extensions = NULL;
    return E_FAIL;
}


/*********************************************************************/
/** Dummy IUnknown functions                                        **/
/*********************************************************************/
HRESULT DummyReleaseISCMActivator(
    IN  handle_t              rpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * localthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  DWORD                 dummy
    )
{
    CairoleDebugOut((DEB_ERROR, "SystemActivator Dummy function should never be called!\n"));
    ORPCthat->flags = 0;
    ORPCthat->extensions = NULL;
    return E_FAIL;
}


/*
  ActivateFromPropertiesPreamble

  Does various stuff, loads custom activators, delegates.

*/
HRESULT ActivateFromPropertiesPreamble(
ActivationPropertiesIn *pActPropsIn,
IActivationPropertiesOut **ppActOut,
PACTIVATION_PARAMS pActParams
)
{
    HRESULT                   rethr;
    ILegacyInfo*              pLegacyInfo = NULL;
    InstantiationInfo*        pInstantiationInfo = NULL;
    IServerLocationInfo*      pISLInfo = NULL;
    ISpecialSystemProperties* pISSP = NULL;
    IActivationSecurityInfo*  pIActSecInfo = NULL;
    BOOL                      IsGetPersist = FALSE;
    DWORD                     destCtx;
    IInstanceInfo*            pInstanceInfo = NULL;
    int                       nRetries = 0;
    IComClassInfo*              pComClassInfo = NULL;
     
    *ppActOut = NULL;

    // Fill up ActParams for Generic Activation Path
    pActParams->pAuthInfo = NULL;
    pActParams->pProcess = 0;
    pActParams->pToken = 0;

    rethr = pActPropsIn->QueryInterface(IID_IScmRequestInfo, (LPVOID*)&pActParams->pInScmResolverInfo);
    if (FAILED(rethr)) goto exit_Activation;

    rethr = pActPropsIn->QueryInterface(IID_ILegacyInfo, (LPVOID*)&pLegacyInfo);
    if (FAILED(rethr)) goto exit_Activation;

    rethr = pActPropsIn->QueryInterface(IID_IActivationSecurityInfo, (LPVOID*)&pIActSecInfo);
    if (FAILED(rethr)) goto exit_Activation;

    pInstantiationInfo = pActPropsIn->GetInstantiationInfo();
    if (pInstantiationInfo == NULL)
    {
        rethr = E_OUTOFMEMORY;
        goto exit_Activation;
    }
    
    pActParams->pInstantiationInfo = pInstantiationInfo;

    if (pActParams->RemoteActivation)
    {
        pActParams->pProcess = NULL; // no CProcess for remote clients
        pActParams->pEnvBlock = NULL;
        pActParams->pwszWinstaDesktop = NULL;
        pActParams->Apartment = FALSE;
        pActParams->pAuthInfo = 0;
        pActParams->pwszServer = NULL;
    }
    else
    {
        PRIV_SCM_INFO *pPrivScmInfo;

        rethr = pActParams->pInScmResolverInfo->GetScmInfo(&pPrivScmInfo);
        if (FAILED(rethr)) goto exit_Activation;

        // Check local security
        pActParams->pProcess = CheckLocalSecurity(pActParams->hRpc, 
                                     (PHPROCESS)pPrivScmInfo->ProcessSignature, 
                                     TRUE);  // *not* passed as a context handle
        if (!pActParams->pProcess)
        {
            rethr = E_ACCESSDENIED;
            goto exit_Activation;
        }
        
        pActParams->pEnvBlock = pPrivScmInfo->pEnvBlock;
        pActParams->EnvBlockLength = pPrivScmInfo->EnvBlockLength;
        pActParams->pwszWinstaDesktop = pPrivScmInfo->pwszWinstaDesktop;
        pActParams->Apartment = pPrivScmInfo->Apartment;
        
        COSERVERINFO *pServerInfo;
        // Retrieve the COSERVERINFO (originally from the client) and 
        // save a copy.  Then we free the COAUTHINFO part of the actprops
        // so that we don't accidently send it anywhere else.
        rethr = pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
        ASSERT(SUCCEEDED(rethr));
        if (FAILED(rethr)) goto exit_Activation;
        if (pServerInfo)
        {
            rethr = CopyAuthInfo(pServerInfo->pAuthInfo, &pActParams->pAuthInfo);
            SecurityInfo::freeCOAUTHINFO(pServerInfo->pAuthInfo);
            pServerInfo->pAuthInfo = NULL;
            if (FAILED(rethr))
                goto exit_Activation;
        }
    }

    // Make sure caller has not set a COAUTHIDENTITY
    COAUTHIDENTITY* pAuthIdentBogus;
    rethr = pIActSecInfo->GetAuthIdentity(&pAuthIdentBogus);
    if (FAILED(rethr)) goto exit_Activation;
    if (pAuthIdentBogus != NULL)
    {
        // since we have never set this field on any MSFT platform (and
        // never will), this means we have a caller who is playing games
        rethr = E_ACCESSDENIED;
        ASSERT(!"pAuthIdentBogus was non-NULL");
        goto exit_Activation;
    }

    // Make sure process request info is set to defaults before calling any custom activators
    if (pActPropsIn->QueryInterface(IID_IServerLocationInfo, (void**)&pISLInfo) == S_OK)
    {
        HRESULT hr;
        hr = pISLInfo->SetProcess(0, PRT_IGNORE);
        ASSERT(hr == S_OK);
        pISLInfo->Release();
    }

    // Remember if client was impersonating or not
    if (pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP) == S_OK)
    {
      HRESULT hr;
      hr = pISSP->GetClientImpersonating(&pActParams->bClientImpersonating);
      ASSERT(hr == S_OK);
      pISSP->Release();
    }

    // QI will only work if persistent activation is happening
    if (pActPropsIn->QueryInterface(IID_IInstanceInfo,
                                    (LPVOID*)&pInstanceInfo) == S_OK)

    {
        pActParams->pInstanceInfo = pInstanceInfo;

        // The only case where msgtype will already be GETPERSISTENTINSTANCE
        // is during an incoming nt4 client remote activation(see remactif)
        if (pActParams->MsgType == CREATEINSTANCE)
        {
            pActParams->MsgType = GETPERSISTENTINSTANCE;
            WCHAR *pwszObjectName;
            pInstanceInfo->GetFile(&pwszObjectName, &pActParams->Mode);
            if (pActParams->RemoteActivation)
            {
                WCHAR *pwszObjectName2;
                rethr = GetServerPath( pwszObjectName, &pwszObjectName2 );
                if (pwszObjectName != pwszObjectName2)
                {
                    pInstanceInfo->SetFile(pwszObjectName2, pActParams->Mode);
                    pInstanceInfo->GetFile(&pActParams->pwszPath, &pActParams->Mode);
                    MIDL_user_free(pwszObjectName2);
                }
            }
            else
            {
                pActParams->pwszPath = pwszObjectName;
            }

            if ( FAILED(rethr) )
              goto exit_Activation;

            pInstanceInfo->GetStorageIFD(&pActParams->pIFDStorage);
            IsGetPersist = TRUE;
        }

        ASSERT(pActParams->MsgType == GETPERSISTENTINSTANCE);
    }
    else
    {
        ASSERT(pActParams->MsgType != GETPERSISTENTINSTANCE);
        if (pActParams->MsgType == GETCLASSOBJECT)
            pActParams->Mode = MODE_GET_CLASS_OBJECT;

#ifdef DFSACTIVATION
        pActParams->FileWasOpened = FALSE;
#endif
    }

    rethr = pInstantiationInfo->GetClsid(&pActParams->Clsid);
    ASSERT(SUCCEEDED(rethr));
	
    if (pActParams->RemoteActivation)
        pActParams->ClsContext = CLSCTX_LOCAL_SERVER;
    else
    {
        rethr = pInstantiationInfo->GetClsctx(&pActParams->ClsContext);
        ASSERT(SUCCEEDED(rethr));
    }

    rethr = pInstantiationInfo->GetRequestedIIDs(
                            &pActParams->Interfaces,
                            &pActParams->pIIDs);
    ASSERT(SUCCEEDED(rethr));
    /* only one requested interface allowed for GetClassObject */
    if ((pActParams->MsgType == GETCLASSOBJECT) && (pActParams->Interfaces != 1))
    {
        rethr = E_INVALIDARG;
        goto exit_Activation;
    }

    pActParams->ORPCthis->flags = ORPCF_LOCAL;
    pActParams->Localthis->dwFlags = LOCALF_NONE;
    pActParams->ORPCthat->flags = 0;
    pActParams->ORPCthat->extensions = NULL;

    //
    // Get a CToken for all callers.  Only allow unsecure for
    // remote clients.
    //
    RPC_STATUS status;
    status = LookupOrCreateTokenForRPCClient(pActParams->hRpc, 
                                 pActParams->RemoteActivation,
                                 &pActParams->pToken,
                                 &pActParams->UnsecureActivation);
    if (status != RPC_S_OK)
    {
        rethr = HRESULT_FROM_WIN32(status);
        goto exit_Activation;
    }

    // UNDONE: figure out if this is still necessary for correct
    // rot lookups.
    if (pActParams->UnsecureActivation)
    {
        pActParams->pwszWinstaDesktop = L"";        
    }
	
    ASSERT(pActParams->pToken);

    // Look up the (per-user) classinfo here before 
    // the partition activators run.  
    if (!pActParams->UnsecureActivation)
    {
        pActPropsIn->SetClientToken(pActParams->pToken->GetToken());
        if (!(pActParams->ClsContext & CLSCTX_INPROC_SERVER)) 
        {
            rethr = gpCatalogSCM->GetClassInfo ( pActParams->ClsContext,
                                        pActParams->pToken,
                                        pActParams->Clsid,
                                        IID_IComClassInfo,
                                        (void**) &pComClassInfo );            
        }
    }
    else
        rethr = gpCatalog->GetClassInfo ( pActParams->Clsid,
                                          IID_IComClassInfo,
                                          (void**) &pComClassInfo );

    // catalog will return S_FALSE if the class is not
    // registered. 
    if ( pComClassInfo == NULL || rethr != S_OK )
        rethr = REGDB_E_CLASSNOTREG;

    // Careful here:   the lookup above may have failed registration info
    // for a local server activation, but we need to keep going since the 
    // activation may still end up being sent to a remote machine.
    if (FAILED(rethr) && rethr != REGDB_E_CLASSNOTREG) 
        goto exit_Activation;

    if (pComClassInfo) 
    {
    	HRESULT temphr = pActPropsIn->SetClassInfo(pComClassInfo);
    	
        pComClassInfo->Release();
        pComClassInfo=NULL;
        
        if (FAILED(temphr))
        {
            rethr = temphr;
            goto exit_Activation;
    	}
    }
    
    // Set Activation Params "Local Blob"
    pActPropsIn->SetLocalBlob((void*)pActParams);
    pActParams->pActPropsIn = pActPropsIn;

RETRY_ACTIVATION:    
    //
    // Set the stage.  For now, all scm-level activators must be 
    //   SERVER_MACHINE_STAGE activators, since more work needs to be
    //   done to properly define the semantic/other differences 
    //   between "client" and "server" scm activators.
    //   
    rethr = pActPropsIn->SetStageAndIndex(SERVER_MACHINE_STAGE, 0);
    if (FAILED (rethr)) goto exit_Activation;

    //  Delegate onwards....
    if (pActParams->MsgType == GETCLASSOBJECT)
        rethr = pActPropsIn->DelegateGetClassObject(ppActOut);
    else
        rethr = pActPropsIn->DelegateCreateInstance(NULL, ppActOut);
    
    // Sajia - support for partitions
    // If the delegated activation returns ERROR_RETRY,
    // we walk the chain again, but AT MOST ONCE.

    if (HRESULT_FROM_WIN32(ERROR_RETRY) == rethr) {
       ASSERT(!nRetries);
       if (!nRetries)
       {
	        nRetries++;
	        goto RETRY_ACTIVATION;
       }
    }
    
exit_Activation:

    if (IsGetPersist)
    {
        if ( pActParams->pIFDROT )
            MIDL_user_free( pActParams->pIFDROT );
    }

    if (pActParams->pInScmResolverInfo)
        pActParams->pInScmResolverInfo->Release();
    if (pLegacyInfo)
        pLegacyInfo->Release();
    if (pIActSecInfo)
    	pIActSecInfo->Release();
    if (pActParams->pInstanceInfo)
        pActParams->pInstanceInfo->Release();
    if (pActParams->pAuthInfo)
        SecurityInfo::freeCOAUTHINFO(pActParams->pAuthInfo);
    if (pActParams->pToken)
    	pActParams->pToken->Release();
    if (pActParams->pProcess)
        ReleaseProcess(pActParams->pProcess);
    if (pComClassInfo) 
    {
       pComClassInfo->Release();
    }
    return rethr;
}



#if DBG == 1
LONG ActivationExceptionFilter( DWORD lCode,
                               LPEXCEPTION_POINTERS lpep )
{
    ASSERT(NULL && "Unexpected exception thrown");
    return TRUE;
}
#endif

/*********************************************************************/
/** Real Work of SCM Activation begins here After Custom Activators **/
/** have been called. This will be called during all activations    **/
/** occuring in the SCM, local and remote                           **/
/*********************************************************************/
HRESULT ActivateFromProperties(
IActivationPropertiesIn *pActIn,
IActivationPropertiesOut **ppActOut
)
{
    HRESULT rethr;
    REMOTE_REQUEST_SCM_INFO * pScmRequestInfo=NULL;
    IScmReplyInfo           * pOutScmResolverInfo = NULL;
    DWORD destCtx;
    REMOTE_REPLY_SCM_INFO *pScmReplyInfo=NULL;
    PRIV_RESOLVER_INFO *pPrivActOutInfo=NULL;
    ActivationPropertiesIn *pActPropsIn=NULL;
    WCHAR *             pwszDummy;

    *ppActOut = NULL;

    // Get Activation Params "Local Blob"
    rethr = pActIn->QueryInterface(CLSID_ActivationPropertiesIn, (void**)&pActPropsIn);
    PACTIVATION_PARAMS pActParams;
    pActPropsIn->GetLocalBlob((void**)&pActParams);
    ASSERT(pActParams != NULL);

    // This could have already been set in the lb rerouting case
    pActParams->activatedRemote = FALSE;


    if (pActParams->RemoteActivation)
    {
        ASSERT(pActParams->pInScmResolverInfo);
        rethr = pActParams->pInScmResolverInfo->GetRemoteRequestInfo(&pScmRequestInfo);
        if (pScmRequestInfo == NULL)
        {
            if (SUCCEEDED(rethr))
                rethr = E_FAIL;
            goto exit_Activation;
        }

        pScmReplyInfo = (REMOTE_REPLY_SCM_INFO*)
                          MIDL_user_allocate(sizeof(REMOTE_REPLY_SCM_INFO));

        if (pScmReplyInfo == NULL)
        {
            rethr = E_OUTOFMEMORY;
            goto exit_Activation;
        }

        memset(pScmReplyInfo, 0, sizeof(REMOTE_REPLY_SCM_INFO));

        pActParams->pOxidServer = &pScmReplyInfo->Oxid;

        //
        // The following OR fields are not used while servicing a
        // remote activation.
        //
        pActParams->ppServerORBindings = (DUALSTRINGARRAY **)NULL;
        pActParams->pOxidInfo = NULL;
        pActParams->pLocalMidOfRemote = NULL;
        pActParams->pDllServerModel = NULL;
        pActParams->ppwszDllServer = &pwszDummy;
    }
    else
    {
        pPrivActOutInfo = (PRIV_RESOLVER_INFO*)
                               MIDL_user_allocate(sizeof(PRIV_RESOLVER_INFO));

        if (pPrivActOutInfo == NULL)
        {
            rethr = E_OUTOFMEMORY;
            goto exit_Activation;
        }

        memset(pPrivActOutInfo, 0, sizeof(PRIV_RESOLVER_INFO));

        pActParams->pFoundInROT = &pPrivActOutInfo->FoundInROT;
        pActParams->pOxidServer = &pPrivActOutInfo->OxidServer;
        pActParams->ppServerORBindings = &pPrivActOutInfo->pServerORBindings;
        *pActParams->ppServerORBindings = 0;
        pActParams->pOxidInfo = &pPrivActOutInfo->OxidInfo;
        pActParams->pOxidInfo->psa = 0;
        pActParams->pLocalMidOfRemote = &pPrivActOutInfo->LocalMidOfRemote;
        pActParams->pDllServerModel = &pPrivActOutInfo->DllServerModel;
        pActParams->ppwszDllServer = &pPrivActOutInfo->pwszDllServer;
    }

    {
        IServerLocationInfo *pServerLocationInfo = NULL;
        pServerLocationInfo = pActPropsIn->GetServerLocationInfo();
        ASSERT(pServerLocationInfo != NULL);
        pServerLocationInfo->GetRemoteServerName(&pActParams->pwszServer);
    }

    pActPropsIn->GetClassInfo(IID_IComClassInfo, (void**)&pActParams->pComClassInfo);
    pActParams->ProtseqId = 0;
    *pActParams->pOxidServer = 0;
    *pActParams->ppwszDllServer = 0;

    RpcTryExcept
    {
        // Generic SCM Activation Path
        rethr = Activation( pActParams );
    }

#if DBG == 1
    RpcExcept(ActivationExceptionFilter(GetExceptionCode(),
                                        GetExceptionInformation()) )
#else
    RpcExcept(TRUE)
#endif
    {
        rethr = HRESULT_FROM_WIN32(RpcExceptionCode());
    }

    RpcEndExcept

    if (rethr != S_OK)
        goto exit_ActWithoutResolvingInfo;


    if (pActParams->activatedRemote)
    {
        // if did remote activation for an incoming one
        // just exit
        if (pActParams->RemoteActivation)
        {
            *ppActOut = pActParams->pActPropsOut;
            goto exit_ActWithoutResolvingInfo;
        }

        if(!pActParams->IsLocalOxid)
        {
            //Set Tid/Pid to 0 for remote server
            ASSERT(pActParams->pOxidInfo);
            pActParams->pOxidInfo->dwTid = 0;
            pActParams->pOxidInfo->dwPid = 0;
        }
    }

    ActivationPropertiesOut *pActPropsOut;

    pActPropsOut = pActParams->pActPropsOut;

    if (pActPropsOut == NULL)
    {
        rethr = pActPropsIn->GetReturnActivationProperties(&pActPropsOut);

        if (FAILED(rethr))
            goto exit_ActWithoutResolvingInfo;


        rethr = pActPropsOut->SetMarshalledResults(pActParams->Interfaces,
                                                pActParams->pIIDs,
                                                pActParams->pResults,
                                                pActParams->ppIFD);
        // COM+ 31260, don't free pActParams->pIIDs since it is owned by ActPropsIn
        MIDL_user_free(pActParams->pResults);
        MIDL_user_free(pActParams->ppIFD);

        if (FAILED(rethr))
            goto exit_ActWithoutResolvingInfo;

        pActParams->pActPropsOut = pActPropsOut;
    }


    rethr = pActPropsOut->QueryInterface(
                            IID_IScmReplyInfo,
                            (LPVOID*)&pOutScmResolverInfo
                            );

    if (FAILED(rethr))
        goto exit_ActWithoutResolvingInfo;

    if (pActParams->RemoteActivation)
    {
        RPC_STATUS          sc;
        if (*pActParams->pOxidServer != 0)
        {
            sc = _ResolveOxid2(pActParams->hRpc,
                       pActParams->pOxidServer,
                       pScmRequestInfo->cRequestedProtseqs,
                       pScmRequestInfo->pRequestedProtseqs,
                       &pScmReplyInfo->pdsaOxidBindings,
                       &pScmReplyInfo->ipidRemUnknown,
                       &pScmReplyInfo->authnHint,
                       &pScmReplyInfo->serverVersion );
            rethr = HRESULT_FROM_WIN32(sc);
        }
        pOutScmResolverInfo->SetRemoteReplyInfo(pScmReplyInfo);
    }
    else
        pOutScmResolverInfo->SetResolverInfo(pPrivActOutInfo);

    pOutScmResolverInfo->Release();

    *ppActOut = pActPropsOut;


exit_Activation:
    if (pActParams->pComClassInfo) 
    {
       pActParams->pComClassInfo->Release();
    }
    return rethr;

// Go here if ActivationPropertiesOut is not created
exit_ActWithoutResolvingInfo:
    MIDL_user_free(pScmReplyInfo);
    MIDL_user_free(pPrivActOutInfo);
    goto exit_Activation;
}

//
//   GetClassInfoFromClsid
//
//   On success, returns a IComClassInfo for the requested class
//
//   FUTURE:  this function is basically a duplicate of one linked into 
//     ole32.   We should find a way to centralize all of this catalog
//     stuff and do away with this funky "this function is just here to 
//     satisfy the linker" crud.
//
HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo)
{
    HRESULT hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        return hr;
    }
    else
    {
        // get the information object for the requested class
        // this may translate the CLSID via TreatAs and other mappings
        hr = gpCatalog->GetClassInfo(rclsid, IID_IComClassInfo, (void**)ppClassInfo);
    }
    return hr;
}

//This should never be called. It is mainly to link with actprops which
//uses it to load persistent objects and should only do so in a server.
HRESULT LoadPersistentObject(IUnknown *punk, IInstanceInfo *pInstanceInfo)
{
    return E_NOTIMPL;
}

//This should never be called. It is mainly to link with actprops which
//uses it for marshalling of returns
void *GetDestCtxPtr(COMVERSION *pComVersion)
{
    return NULL;
}

//
// These should never be called. It is mainly to link with actprops which
// uses it creating contexts
//

HRESULT CObjectContextCF_CreateInstance(IUnknown *pUnkOuter,
                                        REFIID riid,
                                        void** ppv)
{
    return E_NOTIMPL;
}

HRESULT CObjectContext::QueryInterface(REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

ULONG CObjectContext::AddRef()
{
    return E_NOTIMPL;
}

ULONG CObjectContext::Release()
{
    return E_NOTIMPL;
}

HRESULT CObjectContext::InternalQueryInterface(REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

ULONG CObjectContext::InternalAddRef()
{
    return E_NOTIMPL;
}

ULONG CObjectContext::InternalRelease()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\excladdr.cxx ===
//+-------------------------------------------------------------------
//
//  File:       excladdr.cxx
//
//  Contents:   Implements classes for managing the current address 
//              exclusion list
//
//  Classes:    CAddrExclusionMgr 
//
//  History:    07-Oct-00   jsimmons      Created
//--------------------------------------------------------------------

#include "act.hxx"


// The single instance of this object
CAddrExclusionMgr gAddrExclusionMgr;

CAddrExclusionMgr::CAddrExclusionMgr() :
                _dwNumStrings(0),
                _ppszStrings(NULL),
                _bInitRegistry(FALSE)
{
}

// 
// GetExclusionList
//
// Returns the current exclusion list.
//
HRESULT CAddrExclusionMgr::GetExclusionList(
                DWORD* pdwNumStrings,
                LPWSTR** pppszStrings)
{
    gpClientLock->LockExclusive();

    // Handle easy case
    if (_dwNumStrings == 0)
    {
        *pdwNumStrings = 0;
        *pppszStrings = NULL;
        gpClientLock->UnlockExclusive();
        return S_OK;
    }

    DWORD i;
    DWORD dwCopiedStrings;
    LPWSTR* ppszCopiedStrings;      

    ppszCopiedStrings = (LPWSTR*)MIDL_user_allocate(sizeof(WCHAR*) * _dwNumStrings);
    if (!ppszCopiedStrings)
    {
        gpClientLock->UnlockExclusive();
        return E_OUTOFMEMORY;
    }

    dwCopiedStrings = 0;
    for (i = 0; i < _dwNumStrings; i++)
    {
        if (_ppszStrings[i])
        {
            ppszCopiedStrings[i] = (LPWSTR)MIDL_user_allocate(
            sizeof(WCHAR) * (lstrlen(_ppszStrings[i]) + 1));
            if (!ppszCopiedStrings[i])
            {
                // failure in the middle.  cleanup previous allocations and return
                for (i = 0; i < _dwNumStrings; i++)
                {
                    if (ppszCopiedStrings[i])
                        MIDL_user_free(ppszCopiedStrings[i]);
                }
                MIDL_user_free(ppszCopiedStrings);
                gpClientLock->UnlockExclusive();
                return E_OUTOFMEMORY;
            }

            lstrcpy(ppszCopiedStrings[i], _ppszStrings[i]);
            dwCopiedStrings++;
        }
    }

    *pdwNumStrings = dwCopiedStrings;
    *pppszStrings = ppszCopiedStrings;

    gpClientLock->UnlockExclusive();

    return S_OK;
}

// 
// SetExclusionList
//
// Sets the current exclusion list, and pushes the
// new bindings to all current running processes 
// registered with COM.
//
HRESULT CAddrExclusionMgr::SetExclusionList(
                DWORD dwNumStrings,
                LPWSTR* ppszStrings)
{
    HRESULT hr = S_OK;
    RPC_STATUS status;
    DWORD i, j;
    LPWSTR* ppszStringsNew = NULL;

    gpClientLock->LockExclusive();

    if (dwNumStrings > 0)
    {
        ppszStringsNew = (LPWSTR*)PrivMemAlloc(sizeof(WCHAR*) * dwNumStrings);
        if (!ppszStringsNew)
        {
            gpClientLock->UnlockExclusive();
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < dwNumStrings; i++)
        {
            // Skip any null entries.  Assert in debug builds since
            // this is likely a sign of a broken app
            ASSERT(ppszStrings[i]);
            if (!ppszStrings[i])
                continue;

            ppszStringsNew[i] = (LPWSTR)PrivMemAlloc(
            sizeof(WCHAR) * (lstrlen(ppszStrings[i]) + 1));
            if (!ppszStringsNew[i])
            {
                // free up any earlier allocations that succeeded
                for (j = 0; j < i; j++)
                    PrivMemFree(ppszStringsNew[j]);

                PrivMemFree(ppszStringsNew);

                gpClientLock->UnlockExclusive();

                // and return error
                return E_OUTOFMEMORY;
            }

            lstrcpy(ppszStringsNew[i], ppszStrings[i]);
        }
    }

    // Get rid of the old list
    FreeCurrentBuffers();

    // Save off the new one
    _dwNumStrings = dwNumStrings;
    _ppszStrings = ppszStringsNew;

    // Recompute the bindings
    status = ComputeNewResolverBindings();
    if (status != RPC_S_OK)
    {
        hr = E_OUTOFMEMORY;
    }

    gpClientLock->UnlockExclusive();

    if (status == RPC_S_OK)
    {
        // Update currently running processes   
        PushCurrentBindings();
    }

    return hr;
}

// 
// EnableDisableDynamicTracking
//
// Turns on\off the dynamic address binding feature, and updates
// the registry key accordingly.
//
HRESULT CAddrExclusionMgr::EnableDisableDynamicTracking(BOOL fEnable)
{
    HRESULT hr = S_OK;
    LONG error;
    HKEY hOle;
    WCHAR* szY = L"Y";
    WCHAR* szN = L"N";

    gpClientLock->LockExclusive();

    // Open the registry key and change the value
    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_WRITE,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {   
        error = RegSetValueEx(hOle,
                              L"EnableSystemDynamicIPTracking",
                              0,
                              REG_SZ,
                              (BYTE*)(fEnable ? szY : szN),
                              4); // 4 = one wchar + null
        if (error == ERROR_SUCCESS)
        {
            // Reset the global.  Will be seen immediately
            gbDynamicIPChangesEnabled = fEnable ? TRUE : FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        CloseHandle(hOle);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    gpClientLock->UnlockExclusive();

    return hr;
}


//
//  IsExcludedAddress
//
//  Checks to see if the specified address is in our
//  current exclusion list.
//
BOOL CAddrExclusionMgr::IsExcludedAddress(LPWSTR pszAddress)
{
    DWORD i;

    ASSERT(gpClientLock->HeldExclusive());
    ASSERT(_ppszStrings);

    for (i = 0; i < _dwNumStrings; i++)
    {       
        if (_ppszStrings[i])
        {
            if (lstrcmpi(_ppszStrings[i], pszAddress) == 0)
            {
                // found it in the list
                return TRUE;
            }
        }
    }
    return FALSE;
}

// 
// BuildExclusionDSA
//
// Constructs a new dsa and puts it in *ppdsaOut; the new 
// dsa is the same as pdsaSrc, minus any addresses that are
// currently in the exclusion list.
//
HRESULT CAddrExclusionMgr::BuildExclusionDSA(                                                                                   
                                DUALSTRINGARRAY* pdsaSrc,
                                DUALSTRINGARRAY** ppdsaOut
                                )
{
    ASSERT(pdsaSrc && ppdsaOut);
    ASSERT(dsaValid(pdsaSrc));

    ASSERT(gpClientLock->HeldExclusive());

    SCMVDATEHEAP();

    DWORD i;
    BOOL bDone;
    USHORT* pStart;
    USHORT* pCurrent;
    USHORT* pCurrentNew;
    DWORD dwBindingsToExclude = 0;
    USHORT usNewDSALen = 0;
    DUALSTRINGARRAY* pdsaNew;
    BOOL* afIsExcludedAddress;

    *ppdsaOut = NULL;

    // If our list is empty, nothing to do
    if (_dwNumStrings == 0)
        return dsaAllocateAndCopy(ppdsaOut, pdsaSrc);

    // Allocate an array of bools on the stack.  This 
    // will be used to remember if an address is excluded
    // or not on the first pass, so we don't have to be
    // figure that out again on the second pass.
    //
    // Note that I will almost always allocate too much stack
    // memory -- better that than not enough.   To be exact
    // I'd have to make an extra pass thru the dsa to see how 
    // many string bindings there are - which sorta defeats
    // the purpose.
    afIsExcludedAddress = (BOOL*)_alloca(sizeof(BOOL) * pdsaSrc->wSecurityOffset);

    // First make one pass thru the incoming dsa to 
    // see how many addresses we should retain, and
    // calculate how much space they will need.
    bDone = FALSE;
    pStart = pCurrent = &(pdsaSrc->aStringArray[0]);
    i = 0;
    do
    {
        // Find end of the current string binding.  Be careful
        // to handle cases where there are no string bindings.
        while (*pCurrent != 0)
            pCurrent++;

        if ((i > 0) && (pCurrent == pStart) ||
            ((i == 0) && (*(pCurrent+1) == 0)))
        {
            // either found a zero after the previous
            // binding, or we found two zeroes in a row
            // at the beginning of pdsaSrc->aStringArray.
            bDone = TRUE;
        }
        else
        {               
            i++;  // count total # of strings found

            STRINGBINDING* psb = (STRINGBINDING*)pStart;

            // We only exclude addresses if they are using tcp
            if (psb->wTowerId == ID_TCP &&
                IsExcludedAddress(&(psb->aNetworkAddr)))
            {
                dwBindingsToExclude++;
                afIsExcludedAddress[i] = TRUE;
            }
            else
            {
                // Add string len plus 2 (space for towerid + null terminator)
                usNewDSALen = usNewDSALen + (USHORT) (lstrlen(&(psb->aNetworkAddr)) + 2);
                afIsExcludedAddress[i] = FALSE;
            }
            // advance to next string binding
            pCurrent++; 
            pStart = pCurrent;
        }
    } while (!bDone);

    // If there are no addresses that need excluding, just copy
    // and return the incoming bindings.
    if (dwBindingsToExclude == 0)
        return dsaAllocateAndCopy(ppdsaOut, pdsaSrc);

    // If we didn't find any string bindings to use at all, then we 
    // need to manually add a word for the initial NULL.
    if (usNewDSALen == 0)
        usNewDSALen = 1;

    // Add space for wNumEntries + wSecurityOffset
    usNewDSALen += (sizeof(USHORT) * 2);

    // Add size of all security bindings
    usNewDSALen += ((pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset));

    // Add one for the string bindings terminating NULL.
    usNewDSALen++;

    // Allocate the memory
    pdsaNew = (DUALSTRINGARRAY*)MIDL_user_allocate(usNewDSALen * sizeof(USHORT));
    if (!pdsaNew)
        return E_OUTOFMEMORY;

    ZeroMemory(pdsaNew, usNewDSALen * sizeof(USHORT));

    // Set length
    pdsaNew->wNumEntries = usNewDSALen - 2; // don't count wNumEntries\wSecOffset

    // Initialize ptr into the new dsa
    pCurrentNew = &(pdsaNew->aStringArray[0]);

    // If we are excluding all of the string bindings in pdsaSrc, then 
    // there's no need to make a second pass
    if (dwBindingsToExclude == i)
    {
        // No string bindings left at all.  Not a very useful 
        // situation.  Need to add the initial NULL:
        *pCurrentNew = NULL;
        pCurrentNew++;
    }
    else
    {
        // Make a second pass, copying the non-excluded addresses
        // over to the new dsa as we go.
        bDone = FALSE;
        pStart = pCurrent = &(pdsaSrc->aStringArray[0]);
        i = 0;          
        do              
        {
            // Find end of the current string binding
            while (*pCurrent != 0)
                pCurrent++;

            if ((i > 0) && (pCurrent == pStart) ||
                ((i == 0) && (*(pCurrent+1) == 0)))
            {
                // either found a zero after the previous
                // binding, or we found two zeroes in a row
                // at the beginning of pdsaSrc->aStringArray.
                bDone = TRUE;
            }
            else
            {
                i++;  // count total # of strings found

                if (!afIsExcludedAddress[i]) // remembered from first pass above
                {
                    STRINGBINDING* psb = (STRINGBINDING*)pStart;
                    STRINGBINDING* psbNew = (STRINGBINDING*)pCurrentNew;

                    // Copy tower id
                    psbNew->wTowerId = psb->wTowerId;
                    // Copy address
                    lstrcpy(&(psbNew->aNetworkAddr), &(psb->aNetworkAddr));
                    // Move cursor for new dsa (2=towerid + null terminator)
                    pCurrentNew += (2 + lstrlen(&(psbNew->aNetworkAddr)));
                }
                pCurrent++;
                pStart = pCurrent;
            }
        } while (!bDone);
    }

    // Add final null terminator for string bindings
    *pCurrentNew = NULL;   // points to after last string binding, NULL it out
    pCurrentNew++;         // now points to first security binding

    // Set security offset
    pdsaNew->wSecurityOffset = (unsigned short)(pCurrentNew - &(pdsaNew->aStringArray[0]));

    // Copy security bindings en masse
    memcpy(pCurrentNew, 
    &(pdsaSrc->aStringArray[pdsaSrc->wSecurityOffset]),
    (pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset) * sizeof(USHORT));

    ASSERT(dsaValid(pdsaNew));

    // Success
    *ppdsaOut = pdsaNew;

    SCMVDATEHEAP();

    return S_OK;
}

//
//  InitializeFromRegistry
//  
//  Reads initial address list from registry.  Can only
//  be called once, after that subsequent calls will be
//  ignored.
//
void CAddrExclusionMgr::InitializeFromRegistry()
{
    ASSERT(gpClientLock->HeldExclusive());  

    if (_bInitRegistry)
        return;

    _bInitRegistry = TRUE; // this is it, success or fail

    // UNDONE -- if we wanted to, we could support persisting
    // the exclusion list in the registry, and read it out
    // here shortly after boot.

    return;
}

// Private function, no lock needed
void CAddrExclusionMgr::FreeCurrentBuffers()
{
    ASSERT((_dwNumStrings == 0 && _ppszStrings == 0) ||
           (_dwNumStrings != 0 && _ppszStrings != 0));

    DWORD i;

    for (i = 0; i < _dwNumStrings; i++)
    {
        PrivMemFree(_ppszStrings[i]);
    }

    if (_ppszStrings)
        PrivMemFree(_ppszStrings);

    _dwNumStrings = 0;
    _ppszStrings = NULL;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\clsid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  clsid.cxx
//
//  Classes for managing CLSID and APPID registry settings.
//
//--------------------------------------------------------------------------

#include "act.hxx"
#include <catalog.h>
#include <ole2com.h>
#include "registry.hxx"

// The domain name to use if no domain name is specified in the RunAs key.
// We use . instead  of the local machine name because the local machine name
// does not work if we are on a Domain Controller, . works in all cases.

WCHAR *gpwszLocalMachineDomain = L".";

//+-------------------------------------------------------------------------
//
// LookupClsidData
//
//  Loads the registry configuration for the given CLSID.  Option can be any
//  of the LOAD_* values defined in clsid.hxx, or 0 for no special handling.
//
//--------------------------------------------------------------------------
HRESULT
LookupClsidData(
               IN  GUID &          Clsid,
               IN  IComClassInfo*  pComClassInfo,
               IN  CToken *        pToken,
               IN  DWORD           Option,
               IN OUT CClsidData **ppClsidData
               )
{
    HRESULT hr;

    if ( ! *ppClsidData )
       *ppClsidData = new CClsidData( Clsid, pToken, pComClassInfo );

    if ( ! *ppClsidData )
        return (E_OUTOFMEMORY);

    hr = (*ppClsidData)->Load( Option );

    if ( hr != S_OK )
    {
        delete *ppClsidData;
        *ppClsidData = 0;
    }
    else
    {
        // In case of Treat As
        Clsid = *(*ppClsidData)->ClsidGuid();
    }

    return (hr);
}

//+-------------------------------------------------------------------------
//
// LookupAppidData
//
//  Loads the registry configuration for the given APPID.
//
//--------------------------------------------------------------------------
HRESULT
LookupAppidData(
               IN  GUID &        AppidGuid,
               IN  CToken      * pToken,
               OUT CAppidData ** ppAppidData
               )
{
    HRESULT hr = S_OK;

    WCHAR   wszAppid[GUIDSTR_MAX];
    wStringFromGUID2( AppidGuid, wszAppid, sizeof(wszAppid) );

    *ppAppidData = new CAppidData( wszAppid, pToken );

    if ( ! *ppAppidData )
        hr = E_OUTOFMEMORY;
    else
        hr = (*ppAppidData)->Load( NULL );

    return (hr);
}

//
// CClsidData
//

CClsidData::CClsidData(
                      IN  GUID &      Clsid,
                      IN  CToken *    pToken,
                      IN  IComClassInfo*  pComClassInfo
                      )
{
    if ( pToken )
        pToken->AddRef();

    _pToken = pToken;

    _Clsid = Clsid;
    _pAppid = NULL;
    _ServerType = SERVERTYPE_NONE;
    _DllThreadModel = SINGLE_THREADED;
    _pwszServer = NULL;
    _pwszServerExecutable = NULL;
    _pIComCI = pComClassInfo;
    if (pComClassInfo)
    {
        pComClassInfo->AddRef();
        pComClassInfo->Lock();
    }
    _pIClassCI = NULL;
    _pICPI = NULL;
    _pwszDarwinId = NULL;
    _pwszDllSurrogate = NULL;
    _hSaferLevel = NULL;
    _dwAcceptableCtx = 0;
    _bIsInprocClass = FALSE;
	memset(_wszClsid, 0, sizeof(_wszClsid));
}

CClsidData::~CClsidData()
{
    Purge();

    if ( _pToken )
        _pToken->Release();

    _pToken = 0;

    if ( _pIComCI != NULL )
    {
        _pIComCI->Unlock();
        _pIComCI->Release();
    }
    if ( _pIClassCI != NULL )
        _pIClassCI->Release();
    if ( _pICPI != NULL )
        _pICPI->Release();
}

//-------------------------------------------------------------------------
//
// CClsidData::Load
//
//  Forces a load of all registry keys and values for this clsid and its
//  associated APPID.
//
//-------------------------------------------------------------------------
HRESULT
CClsidData::Load(
                IN  DWORD   Option
                )
{
    HRESULT hr = E_FAIL;
    LocalServerType lsType = LocalServerType32;
    ProcessType pType = ProcessTypeNormal;
    ThreadingModel tModel = SingleThreaded;
    DWORD dwAcceptableClsCtx = 0;
    IComServices *pServices = NULL;
    IComClassInfo2 *pIComCI2 = NULL;
    IClassClassicInfo2 *pClassCI2 = NULL;
        

    //
    // Catalog cruft
    //

    hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    if ( _pIComCI == NULL )
    {
        if ( _pToken )
        {
            // Ok, here's the deal.
            // First we need to make sure we've exhausted all of the LocalServer
            // options on the machine before turning to a remote server option,
            // because the classinfo will always say yes to remote server.
            hr = gpCatalogSCM->GetClassInfo ( CLSCTX_LOCAL_SERVER,
                                              _pToken,
                                              _Clsid,
                                              IID_IComClassInfo,
                                              (void**) &_pIComCI );
            
            if ( _pIComCI == NULL || hr != S_OK )
            {
                // Exhaustive search for localserver failed, or we just want
                // the first thing we find.  Just do a normal search.
                // REVIEW: Will the do the right thing for 32bit CLSID?
                //         What about Darwin?
                hr = gpCatalogSCM->GetClassInfo ( 0,
                                                  _pToken,
                                                  _Clsid,
                                                  IID_IComClassInfo,
                                                  (void**) &_pIComCI );
            }
        }
        else
        {
            hr = gpCatalog->GetClassInfo ( _Clsid,
                                           IID_IComClassInfo,
                                           (void**) &_pIComCI );
        }

        if ( _pIComCI == NULL || hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }

        _pIComCI->Lock();
    }

    hr = _pIComCI->QueryInterface(IID_IComClassInfo2, (void **)&pIComCI2);
    if(SUCCEEDED(hr))
    {
    	BOOL bClassEnabled;
		pIComCI2->IsEnabled(&bClassEnabled);
		pIComCI2->Release();

		if(bClassEnabled == FALSE)
		{
			hr = CO_E_CLASS_DISABLED;
			goto cleanup;
		}
    }

    // Treat As possible so read clsid
    GUID *pguid;
    hr = _pIComCI->GetConfiguredClsid(&pguid);
    _Clsid = *pguid;
	
    wStringFromGUID2(_Clsid, _wszClsid, sizeof(_wszClsid));	

    if ( _pIClassCI == NULL )
    {
        hr = _pIComCI->QueryInterface (IID_IClassClassicInfo, (void**) &_pIClassCI );
        if ( _pIClassCI == NULL || hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
    }

    if ( _pICPI == NULL )
    {
        hr = _pIClassCI->GetProcess ( IID_IComProcessInfo, (void**) &_pICPI );
        if ( hr != S_OK && _pICPI != NULL )
        {
            _pICPI->Release();
            _pICPI = NULL;
        }
        hr = S_OK;
    }

    Purge();

    //
    // Load Surrogate command line

    hr = _pIClassCI->GetSurrogateCommandLine(&_pwszDllSurrogate);
    if ( hr != S_OK )
    {
        // GetSurrogateCommandLine can fail for two reasons:  1) out-of-memory;
        // or 2) the class is not configured to run as a surrogate.  It is 
        // somewhat difficult to tell at this point which is which.   Therefore,
        // we don't let a failure here doesn't stop us; instead we check further 
        // below for the case where we are supposedly a surrogate but don't have
        // a surrogate cmd line.
        _pwszDllSurrogate = NULL;
        hr = S_OK;
    }

    //
    // Load APPID settings before other non-Darwin CLSID settings.
    //

    if ( _pICPI != NULL )
    {
        GUID* pGuidProcessId;
        WCHAR wszAppid[GUIDSTR_MAX];

        hr = _pICPI->GetProcessId (&pGuidProcessId);
        if ( hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
        wStringFromGUID2( *pGuidProcessId, wszAppid, sizeof(wszAppid) );

        _pAppid = new CAppidData( wszAppid, _pToken );

        if ( _pAppid == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = _pAppid->Load( _pICPI );
        }

        if ( hr != S_OK )
        {
            goto cleanup;
        }

        hr = _pICPI->GetProcessType (&pType);
        if ( hr != S_OK )
        {
            pType = ProcessTypeNormal;
            hr = S_OK;
        }
    }

    //
    //  See if we can find a LocalServer
    //

    hr = _pIClassCI->GetLocalServerType (&lsType);
    if ( hr != S_OK )
    {
        hr = S_OK;
    }
    else if ( (pType != ProcessTypeService) &&
			  (pType != ProcessTypeComPlusService) )
    {
        if ( lsType == LocalServerType16 )
        {
            _ServerType = SERVERTYPE_EXE16;
        }
        else
        {
            _ServerType = SERVERTYPE_EXE32;
        }

        hr = _pIClassCI->GetModulePath(CLSCTX_LOCAL_SERVER, &_pwszServer);
        if ( hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
        else
        {
            pType = ProcessTypeNormal;
        }
    }

    hr = _pIClassCI->QueryInterface(IID_IClassClassicInfo2, (void **)&pClassCI2);
    if (SUCCEEDED(hr))
    {
        hr = pClassCI2->GetServerExecutable(&_pwszServerExecutable);
        if (FAILED(hr))
        {
            _pwszServerExecutable = NULL;
        }        
        pClassCI2->Release();
    }    

    //
    //  Set up process type information
    //

    // Determine the acceptable context of creation
    hr = _pIComCI->GetClassContext((CLSCTX)(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER),
                                   (CLSCTX*) &dwAcceptableClsCtx);
    
    if ( SUCCEEDED(hr) )
    {
        if ( !dwAcceptableClsCtx )
        {
            if (Option == LOAD_APPID)
            {
                _bIsInprocClass = TRUE;
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }
        }
    }

    if ( FAILED(hr) )
        goto cleanup;

    // Set the acceptable context of creation
    _dwAcceptableCtx = dwAcceptableClsCtx;


    switch ( pType )
    {
    case ProcessTypeNormal:
        break;

    case ProcessTypeService:
        _ServerType = SERVERTYPE_SERVICE;
        break;

    case ProcessTypeComPlusService:
        _ServerType = SERVERTYPE_COMPLUS_SVC;
        break;

    case ProcessTypeComPlus:
        //See if services configured, else normal dllhost
        if (_pICPI->QueryInterface(IID_IComServices,
                                   (void**) &pServices) == S_OK )
        {
            _ServerType = SERVERTYPE_COMPLUS;
            pServices->Release();
        }
        else
            _ServerType = SERVERTYPE_DLLHOST;

        break;

    case ProcessTypeLegacySurrogate:
        _ServerType = SERVERTYPE_SURROGATE;

        hr = _pIClassCI->GetModulePath(CLSCTX_INPROC_SERVER, &_pwszServer);
        if ( hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
        break;
    default:
        hr = REGDB_E_CLASSNOTREG;
        goto cleanup;
        break;
    }


    //
    //  Other process info
    //

	if ( S_OK != _pIClassCI->GetThreadingModel (&tModel) )
	{
	    hr = REGDB_E_BADTHREADINGMODEL;
	}
	else
	{
	    switch ( tModel )
	    {
	    case ApartmentThreaded:
	        _DllThreadModel = APT_THREADED;
	        break;
	    case FreeThreaded:
	        _DllThreadModel = FREE_THREADED;
	        break;
	    case SingleThreaded:
	    default:
	        _DllThreadModel = SINGLE_THREADED;
	        break;
	    case BothThreaded:
	    case NeutralThreaded:
	        _DllThreadModel = BOTH_THREADED;
	        break;
	    }
	}

    //
    // Safer Level.
    //
    hr = CalculateSaferLevel();

    cleanup:

    if ( _ServerType == SERVERTYPE_SURROGATE ||
         _ServerType == SERVERTYPE_COMPLUS ||
         _ServerType == SERVERTYPE_DLLHOST)
    {
        if (!_pwszDllSurrogate)
        {
            // we're supposed to be a surrogate, but don't have a cmd line for such
            if (SUCCEEDED(hr))
                hr = E_OUTOFMEMORY;
        }
    }

    if ( FAILED(hr) )
    {
        Purge();

        if ( _pIComCI != NULL )
        {
            _pIComCI->Unlock();
            _pIComCI->Release();
            _pIComCI = NULL;
        }

        if ( _pIClassCI != NULL )
        {
            _pIClassCI->Release();
            _pIClassCI = NULL;
        }

        if ( _pICPI != NULL )
        {
            _pICPI->Release();
            _pICPI = NULL;
        }
    }

    return (hr);
}

//-------------------------------------------------------------------------
//
// CClsidData::Purge
//
//  Frees and clears all member data except for clsid registry key and
//  Darwin ID values.
//
//-------------------------------------------------------------------------
void
CClsidData::Purge()
{
    if ( _pAppid )
    {
        delete _pAppid;
    }

    _pAppid = NULL;
    _ServerType = SERVERTYPE_NONE;
    _DllThreadModel = SINGLE_THREADED;
    _pwszServer = NULL;
    _pwszServerExecutable = NULL;
    _pwszDarwinId = NULL;
    _pwszDllSurrogate = NULL;

    if (_hSaferLevel)
    {
        SaferCloseLevel(_hSaferLevel);
        _hSaferLevel = NULL;
    }
}

//-------------------------------------------------------------------------
//
// CClsidData::CalculateSaferLevel
//
//  Determine (and open) the safer level for this CLSID.  The decision
//  process is as follows:
//
//  - If a SAFER level is configured on the application, use that.
//  - Otherwise, if automatic enforcement is ON:
//     - If we can get a SAFER level from the file, use that.
//     - Otherwise, if there's a default SAFER level, use that.
//     - Otherwise, don't use SAFER.
//  - Otherwise, don't use SAFER.
//
//-------------------------------------------------------------------------
HRESULT
CClsidData::CalculateSaferLevel()
{
    HRESULT hr = S_OK;

    // 
    // One has already been calculated, return it.
    //
    if (_hSaferLevel)
    {
        return S_OK;
    }

    //
    // Get the configured safer level...
    //
    if (_pAppid)
    {
        DWORD dwSaferLevel;
        
        // GetSaferLevel returns TRUE if we have a configured safer level....
        BOOL fSaferConfigured = _pAppid->GetSaferLevel(&dwSaferLevel);
        if (fSaferConfigured)
        {   
            if (!SaferCreateLevel(SAFER_SCOPEID_MACHINE,
                                  dwSaferLevel,
                                  SAFER_LEVEL_OPEN,
                                  &_hSaferLevel,
                                  NULL))
            {
                _hSaferLevel = NULL;
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}


//
// CAppidData
//
CAppidData::CAppidData(
                      IN  WCHAR *     pwszAppid,
                      IN  CToken *    pToken
                      )
{
    ASSERT( lstrlenW( pwszAppid ) == GUIDSTR_MAX - 1 );

    lstrcpyW( _wszAppid, pwszAppid );
    BOOL bGuidConv = wGUIDFromString(_wszAppid,&_GuidAppid);

    ASSERT(bGuidConv && "AppID is not a well-formed GUID");

    if ( pToken )
        pToken->AddRef();

    _pToken = pToken;

    _bActivateAtStorage = FALSE;

    _pwszService = 0;
    _pwszServiceParameters = 0;
    _pwszRunAsUser = 0;
    _pwszRunAsDomain = 0;
    _pLaunchPermission = 0;

    _pwszRemoteServerNames = 0;
    _bComPlusProcess = FALSE;

    _pICPI = NULL;

    _dwSaferLevel = 0;
    _fSaferLevelValid = FALSE;
}

CAppidData::~CAppidData()
{
    Purge();

    if ( _pToken )
        _pToken->Release();

    if ( _pICPI != NULL )
        _pICPI->Release();
}

//-------------------------------------------------------------------------
//
// CAppidData::Load
//
//  Reads all named value settings for this APPID.
//
//-------------------------------------------------------------------------
HRESULT
CAppidData::Load( IN IComProcessInfo *pICPI )
{
    HRESULT hr;
    IComProcessInfo2 *pICPI2 = NULL;
    ProcessType pType = ProcessTypeNormal;
    WCHAR* pwszTmpValue = NULL;
    WCHAR* pwszRunAsDomain = NULL;
    int len = 0;
    DWORD dwJunk;    


    hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    if ( _pICPI == NULL )
    {
        if ( pICPI != NULL )
        {
            _pICPI = pICPI;
            _pICPI->AddRef();
        }
        else if ( _pToken )
            hr = gpCatalogSCM->GetProcessInfo (0,
                                               _pToken,
                                               _GuidAppid,
                                               IID_IComProcessInfo,
                                               (void**) &_pICPI );
        else
            hr = gpCatalog->GetProcessInfo ( _GuidAppid,
                                             IID_IComProcessInfo,
                                             (void**) &_pICPI );

        if ( _pICPI == NULL || hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
    }

    //
    // ActivateAtStorage
    //

    hr = _pICPI->GetActivateAtStorage (&_bActivateAtStorage);
    if ( hr != S_OK )
    {
        _bActivateAtStorage = FALSE;
        hr = S_OK;
    }

    //
    //  ProcessType
    //

    hr = _pICPI->GetProcessType (&pType);
    if ( hr != S_OK )
    {
        pType = ProcessTypeNormal;
        hr = S_OK;
    }

    //
    //  ComPlus?
    //
    // NOTE!!!!:: This is true for normal dllhost.exe regardless of
    //            whether they are really complus or not.  We won't
    //            distinguish this in here in AppidData but in
    //            ClsidData

    _bComPlusProcess = pType == ProcessTypeComPlus;

    //
    // RemoteServerName
    //
    hr = _pICPI->GetRemoteServerName (&_pwszRemoteServerNames);
    if ( hr != S_OK )
    {
        _pwszRemoteServerNames = NULL;
        hr = S_OK;
    }

    //
    // LaunchPermision
    //
    hr = _pICPI->GetLaunchPermission ( (void**) &_pLaunchPermission, &dwJunk );
    if ( hr != S_OK )
    {
        _pLaunchPermission = NULL;
        hr = S_OK;
    }

    //
    // LocalService and ServiceParameters
    //

    hr = _pICPI->GetServiceName (&_pwszService);
    if ( hr != S_OK )
    {
        _pwszService = NULL;
        hr = S_OK;
    }
    hr = _pICPI->GetServiceParameters (&_pwszServiceParameters);
    if ( hr != S_OK )
    {
        _pwszServiceParameters = NULL;
        hr = S_OK;
    }

    //
    // RunAs
    //
    // Note: current implementation of GetRunAsUser is that it 
    // returns an error if there is no RunAs user for this appid,
    // --OR-- it returns S_OK with a valid outparam.
    //
    hr = _pICPI->GetRunAsUser (&pwszTmpValue);
    if ( hr != S_OK )
    {
        _pwszRunAsUser = NULL;
        _pwszRunAsDomain = NULL;
        hr = S_OK;
    }
    else
    {
        len = lstrlenW(pwszTmpValue)+1;
        _pwszRunAsUser = new WCHAR[len];
        if (!_pwszRunAsUser)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        lstrcpyW(_pwszRunAsUser, pwszTmpValue);

        pwszTmpValue = _pwszRunAsUser;

        while ( *pwszTmpValue && *pwszTmpValue != L'\\' )
            pwszTmpValue++;

        if ( ! *pwszTmpValue )
        {
            // user name, no domain name, use the machine name
            _pwszRunAsDomain = gpwszLocalMachineDomain;
        }
        else
        {
            // domain\user
            ASSERT( L'\\' == *pwszTmpValue );
            *pwszTmpValue = 0;
            _pwszRunAsDomain = _pwszRunAsUser;
            _pwszRunAsUser = pwszTmpValue + 1;

            if ( ! *_pwszRunAsUser )
            {
                hr = E_FAIL;
                goto cleanup;
            }
        }
    }

    //
    // Safer trust level.
    //
    hr = _pICPI->QueryInterface(IID_IComProcessInfo2, (void **)&pICPI2);
    if (SUCCEEDED(hr))
    {
        hr = pICPI2->GetSaferTrustLevel(&_dwSaferLevel);
        
        pICPI2->Release();
    }
    
    // If we couldn't get a configured trust level, make
    // sure we remember that.
    if (FAILED(hr))
    {
        _fSaferLevelValid = FALSE;
        hr = S_OK;
    }
    else
    {
        _fSaferLevelValid = TRUE;
    }

    cleanup:
    if ( FAILED(hr) )
    {
        Purge();
        if ( _pICPI != NULL )
        {
            _pICPI->Release();
            _pICPI = NULL;
        }
    }

    return (hr);
}


//-------------------------------------------------------------------------
//
// CAppidData::Purge
//
//  Frees and clears all named value settings for this APPID.
//
//-------------------------------------------------------------------------
void
CAppidData::Purge()
{
    _pwszService = 0;
    _pwszServiceParameters = 0;
    _pLaunchPermission = 0;

    //  This is too tricky, so it goes. If we've assigned RunAsDomain
    //  the address of the global local machine name, then the buffer
    //  we allocated is pointed at by _pwszRunAsUser. Otherwise, it's
    //  pointed at by _pwszRunAsDomain ('cause if both user and domain
    //  are in the string, domain is first).

    if ( _pwszRunAsUser != NULL )
    {
        if ( _pwszRunAsDomain == gpwszLocalMachineDomain )
        {
            delete [] _pwszRunAsUser;
        }
        else
        {
            delete [] _pwszRunAsDomain;
        }
    }
    _pwszRunAsUser = 0;
    _pwszRunAsDomain = 0;

    _fSaferLevelValid = FALSE;
    _dwSaferLevel = 0;

    _pwszRemoteServerNames = 0;
    _bActivateAtStorage = 0;
}


BOOL
CAppidData::CertifyServer(
                         CProcess *  pProcess
                         )
{
    PSID    pRequiredSid = NULL;
    HANDLE  hToken = 0;
    BOOL    bStatus;

    if ( _pwszService )
    {
        SC_HANDLE       hService;
		
        ASSERT(g_hServiceController);
        hService = OpenService( g_hServiceController,
                                _pwszService,
                                GENERIC_READ );

        if ( ! hService )
            return (FALSE);

        DWORD dwBufNeeded = 0;
        bStatus = QueryServiceStatusEx(hService,
                                       SC_STATUS_PROCESS_INFO,
                                       NULL,
                                       0,
                                       &dwBufNeeded);
        ASSERT(!bStatus);
        if (!bStatus && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {            
            BYTE* pBuf = NULL;
            
            SafeAllocaAllocate(pBuf, dwBufNeeded);
            if (pBuf)
            {                
                bStatus = QueryServiceStatusEx(hService,
                                               SC_STATUS_PROCESS_INFO,
                                               pBuf,
                                               dwBufNeeded,
                                               &dwBufNeeded);
                if (bStatus)
                {
                    SERVICE_STATUS_PROCESS* pServiceStatus = (SERVICE_STATUS_PROCESS*)pBuf;
                    
                    // Service must not be stopped or stopping, and service's
                    // pid should match that of the registering process.
                    if (pServiceStatus->dwCurrentState == SERVICE_STOPPED ||
                        pServiceStatus->dwCurrentState == SERVICE_STOP_PENDING ||
                        pServiceStatus->dwProcessId != pProcess->GetPID())
                    {
                        bStatus = FALSE;
                    }
                }
                SafeAllocaFree(pBuf);
            }
        }
        else
        {
            bStatus = FALSE;
        }
                                       
        CloseServiceHandle(hService);

        return (bStatus);
    }

    if ( ( ! _pwszRunAsUser ) && ( ! IsInteractiveUser() ) )
        return (TRUE);

    if ( IsInteractiveUser() )
    {
        ULONG ulSessionID = pProcess->GetToken()->GetSessionId();
        hToken = GetUserTokenForSession(ulSessionID);
    }
    else
    {
        hToken = GetRunAsToken( 0,    // CLSCTX isn't always available here
                                _wszAppid,
                                _pwszRunAsDomain,
                                _pwszRunAsUser,
                                FALSE);
    }
    
    if (hToken)
    {
        DWORD dwSaferLevel;
        if (GetSaferLevel(&dwSaferLevel))
        {
            //
            // If a safer level is configured, then the person being launched
            // must have the same safer restrictions as we expected put on them.
            //
            SAFER_LEVEL_HANDLE hSaferLevel = NULL;
            HANDLE      hSaferToken = NULL; 

            bStatus = SaferCreateLevel(SAFER_SCOPEID_MACHINE,
                                       dwSaferLevel,
                                       SAFER_LEVEL_OPEN,
                                       &hSaferLevel,
                                       NULL);
            if (bStatus)
            {
                bStatus = SaferComputeTokenFromLevel(hSaferLevel,
                                                     hToken,
                                                     &hSaferToken,
                                                     0,
                                                     NULL);
                SaferCloseLevel(hSaferLevel);
            }

            if (bStatus)
            {
                NtClose(hToken);
                hToken = hSaferToken;
            }
        }
        else
            bStatus = TRUE;

        if (bStatus)
        {
            if (S_OK != pProcess->GetToken()->MatchToken(hToken, TRUE))
                bStatus = FALSE;
        }
    }
    else
        bStatus = FALSE;


    if ( hToken )
        NtClose( hToken );

    return (bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\dfsext.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsext.cxx
//
//  Contents:   Code to see if a path refers to a Dfs path.
//
//  Classes:    None
//
//  Functions:  TranslateDfsPath
//
//  History:    June 17, 1996  Milans Created
//
//-----------------------------------------------------------------------------

#include "act.hxx"

#ifdef DFSACTIVATION

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  OUT PULONG OutputBufferLength);

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle);


//+-------------------------------------------------------------------------
//
//  Function:   DfsOpen, private
//
//  Synopsis:   Opens a handle to the Dfs driver for fsctl purposes.
//
//  Arguments:  [DfsHandle] -- On successful return, contains handle to the
//                      driver.
//
//  Returns:    NTSTATUS of attempt to open the Dfs driver.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING name = {
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        DFS_DRIVER_NAME};

    InitializeObjectAttributes(
        &objectAttributes,
        &name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctl, public
//
//  Synopsis:   Fsctl's to the Dfs driver.
//
//  Arguments:  [DfsHandle] -- Handle to the Dfs driver, usually obtained by
//                      calling DfsOpen.
//              [FsControlCode] -- The FSCTL code (see private\inc\dfsfsctl.h)
//              [InputBuffer] -- InputBuffer to the fsctl.
//              [InputBufferLength] -- Length, in BYTES, of InputBuffer
//              [OutputBuffer] -- OutputBuffer to the fsctl.
//              [OutputBufferLength] -- Length, in BYTES, of OutputBuffer
//
//  Returns:    NTSTATUS of Fsctl attempt.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN OUT PULONG OutputBufferLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    status = NtFsControlFile(
        DfsHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        *OutputBufferLength
    );

    if(NT_SUCCESS(status))
        status = ioStatus.Status;

    if (status == STATUS_BUFFER_OVERFLOW)
        *OutputBufferLength = *((PULONG) OutputBuffer);

    return status;
}

#endif // DFSACTIVATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\events.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       events.cxx
//
//  Contents:
//
//  History:    ?-??-??   ???       Created
//              6-17-99   a-sergiv  Added event filtering
//
//--------------------------------------------------------------------------

#include "act.hxx"

BOOL
GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy) {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, TEXT("S-%lu-"), SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}
void
LogRegisterTimeout(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    // %1 is the clsid
    HANDLE  LogHandle;
    LPWSTR  Strings[1]; // array of message strings.
    WCHAR   wszClsid[GUIDSTR_MAX];

    // Get the clsid
    wStringFromGUID2( *pClsid, wszClsid, sizeof(wszClsid) );
    Strings[0] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_SERVER_START_TIMEOUT,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     1,             // 1 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }

}

void
LogServerStartError(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    WCHAR *     pwszCommandLine
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[3]; // array of message strings.
    WCHAR   wszErrnum[20];
    WCHAR   wszClsid[GUIDSTR_MAX];

    // Save the command line
    Strings[0] = pwszCommandLine;

    // Save the error number
    wsprintf(wszErrnum, L"%lu",GetLastError() );
    Strings[1] = wszErrnum;

    // Get the clsid
    wStringFromGUID2( *pClsid, wszClsid, sizeof(wszClsid) );
    Strings[2] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_CREATEPROCESS_FAILURE,
                     pClientToken->GetSid(), // SID
                     3,             // 3 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}

void
LogRunAsServerStartError(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    WCHAR *     pwszCommandLine,
    WCHAR *     pwszRunAsUser,
    WCHAR *     pwszRunAsDomain
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[5];
    WCHAR   wszErrnum[20];
    WCHAR   wszClsid[GUIDSTR_MAX];

    // for this message,
    // %1 is the command line, and %2 is the error number string
    // %3 is the CLSID, %4 is the RunAs domain name, %5 is the RunAs Userid

    // Save the command line
    Strings[0] = pwszCommandLine;

    // Save the error number
    wsprintf(wszErrnum, L"%lu",GetLastError() );
    Strings[1] = wszErrnum;

    // Get the clsid
    wStringFromGUID2(*pClsid, wszClsid, sizeof(wszClsid));
    Strings[2] = wszClsid;

    // Put in the RunAs identity
    Strings[3] = pwszRunAsDomain;
    Strings[4] = pwszRunAsUser;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
        {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     5,             // 5 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
        }
}

void
LogServiceStartError(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    WCHAR *     pwszServiceName,
    WCHAR *     pwszServiceArgs,
    DWORD       err
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[4];
    WCHAR   wszClsid[GUIDSTR_MAX];
    WCHAR   wszErrnum[20];

    // %1 is the error number
    // %2 is the service name
    // %3 is the serviceargs
    // %4 is the clsid

    // Save the error number
    wsprintf(wszErrnum, L"%lu",err );
    Strings[0] = wszErrnum;

    Strings[1] = pwszServiceName;
    Strings[2] = pwszServiceArgs;

    // Get the clsid
    wStringFromGUID2(*pClsid, wszClsid, sizeof(wszClsid));
    Strings[3] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_START_SERVICE_FAILURE,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     4,             // 4 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}


void
LogLaunchAccessFailed(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    BOOL        bDefaultLaunchPermission
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    ASSERT(pClientToken);

    HANDLE  LogHandle;
    LPWSTR  Strings[4];
    PSID    pSid = pClientToken->GetSid();
    WCHAR   wszClsid[GUIDSTR_MAX];

    // for this message, %1 is the clsid
    //                   %2 is username
    //                   %3 is domainname
    //                   %4 is textual SID


    ///////////////////////////////////////////////////
    //
    // Get the clsid
    //

    wStringFromGUID2(*pClsid, wszClsid, sizeof(wszClsid));
    Strings[0] = wszClsid;

    ///////////////////////////////////////////////////
    //
    // Get the user name, domain name
    //

#define NAMELEN 256

    DWORD unamelen = NAMELEN;
    DWORD dnamelen = NAMELEN;
    SID_NAME_USE sidNameUse;
    WCHAR username[NAMELEN] = L"Unavailable";
    WCHAR domainname[NAMELEN] = L"Unavailable";

    Strings[1] = username;
    Strings[2] = domainname;

    if (pSid != NULL)
    {
        LookupAccountSid (NULL, pSid, 
                          username, &unamelen, 
                          domainname, &dnamelen,
                          &sidNameUse);
    }
    

    ///////////////////////////////////////////////////
    //
    // Get SID as text
    //

    BOOL worked = FALSE;
    DWORD sidLen = NAMELEN;
    WCHAR sidAsText[NAMELEN];

    if (pSid != NULL)
    {
        worked = GetTextualSid (pSid, sidAsText, &sidLen);
    }        
    
    Strings[3] = worked ? sidAsText : L"Unavailable";        
    

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     bDefaultLaunchPermission ? EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED : EVENT_RPCSS_LAUNCH_ACCESS_DENIED,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     4,             // 1 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}


void
LogRemoteSideUnavailable(
    DWORD   clsctx,
    WCHAR * pwszServerName )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE      LogHandle;
    LPWSTR      Strings[1];
    CToken *    pToken;
    RPC_STATUS  Status;

    // %1 is the remote machine name

    Strings[0] = pwszServerName;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL, SCM_EVENT_SOURCE );
    if ( ! LogHandle )
        return;

    Status = LookupOrCreateTokenForRPCClient( NULL, TRUE, &pToken, NULL );
    if ( Status != RPC_S_OK )
        return;

    ReportEvent( LogHandle,
                 EVENTLOG_ERROR_TYPE,
                 0,             // event category
                 EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE,
                 pToken->GetSid(),
                 1,             // 1 strings passed
                 0,             // 0 bytes of binary
                 (LPCTSTR *)Strings, // array of strings
                 NULL );        // no raw data

    // clean up the event log handle
    DeregisterEventSource(LogHandle);

    pToken->Release();
}

void
LogRemoteSideFailure(
    CLSID *             pClsid,
    DWORD               clsctx,
    WCHAR *             pwszServerName,
    WCHAR *             pwszPathForServer,
    HRESULT             hr )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE      LogHandle;
    LPWSTR      Strings[4];
    WCHAR       wszClsid[GUIDSTR_MAX];
    WCHAR       wszErrnum[20];
    CToken *    pToken;
    RPC_STATUS  Status;

    // %1 is the error number
    // %2 is the remote machine name
    // %3 is the clsid
    // %4 is the PathForServer

    // Save the error number
    wsprintf(wszErrnum, L"%lu",hr );
    Strings[0] = wszErrnum;

    Strings[1] = pwszServerName;

    // Get the clsid
    wStringFromGUID2( *pClsid, wszClsid, sizeof(wszClsid) );
    Strings[2] = wszClsid;

    Strings[3] = pwszPathForServer;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL, SCM_EVENT_SOURCE );

    if ( ! LogHandle )
        return;

    Status = LookupOrCreateTokenForRPCClient( NULL, TRUE, &pToken, NULL );
    if ( Status != RPC_S_OK )
        return;

    if ( pwszPathForServer )
        {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE,
                     pToken->GetSid(),
                     4,             // 4 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data
        }
    else
        {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_REMOTE_SIDE_ERROR,
                     pToken->GetSid(),
                     3,             // 3 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data
        }

    // clean up the event log handle
    DeregisterEventSource(LogHandle);

    pToken->Release();
}


void
LogComPlusRemoteDisabled(
    DWORD    clsctx,
    REFCLSID Clsid )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE      LogHandle;
    LPWSTR      Strings[1];
    WCHAR       wszClsid[GUIDSTR_MAX];
    CToken *    pToken;
    RPC_STATUS  Status;

    // %1 is the clsid
    // Get the clsid
    wStringFromGUID2( Clsid, wszClsid, sizeof(wszClsid) );
    Strings[0] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL, SCM_EVENT_SOURCE );
    if ( ! LogHandle )
        return;

    Status = LookupOrCreateTokenForRPCClient( NULL, TRUE, &pToken, NULL );
    if ( Status != RPC_S_OK )
        return;

    ReportEvent( LogHandle,
                 EVENTLOG_ERROR_TYPE,
                 0,             // event category
                 EVENT_DCOM_COMPLUS_DISABLED,
                 pToken->GetSid(),
                 1,             // 4 strings passed
                 0,             // 0 bytes of binary
                 (LPCTSTR *)Strings, // array of strings
                 NULL );        // no raw data

    // clean up the event log handle
    DeregisterEventSource(LogHandle);
    pToken->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\execclt.cxx ===
/*************************************************************************
*
* execclt.c
*
* Exec service client.
*
* This allows the starting of a program on any Terminal Server Session under
* the account of the logged on user, or the SYSTEM account for services.
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*
*************************************************************************/

#include "act.hxx"
extern "C" {
#include <execsrv.h>
#include <winsta.h>
}



//
// Forward references
//

PWCHAR
MarshallString(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount,
    BOOL   bMulti = FALSE
    );





/*****************************************************************************
 *
 *  CreateRemoteSessionProcess
 *
 *   Create a process on the given Terminal Server Session
 *
 * ENTRY:
 *   SessionId (input)
 *     SessionId of Session to create process on
 *
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
CreateRemoteSessionProcess(
    ULONG  SessionId,
    HANDLE hSaferToken,
    BOOL   System,
    PWCHAR lpszImageName,
    PWCHAR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvironment,
    LPWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    BOOL   Result;
    HANDLE hPipe = NULL;
    WCHAR  szPipeName[EXECSRVPIPENAMELEN];
    PCHAR  ptr;
    ULONG  Count, AmountWrote, AmountRead;
    DWORD  MyProcId;
    PEXECSRV_REQUEST pReq;
    EXECSRV_REPLY    Rep;
    CHAR Buf[EXECSRV_BUFFER_SIZE];
    ULONG  MaxSize = EXECSRV_BUFFER_SIZE;
    ULONG  ReturnLen;

    if( lpszImageName )
        CairoleDebugOut((DEB_TRACE, "EXECCLIENT: lpszImageName %ws\n",lpszImageName));

    if( lpszCommandLine )
        CairoleDebugOut((DEB_TRACE, "EXECCLIENT: lpszCommandLine %ws\n",lpszCommandLine));

    // Winlogon handles all now. System flag tells it what to do
    Result = WinStationQueryInformation( NULL, SessionId, WinStationExecSrvSystemPipe, szPipeName, sizeof(szPipeName), &ReturnLen );
    if ( !Result ) {
        CairoleDebugOut((DEB_ERROR, "WinStationQueryInformation for the EXECSRV pipe name failed\n"));
        return(FALSE);
    }


    while (TRUE) {

        hPipe = CreateFileW(
                    szPipeName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,    // File share mode
                    NULL, // default security
                    OPEN_EXISTING,
                    0,    // Attrs and flags
                    NULL  // template file handle
                    );

        if( hPipe == INVALID_HANDLE_VALUE ) {

            if (GetLastError() == ERROR_PIPE_BUSY) {

                if (!WaitNamedPipe( szPipeName, 30000 )) { // 30 sec

                    CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Waited too long for pipe name %ws\n", szPipeName));
                    return(FALSE);
                }
            } else {

                CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Could not create pipe name %ws\n", szPipeName));
                return(FALSE);
            }
        } else {

            break;
        }
    }

    /*
     * Get the handle to the current process
     */
    MyProcId = GetCurrentProcessId();

    /*
     * setup the marshalling
     */
    ptr = Buf;
    Count = 0;

    pReq = (PEXECSRV_REQUEST)ptr;
    ptr   += sizeof(EXECSRV_REQUEST);
    Count += sizeof(EXECSRV_REQUEST);

    // set the basic parameters
    pReq->hToken = hSaferToken;
    pReq->System = System;
    pReq->RequestingProcessId = MyProcId;
    pReq->fInheritHandles = fInheritHandles;
    pReq->fdwCreate = fdwCreate;

    // marshall the ImageName string
    if( lpszImageName ) {
        pReq->lpszImageName = MarshallString( lpszImageName, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszImageName = NULL;
    }

    // marshall in the CommandLine string
    if( lpszCommandLine ) {
        pReq->lpszCommandLine = MarshallString( lpszCommandLine, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCommandLine = NULL;
    }

    // marshall in the CurDir string
    if( lpszCurDir ) {
        pReq->lpszCurDir = MarshallString( lpszCurDir, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCurDir = NULL;
    }

    // marshall in the StartupInfo structure
    RtlMoveMemory( &pReq->StartInfo, pStartInfo, sizeof(STARTUPINFO) );

    // Now marshall the strings in STARTUPINFO
    if( pStartInfo->lpDesktop ) {
        pReq->StartInfo.lpDesktop = MarshallString( pStartInfo->lpDesktop, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpDesktop = NULL;
    }

    if( pStartInfo->lpTitle ) {
        pReq->StartInfo.lpTitle = MarshallString( pStartInfo->lpTitle, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpTitle = NULL;
    }

    if( lpvEnvironment ) {
        pReq->lpvEnvironment = MarshallString( (PWCHAR)lpvEnvironment, Buf, MaxSize, &ptr, &Count, TRUE );
    }
    else {
        pReq->lpvEnvironment = NULL;
    }

    //
    // WARNING: This version does not pass the following:
    //
    //  Also saProcess and saThread are ignored right now and use
    //  the users default security on the remote WinStation
    //
    // Set things that are always NULL
    //
    pReq->StartInfo.lpReserved = NULL;  // always NULL

    // now fill in the total count
    pReq->Size = Count;

    /*
     * Now send the buffer out to the server
     */
    Result = WriteFile(
                 hPipe,
                 Buf,
                 Count,
                 &AmountWrote,
                 NULL
                 );

    if( !Result ) {
        CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Error %d sending request\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Now read the reply
     */
    Result = ReadFile(
                 hPipe,
                 &Rep,
                 sizeof(Rep),
                 &AmountRead,
                 NULL
                 );

    if( !Result ) {
        CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Error %d reading reply\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Check the result
     */
    if( !Rep.Result ) {
        CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Error %d in reply\n",Rep.LastError));
        // set the error in the current thread to the returned error
        Result = Rep.Result;
        SetLastError( Rep.LastError );
        goto Cleanup;
    }

    /*
     * We copy the PROCESS_INFO structure from the reply
     * to the caller.
     *
     * The remote site has duplicated the handles into our
     * process space for hProcess and hThread so that they will
     * behave like CreateProcessW()
     */

     RtlMoveMemory( pProcInfo, &Rep.ProcInfo, sizeof( PROCESS_INFORMATION ) );

Cleanup:
    CloseHandle(hPipe);

    CairoleDebugOut((DEB_TRACE, "EXECCLIENT: Result 0x%x\n", Result));

    return(Result);
}

/*****************************************************************************
 *
 *  MarshallString
 *
 *   Marshall in a UNICODE_NULL terminated WCHAR string
 *
 * ENTRY:
 *   pSource (input)
 *     Pointer to source string
 *
 *   pBase (input)
 *     Base buffer pointer for normalizing the string pointer
 *
 *   MaxSize (input)
 *     Maximum buffer size available
 *
 *   ppPtr (input/output)
 *     Pointer to the current context pointer in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 *   pCount (input/output)
 *     Current count of data in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 *   bMulti (optional input)
 *     If TRUE then marshall in a multi UNICODE string. Each string are
 *     UNICODE_NULL terminated and the multi string is terminated with a double
 *     UNICODE_NULL. The default value is FALSE.
 *
 * EXIT:
 *   NULL - Error
 *   !=NULL "normalized" pointer to the string in reference to pBase
 *
 ****************************************************************************/

PWCHAR
MarshallString(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount,
    BOOL   bMulti
    )
{
    SIZE_T Len;
    PCHAR ptr;

    if (bMulti) {

        Len = 0;

        for (PWCHAR pStr = pSource; *pStr; ) {

            SIZE_T StrLen = wcslen( pStr ) + 1; // include the NULL

            Len += StrLen;
            pStr += StrLen;

            // bail out if too long
            if( (*pCount + (Len * sizeof(WCHAR))) > MaxSize ) {
                return( NULL );
            }
        }

        Len++; // include last NULL

    } else {
        Len = wcslen( pSource );
        Len++; // include the NULL
    }

    Len *= sizeof(WCHAR); // convert to bytes

    if( (*pCount + Len) > MaxSize ) {
        return( NULL );
    }

    RtlMoveMemory( *ppPtr, pSource, Len );

    // the normalized ptr is the current count - Sundown: zero-extended value.
    ptr = (PCHAR)ULongToPtr(*pCount);

    *ppPtr += Len;
    *pCount += (ULONG) Len;

    return((PWCHAR)ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\guidtbl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       guidtbl.cxx
//
//  Contents:
//
//--------------------------------------------------------------------------

#include "act.hxx"

CGuidTable::CGuidTable( OUT LONG& Status ) :
    CHashTable( Status )
{
}

CGuidTable::~CGuidTable()
{
}

CGuidTableEntry *
CGuidTable::Lookup(
    IN  CLSID * pClsid )
{
    //
    // GUID structures are not 8-byte aligned.  Therefore the UNALIGNED
    // modifier is required when referencing the contents of a GUID via
    // a pointer to an 8-byte type.
    // 

    CId2Key Key( ((ID UNALIGNED *)pClsid)[0], ((ID UNALIGNED *)pClsid)[1] );

    return (CGuidTableEntry *) CHashTable::Lookup( Key );
}

CGuidTableEntry::CGuidTableEntry(
    IN  CLSID * pClsid
    ) :
    CId2TableElement( ((ID UNALIGNED *)pClsid)[0], ((ID UNALIGNED *)pClsid)[1] )
{
}

CGuidTableEntry::~CGuidTableEntry()
{
}

GUID
CGuidTableEntry::Guid()
{
    GUID    Guid;

    ((ID UNALIGNED *)&Guid)[0] = Id();
    ((ID UNALIGNED *)&Guid)[1] = Id2();

    return Guid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\remactif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      objexif.cxx
//
//  Contents:
//      Entry point for remote activation call to SCM/OR.
//
//  Functions:
//      RemoteActivation
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   _RemoteActivation
//
//  Synopsis:   Entry point for old style activations from off machine.
//              Creates new stype activation properties and forwards to
//              ActivateFromPropertiesPreamble.
//
//----------------------------------------------------------------------------
error_status_t _RemoteActivation(
    handle_t            hRpc,
    ORPCTHIS           *ORPCthis,
    ORPCTHAT           *ORPCthat,
    GUID               *Clsid,
    WCHAR              *pwszObjectName,
    MInterfacePointer  *pObjectStorage,
    DWORD               ClientImpLevel,
    DWORD               Mode,
    DWORD               Interfaces,
    IID                *pIIDs,
    unsigned short      cRequestedProtseqs,
    unsigned short      aRequestedProtseqs[],
    OXID               *pOxid,
    DUALSTRINGARRAY   **ppdsaOxidBindings,
    IPID               *pipidRemUnknown,
    DWORD              *pAuthnHint,
    COMVERSION         *pServerVersion,
    HRESULT            *phr,
    MInterfacePointer **ppInterfaceData,
    HRESULT            *pResults )
{
    RPC_STATUS          sc;
    ACTIVATION_PARAMS   ActParams;
    LOCALTHIS           Localthis;
    WCHAR *             pwszDummy;
    error_status_t rpcerror= RPC_S_OK;
    IID *newIIDs = 0;
    DWORD count;
    DWORD i;
    IComClassInfo* pClassInfo = NULL;
    IInitActivationPropertiesIn* pInitActPropsIn = NULL;

    // check for valid parameters
    if (ORPCthis == NULL          ||
       ORPCthat == NULL      	  ||
       Clsid == NULL              ||
       pOxid == NULL           	  ||
       Interfaces == 0            ||
       pIIDs == NULL              ||
       ppdsaOxidBindings == NULL  ||
       pipidRemUnknown == NULL	  ||
       pAuthnHint == NULL         ||
       pServerVersion == NULL	  ||
       phr == NULL             	  ||
       ppInterfaceData == NULL	  ||
       pResults == NULL)       
    {
    	return E_INVALIDARG;
    }
	
    *ppInterfaceData = NULL;
    *pOxid = 0;
    *ppdsaOxidBindings = NULL;

    memset(&ActParams, 0, sizeof(ActParams));

    /** Old Functionality **/

    Localthis.dwClientThread = 0;
    Localthis.dwFlags        = LOCALF_NONE;
    ORPCthis->flags         |= ORPCF_DYNAMIC_CLOAKING;
    ORPCthat->flags          = 0;
    ORPCthat->extensions     = NULL;

    // Determine what version to use for the returned interface.  Fail
    // if the client wants a version we don't support.
    *pServerVersion = ORPCthis->version;
    *phr = NegotiateDCOMVersion( pServerVersion );
    if (*phr != OR_OK)
    {
        pServerVersion->MajorVersion = COM_MAJOR_VERSION;
        pServerVersion->MinorVersion = COM_MINOR_VERSION;
        return RPC_S_OK; 
    }

    if ( ! s_fEnableDCOM )
    {
        *phr = E_ACCESSDENIED;
        return RPC_S_OK;
    }

    RegisterAuthInfoIfNecessary();

    /** Set up Actparams **/
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = &Localthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = TRUE;
    ActParams.RemoteActivation = TRUE;

    if ( pwszObjectName || pObjectStorage )
        ActParams.MsgType = GETPERSISTENTINSTANCE;
    else
        ActParams.MsgType = (Mode == MODE_GET_CLASS_OBJECT) ?
                            GETCLASSOBJECT : CREATEINSTANCE;

    /** Set up Activation Properties **/
    ActivationPropertiesIn   * pInActivationProperties=NULL;
    ActivationPropertiesOut  * pOutActivationProperties=NULL;
    InstantiationInfo      * pInstantiationInfo=NULL;
    IScmRequestInfo        * pInScmRequestInfo=NULL;
    IInstanceInfo *pInstanceInfo=NULL;
    ISpecialSystemProperties* pISpecialSystemProps = NULL;
    REMOTE_REQUEST_SCM_INFO *pReqInfo;
    IScmReplyInfo        * pScmReplyInfo = NULL;
    REMOTE_REPLY_SCM_INFO *pReply;

    pInActivationProperties = new ActivationPropertiesIn;
    if (NULL == pInActivationProperties)
    {
        *phr = E_OUTOFMEMORY;
        return RPC_S_OK;
    }

    HRESULT hr;

    // Incoming session id from down-level clients is implicitly INVALID_SESSION_ID; make it so
    *phr = pInActivationProperties->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISpecialSystemProps);
    if (FAILED(*phr))
      goto exit_oldremote;

    hr = pISpecialSystemProps->SetSessionId(INVALID_SESSION_ID, FALSE, FALSE);
    ASSERT(hr == S_OK);

    // pISpecialSystemProps will be released just before returning

    pInstantiationInfo = pInActivationProperties->GetInstantiationInfo();
    if (pInstantiationInfo == NULL)
    {
        *phr = E_OUTOFMEMORY;
        goto exit_oldremote;
    }

    *phr = pInActivationProperties->QueryInterface(IID_IScmRequestInfo,
                                                 (LPVOID*)&pInScmRequestInfo);
    if (FAILED(*phr))
        goto exit_oldremote;

    hr = pInstantiationInfo->SetClsid(*Clsid);
    ASSERT(hr == S_OK);

    hr = pInstantiationInfo->SetClsctx(CLSCTX_LOCAL_SERVER);
    ASSERT(hr == S_OK);

    hr = pInstantiationInfo->SetClientCOMVersion(ORPCthis->version);
    ASSERT(hr == S_OK);

    *phr = pInActivationProperties->AddRequestedIIDs(Interfaces,pIIDs);
    if ( FAILED(*phr) )
        goto exit_oldremote;

    if (ActParams.MsgType == GETPERSISTENTINSTANCE)
    {
        *phr = pInActivationProperties->QueryInterface(IID_IInstanceInfo,
                                  (LPVOID*)&pInstanceInfo);
        if (FAILED(*phr))
            goto exit_oldremote;

        if ( pwszObjectName )
        {
            WCHAR *oldName = pwszObjectName;
            *phr = GetServerPath( pwszObjectName, &pwszObjectName);
            if ( FAILED(*phr) )
                goto exit_oldremote;

            *phr = pInstanceInfo->SetFile(pwszObjectName, Mode);
            if ( FAILED(*phr) )
                goto exit_oldremote;
            pInstanceInfo->GetFile(&ActParams.pwszPath, &ActParams.Mode);
            if (pwszObjectName != oldName)
                PrivMemFree(pwszObjectName);
        }
        else
        {
            ActParams.pwszPath = 0;
        }

        if (pObjectStorage)
        {
            MInterfacePointer* newStorage;
            newStorage = (MInterfacePointer*)
                            AllocateAndCopy((InterfaceData*)pObjectStorage);
            if (newStorage)
            {
                *phr = pInstanceInfo->SetStorageIFD(newStorage);
                ActParams.pIFDStorage = pObjectStorage;
            }
            else
                *phr = E_OUTOFMEMORY;
        }

        if ( FAILED(*phr) )
            goto exit_oldremote;
    }


    pReqInfo = (REMOTE_REQUEST_SCM_INFO *)MIDL_user_allocate(sizeof(REMOTE_REQUEST_SCM_INFO));
    if (pReqInfo)
    {
        memset(pReqInfo, 0, sizeof(REMOTE_REQUEST_SCM_INFO));
        pReqInfo->ClientImpLevel = ClientImpLevel;
        if (pReqInfo->cRequestedProtseqs = cRequestedProtseqs)
        {
            pReqInfo->pRequestedProtseqs = (unsigned short*)
                                    MIDL_user_allocate(sizeof(unsigned short) *
                                                            cRequestedProtseqs);
            if (pReqInfo->pRequestedProtseqs == NULL)
            {
                *phr = E_OUTOFMEMORY;
                MIDL_user_free(pReqInfo);
            }
        }
    }
    else
        *phr = E_OUTOFMEMORY;

    if ( FAILED(*phr) )
        goto exit_oldremote;

    for (i=0; i<cRequestedProtseqs; i++)
        pReqInfo->pRequestedProtseqs[i] = aRequestedProtseqs[i];

    pInScmRequestInfo->SetRemoteRequestInfo(pReqInfo);

    //Set up for marshalling
    pInActivationProperties->SetDestCtx(MSHCTX_DIFFERENTMACHINE);
    
    //
    // Get/set class info for the requested class;  ActivateFromPropertiesPreamble 
    // expects that actpropsin will already have had this done.
    //
    *phr = GetClassInfoFromClsid(*Clsid, &pClassInfo);
    if (FAILED(*phr))
      goto exit_oldremote;

    *phr = pInActivationProperties->QueryInterface(IID_IInitActivationPropertiesIn, (void**)&pInitActPropsIn);
    if (FAILED(*phr))
      goto exit_oldremote;
    
    *phr = pInitActPropsIn->SetClassInfo(pClassInfo);
    if (FAILED(*phr))
      goto exit_oldremote;
   
    //Mark properties object as having been delegated from by
    //client which is implicitly true even though it's created here
    //for first time
    pInActivationProperties->SetDelegated();

    //Delegate through activation properties
    IActivationPropertiesOut *pActPropsOut;
    *phr = ActivateFromPropertiesPreamble(pInActivationProperties,
                                          &pActPropsOut,
                                          &ActParams);


    pOutActivationProperties = ActParams.pActPropsOut;
    if ((*phr != S_OK) || (pOutActivationProperties == NULL))
        goto exit_oldremote;

    *phr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                                 (LPVOID*)&pScmReplyInfo);
    if ( FAILED(*phr) )
        goto exit_oldremote;

    pScmReplyInfo->GetRemoteReplyInfo(&pReply);

    *pOxid = pReply->Oxid;
    *ppdsaOxidBindings = pReply->pdsaOxidBindings;
    pReply->pdsaOxidBindings = NULL;        // so it won't be freed twice

    *pipidRemUnknown = pReply->ipidRemUnknown;
    *pAuthnHint = pReply->authnHint;

    // For custom marshalled interfaces the reply is not set.  Don't
    // clear the version number in that case.
    if (pReply->serverVersion.MajorVersion != 0)
        *pServerVersion = pReply->serverVersion;

    *phr = pOutActivationProperties->GetMarshalledResults(&count,
                                                          &newIIDs,
                                                          &pResults,
                                                          &ppInterfaceData);

//  ********************
//  ** Begin fix for NT Bug 312637
//  ** April 1, 1999 -- stevesw
//  **
//  ** GetMarshalledResults puts a pointer to an empty MInterfacePointer
//  ** in the ppInterfaceData array. NT4 expects the values to be NULL.
//  ** Here we translate from NT5 to NT4 by freeing and nulling out these
//  ** array values.
//  **

    for (i = 0; i < count; i++ )
    {
        if ( !SUCCEEDED(pResults[i]) ||
             ppInterfaceData[i]->ulCntData < 2*sizeof(ULONG) )
        {
            ActMemFree (ppInterfaceData[i]);
            ppInterfaceData[i] = NULL;
        }
    }

//  **
//  ** End fix for NT Bug 312637
//  ********************

    pScmReplyInfo->Release();
    count = pOutActivationProperties->Release();
    ASSERT(count == 0);



exit_oldremote:
    if (pInstanceInfo)
        pInstanceInfo->Release();
    if (pClassInfo)
        pClassInfo->Release();
    if (pInitActPropsIn)
        pInitActPropsIn->Release();

    if (pISpecialSystemProps)
    {
      pISpecialSystemProps->Release();
    }

    if (pInScmRequestInfo)
    {
        count = pInScmRequestInfo->Release();
        ASSERT(count == 1);
    }

    if (pInActivationProperties)
    {
        count = pInActivationProperties->Release();
        ASSERT(count == 0);
    }

    return rpcerror;
}

//+---------------------------------------------------------------------------
//
//  Function:    GetServerPath
//
//  Synopsis:    Computes file name of executable with drive name instead of
//               UNC name.
//
//  Description: This is to work around limitations in NT's current
//               security/rdr.  If we get a UNC path to this machine,
//               convert it into a drive based path.  A server activated as
//               the client can not open any UNC path file, even if local,
//               so we make it drive based.
//
//               On Chicago, we neither have this problem nor do we have
//               the NetGetShareInfo entrypoint in the relevant DLL
//
//----------------------------------------------------------------------------
HRESULT GetServerPath(
    WCHAR *     pwszPath,
    WCHAR **    pwszServerPath )
{
    WCHAR * pwszFinalPath;

    ASSERT(pwszPath != NULL);
    ASSERT(pwszServerPath != NULL);
    	
    pwszFinalPath = pwszPath;
    *pwszServerPath = pwszPath;

    if ( (pwszPath[0] == L'\\') && (pwszPath[1] == L'\\') )
    {
        WCHAR           wszMachineName[MAX_COMPUTERNAME_LENGTH+1];
        WCHAR *         pwszShareName;
        WCHAR *         pwszShareEnd;
        PSHARE_INFO_2   pShareInfo;
        NET_API_STATUS  Status;
        HRESULT         hr;

        // It's already UNC so this had better succeed.
        hr = GetMachineName(
                    pwszPath,
                    wszMachineName
#ifdef DFSACTIVATION
                    ,FALSE
#endif
                    );

        if ( FAILED(hr) )
            return hr;

        if ( gpMachineName->Compare( wszMachineName ) )
        {
            pwszShareName = pwszPath + 2;
            while ( *pwszShareName++ != L'\\' )
                ;

            pwszShareEnd = pwszShareName;
            while ( *pwszShareEnd != L'\\' )
                pwszShareEnd++;

            // This is OK, we're just munching on the string the RPC stub passed us.
            *pwszShareEnd = 0;

            pShareInfo = 0;
            Status = NetShareGetInfo(
                            NULL,
                            pwszShareName,
                            2,
                            (LPBYTE *)&pShareInfo );

            if ( Status != STATUS_SUCCESS )
                return (ULONG) CO_E_BAD_PATH;

            pwszFinalPath = (WCHAR *) PrivMemAlloc( sizeof(WCHAR) * (MAX_PATH+1) );

            if ( ! pwszFinalPath )
            {
                LocalFree( pShareInfo );
                return (ULONG) E_OUTOFMEMORY;
            }

            lstrcpyW( pwszFinalPath, pShareInfo->shi2_path );
            *pwszShareEnd = L'\\';
            lstrcatW( pwszFinalPath, pwszShareEnd );

            //
            // Netapi32.dll midl_user_allocate calls LocalAlloc, so use
            // LocalFree to free up the stuff the stub allocated.
            //
            LocalFree( pShareInfo );
        }
    }

    *pwszServerPath = pwszFinalPath;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\macif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  activate.cxx
//
//  Main dcom activation service routines.
//
//--------------------------------------------------------------------------

#include "act.hxx"

HRESULT MakeProcessActive(CProcess *pProcess);
HRESULT ProcessInitializationFinished(CProcess *pProcess);


HRESULT ProcessActivatorStarted( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    IN  ProcessActivatorToken *pActToken,
    OUT error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat || !pActToken)
        return E_INVALIDARG;

    *prpcstat = 0;

    HRESULT hr = S_OK;
    CServerTableEntry *pProcessEntry = NULL;
    CAppidData *pAppidData = NULL;
    ScmProcessReg *pScmProcessReg = NULL;
    DWORD RegistrationToken = 0;
    BOOL fCallerOK = FALSE;
    
    // Lookup appid info
    hr = LookupAppidData(
                pActToken->ProcessGUID,
                pProcess->GetToken(),
                &pAppidData );
    if (FAILED(hr))
    {
        goto exit;
    }

    ASSERT(pAppidData && "LookupAppidData returned NULL AppidData");

    //
    // Check that the caller is allowed to register this CLSID.
    //
    fCallerOK = pAppidData->CertifyServer(pProcess);
    if (!fCallerOK)
    {
        hr = CO_E_WRONG_SERVER_IDENTITY;
        goto exit;
    }

    pProcessEntry = gpProcessTable->GetOrCreate( pActToken->ProcessGUID );
    if (!pProcessEntry)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pScmProcessReg = new ScmProcessReg;
    if (!pScmProcessReg)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    pScmProcessReg->TimeOfLastPing = GetTickCount();
    pScmProcessReg->ProcessGUID = pActToken->ProcessGUID;
    pScmProcessReg->ReadinessStatus = SERVERSTATE_SUSPENDED;
    pProcess->SetProcessReg(pScmProcessReg);

    hr = pProcessEntry->RegisterServer(
                                pProcess,
                                pActToken->ActivatorIPID,
                                NULL,
                                pAppidData,
                                SERVERSTATE_SUSPENDED,
                                &RegistrationToken );

    pScmProcessReg->RegistrationToken = RegistrationToken;

exit:

    if (pProcessEntry) pProcessEntry->Release();
    if (pAppidData) delete pAppidData;

    return hr;
}

HRESULT ProcessActivatorInitializing( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    OUT error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;

    ScmProcessReg *pScmProcessReg = pProcess->GetProcessReg();
    ASSERT(pScmProcessReg);
    if ( ! pScmProcessReg )
      return E_UNEXPECTED;

    pScmProcessReg->TimeOfLastPing = GetTickCount();

    return S_OK;
}

HRESULT ProcessActivatorReady( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    OUT error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;

    HRESULT hr;
    if (pProcess->IsInitializing())
    {
        // Process was running user initializaiton code, 
        // so signal that we've finished with that.
        hr = ProcessInitializationFinished(pProcess);
    }
    else
    {
        // Normal case-- simply mark the process as 
        // ready-to-go.
        hr = MakeProcessActive(pProcess);
    }

    return hr;
}

HRESULT ProcessActivatorStopped( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    OUT error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;

    ScmProcessReg *pScmProcessReg = pProcess->RemoveProcessReg();
    ASSERT(pScmProcessReg);
    if (!pScmProcessReg )
      return E_UNEXPECTED;

    HRESULT hr = S_OK;

    CServerTableEntry *pProcessEntry 
                        = gpProcessTable->Lookup(pScmProcessReg->ProcessGUID);

    if (!pProcessEntry)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pProcessEntry->RevokeServer(pScmProcessReg);

exit:

    if (pScmProcessReg) delete pScmProcessReg;
    if (pProcessEntry) pProcessEntry->Release();

    return hr;
}


//
//  ProcessActivatorPaused
//
//  A process activator is telling us to turn on the "paused" bit
//  for its process.
//
HRESULT ProcessActivatorPaused(
        IN handle_t                hRpc,
        IN PHPROCESS               phProcess,
        OUT error_status_t        * prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;

    pProcess->Pause();

    return S_OK;
}

//
//  ProcessActivatorResumed
//
//  A process activator is telling us to turn off the "paused" bit
//  for its process.
//
HRESULT ProcessActivatorResumed(
        IN handle_t                hRpc,
        IN PHPROCESS               phProcess,
        OUT error_status_t        * prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;

    pProcess->Resume();

    return S_OK;
}


//
//  ProcessActivatorUserInitializing
//
//  A process activator is telling us that it's running long-running
//  code and that we might have to wait for a long time on it.
//
HRESULT ProcessActivatorUserInitializing(
        IN handle_t                hRpc,
        IN PHPROCESS               phProcess,
        OUT error_status_t        * prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;
    
    //
    // Make this process active, but mark it as initializing so that
    // attempts to call into it will block...
    //
    pProcess->BeginInit();
    HRESULT hr = MakeProcessActive(pProcess);

    return hr;
}

HRESULT MakeProcessActive(
    IN CProcess      *pProcess
)
{
    CServerTableEntry *pProcessEntry = NULL;
    CAppidData        *pAppidData = NULL;
    CNamedObject*      pRegisterEvent = NULL;
    HRESULT            hr = S_OK;

    ScmProcessReg *pScmProcessReg = pProcess->GetProcessReg();
    ASSERT(pScmProcessReg);
    if (!pScmProcessReg)
        return E_UNEXPECTED;    
    
    pProcessEntry = gpProcessTable->Lookup(pScmProcessReg->ProcessGUID);
    if (!pProcessEntry)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pProcessEntry->UnsuspendServer(pScmProcessReg->RegistrationToken);

    // Lookup an appiddata, from which we will get the register event
    hr = LookupAppidData(pScmProcessReg->ProcessGUID,
                         pProcess->GetToken(),
                         &pAppidData);
    if (FAILED(hr))
        goto exit;

    ASSERT(pAppidData && "LookupAppidData returned NULL AppidData");

    pRegisterEvent = pAppidData->ServerRegisterEvent();
    if (pRegisterEvent)
    {
        SetEvent( pRegisterEvent->Handle() );
        pRegisterEvent->Release();        
        pProcess->SetProcessReadyState(SERVERSTATE_READY);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    
    if ( FAILED(hr) && pProcess && pProcessEntry )
        pProcessEntry->RevokeServer( pScmProcessReg );

    if (pProcessEntry) pProcessEntry->Release();
    if (pAppidData) delete pAppidData;

    return hr;
}

HRESULT ProcessInitializationFinished(
    IN CProcess *pProcess
)
{
    CAppidData *pAppidData = NULL;

    ScmProcessReg *pScmProcessReg = pProcess->GetProcessReg();
    ASSERT(pScmProcessReg);
    if ( !pScmProcessReg )
        return E_UNEXPECTED;

    // Initialization is finished... set the initialization event...
    HRESULT hr = LookupAppidData(pScmProcessReg->ProcessGUID,
                                 pProcess->GetToken(),
                                 &pAppidData );
    if (FAILED(hr)) 
        goto exit;
    
    // Signal the initialized event.
    CNamedObject* pInitializedEvent = pAppidData->ServerInitializedEvent();
    if (!pInitializedEvent)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // The order of the following is important:
    //
    // Clear the initializing flag...
    pProcess->EndInit();
    
    // Set the initialized event...
    SetEvent(pInitializedEvent->Handle());
    pInitializedEvent->Release();
    
    hr = S_OK;
    
exit:
    delete pAppidData;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\remsysif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      objexif.cxx
//
//  Contents:
//      Entry point for remote activation call to SCM/OR.
//
//  Functions:
//      RemoteGetClassObject
//      RemoteCreateInstance
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"

//-------------------------------------------------------------------------
//
//  Function:   _RemoteGetClassObject
//
//  Synopsis:   Entry point for 5.6 get class object activations.  Forwards to
//              PerformScmStage.
//
//-------------------------------------------------------------------------

HRESULT _RemoteGetClassObject(
    handle_t            hRpc,
    ORPCTHIS           *ORPCthis,
    ORPCTHAT           *ORPCthat,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    RPC_STATUS          sc;
    LOCALTHIS           Localthis;
    HRESULT             hr;

    if (ORPCthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;
    
    Localthis.dwClientThread = 0;
    Localthis.dwFlags        = LOCALF_NONE;
    ORPCthis->flags         |= ORPCF_DYNAMIC_CLOAKING;
    ORPCthat->flags          = 0;
    ORPCthat->extensions     = NULL;

    if ( ! s_fEnableDCOM )
    {
        return E_ACCESSDENIED;
    }

    // Determine what version to use for the returned interface.  Fail
    // if the client wants a version we don't support.
    hr = NegotiateDCOMVersion( &ORPCthis->version );
    if (hr != OR_OK)
    {
        return hr;
    }

    RegisterAuthInfoIfNecessary();

    ACTIVATION_PARAMS       ActParams;
    memset(&ActParams, 0, sizeof(ActParams));

    ActParams.MsgType = GETCLASSOBJECT;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = &Localthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;
    ActParams.RemoteActivation = TRUE;


    return PerformScmStage(SERVER_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}


//-------------------------------------------------------------------------
//
//  Function:   _RemoteGetCreateInstance
//
//  Synopsis:   Entry point for 5.6 create instance activations.  Forwards to
//              PerformScmStage.
//
//-------------------------------------------------------------------------

HRESULT _RemoteCreateInstance(
    handle_t            hRpc,
    ORPCTHIS           *ORPCthis,
    ORPCTHAT           *ORPCthat,
    IN  MInterfacePointer   * pUnk,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    RPC_STATUS          sc;
    LOCALTHIS           Localthis;
    HRESULT             hr;

    if (ORPCthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;
    
    Localthis.dwClientThread = 0;
    Localthis.dwFlags        = LOCALF_NONE;
    ORPCthis->flags         |= ORPCF_DYNAMIC_CLOAKING;
    ORPCthat->flags          = 0;
    ORPCthat->extensions     = NULL;

    if ( ! s_fEnableDCOM )
    {
        return E_ACCESSDENIED;
    }

    // Determine what version to use for the returned interface.  Fail
    // if the client wants a version we don't support.
    hr = NegotiateDCOMVersion( &ORPCthis->version );
    if (hr != OR_OK)
    {
        return hr;
    }

    RegisterAuthInfoIfNecessary();

    ACTIVATION_PARAMS       ActParams;
    memset(&ActParams, 0, sizeof(ActParams));

    ActParams.MsgType = CREATEINSTANCE;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = &Localthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;
    ActParams.RemoteActivation = TRUE;

    return PerformScmStage(SERVER_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}

//-------------------------------------------------------------------------
//
//  Function:   _DummyQueryInterfaceIRemoteSCMActivator
//
//  Synopsis:   Unused function required by linker.  This function exists
//              to make the activation interface wire compatible with a
//              COM interface.
//
//-------------------------------------------------------------------------

HRESULT _DummyQueryInterfaceIRemoteSCMActivator(handle_t rpc,
                                                ORPCTHIS *orpcthis,
                                                ORPCTHAT *orpcthat,
                                                DWORD dummy )
{
    return E_NOTIMPL;
}

//-------------------------------------------------------------------------
//
//  Function:   _DummyAddRefIRemoteSCMActivator
//
//  Synopsis:   Unused function required by linker.  This function exists
//              to make the activation interface wire compatible with a
//              COM interface.
//
//-------------------------------------------------------------------------

HRESULT _DummyAddRefIRemoteSCMActivator(handle_t rpc,
                                        ORPCTHIS *orpcthis,
                                        ORPCTHAT *orpcthat,
                                        DWORD dummy )
{
    return E_NOTIMPL;
}

//-------------------------------------------------------------------------
//
//  Function:   _DummyReleaseIRemoteSCMActivator
//
//  Synopsis:   Unused function required by linker.  This function exists
//              to make the activation interface wire compatible with a
//              COM interface.
//
//-------------------------------------------------------------------------

HRESULT _DummyReleaseIRemoteSCMActivator(handle_t rpc,
                                         ORPCTHIS *orpcthis,
                                         ORPCTHAT *orpcthat,
                                         DWORD dummy )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\rotif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rotif.cxx
//
//  Contents:   Initialization for SCM ROT and RPC interface
//
//  Functions:  InitScmRot
//              IrotRegister
//              IrotRevoke
//              IrotIsRunning
//              IrotGetObject
//              IrotNoteChangeTime
//              IrotGetTimeOfLastChange
//              IrotEnumRunning
//              GetObjectFromRot
//
//  History:    24-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

CScmRot *gpscmrot = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   InitScmRot
//
//  Synopsis:   Initialize ROT Directory for the SCM
//              NOTE:  if InitRotDir is ever called by any process other than the
//              SCM then the RpcServerRegisterIf may fail with RPC_S_TYPE_ALREADY_REGISTERED
//              in some unusal cases.  Change the error checking code to ignore that error.
//
//  Returns:    S_OK - Created ROT directory successfully
//
//  History:    17-Nov-93 Ricksa    Created
//              26-Jul-94 AndyH     Added warning above while bug hunting.
//              25-Jan-95 Ricksa    New rot
//
//  Notes:      This routine is only in non-chicago builds
//
//--------------------------------------------------------------------------
HRESULT InitScmRot()
{
    CairoleDebugOut((DEB_ROT, "%p _IN InitScmRot \n", NULL));

    HRESULT hr = E_OUTOFMEMORY;

    gpscmrot = new CScmRot(hr, ROTHINT_NAME);

    if (SUCCEEDED(hr))
    {
        RPC_STATUS status;
        
        status = RpcServerRegisterIfEx(IROT_ServerIfHandle, 
                              NULL,
                              NULL,
                              0,
                              RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                              LocalInterfaceOnlySecCallback);
        ASSERT((status == RPC_S_OK) && "RpcServerRegisterIf for IROT failed!");
        if (status == RPC_S_OK)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(status);
            delete gpscmrot;
            gpscmrot = NULL;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT InitScmRot ( %lx )\n", NULL, hr));

    return  hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IrotRegister
//
//  Synopsis:   Main entry point for registering an item in the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [phProcess] - context handle (CProcess)
//              [pmkeqbuf] - moniker equality buffer
//              [pifdObject] - marshaled object
//              [pifdObjectName] - marshaled moniker
//              [pfiletime] - time of last change
//              [dwProcessID] - process ID for object
//              [psrkRegister] - SCM registration ID
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      The purpose of this routine is really just to make the
//              code more readable.
//
//--------------------------------------------------------------------------
extern "C" HRESULT IrotRegister(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmkeqbuf,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    WCHAR *pwszServerExe,
    SCMREGKEY *psrkRegister,
    error_status_t *prpcstat)
{    
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    // Ole32 always sends us a desktop.  Since NULL is a reserved value
    // internally, don't let anybody send us such a value from outside.
    if (!pwszWinstaDesktop)
        return E_ACCESSDENIED;

    VDATEHEAP();
    
    if (!prpcstat)
        return E_ACCESSDENIED;
		
    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotRegister\n", NULL));
    DbgPrintMnkEqBuf("_IN Moinker Compare Buffer:", pmkeqbuf);
    DbgPrintIFD("_IN Object Interface Data:", pifdObject);
    DbgPrintIFD("_IN Moniker Interface Data:", pifdObject);
    DbgPrintFileTime("_IN FileTime: ", pfiletime);
    CairoleDebugOut((DEB_SCM, "_IN Process ID: %lX\n", dwProcessID));

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->Register(pProcess,
                                pwszWinstaDesktop,
                                pmkeqbuf,
                                pifdObject,
                                pifdObjectName,
                                pfiletime,
                                dwProcessID,
                                pwszServerExe,
                                psrkRegister);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotRegister\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult %lX\n", hr));

    if (SUCCEEDED(hr))
    {
        DbgPrintScmRegKey("OUT Register Key: ", psrkRegister);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IrotRevoke
//
//  Synopsis:   Main entry point for revoking an item from the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [phProcess] - context handle (CProcess) 
//              [psrkRegister] - SCM registration ID
//              [ppifdObject] - returned marshaled object
//              [ppifdObjectName] - returned marshaled moniker
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      The purpose of this routine is really just to make the
//              code more readable.
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotRevoke(
    handle_t hRpc,
    PHPROCESS phProcess,
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject,
    InterfaceData **ppifdName,
    error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    VDATEHEAP();

    if (!prpcstat)
        return E_ACCESSDENIED;

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotRevoke\n", NULL));
    DbgPrintScmRegKey("_IN Revoke Key: ", psrkRegister);
    CairoleDebugOut((DEB_SCM, "_IN Object Interface Data Ptr: %lx\n",
                     ppifdObject));
    CairoleDebugOut((DEB_SCM, "_IN Moniker Interface Data Ptr: %lx\n",
                     ppifdName));
    
#endif // DBG == 1    

    HRESULT hr = E_OUTOFMEMORY;
    if (gpscmrot != NULL)
    {
        hr = gpscmrot->Revoke(pProcess, psrkRegister, ppifdObject, ppifdName);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotRevoke\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

    if (*ppifdObject != NULL)
    {
        DbgPrintIFD("OUT Object Interface Data:", *ppifdObject);
    }

    if (*ppifdName != NULL)
    {
        DbgPrintIFD("OUT Moniker Interface Data:", *ppifdName);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotIsRunning
//
//  Synopsis:   Main entry point for determining if an entry is in the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [pmkeqbuf] - moniker equality buffer
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      The purpose of this routine is really just to make the
//              code more readable.
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotIsRunning(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmkeqbuf,
    error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    VDATEHEAP();

    if (!prpcstat)
        return E_ACCESSDENIED;

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotIsRunning\n", NULL));
    DbgPrintMnkEqBuf("_IN Moniker Compare Buffer:", pmkeqbuf);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->IsRunning(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                pmkeqbuf);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotIsRunning\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotGetObject
//
//  Synopsis:   Main entry point for getting an object from the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [dwProcessID] - process id for object
//              [pmkeqbuf] - moniker equality buffer
//              [psrkRegister] - Registration ID of returned Object
//              [ppifdObject] - returned marshaled object
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotGetObject(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    DWORD dwProcessID,
    MNKEQBUF *pmkeqbuf,
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject,
    error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    VDATEHEAP();

    if (!prpcstat)
        return E_ACCESSDENIED;

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotGetObject\n", NULL));
    CairoleDebugOut((DEB_SCM, "_IN Process ID: %lX\n", dwProcessID));
    DbgPrintMnkEqBuf("_IN Moniker Compare Buffer:", pmkeqbuf);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->GetObject(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                dwProcessID,
                pmkeqbuf,
                psrkRegister,
                ppifdObject);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotGetObject\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

    if (SUCCEEDED(hr))
    {
        DbgPrintScmRegKey("OUT Register Key: ", psrkRegister);
        DbgPrintIFD("OUT Object Interface Data:", *ppifdObject);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotNoteChangeTime
//
//  Synopsis:   Main entry point for setting the change time of an object
//              int the ROT.
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [psrkRegister] - Registration ID of Object to update
//              [pfiletime] - new change time for the object
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotNoteChangeTime(
    handle_t hRpc,
    PHPROCESS phProcess,    
    SCMREGKEY *psrkRegister,
    FILETIME *pfiletime,
    error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    VDATEHEAP();

    if (!prpcstat)
        return E_ACCESSDENIED;

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotNoteChangeTime\n", NULL));
    DbgPrintScmRegKey("_IN Revoke Key: ", psrkRegister);
    DbgPrintFileTime("_IN FileTime: ", pfiletime);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->NoteChangeTime(psrkRegister, pfiletime);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotRevoke\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotGetTimeOfLastChange
//
//  Synopsis:   Main entry point for getting the change time of an object
//              int the ROT.
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [pmkeqbuf] - Moniker for object
//              [pfiletime] - new change time for the object
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotGetTimeOfLastChange(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmkeqbuf,
    FILETIME *pfiletime,
    error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    VDATEHEAP();

    if (!prpcstat)
        return E_ACCESSDENIED;

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotGetTimeOfLastChange\n", NULL));
    DbgPrintMnkEqBuf("_IN Moniker Compare Buffer:", pmkeqbuf);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->GetTimeOfLastChange(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                pmkeqbuf,
                pfiletime);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotGetTimeOfLastChange\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));
    DbgPrintFileTime("OUT FileTime: ", pfiletime);

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotEnumRunning
//
//  Synopsis:   Main entry point for getting all monikers to running objects
//              int the ROT.
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [ppMKIFList] - list of marshaled monikers to running objects
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotEnumRunning(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MkInterfaceList **ppMkIFList,
    error_status_t *prpcstat)
{
    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
    	return E_ACCESSDENIED;

    VDATEHEAP();

    if (!prpcstat)
        return E_ACCESSDENIED;

    *prpcstat = RPC_S_OK;

    CairoleDebugOut((DEB_SCM, "%p _IN IrotEnumRunning\n", NULL));

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->EnumRunning(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                ppMkIFList);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotEnumRunning\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

    if (SUCCEEDED(hr))
    {
        DbgPrintMkIfList("OUT Moniker IF List: ", ppMkIFList);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetObjectFromRot
//
//  Synopsis:   Helper for binding to locate an object in the ROT
//
//  Arguments:  [pwszPath] - path for bind
//              [ppifdObject] - marshaled output buffer
//
//  Returns:    NOERROR
//
//  Algorithm:  Get the ROT. Create a moniker comparison buffer for searching
//              the ROT. Then try to get the object out of the ROT.
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT GetObjectFromRot(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    WCHAR *pwszPath,
    InterfaceData **ppifdObject)
{
    VDATEHEAP();

    CairoleDebugOut((DEB_ROT, "%p _IN GetObjectFromRot "
        "( %p , %p )\n", NULL, pwszPath, ppifdObject));

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        // Create a moniker equality buffer from path
        CTmpMkEqBuf tmeb;

        hr = CreateFileMonikerComparisonBuffer(pwszPath, tmeb.GetBuf(),
            tmeb.GetSize(), tmeb.GetSizeAddr());

        if (hr == NOERROR)
        {
            // SCMREGKEY which we won't really use
            SCMREGKEY srkRegister;

            hr = gpscmrot->GetObject(
                    pToken,
                    pwszWinstaDesktop,
                    0,
                    tmeb.GetMkEqBuf(),
                    &srkRegister,
                    ppifdObject );
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetObjectFromRot ( %lx ) [ %p ]\n",
        NULL, hr, *ppifdObject));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\launch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       launch.cxx
//
//  Contents:
//
//  History:    ?-??-??   ???       Created
//              6-17-99   a-sergiv  Added event log filtering
//
//--------------------------------------------------------------------------

#include "act.hxx"

#include <winbasep.h> // For CreateProcessInternalW

extern "C" {
#include <execsrv.h>
}
#include "execclt.hxx"

const ULONG MAX_SERVICE_ARGS = 16;

const WCHAR REGEVENT_PREFIX[] = L"RPCSS_REGEVENT:";
const DWORD REGEVENT_PREFIX_STRLEN = sizeof(REGEVENT_PREFIX) / sizeof(WCHAR) - 1;

const WCHAR INITEVENT_PREFIX[] = L"RPCSS_INITEVENT:";
const DWORD INITEVENT_PREFIX_STRLEN = sizeof(INITEVENT_PREFIX) / sizeof(WCHAR) - 1;


HRESULT
CClsidData::GetAAASaferToken(
    IN  CToken *pClientToken,
    OUT HANDLE *pTokenOut
)
/*++
 
Routine Description:
 
    Get the token that will be used in an Activate As Activator
    launch.  This token is the more restricted of the incoming
    token and the configured safer level.
 
Arguments:
 
    pClientToken - token of the user doing the activation

    pTokenOut - out parameter that will recieve the handle to use
                in the activation.

Return Value:
 
    S_OK: Everything went fine.  The caller owns a reference on
          pTokenOut and must close it.
    S_FALSE: Everything went fine.  The caller does not own a 
          reference on pToken out and does not need to close it.

    Anything else: An error occured.
 
--*/
{
    HANDLE  hSaferToken = NULL;
    HRESULT hr = S_OK;
    BOOL    bStatus = TRUE;

    *pTokenOut = NULL;

    ASSERT(SaferLevel() && "Called GetAAASaferToken with SAFER disabled!");
    if (!SaferLevel()) return E_UNEXPECTED;

    // Get the safer token for this configuration.
    bStatus = SaferComputeTokenFromLevel(SaferLevel(),
                                         pClientToken->GetToken(),
                                         &hSaferToken,
                                         0,
                                         NULL);
    if (bStatus)
    {
        hr = pClientToken->CompareSaferLevels(hSaferToken);

        if (hr == S_OK)
        {
            CloseHandle(hSaferToken);
            hSaferToken = pClientToken->GetToken(); 

            // Shared reference, return S_FALSE.
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    *pTokenOut = hSaferToken;            

    return hr;
}
                    
HRESULT
CClsidData::LaunchActivatorServer(
    IN  CToken *    pClientToken,
    IN  WCHAR *     pEnvBlock,
    IN  DWORD       EnvBlockLength,
    IN  BOOL        fIsRemoteActivation,
    IN  BOOL        fClientImpersonating,
    IN  WCHAR*      pwszWinstaDesktop,
    IN  DWORD       clsctx,
    OUT HANDLE *    phProcess,
    OUT DWORD *     pdwProcessId
    )
{    
    WCHAR *                 pwszCommandLine;
    WCHAR *                 pFinalEnvBlock;
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInfo;
    SECURITY_ATTRIBUTES     saProcess;
    PSECURITY_DESCRIPTOR    psdNewProcessSD;
    HRESULT                 hr;
    DWORD                   CreateFlags;
    BOOL                    bStatus = FALSE;
    ULONG                   SessionId = 0;
    HANDLE                  hSaferToken = NULL;
    BOOL                    bCloseSaferToken = TRUE;

    *phProcess = NULL;
    *pdwProcessId = 0;

    if ( ! pClientToken )
        return (E_ACCESSDENIED);

    pFinalEnvBlock = NULL;
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.lpReserved = NULL;

    // Choose desktop for new server:
    //   client remote  ->  system chooses desktop
    //   client local, not impersonating ->  we pick client's desktop
    //   client local, impersonating ->  system chooses desktop
    StartupInfo.lpDesktop = (fIsRemoteActivation || fClientImpersonating) ? L"" : pwszWinstaDesktop;
    StartupInfo.lpTitle = (SERVERTYPE_SURROGATE == _ServerType) ? NULL : _pwszServer;
    StartupInfo.dwX = 40;
    StartupInfo.dwY = 40;
    StartupInfo.dwXSize = 80;
    StartupInfo.dwYSize = 40;
    StartupInfo.dwFlags = 0;
    StartupInfo.wShowWindow = SW_SHOWNORMAL;
    StartupInfo.cbReserved2 = 0;
    StartupInfo.lpReserved2 = NULL;

    ProcessInfo.hThread = 0;
    ProcessInfo.hProcess = 0;
    ProcessInfo.dwProcessId = 0;

    hr = GetLaunchCommandLine( &pwszCommandLine );
    if ( hr != S_OK )
        return (hr);

    if ( pEnvBlock )
    {
        hr = AddAppPathsToEnv( pEnvBlock, EnvBlockLength, &pFinalEnvBlock );
        if ( hr != S_OK )
        {
            PrivMemFree( pwszCommandLine );
            return (hr);
        }
    }

    CreateFlags = CREATE_NEW_CONSOLE;

    if ( pFinalEnvBlock )
        CreateFlags |= CREATE_UNICODE_ENVIRONMENT;

    CAccessInfo AccessInfo( pClientToken->GetSid() );

    //
    // Apply configured safer restrictions to the token we're using to launch.
    // SAFER might not be enabled at all, in which case we don't need to do this.
    //
    if ( gbSAFERAAAChecksEnabled && SaferLevel() )
    {
        hr = GetAAASaferToken( pClientToken, &hSaferToken );
        if ( FAILED(hr) ) goto LaunchServerEnd;
        if ( hr == S_FALSE )
        {
            // GetAAASaferToken has returned a shared reference
            // to pClientToken.
            bCloseSaferToken = FALSE;
            hr = S_OK;
        }
        else
            bCloseSaferToken = TRUE;
    }
    else
    {
        hSaferToken = pClientToken->GetToken();
        bCloseSaferToken = FALSE;
    }

    //
    // This should never fail here, but if it did that would be a really,
    // really bad security breach, so check it anyway.
    //
    if ( ! ImpersonateLoggedOnUser( hSaferToken ) )
    {
        hr = E_ACCESSDENIED;
        goto LaunchServerEnd;
    }

    //
    // Initialize process security info (SDs).  We need both SIDs to
    // do this, so here is the 1st time we can.  We Delete the SD right
    // after the CreateProcess call, no matter what happens.
    //
    psdNewProcessSD = AccessInfo.IdentifyAccess(
                                               FALSE,
                                               PROCESS_ALL_ACCESS,
                                               PROCESS_SET_INFORMATION |          // Allow primary token to be set
                                               PROCESS_TERMINATE | SYNCHRONIZE    // Allow screen-saver control
                                               );

    if ( ! psdNewProcessSD )
    {
        RevertToSelf();
        hr = E_OUTOFMEMORY;
        goto LaunchServerEnd;
    }

    saProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
    saProcess.lpSecurityDescriptor = psdNewProcessSD;
    saProcess.bInheritHandle = FALSE;

    SessionId = fIsRemoteActivation ? 0 : pClientToken->GetSessionId();

    if( SessionId != 0 ) {

        //
        // We must send the request to the remote WinStation
        // of the requestor
        //
        // NOTE: The current WinStationCreateProcessW() does not use
        //       the supplied security descriptor, but creates the
        //       process under the account of the logged on user.
        //
        // We do not stuff the security descriptor, so clear the suspend flag
#if DBGX
        CairoleDebugOut((DEB_TRACE, "SCM: Sending CreateProcess to SessionId %d\n",SessionId));
#endif

        // Non-zero sessions have only one winstation/desktop which is
        // the default one. We will ignore the winstation/desktop passed
        // in and use the default one.
        // review: Figure this out TarunA 05/07/99
        //StartupInfo.lpDesktop = L"WinSta0\\Default";

        // jsimmons 4/6/00 -- note that if the client was impersonating, then we won't
        // launch the server under the correct identity.   More work needed to determine
        // if we can fully support this.

        //
        // Stop impersonating before doing the WinStationCreateProcess.
        // The remote winstation exec thread will launch the app under
        // the users context. We must not be impersonating because this
        // call only lets SYSTEM request the remote execute.
        //
        RevertToSelf();
	
	HANDLE hDuplicate = NULL;
	
	// We need to pass in the SAFER blessed token to TS so that the 
	// server can use that token
	
	// TS code will call CreateProcessAsUser, so we need to get a primary token
	
	if (DuplicateTokenForSessionUse(hSaferToken, &hDuplicate)) 
	{
	   if (bCloseSaferToken)
	   {
	       CloseHandle(hSaferToken);
	   }
	   hSaferToken = hDuplicate;
	   bCloseSaferToken = TRUE;
	   bStatus = CreateRemoteSessionProcess(
					       SessionId,
					       hSaferToken,
					       FALSE,               // Run as Logged on USER
					       ServerExecutable(),  // application name
					       pwszCommandLine,     // command line
					       &saProcess,          // process sec attributes
					       NULL,                // default thread sec attributes
					       // (this was &saThread, but isn't needed)
					       FALSE,               // dont inherit handles
					       CreateFlags,         // creation flags
					       pFinalEnvBlock,      // use same enviroment block as the client
					       NULL,                // use same directory
					       &StartupInfo,        // startup info
					       &ProcessInfo         // proc info returned
					       );
	}

    }
    else
    {
        HANDLE hPrimary = NULL;
        if (DuplicateTokenAsPrimary(hSaferToken, pClientToken->GetSid(), &hPrimary)) 
        {
	   if (bCloseSaferToken)
	   {
	       CloseHandle(hSaferToken);
	   }
	   hSaferToken = hPrimary;
	   bCloseSaferToken = TRUE;
           //
           // Do the exec while impersonating so the file access gets ACL
           // checked correctly.  
           //
           //
           bStatus = CreateProcessAsUser(
                                  hSaferToken,
                                  ServerExecutable(),
                                  pwszCommandLine,
                                  &saProcess,
                                  NULL,
                                  FALSE,
                                  CreateFlags,
                                  pFinalEnvBlock,
                                  NULL,
                                  &StartupInfo,
                                  &ProcessInfo);
   
        }

        RevertToSelf();
    }

    if ( ! bStatus )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        LogServerStartError( &_Clsid, clsctx, pClientToken, pwszCommandLine );
        goto LaunchServerEnd;
    }

LaunchServerEnd:

    if ( pFinalEnvBlock && pFinalEnvBlock != pEnvBlock )
        PrivMemFree( pFinalEnvBlock );

    if ( ProcessInfo.hThread )
        CloseHandle( ProcessInfo.hThread );

    if ( ProcessInfo.hProcess && ! bStatus )
    {
        CloseHandle( ProcessInfo.hProcess );
        ProcessInfo.hProcess = 0;
    }
    
    if ( hSaferToken && bCloseSaferToken )    
    {
        CloseHandle( hSaferToken );
    }

    *phProcess = ProcessInfo.hProcess;
    *pdwProcessId = ProcessInfo.dwProcessId;

    PrivMemFree( pwszCommandLine );

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  LaunchRunAsServer
//
//--------------------------------------------------------------------------
HRESULT
CClsidData::LaunchRunAsServer(
    IN  CToken *    pClientToken,
    IN  BOOL        fIsRemoteActivation,
    IN  ActivationPropertiesIn *pActIn,
    IN  DWORD       clsctx,
    OUT HANDLE *    phProcess,
    OUT DWORD  *    pdwProcessId,
    OUT void**      ppvRunAsHandle
    )
{
    WCHAR *                 pwszCommandLine;
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInfo = {0};
    HANDLE                  hToken;
    SECURITY_ATTRIBUTES     saProcess;
    PSECURITY_DESCRIPTOR    psdNewProcessSD;
    PSID                    psidUserSid;
    HRESULT                 hr;
    BOOL                    bStatus = FALSE;
    ULONG                   ulSessionId;
    BOOL                    bFromRunAsCache = FALSE;

    hr = GetLaunchCommandLine( &pwszCommandLine );
    if ( hr != S_OK )
        return (hr);
    
    *phProcess = NULL;
    
    *pdwProcessId = 0;
    
    hToken = NULL;
    bStatus = FALSE;
    
    StartupInfo.cb = sizeof(STARTUPINFO);
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop = NULL;
    StartupInfo.lpTitle = (SERVERTYPE_SURROGATE == _ServerType) ? NULL : _pwszServer;
    StartupInfo.dwFlags = 0;
    StartupInfo.cbReserved2 = 0;
    StartupInfo.lpReserved2 = NULL;
    
    ulSessionId = 0;
    
    if( IsInteractiveUser() )
    {
        if (!fIsRemoteActivation)
        {
            // This code seems to be saying, "if the client is local then I
            // should always be able to impersonate him".  Which is true under
            // normal circumstances, but we have seen a case (stress machine
            // shutdowns) where the client is local but came in un-authenticated.
            if (!pClientToken)
                return E_ACCESSDENIED;
            
            if ( !ImpersonateLoggedOnUser( pClientToken->GetToken() ) )
            {
                PrivMemFree(pwszCommandLine);
                return E_ACCESSDENIED;
            }
            
            RevertToSelf();
        }
        
        ASSERT(pActIn);
        LONG lSessIdTemp;

        // Query for incoming session
        GetSessionIDFromActParams(pActIn, &lSessIdTemp);
        if (lSessIdTemp != INVALID_SESSION_ID)
        {
            ulSessionId = lSessIdTemp;
        }
        
        // Right now force all complus to
        // session 0. Session based activation
        // is still ill defined for complus
        // servers.
        if (_ServerType == SERVERTYPE_COMPLUS)
        {
            ulSessionId = 0;
        }

        hToken = GetUserTokenForSession(ulSessionId);
    }
    else
    {
        hToken = GetRunAsToken( clsctx,
                                AppidString(),
                                RunAsDomain(),
                                RunAsUser(),
                                TRUE);
        if (hToken)
        {
            hr = RunAsGetTokenElem(&hToken,
                                   ppvRunAsHandle);
            if (SUCCEEDED(hr))
                bFromRunAsCache = TRUE;
            else
            {
                ASSERT((*ppvRunAsHandle == NULL) && "RunAsGetTokenElem failed but *ppvRunAsHandle is non-NULL");            
                PrivMemFree( pwszCommandLine );
                CloseHandle(hToken);
                return hr;
            }
        }
    }

    if ( ! hToken )
    {
        PrivMemFree( pwszCommandLine );
        return (CO_E_RUNAS_LOGON_FAILURE);
    }

    psdNewProcessSD = 0;

    psidUserSid = GetUserSid(hToken);

    CAccessInfo AccessInfo(psidUserSid);

    // We have to get past the CAccessInfo before we can use a goto.

    if ( psidUserSid )
    {
        psdNewProcessSD = AccessInfo.IdentifyAccess(
                                                   FALSE,
                                                   PROCESS_ALL_ACCESS,
                                                   PROCESS_SET_INFORMATION |          // Allow primary token to be set
                                                   PROCESS_TERMINATE | SYNCHRONIZE    // Allow screen-saver control
                                                   );
    }

    if ( ! psdNewProcessSD )
    {
        hr = E_OUTOFMEMORY;
        goto LaunchRunAsServerEnd;
    }

    saProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
    saProcess.lpSecurityDescriptor = psdNewProcessSD;
    saProcess.bInheritHandle = FALSE;

    {
        //
        // Get the environment block of the user
        //
        LPVOID lpEnvBlock = NULL;

        bStatus = CreateEnvironmentBlock(&lpEnvBlock, hToken, FALSE);
        
        HANDLE hSaferToken = NULL;
        if(bStatus && SaferLevel())
        {
            bStatus = SaferComputeTokenFromLevel(SaferLevel(),
                                                 hToken,
                                                 &hSaferToken,
                                                 0,
                                                 NULL);
        }
        else
        {
            hSaferToken = hToken;
        }
        
        if (bStatus && (ulSessionId != 0))
        {
            bStatus = SetTokenInformation(hSaferToken,
                                          TokenSessionId,
                                          &ulSessionId,
                                          sizeof(ulSessionId));
        }
        
        if(bStatus)
        {
            //
            // This allows the process create to work with paths to remote machines.
            //
            (void) ImpersonateLoggedOnUser( hSaferToken );
            
            bStatus = CreateProcessAsUser(hSaferToken,
                                          ServerExecutable(),
                                          pwszCommandLine,
                                          &saProcess,
                                          NULL,
                                          FALSE,
                                          CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,
                                          lpEnvBlock,
                                          NULL,
                                          &StartupInfo,
                                          &ProcessInfo);
            
            (void) RevertToSelf();
        }
    
        //
        // Free the environment block buffer
        //
        if (lpEnvBlock)
            DestroyEnvironmentBlock(lpEnvBlock);
        
        if (hSaferToken && SaferLevel())
            CloseHandle(hSaferToken);
    }

    if ( ! bStatus )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        LogRunAsServerStartError(
                                &_Clsid,
                                clsctx,
                                pClientToken,
                                pwszCommandLine,
                                RunAsUser(),
                                RunAsDomain() );
        goto LaunchRunAsServerEnd;
    }

    *phProcess = ProcessInfo.hProcess;
    *pdwProcessId = ProcessInfo.dwProcessId;

    NtClose( ProcessInfo.hThread );

LaunchRunAsServerEnd:

    if ( hToken )
    {
        NtClose( hToken );
    }

    if ( psidUserSid )
    {
        PrivMemFree(psidUserSid);
    }

    PrivMemFree( pwszCommandLine );

    if (!bFromRunAsCache)
        *ppvRunAsHandle = NULL;
    else
    if (!SUCCEEDED(hr))
    {
        RunAsRelease(*ppvRunAsHandle);
        *ppvRunAsHandle = NULL;
    }
    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Member:     LaunchService
//
//--------------------------------------------------------------------------
HRESULT
CClsidData::LaunchService(
                         IN  CToken *    pClientToken,
                         IN  DWORD       clsctx,
                         OUT SC_HANDLE * phService
                         )
{
    WCHAR  *pwszArgs = NULL;
    ULONG   cArgs = 0;
    WCHAR  *apwszArgs[MAX_SERVICE_ARGS];
    BOOL    bStatus;
    HRESULT hr;

    ASSERT(g_hServiceController);
    *phService = OpenService( g_hServiceController,
                              _pAppid->Service(),
                              GENERIC_EXECUTE | GENERIC_READ );

    if ( ! *phService )
        return (HRESULT_FROM_WIN32( GetLastError() ));

    // Formulate the arguments (if any)
    if ( ServiceArgs() )
    {
        UINT   k = 0;

        // Make a copy of the service arguments
        pwszArgs = (WCHAR *) PrivMemAlloc(
                                         (lstrlenW(ServiceArgs()) + 1) * sizeof(WCHAR));
        if ( pwszArgs == NULL )
        {
            CloseServiceHandle(*phService);
            *phService = 0;
            return (E_OUTOFMEMORY);
        }
        lstrcpyW(pwszArgs, ServiceArgs());

        // Scan the arguments
        do
        {
            // Scan to the next non-whitespace character
            while ( pwszArgs[k]  &&
                    (pwszArgs[k] == L' '  ||
                     pwszArgs[k] == L'\t') )
            {
                k++;
            }

            // Store the next argument
            if ( pwszArgs[k] )
            {
                apwszArgs[cArgs++] = &pwszArgs[k];
            }

            // Scan to the next whitespace char
            while ( pwszArgs[k]          &&
                    pwszArgs[k] != L' '  &&
                    pwszArgs[k] != L'\t' )
            {
                k++;
            }

            // Null terminate the previous argument
            if ( pwszArgs[k] )
            {
                pwszArgs[k++] = L'\0';
            }
        } while ( pwszArgs[k] );
    }

    bStatus = StartService( *phService,
                            cArgs,
                            cArgs > 0 ? (LPCTSTR  *) apwszArgs : NULL);

    PrivMemFree(pwszArgs);

    if ( bStatus )
        return (S_OK);

    DWORD dwErr = GetLastError();

    hr = HRESULT_FROM_WIN32( dwErr );

    if ( dwErr == ERROR_SERVICE_ALREADY_RUNNING )
        return (hr);

    CairoleDebugOut((DEB_ERROR,
                     "StartService %ws failed, error = %#x\n",_pAppid->Service(),GetLastError()));
    CloseServiceHandle(*phService);
    *phService = 0;

    LogServiceStartError(
                        &_Clsid,
                        clsctx,
                        pClientToken,
                        _pAppid->Service(),
                        ServiceArgs(),
                        dwErr );

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  LaunchAllowed
//
//--------------------------------------------------------------------------
BOOL
CClsidData::LaunchAllowed(
                         IN  CToken * pClientToken,
                         IN  DWORD    clsctx
                         )
{
    BOOL    bStatus;

    ASSERT(pClientToken);

#if DBG
    WCHAR wszUser[MAX_PATH];
    ULONG cchSize = MAX_PATH;
    pClientToken->Impersonate();
    GetUserName( wszUser, &cchSize );
    pClientToken->Revert();
    CairoleDebugOut((DEB_TRACE, "RPCSS : CClsidData::LaunchAllowed on %ws\n", wszUser));
#endif

    if ( LaunchPermission() )
        bStatus = CheckForAccess( pClientToken, LaunchPermission() );
    else
    {
        CSecDescriptor* pSD = GetDefaultLaunchPermissions();
        if (pSD)
        {
            bStatus = CheckForAccess( pClientToken, pSD->GetSD() );

            pSD->DecRefCount();
        }
        else
            bStatus = FALSE;
    }

    if ( ! bStatus )
    {
        LogLaunchAccessFailed(
                             &_Clsid,
                             clsctx,
                             pClientToken,
                             0 == LaunchPermission() );
    }

    return (bStatus);
}

HRESULT
CClsidData::GetLaunchCommandLine(
                                OUT WCHAR ** ppwszCommandLine
                                )
{
    DWORD   AllocBytes;

    *ppwszCommandLine = 0;

    if ( (SERVERTYPE_EXE16 == _ServerType) || (SERVERTYPE_EXE32 == _ServerType) )
    {
        AllocBytes = ( 1 + lstrlenW( L"-Embedding" ) +
                       1 + lstrlenW( _pwszServer ) ) * sizeof(WCHAR);
        *ppwszCommandLine = (WCHAR *) PrivMemAlloc( AllocBytes );
        if ( *ppwszCommandLine != NULL )
        {
            lstrcpyW( *ppwszCommandLine, _pwszServer );
            lstrcatW( *ppwszCommandLine, L" -Embedding" );
        }
    }
    else
    {
        ASSERT(    SERVERTYPE_SURROGATE == _ServerType
                   || SERVERTYPE_COMPLUS == _ServerType
                   || SERVERTYPE_DLLHOST == _ServerType );

        AllocBytes = ( 1 + lstrlenW( DllSurrogate() ) ) * sizeof(WCHAR);
        *ppwszCommandLine = (WCHAR *) PrivMemAlloc( AllocBytes );
        if ( *ppwszCommandLine != NULL )
        {
            lstrcpyW( *ppwszCommandLine, DllSurrogate() );
        }
    }

    return (*ppwszCommandLine ? S_OK : E_OUTOFMEMORY);
}

CNamedObject*
CClsidData::ServerLaunchMutex()
{
    WCHAR* pwszPath = NULL;
    WCHAR* pszPathBuf = NULL;

    if ( SERVERTYPE_SURROGATE == _ServerType )
    {
        pwszPath = DllSurrogate();

        //  Will never be called any more, ever
        if ( ! pwszPath || ! *pwszPath )
        {
            ASSERT(_pAppid);
            pwszPath = _pAppid->AppidString();
            //pwszPath = L"dllhost.exe";
        }
    }
    else if ( DllHostOrComPlusProcess() )
    {
        ASSERT(_pAppid);
        pwszPath = _pAppid->AppidString();
        //pwszPath = L"dllhost.exe";
    }
    else
    {
        pwszPath = Server();

        // Need to use the base .exe part of the file path here,
        // there are tests that move the registration of their
        // server from one dir to another and we need to handle 
        // this while concurrent activations are happening.
        LPWSTR pszBaseExeName = NULL;

        // First see how much of a buffer we need
        DWORD dwRet = GetFullPathName(pwszPath,
                                      0,
                                      NULL,
                                      NULL);
        ASSERT(dwRet != 0);
        pszPathBuf = (WCHAR*)PrivMemAlloc(dwRet * sizeof(WCHAR));
        if (!pszPathBuf)
            return NULL;

        dwRet = GetFullPathName(pwszPath,
                                dwRet,
                                pszPathBuf,
                                &pszBaseExeName);
        if ((dwRet == 0) || !pszBaseExeName)
        {
            ASSERT(!"Unexpected failure from GetFullPathName");
            PrivMemFree(pszPathBuf);
            return NULL;
        }

        // Use the base exe name for the event name
        pwszPath = pszBaseExeName;
    }

    if ( !pwszPath )
    {
        ASSERT(0);
        PrivMemFree(pszPathBuf);
        return (NULL);
    }

    CNamedObject* pObject = 
        gpNamedObjectTable->GetNamedObject(pwszPath, CNamedObject::MUTEX);

    PrivMemFree(pszPathBuf);

    if (pObject)
    {
        WaitForSingleObject(pObject->Handle(), INFINITE);        
    }

    return pObject;
}

//
//  CClsidData::ServerRegisterEvent
//
//  Returns a handle to the appropriate register  
//  event for the server in question.   
//
CNamedObject*
CClsidData::ServerRegisterEvent()
{
    if ( DllHostOrComPlusProcess() )
    {
        // For dllhost\com+ surrogates, we delegate to the appid
        ASSERT(_pAppid);
        return _pAppid->ServerRegisterEvent();
    }
    
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(REGEVENT_PREFIX)];	
    memcpy(wszEventName, REGEVENT_PREFIX, sizeof(REGEVENT_PREFIX));
    memcpy(wszEventName + REGEVENT_PREFIX_STRLEN, _wszClsid, sizeof(_wszClsid));

    return gpNamedObjectTable->GetNamedObject(wszEventName, CNamedObject::EVENT);
}

//
//  CClsidData::ServerInitializedEvent
//
//  Returns a handle to the appropriate register
//  event for the server in question.  This event is
//  signaled when initialization is finished.
//
CNamedObject*
CAppidData::ServerInitializedEvent()
{
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(INITEVENT_PREFIX)];
    memcpy(wszEventName, INITEVENT_PREFIX, sizeof(INITEVENT_PREFIX));
    memcpy(wszEventName + INITEVENT_PREFIX_STRLEN, _wszAppid, sizeof(_wszAppid));

    return gpNamedObjectTable->GetNamedObject(wszEventName, CNamedObject::EVENT);
}

//
//  CClsidData::ServerInitializedEvent
//
//  Returns a handle to the appropriate register
//  event for the server in question.  This event is
//  signaled when initialization is finished.
//
//  NOTE: The non-DllHost path is currently not used here.
//
CNamedObject*
CClsidData::ServerInitializedEvent()
{
    if ( DllHostOrComPlusProcess() )
    {
        // For dllhost\com+ surrogates, we delegate to the appid
        ASSERT(_pAppid);
        return _pAppid->ServerInitializedEvent();
    }
    
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(INITEVENT_PREFIX)];    
    memcpy(wszEventName, INITEVENT_PREFIX, sizeof(INITEVENT_PREFIX));
    memcpy(wszEventName + INITEVENT_PREFIX_STRLEN, _wszClsid, sizeof(_wszClsid));

    return gpNamedObjectTable->GetNamedObject(wszEventName, CNamedObject::EVENT);
}

//
//  CAppidData::ServerRegisterEvent
//
//  Returns a handle to the appropriate register  
//  event for the server in question.   
//
CNamedObject*
CAppidData::ServerRegisterEvent()
{
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(REGEVENT_PREFIX)];
    memcpy(wszEventName, REGEVENT_PREFIX, sizeof(REGEVENT_PREFIX));
    memcpy(wszEventName + REGEVENT_PREFIX_STRLEN, _wszAppid, sizeof(_wszAppid));

    return gpNamedObjectTable->GetNamedObject(wszEventName, CNamedObject::EVENT);
}


//+-------------------------------------------------------------------------
//
//  CClsidData::AddAppPathsToEnv
//
//  Constructs a new environment block with an exe's AppPath value from the
//  registry appended to the Path environment variable.  Simply returns the
//  given environment block if the clsid's server is not a 32 bit exe or if
//  no AppPath is found for the exe.
//
//--------------------------------------------------------------------------
HRESULT
CClsidData::AddAppPathsToEnv(
                            IN  WCHAR *     pEnvBlock,
                            IN  DWORD       EnvBlockLength,
                            OUT WCHAR **    ppFinalEnvBlock
                            )
{
    HKEY        hAppKey;
    WCHAR *     pwszExe;
    WCHAR *     pwszExeEnd;
    WCHAR *     pwszAppPath;
    WCHAR *     pPath;
    WCHAR *     pNewEnvBlock;
    WCHAR       wszStr[8];
    WCHAR       wszKeyName[APP_PATH_LEN+MAX_PATH];
    DWORD       AppPathLength;
    DWORD       EnvFragLength;
    DWORD       Status;
    BOOL        bFoundPath;

    pwszAppPath = 0;
    pNewEnvBlock = 0;

    *ppFinalEnvBlock = pEnvBlock;

    if ( _ServerType != SERVERTYPE_EXE32 )
        return (S_OK);

    //
    // Find the exe name by looking for the first .exe sub string which
    // is followed by a space or null.  Only servers registered with a
    // .exe binary are supported.  Otherwise the parsing is ambiguous since
    // the LocalServer32 can contain paths with spaces as well as optional
    // arguments.
    //
    if ( ! FindExeComponent( _pwszServer, L" ", &pwszExe, &pwszExeEnd ) )
        return (S_OK);

    //
    // pwszExe points to the beginning of the binary name
    // pwszExeEnd points to one char past the end of the binary name
    //
    memcpy( wszKeyName, APP_PATH, APP_PATH_LEN * sizeof(WCHAR) );
    memcpy( &wszKeyName[APP_PATH_LEN], pwszExe, (ULONG) (pwszExeEnd - pwszExe) * sizeof(WCHAR) );
    wszKeyName[APP_PATH_LEN + (pwszExeEnd - pwszExe)] = 0;

    Status = RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         wszKeyName,
                         0,
                         KEY_READ,
                         &hAppKey );

    if ( ERROR_SUCCESS == Status )
    {
        Status = ReadStringValue( hAppKey, L"Path", &pwszAppPath );
        RegCloseKey( hAppKey );
    }

    if ( Status != ERROR_SUCCESS )
        return (S_OK);

    AppPathLength = lstrlenW(pwszAppPath);

    // New env block size includes space for a new ';' separator in the path.
    pNewEnvBlock = (WCHAR *) PrivMemAlloc( (EnvBlockLength + 1 + AppPathLength) * sizeof(WCHAR) );

    if ( ! pNewEnvBlock )
    {
        PrivMemFree( pwszAppPath );
        return (E_OUTOFMEMORY);
    }

    pPath = pEnvBlock;
    bFoundPath = FALSE;

    for ( ; *pPath; )
    {
        memcpy( wszStr, pPath, 5 * sizeof(WCHAR) );
        wszStr[5] = 0;

        pPath += lstrlenW( pPath ) + 1;

        if ( lstrcmpiW( wszStr, L"Path=" ) == 0 )
        {
            bFoundPath = TRUE;
            break;
        }
    }

    if ( bFoundPath )
    {
        pPath--;

        EnvFragLength = (ULONG) (pPath - pEnvBlock);

        memcpy( pNewEnvBlock,
                pEnvBlock,
                EnvFragLength * sizeof(WCHAR) );

        pNewEnvBlock[EnvFragLength] = L';';

        memcpy( &pNewEnvBlock[EnvFragLength + 1],
                pwszAppPath,
                AppPathLength * sizeof(WCHAR) );

        memcpy( &pNewEnvBlock[EnvFragLength + 1 + AppPathLength],
                pPath,
                (EnvBlockLength - EnvFragLength) * sizeof(WCHAR) );

        *ppFinalEnvBlock = pNewEnvBlock;
    }
    else
    {
        PrivMemFree( pNewEnvBlock );
    }

    PrivMemFree( pwszAppPath );
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\mach.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:   mach.cxx
//
//  Contents:
//      Machine naming helper objects
//
//  History:
//--------------------------------------------------------------------------

#include    "act.hxx"
#include    <mach.hxx>
#include    <misc.hxx>

// Singleton instance:
CMachineName gMachineName;

// Defn of global ptr external parties use:
CMachineName * gpMachineName = &gMachineName;

CIPAddrs::CIPAddrs() :
    _lRefs(1),  // constructed with non-zero refcount!
    _pIPAddresses(NULL)
{
}
CIPAddrs::~CIPAddrs()
{
    ASSERT(_lRefs == 0);

    if (_pIPAddresses)
    {
        PrivMemFree(_pIPAddresses);
    }
}
void CIPAddrs::IncRefCount()
{
    InterlockedIncrement(&_lRefs);
}
void CIPAddrs::DecRefCount()
{
    LONG lRefs = InterlockedDecrement(&_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }
}

const DWORD MAX_IPV4_STRING_BUF = ((INET_ADDRSTRLEN+1) * sizeof(WCHAR));
const DWORD MAX_IPV6_STRING_BUF = ((INET6_ADDRSTRLEN+1) * sizeof(WCHAR));

CMachineName::CMachineName()
{
    _pIPAddresses = NULL;
    _pwszNetBiosName = NULL;
    _pwszDNSName = NULL;
    _bIPV4AddrsChanged = TRUE;
    _bIPV6AddrsChanged = TRUE;
    _bInitialized = FALSE;
    
    InitAQD(&_aqdIPV4, AF_INET);
    InitAQD(&_aqdIPV6, AF_INET6);

    ZeroMemory(&_csMachineNameLock, sizeof(CRITICAL_SECTION));
}


void
CMachineName::InitAQD(
           ADDRESS_QUERY_DATA* paqd,
           int addrfamily)
{
    ASSERT(paqd);

    ZeroMemory(paqd, sizeof(ADDRESS_QUERY_DATA));
    paqd->dwSig = ADDRQUERYDATA_SIG;
    paqd->socket = INVALID_SOCKET;
    paqd->addrfamily = addrfamily;
    if (addrfamily == AF_INET)
    {
    	paqd->pfnIsGlobalAddress = CMachineName::IsIPV4AddressGlobal;
        paqd->dwMaxAddrStringBufSize = MAX_IPV4_STRING_BUF;
    }
    else if (addrfamily == AF_INET6)
    {
    	paqd->pfnIsGlobalAddress = CMachineName::IsIPV6AddressGlobal;
        paqd->dwMaxAddrStringBufSize = MAX_IPV6_STRING_BUF;
    }
    else
    {
        ASSERT(0);
    }
}

CMachineName::~CMachineName()
{
    // CODEWORK:  This object does not cleanup its resources.  This 
    // could be fixed, but is pointless at the present time since the 
    // object lives for the life of the RPCSS svchost, which lives for 
    // the life of the machine boot.
}

BOOL CMachineName::Initialize()
{
    NTSTATUS status;

    // Initialize lock
    status = RtlInitializeCriticalSection(&_csMachineNameLock); 
    _bInitialized = NT_SUCCESS(status);
    
    return _bInitialized;
}

void 
CMachineName::IPAddrsChanged(int addrfamily)
{
    ASSERT(_bInitialized);
	
    switch (addrfamily)
    {
    case AF_INET:
        // IPV4 addresses changed
        _bIPV4AddrsChanged = TRUE;
        break;
    case AF_INET6:
        // IPV6 addresses changed
        ASSERT(gAddrRefreshMgr.IsIPV6Installed() == TRUE);
        _bIPV6AddrsChanged = TRUE;
        break;
    default:
        ASSERT(0 && "Address change signalled on unknown addr family");
        return;
    }

    return;
}

BOOL
CMachineName::Compare( IN WCHAR * pwszName )
{
    CIPAddrs* pIPAddrs = NULL;

    ASSERT(_bInitialized);

    if (!pwszName)
        return FALSE;

    // Okay to check hard-coded names first (they never change)
    if (CompareHardCodedLocalHostNames(pwszName))
        return TRUE;

    // Get netbios name if we haven't done so already:
	if (!_pwszNetBiosName)
	{
		SetNetBIOSName();
	}

    if (_pwszNetBiosName && !lstrcmpiW(pwszName, _pwszNetBiosName))
        return TRUE;

    // Don't go any farther unless we're actually using TCP
    if (!gAddrRefreshMgr.ListenedOnTCP())
        return FALSE;
	
    // Get DNS name if we haven't done so already.
    if (! _pwszDNSName)
	{
        SetDNSName();
    }
    
    if (_pwszDNSName && !lstrcmpiW(pwszName, _pwszDNSName))
        return TRUE;

	// review:  there are other names we could be checking for here, see docs
	// on GetComputerNameEx.  Need to be wary of cluster names though.
	
    pIPAddrs = GetIPAddrs();
    if (pIPAddrs)
    {
        NetworkAddressVector* pNetworkAddrVector = pIPAddrs->_pIPAddresses;
        for ( DWORD n = 0; n < pNetworkAddrVector->Count; n++ )
        {
            if (!lstrcmpiW(pwszName, pNetworkAddrVector->NetworkAddresses[n]))
            {
                pIPAddrs->DecRefCount();
                return TRUE;
            }
        }
        pIPAddrs->DecRefCount();
    }

    // We do this last because a side-effect of calling GetIPAddrs is that it will
    // populate the list of IPV4 & IPV6 localhost names, if any.
    if (CompareDynamicLocalHostNames(pwszName))
        return TRUE;

    return FALSE;
}

//
//  CMachineName::GetIPAddrs()
//
//  Returns a pointer to a refcounted CIPAddrs for this 
//  machine.    If we don't yet have a non-localhost ip, 
//  then we keep trying to get one.
// 
CIPAddrs* 
CMachineName::GetIPAddrs()
{
    ASSERT(_bInitialized);

    CMutexLock lock(&_csMachineNameLock);

    // should we call gAddrRefreshMgr.ListenedOnTCP() here
    // and simply return an empty vector if so?
	
    // If anything changed, or if we don't have any
    // addresses at all, go query for the current stuff
    if (_bIPV4AddrsChanged ||
        _bIPV6AddrsChanged ||
        !_pIPAddresses)
    {
        // Release old addresses, if any
        if (_pIPAddresses)
        {
            _pIPAddresses->DecRefCount();
            _pIPAddresses = NULL;
        }

        _pIPAddresses = QueryAddresses();
        if (!_pIPAddresses)
            return NULL;
    }

    ASSERT(_pIPAddresses);
    _pIPAddresses->IncRefCount();

    return _pIPAddresses;
}

WCHAR* 
CMachineName::NetBiosName()
{
    ASSERT(_bInitialized);

    if (!_pwszNetBiosName)
    {
        SetNetBIOSName();
    }
    
    return _pwszNetBiosName;
}

WCHAR* 
CMachineName::DNSName()
{
    ASSERT(_bInitialized);

    if (!_pwszDNSName)
    {
        SetDNSName();
    }
    
    return _pwszDNSName;
}

CIPAddrs*
CMachineName::QueryAddresses()
{
    // Assumes we hold _csMachineNameLock
    
    // If necessary free old ipv4 addresses and requery
    if (_bIPV4AddrsChanged)
    {
        _bIPV4AddrsChanged = FALSE;
        BOOL fRet = QueryAddressesSpecific(&_aqdIPV4);
        if (!fRet)
        {
            // If something went wrong, just keep going.  The only thing
            // we could do here is refuse to supply bindings.  If we keep
            // going though, the worst thing that could occur (IMHO) is 
            // that the bindings might only contain a DNS name.   Better 
            // to degrade gracefully than refuse service altogether.
        }
    }

    // If necessary free old ipv6 addresses and requery
    if (_bIPV6AddrsChanged && gAddrRefreshMgr.IsIPV6Installed())
    {
        _bIPV6AddrsChanged = FALSE;
        BOOL fRet = QueryAddressesSpecific(&_aqdIPV6);
        if (!fRet)
        {
            // If something went wrong, just keep going.  The only thing
            // we could do here is refuse to supply bindings.  If we keep
            // going though, the worst thing that could occur (IMHO) is 
            // that the bindings might only contain a DNS name.   Better 
            // to degrade gracefully than refuse service altogether.
        }
    }
   
    // We now have the current IPV4 + IPV6 addresses, now
    // just merge them.
    CIPAddrs* pIPAddrs = MergeAddresses();
    if (!pIPAddrs)
        return NULL;
    
    return pIPAddrs;
}

CIPAddrs*
CMachineName::MergeAddresses()
{
    DWORD dwCurrentAddress = 0;
    DWORD dwTotalAddresses = 0;
    CIPAddrs* pIPAddrs = NULL;
    NetworkAddressVector* pVector = NULL;
    DWORD dwTotalVectorStorageNeeded = 0;
    
    // Assumes we hold _csMachineNameLock

    // Allocate new wrapper object
    pIPAddrs = new CIPAddrs();
    if (!pIPAddrs)
        return NULL;

    // Figure out how many addresses we have
    if (_aqdIPV4.pAddresses)
    {
        dwTotalAddresses += _aqdIPV4.pAddresses->Count;
    }
    if (_aqdIPV6.pAddresses)
    {
        dwTotalAddresses += _aqdIPV6.pAddresses->Count;
    }

    //
    // Handle case with zero addresses
    //
    if (dwTotalAddresses == 0)
    {
        // Allocate an empty vector
        pVector = (NetworkAddressVector*)PrivMemAlloc(sizeof(NetworkAddressVector));
        if (pVector)
        {
            pVector->Count = 0;
            pVector->StringBufferSpace = 0;
            pVector->NetworkAddresses = NULL;
            pIPAddrs->_pIPAddresses = pVector;
        }
        else
        {
            pIPAddrs->DecRefCount();
            pIPAddrs = NULL;
        }
        return pIPAddrs;
    }

    //
    // Calculate total memory needed for combined vector and 
    // allocate it
    //
    dwTotalVectorStorageNeeded = sizeof(NetworkAddressVector);
    dwTotalVectorStorageNeeded += (sizeof(WCHAR*) * dwTotalAddresses);
    if (_aqdIPV4.pAddresses)
    {
	    dwTotalVectorStorageNeeded += _aqdIPV4.pAddresses->StringBufferSpace;
    }
    if (_aqdIPV6.pAddresses)
    {
        dwTotalVectorStorageNeeded += _aqdIPV6.pAddresses->StringBufferSpace;
    }
    
    pVector = (NetworkAddressVector*)PrivMemAlloc(dwTotalVectorStorageNeeded);
    if (!pVector)
    {
        pIPAddrs->DecRefCount();
        pIPAddrs = NULL;
        return NULL;
    }

    //
    // Init struct and set it up for copying
    //
    ZeroMemory(pVector, dwTotalVectorStorageNeeded);
    pVector->Count = dwTotalAddresses;
    if (_aqdIPV4.pAddresses)
    {
        pVector->StringBufferSpace = _aqdIPV4.pAddresses->StringBufferSpace;
    }
    if (_aqdIPV6.pAddresses)
    {
        pVector->StringBufferSpace += _aqdIPV6.pAddresses->StringBufferSpace;
    }
    
    pVector->NetworkAddresses = (WCHAR**)&pVector[1];

    //
    // Copy addresses into the vector
    //
    dwCurrentAddress = 0;
    WCHAR* pszCurrentAddress = (WCHAR*)(&pVector->NetworkAddresses[dwTotalAddresses]);
    if (_aqdIPV4.pAddresses)
    {
        CopySrcVectorToTargetVector (pVector,
                                _aqdIPV4.pAddresses,
                                &dwCurrentAddress,
                                &pszCurrentAddress);
        ASSERT(dwCurrentAddress == _aqdIPV4.pAddresses->Count);
    }   
    if (_aqdIPV6.pAddresses)
    {
        CopySrcVectorToTargetVector(pVector,
                                _aqdIPV6.pAddresses,
                                &dwCurrentAddress,
                                &pszCurrentAddress);
    }
    ASSERT(dwCurrentAddress == dwTotalAddresses);
    
    ValidateVector(pVector);
    
    //
    // Success    
    //
    pIPAddrs->_pIPAddresses = pVector;    
    return pIPAddrs;
}

void
CMachineName::CopySrcVectorToTargetVector (
    NetworkAddressVector* pTargetVector, // The vector to copy into
    NetworkAddressVector* pSourceVector, // The vector to copy from
    DWORD * pdwCurrentAddress,           // On input, the index in the vector to start copying into.
    WCHAR** ppszCurrentAddress)          // On input, the buffer position to start copying into.
{
    // Do nothing in case of an empty source vector
    if (pSourceVector->Count == 0)
        return;

    // Copy down the [in,out] parameters for shorthand purposes.
    DWORD dwCurrent   = *pdwCurrentAddress;
    WCHAR *pszCurrent = *ppszCurrentAddress;
    for (DWORD i = 0; i < pSourceVector->Count; i++)
    {
        // Lay the source network address into the buffer at wszCurrent.
        lstrcpy(pszCurrent, pSourceVector->NetworkAddresses[i]);

        // Now set the pointer in pTargetVector to point to wszCurrent...
        pTargetVector->NetworkAddresses[dwCurrent] = pszCurrent;
        //
        // ...and advance wszCurrent to the next free spot in the buffer.
        pszCurrent += (lstrlen(pszCurrent) + 1);
        dwCurrent++;
    }

    // Update the [in,out] params.
    *pdwCurrentAddress  = dwCurrent;
    *ppszCurrentAddress = pszCurrent;

    return;
}

BOOL
CMachineName::IsIPV4AddressGlobal(LPSOCKADDR psockaddr)
{
    ASSERT(psockaddr);

    // undone? what do we need to check here?  do we even see localhost
    // addresses from a socket query? (not usually)
	
    //in6_addr* pin6addr = &(((sockaddr_in6*)psockaddr)->sin6_addr);
	
    return TRUE;
}

BOOL
CMachineName::IsIPV6AddressGlobal(LPSOCKADDR psockaddr)
{
    ASSERT(psockaddr);

    in6_addr* pin6addr = &(((sockaddr_in6*)psockaddr)->sin6_addr);

    // This macro just checks for ::1%1
    if (IN6_IS_ADDR_LOOPBACK(pin6addr))
    {
        return FALSE;
    }

    // Unfortunately, the IN6_IS_ADDR_LOOPBACK macro doesn't cover all
    // cases.  Specifically, it doesn't work for fe80::1.  Here we 
    // have a hard-coded check for this:
    if ((pin6addr->s6_words[0] == 0x80fe) &&
        (pin6addr->s6_words[1] == 0x0) &&
        (pin6addr->s6_words[2] == 0x0) &&
        (pin6addr->s6_words[3] == 0x0) &&
        (pin6addr->s6_words[4] == 0x0) &&
        (pin6addr->s6_words[5] == 0x0) &&
        (pin6addr->s6_words[6] == 0x0) &&
        (pin6addr->s6_words[7] == 0x0100))
    {
        return FALSE;
	}

    // No link-local addresses
    if (IN6_IS_ADDR_LINKLOCAL(pin6addr))
    {
        return FALSE;
    }

    // No site local addresses.  
    if (IN6_IS_ADDR_SITELOCAL(pin6addr))
    {
        return FALSE;
    }

    // At this point, we have concluded that the IPV6 address in question is
    // a "global" scope address, and hence is okay to put in the bindings.
    return TRUE;
}

void
CMachineName::SetNetBIOSName()
{
    CMutexLock lock(&_csMachineNameLock);
    if (!_pwszNetBiosName)
    {
        SetComputerNameHelper(ComputerNamePhysicalNetBIOS, &_pwszNetBiosName);
    }
}

void
CMachineName::SetDNSName()
{
    CMutexLock lock(&_csMachineNameLock);
    if (!_pwszDNSName)
    {
        SetComputerNameHelper(ComputerNamePhysicalDnsFullyQualified, &_pwszDNSName);
    }
}

void
CMachineName::SetComputerNameHelper(
				COMPUTER_NAME_FORMAT format,
				WCHAR** ppwszName				
				)
{
	BOOL fRet = FALSE;
    DWORD dwSize = 0;

    ASSERT(ppwszName);

    *ppwszName = NULL;
	
	// Get needed buffer size
	fRet = GetComputerNameEx(format, NULL, &dwSize);
	if (!fRet)
	{
		// Be resilient if failures occur, sometimes network
		// apis can be flaky during machine boot (for instance)
		if (GetLastError() == ERROR_MORE_DATA)
		{
			ASSERT(dwSize > 0);
			if (dwSize == 0)
				return;

			WCHAR* pwszName = new WCHAR[dwSize];
			if (!pwszName)
				return;

			// Get name for real
			fRet = GetComputerNameEx(format, pwszName, &dwSize);
			if (fRet)
			{
				// success
				*ppwszName = pwszName;
			}
			else
			{
				// still failed?  hmm
				ASSERT(0 && "Unexpected failure from GetComputerNameEx");
				delete [] pwszName;
			}
		}
	}

	return;    
}

BOOL
CMachineName::CompareHardCodedLocalHostNames(WCHAR* pwszName)
{
    ASSERT(pwszName);
    
    // Some localhost aliases don't show up in socket queries.

    if (!lstrcmpi(L"localhost", pwszName))
        return TRUE;

    if (!lstrcmpi(L"127.0.0.1", pwszName))
        return TRUE;

    return FALSE;
}

BOOL
CMachineName::CompareDynamicLocalHostNames(WCHAR* pwszName)
{
    DWORD i;

    ASSERT(pwszName);

    CMutexLock lock(&_csMachineNameLock);

    if (_aqdIPV4.pLocalOnlyAddresses)
    {
        for (i = 0; i < _aqdIPV4.pLocalOnlyAddresses->Count; i++)
        {
            if (!lstrcmpi(_aqdIPV4.pLocalOnlyAddresses->NetworkAddresses[i],
                          pwszName))
            {
                return TRUE;
            }
        }
    }
    
    if (_aqdIPV6.pLocalOnlyAddresses)
    {
        for (i = 0; i < _aqdIPV6.pLocalOnlyAddresses->Count; i++)
        {
            if (!lstrcmpi(_aqdIPV6.pLocalOnlyAddresses->NetworkAddresses[i],
                          pwszName))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL
CMachineName::QueryAddressesSpecific(ADDRESS_QUERY_DATA* paqd)
/*++

Routine Description:

    Retrieves a SOCKET_ADDRESS_LIST containing addresses supported by this 
    machine for the specified address family (ipv4 or ipv6) and stores
    it in either _pIPV4Addrs or _pIPV6Addrs.

Arguments:

    paqd - structure containing data with which to query addresses on

Return Value:

    TRUE  -- valid results are stored in paqd
    FALSE -- error occurred.  One or both of paqd->pAddresses and 
             paqd->pLocalAddresses may be NULL.

--*/
{
    int ret;
    BOOL fReturn = TRUE;
    DWORD dwBytesReturned;
    DWORD i;
    SOCKET* pSocket = NULL;
    SOCKET_ADDRESS_LIST** ppSocketAddrList = NULL;
    DWORD* pdwSocketAddrBufferSize = NULL;

    ASSERT(paqd->dwSig == ADDRQUERYDATA_SIG);

    // Allocate socket if we haven't already
    if (paqd->socket == INVALID_SOCKET)
    {
        paqd->socket = WSASocket(paqd->addrfamily,
							 SOCK_STREAM,
							 IPPROTO_TCP,
							 NULL,
							 0,
							 0
							 );
        if (paqd->socket == INVALID_SOCKET)
            return NULL;
        
        // else we got a socket for this addrfamily, which we keep forever.
    }

    while (TRUE)
    {
        ret = WSAIoctl(paqd->socket,
                       SIO_ADDRESS_LIST_QUERY,
                       NULL,
                       0,
                       (BYTE*)paqd->pSockAddrList,
                       paqd->dwSockAddrListBufferSize,
                       &dwBytesReturned,
                       NULL,
                       NULL);

        paqd->dwTotalTimesQueried++;

        if (ret == 0)
        {
            // Success
            break;
        }
        else
        {
            // Failed.  If need bigger buffer, allocate it
            // and try again. Otherwise fail.
            if (WSAGetLastError() == WSAEFAULT)
            {
                ASSERT(dwBytesReturned > paqd->dwSockAddrListBufferSize);

                if (paqd->pSockAddrList)
                {
                    ASSERT(paqd->dwSockAddrListBufferSize > 0);
                    PrivMemFree(paqd->pSockAddrList);
                    paqd->pSockAddrList = NULL;
                    paqd->dwSockAddrListBufferSize = 0;
                }
                else
                {
                    ASSERT(paqd->dwSockAddrListBufferSize == 0);
                }

                paqd->pSockAddrList = (SOCKET_ADDRESS_LIST*)PrivMemAlloc(dwBytesReturned);
                if (!(paqd->pSockAddrList))
                {
                    fReturn = FALSE;
                    break;
                }

                paqd->dwSockAddrListBufferSize = dwBytesReturned;
            }
            else
            {
                // some other error
                fReturn = FALSE;
                break;
            }
        }
    }

    if (fReturn)
    {
        // Build local-only vector
        if (!BuildVector(paqd, FALSE))
            fReturn = FALSE;

        // Build non-local-only vector
        if (!BuildVector(paqd, TRUE))
            fReturn = FALSE;
    }
    else
    {
        // if we failed above before calling BuildVector, then we need to
        // free and NULL pAddresses & pLocalAddresses so that downstream
        // code doesn't assume that they are pointing to valid contents.
        PrivMemFree(paqd->pAddresses);
        paqd->pAddresses = NULL;
        paqd->dwAddrVectorSize = 0;
        PrivMemFree(paqd->pLocalOnlyAddresses);
        paqd->pLocalOnlyAddresses = NULL;
        paqd->dwLocalAddrVectorSize = 0;
    }
	
    return fReturn;
}

BOOL
CMachineName::BuildVector(ADDRESS_QUERY_DATA* paqd, BOOL fLocalOnly)
{
    int i = 0;
    DWORD* pdwVectorSize = NULL;
    NetworkAddressVector** ppVector = NULL;
    DWORD dwTotalAddrs = 0;
    BOOL fIsGlobalAddress;

    ASSERT(paqd->dwSig == ADDRQUERYDATA_SIG);

    //
    // Sum up how many addresses of the non-local or local-only type there
    // are, so we know how much memory to allocate.
    //
    for (i = 0; i < paqd->pSockAddrList->iAddressCount; i++)
    {
        fIsGlobalAddress = (!paqd->pfnIsGlobalAddress ||
                    paqd->pfnIsGlobalAddress(paqd->pSockAddrList->Address[i].lpSockaddr));
        if ((fIsGlobalAddress && !fLocalOnly) || (!fIsGlobalAddress && fLocalOnly))
        {
            dwTotalAddrs++;
        }
    }

    if (fLocalOnly)
    {
        pdwVectorSize = &paqd->dwLocalAddrVectorSize;
        ppVector = &paqd->pLocalOnlyAddresses;
    }
    else
    {
        pdwVectorSize = &paqd->dwAddrVectorSize;
        ppVector = &paqd->pAddresses;
    }

    //
    // Build a vector of the specified addresses
    //
    DWORD dwBufSizeNeeded;

    //
    // Figure out how much space we need.   See comment below (right above call
    // to WSAAddressToString) regarding string buffer space required per address.
    //
    dwBufSizeNeeded = sizeof(NetworkAddressVector) +
                        (dwTotalAddrs * sizeof(WCHAR*)) +
                        (dwTotalAddrs * paqd->dwMaxAddrStringBufSize);

    // Figure out if we can use the old vector buffer, or allocate a new one
    if (*pdwVectorSize < dwBufSizeNeeded)
    {
        ASSERT((*pdwVectorSize > 0) ? (*ppVector != NULL) : (*ppVector == NULL));
        PrivMemFree(*ppVector);
        *pdwVectorSize = 0;
        *ppVector = (NetworkAddressVector*)PrivMemAlloc(dwBufSizeNeeded);
        if (!(*ppVector))
            return FALSE;
        *pdwVectorSize = dwBufSizeNeeded;
    }

    // Zero the buffer
    ASSERT(*ppVector);
    ZeroMemory(*ppVector, *pdwVectorSize);

    // Fill in the vector
    if (dwTotalAddrs > 0)
    {
        NetworkAddressVector* pVector = *ppVector;
        
        pVector->Count = dwTotalAddrs;
        pVector->StringBufferSpace = (dwTotalAddrs * paqd->dwMaxAddrStringBufSize);
        pVector->NetworkAddresses = (WCHAR**)&pVector[1];

        DWORD dwCurrentVectorAddress = 0;
        WCHAR* pszNextAddress = (WCHAR*)&pVector->NetworkAddresses[dwTotalAddrs];

        for (i = 0; 
             (i < paqd->pSockAddrList->iAddressCount) && (dwCurrentVectorAddress < dwTotalAddrs);
             i++)
        {
            BOOL fUseCurrentAddress;
            
            // Re-calculate if the current address in the sockaddrlist is going to
            // be put into the vector.
            fIsGlobalAddress = (!(paqd->pfnIsGlobalAddress) ||
                    paqd->pfnIsGlobalAddress(paqd->pSockAddrList->Address[i].lpSockaddr));

            fUseCurrentAddress = (fIsGlobalAddress && !fLocalOnly) || (!fIsGlobalAddress && fLocalOnly);

            if (fUseCurrentAddress)
            {
                int ret;
                DWORD dwAddrBufLen;

                dwAddrBufLen = paqd->dwMaxAddrStringBufSize;

                // Note that we are being slightly sloppy here.  In theory we could be
                // callling WSAAddressToString with a zero-size output buffer, and WSATS
                // would come back with an error and the exact required size of the buffer;
                // We could then do this across all addresses going into the vector.  However,
                // there are some network stack bugs that don't let this work for every
                // address type (ie, ipv6).  Hence, we play it safe and allocate a "maximum"
                // buffer space for every address.
                ret = WSAAddressToString(paqd->pSockAddrList->Address[i].lpSockaddr,
                                         paqd->pSockAddrList->Address[i].iSockaddrLength,
                                         NULL,
                                         pszNextAddress,
                                         &dwAddrBufLen);
                if (ret != 0)
                {
                    // An error occurred.  We don't expect "insufficient buffer" here, and other
                    // errors are not something we can recover from.  Cleanup and return NULL.
                    PrivMemFree(*ppVector);
                    *ppVector = NULL;
                    *pdwVectorSize = 0;
                    return FALSE;
                }
                else
                {
                    ASSERT(dwAddrBufLen <= paqd->dwMaxAddrStringBufSize);
                    ASSERT((((DWORD)lstrlenW(pszNextAddress) + 1) * sizeof(WCHAR)) <= paqd->dwMaxAddrStringBufSize);

                    // Write in address of just copied string
                    pVector->NetworkAddresses[dwCurrentVectorAddress] = pszNextAddress;

                    // Advance pointers to next free spot in the buffer
                    dwCurrentVectorAddress++;
                    pszNextAddress += (lstrlen(pszNextAddress) + 1);
                }
            }
            // else skip this address
        }

        ASSERT(dwCurrentVectorAddress == dwTotalAddrs);
    }
    else
    {
        // Zero addresses and the vector is already "empty" (it was
        // zeroed out above).  So nothing to do.
    }

    ValidateVector(*ppVector);

    return TRUE;
}

void
CMachineName::ValidateVector(NetworkAddressVector* pVector)
{
#ifdef DBG
    ASSERT(pVector);
    if (pVector->Count > 0)
    {
        ASSERT(pVector->StringBufferSpace > 0);
        ASSERT(pVector->NetworkAddresses != NULL);
        DWORD i;
        DWORD cchTotalStringSpace = 0;
        for (i = 0; i < pVector->Count; i++)
        {            
            BYTE* pStart = (BYTE*)&pVector->NetworkAddresses[pVector->Count];
            BYTE* pEnd = pStart + pVector->StringBufferSpace;            
            ASSERT((BYTE*)pVector->NetworkAddresses[i] >= pStart);
            ASSERT((BYTE*)pVector->NetworkAddresses[i] < pEnd);            
            cchTotalStringSpace += (lstrlenW(pVector->NetworkAddresses[i]) + 1);
        }

        ASSERT((cchTotalStringSpace * sizeof(WCHAR)) <= pVector->StringBufferSpace);
    }
    else
    {
        ASSERT(pVector->StringBufferSpace == 0);
        ASSERT(pVector->NetworkAddresses == NULL);
    }    
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\remact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      remact.cxx
//
//  Contents:
//
//      Implementation of binding handle cache to remote activation services.
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"
#include "misc.hxx"

CRemoteMachineList * gpRemoteMachineList = NULL;
CSharedLock * gpRemoteMachineLock = NULL;

// These globals are set to their defaults here, but can be overridden at boot
// time via registry knobs.  See ReadRemoteBindingHandleCacheKeys in registry.cxx.

// Also note that gdwRemoteBindingHandleCacheMaxSize cannot be adjusted after boot,
// but gdwRemoteBindingHandleCacheMaxLifetime and gdwRemoteBindingHandleCacheIdleTimeout can
// be played with in the debugger at will for those so inclined.
DWORD gdwRemoteBindingHandleCacheMaxSize = 16;      // in # of cache elements
DWORD gdwRemoteBindingHandleCacheMaxLifetime = 0;   // in minutes
DWORD gdwRemoteBindingHandleCacheIdleTimeout = 15;  // in minutes



class CRemActPPing : public CParallelPing
{
public:
    CRemActPPing(WCHAR          *pMachine) :
        _ndx(0),
        _pMachine(pMachine)
        {}


    BOOL NextCall(PROTSEQINFO *pProtseqInfo)
    {
        RPC_STATUS status;
        if (_ndx < cMyProtseqs)
        {
            status = CreateRemoteBinding(_pMachine,
                                         _ndx,
                                         &pProtseqInfo->hRpc);
            if (status != RPC_S_OK)
            {
                pProtseqInfo->hRpc = NULL;
            }
            pProtseqInfo->dwUserInfo = _ndx;
            _ndx++;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void ReleaseCall(PROTSEQINFO *pProtseqInfo)
    {
        if (pProtseqInfo->hRpc)
        {
            RpcBindingFree(&pProtseqInfo->hRpc);
        }
    }
private:
    DWORD           _ndx;
    WCHAR          *_pMachine;
};


//+---------------------------------------------------------------------------
//
//  Function:   RemoteActivationCall
//
//  Synopsis:   Finds or creates a machine object to cache binding handles
//              to the server machine and forwards the activation request
//              to it.
//
//----------------------------------------------------------------------------

HRESULT
RemoteActivationCall(
                    ACTIVATION_PARAMS * pActParams,
                    WCHAR *             pwszServerName )
{
    CRemoteMachine *    pRemoteMachine;
    WCHAR               wszPathForServer[MAX_PATH+1];
    WCHAR *             pwszPathForServer;
    HRESULT             hr;
    
    pActParams->activatedRemote = TRUE;
    
    ASSERT( pwszServerName );
    
    pwszPathForServer = 0;
    
    if ( pActParams->pwszPath )
    {
        hr = GetPathForServer( pActParams->pwszPath, wszPathForServer, &pwszPathForServer );
        if ( hr != S_OK )
            return hr;
    }
    
    pRemoteMachine = gpRemoteMachineList->GetOrAdd( pwszServerName );
    if ( ! pRemoteMachine )
        return E_OUTOFMEMORY;
    
    ASSERT(pActParams->pActPropsIn);
    BOOL fUseSystemId;
    pActParams->pActPropsIn->GetRemoteActivationFlags(&pActParams->fComplusOnly,
                                                      &fUseSystemId);    
    if (!fUseSystemId)
    {
        if (pActParams->pToken != NULL)
            pActParams->pToken->Impersonate();
        else
        {
            pRemoteMachine->Release();
            return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        }
    }
    
    IServerLocationInfo *pServerLocationInfo = NULL;
    ISpecialSystemProperties* pSSP = NULL;
    ULONG ulCurrentSessionId = 0;
    BOOL bUseConsole = FALSE;
    BOOL fRemoteThisSessionId = FALSE;
    pServerLocationInfo = pActParams->pActPropsIn->GetServerLocationInfo();
    ASSERT(pServerLocationInfo != NULL);
    pServerLocationInfo->SetRemoteServerName(NULL);
    
    //
    // Session id's should flow off-machine only when explicitly told to; make sure
    // this is the case:
    //
    hr = pActParams->pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**)&pSSP);
    if (SUCCEEDED(hr))
    {
        pSSP->GetSessionId2(&ulCurrentSessionId, &bUseConsole, &fRemoteThisSessionId);
        if (!fRemoteThisSessionId)
        {
            hr = pSSP->SetSessionId(INVALID_SESSION_ID, FALSE, FALSE);
            ASSERT(SUCCEEDED(hr) && "SetSessionId failed");
        }
    }
    
    //
    // Try the activation:
    //
    hr = pRemoteMachine->Activate( pActParams, pwszPathForServer );
    
    //
    // Restore session id just in case the activation ends up being re-tried (for
    // whatever reason) on this machine (eg, if a load-balancing activator is loaded)
    //
    if (!fRemoteThisSessionId)
    {
        HRESULT hrLocal;
        hrLocal = pSSP->SetSessionId(ulCurrentSessionId, bUseConsole, FALSE);
        ASSERT(SUCCEEDED(hrLocal) && "SetSessionId failed");
    }
    
    if (pSSP)
        pSSP->Release();
    
    pRemoteMachine->Release();
    
    if (!fUseSystemId)
        pActParams->pToken->Revert();
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::GetOrAdd
//
//  Synopsis:   Scans the machine list for a matching name.  Returns it if
//              found.  Otherwise, creates a machine list entry.   Returned
//              object is refcounted.
//
//  Changes:    jsimmons    4/6/00      Fix for bug 22803 -- cap cache size
//
//----------------------------------------------------------------------------

CRemoteMachine *
CRemoteMachineList::GetOrAdd(
                            IN  WCHAR * pwszMachine
                            )
{
    CRemoteMachine *    pMachine;
    WCHAR *             pwszMachineCopy;
    WCHAR *             pwszScmSPNCopy;

    gpRemoteMachineLock->LockExclusive();

    for ( pMachine = (CRemoteMachine *) First();
        pMachine;
        pMachine = (CRemoteMachine *) pMachine->Next() )
    {
        if ( lstrcmpiW( pMachine->_pwszMachine, pwszMachine ) == 0 )
        {
            pMachine->_dwLastUsedTickCount = GetTickCount();
            pMachine->AddRef();  // add caller reference
            break;
        }
    }
	
    if ( ! pMachine )
    {
        pwszMachineCopy = (WCHAR *) PrivMemAlloc( (lstrlenW( pwszMachine ) + 1) * sizeof(WCHAR) );
        if (pwszMachineCopy)
        {
            pwszScmSPNCopy = (WCHAR *) PrivMemAlloc( (lstrlenW( pwszMachine ) +
                                                     (sizeof(RPCSS_SPN_PREFIX) / sizeof(WCHAR))
                                                      + 1) * sizeof(WCHAR) );
            if (pwszScmSPNCopy)
            {
                lstrcpyW( pwszMachineCopy, pwszMachine );

                // Form server principal name for the remote scm
                lstrcpyW( pwszScmSPNCopy, RPCSS_SPN_PREFIX);
                lstrcatW( pwszScmSPNCopy, pwszMachine);

                pMachine = new CRemoteMachine( pwszMachineCopy, pwszScmSPNCopy);
                // constructed with refcount of 1, don't addref it again
                if ( pMachine )
                {
                    // Only attempt to save new object in cache if cache size > 0:
                    if (_dwMaxCacheSize > 0)
                    {
                        ASSERT(_dwCacheSize <= _dwMaxCacheSize);
                        if (_dwCacheSize == _dwMaxCacheSize)
                        {
                            // Cache has no more room.  Dump the oldest one
                            RemoveOldestCacheElement();

                            ASSERT(_dwCacheSize < _dwMaxCacheSize);
                        }

                        Insert( pMachine );
                        pMachine->AddRef();  
                        _dwCacheSize++;
                        ASSERT(_dwCacheSize <= _dwMaxCacheSize);
                    }
                }
                else
                {
                    PrivMemFree( pwszMachineCopy );
                    PrivMemFree( pwszScmSPNCopy );
                }
            }
            else
            {
                PrivMemFree(pwszMachineCopy);
            }
        }
    }
    
    gpRemoteMachineLock->UnlockExclusive();
	
    return pMachine;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::CRemoteMachine
//
//  Synopsis:   Looks thru the cache for the lru element and removes it.
//
//----------------------------------------------------------------------------
void CRemoteMachineList::RemoveOldestCacheElement()
{
    ASSERT(_dwCacheSize > 0);
    ASSERT(gpRemoteMachineLock->HeldExclusive());

    CRemoteMachine* pLRUMachine = (CRemoteMachine*)First();
    CRemoteMachine* pMachine = (CRemoteMachine*)pLRUMachine->Next();

    while (pMachine)
    {
        if (pMachine->_dwLastUsedTickCount < pLRUMachine->_dwLastUsedTickCount)
        {
            pLRUMachine = pMachine;
        }
        pMachine = (CRemoteMachine*)pMachine->Next();
    }

    Remove(pLRUMachine);
    pLRUMachine->Release();
    _dwCacheSize--;
    
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::FlushSpecificBindings
//
//  Synopsis:   Looks thru the cache for the specified element and removes it
//              from the cache if found.
//
//  Arguments:  [pszMachine] -- name of the machine to flush from the cache.  Can
//                be ""; this means all bindings should be flushed
//
//  Returns:    S_OK -- the specified bindings were found and flushed
//              CO_S_MACHINENAMENOTFOUND -- if "" was passed, means the cache was 
//                 empty; otherwise means that the specified machine name was not
//                 found in the cache.
//
//----------------------------------------------------------------------------
HRESULT CRemoteMachineList::FlushSpecificBindings(WCHAR* pszMachine)
{
    HRESULT hr = CO_S_MACHINENAMENOTFOUND;
    BOOL bFlushAll = (0 == lstrcmpW(pszMachine, L""));
    CRemoteMachine* pMachine;
    CRemoteMachine* pNextMachine;

    gpRemoteMachineLock->LockExclusive();
    
    if (bFlushAll)
    {
        // Loop thru and release all of them
        while (pMachine = (CRemoteMachine*)First())
        {
            Remove(pMachine);
            pMachine->Release();
            _dwCacheSize--;
            hr = S_OK;  // there was at least one item in the cache, so return S_OK
        }
    }
    else
    {
        // Loop thru looking for the specified machine name
        pMachine = (CRemoteMachine*)First();

        while (pMachine)
        {
            if (lstrcmpiW(pszMachine, pMachine->_pwszMachine) == 0)
            {
                // Found it
                Remove(pMachine);
                pMachine->Release();
                _dwCacheSize--;
                hr = S_OK;  // found it so return S_OK
                break;
            }
            pMachine = (CRemoteMachine*)pMachine->Next();
        }
    }
    
    gpRemoteMachineLock->UnlockExclusive();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::TryToFlushIdleOrTooOldElements
//
//  Synopsis:   Looks thru the cache for elements which have either 1) not been
//     used for a period than the idle timeout period; or 2) been in the cache
//     longer than the maximum allowable period.    If any are found they are
//     deleted from the cache.
//
//  Arguments:  none
//
//  Returns:    void
//
//----------------------------------------------------------------------------
void CRemoteMachineList::TryToFlushIdleOrTooOldElements()
{
    CRemoteMachine* pMachine;
    CRemoteMachine* pNextMachine;
    DWORD dwNow = GetTickCount();
    DWORD dwIdleTimeout = gdwRemoteBindingHandleCacheIdleTimeout * 1000 * 60;
    DWORD dwLifetimeTimeout = gdwRemoteBindingHandleCacheMaxLifetime * 1000 * 60;
	
    if (!dwIdleTimeout && !dwLifetimeTimeout)
        return; // nothing to do

    gpRemoteMachineLock->LockExclusive();
        
    pMachine = (CRemoteMachine*)First();

    while (pMachine)
    {
        BOOL bRemoveCurrentItem;

        bRemoveCurrentItem = FALSE;

        // Check if it's been idle too long
        if (dwIdleTimeout > 0)
        {
            if (dwNow - pMachine->_dwLastUsedTickCount > dwIdleTimeout)
            {
                bRemoveCurrentItem = TRUE;
            }
        }
        
        // Check if it's been around too long, period
        if (dwLifetimeTimeout > 0)
        {
            if (dwNow - pMachine->_dwTickCountAtCreate > dwLifetimeTimeout)
            {
                bRemoveCurrentItem = TRUE;
            }
        }

        pNextMachine = (CRemoteMachine*)pMachine->Next();

        if (bRemoveCurrentItem)
        {
            Remove(pMachine);
            pMachine->Release();
            _dwCacheSize--;
        }
    
        pMachine = pNextMachine;
    }
                    
    gpRemoteMachineLock->UnlockExclusive();
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESCMBindingHandleFlush
//
//  Synopsis:   This function gets called periodically by objex's worker 
//     thread.  It gives us a chance to flush idle or too-old cache elements
//     in the remote binding handle cache.
//
//----------------------------------------------------------------------------
void OLESCMBindingHandleFlush()
{
    gpRemoteMachineList->TryToFlushIdleOrTooOldElements();
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::CRemoteMachine
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CRemoteMachine::CRemoteMachine(
                              IN WCHAR * pwszMachine,
                              IN WCHAR * pwszScmSPN
                              )
{
    _pwszMachine = pwszMachine;
    _pwszScmSPN  = pwszScmSPN;
    _dsa         = NULL;
    _ulRefCount  = 1;  // starts with non-zero refcount
    _dwLastUsedTickCount = GetTickCount();
    _dwTickCountAtCreate = _dwLastUsedTickCount;

    _fUseOldActivationInterface = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::CRemoteMachine
//
//  Synopsis:   Destructor
//  
//----------------------------------------------------------------------------
CRemoteMachine::~CRemoteMachine()
{
    ASSERT(_ulRefCount == 0);
    
    // We don't need to hold a lock to flush the bindings, 
    // since no one else has a reference to us.
    FlushBindingsNoLock();

    if (_pwszMachine)
        PrivMemFree(_pwszMachine);
    if (_pwszScmSPN)
        PrivMemFree(_pwszScmSPN);
    if (_dsa)
        _dsa->Release();
}

// AddRef function
ULONG CRemoteMachine::AddRef()
{
    return InterlockedIncrement((PLONG)&_ulRefCount);
}

// Release function
ULONG CRemoteMachine::Release()
{
    ULONG ulNewRefCount = InterlockedDecrement((PLONG)&_ulRefCount);
    if (ulNewRefCount == 0)
    {
        delete this;
    }
    return ulNewRefCount;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::Activate
//
//  Synopsis:   Picks a protocol and authentication service to use to call
//              the server machine.  Forwards the activation request to
//              CallRemoteMachine.
//
//  Description:
//
//  This method tries several different methods to get a binding handle.
//      Look for auth info match in cache
//      Look for any binding handle in cache
//      Ping server to find valid protocol sequence
//
//  After it gets a binding handle, it tries to pick auth info.
//      Use client params if specified
//      Use cached params if they exist
//      Try all auth svc valid on client and server
//      Try unsecure
//
//  This function maintains a cache of binding handles with the following
//  rules.
//      - All binding handles in the cache at any point in time use the same
//      protocol sequence.
//      - The best non-custom authentication info is before any other
//      non-custom authentication info.
//      - The cache is flushed if the protocol is competely invalid.
//      - If a cached entry gets a non security error, it is discarded
//      (security errors may be due to the current credentials rather then
//      the binding handle itself).
//      - Only binding handles that actually worked once are cached.
//
//----------------------------------------------------------------------------
HRESULT
CRemoteMachine::Activate(
                        IN  ACTIVATION_PARAMS * pActParams,
                        IN  WCHAR *             pwszPathForServer
                        )
{
    CMachineBinding *   pMachineBinding;
    handle_t            hBinding = NULL;
    BOOL                bNoEndpoint;
    BOOL                bStatus;
    HRESULT             hr = E_OUTOFMEMORY;
    USHORT              AuthnSvc;
    USHORT              ProtseqId = 0;
    DWORD               AuthnLevel;
    RPC_STATUS          Status = RPC_S_INTERNAL_ERROR;

    // Try to use a cached handle first.
    if (pActParams->pAuthInfo != NULL)
        AuthnSvc = (USHORT) pActParams->pAuthInfo->dwAuthnSvc;
    else
        AuthnSvc = AUTHN_ANY;

    
    hr = GetAuthnLevel(pActParams, &AuthnLevel);
    if (FAILED(hr))
        return hr;

    pMachineBinding = LookupBinding( AuthnSvc, AuthnLevel, pActParams->pAuthInfo );
    if ( pMachineBinding )
    {
        AuthnSvc = pMachineBinding->_AuthnSvc;
        Status = pMachineBinding->GetMarshaledTargetInfo(&pActParams->ulMarshaledTargetInfoLength, &pActParams->pMarshaledTargetInfo);
        if (Status == RPC_S_OK) 
        {
           Status = CallRemoteMachine(pMachineBinding->_hBinding,
                                      pMachineBinding->_ProtseqId,
                                      pActParams, 
                                      pwszPathForServer, 
                                      _pwszMachine, 
                                      _fUseOldActivationInterface,
                                      &hr);
        }
        if (Status == RPC_S_OK)
        {
            pActParams->AuthnSvc = AuthnSvc;
            pMachineBinding->Release();
            return hr;
        }

        // Throw away the binding if it is unlikely to work again in the
        // future.
        else if (Status != RPC_S_ACCESS_DENIED &&
                 Status != RPC_S_SEC_PKG_ERROR)
        {
            RemoveBinding( pMachineBinding );
        }
        pMachineBinding->Release();
    }

    // Throw away all bindings if the protocol is unlikely to work
    // again.
    if (Status == RPC_S_SERVER_UNAVAILABLE ||
        Status == EPT_S_NOT_REGISTERED)
    {
        FlushBindings();
    }
    // Get any binding handle from the cache.
    else
    {
        gpRemoteMachineLock->LockShared();
        pMachineBinding = (CMachineBinding *) _BindingList.First();
        if (pMachineBinding != NULL)
        {
            Status = RpcBindingCopy( pMachineBinding->_hBinding, &hBinding );
            if (Status == RPC_S_OK)
            {
                ASSERT(hBinding != NULL);
                ProtseqId = pMachineBinding->_ProtseqId;
            }
            else
                hBinding = NULL;
        }
        gpRemoteMachineLock->UnlockShared();

        // Try to find auth info that will work.
        if (hBinding != NULL)
        {
            Assert (pMachineBinding != NULL);            
            Status = PickAuthnAndActivate( pActParams, pwszPathForServer,
                                           &hBinding, AuthnSvc, AuthnLevel,
                                           ProtseqId, &hr );
            if (Status == RPC_S_OK)
            {
                Assert( hBinding == NULL );
                return hr;
            }
            else
            {
                // Stop if the activation failed but the protocol was
                // probably good.
                Assert( hBinding != NULL );
                RpcBindingFree( &hBinding );
                hBinding = NULL;
                if (Status != RPC_S_SERVER_UNAVAILABLE &&
                    Status != EPT_S_NOT_REGISTERED)
                {
                    if (Status == RPC_S_ACCESS_DENIED)
                    {
                        // Don't map security errors as this is just confusing.
                        return HRESULT_FROM_WIN32(RPC_S_ACCESS_DENIED);
                    }
                    else
                    {
                        LogRemoteSideUnavailable( pActParams->ClsContext, _pwszMachine );
                        return HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
                    }
                }
            }
        }
    }

    // No cached binding handles worked.  Try to ping for one.
    {
        CRemActPPing ping(_pwszMachine);

        // This loop only executes twice if we need to try the call without
        // an endpoint specified.
        //
        bNoEndpoint = FALSE;
        for (;;)
        {
            Status = ping.Ping();
            if ( RPC_S_UNKNOWN_IF == Status )
            {
                if ( ! bNoEndpoint )
                {
                    for ( ULONG ProtseqIndex = 0; ProtseqIndex < ping.HandleCount(); ProtseqIndex++ )
                    {
                        RPC_BINDING_HANDLE tmpBinding;
                        Status = RpcBindingCopy( ping.Info(ProtseqIndex)->hRpc, &tmpBinding);

                        if (Status != RPC_S_OK)
                            break;

                        Status = RpcBindingFree( &(ping.Info(ProtseqIndex)->hRpc));

                        if (Status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }

                        Status = RpcBindingReset(tmpBinding);
                        if (Status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }

                        ping.Info(ProtseqIndex)->hRpc = tmpBinding;
                    }
                    if (Status == RPC_S_OK)
                    {
                        bNoEndpoint = TRUE;
                        continue;
                    }
                }
            }
            break;
        }
        if (Status == RPC_S_OK)
        {
            gpRemoteMachineLock->LockExclusive();
            if (_dsa != NULL)
                _dsa->Release();
            hBinding               = ping.GetWinner()->hRpc;
            ping.GetWinner()->hRpc = NULL;
            _dsa                   = ping.TakeOrBindings();
            ProtseqId              = aMyProtseqs[ping.GetWinner()->dwUserInfo];
            ASSERT( hBinding != NULL );

            //
            // If this is not a win2k or better system, then use the old activation
            // interface.  Otherwise, use the new activation interface.
            //
            if (ping.GetWinner()->comVersion.MinorVersion < 6)
            {
                _fUseOldActivationInterface = TRUE;
            }
            else
            {
                _fUseOldActivationInterface = FALSE;
            }

            gpRemoteMachineLock->UnlockExclusive();
        }

        ping.Reset();

    }

    // Try auth info with the new binding.
    if (hBinding != NULL)
    {
        // We've had to re-bind.  Make sure we've still decided on
        // the right authentication level here.
        hr = GetAuthnLevel(pActParams, &AuthnLevel);
        if (SUCCEEDED(hr))
        {
            Status = PickAuthnAndActivate( pActParams, pwszPathForServer,
                                           &hBinding, RPC_C_AUTHN_NONE, 
                                           AuthnLevel, ProtseqId, &hr );
            if (Status == RPC_S_OK)
            {
                // asserts that in success cases binding was added to the cache
                Assert( hBinding == NULL );
            }
        }
    }


    // If the call never worked, return a nice error code.
    // except for security errors.
    if (Status != RPC_S_OK)
    {
        if (Status == RPC_S_ACCESS_DENIED)
            hr = HRESULT_FROM_WIN32(RPC_S_ACCESS_DENIED);
        else
        {
            hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
            LogRemoteSideUnavailable( pActParams->ClsContext, _pwszMachine );
        }
    }

    // Clean up resources.
    if (hBinding != NULL)
        RpcBindingFree( &hBinding );
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::GetAuthnLevel
//
//  Synopsis:   Figures out what the authentication level for this call ought
//              to be.
//
//----------------------------------------------------------------------------
HRESULT CRemoteMachine::GetAuthnLevel(ACTIVATION_PARAMS *pActParams, DWORD *pdwDefaultAuthnLevel)
{
    ISpecialSystemProperties *pSpecialSystemProperties;
    HRESULT hr = S_OK;

    if (pActParams->pAuthInfo)
    {
        *pdwDefaultAuthnLevel = pActParams->pAuthInfo->dwAuthnLevel;
    }
    else
    {
        // Get the default authentication level from the actprops, if we're talking over
        // the "new" style interface.
        if (!_fUseOldActivationInterface)
        {
            hr = pActParams->pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, 
                                                         (void **)&pSpecialSystemProperties);
            if (SUCCEEDED(hr))
            {
                hr = pSpecialSystemProperties->GetDefaultAuthenticationLevel(pdwDefaultAuthnLevel);
                pSpecialSystemProperties->Release();
                
                if (SUCCEEDED(hr))
                {
                    if (*pdwDefaultAuthnLevel < RPC_C_AUTHN_LEVEL_CONNECT)
                    {
                        // Don't do the activation at less than connect. 
                        *pdwDefaultAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
                    }
                }
            }
        }
        else
        {
            // Always use RPC_C_AUTHN_LEVEL_CONNECT for talking to < Win2k servers.
            *pdwDefaultAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::PickAuthnAndActivate
//
//  Synopsis:   Determine what authentication information to use for the
//              activation.  The AuthnSvc parameter indicates an
//              authentication service that was already tried.
//
//----------------------------------------------------------------------------
RPC_STATUS CRemoteMachine::PickAuthnAndActivate(
                        IN  ACTIVATION_PARAMS * pActParams,
                        IN  WCHAR *             pwszPathForServer,
                        IN  handle_t          * pBinding,
                        IN  USHORT              AuthnSvc,
                        IN  DWORD               AuthnLevel,
                        IN  USHORT              ProtseqId,
                        OUT HRESULT           * phr )
{
    RPC_SECURITY_QOS    Qos;
    DWORD               i;
    RPC_STATUS          Status;
    CMachineBinding    *pMachineBinding;
    BOOL                fTry;
    CDualStringArray   *pdsa    = NULL;
    HRESULT             hr = S_OK;

    // If the client specified security, try exactly the settings requested.
    Qos.Version                    = RPC_C_SECURITY_QOS_VERSION;
    pActParams->UnsecureActivation = FALSE;
    if (pActParams->pAuthInfo)
    {
        // Set the requested authentication information.
        AuthnSvc              = (USHORT) pActParams->pAuthInfo->dwAuthnSvc;
        pActParams->AuthnSvc  = (USHORT) pActParams->pAuthInfo->dwAuthnSvc;
        AuthnLevel            = pActParams->pAuthInfo->dwAuthnLevel;
        Qos.Capabilities      = pActParams->pAuthInfo->dwCapabilities;
        Qos.ImpersonationType = pActParams->pAuthInfo->dwImpersonationLevel;
        if (pActParams->pAuthInfo->pAuthIdentityData != NULL)
            Qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        else
            Qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        
        Status = RpcBindingSetAuthInfoExW(
                *pBinding,
                pActParams->pAuthInfo->pwszServerPrincName,
                pActParams->pAuthInfo->dwAuthnLevel,
                pActParams->pAuthInfo->dwAuthnSvc,
                pActParams->pAuthInfo->pAuthIdentityData,
                pActParams->pAuthInfo->dwAuthzSvc,
                &Qos );
          
        // Try the activation.
        if (Status == RPC_S_OK)
        {
            Status = CallRemoteMachine(*pBinding,
                                       ProtseqId,
                                       pActParams, 
                                       pwszPathForServer,                                        
                                       _pwszMachine, 
                                       _fUseOldActivationInterface,
                                       phr);
        }
    }
    // Try all authentication services and then try unsecure.
    else
    {
        // Get a reference to the dual string array.
        gpRemoteMachineLock->LockShared();
        pdsa = _dsa;
        if (pdsa) pdsa->AddRef();
        gpRemoteMachineLock->UnlockShared();
        
        // Initialize the QOS structure.
        Qos.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        Qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        Qos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
        
        // Loop over the authentication services.
        Status = RPC_S_INTERNAL_ERROR;
        for (i = 0; i < s_cRpcssSvc; i++)
        {
            // Skip the authentication service that was already tried.
            if (s_aRpcssSvc[i].wId == AuthnSvc)
                continue;
            
            // If there are no security bindings, only try NTLM.
            if (pdsa == NULL)
            {
                fTry = s_aRpcssSvc[i].wId == RPC_C_AUTHN_WINNT;
            }            
            else
            {
                // If there are security bindings, try the next authentication
                // service if both machines use it.
                fTry = ValidAuthnSvc( pdsa->DSA(), s_aRpcssSvc[i].wId );
            }
            
            if (fTry)
            {
                BOOL   bSetSecurityCallBack = FALSE;
                USHORT usAuthSvcFromCallback = RPC_C_AUTHN_GSS_NEGOTIATE;
                
                // Set the security.
                Status = RPC_S_OK;
                if (s_aRpcssSvc[i].wId == RPC_C_AUTHN_GSS_NEGOTIATE)
                {
                    // Using snego, compute list of compatible authnsvcs:
                    ASSERT(pdsa);
                    // if using snego, we need to know what sec pkg is eventually negotiated:
                    if (gpCRpcSecurityCallbackMgr->RegisterForRpcAuthSvcCallBack(*pBinding))
                       bSetSecurityCallBack = TRUE;
                }
                
                if (Status == RPC_S_OK)
                {
                    Status = RpcBindingSetAuthInfoEx(
                                            *pBinding,
                                            _pwszScmSPN,
                                            AuthnLevel,
                                            s_aRpcssSvc[i].wId,
                                            NULL,
                                            0,
                                            &Qos );

                }
                
                if (Status != RPC_S_OK)
                {
                    if (bSetSecurityCallBack)
                       gpCRpcSecurityCallbackMgr->GetSecurityContextDetailsAndTurnOffCallback(*pBinding, NULL, 
                                                  &pActParams->ulMarshaledTargetInfoLength, &pActParams->pMarshaledTargetInfo);
                }
                
                // Try the activation.
                if (Status == RPC_S_OK)
                {
                    Status = CallRemoteMachine(*pBinding,
                                               ProtseqId,
                                               pActParams, 
                                               pwszPathForServer,                                        
                                               _pwszMachine, 
                                               _fUseOldActivationInterface,
                                               phr);
                    if (bSetSecurityCallBack)
                    {
                        //
                        //  Only ask for the result of the callback if the call went through; otherwise
                        //  just cancel the registration.
                        //
                        if (Status == RPC_S_OK)
                        {
                           if (!gpCRpcSecurityCallbackMgr->GetSecurityContextDetailsAndTurnOffCallback(*pBinding,
                               &usAuthSvcFromCallback, &pActParams->ulMarshaledTargetInfoLength, &pActParams->pMarshaledTargetInfo))
                           {
                              // something went wrong.  In this case we don't trust what the callback
                              // told us.   Fall back on the original behavior
                              bSetSecurityCallBack = FALSE;
                           }
                        }
                        else
                        {
                            // cancel the callback
                           gpCRpcSecurityCallbackMgr->GetSecurityContextDetailsAndTurnOffCallback(*pBinding, NULL,
                                                      &pActParams->ulMarshaledTargetInfoLength, &pActParams->pMarshaledTargetInfo);
                           bSetSecurityCallBack = FALSE;
                        }
                    }
                    
                    if (Status == RPC_S_OK                 ||
                        Status == RPC_S_SERVER_UNAVAILABLE ||
                        Status == EPT_S_NOT_REGISTERED)
                    {
                        if (bSetSecurityCallBack)
                        {
                            // snego call, and we succesfully got a callback telling us
                            // what the real authentication service was
                            if (usAuthSvcFromCallback == RPC_C_AUTHN_GSS_KERBEROS)
                            {
                                // if we got back kerberos we're going to cache snego anyway; this
                                // helps NTLM-only clients who can't use kerberos
                                pActParams->AuthnSvc = AuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
                            }
                            else
                                pActParams->AuthnSvc = AuthnSvc = usAuthSvcFromCallback;
                        }
                        else
                        {
                            // non-snego, or something went wrong with security callback
                            // on a snego call
                            pActParams->AuthnSvc = AuthnSvc = s_aRpcssSvc[i].wId;
                        }
                        break;
                    }
                }
            }
        }
        
        if (pdsa)
        {
            pdsa->Release();
            pdsa = NULL;
        }
        
        // If no authentication services worked and the protocol doesn't
        // look bad, try no authentication
        if (Status != RPC_S_OK                 &&
            Status != RPC_S_SERVER_UNAVAILABLE &&
            Status != EPT_S_NOT_REGISTERED)
        {
            // remember that unsecure activation was done.
            // This will be used later when creating the MID
            // so we do unsecure pinging also.
            pActParams->UnsecureActivation = TRUE;
            
            // Look for a cached unsecure binding handle.
            pMachineBinding = LookupBinding( RPC_C_AUTHN_NONE, RPC_C_AUTHN_LEVEL_NONE, NULL );
            if ( pMachineBinding )
            {
                Status = CallRemoteMachine(pMachineBinding->_hBinding,
                                           pMachineBinding->_ProtseqId,
                                           pActParams, 
                                           pwszPathForServer, 
                                           _pwszMachine, 
                                           _fUseOldActivationInterface,
                                           phr);
                                
                // Throw away the binding handle received as a parameter so
                // it doesn't get cached.
                if (Status == RPC_S_OK)
                {
                    RpcBindingFree( pBinding );
                    *pBinding = NULL;
                }
                
                // Throw away the binding if it is unlikely to work again in the
                // future.
                else
                {
                    RemoveBinding( pMachineBinding );
                }
                pMachineBinding->Release();
            }
            
            // Make the current binding handle unsecure.
            else
            {
                // Set the authentication information.
                Status =  RpcBindingSetAuthInfoEx(
                                    *pBinding,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_NONE,
                                    RPC_C_AUTHN_NONE,
                                    NULL,
                                    0,
                                    NULL );
                if (Status == RPC_S_OK)
                {
                    AuthnSvc = RPC_C_AUTHN_NONE;
                    AuthnLevel = RPC_C_AUTHN_LEVEL_NONE;

                    Status = CallRemoteMachine(
                                        *pBinding,
                                        ProtseqId,
                                        pActParams,
                                        pwszPathForServer,
                                        _pwszMachine,
                                        _fUseOldActivationInterface,
                                        phr );
                }
            }
        }
    }
    
    if (Status == RPC_S_OK && *pBinding != NULL)
    {
        //
        // The call completed.  We now cache this binding handle.
        // Caching is just an optimization so we don't care if this
        // insert fails.
        //
        InsertBinding(
            *pBinding,
            ProtseqId,
            AuthnSvc,
            pActParams->ulMarshaledTargetInfoLength,
            pActParams->pMarshaledTargetInfo,
            AuthnLevel,
            pActParams->pAuthInfo);
        *pBinding = NULL;
    }
    // Throw away all bindings if the protocol is unlikely to work
    // again.
    else if (Status == RPC_S_SERVER_UNAVAILABLE ||
             Status == EPT_S_NOT_REGISTERED)
    {
        FlushBindings();
    }

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::LookupBinding
//
//  Synopsis:   Scan the binding list for a binding with matching
//              authentication information
//
//----------------------------------------------------------------------------
CMachineBinding *
CRemoteMachine::LookupBinding(
                             IN  USHORT              AuthnSvc,
                             IN  DWORD               AuthnLevel,
                             IN  COAUTHINFO *        pAuthInfo OPTIONAL
                             )
{
    CMachineBinding * pMachineBinding;

    gpRemoteMachineLock->LockShared();

    for ( pMachineBinding = (CMachineBinding *) _BindingList.First();
        pMachineBinding;
        pMachineBinding = (CMachineBinding *) pMachineBinding->Next() )
    {
        if ( pMachineBinding->Equal( AuthnSvc, AuthnLevel, pAuthInfo ) )
        {
            pMachineBinding->Reference();
            break;
        }
    }

    gpRemoteMachineLock->UnlockShared();

    return pMachineBinding;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::FlushBindings
//
//  Synopsis:   Release all entries under a lock
//
//----------------------------------------------------------------------------
void
CRemoteMachine::FlushBindings()
{
    gpRemoteMachineLock->LockExclusive();
	
    FlushBindingsNoLock();

    gpRemoteMachineLock->UnlockExclusive();
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::FlushBindingsNoLock
//
//  Synopsis:   Release all entries without taking a lock first.
//
//----------------------------------------------------------------------------
void CRemoteMachine::FlushBindingsNoLock()
{
    CMachineBinding * pMachineBinding;
    
    while ( pMachineBinding = (CMachineBinding *) _BindingList.First() )
    {
        _BindingList.Remove( pMachineBinding );
        pMachineBinding->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::InsertBinding
//
//  Synopsis:   Add the specified binding handle to the cache of binding
//              handles for this machine.  Free it if the insertion fails.
//
//----------------------------------------------------------------------------
void
CRemoteMachine::InsertBinding(
                             IN  handle_t            hBinding,
                             IN  USHORT              ProtseqId,
                             IN  USHORT              AuthnSvc,
                             IN  unsigned long       ulMarshaledTargetInfoLength,
                             IN  unsigned char*      pMarshaledTargetInfo,
                             IN  DWORD               AuthnLevel,
                             IN  COAUTHINFO *        pAuthInfo OPTIONAL)
{
    CMachineBinding *   pMachineBinding;
    CMachineBinding *   pExistingBinding;
    COAUTHINFO *        pAuthInfoCopy;

    pAuthInfoCopy = 0;
    pMachineBinding = 0;

    if (pAuthInfo && pAuthInfo->pAuthIdentityData)
    {
        // Cannot cache this particular binding.  
        // Just free the binding handle.
        RpcBindingFree( &hBinding );
        return;
    }

    if ( ! pAuthInfo || (CopyAuthInfo( pAuthInfo, &pAuthInfoCopy ) == S_OK) )
    {
        pMachineBinding = new CMachineBinding(
                                             hBinding,
                                             ProtseqId,
                                             AuthnSvc,
                                             AuthnLevel,
                                             pAuthInfoCopy);
    }
    
    if ( ! pMachineBinding )
    {
        RpcBindingFree( &hBinding );
        return;
    }

    gpRemoteMachineLock->LockExclusive();

    for ( pExistingBinding = (CMachineBinding *) _BindingList.First();
        pExistingBinding;
        pExistingBinding = (CMachineBinding *) pExistingBinding->Next() )
    {
        if ( pExistingBinding->Equal( AuthnSvc, AuthnLevel, pAuthInfoCopy ) )
            break;
    }

    if ( ! pExistingBinding )
    {
       pMachineBinding->SetMarshaledTargetInfo(ulMarshaledTargetInfoLength, pMarshaledTargetInfo);
       _BindingList.Insert( pMachineBinding );
    }

    gpRemoteMachineLock->UnlockExclusive();

    if ( pExistingBinding )
    {
        // Will delete the new binding we created above.
        pMachineBinding->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::RemoveBinding
//
//  Synopsis:   Remove the specified binding handle from the cache for
//              this machine.
//
//----------------------------------------------------------------------------
void
CRemoteMachine::RemoveBinding(
                             IN  CMachineBinding * pMachineBinding
                             )
{
    CMachineBinding * pBinding;

    gpRemoteMachineLock->LockExclusive();

    for ( pBinding = (CMachineBinding *) _BindingList.First();
        pBinding;
        pBinding = (CMachineBinding *) pBinding->Next() )
    {
        if ( pBinding == pMachineBinding )
        {
            _BindingList.Remove( pMachineBinding );
            pMachineBinding->Release();
            break;
        }
    }

    gpRemoteMachineLock->UnlockExclusive();
}

//+---------------------------------------------------------------------------
//
//  Function:   CMachineBinding::CMachineBinding
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------

//
// CMachineBinding
//
CMachineBinding::CMachineBinding(
                                IN  handle_t        hBinding,
                                IN  USHORT          ProtseqId,
                                IN  USHORT          AuthnSvc,
                                IN  DWORD           AuthnLevel,
                                IN  COAUTHINFO *    pAuthInfo OPTIONAL
                                )
{
    _hBinding   = hBinding;
    _ProtseqId  = ProtseqId;
    _AuthnSvc   = AuthnSvc;
    _AuthnLevel = AuthnLevel;
    _pAuthInfo  = pAuthInfo;
    _ulMarshaledTargetInfoLength = 0;
    _pMarshaledTargetInfo = NULL;
    
    ASSERT(pAuthInfo == NULL || pAuthInfo->pAuthIdentityData == NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   CMachineBinding::~CMachineBinding
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CMachineBinding::~CMachineBinding()
{
    if ( _hBinding )
        RpcBindingFree( &_hBinding );

    if ( _pAuthInfo )
    {
        PrivMemFree( _pAuthInfo->pwszServerPrincName );
        PrivMemFree( _pAuthInfo );
    }
    if (_ulMarshaledTargetInfoLength) 
    {
       MIDL_user_free(_pMarshaledTargetInfo);
    }
}
//keeps a copy of the passed in creds
RPC_STATUS CMachineBinding::SetMarshaledTargetInfo(unsigned long ulMarshaledTargetInfoLength, unsigned char *pMarshaledTargetInfo)
{
         
   // I don't expect any existing creds here
   ASSERT( (_ulMarshaledTargetInfoLength == 0) && (_pMarshaledTargetInfo == NULL));
   // but just in case
   if (_pMarshaledTargetInfo)
   {
           MIDL_user_free(_pMarshaledTargetInfo);
   }      
   _ulMarshaledTargetInfoLength = 0;
   _pMarshaledTargetInfo = NULL;
   RPC_STATUS status=OR_OK;
   if (ulMarshaledTargetInfoLength) 
   {
      _pMarshaledTargetInfo = (unsigned char *) MIDL_user_allocate(ulMarshaledTargetInfoLength * sizeof(char));
      if (_pMarshaledTargetInfo) 
      {
         memcpy(_pMarshaledTargetInfo, pMarshaledTargetInfo, ulMarshaledTargetInfoLength);
         _ulMarshaledTargetInfoLength = ulMarshaledTargetInfoLength;
      }
      else
         status = ERROR_NOT_ENOUGH_MEMORY;
   }
   return status;
   
}
// hands out a copy of my creds
RPC_STATUS CMachineBinding::GetMarshaledTargetInfo(unsigned long *pulMarshaledTargetInfoLength, unsigned char **pucMarshaledTargetInfo)
{
   RPC_STATUS status=OR_OK;
   *pulMarshaledTargetInfoLength = 0;
   *pucMarshaledTargetInfo = NULL;
   if (_ulMarshaledTargetInfoLength) 
   {
      *pucMarshaledTargetInfo = (unsigned char *) MIDL_user_allocate(_ulMarshaledTargetInfoLength * sizeof(char));
      if (*pucMarshaledTargetInfo) 
      {
         memcpy(*pucMarshaledTargetInfo, _pMarshaledTargetInfo, _ulMarshaledTargetInfoLength);
         *pulMarshaledTargetInfoLength = _ulMarshaledTargetInfoLength;
      }
      else
         status = ERROR_NOT_ENOUGH_MEMORY;
   }
   return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   CMachineBinding::Equal
//
//  Synopsis:   Return TRUE if the specified authentication information
//              matches this binding handle.  If the AUTHN_ANY flag is
//              specified, do not check the authentication service but do
//              check the authentication info.
//
//----------------------------------------------------------------------------
BOOL
CMachineBinding::Equal(
                      IN  USHORT          AuthnSvc,
                      IN  DWORD           AuthnLevel,
                      IN  COAUTHINFO *    pAuthInfo OPTIONAL
                      )
{    
    if (AuthnSvc == _AuthnSvc ||
        (AuthnSvc == AUTHN_ANY && _AuthnSvc != RPC_C_AUTHN_NONE))
    {
        if (AuthnLevel > _AuthnLevel)
        {
            // Asking for an authentication level greater than what this
            // machine binding supports.
            return FALSE;
        }

        if (!EqualAuthInfo( pAuthInfo, _pAuthInfo ))
        {
            // Specified COAUTHINFO does not match.
            return FALSE;
        }
        
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallRemoteMachine
//
//  Synopsis:   Marshal/Unmarshal the activation parameters.  Call the right
//              remote activation interface.
//
//----------------------------------------------------------------------------
RPC_STATUS
CallRemoteMachine(
                 handle_t            hBinding,
                 USHORT              ProtseqId,
                 ACTIVATION_PARAMS * pActParams,
                 WCHAR *             pwszPathForServer,
                 WCHAR *             pwszMachine,
                 BOOL                fUseOldActivationInterface,
                 HRESULT *           phr
                 )
{
    RPC_STATUS  Status=RPC_S_OK;

    if (fUseOldActivationInterface)
    {
        Status = CallOldRemoteActivation(hBinding,
                                         ProtseqId,
                                         pActParams, 
                                         pwszPathForServer, 
                                         pwszMachine, 
                                         phr);
    }
    else
    {
        Status = CallNewRemoteActivation(hBinding,
                                         ProtseqId,
                                         pActParams,
                                         pwszPathForServer,
                                         pwszMachine,
                                         phr);                                             
    }

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallNewRemoteActivation
//
//  Synopsis:   Call the COM+ remote activation functions.  Returns the RPC 
//              status of the call, not the end result.  In other words, the 
//              call might fail because of some out of memory, or something, 
//              but we will still say "success".
//
//              If everything works out, then when we are finished, the 
//              interface information will be in the actprops, and the 
//              ProtseqId will be in the ActParams.
//
//----------------------------------------------------------------------------
RPC_STATUS
CallNewRemoteActivation(
    handle_t            hBinding,
    USHORT              ProtseqId,
    ACTIVATION_PARAMS * pActParams,
    WCHAR *             pwszPathForServer,
    WCHAR *             pwszMachine,
    HRESULT *           phr)
{
    RPC_STATUS  Status=RPC_S_OK;

    //
    // Setup the ActProps for the new stuff.
    //
    if (pwszPathForServer && (pwszPathForServer != pActParams->pwszPath))
    {
        ASSERT(pActParams->pInstanceInfo != NULL);
        pActParams->pInstanceInfo->SetFile(pwszPathForServer, pActParams->Mode);
    }
    ASSERT(pActParams->pActPropsIn != NULL);

    IScmRequestInfo *pRequestInfo;
    *phr = pActParams->pActPropsIn->QueryInterface(IID_IScmRequestInfo,
                                                   (void**) &pRequestInfo);

    if (*phr != S_OK)
        return Status;

    REMOTE_REQUEST_SCM_INFO *pRequest;
    pRequest = (REMOTE_REQUEST_SCM_INFO *)
               MIDL_user_allocate(sizeof(REMOTE_REQUEST_SCM_INFO));
    if (pRequest == NULL)
    {
        pRequestInfo->Release();
        *phr = E_OUTOFMEMORY;
        return Status;
    }

    pRequest->ClientImpLevel     = RPC_C_IMP_LEVEL_IDENTIFY;
    pRequest->cRequestedProtseqs = cMyProtseqs;
    pRequest->pRequestedProtseqs = (unsigned short*)
                                   MIDL_user_allocate(sizeof(short)*pRequest->cRequestedProtseqs);

    if (pRequest->pRequestedProtseqs==NULL)
    {
        *phr = E_OUTOFMEMORY;
        MIDL_user_free(pRequest);
        pRequestInfo->Release();
        return RPC_S_OK;
    }
    memcpy(pRequest->pRequestedProtseqs, aMyProtseqs, sizeof(short)*cMyProtseqs);

    pRequestInfo->SetRemoteRequestInfo(pRequest);
    pRequestInfo->Release();

    MInterfacePointer *pIFDIn, *pIFDOut=NULL;
    *phr = ActPropsMarshalHelper(pActParams->pActPropsIn,
                                 IID_IActivationPropertiesIn,
                                 MSHCTX_DIFFERENTMACHINE,
                                 MSHLFLAGS_NORMAL,
                                 &pIFDIn);
    if (*phr != S_OK)
    {
        return RPC_S_OK;
    }

    RpcTryExcept
      {
          if (pActParams->MsgType == GETCLASSOBJECT)
          {
              *phr = RemoteGetClassObject(hBinding,
                                          pActParams->ORPCthis,
                                          pActParams->ORPCthat,
                                          pIFDIn,
                                          &pIFDOut);
          }
          else
          {
              *phr = RemoteCreateInstance(hBinding,
                                          pActParams->ORPCthis,
                                          pActParams->ORPCthat,
                                          NULL,
                                          pIFDIn,
                                          &pIFDOut);
          }
      }    
    RpcExcept(TRUE)
      {
          Status = RpcExceptionCode();
      }    
    RpcEndExcept;

    // Don't need the marshalled [in] interface anymore.
    MIDL_user_free(pIFDIn);

    //
    // If the status we got back was not RPC_S_OK, just return it.
    // Set *phr, too, but depending on the error, the caller might
    // not care.
    //
    if (Status != RPC_S_OK)
    {
        *phr = HRESULT_FROM_WIN32(Status);
        return Status;
    }

    if (*phr != S_OK)
    {
        // a-sergiv (Sergei O. Ivanov), 6-17-99
        // Fix for com+ 14808/nt 355212        
        LogRemoteSideFailure( &pActParams->Clsid, pActParams->ClsContext, pwszMachine, pwszPathForServer, *phr);
        return RPC_S_OK;
    }

    // AWFUL HACK ALERT:  This is too hacky even for the SCM
    ActivationStream ActStream((InterfaceData*)(((BYTE*)pIFDOut)+48));

    pActParams->pActPropsOut = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */);
    if (pActParams->pActPropsOut==NULL)
    {
        *phr = E_OUTOFMEMORY;
        return RPC_S_OK;
    }

    IScmReplyInfo *pReplyInfo;
    *phr = pActParams->pActPropsOut->UnmarshalInterface(&ActStream,
                                                        IID_IScmReplyInfo,
                                                        (LPVOID*)&pReplyInfo);
    if (*phr != S_OK)
    {
        pReplyInfo->Release();
        pActParams->pActPropsOut->Release();
        pActParams->pActPropsOut=NULL;
        MIDL_user_free(pIFDOut);
        return RPC_S_OK;
    }

    // If in a remote LB router, just return
    if (pActParams->RemoteActivation)
    {
        pReplyInfo->Release();
        MIDL_user_free(pIFDOut);
        return RPC_S_OK;
    }
    
    REMOTE_REPLY_SCM_INFO *pReply;
    pReplyInfo->GetRemoteReplyInfo(&pReply);
    ASSERT(pReply!=NULL);

    *pActParams->pOxidServer = pReply->Oxid;
    
    //We will not have protocol bindings for custom marshalled objrefs
    if ((pReply->pdsaOxidBindings) && (pReply->pdsaOxidBindings->wNumEntries))
    {
        ASSERT(pActParams->pOxidInfo != NULL);
        pActParams->pOxidInfo->psa =  (DUALSTRINGARRAY *)
                                      MIDL_user_allocate(pReply->pdsaOxidBindings->wNumEntries
                                                         * sizeof(WCHAR) +
                                                         sizeof(DUALSTRINGARRAY));        
        if (pActParams->pOxidInfo->psa == NULL)
        {
            pReplyInfo->Release();
            pActParams->pActPropsOut->Release();
            pActParams->pActPropsOut=NULL;
            *phr = E_OUTOFMEMORY;
            return RPC_S_OK;
        }

        dsaCopy(pActParams->pOxidInfo->psa, pReply->pdsaOxidBindings);
    }
    else
        pActParams->pOxidInfo->psa = NULL;

    pActParams->ProtseqId = ProtseqId;
    pActParams->pOxidInfo->ipidRemUnknown = pReply->ipidRemUnknown;
    pActParams->pOxidInfo->dwAuthnHint    = pReply->authnHint;
    pActParams->pOxidInfo->version        = pReply->serverVersion;
    
    pActParams->pIIDs    = 0;
    pActParams->pResults = 0;
    pActParams->ppIFD    = 0;
    
    MIDL_user_free(pIFDOut);
    pReplyInfo->Release();
    
    return RPC_S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallOldRemoteActivation
//
//  Synopsis:   Call the down-level "RemoteActivation" function, for downrev
//              servers.  Returns the RPC status of the call, not the end 
//              result.  In other words, the call might fail because of some
//              out of memory, or something, but we will still say "success".
//
//              If everything works out, then when we are finished, the 
//              interface information will be in the actprops, and the 
//              ProtseqId will be in the ActParams.
//
//----------------------------------------------------------------------------
RPC_STATUS
CallOldRemoteActivation(
    handle_t            hBinding,
    USHORT              ProtseqId,
    ACTIVATION_PARAMS * pActParams,
    WCHAR *             pwszPathForServer,
    WCHAR *             pwszMachine,
    HRESULT *           phr)
{
    RPC_STATUS Status;

    // Use Old Down-level interface
    //
    // all remote activations on this interface have to be made with
    // minor version 1, since remote downlevel (version 5.1) servers
    // refuse any other version.
    pActParams->ORPCthis->version.MinorVersion = COM_MINOR_VERSION_1;
    pActParams->ORPCthis->flags = ORPCF_NULL;

    pActParams->ppIFD = (MInterfacePointer **)
                        MIDL_user_allocate(sizeof(MInterfacePointer *) *
                                           pActParams->Interfaces);

    pActParams->pResults = (HRESULT*) MIDL_user_allocate(sizeof(HRESULT) *
                                                         pActParams->Interfaces);
    if ((pActParams->ppIFD == NULL) || (pActParams->pResults == NULL))
    {
        MIDL_user_free(pActParams->ppIFD);
        MIDL_user_free(pActParams->pResults);
        *phr = E_OUTOFMEMORY;
        return RPC_S_OK;
    }

    for (DWORD i=0; i<pActParams->Interfaces;i++)
    {
        pActParams->ppIFD[i] = NULL;
        pActParams->pResults[i] = E_FAIL;
    }

    Status = RemoteActivation(
                             hBinding,
                             pActParams->ORPCthis,
                             pActParams->ORPCthat,
                             &pActParams->Clsid,
                             pwszPathForServer,
                             pActParams->pIFDStorage,
                             RPC_C_IMP_LEVEL_IDENTIFY,
                             pActParams->Mode,
                             pActParams->Interfaces,
                             pActParams->pIIDs,
                             cMyProtseqs,
                             aMyProtseqs,
                             pActParams->pOxidServer,
                             &pActParams->pOxidInfo->psa,
                             &pActParams->pOxidInfo->ipidRemUnknown,
                             &pActParams->pOxidInfo->dwAuthnHint,
                             &pActParams->pOxidInfo->version,
                             phr,
                             pActParams->ppIFD,
                             pActParams->pResults );

    //
    // Note that this will only give us a bad status if there is a
    // communication failure.
    //
    if ( Status != RPC_S_OK )
        return Status;

    // Tweak the COMVERSION to be the lower of the two.
    Status = NegotiateDCOMVersion( &pActParams->pOxidInfo->version );
    if ( Status != RPC_S_OK )
        return Status;

    if ( (RPC_S_OK == Status) && FAILED(*phr) )
        LogRemoteSideFailure( &pActParams->Clsid, pActParams->ClsContext, pwszMachine, pwszPathForServer, *phr );

    if ((pActParams->MsgType == GETCLASSOBJECT) && (*phr == S_OK))
    {
        *pActParams->pResults = *phr;
    }


    //
    // If the activation fails we return success for the communication
    // status, but the overall operation has failed and the error will
    // be propogated back to the client.
    //
    if ( FAILED(*phr) )
        return RPC_S_OK;

    //
    // Anything that fails from here on out is our fault, not the server's.
    // So it is now safe to remember the ProtseqId.
    //
    pActParams->ProtseqId = ProtseqId;

    ASSERT(pActParams->pActPropsIn != NULL);
    *phr =
    pActParams->pActPropsIn->GetReturnActivationProperties((ActivationPropertiesOut **)
                                                           &pActParams->pActPropsOut);
    if ( FAILED(*phr) )
        return RPC_S_OK;

    *phr = pActParams->pActPropsOut->SetMarshalledResults(pActParams->Interfaces,
                                                          pActParams->pIIDs,
                                                          pActParams->pResults,
                                                          pActParams->ppIFD);
    
    //pActParams->pIIDs belongs to ActPropsIn
    MIDL_user_free(pActParams->pResults);
    for (i=0;i<pActParams->Interfaces ; i++)
        MIDL_user_free(pActParams->ppIFD[i]);
    MIDL_user_free(pActParams->ppIFD);
    pActParams->pResults = NULL;
    pActParams->ppIFD = NULL;

    return RPC_S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateRemoteBinding
//
//  Synopsis:   Create a binding handle for the specified machine and protseq.
//
//----------------------------------------------------------------------------
RPC_STATUS
CreateRemoteBinding(
                   IN  WCHAR *             pwszMachine,
                   IN  int                 ProtseqIndex,
                   OUT handle_t *          phBinding
                   )
{
    WCHAR *             pwszStringBinding;
    RPC_STATUS          Status;

    *phBinding = 0;

    Status = RpcStringBindingCompose(
                                    NULL,
                                    gaProtseqInfo[aMyProtseqs[ProtseqIndex]].pwstrProtseq,
                                    pwszMachine,
                                    gaProtseqInfo[aMyProtseqs[ProtseqIndex]].pwstrEndpoint,
                                    NULL,
                                    &pwszStringBinding );

    if ( Status != RPC_S_OK )
        return Status;

    Status = RpcBindingFromStringBinding( pwszStringBinding, phBinding );

    RpcStringFree( &pwszStringBinding );

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyAuthIdentity
//
//  Synopsis:   Copy an auth identity structure and all its strings.
//
//----------------------------------------------------------------------------
HRESULT
CopyAuthIdentity(
                IN  COAUTHIDENTITY *    pAuthIdentSrc,
                IN  COAUTHIDENTITY **   ppAuthIdentDest
                )
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG ulCharLen = 1;
    COAUTHIDENTITY  *pAuthIdentTemp = NULL;

    *ppAuthIdentDest = NULL;
    
    // Guard against both being set, although presumably this would have
    // caused grief before we got to this point.
    if ((pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) &&
        (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
    {
        ASSERT(0 && "Both string type flags were set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
    {
        ulCharLen = sizeof(WCHAR);
    }
    else if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
    {
        ulCharLen = sizeof(CHAR);
    }
    else
    {
       // The user didn't specify either string bit? How did we get here?
        ASSERT(0 && "String type flag was not set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pAuthIdentTemp = (COAUTHIDENTITY*) ActMemAlloc(sizeof(COAUTHIDENTITY));
    if (!pAuthIdentTemp)
        goto Cleanup;

    CopyMemory(pAuthIdentTemp, pAuthIdentSrc, sizeof(COAUTHIDENTITY));

    // Strings need to be allocated individually and copied
    pAuthIdentTemp->User = pAuthIdentTemp->Domain = pAuthIdentTemp->Password = NULL;

    if (pAuthIdentSrc->User)
    {
        pAuthIdentTemp->User = (USHORT *)ActMemAlloc((pAuthIdentTemp->UserLength+1) * ulCharLen);

        if (!pAuthIdentTemp->User)
            goto Cleanup;

        CopyMemory(pAuthIdentTemp->User, pAuthIdentSrc->User, (pAuthIdentTemp->UserLength+1) * ulCharLen);
    }

    if (pAuthIdentSrc->Domain)
    {
        pAuthIdentTemp->Domain = (USHORT *)ActMemAlloc((pAuthIdentTemp->DomainLength+1) * ulCharLen);

        if (!pAuthIdentTemp->Domain)
            goto Cleanup;

        CopyMemory(pAuthIdentTemp->Domain, pAuthIdentSrc->Domain, (pAuthIdentTemp->DomainLength+1) * ulCharLen);
    }
            
    if (pAuthIdentSrc->Password)
    {
        pAuthIdentTemp->Password = (USHORT *)ActMemAlloc((pAuthIdentTemp->PasswordLength+1) * ulCharLen);

        if (!pAuthIdentTemp->Password)
            goto Cleanup;

        CopyMemory(pAuthIdentTemp->Password, pAuthIdentSrc->Password, (pAuthIdentTemp->PasswordLength+1) * ulCharLen);
    }
    

    hr = S_OK;

Cleanup:
    if (SUCCEEDED(hr))
    {
        *ppAuthIdentDest = pAuthIdentTemp;
    }
    else
    {
        if (pAuthIdentTemp)
        {
            SecurityInfo::freeCOAUTHIDENTITY(pAuthIdentTemp);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyAuthInfo
//
//  Synopsis:   Copy an auth info structure and all its sub structures.
//
//----------------------------------------------------------------------------
HRESULT
CopyAuthInfo(
            IN  COAUTHINFO *    pAuthInfoSrc,
            IN  COAUTHINFO **   ppAuthInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;
    COAUTHINFO   *pAuthInfoTemp = NULL;
    
    *ppAuthInfoDest = NULL;

    if (pAuthInfoSrc == NULL)
    {
       return S_OK;
    }

    pAuthInfoTemp = (COAUTHINFO*)ActMemAlloc(sizeof(COAUTHINFO));

    if (!pAuthInfoTemp)
        goto Cleanup;

    CopyMemory(pAuthInfoTemp, pAuthInfoSrc, sizeof(COAUTHINFO));

    // We need to allocate these fields and make a copy
    pAuthInfoTemp->pwszServerPrincName = NULL;
    pAuthInfoTemp->pAuthIdentityData = NULL;

    // only alloc space for  pwszServerPrincName if its non-null
    if (pAuthInfoSrc->pwszServerPrincName)
    {
        pAuthInfoTemp->pwszServerPrincName = 
            (LPWSTR) ActMemAlloc((lstrlenW(pAuthInfoSrc->pwszServerPrincName) + 1) * sizeof(WCHAR));

        if (!pAuthInfoTemp->pwszServerPrincName)
            goto Cleanup;
        
        lstrcpyW(pAuthInfoTemp->pwszServerPrincName, pAuthInfoSrc->pwszServerPrincName);
    }
    
    // copy the AuthIdentity if its non-null
    if (pAuthInfoSrc->pAuthIdentityData)
    {
        hr = CopyAuthIdentity(pAuthInfoSrc->pAuthIdentityData, &pAuthInfoTemp->pAuthIdentityData);
        if (FAILED(hr))
            goto Cleanup;
    }
    hr = S_OK;
    
   Cleanup:

    if (SUCCEEDED(hr))
    {
        *ppAuthInfoDest = pAuthInfoTemp;
    }
    else if (pAuthInfoTemp)
    {
        SecurityInfo::freeCOAUTHINFO(pAuthInfoTemp);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EqualAuthInfo
//
//  Synopsis:   Compare two auth info structures and their sub structures.
//
//----------------------------------------------------------------------------
BOOL
EqualAuthInfo(
             COAUTHINFO*         pAuthInfo,
             COAUTHINFO*         pAuthInfoOther)
{
    if ( pAuthInfo && pAuthInfoOther )
    {
        if ( (pAuthInfo->dwAuthnSvc != pAuthInfoOther->dwAuthnSvc) ||
             (pAuthInfo->dwAuthzSvc != pAuthInfoOther->dwAuthzSvc) ||
             (pAuthInfo->dwAuthnLevel != pAuthInfoOther->dwAuthnLevel) ||
             (pAuthInfo->dwImpersonationLevel != pAuthInfoOther->dwImpersonationLevel) ||
             (pAuthInfo->dwCapabilities != pAuthInfoOther->dwCapabilities) )
        {
            return FALSE;
        }

        // only compare pwszServerPrincName's if they're both specified
        if (pAuthInfo->pwszServerPrincName && pAuthInfoOther->pwszServerPrincName)
        {
            if ( lstrcmpW(pAuthInfo->pwszServerPrincName,
                          pAuthInfoOther->pwszServerPrincName) != 0 )
            {
                return FALSE;
            }
        }
        else
        {
            // if one was NULL, both should be NULL for equality
            if (pAuthInfo->pwszServerPrincName != pAuthInfoOther->pwszServerPrincName)
            {
                return FALSE;
            }
        }
        // we never cache authid, so one of them must be NULL
        ASSERT(!(pAuthInfo->pAuthIdentityData && pAuthInfoOther->pAuthIdentityData));
        if (pAuthInfo->pAuthIdentityData || pAuthInfoOther->pAuthIdentityData) 
        {
           return FALSE;
        }
    }
    else
    {
        if ( pAuthInfo != pAuthInfoOther )
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\registry.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  registry.cxx
//
//  Registry related routines
//
//--------------------------------------------------------------------------

#include "act.hxx"

#ifdef SERVER_HANDLER
BOOL gbDisableEmbeddingServerHandler = FALSE;
#endif // SERVER_HANDLER

BOOL gbSAFERROTChecksEnabled = TRUE;
BOOL gbSAFERAAAChecksEnabled = TRUE;

BOOL gbDynamicIPChangesEnabled = TRUE;  // On in whistler; was off by default in W2K
DWORD gdwTimeoutPeriodForStaleMids = 10 * 60 * 1000; // ten minutes

//-------------------------------------------------------------------------
//
// ReadStringValue
//
//  Returns the named value string under the specified open registry key.
//
// Returns :
//
//  ERROR_SUCCESS, ERROR_FILE_NOT_FOUND, ERROR_BAD_FORMAT, ERROR_OUTOFMEMORY,
//  ERROR_BAD_PATHNAME, or other more esoteric win32 error code.
//
//-------------------------------------------------------------------------
DWORD
ReadStringValue(
    IN  HKEY        hKey,
    IN  WCHAR *     pwszValueName,
    OUT WCHAR **    ppwszString )
{
    DWORD   Status;
    DWORD   Type;
    DWORD   StringSize;
    WCHAR * pwszScan;
    WCHAR * pwszSource;
    WCHAR   wszString[64];

    *ppwszString = 0;

    StringSize = sizeof(wszString);

    Status = RegQueryValueEx(
                hKey,
                pwszValueName,
                NULL,
                &Type,
                (BYTE *) wszString,
                &StringSize );

    if ( (ERROR_SUCCESS == Status) &&
         (Type != REG_SZ) && (Type != REG_MULTI_SZ) && (Type != REG_EXPAND_SZ) )
        Status = ERROR_BAD_FORMAT;

    if ( (Status != ERROR_SUCCESS) && (Status != ERROR_MORE_DATA) )
        return Status;

    // Allocate one extra WCHAR for an extra null at the end.
    *ppwszString = (WCHAR *) PrivMemAlloc( StringSize + sizeof(WCHAR) );

    if ( ! *ppwszString )
        return ERROR_OUTOFMEMORY;

    if ( ERROR_MORE_DATA == Status )
    {
        Status = RegQueryValueEx(
                    hKey,
                    pwszValueName,
                    NULL,
                    &Type,
                    (BYTE *) *ppwszString,
                    &StringSize );

        if ( Status != ERROR_SUCCESS )
        {
            PrivMemFree( *ppwszString );
            *ppwszString = 0;
            return Status;
        }
    }
    else
    {
        memcpy( *ppwszString, wszString, StringSize );
    }

    //
    // Put an extra null at the end.  This allows using identical logic for both
    // REG_SZ and REG_MULTI_SZ values like RemoteServerNames instead of special
    // casing it.
    //
    (*ppwszString)[StringSize/sizeof(WCHAR)] = 0;

    //
    // Don't bother with any of the following conversions for multi strings.
    // They better be in the correct format.
    //
    if ( REG_MULTI_SZ == Type )
        return Status;

    pwszScan = pwszSource = *ppwszString;

    //
    // The original OLE sources had logic for stripping out a quoted
    // value.  I have no idea on the origin of this or if it is still
    // important.  It shouldn't hurt anything to keep it in to save
    // us from some nasty compatability problem.
    // - DKays, 8/96
    //

    if ( L'\"' == *pwszScan )
    {
        pwszScan++;

        // Copy everything between the quotes.
        while ( *pwszScan && (*pwszScan != L'\"') )
            *pwszSource++ = *pwszScan++;

        *pwszSource = 0;
    }

    //
    // Leading and trailing whitespace would hose us for some values, like
    // RemoteServerName or RunAs.  These are stripped here.  Once again, only
    // good things can happen if we put this logic in.
    //

    pwszScan = *ppwszString;

    while ( *pwszScan && ((L' ' == *pwszScan) || (L'\t' == *pwszScan)) )
        pwszScan++;

    if ( ! *pwszScan )
    {
        PrivMemFree( *ppwszString );
        *ppwszString = 0;
        return ERROR_BAD_PATHNAME;
    }

    if ( *ppwszString < pwszScan )
        lstrcpyW( *ppwszString, pwszScan );

    pwszScan = *ppwszString + lstrlenW(*ppwszString);

    while ( (pwszScan != *ppwszString) &&
            ((L' ' == pwszScan[-1]) || (L'\t' == pwszScan[-1])) )
        pwszScan--;

    *pwszScan = 0;

    //
    // Finally, handle environment string expansion if necessary.
    // Remember to add the extra trailing null again.
    //
    if ( REG_EXPAND_SZ == Type )
    {
        WCHAR * pwszExpandedString;
        DWORD   ExpandedStringSize;

        pwszExpandedString = 0;
        StringSize /= sizeof(WCHAR);

        for (;;)
        {
            PrivMemFree( pwszExpandedString );
            pwszExpandedString = (WCHAR *) PrivMemAlloc( (StringSize + 1) * sizeof(WCHAR) );

            if ( ! pwszExpandedString )
            {
                Status = ERROR_OUTOFMEMORY;
                break;
            }

            ExpandedStringSize = ExpandEnvironmentStrings(
                                    *ppwszString,
                                    pwszExpandedString,
                                    StringSize );

            if ( ! ExpandedStringSize )
            {
                Status = GetLastError();
                break;
            }

            if ( ExpandedStringSize > StringSize )
            {
                StringSize = ExpandedStringSize;
                continue;
            }

            Status = ERROR_SUCCESS;
            break;
        }

        PrivMemFree( *ppwszString );

        if ( ERROR_SUCCESS == Status )
        {
            pwszExpandedString[lstrlenW(pwszExpandedString)+1] = 0;
            *ppwszString = pwszExpandedString;
        }
        else
        {
            PrivMemFree( pwszExpandedString );
            *ppwszString = 0;
        }
    }

    return Status;
}

//-------------------------------------------------------------------------
//
// ReadStringKeyValue
//
//  Reads the unnamed named value string for the specified subkey name
//  under the given open registry key.
//
//-------------------------------------------------------------------------
DWORD
ReadStringKeyValue(
    IN  HKEY        hKey,
    IN  WCHAR *     pwszKeyName,
    OUT WCHAR **    ppwszString )
{
    DWORD   Status;
    HKEY    hSubKey;

    Status = RegOpenKeyEx(
                hKey,
                pwszKeyName,
                NULL,
                KEY_READ,
                &hSubKey );

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = ReadStringValue( hSubKey, L"", ppwszString );

    RegCloseKey( hSubKey );

    return Status;
}

//-------------------------------------------------------------------------
//
// ReadSecurityDescriptor
//
//  Converts a security descriptor from self relative to absolute form.
//  Stuffs in an owner and a group.
//
// Notes :
//
//  REGDB_E_INVALIDVALUE is returned when there is something
//  at the specified value, but it is not a security descriptor.
//
//-------------------------------------------------------------------------
DWORD
ReadSecurityDescriptor(
    IN  HKEY                    hKey,
    IN  WCHAR *                 pwszValue,
    OUT CSecDescriptor **  ppCSecDescriptor )

{
    PSID    pGroupSid;
    PSID    pOwnerSid;
    DWORD   Size;
    DWORD   Type;
    DWORD   Status;
    DWORD   Size2;
    SECURITY_DESCRIPTOR* pSD = NULL;
    CSecDescriptor* pCSecDescriptor = NULL;

    // Find put how much memory to allocate for the security descriptor.

    Size = 0;
    *ppCSecDescriptor = NULL;

    Status = RegQueryValueEx( hKey, pwszValue, 0, &Type, 0, &Size );
    
    Size2 = Size;

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( Type != REG_BINARY || (Size < sizeof(SECURITY_DESCRIPTOR)) )
        return ERROR_BAD_FORMAT;

    //
    // Allocate memory for the security descriptor plus the owner and
    // group SIDs.
    //

#ifdef _WIN64
    {
        DWORD deltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE );
        ASSERT( deltaSize < sizeof( SECURITY_DESCRIPTOR ) );
        deltaSize = (DWORD) OLE2INT_ROUND_UP( deltaSize, sizeof(PVOID) );

        Size2 += deltaSize;
    }
#endif // _WIN64
    
    // Allocate sd buffer and wrapper class
    pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc( Size2 );
    if (!pSD)
        return ERROR_OUTOFMEMORY;

    // Read the security descriptor.
    Status = RegQueryValueEx( hKey, pwszValue, 0, &Type, (PBYTE) pSD, &Size );

    if ( Status != ERROR_SUCCESS )
        goto ReadSecurityDescriptorEnd;

    if ( Type != REG_BINARY )
    {
        Status = ERROR_BAD_FORMAT;
        goto ReadSecurityDescriptorEnd;
    }

    //
    // Fix up the security descriptor.
    //

#ifdef _WIN64
    if ( MakeAbsoluteSD2( pSD, &Size2 ) == FALSE )   {
        Status = ERROR_BAD_FORMAT;
        goto ReadSecurityDescriptorEnd;
    }
#else  // !_WIN64

    pSD->Control &= ~SE_SELF_RELATIVE;
    pSD->Sacl = NULL;

    if ( pSD->Dacl != NULL )
    {
        if ( (Size < sizeof(ACL) + sizeof(SECURITY_DESCRIPTOR)) ||
             ((ULONG) pSD->Dacl > Size - sizeof(ACL)) )
        {
            Status = ERROR_BAD_FORMAT;
            goto ReadSecurityDescriptorEnd;
        }

        pSD->Dacl = (ACL *) (((char *) pSD) + ((ULONG) pSD->Dacl));

        if ( pSD->Dacl->AclSize + sizeof(SECURITY_DESCRIPTOR) > Size )
        {
            Status = ERROR_BAD_FORMAT;
            goto ReadSecurityDescriptorEnd;
        }
    }

    // Set up the owner and group SIDs.
    if ( pSD->Group == 0 ||
         ((ULONG)pSD->Group) + sizeof(SID) > Size ||
         pSD->Owner == 0 ||
         ((ULONG)pSD->Owner) + sizeof(SID) > Size )
    {
        Status = ERROR_BAD_FORMAT;
        goto ReadSecurityDescriptorEnd;
    }

    pSD->Group = (SID *) (((BYTE *) pSD) + (ULONG) (pSD)->Group);
    pSD->Owner = (SID *) (((BYTE *) pSD) + (ULONG) (pSD)->Owner);

#endif // !_WIN64

ReadSecurityDescriptorEnd:

    if ( Status != ERROR_SUCCESS )
    {
        if ( pSD )
            PrivMemFree( pSD );

        return Status;
    }
	
    // Allocate wrapper class for refcount semantics
    pCSecDescriptor = new CSecDescriptor(pSD);
    if (!pCSecDescriptor)
    {
        PrivMemFree(pSD);
        return ERROR_OUTOFMEMORY;
    }

    ASSERT( IsValidSecurityDescriptor( pCSecDescriptor->GetSD()) );
	
    // New class has refcount of 1, owned by the caller
    *ppCSecDescriptor = pCSecDescriptor;

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------------------
//
// InitSCMRegistry
//
//   Opens global registry keys and settings.
//
//-------------------------------------------------------------------------
HRESULT
InitSCMRegistry()
{
    HRESULT hr;
    LONG    err;
    DWORD   dwDisp;

    ReadRemoteActivationKeys();

    ReadRemoteBindingHandleCacheKeys();
	
	ReadSAFERKeys();

    ReadDynamicIPChangesKeys();

    // Now read the actual values from the registry
    // Check if Embedding Server Handler is enabled
#ifdef SERVER_HANDLER
    HKEY    hkeyOle;
    err = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\OLE\\DisableEmbeddingServerHandler",
                         NULL,
                         KEY_QUERY_VALUE,
                         &hkeyOle );

    if (err == ERROR_SUCCESS)
    {
        gbDisableEmbeddingServerHandler=TRUE;
        RegCloseKey(hkeyOle);
    }
#endif // SERVER_HANDLER

    return S_OK;
}


//-------------------------------------------------------------------------
//
// ReadRemoteActivationKeys
//
//-------------------------------------------------------------------------
void ReadRemoteActivationKeys()
{
    DWORD err;
    HKEY  hOle;

    // Read the DefaultLaunchPermission value (if present) from the registry
    if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE", NULL, KEY_READ,
                            &hOle)) == ERROR_SUCCESS)
    {
        DWORD dwStatus;
        CSecDescriptor* pSecDescriptor = NULL;

        dwStatus = ReadSecurityDescriptor( hOle,
                                           L"DefaultLaunchPermission",
                                           &pSecDescriptor);
        if (dwStatus == ERROR_SUCCESS)
        {
            ASSERT(pSecDescriptor);
            SetDefaultLaunchPermissions(pSecDescriptor);
            pSecDescriptor->DecRefCount();
        }
        else
        {
            // In case of a non-existent or malformed descriptor, reset 
            // current perms to NULL - this blocks everybody.
            ASSERT(!pSecDescriptor);
            SetDefaultLaunchPermissions(NULL);
        }

        RegCloseKey(hOle);
    }
}

//-------------------------------------------------------------------------
//
// GetActivationFailureLoggingLevel
//
//  Returns current activation failure logging level as specified
//  by a certain key in the Registry.
//
// History: 
//
//  a-sergiv    6-17-99    Created
//
// Returns :
//
//  0 = Discretionary logging. Log by default, client can override
//  1 = Always log. Log all errors no matter what client specified
//  2 = Never log. Never log error no matter what client speciied
//
//-------------------------------------------------------------------------

DWORD
GetActivationFailureLoggingLevel()
{
    DWORD err;
    DWORD dwSize;
    DWORD dwType;
    HKEY hOle;
    DWORD dwLevel = 0;

    if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE", NULL, KEY_READ,
                            &hOle)) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);

        if ((err = RegQueryValueEx(hOle, L"ActivationFailureLoggingLevel",
                                   NULL, &dwType, (BYTE *) &dwLevel, &dwSize))
            == ERROR_SUCCESS)
        {
            // Valid values are 0, 1 and 2. The variable is unsigned.
            // Assume 0 if invalid value is specified.

            if(dwLevel > 2)
                dwLevel = 0;
        }
	else
        {
            // Assume 0 if not specified

            dwLevel = 0;
        }

        RegCloseKey(hOle);
    }

    return dwLevel;
}

//
//  ReadRegistryIntegerValue
//
//  Tries to read a numeric value from the specified value under the key.
//  Returns FALSE if it doesn't exist or is of the wrong type, TRUE
//  otherwise.
//
BOOL ReadRegistryIntegerValue(HKEY hkey, WCHAR* pwszValue, DWORD* pdwValue)
{
    BOOL bResult = FALSE;
    DWORD error;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD dwValue;

    error = RegQueryValueExW(hkey, 
                             pwszValue,
                             NULL,
                             &dwType,
                             (BYTE*)&dwValue,
                             &dwSize);
    if (error == ERROR_SUCCESS &&
        dwType == REG_DWORD)
    {
        *pdwValue = dwValue;
        bResult = TRUE;
    }
    
    return bResult;
}

//-------------------------------------------------------------------------
//
// ReadRemoteBindingHandleCacheKeys
//
// Reads optional values from the registry to control the behavior of the
// remote binding handle cache (gpRemoteMachineList).
//
//-------------------------------------------------------------------------
void
ReadRemoteBindingHandleCacheKeys()
{
    HKEY hOle;
    DWORD error;

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        DWORD dwValue;

        if (ReadRegistryIntegerValue(hOle, L"RemoteHandleCacheMaxSize", &dwValue))
        {
            gdwRemoteBindingHandleCacheMaxSize = dwValue;
        }

        if (ReadRegistryIntegerValue(hOle, L"RemoteHandleCacheMaxLifetime", &dwValue))
        {
            gdwRemoteBindingHandleCacheMaxLifetime = dwValue;
        }

        if (ReadRegistryIntegerValue(hOle, L"RemoteHandleCacheMaxIdleTimeout", &dwValue))
        {
            gdwRemoteBindingHandleCacheIdleTimeout = dwValue;
        }

        // This one not really a "binding handle cache" knob.  
        // CODEWORK:  all of this registry knob reading code needs to be
        // cleaned-up and rewritten.
        if (ReadRegistryIntegerValue(hOle, L"StaleMidTimeout", &dwValue))
        {
            gdwTimeoutPeriodForStaleMids = dwValue;
        }
           
        RegCloseKey(hOle);
    }

    return;
}

//-------------------------------------------------------------------------
//
// ReadSAFERKeys
//
// Reads optional values from the registry to control aspects of our 
// SAFER windows support
//
//-------------------------------------------------------------------------
void
ReadSAFERKeys()
{
    HKEY hOle;
    DWORD error;
    DWORD dwType;
    DWORD dwSize;
    WCHAR wszYN[5];

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        dwSize = sizeof(wszYN) / sizeof(WCHAR);

        error = RegQueryValueEx(hOle, 
                                L"SRPRunningObjectChecks",
                                NULL,
                                &dwType,
                                (BYTE*)wszYN,
                                &dwSize);
        if (error == ERROR_SUCCESS && (wszYN[0] == L'n'  ||  wszYN[0] == L'N'))
        {
            gbSAFERROTChecksEnabled = FALSE;
        }

        dwSize = sizeof(wszYN) / sizeof(WCHAR);

        error = RegQueryValueEx(hOle, 
                                L"SRPActivateAsActivatorChecks",
                                NULL,
                                &dwType,
                                (BYTE*)wszYN,
                                &dwSize);
        if (error == ERROR_SUCCESS && (wszYN[0] == L'n'  ||  wszYN[0] == L'N'))
        {
            gbSAFERAAAChecksEnabled = FALSE;
        }

        CloseHandle(hOle);
    }
    return;
}


//-------------------------------------------------------------------------
//
// ReadDynamicIPChangesKeys
//
// Reads optional values from the registry to control aspects of our
// dynamic IP change support.
//
//-------------------------------------------------------------------------
void
ReadDynamicIPChangesKeys()
{
    HKEY hOle;
    DWORD error;
    DWORD dwType;
    DWORD dwSize;
    WCHAR wszYN[5];

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        dwSize = sizeof(wszYN) / sizeof(WCHAR);

        error = RegQueryValueEx(hOle, 
                                L"EnableSystemDynamicIPTracking",
                                NULL,
                                &dwType,
                                (BYTE*)wszYN,
                                &dwSize);
        // note: in w2k, this code turned the flag on only if the registry
        // value was "y" or "Y".  In whistler I have reversed these semantics.
        if (error == ERROR_SUCCESS && (wszYN[0] == L'n'  ||  wszYN[0] == L'N'))
        {
            gbDynamicIPChangesEnabled = FALSE;
        }

        CloseHandle(hOle);
    }
    return;
}


//-------------------------------------------------------------------------
//
// CRegistryWatcher::CRegistryWatcher
//
// Constructor for CRegistryWatcher.
//
// If allocation of the event fails, or opening the key fails, or registering
// for the notify fails, then Changed() always returns S_OK (yes, it changed).
// This doesn't affect correctness, only speed.
//
//-------------------------------------------------------------------------
CRegistryWatcher::CRegistryWatcher(HKEY hKeyRoot, const WCHAR *wszSubKey)
{
    _fValid = FALSE;

    _hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    if (!_hEvent)
        return;
    
    LONG res = RegOpenKeyEx(hKeyRoot, wszSubKey, 0, KEY_NOTIFY, &_hWatchedKey);
    if (res != ERROR_SUCCESS)
    {
        Cleanup();
        return;
    }
       
    _fValid = TRUE;
}

//-------------------------------------------------------------------------
//
// CRegistryWatcher::CRegistryWatcher
//
// Determine if the registry key being watched has changed.  Returns
// S_OK if it has changed, S_FALSE if not, and an error if something
// failed.
//
//-------------------------------------------------------------------------
HRESULT CRegistryWatcher::Changed()
{
    if (!_fValid)
        return S_OK;

    // _hEvent is auto-reset, so only one thread will re-register.
    if (WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0))
    {
        LONG res = RegNotifyChangeKeyValue(_hWatchedKey,
                                           TRUE, 
                                           REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                                           _hEvent,
                                           TRUE);
        if (res != ERROR_SUCCESS)
        {
            // Could not re-register, so we can't watch the key anymore.
            _fValid = FALSE;
            return HRESULT_FROM_WIN32(res);
        }
        else
            return S_OK;            
    }
    else
        return S_FALSE;
}

void CRegistryWatcher::Cleanup()
{
    if (_hEvent)
    {
        CloseHandle(_hEvent);      
        _hEvent = NULL;
    }

    if (_hWatchedKey)
    {
        RegCloseKey(_hWatchedKey); 
        _hWatchedKey = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\scmhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scmhash.cxx
//
//  Contents:   Class definitions used for SCM hash table.
//
//  History:    20-Jan-93 Ricksa    Created from map_kv.cpp
//
//  Notes:      The reason for creating this file rather than using the
//              original class is that the SCM has different memory allocation
//              needs depending on whether it is built for Win95 or NT.
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CScmHashEntry::~CScmHashEntry
//
//  Synopsis:   Clean up hash entry
//
//  History:    16-Feb-96 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry::~CScmHashEntry(void)
{
    // Just exists hopefully to save some space
}






//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::~CScmHashTable
//
//  Synopsis:   Free resources held by the hash table
//
//  Algorithm:  For each hash bucket, delete all member of the collison
//              list.
//
//  History:    16-Feb-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashTable::~CScmHashTable(void)
{
    // Free all the objects in the table.

    // Loop through each hash bucket
    for (DWORD i = 0; i < _ndwHashTableSize; i++)
    {
        // For each entry in the hash bucket list delete it.
        CScmHashEntry *pshe = _apsheHashTable[i];

        while (pshe != NULL)
        {
            CScmHashEntry *psheNext = pshe->GetNext();

            delete pshe;

            pshe = psheNext;
        }

    }

    // Free the table itself
    PrivMemFree (_apsheHashTable);
}




//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::Lookup
//
//  Synopsis:   Look up entry by hash and key
//
//  Arguments:  [dwHash] - hash value to use
//              [pKey] - key to use
//              [cbKey] - count of bytes in the key
//
//  Returns:    NULL - no matching entry was found
//              Pointer to first matching entry found
//
//  Algorithm:  If there is an entry for the hash bucket, search
//              through the collision entries for the first entry
//              that matches.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry * CScmHashTable::Lookup(
    DWORD dwHash,
    LPVOID pKey,
    UINT cbKey) const
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::Lookup "
        "( %lx , %p , %lx )\n", this, dwHash, pKey, cbKey));

    CScmHashEntry *psheFound = NULL;

    // Are there any entries for this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];

        // Loop searching for a match
        do
        {
            if (psheToSearch->IsEqual(pKey, cbKey))
            {
                psheFound = psheToSearch;
                break;
            }
        } while ((psheToSearch = psheToSearch->GetNext()) != NULL);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::Lookup ( %p )\n",
        this, psheFound));
    return psheFound;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::Lookup
//
//  Synopsis:   Look up entry by entry pointer
//
//  Arguments:  [dwHash] - hash value to use
//              [pvEntry] - entry pointer to find
//
//  Returns:    NULL - no matching entry was found
//              Pointer to first matching entry found
//
//  Algorithm:  If there is an entry for the hash bucket, search
//              through the collision entries for the first entry
//              that matches.
//
//  History:    05-Mar-02 JohnDoty    Created
//
//--------------------------------------------------------------------------
CScmHashEntry * CScmHashTable::Lookup(
    DWORD dwHash,
    LPVOID pvEntry) const
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::Lookup "
                     "( %lx , %p )\n", this, dwHash, pvEntry));

    // Make sure the hash is valid.
    if (dwHash >= SCM_HASH_SIZE)
      return NULL;

    CScmHashEntry *psheFound = NULL;

    // Are there any entries for this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];

        // Loop searching for a match
        do
        {
            if (psheToSearch == pvEntry)
            {
                psheFound = psheToSearch;
                break;
            }
        } while ((psheToSearch = psheToSearch->GetNext()) != NULL);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::Lookup ( %p )\n",
                     this, psheFound));
    return psheFound;
}



//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::SetAt
//
//  Synopsis:   Add a new entry
//
//  Arguments:  [dwHash] - hash value to use
//              [psheToAdd] - hash entry to add
//
//  Algorithm:  If there are no entries for the bucket, make the bucket
//              point to this entry. Otherwise, put this entry on the
//              end of the list of collisions.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
void CScmHashTable::SetAt(
    DWORD dwHash,
    CScmHashEntry *psheToAdd)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::SetAt "
        "( %lx , %p )\n", this, dwHash, psheToAdd));

    // Are there entries that has to this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        // Yes -- then put this one on the end of the list

        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];
        CScmHashEntry *psheLast;

        do
        {

            psheLast = psheToSearch;

        } while ((psheToSearch = psheToSearch->GetNext()) != NULL);

        psheLast->SetNext(psheToAdd);
    }
    else
    {
        // No entries on the list so put this one first
        _apsheHashTable[dwHash] = psheToAdd;
    }

    _ndwCount++;

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::SetAt \n", this));
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::RemoveEntry
//
//  Synopsis:   Remove an entry from the list
//
//  Arguments:  [dwHash] - hash value to use
//              [psheToRemove] - hash entry to add
//
//  Returns:    TRUE - entry removed.
//              FALSE - no such entry found
//
//  Algorithm:  If bucket is not empty, if this is the first entry replace
//              it with its next. Otherwise, loop through the list searching
//              for the entry and make its previous point to the current
//              one's next.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CScmHashTable::RemoveEntry(
    DWORD dwHash,
    CScmHashEntry *psheToRemove)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::RemoveEntry "
        "( %lx , %p )\n", this, dwHash, psheToRemove));

    BOOL fFound = FALSE;

    // Are there any entries for this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];
        CScmHashEntry *pshePrev = NULL;

        while (psheToSearch != NULL)
        {
            if (psheToSearch == psheToRemove)
            {
                if (pshePrev == NULL)
                {
                    // First entry matches so update the head of the list
                    _apsheHashTable[dwHash] = psheToSearch->GetNext();
                }
                else
                {
                    // Found entry in the middle of the list so delete
                    // the previous item's next pointer
                    pshePrev->SetNext(psheToSearch->GetNext());
                }

                // Tell the caller we found the item
                fFound = TRUE;
                break;
            }

            pshePrev = psheToSearch;
            psheToSearch = psheToSearch->GetNext();
        }

        if (fFound)
        {
            _ndwCount--;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::RemoveEntry ( %lx )\n",
        this, fFound));

    return fFound;
}




//+-------------------------------------------------------------------------
//
//  Member:     CScmHashIter::FindNextBucketWithEntry
//
//  Synopsis:   Find next hash bucket that has an entry
//
//  Returns:    Entry for bucket or NULL if there are none/
//
//  Algorithm:  Beginning with the current bucket loop through the list
//              of buckets till one is not null or there are no more
//              buckets.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry *CScmHashIter::FindNextBucketWithEntry(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashIter::FindNextBucketWithEntry\n",
        this));

    for (; _dwBucket < _psht->_ndwHashTableSize; _dwBucket++)
    {
        if ((_psheNext =_psht->_apsheHashTable[_dwBucket]) != NULL)
        {
            break;
        }
    }

    // Point to the next bucket
    _dwBucket++;

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashIter::FindNextBucketWithEntry "
        "( %p )\n", this, _psheNext));

    return _psheNext;
}




//+-------------------------------------------------------------------------
//
//  Member:     CScmHashIter::GetNext
//
//  Synopsis:   Find next hash bucket that has an entry
//
//  Returns:    Next entry in the iteration
//
//  Algorithm:  Get the next pointer from the object and then update
//              the next pointer if there are still entries to be
//              iterated.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry *CScmHashIter::GetNext(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashIter::GetNext \n", this));

    CScmHashEntry *psheToReturn = _psheNext;

    // Search for the next entry to return
    if (_psheNext != NULL)
    {
        _psheNext = _psheNext->GetNext();

        if (_psheNext == NULL)
        {
            FindNextBucketWithEntry();
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashIter::GetNext "
        "( %p )\n", this, psheToReturn));

    return psheToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\scminfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       scminfo.cxx
//
//  Contents:   Definitions/objects for use by scm-level activators
//
//  History:    05-Sep-99  JSimmons    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"
#include "scminfo.hxx"
#include "initguid.h"

// Macros to index into special members of the SCMProcessInfo struct
#define SPI_TO_SIZE(pSPI)     (ULONG*)(((BYTE*)pSPI) + sizeof(SCMProcessInfo))
#define SPI_TO_REFCOUNT(pSPI) (LONG*)(((BYTE*)pSPI) + sizeof(SCMProcessInfo) + sizeof(ULONG))
#define SPI_TO_CPROCESS(pSPI) (CProcess**)(((BYTE*)pSPI) + sizeof(SCMProcessInfo) + sizeof(ULONG) + sizeof(ULONG))
#define SPI_TO_WINSTA(pSPI)   (WCHAR*)(((BYTE*)pSPI) + sizeof(SCMProcessInfo) + sizeof(ULONG) + sizeof(ULONG) + sizeof(CProcess*))

// Rounding constant for ptr sizes
#if defined(_X86_)
	#define MEM_ALIGN_SIZE   4
#else 
#ifdef _WIN64
	#define MEM_ALIGN_SIZE   16
#else
	#define MEM_ALIGN_SIZE   8		
#endif
#endif

//+-------------------------------------------------------------------------
//
//  Implementation of CSCMProcessControl begins here
//
//--------------------------------------------------------------------------

// Constructor
CSCMProcessControl::CSCMProcessControl() :
  _lRefs(0),
  _bInitializedEnum(FALSE)
{
}

// Destructor
CSCMProcessControl::~CSCMProcessControl()
{
	ASSERT(_lRefs == 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   FindApplication
//
//  Synopsis:   Creates an enumerator for enumerating over all running com+
//              processes that have registered for the specified application.
//
//  Arguments:  rappid -- the appid they want to know about
//              ppESPI -- out param to store the resulting IEnumSCMProcessInfo
//
//  Returns:    S_OK - life is good;  *ppESPI will be non-NULL if at least 
//                one suitable server was found
//              E_INVALIDARG -- one or more parameters was incorrect  
//              E_OUTOFMEMORY 
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FindApplication(REFGUID rappid, IEnumSCMProcessInfo** ppESPI)
{
	return FindAppOrClass(rappid, gpProcessTable, ppESPI);
}

//+-------------------------------------------------------------------------
//
//  Function:   FindClass
//
//  Synopsis:   Creates an enumerator for enumerating over all running 
//              processes that have registered a class factory for the 
//              specified clsid.
//
//  Arguments:  rclsid -- the clsid they want to know about
//              ppESPI -- out param to store the resulting IEnumSCMProcessInfo
//
//  Returns:    S_OK - life is good;  *ppESPI will be non-NULL if at least 
//                one suitable server was found
//              E_INVALIDARG -- one or more parameters was incorrect  
//              E_OUTOFMEMORY 
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FindClass(REFCLSID rclsid, IEnumSCMProcessInfo **ppESPI)
{ 
	return FindAppOrClass((GUID&)rclsid, gpClassTable, ppESPI);
}

//+-------------------------------------------------------------------------
//
//  Function:   FindProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then calls FillInSCMProcessInfo.
//
//  Arguments:  pid -- process id of the process they're interested in
//              ppSPI -- out param to store a ptr to new SCMProcessInfo struct
//
//  Returns:    S_OK - life is good; *ppSPI will be non-NULL if the process was found
//              E_INVALIDARG -- didn't find that pid
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FindProcess(DWORD pid, SCMProcessInfo** ppSPI)
{
	HRESULT hr = S_OK;
	
	if (!ppSPI)
		return E_INVALIDARG;
	
	*ppSPI = NULL;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves?
	//return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it      
			pprocess->ClientReference();
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	if (pprocess)
	{  
		// REVIEW:  we assume blindly here that the process in question has
		// finished all registration activities.   However, it is possible I 
		// guess for an activator to query about a process before it had 
		// finished registration.   This would not be a very smart activator.
		hr = FillInSCMProcessInfo(pprocess, TRUE, ppSPI);
		ReleaseProcess(pprocess);
	}
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   SuspendApplication
//
//  Synopsis:   Marks as suspended all applications that match the specified
//              appid.   No other applications of this type will be started
//              by RPCSS.   If any applications of this type are started
//              manually, they also will be marked as suspended.
//
//  Arguments:  rappid -- appid to suspend
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::SuspendApplication(REFGUID rappid)
{
	CServerTableEntry *pProcessEntry;
	
	pProcessEntry = gpProcessTable->Lookup( (GUID&)rappid );
	
	if (pProcessEntry)
	{
		pProcessEntry->SuspendApplication();
		pProcessEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SuspendClass
//
//  Synopsis:   Marks as suspended all class factories that have been
//              registered for the specified clsid.   If any new class 
//              factory registrations are encountered after the suspend has
//              been issued, the new registrations will also be suspended.  
//              No new servers will be launched by RPCSS on behalf of this
//              clsid.
//
//  Arguments:  rclsid -- clsid to suspend
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::SuspendClass(REFCLSID rclsid)
{
	CServerTableEntry *pClassEntry;
	
	pClassEntry = gpClassTable->Lookup( (GUID&)rclsid );
	
	if (pClassEntry)
	{
		pClassEntry->SuspendClass();
		pClassEntry->Release();
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SuspendProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then marks that process as suspended (unavailable
//              for further activations).
//
//  Arguments:  pid -- process id of the process callers wants to suspend
//
//  Returns:    S_OK - process was suspended
//              E_INVALIDARG -- didn't find that pid
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::SuspendProcess(DWORD pid)
{
	HRESULT hr = E_INVALIDARG;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves?
    //return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it
			pprocess->Suspend();
			hr = S_OK;
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeApplication
//
//  Synopsis:   Marks as available for activations all applications previously
//              suspended.
//
//  Arguments:  rappid -- application id the caller wants to un-suspend
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::ResumeApplication(REFGUID rappid)
{
	CServerTableEntry *pProcessEntry;
	
	pProcessEntry = gpProcessTable->Lookup( (GUID&)rappid );
	
	if (pProcessEntry)
	{
		pProcessEntry->UnsuspendApplication();
		pProcessEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeClass
//
//  Synopsis:   Marks all servers supporting the specified clsid as available
//              for activation.
//
//  Arguments:  rclsid -- clsid of the object the caller wants to un-suspend
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::ResumeClass(REFCLSID rclsid)
{
	CServerTableEntry *pClassEntry;
	
	pClassEntry = gpClassTable->Lookup( (GUID&)rclsid );
	
	if (pClassEntry)
	{
		pClassEntry->UnsuspendClass();
		pClassEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then marks that process as unsuspended (ie, 
//              available for further activations).
//
//  Arguments:  pid -- process id of the process callers wants to suspend
//
//  Returns:    S_OK - process was suspended
//              E_INVALIDARG -- didn't find that pid
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::ResumeProcess(DWORD pid)
{
	HRESULT hr = E_INVALIDARG;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves?
    //return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it
			pprocess->ClientReference();
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	if (pprocess)
	{
		pprocess->Unsuspend();
		ReleaseProcess(pprocess);
		hr = S_OK;
	}
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireApplication
//
//  Synopsis:   Marks as "retired" all currently running applications with 
//              the specified appid.
//
//  Arguments:  appid -- appid to retire
//
//  Returns:    S_OK - all running applications that matched the appid were
//                retired            
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::RetireApplication(REFGUID rappid)
{
	CServerTableEntry *pProcessEntry;
	
	pProcessEntry = gpProcessTable->Lookup( (GUID&)rappid );
	
	if (pProcessEntry)
	{
		pProcessEntry->RetireApplication();
		pProcessEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireClass
//
//  Synopsis:   Marks as "retired" all currently running processes which 
//              have registered a class factory for the specified clsid.
//
//  Arguments:  rclsid -- clsid to retire
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::RetireClass(REFCLSID rclsid)
{
	CServerTableEntry *pClassEntry;
	
	pClassEntry = gpClassTable->Lookup( (GUID&)rclsid );
	
	if (pClassEntry)
	{
		pClassEntry->RetireClass();
		pClassEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then marks that process as retired (ie, 
//              unavailable for further activations until the end of time).
//
//  Arguments:  pid -- process id of the process callers wants to retire
//
//  Returns:    S_OK - process was suspended
//              E_INVALIDARG -- didn't find that pid
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::RetireProcess(DWORD pid)
{
	HRESULT hr = E_INVALIDARG;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves
    //return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it
			pprocess->Retire();
			hr = S_OK;
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeSCMProcessInfo
//
//  Synopsis:   Method that knows how to free a SCMProcessInfo structure, 
//              including of course its constituent members.
//
//  Arguments:  ppSPI -- ptr-ptr to the SCMProcessInfo struct
//
//  Returns:    S_OK - life is good
//              E_INVALIDARG -- bad parameter
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FreeSCMProcessInfo(SCMProcessInfo** ppSPI)
{
	return CSCMProcessControl::FreeSCMProcessInfoPriv(ppSPI);
}

//+-------------------------------------------------------------------------
//
//  Private CSCMProcessControl methods below here
//
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Function:   FillInSCMProcessInfo 
//
//  Synopsis:   Allocates and fills in a SCMProcessInfo structure for the 
//              given CProcess object.
//
//  Arguments:  pprocess -- ptr to the CProcess object
//              bProcessReady -- whether the process in question is ready to 
//                receive activations
//              ppSPI -- out param to store a ptr to new SCMProcessInfo struct
//
//  Returns:    S_OK - life is good
//              E_OUTOFMEMORY
//
//  Notes:      assumes that at least a read lock is held by the caller for
//              the duration of the call.
//
//    The SCMProcessInfo memory is layed out as follows:
//
//      <SCMProcessInfo>
//      <size of entire allocation>
//      <ref count on this struct>
//      <CProcess*>
//      <winsta string if any>
//      <array of clsids if any>
//
//    (note that the size and refcount combined make 8 bytes, thus maintaining ptr alignment on Win64)
//    (the winsta string is also padded out to a multiple of the platform ptr size)
//
//    The pointer members of the SCMProcessInfo struct point beyond the 
//    SCMProcessInfo struct proper to the appropriate data.   The saved CProcess*
//    object has an added refcount.    The # of users using the struct is counted
//    by the ref count field.    We don't free the struct until this falls to zero
//    (done in FreeSCMProcessInfoPriv below).     Use the macros in scminfo.hxx to
//    access these undoc'd members.
//
//    If you modify this layout watch out for Win64 alignment issues.
//
HRESULT CSCMProcessControl::FillInSCMProcessInfo(CProcess* pprocess, BOOL bProcessReady, SCMProcessInfo** ppSPI)
{
	HRESULT hr = S_OK;
	ULONG ulWinstaStrlen = 0;
	SCMProcessInfo* pSPI = NULL;
	
	ASSERT(pprocess);
	ASSERT(ppSPI);
	
	*ppSPI = NULL;
	
	// Try to take fast path.  We can do this if the process in question has not added or
	// removed any class registrations.
	gpServerLock->LockShared();
	
	if (!pprocess->SPIDirty())
	{
		// great; make a copy of the struct that we previously cached in the process 
		// object; this struct won't be messed with while we're holding the read lock
		hr = CopySCMProcessInfo((SCMProcessInfo*)pprocess->GetSCMProcessInfo(), ppSPI);    
		gpServerLock->UnlockShared();
		return hr;
	}
	
	gpServerLock->UnlockShared();
	
	// Darn, the process changed its set of registrations, or this is the first time we've ever
	// done this.  Take a write lock and do it the hard way
	gpServerLock->LockExclusive();
	
	if (!pprocess->SPIDirty())
	{
		// we got beat to the lock
		hr = CopySCMProcessInfo((SCMProcessInfo*)pprocess->GetSCMProcessInfo(), ppSPI);    
		gpServerLock->UnlockExclusive();
		return hr;
	}
	
	// Find length of the winsta string
	if (pprocess->_pwszWinstaDesktop)
	{
		ulWinstaStrlen = lstrlenW(pprocess->_pwszWinstaDesktop) + sizeof(WCHAR);
		
		// Need for the string buffer to be a even multiple of the ptr size
		ulWinstaStrlen = (ulWinstaStrlen + MEM_ALIGN_SIZE - 1) & ~(MEM_ALIGN_SIZE - 1);
	}
    
	// Allocate one buffer to hold the struct, the winsta string, and the CLSIDs:
	ULONG ulBufSizeNeeded = sizeof(SCMProcessInfo) + 
		sizeof(ULONG) +
		sizeof(ULONG) +
		sizeof(CProcess*) +
		(ulWinstaStrlen * sizeof(WCHAR)) +
		(pprocess->_ulClasses * sizeof(CLSID));
	
	pSPI = (SCMProcessInfo*) new BYTE[ ulBufSizeNeeded ];
	if (!pSPI)
	{
		gpServerLock->UnlockExclusive();
		return E_OUTOFMEMORY;
	}
	
	ZeroMemory(pSPI, ulBufSizeNeeded);   
	
	// Store the allocation size.   This takes up an extra dword , but saves
	// a lot of time when we have to copy the struct
	*SPI_TO_SIZE(pSPI)= ulBufSizeNeeded;
	
	// Store a pointer to the CProcess* object itself and take a reference on it
	*SPI_TO_CPROCESS(pSPI) = pprocess;
	pprocess->Reference();
	
	// Mark the initial refcount as one.   This refcount belongs to the CProcess object
	// when we cache it below
	*SPI_TO_REFCOUNT(pSPI) = 1;
	
	CLSID* pCLSIDs;
	WCHAR* pwszWinSta = NULL;
	
	// Copy the winsta string
	if (ulWinstaStrlen > 0)
	{
		pwszWinSta = SPI_TO_WINSTA(pSPI);
		lstrcpyW(pwszWinSta, pprocess->_pwszWinstaDesktop);
		pSPI->pwszWinstaDesktop = pwszWinSta;
	}
	
	// Copy the clsids
	ULONG ulCLSID = 0;
	if (pprocess->_ulClasses > 0)
	{
	    Assert (pwszWinSta);
	    
		pSPI->ulNumClasses = pprocess->_ulClasses;
		pSPI->pCLSIDs = (CLSID*) (pwszWinSta + ulWinstaStrlen);
		
		CClassReg* pReg = (CClassReg*)pprocess->_listClasses.First();
		while (pReg)
		{
			pSPI->pCLSIDs[ulCLSID] = pReg->_Guid;
			pReg = (CClassReg*)pReg->Next();
			ulCLSID++;
		}
	}
	
	ASSERT(ulCLSID == pprocess->_ulClasses);
	
	pSPI->pidProcess = pprocess->GetPID();
	
	// We hold a reference on the CProcess object, which owns the process handle until
	// it goes away.  So it's safe to store the handle directly like this.
    // The handle may be NULL if we didn't launch the process, callers have the responsibility
    // of checking for this.
    pSPI->hProcess = pprocess->GetProcessHandle();
	
	// We hold a reference on the CProcess object, which holds a reference on it's CToken
	// object.  So it's safe to store the token directly like this, it won't go away.
	pSPI->hImpersonationToken = pprocess->GetToken()->GetToken();   
	
	// The process will only have a ScmProcessReg if it is a COM+ app      
	if (pprocess->_pScmProcessReg)
	{
		pSPI->dwState |= SPIF_COMPLUS;
		pSPI->AppId = pprocess->_pScmProcessReg->ProcessGUID;
		
		// flip the ready bit
		if (pprocess->_pScmProcessReg->ReadinessStatus & SERVERSTATE_READY)
		{
			pSPI->dwState |= SPIF_READY;
		}
	}
	else
	{
		// Legacy-style server.  We consider the process to be "ready" if it's
		// not in the midst of doing class registrations.  The caller tells us this.
		if (bProcessReady)
		{
			pSPI->dwState |= SPIF_READY;
		}
	}
	
	if (pprocess->IsSuspended())
		pSPI->dwState |= SPIF_SUSPENDED;
	
	if (pprocess->IsRetired())
		pSPI->dwState |= SPIF_RETIRED;
	
	if (pprocess->IsPaused())
		pSPI->dwState |= SPIF_PAUSED;
	
	pSPI->ftCreated = *(pprocess->GetFileTimeCreated());
	
	// UNDONE:  server type and identity.  Still working on the exact details of this
	
	//pSPI->ServerType = 
	//if (pSPI->ServerType != SET_SERVICE_
	//  pSPI->ServerIdent = 
	
	// Before we leave the lock, we need to replace the cached struct in the process object
	// with the new one; this also clears the dirty bit on the process  
	pprocess->SetSCMProcessInfo((void*)pSPI);
	
	// Lastly, make a new copy to return to the caller
	hr = CopySCMProcessInfo(pSPI, ppSPI);    
	
	gpServerLock->UnlockExclusive();
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeSCMProcessInfoPriv
//
//  Synopsis:   Method that knows how to free a SCMProcessInfo structure, 
//              including of course its constituent members.
//
//  Arguments:  ppSCMProcessInfo -- ptr-ptr to the SCMProcessInfo struct
//
//  Returns:    S_OK - life is good
//              E_INVALIDARG -- bad parameter
//
//  Note:   refer to the header comments for FillInSCMProcessInfo for info 
//          on the extended layout of a SCMProcessInfo struct.
//  
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::FreeSCMProcessInfoPriv(SCMProcessInfo** ppSCMProcessInfo)
{
	if (!ppSCMProcessInfo)
		return E_INVALIDARG;
	
	if (*ppSCMProcessInfo)
	{
		// Decrement the struct ref count; it will not fall to zero until the CProcess*
		// object releases its reference, which will not happen unless it is either
		// a) rundown; or b) replacing a previous dirty SPI with a new one
		LONG lRefs = InterlockedDecrement(SPI_TO_REFCOUNT(*ppSCMProcessInfo));
		if (lRefs == 0)
		{
			(*SPI_TO_CPROCESS(*ppSCMProcessInfo))->Release();
			
			delete (*ppSCMProcessInfo);
		}
		*ppSCMProcessInfo = NULL;
	}
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   CopySCMProcessInfo
//
//  Synopsis:   Allocates and fills in a SCMProcessInfo structure for the 
//              given CProcess server.
//
//  Arguments:  pSPISrc -- ptr to the SCMProcessInfo struct that is to be copied 
//              ppSPIDest -- ptrptr to store the copied struct
//
//  Returns:    S_OK - success
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::CopySCMProcessInfo(SCMProcessInfo* pSPISrc, SCMProcessInfo** ppSPIDest)
{
	ASSERT(pSPISrc && ppSPIDest);
	
	if (!pSPISrc || !ppSPIDest)
		return E_INVALIDARG;
	
	LONG lNewRefs = InterlockedIncrement(SPI_TO_REFCOUNT(pSPISrc));
	
	*ppSPIDest = pSPISrc;
	
	return S_OK;
};


//+-------------------------------------------------------------------------
//
//  Function:   FindAppOrClass
//
//  Synopsis:   This is a generic helper function used by the FindApplication
//              and FindClass methods.    The logic is the same for either.
//
//  Arguments:  rguid -- the appid or clsid to use in the query
//              pServerTable - the table to use in the query
//              ppESPI -- the place to store the resulting enumerator object
//
//  Returns:    S_OK - success
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::FindAppOrClass(const GUID& rguid, CServerTable* pServerTable, IEnumSCMProcessInfo** ppESPI)
{
	HRESULT hr = S_OK;
	CSCMProcessEnumerator* pSPEnum = NULL;
	CServerTableEntry* pSTE = NULL;
	
	if (!ppESPI)
		return E_INVALIDARG;
	
	*ppESPI = NULL;
	
	pSTE = pServerTable->Lookup((GUID&)rguid);
	if (!pSTE)
	{
		return S_OK;
	}
	
	pSPEnum = new CSCMProcessEnumerator();
	if (!pSPEnum)
	{
		pSTE->Release();
		return E_OUTOFMEMORY;
	}
    
	CServerList* pServerList = pSTE->GetServerListWithSharedLock();
	ASSERT(pServerList && "unexpected NULL pServerList");
	
	// For each server that has registered for this appid/clsid, add a 
	// SCMProcessInfo to the enumerator object
	CServerListEntry* pSLE = (CServerListEntry*)pServerList->First();
	while (pSLE)
	{
		SCMProcessInfo* pSPI;
		
		CProcess* pprocess = pSLE->GetProcess(); // not refcounted
		ASSERT(pprocess);
		
		hr = FillInSCMProcessInfo(pprocess, pSLE->IsReadyForActivations(), &pSPI);
		if (SUCCEEDED(hr))
		{
			// add it to the enumerator; on success, the enumerator owns it
			hr = pSPEnum->AddProcess(pSPI);
			if (FAILED(hr)) 
			{
				FreeSCMProcessInfoPriv(&pSPI);  // we still own it, so free the memory
				break;
			}
		}
		else
			break;
		
		pSLE = (CServerListEntry*) pSLE->Next();
	}
	
	pSTE->ReleaseSharedListLock();
	
	if (SUCCEEDED(hr))
	{
		hr = pSPEnum->QueryInterface(__uuidof(IEnumSCMProcessInfo), (void**)ppESPI);
	}
	
	pSPEnum->Release();
	pSTE->Release();
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeEnumerator
//
//  Synopsis:   Initializes the aggregated enumerator object for use.  Mainly
//              this consists of adding SCMProcessInfo's for all known servers
//              to the enumerator.
//
//  Arguments:  none
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::InitializeEnumerator()
{
	return E_NOTIMPL;
}

// IUnknown implementation for CSCMProcessControl
STDMETHODIMP CSCMProcessControl::QueryInterface(REFIID riid, void** ppv)
{
	HRESULT hr = S_OK;
	if (!ppv)
		return E_POINTER;
	
	*ppv = NULL;
	
	if (riid == IID_IUnknown || riid == IID_ISCMProcessControl)
	{
		*ppv = (void*)this;
		AddRef();
		return S_OK;
	}
	/*
	else if (riid == IID_IEnumSCMProcessInfo)
	{
    if (!_bInitializedEnum)
    {
	// First time we've been QI'd for this interface; create an 
	// enumerator object to aggregate over.
	hr = InitializeEnumerator();
	_bInitializedEnum = TRUE;
    }
	
	  if (SUCCEEDED(hr))
	  {
      hr = _SPEnum.QueryInterface(riid, ppv);
	  }
	  return hr;
	  }
	*/
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSCMProcessControl::AddRef()
{
	return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CSCMProcessControl::Release()
{
	LONG lRefs = InterlockedDecrement(&_lRefs);
	if (lRefs == 0)
	{
		delete this;
	}
	return lRefs;
}

//+-------------------------------------------------------------------------
//
//  Implementation of CSCMProcessEnumerator begins here
//
//--------------------------------------------------------------------------

//
// ctor used by the CSCMProcessControl object
//
CSCMProcessEnumerator::CSCMProcessEnumerator() :
	_lRefs(1),
	_dwNumSPInfos(0),
	_dwMaxSPInfos(SPENUM_INITIAL_SIZE),
	_dwCurSPInfo(0),
	_ppSPInfos(NULL),
	_ppSPInfosForReal(_pSPInfosInitial),
	_pOuterUnk(NULL)
{
	  ZeroMemory(_pSPInfosInitial, sizeof(SCMProcessInfo*) * SPENUM_INITIAL_SIZE);
}

//
// ctor used by the Clone method to create new copies of an enumerator
//
CSCMProcessEnumerator::CSCMProcessEnumerator(CSCMProcessEnumerator* pCSPEOrig,
                                             HRESULT* phrInit) :
	_lRefs(1),
	_dwNumSPInfos(0),  // this gets adjusted in the loop below
	_dwMaxSPInfos(pCSPEOrig->_dwMaxSPInfos),
	_dwCurSPInfo(pCSPEOrig->_dwCurSPInfo),
	_pOuterUnk(NULL)
{  
	ZeroMemory(_pSPInfosInitial, sizeof(SCMProcessInfo*) * SPENUM_INITIAL_SIZE);
	
	if (_dwMaxSPInfos == SPENUM_INITIAL_SIZE)
	{
		// The src enumerator did not grown beyond SPENUM_INITIAL_SIZE
		_ppSPInfosForReal = _pSPInfosInitial;
	}
	else
	{
		// The src enumerator did grow, so we need to create an array 
		// to hold everything
		_ppSPInfos = new SCMProcessInfo*[_dwMaxSPInfos];
		if (!_ppSPInfos)
		{
			*phrInit = E_OUTOFMEMORY;
			return;
		}
		ZeroMemory(_ppSPInfos, sizeof(SCMProcessInfo*) * _dwMaxSPInfos);
		_ppSPInfosForReal = _ppSPInfos;
	}
	
	// Make copies of each of the original enumerator's SCMProcessInfo structs
	DWORD dwNumSPInfosInOriginal = pCSPEOrig->_dwNumSPInfos;
	for (DWORD i = 0; i < dwNumSPInfosInOriginal; i++)
	{
		*phrInit = CSCMProcessControl::CopySCMProcessInfo(pCSPEOrig->_ppSPInfos[i], &(_ppSPInfosForReal[i]));
		if (FAILED(*phrInit))
			return;
		
		_dwNumSPInfos++;
	}     
}

//
// ctor used when we are aggregated by the CSCMProcessControl object
//
CSCMProcessEnumerator::CSCMProcessEnumerator(CSCMProcessControl* pOuterUnk) :
	_lRefs(-1),        // don't use refcount when we are aggregated
	_dwNumSPInfos(0), 
	_dwMaxSPInfos(SPENUM_INITIAL_SIZE),
	_dwCurSPInfo(0),
	_ppSPInfosForReal(_pSPInfosInitial),
	_pOuterUnk(pOuterUnk)  // not refcounted!
{  
}

//
// dtor
//
CSCMProcessEnumerator::~CSCMProcessEnumerator()
{
#ifdef DBG
	if (_pOuterUnk)
		ASSERT(_lRefs == -1);
	else
		ASSERT(_lRefs == 0);
#endif
  
	for (DWORD i = 0; i < _dwNumSPInfos; i++)
	{
		CSCMProcessControl::FreeSCMProcessInfoPriv(&(_ppSPInfosForReal[i]));
	}
  
#ifdef DBG
	for (DWORD j = i; j < _dwMaxSPInfos; j++)
	{
		ASSERT(_ppSPInfosForReal[j] == NULL);
	}
#endif

	if (_ppSPInfos)
	{
		ASSERT(_dwMaxSPInfos > SPENUM_INITIAL_SIZE);
		delete _ppSPInfos;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   Next
//
//  Synopsis:   Returns to the caller the requested # of SCMProcessInfo
//              ptrs.    
//
//  Arguments:  cElems -- # of requested structs
//              ppSPI -- ptr to an array of size cElems
//              pcFetched -- out param containg # of elements actually
//                fetched; can be NULL.
//
//  Returns:    S_OK - the requested # of elements were returned
//              S_FALSE -- only some of the requested # of elements were returned
//              E_INVALIDARG -- one or more parameters were bogus
//
//  Notes:      the caller's ppSPI array, on success, will contain ptrs to the 
//              enumerator's SPI structs.    The caller may only use his ptrs while
//              he holds a reference on the enumerator.
// 
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessEnumerator::Next(ULONG cElems, SCMProcessInfo** ppSPI, ULONG* pcFetched)
{
	if (!ppSPI)
		return E_INVALIDARG;
    
	ZeroMemory(ppSPI, sizeof(SCMProcessInfo*) * cElems);
	
	DWORD dwFetched = 0;
	for (DWORD i = _dwCurSPInfo; (i < _dwNumSPInfos) && (dwFetched < cElems); i++, dwFetched++)
	{
		ppSPI[dwFetched] = _ppSPInfosForReal[i];
	}
	
	// tell the caller how many he's getting, if he cared
	if (pcFetched)
		*pcFetched = dwFetched;
	
	// Advance the cursor
	_dwCurSPInfo += dwFetched;
	
	return (dwFetched == cElems) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   Skip
//
//  Synopsis:   Advances the enumerator's "cursor"/ptr by the specified #
//              of elements
//
//  Arguments:  cElems -- the # of elements to advance the cursor by
//
//  Returns:    S_OK - success
//              S_FALSE - there were not a sufficient # of elements to advance
//                that many by.  The cursor now points to the last element.
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessEnumerator::Skip(ULONG cElems)
{
	_dwCurSPInfo += cElems;
	if (_dwCurSPInfo > _dwNumSPInfos)
	{
		_dwCurSPInfo = _dwNumSPInfos;
		return S_FALSE;
	}
	else
		return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   Reset
//
//  Synopsis:   Resets the enumerator "cursor"/ptr to the initial element
//
//  Arguments:  none
//
//  Returns:    S_OK
//
STDMETHODIMP CSCMProcessEnumerator::Reset()
{
	_dwCurSPInfo = 0;
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   Clone
//
//  Synopsis:   Creates a copy of this enumerator and returns it.
//
//  Arguments:  ppESPI -- out-param for newly created copy
//
//  Returns:    S_OK - life is good
//              E_INVALIDARG - bad input parameter
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessEnumerator::Clone(IEnumSCMProcessInfo **ppESPI)
{
	HRESULT hr = S_OK;
	
	if (!ppESPI)
		return E_INVALIDARG;
	
	*ppESPI = NULL;
	
	CSCMProcessEnumerator* pNewEnum = new CSCMProcessEnumerator(this, &hr);
	if (!pNewEnum)
		return E_OUTOFMEMORY;
	
	if (SUCCEEDED(hr))
	{
		hr = pNewEnum->QueryInterface(IID_IEnumSCMProcessInfo, (void**)ppESPI);
	}
	
	pNewEnum->Release();
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   AddProcess
//
//  Synopsis:   Adds the supplied SCMProcessInfo struct to the list managed
//              by this enumerator.
//
//  Arguments:  pSPI -- SCMProcessInfo struct to be added
//
//  Returns:    S_OK - new struct was successfully added
//              E_OUTOFMEMORY
//
//  Notes:      the list of SCMProcessInfo's managed by this enumerator is
//              implemented as a fixed-size array which is grown on demand.
//              This enumerator owns freeing the pSPI struct once added.
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessEnumerator::AddProcess(SCMProcessInfo* pSPI)
{
	ASSERT(pSPI);
	
	if (!pSPI)
		return E_INVALIDARG;
    
	// Time to grow the array?
	if (_dwNumSPInfos == _dwMaxSPInfos)
	{
		DWORD dwNewArraySize = _dwMaxSPInfos + SPENUM_GROWTH_SIZEADD;  // 10,20,30, etc
		SCMProcessInfo** ppSPInfosNew = new SCMProcessInfo*[dwNewArraySize];
		if (!ppSPInfosNew)
			return E_OUTOFMEMORY; 
		
		// Zero everything out
		ZeroMemory(ppSPInfosNew, sizeof(SCMProcessInfo*) * dwNewArraySize);
		
		// Copy over the contents of the old array
		CopyMemory(ppSPInfosNew, _ppSPInfosForReal, sizeof(SCMProcessInfo*) * _dwMaxSPInfos);
    
#ifdef DBG
		// Fill in the old array with a dummy value
		FillMemory(_pSPInfosInitial, sizeof(SCMProcessInfo*) * _dwMaxSPInfos, 0xba);
#endif

		if (_dwMaxSPInfos > SPENUM_INITIAL_SIZE)
		{
			// We're growing larger than a previous dynamic array; cleanup
			// the old memory
			ASSERT(_ppSPInfos);
			delete _ppSPInfos;
		}
		
		_ppSPInfos = ppSPInfosNew;
		_ppSPInfosForReal = _ppSPInfos;
		_dwMaxSPInfos = dwNewArraySize;
	}
	
	// Store the new SCMProcessInfo struct
	_ppSPInfosForReal[_dwNumSPInfos] = pSPI;
	_dwNumSPInfos++;
	
	return S_OK;
}

// IUnknown implementation for CSCMProcessEnumerator
STDMETHODIMP CSCMProcessEnumerator::QueryInterface(REFIID riid, void** ppv)
{
	if (!ppv)
		return E_POINTER;
	
	if (riid == IID_IUnknown || riid == IID_IEnumSCMProcessInfo)
	{
		if (_pOuterUnk && riid == IID_IUnknown)
			return _pOuterUnk->QueryInterface(riid, ppv);
		
		*ppv = (void*)this;
		AddRef();
		return S_OK;
	}
	else if (_pOuterUnk)
	{
		// Unknown interface, let punkouter take care of it
		return _pOuterUnk->QueryInterface(riid, ppv);
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSCMProcessEnumerator::AddRef()
{
	if (_pOuterUnk)
		return _pOuterUnk->AddRef();
	
	return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CSCMProcessEnumerator::Release()
{
	if (_pOuterUnk)
		return _pOuterUnk->Release();
	
	LONG lRefs = InterlockedDecrement(&_lRefs);
	if (lRefs == 0)
	{
		delete this;
	}
	return lRefs;
}

//+-------------------------------------------------------------------------
//
//  Function:  FreeSPIFromCProcess
//
//  Synopsis:  CProcess's don't know about CSCMProcessControl stuff.  This is
//             helper function which CProcess extern's in order to call
//
//--------------------------------------------------------------------------
HRESULT FreeSPIFromCProcess(void** ppSCMProcessInfo)
{
  return CSCMProcessControl::FreeSCMProcessInfoPriv((SCMProcessInfo**)ppSCMProcessInfo);
}



//+-------------------------------------------------------------------------
//
//  Function:  PrivGetRPCSSInfo
//
//  Synopsis:  Activators that call GetRPCSSInfo (exported from rpcss.dll) 
//             end up in this function; they call here in order to get an 
//             interface on which they can query & adjust the scm activation state. 
//
//  History:   05-Sep-99   JSimmons   Created
//
//--------------------------------------------------------------------------
HRESULT PrivGetRPCSSInfo(REFCLSID rclsid, REFIID riid, void** ppv)
{
	HRESULT hr = E_INVALIDARG;
	
	if (!ppv)
		return E_POINTER;

	if (rclsid == CLSID_RPCSSInfo)
	{
		CSCMProcessControl* pSPC = NULL;
		pSPC = new CSCMProcessControl();
		if (pSPC)
		{
			hr = pSPC->QueryInterface(riid, ppv);
			if (FAILED(hr))
				delete pSPC;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\scmif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scmif.cxx
//
//  Contents:   Entry points for scm interface.
//
//  Functions:  StartObjectService
//              SvcActivateObject
//              SvcCreateActivateObject
//              ObjectServerStarted
//              StopServer
//
//  History:    01-May-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//
//--------------------------------------------------------------------------

#include "act.hxx"

extern void UpdateCOMPlusEnabled();

//+-------------------------------------------------------------------------
//
//  Function:   Dummy1
//
//  Synopsis:   Needed for IDL hack.  Never called.
//
//  Arguments:  [hRpc] - RPC handle
//              [orpcthis] - ORPC handle
//              [localthis] - ORPC call data
//              [orpcthat] - ORPC reply data
//
//  Returns:    HRESULT
//
//  History:    14 Apr 95   AlexMit    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT DummyQueryInterfaceIOSCM(
    handle_t  hRpc,
    ORPCTHIS  *orpcthis,
    LOCALTHIS *localthis,
    ORPCTHAT *orpcthat,
    DWORD     dummy )
{
    CairoleDebugOut((DEB_ERROR, "SCM Dummy function should never be called!\n" ));
    orpcthat->flags      = 0;
    orpcthat->extensions = NULL;
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Function:   Dummy2
//
//  Synopsis:   Needed for IDL hack.  Never called.
//
//  Arguments:  [hRpc] - RPC handle
//              [orpcthis] - ORPC handle
//              [localthis] - ORPC call data
//              [orpcthat] - ORPC reply data
//
//  Returns:    HRESULT
//
//  History:    14 Apr 95   AlexMit    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT DummyAddRefIOSCM(
    handle_t  hRpc,
    ORPCTHIS  *orpcthis,
    LOCALTHIS *localthis,
    ORPCTHAT *orpcthat,
    DWORD     dummy )
{
    CairoleDebugOut((DEB_ERROR, "SCM Dummy function should never be called!\n" ));
    orpcthat->flags      = 0;
    orpcthat->extensions = NULL;
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Function:   Dummy3
//
//  Synopsis:   Needed for IDL hack.  Never called.
//
//  Arguments:  [hRpc] - RPC handle
//              [orpcthis] - ORPC handle
//              [localthis] - ORPC call data
//              [orpcthat] - ORPC reply data
//
//  Returns:    HRESULT
//
//  History:    14 Apr 95   AlexMit    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT DummyReleaseIOSCM(
    handle_t  hRpc,
    ORPCTHIS  *orpcthis,
    LOCALTHIS *localthis,
    ORPCTHAT *orpcthat,
    DWORD     dummy )
{
    CairoleDebugOut((DEB_ERROR, "SCM Dummy function should never be called!\n" ));
    orpcthat->flags      = 0;
    orpcthat->extensions = NULL;
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Function:   ServerRegisterClsid
//
//  Synopsis:   Notifies SCM that server is started for a class
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [lpDeskTop] - caller's desktop
//              [pregin] - array of registration entries
//              [ppregout] - array of registration cookies to return
//              [rpcstat] - status code
//
//  Returns:    HRESULT
//
//  History:    01-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT ServerRegisterClsid(
    handle_t hRpc,
    PHPROCESS phProcess,
    RegInput *pregin,
    RegOutput **ppregout,
    error_status_t *prpcstat)
{
    RegOutput*          pregout;
    CServerTableEntry*  pClassTableEntry;
    CClsidData*         pClsidData = NULL;
    DWORD               Size, Entries, i;
    UCHAR               ServerState;
    LONG                Status;
    HRESULT             hr = S_OK;
    CNamedObject**      pRegisterEvents = NULL; 

    // Parameter validation
    if (!prpcstat || !pregin || !ppregout)
        return E_INVALIDARG;

    *prpcstat = 0;
    *ppregout = NULL;

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    // Allocate an array of handles to hold the register events.
    pRegisterEvents = (CNamedObject**)alloca(sizeof(CNamedObject*) * pregin->dwSize);
    memset(pRegisterEvents, 0, sizeof(CNamedObject*) * pregin->dwSize);

    Size = sizeof(RegOutput) + (pregin->dwSize - 1) * sizeof(DWORD);
    *ppregout = (RegOutput *) PrivMemAlloc(Size);
    if (!(*ppregout))
    {
        return E_OUTOFMEMORY;
    }

    pregout = *ppregout;
    memset( pregout, 0, Size );
    pregout->dwSize = pregin->dwSize;

    Entries = pregin->dwSize;

    //
    // First loop, we add all of the registrations.
    //
    for ( i = 0; i < Entries; i++ )
    {
        pClsidData = 0;

        // This path taken by non-COM+ servers, ergo 
        // no IComClassinfo 
        (void) LookupClsidData(
                    pregin->rginent[i].clsid,
                    NULL,
                    pProcess->GetToken(),
                    LOAD_APPID,
                    &pClsidData );

        //
        // Check that the caller is allowed to register this CLSID.
        //
        if ( pClsidData && ! pClsidData->CertifyServer( pProcess ) )
        {
            delete pClsidData;
            hr = CO_E_WRONG_SERVER_IDENTITY;
            break;
        }
        
        //
        // Get the register event for this clsid, to be signalled later on
        // in the second loop below.   If we couldn't find a pClsidData for
        // this clsid, that's fine it just means it was a registration for
        // an unknown clsid (which is legal).
        //
        if (pClsidData)
        {
            pRegisterEvents[i] = pClsidData->ServerRegisterEvent();
            if (!pRegisterEvents[i])
            {
                delete pClsidData;
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        ServerState = SERVERSTATE_SUSPENDED;

        // Note:  REGCLS_SINGLEUSE is *not* a bitflag, it's zero!
        // Therefore, it is incompatible with all other flags
        if ( pregin->rginent[i].dwFlags == REGCLS_SINGLEUSE )
            ServerState |= SERVERSTATE_SINGLEUSE;

        if ( pregin->rginent[i].dwFlags & REGCLS_SURROGATE )
            ServerState |= SERVERSTATE_SURROGATE;

        pClassTableEntry = gpClassTable->GetOrCreate( pregin->rginent[i].clsid );

        if ( ! pClassTableEntry )
            hr = E_OUTOFMEMORY;

        if ( pClassTableEntry )
        {
            hr = pClassTableEntry->RegisterServer(
                                        pProcess,
                                        pregin->rginent[i].ipid,
                                        pClsidData,
                                        NULL,
                                        ServerState,
                                        &pregout->RegKeys[i] );

            pClassTableEntry->Release();
        }

        if ( pClsidData )
        {
            delete pClsidData;
            pClsidData = NULL;
        }

        if ( hr != S_OK )
            break;
    }

    //
    // If we encountered any errors then we remove any entries which were
    // successfully added.
    //
    // On success, we now signal all of the class table events.
    //
    // This loop restarts itself in removal mode if it encounters an errors
    // while trying to signal the register events.
    //
    for ( i = 0; i < Entries; i++ )
    {
        pClassTableEntry = gpClassTable->Lookup( pregin->rginent[i].clsid );

        if ( S_OK == hr )
        {
            ASSERT( pClassTableEntry );

            pClassTableEntry->UnsuspendServer( pregout->RegKeys[i] );
            
            //
            //  Signal to waiting client (if any) that this clsid is registered
            // 
            if (pRegisterEvents[i])
            {
                SetEvent(pRegisterEvents[i]->Handle());
                pRegisterEvents[i]->Release();
                pRegisterEvents[i] = NULL;
            }
        }

        if ( (hr != S_OK) && pregout->RegKeys[i] )
        {
            if ( pClassTableEntry )
                pClassTableEntry->RevokeServer( pProcess, pregout->RegKeys[i] );
        }

        if ( pClassTableEntry )
            pClassTableEntry->Release();
    }

    if ( hr != S_OK )
        memset( pregout->RegKeys, 0, pregout->dwSize * sizeof(DWORD) );
    
    //
    // Release all of the registration event handles
    //
    for (i = 0; i < Entries; i++)
    {
        if (pRegisterEvents[i])
        {
            pRegisterEvents[i]->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ServerRevokeClsid
//
//  Synopsis:   Get notification that class server is stopping
//
//  Arguments:  [hRpc] - RPC handle
//              [prevcls] - list of classes/registrations to stop
//
//  History:    01-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
extern "C" void ServerRevokeClsid(
    handle_t hRpc,
    PHPROCESS phProcess,
    RevokeClasses *prevcls,
    error_status_t *prpcstat)
{
    CServerTableEntry*  pClassTableEntry;
    RevokeEntry*        prevent;
    DWORD               Entries;

    // Parameter validation
    if (!prpcstat || !prevcls)
        return; // E_INVALIDARG

    *prpcstat = 0;

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return; // E_ACCESSDENIED
            
    Entries = prevcls->dwSize;
    prevent = prevcls->revent;

    for ( ; Entries--; prevent++ )
    {
        pClassTableEntry = gpClassTable->Lookup( prevent->clsid );
        if ( pClassTableEntry )
        {
            pClassTableEntry->RevokeServer( pProcess, prevent->dwReg );
            pClassTableEntry->Release();
        }
    }
}

void GetThreadID(
    handle_t    hRpc,
    PHPROCESS phProcess,
    DWORD *     pThreadID,
    error_status_t *prpcstat)
{
    if (!CheckLocalSecurity(hRpc, phProcess))
        RpcRaiseException(ERROR_ACCESS_DENIED);
	
    // Parameter validation
    if (!pThreadID || !prpcstat)
        return;

    *prpcstat = 0;
    *pThreadID = InterlockedExchangeAdd((long *)&gNextThreadID,1);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateActivationSettings
//
//  Synopsis:   Re-read default activation settings.
//
//  Arguments:  [hRpc] - RPC handle
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------

extern void ComputeSecurity();

extern "C" void UpdateActivationSettings(
    handle_t hRpc,
    PHPROCESS phProcess,
    error_status_t *prpcstat)
{
    if (!CheckLocalSecurity(hRpc, phProcess))
        RpcRaiseException(ERROR_ACCESS_DENIED);

    // Parameter validation
    if (!prpcstat)
        return;

    *prpcstat = 0;

    ReadRemoteActivationKeys();
    ComputeSecurity();
    UpdateCOMPlusEnabled();
}


//+-------------------------------------------------------------------------
//
//  Function:   VerifyCallerIsAdministrator
//
//  Synopsis:   Verifies that the specified user is an administrator
//
//  Returns:    S_OK  -- success, *pbAdmin is valid
//              other -- error occurred
//
//  Arguments:  [pToken] - token of the user
//              [pbAdmin] - out param denoting admin status
//
//--------------------------------------------------------------------------
HRESULT VerifyCallerIsAdministrator(CToken* pToken, BOOL* pbAdmin)
{
    BOOL fSuccess;
    PSID psidAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
        
    // Allocate sid for Administrators
    fSuccess = AllocateAndInitializeSid(&SystemSidAuthority, 2, 
                                        SECURITY_BUILTIN_DOMAIN_RID, 
                                        DOMAIN_ALIAS_RID_ADMINS,
                                        0, 0, 0, 0, 0, 0, &psidAdmin);
    if (!fSuccess)
        return HRESULT_FROM_WIN32(GetLastError());

    // Check that caller is an admin
    fSuccess = CheckTokenMembership(pToken->GetToken(), psidAdmin, pbAdmin);
	
    FreeSid(psidAdmin);

    if (!fSuccess)
        return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   EnableDisableDynamicIPTracking
//
//  Synopsis:   Writes a "Y" or "N" to the HKLM\Software\MS\Ole\
//              EnableSystemDynamicIPTracking string value, and sets the 
//              global variable gbDynamicIPChangesEnabled accordingly.
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [fEnable] - whether to enable or disable
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C"
HRESULT EnableDisableDynamicIPTracking(
    handle_t hRpc,
    PHPROCESS phProcess,
    BOOL fEnable,
    error_status_t* prpcstat)
{
    HRESULT hr = S_OK;
    BOOL bAdmin;
    ORSTATUS status;

    // Parameter validation
    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateTokenForRPCClient(hRpc, FALSE, &pToken, NULL);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;

    SCMVDATEHEAP();
    
    hr = gAddrExclusionMgr.EnableDisableDynamicTracking(fEnable);

    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetCurrentIPExclusionList
//
//  Synopsis:   Passes the contents of the current address exclusion list
//              back to the caller
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [pdwNumStrings] - size of the pppszStrings array
//              [pppszStrings] - array of pointers to NULL-term'd strings
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C"
HRESULT GetCurrentAddrExclusionList(
    handle_t hRpc,
    PHPROCESS phProcess,
    DWORD* pdwNumStrings,
    LPWSTR** pppszStrings,
    error_status_t* prpcstat)
{
    HRESULT hr = S_OK;
    BOOL bAdmin;
    ORSTATUS status;

    // Parameter validation
    if (!prpcstat || !pppszStrings || !pppszStrings)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateTokenForRPCClient(hRpc, FALSE, &pToken, NULL);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;
	
    SCMVDATEHEAP();

    hr = gAddrExclusionMgr.GetExclusionList(
                    pdwNumStrings,
                    pppszStrings);         
    
    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetAddrExclusionList
//
//  Synopsis:   Re-sets the contents of the address exclusion list, and updates
//              all currently running processes with the new bindings.
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [dwNumStrings] - size of the ppszStrings array
//              [ppszStrings] - array of pointers to NULL-term'd strings
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C"
HRESULT SetAddrExclusionList(
    handle_t hRpc,
    PHPROCESS phProcess,
    DWORD dwNumStrings,
    LPWSTR* ppszStrings,
    error_status_t* prpcstat)
{
    HRESULT hr = S_OK;
    BOOL bAdmin;
    ORSTATUS status;

    // Parameter validation
    if (!ppszStrings || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateTokenForRPCClient(hRpc, FALSE, &pToken, NULL);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;

    SCMVDATEHEAP();

    hr = gAddrExclusionMgr.SetExclusionList(
                    dwNumStrings,
                    ppszStrings);                             

    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   FlushSCMBindings
//
//  Synopsis:   Remove the specified machine bindings from our remote binding
//              handle cache
//
//  Arguments:  [hRpc] - RPC handle
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C" 
HRESULT FlushSCMBindings(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR* pszMachineName,
    error_status_t* prpcstat)
{
    HRESULT hr;
    BOOL bAdmin;
    ORSTATUS status;

    // Parameter validation
    if (!pszMachineName || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateTokenForRPCClient(hRpc, FALSE, &pToken, NULL);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;
    
    SCMVDATEHEAP();

    hr = gpRemoteMachineList->FlushSpecificBindings(pszMachineName);

    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireServer
//
//  Synopsis:   Marks the specified server as being no longer eligible for 
//              component activations of any type.   Currently only used
//              to support COM+'s process recycling feature.
//
//  Arguments:  [hRpc] - RPC handle
//              [pguidProcessIdentifier] - guid which identifies the server
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C" 
HRESULT RetireServer(
    handle_t hRpc,
    PHPROCESS phProcess,
    GUID* pguidProcessIdentifier,
    error_status_t* prpcstat)
{
    // Parameter validation
    if (!pguidProcessIdentifier || !prpcstat)
    	return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    CProcess* pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    // Get token for the caller
    CToken* pToken;
    ORSTATUS status;
    status = LookupOrCreateTokenForRPCClient(hRpc, FALSE, &pToken, NULL);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;

    // Make sure they're an administrator
    HRESULT hr;
    BOOL bAdmin;
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;

    // Okay, see if we know which process they're talking about
    gpProcessListLock->LockShared();
    
    hr = E_INVALIDARG;  // review for better code when we don't find the process

    CBListIterator all_procs(gpProcessList);  
    CProcess* pprocess;
    while (pprocess = (CProcess*)all_procs.Next())
    {
        if (*pprocess->GetGuidProcessIdentifier() == *pguidProcessIdentifier)
        {
            // Found it.   Mark it as retired
            pprocess->Retire();
            hr = S_OK;
            break;
        }
    }
    
    gpProcessListLock->UnlockShared();

    return hr;
}


CWIPTable gWIPTbl;  // global instance of the class
CWIPTable * gpWIPTbl = &gWIPTbl;

//+-------------------------------------------------------------------------
//
//  Function:   CopyDualStringArray
//
//  Synopsis:   makes a copy of the given string array
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CopyDualStringArray(DUALSTRINGARRAY *psa, DUALSTRINGARRAY **ppsaNew)
{
    ULONG ulSize = sizeof(DUALSTRINGARRAY) + (psa->wNumEntries * sizeof(WCHAR));

    *ppsaNew = (DUALSTRINGARRAY *) PrivMemAlloc(ulSize);

    if (*ppsaNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*ppsaNew, psa, ulSize);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::AddEntry, public
//
//  Synopsis:   Adds a WIPEntry to the table.
//
//  Arguments:  [hWnd] - window handle
//              [pStd] - standard marshaled interface STDOBJREF
//              [pOxidInfo] - info needed to resolve the OXID
//              [pdwCookie] - cookie to return (to be placed on the window)
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CWIPTable::AddEntry(
    DWORD_PTR  hWnd, 
    STDOBJREF *pStd, 
    OXID_INFO *pOxidInfo,
    ULONG sessId,
    void * creator,
    DWORD_PTR *pdwCookie
    )
{
    // make a copy of the string array in the OxidInfo since MIDL will
    // delete it on the way back out of the call.

    DUALSTRINGARRAY *psaNew;
    HRESULT hr;

    if (m_fCsInitialized == FALSE)
    {
    	ASSERT(FALSE);
    	return E_OUTOFMEMORY;
    }
    
    psaNew = (DUALSTRINGARRAY *) PrivMemAlloc(sizeof(DUALSTRINGARRAY) + (pOxidInfo->psa->wNumEntries * sizeof(WCHAR)));

    if (psaNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(psaNew, pOxidInfo->psa, sizeof(DUALSTRINGARRAY) + (pOxidInfo->psa->wNumEntries * sizeof(WCHAR)));

    CLock2 lck(s_mxs);

    // find a free slot in the table
    DWORD_PTR dwpIndex = s_iNextFree;

    if (dwpIndex == (DWORD_PTR)-1)
    {
        // grow the table
        dwpIndex = Grow();
    }

    if (dwpIndex != (DWORD_PTR)-1)
    {
        // get the pointer to the entry,
        WIPEntry *pEntry = s_pTbl + dwpIndex;

        // update the next free index.
        s_iNextFree = pEntry->hWnd;

        // copy in the data
        memcpy(&pEntry->std, pStd, sizeof(STDOBJREF));
        memcpy(&pEntry->oxidInfo, pOxidInfo, sizeof(OXID_INFO));

        pEntry->oxidInfo.psa = psaNew;
        pEntry->hWnd         = hWnd;
        pEntry->dwFlags      = WIPF_OCCUPIED;
        pEntry->sessId       = sessId;
        pEntry->creator      = creator;

        // set the cookie to return
        *pdwCookie = dwpIndex+5000;

        // return success
        hr = S_OK;
    }
    else
    {
        // free the allocated string array
        PrivMemFree(psaNew);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::GetEntry, public
//
//  Synopsis:   Retrieves and optionally delets a WIPEntry from the table.
//
//  Arguments:  [hWnd] - window handle
//              [dwCookie] - cookie from the window
//              [pStd] - place to return STDOBJREF data
//              [pOxidInfo] - place to return info needed to resolve the OXID
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CWIPTable::GetEntry(
    DWORD_PTR  hWnd, 
    DWORD_PTR  dwCookie, 
    BOOL       fRevoke,
    ULONG 	sessId,
    void*	caller,
    STDOBJREF *pStd,
    OXID_INFO *pOxidInfo)
{
    HRESULT hr = E_INVALIDARG;

    // validate the cookie
    DWORD_PTR dwpIndex = dwCookie - 5000;
    if (dwpIndex >= s_cEntries)
    {
        return hr;
    }

    if (m_fCsInitialized == FALSE)
    {
        ASSERT(FALSE);
    	return E_OUTOFMEMORY;
    }
    
    CLock2 lck(s_mxs);

    // get the pointer to the entry,
    WIPEntry *pEntry = s_pTbl + dwpIndex;

    // make sure the entry is occupied
    if (pEntry->dwFlags & WIPF_OCCUPIED)
    {
        if (sessId != pEntry->sessId)       // trying to access the droptarget of a different session???
            return E_ACCESSDENIED;
        if (fRevoke && (caller != pEntry->creator))    // trying to delete someone else's droptarget??
            return E_ACCESSDENIED;
        if (hWnd != pEntry->hWnd)           // additional verification.. authorized clients should know what the hwnd is.
            return E_ACCESSDENIED;

        DUALSTRINGARRAY *psaNew;
        psaNew = (DUALSTRINGARRAY *) PrivMemAlloc(sizeof(DUALSTRINGARRAY) + (pEntry->oxidInfo.psa->wNumEntries * sizeof(WCHAR)));

        if (psaNew == NULL)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(psaNew, pEntry->oxidInfo.psa, sizeof(DUALSTRINGARRAY) + (pEntry->oxidInfo.psa->wNumEntries * sizeof(WCHAR)));

        // copy out the data to return
        memcpy(pStd, &pEntry->std, sizeof(STDOBJREF));
        memcpy(pOxidInfo, &pEntry->oxidInfo, sizeof(OXID_INFO));
        pOxidInfo->psa = psaNew;

        if (fRevoke)
        {
            // free the entry by updating the flags and the next free index
            PrivMemFree(pEntry->oxidInfo.psa);

            pEntry->dwFlags = WIPF_VACANT;
            pEntry->hWnd    = s_iNextFree;
            pEntry->sessId  = 0;
            pEntry->creator = NULL;
            s_iNextFree     = dwpIndex;
        }

        // return success
        hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::Grow, private
//
//  Synopsis:   grows the WIPTable size.
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
DWORD_PTR CWIPTable::Grow()
{
    // compute the size and allocate a new table
    DWORD_PTR dwSize = (s_cEntries + WIPTBL_GROW_SIZE) * sizeof(WIPEntry);
    WIPEntry *pNewTbl = (WIPEntry *) PrivMemAlloc((size_t)dwSize);

    if (pNewTbl != NULL)
    {
        // copy the old table in
        memcpy(pNewTbl, s_pTbl, (size_t)(s_cEntries * sizeof(WIPEntry)));

        // free the old table
        if (s_pTbl)
        {
            PrivMemFree(s_pTbl);
        }

        // replace the old table ptr
        s_pTbl = pNewTbl;

        // update the free list and mark the new entries as vacant
        s_iNextFree = s_cEntries;

        WIPEntry *pNext = s_pTbl + s_cEntries;

        for (ULONG i=0; i< WIPTBL_GROW_SIZE; i++)
        {
            pNext->hWnd    = ++s_cEntries;
            pNext->dwFlags = WIPF_VACANT;
            pNext->sessId  = 0;
            pNext->creator = NULL;
            pNext++;
        }

        (pNext-1)->hWnd = (DWORD_PTR)-1;   // last entry has END_OF_LIST marker
    }

    return s_iNextFree;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::RunDown, public
//
//  Synopsis:   Deletes all WIPEntry from the table that were created by creator.
//
//  Arguments:  [creator] - this is the CProcess object of the process being rundown
//
//  History:    27-Mar-02 Hanyr	Created
//
//--------------------------------------------------------------------------
void CWIPTable::RunDown(
	void* creator)
{
    if (m_fCsInitialized == FALSE)
    {
        ASSERT(FALSE);
    	return;
    }
    
    CLock2 lck(s_mxs);

    // get the pointer to the entry,
    WIPEntry *pEntry = s_pTbl;

    for (ULONG i=0; i< s_cEntries; i++)
    {
        if ((pEntry->dwFlags == WIPF_OCCUPIED) && (pEntry->creator == creator))		// a match
        {
            PrivMemFree(pEntry->oxidInfo.psa);
            pEntry->dwFlags = WIPF_VACANT;
            pEntry->hWnd    = s_iNextFree;
            pEntry->sessId = 0;
            pEntry->creator = NULL;
            s_iNextFree     = i;
        }
        pEntry++;
    }
}

void DragDropRunDown(void *creator)
{
    gpWIPTbl->RunDown(creator);
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterWindowPropInterface
//
//  Synopsis:   Associate a window property with a (standard) marshaled
//              interface.
//
//  Arguments:  [hRpc] - RPC handle
//              [hWnd] - window handle
//              [pStd] - standard marshaled interface STDOBJREF
//              [pOxidInfo] - info needed to resolve the OXID
//              [pdwCookie] - cookie to return (to be placed on the window)
//              [prpcstat] - communication status
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT RegisterWindowPropInterface(
    handle_t       hRpc,
    PHPROCESS      phProcess,
    DWORD_PTR      hWnd,
    STDOBJREF      *pStd,
    OXID_INFO      *pOxidInfo,
    DWORD_PTR      *pdwCookie,
    error_status_t *prpcstat)
{
    // Parameter validation
    if (!pStd || !pOxidInfo || !pOxidInfo->psa || !pdwCookie || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    CProcess *pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    ULONG sessId = pProcess->GetToken()->GetSessionId();

    CairoleDebugOut((DEB_SCM,
        "_IN RegisterWindowPropInterface hWnd:%x pStd:%x pOxidInfo:%x\n",
         hWnd, pStd, pOxidInfo));

    VDATEHEAP();

    HRESULT hr = gpWIPTbl->AddEntry(hWnd, pStd, pOxidInfo, sessId, pProcess, pdwCookie);
    if (SUCCEEDED(hr))
        pProcess->IncDropTargets();

    CairoleDebugOut((DEB_SCM, "_OUT RegisterWindowPropInterface dwCookie:%x\n",
                    *pdwCookie));
    VDATEHEAP();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetWindowPropInterface
//
//  Synopsis:   Get the marshaled interface associated with a window property.
//
//  Arguments:  [hRpc] - RPC handle
//              [hWnd] - window handle
//              [dwCookie] - cookie from the window
//              [fRevoke] - whether to revoke entry or not
//              [pStd] - standard marshaled interface STDOBJREF to return
//              [pOxidInfo] - info needed to resolve the OXID
//              [prpcstat] - communication status
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT GetWindowPropInterface(
    handle_t       hRpc,
    PHPROCESS      phProcess,    
    DWORD_PTR      hWnd,
    DWORD_PTR      dwCookie,
    BOOL           fRevoke,
    STDOBJREF      *pStd,
    OXID_INFO      *pOxidInfo,
    error_status_t *prpcstat)
{
    // Parameter validation
    if (!pStd || !pOxidInfo || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;

    CProcess *pProcess = CheckLocalSecurity(hRpc, phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;        

    ULONG sessId = pProcess->GetToken()->GetSessionId();
    
    CairoleDebugOut((DEB_SCM,
        "_IN GetWindowPropInterface hWnd:%x dwCookie:%x fRevoke:%x\n",
             hWnd, dwCookie, fRevoke));

    VDATEHEAP();

    HRESULT hr = gpWIPTbl->GetEntry(hWnd, dwCookie, fRevoke, sessId, pProcess, pStd, pOxidInfo);
    if (fRevoke && SUCCEEDED(hr))
        pProcess->DecDropTargets();
    
    CairoleDebugOut((DEB_SCM,
        "_OUT GetWindowPropInterface pStd:%x pOxidInfo:%x\n", pStd, pOxidInfo));
    VDATEHEAP();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\rpcalloc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rpcalloc.cxx
//
//  Contents:   functions for RPC memory allocation
//
//  Functions:  MIDL_user_allocate
//              MIDL_user_free
//
//  History:    24-Apr-93 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocate memory for RPC
//
//  Arguments:  [cNeeded] - bytes needed
//
//  Returns:    Pointer to block allocated
//
//  History:    24-Apr-93 Ricksa    Created
//              17-Feb-94 AlexT     Use PrivMemAlloc
//
//--------------------------------------------------------------------------

extern "C" void * __RPC_API MIDL_user_allocate(size_t cb)
{
    return(PrivMemAlloc8(cb));
}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Free memory allocated by call above
//
//  Arguments:  [pv] - memory block to free
//
//  History:    24-Apr-93 Ricksa    Created
//              17-Feb-94 AlexT     Use PrivMemFree
//
//--------------------------------------------------------------------------

extern "C" void __RPC_API MIDL_user_free(void *pv)
{
    PrivMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\scmrot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scmrot.hxx
//
//  Contents:   Implementation of classes for the ROT in the SCM
//
//  Functions:  RoundTo8 - round size to 8 byte boundary
//              CalcIfdSize - calculate size needed for marhaled interface
//              SizeMnkEqBufForRotEntry - calculate size for moniker eq buffer
//              AllocateAndCopy - create copy of a marshaled interface
//              GetEntryFromScmReg - convert SCMREGKEY to ROT entry ptr
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

#define DEB_ROT_ADDREMOVE  DEB_USER3

//+-------------------------------------------------------------------------
//
//  Function:   RoundTo8
//
//  Synopsis:   Round size to next 8 byte boundary
//
//  Arguments:  [sizeToRound] - Size to round
//
//  Returns:    Input rounded to the next 8 byte boundary
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
inline size_t RoundTo8(size_t sizeToRound)
{
    return (sizeToRound + 7) & ~7;
}

//+-------------------------------------------------------------------------
//
//  Function:   CalcIfdSize
//
//  Synopsis:   Calculate size required by a marshaled interface
//
//  Arguments:  [pifd] - interface whose size to calculate
//
//  Returns:    size required for interface
//
//  Algorithm:  Get size from the interface and round to next 8 bytes so
//              data packed following this buffer will be nicely aligned.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
size_t CalcIfdSize(InterfaceData *pifd)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CalcIfdSize ( %p )\n", NULL,
        pifd));

    size_t sizeRet = RoundTo8(IFD_SIZE(pifd));

    CairoleDebugOut((DEB_ROT, "%p OUT CalcIfdSize ( %lx )\n", NULL,
        sizeRet));

    return sizeRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   SizeMnkEqBufForRotEntry
//
//  Synopsis:   Calculate 8 byte aligned size for moniker equality buffer
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer
//
//  Returns:    8 byte aligned size of moniker buffer.
//
//  Algorithm:  Calculate size for the moniker equality buffer from input
//              buffer and then round to next 8 byte boundary
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
size_t SizeMnkEqBufForRotEntry(MNKEQBUF *pmnkeqbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN SizeMnkEqBufForRotEntry ( %p )\n", NULL,
        pmnkeqbuf));

    size_t sizeRet = RoundTo8((sizeof(MNKEQBUF) - 1) + pmnkeqbuf->cdwSize);

    CairoleDebugOut((DEB_ROT, "%p OUT SizeMnkEqBufForRotEntry ( %lx )\n", NULL,
        sizeRet));

    return sizeRet;
}



//+-------------------------------------------------------------------------
//
//  Function:   AllocateAndCopy
//
//  Synopsis:   Make a copy of the input marshaled interface
//
//  Arguments:  [pifdIn] - input marshaled interface.
//
//  Returns:    Copy of input marshaled interface.
//
//  Algorithm:  Calculate size required for marshaled interface. Allocate
//              memory for the interface and then copy input interface into
//              the new buffer.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
InterfaceData *AllocateAndCopy(InterfaceData *pifdIn)
{
    CairoleDebugOut((DEB_ROT, "%p _IN AllocateAndCopy ( %p )\n", NULL, pifdIn));

    size_t cbSizeObj = CalcIfdSize(pifdIn);

    InterfaceData *pifd = (InterfaceData *) MIDL_user_allocate(cbSizeObj);

    if (pifd)
    {
        // Copy all the data. Remember that pifdIn was allocated rounded
        // to an 8 byte boundary so we will not run off the end of the
        // memory buffer
        memcpy(pifd, pifdIn, cbSizeObj);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT AllocateAndCopy ( %lx )\n", NULL, pifd));

    return pifd;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRotEntry::CScmRotEntry
//
//  Synopsis:   Create a ROT entry for a registration
//
//  Arguments:  [dwScmRotId] - signiture for item
//              [pmkeqbuf] - moniker equality buffer to use
//              [pfiletime] - file time to use
//              [dwProcessID] - process id to use
//              [pifdObject] - marshaled interface for the object
//              [pifdObjectName] - marshaled moniker for the object
//
//  Algorithm:  Initialize data and calcualte offsets into the object for
//              the variable length data.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotEntry::CScmRotEntry(
    DWORD dwScmRotId,
    DWORD dwHash,
    MNKEQBUF *pmkeqbuf,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName)
        :   _dwSig(SCMROT_SIG),
            _dwScmRotId(dwScmRotId),
            _dwHash(dwHash),
            _dwProcessID(dwProcessID),
            _filetimeLastChange(*pfiletime),
            _pifdObject((InterfaceData *) &_ab[0]),
            _pProcessNext(NULL),
            _cRefs(1)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRotEntry::CScmRotEntry "
        "( %lx , %p , %p , %lx , %p , %p )\n", this, pmkeqbuf, pfiletime,
            dwProcessID, pifdObject, pifdObjectName));

    _pToken = pToken;
    if ( _pToken )
        _pToken->AddRef();

    // Copy data for object to preallocated area
    _pifdObject->ulCntData = pifdObject->ulCntData;
    memcpy(&_pifdObject->abData[0], &pifdObject->abData[0],
        _pifdObject->ulCntData);

    // Calculate the location of the equality buffer in the allocated data
    size_t cbOffsetMnkEqBuf = CalcIfdSize(_pifdObject);
    _pmkeqbufKey = (MNKEQBUF *) &_ab[cbOffsetMnkEqBuf];

    // Copy data for moniker equality buffer into preallocated area
    _pmkeqbufKey->cdwSize = pmkeqbuf->cdwSize;
    memcpy(&_pmkeqbufKey->abEqData[0], &pmkeqbuf->abEqData[0],
        _pmkeqbufKey->cdwSize);

    // Calculate the location of the moniker name buffer
    _pifdObjectName = (InterfaceData *)
        &_ab[cbOffsetMnkEqBuf + SizeMnkEqBufForRotEntry(_pmkeqbufKey)];

    // Copy in the data for the moniker name
    _pifdObjectName->ulCntData = pifdObjectName->ulCntData;
    memcpy(&_pifdObjectName->abData[0], &pifdObjectName->abData[0],
        _pifdObjectName->ulCntData);

    if ( pwszWinstaDesktop )
    {
        _pwszWinstaDesktop = (WCHAR *)
            &_ab[cbOffsetMnkEqBuf + SizeMnkEqBufForRotEntry(_pmkeqbufKey) + CalcIfdSize(_pifdObjectName)];
        lstrcpyW( _pwszWinstaDesktop, pwszWinstaDesktop );
    }
    else
    {
        _pwszWinstaDesktop = NULL;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRotEntry::CScmRotEntry \n",
        this));
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRotEntry::IsEqual
//
//  Synopsis:   Determine if input key is equal to the ROT entry's key
//
//  Arguments:  [pKey] - Key to use for the test
//              [cbKey] - Count of bytes in key
//
//  Returns:    TRUE - input key equals this object's key
//              FALSE - keys are not equal
//
//  Algorithm:  If the two sizes are equal then compare the actual data
//              buffers and return the result of that compare.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CScmRotEntry::IsEqual(LPVOID pKey, UINT cbKey)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRotEntry::IsEqual "
        "( %p , %lx )\n", this, pKey, cbKey));

    BOOL fRet = FALSE;

    if (cbKey == _pmkeqbufKey->cdwSize)
    {
        fRet = memcmp(pKey, &_pmkeqbufKey->abEqData[0], cbKey) == 0;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRotEntry::IsEqual ( %lx )\n",
        this, fRet));

    return fRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::Register
//
//  Synopsis:   Add entry to the ROT
//
//  Arguments:  [pmkeqbuf] - moniker equality buffer to use
//              [pfiletime] - file time to use
//              [dwProcessID] - process id to use
//              [pifdObject] - marshaled interface for the object
//              [pifdObjectName] - marshaled moniker for the object
//
//  Returns:    NOERROR - successfully registered
//              E_OUTOFMEMORY
//
//  Algorithm:  Lock the ROT from all other threads. The create a new
//              entry and determine if there is an eqivalent entry in
//              the ROT. Calculate the hash value and then put the
//              entry into our hash table. Finally, build a registration
//              key to return to the caller.
//
//  History:    20-Jan-95 Ricksa    Created
//              07-Mar-02 JohnDoty  Hang ROT entries off the process.
//
//--------------------------------------------------------------------------
HRESULT CScmRot::Register(
    CProcess *pProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    WCHAR *pwszServerExe,
    SCMREGKEY *psrkRegister)
{
    CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                     "%p _IN CScmRot::Register: Process: %p MNKEQBUF: %p pifdObject: %p pifdObjName: %p\n",
                     this, pProcess, pifdObject, pifdObjectName));


    // Assume that there is a memory problem
    HRESULT hr = E_OUTOFMEMORY;

    CToken * pToken;

    pToken = pProcess->GetToken();

    if ( pwszServerExe )
    {
        HKEY    hKey = NULL;
        LONG    RegStatus;
        WCHAR   wszAppid[40];
        DWORD   Size;

        RegStatus = ERROR_SUCCESS;

        // The pwszServerExe string may contain an AppId string or
        // a module name. If it looks like a GUID string, we can bypass
        // the AppId lookup. Otherwise, we go to the Registry to
        if ( pwszServerExe[0] == L'{' )
        {
            // Use the given string as the AppId

            lstrcpyn(wszAppid, pwszServerExe, sizeof(wszAppid)/sizeof(WCHAR));
        }
        else
        {
            // Try to map the Exe name to an AppId

            HKEY hAppidMachine = NULL;
            DWORD dwDisposition = 0;

            // This may fail during GUI mode setup.
            RegStatus = RegCreateKeyEx(
                                HKEY_CLASSES_ROOT,
                                TEXT("AppID"),
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hAppidMachine,
                                &dwDisposition);
            if ( ERROR_SUCCESS == RegStatus )
            {
                RegStatus = RegOpenKeyEx( hAppidMachine,
                                          pwszServerExe,
                                          NULL,
                                          KEY_READ,
                                          &hKey );
                
                RegCloseKey(hAppidMachine);                
            }

            if ( ERROR_SUCCESS == RegStatus )
            {
                Size = sizeof(wszAppid);
                RegStatus = RegQueryValueEx( hKey,
                                             L"AppId",
                                             NULL,
                                             NULL,
                                             (BYTE *)wszAppid,
                                             &Size );
                RegCloseKey( hKey );
            }

            if ( RegStatus != ERROR_SUCCESS )
                return CO_E_WRONG_SERVER_IDENTITY;
        }

        CAppidData  Appid( wszAppid, pToken );
        BOOL        Access;

        Access = FALSE;

        // Load appid info
        hr = Appid.Load(NULL);
        if ( S_OK == hr )
        {
            // If this is not an activate-as-activator server, then force them to
            // pass CertifyServer.  You can only register in the ROT if you pass
            // CertifyServer.
            if ((Appid.GetRunAsType() != RunAsLaunchingUser) || 
                (Appid.GetProcessType() == ProcessTypeService))
            {
                Access = Appid.CertifyServer( pProcess );
            }
        }

        if ( ! Access )
            return CO_E_WRONG_SERVER_IDENTITY;

        //
        // NULL these to indicate that any client can connect to this
        // registration.
        //
        pwszWinstaDesktop = NULL;
        pToken = NULL;
    }

    // Lock to add to the table...
    CPortableLock lck(_mxs);

    // Bump the id
    _dwIdCntr++;

    DWORD dwHash = ScmRotHash(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize, 0);

    // Build a record to put into the table
    size_t cbExtra = (pwszWinstaDesktop ? (lstrlenW(pwszWinstaDesktop) + 1) : 0) * sizeof(WCHAR);
    cbExtra += CalcIfdSize(pifdObject);
    cbExtra += SizeMnkEqBufForRotEntry(pmnkeqbuf);
    cbExtra += CalcIfdSize(pifdObjectName);
        
    CScmRotEntry *psreNew = new(cbExtra) CScmRotEntry(_dwIdCntr, 
                                                      dwHash, 
                                                      pmnkeqbuf, 
                                                      pfiletime, 
                                                      dwProcessID,
                                                      pToken,
                                                      pwszWinstaDesktop, 
                                                      pifdObject, 
                                                      pifdObjectName);
    if (psreNew != NULL)
    {
        CScmRotEntry *psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );
        
        // Put record into the hash table
        _sht.SetAt(dwHash, psreNew);

        // Update the hint table
        _rht.SetIndicator(dwHash);

        // Build return value
        psreNew->SetScmRegKey(psrkRegister);

        // Link to process.  The process link owns another reference on the object.
        gpServerLock->LockExclusive();

        psreNew->SetProcessNext((CScmRotEntry *)pProcess->GetFirstROTEntry());
        pProcess->SetFirstROTEntry(psreNew);
        psreNew->AddRef();

        gpServerLock->UnlockExclusive();

        // Map return result based on prior existence of the object.
        hr = (psreRunning == NULL)
              ? NOERROR : MK_S_MONIKERALREADYREGISTERED;
    }


    CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                     "%p OUT CScmRot::Register: hr: 0x%08x, psrkReg: [ 0x%I64x, %08x, %08x ]\n", 
                     this, 
                     hr, 
                     (SUCCEEDED(hr)) ? psrkRegister->dwEntryLoc : 0,
                     (SUCCEEDED(hr)) ? psrkRegister->dwHash     : 0,
                     (SUCCEEDED(hr)) ? psrkRegister->dwScmId    : 0));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CScmRot::GetEntryFromScmReg
//
//  Synopsis:   Convert SCMREGKEY into a pointer to a ROT entry if possible.
//              MUST BE CALLED WITH CScmRot::_mxs HELD!
//
//  Arguments:  [psrk] - Pointer to a SCMREGKEY
//
//  Returns:    NULL - psrk not valid
//              ROT entry for the given input key
//
//  Algorithm:  Take the pointer portion of the key, along with the hash
//              portion of the key, and search for that entry in _sht.
//
//  History:    20-Jan-95 Ricksa    Created
//              05-Mar-02 JohnDoty  Modified to use _sht in validation.
//
//--------------------------------------------------------------------------
CScmRotEntry *CScmRot::GetEntryFromScmReg(SCMREGKEY *psrk)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetEntryFromScmReg ( %p )\n",
                     this, psrk));

    CScmRotEntry *psreRet = NULL;

    CScmRotEntry *psre = (CScmRotEntry *) _sht.Lookup(psrk->dwHash, (CScmRotEntry*)psrk->dwEntryLoc);
    if (psre != NULL)
    {
        if (psre->IsValid(psrk->dwScmId))
        {
            psreRet = psre;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetEntryFromScmReg ( %p )\n",
                     this, psreRet));

    return psreRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::Revoke
//
//  Synopsis:   Remove entry from the ROT
//
//  Arguments:  [psrkRegister] - registration to revoke
//              [fServer] - whether this is the object server
//              [ppifdObject] - output marshaled interface (optional)
//              [ppifdName] - output marshaled moniker (optional)
//
//  Returns:    NOERROR - successfully removed.
//              E_INVALIDARG
//
//  Algorithm:  Convert SCMREGKEY to anentry in the ROT. Remove the
//              entry from the hash table. If this is the object server
//              for the entry, then return the marshaled interfaces
//              so the object server can release them.
//
//  History:    20-Jan-95 Ricksa    Created
//              07-Mar-02 JohnDoty  Validate most revokes against the process
//
//--------------------------------------------------------------------------
HRESULT CScmRot::Revoke(
    CProcess *pProcess,
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject,
    InterfaceData **ppifdName)
{
    CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                     "%p _IN CScmRot::Revoke: Process: %p psrkRegister: [ 0x%I64x, %08x, %08x ]\n",
                     this, pProcess, 
                     psrkRegister->dwEntryLoc, 
                     psrkRegister->dwHash, 
                     psrkRegister->dwScmId));

    HRESULT hr = E_INVALIDARG;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);
    
    // Verify registration key
    CScmRotEntry *psreToRemove = GetEntryFromScmReg(psrkRegister);

    if (psreToRemove != NULL)
    {
        BOOL fValid;
        if (pProcess != NULL)
        {
            // Make sure that this entry belongs to the specified process.  
            // If it does not, then ignore the revoke request.
            fValid = FALSE;
            if (pProcess->GetFirstROTEntry() != NULL)
            {
                ASSERT( !gpServerLock->HeldExclusive() );
                gpServerLock->LockExclusive();
                
                CScmRotEntry *pChase = NULL;
                CScmRotEntry *pEntry = (CScmRotEntry *)pProcess->GetFirstROTEntry();
                while (pEntry)
                {
                    if (pEntry == psreToRemove)
                    {
                        CScmRotEntry *pNext = psreToRemove->GetProcessNext();
                            
                        // Great!  This is valid-- remove it from the list.
                        fValid = TRUE;

                        CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                                         "%p ___ CScmRot::Revoke: Remove from process: Chase %p Next %p\n",
                                         this, pChase, pNext));
                        if (pChase != NULL)
                            pChase->SetProcessNext(pNext);
                        else
                            pProcess->SetFirstROTEntry(pNext);

                        // Remove the reference that the list took on us.
                        psreToRemove->Release();
                        break;
                    }

                    pChase = pEntry;
                    pEntry = pEntry->GetProcessNext();
                }

                gpServerLock->UnlockExclusive();
            }
        }
        else
        {
            // No process specified, just do the revoke.
            fValid = TRUE;
        }
        
        if (fValid)
        {
            // Get the hash value
            DWORD dwHash = psrkRegister->dwHash;

            // Remove object from the list
            _sht.RemoveEntry(dwHash, psreToRemove);
            
            // Is this a server doing a revoke?
            if (ppifdObject && ppifdName)
            {
                // Error handling here - suppose these allocations fail, what
                // can we do? The bottom line is nothing. This will cause a
                // memory leak in the server because they can't release the
                // marshaled data. However, this is assumed to be a rare
                // occurance and will really only cause the moniker to live
                // longer than it ought to which should not be too serious.
                *ppifdObject = AllocateAndCopy(psreToRemove->GetObject());
                *ppifdName = AllocateAndCopy(psreToRemove->GetMoniker());
            }
                            
            // Release the table reference on the entry.  
            // (A reference may still exist in the CProcess list, if we're racing
            // a revoke with a rundown.  This should never really happen, because 
            // we should not be running the process down since it's being used as 
            // a context handle in the IrotRevoke RPC, but still... better safe
            // than busy writing QFE fixes.)
            psreToRemove->Release();

            // See if bucket is empty
            if (_sht.IsBucketEmpty(dwHash))
            {
                // Update the hint table.
                _rht.ClearIndicator(dwHash);
            }

            hr = S_OK;
        }
        else
        {
            CairoleDebugOut((DEB_ERROR, "%p ERR CScmRot::Revoke: Attempt to revoke invalid entry 0x%p\n",
                             this, psreToRemove));
        }
    }

    CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                     "%p OUT CScmRot::Revoke: ( %lx ) [ %p, %p ] \n", 
                     this, hr,
                     (ppifdObject != NULL) ? *ppifdObject : NULL,
                     (ppifdName != NULL) ? *ppifdName : NULL));
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::IsRunning
//
//  Synopsis:   Determine if there is a registered entry for an item
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer to search for
//
//  Returns:    NOERROR - moniker is registered as running
//              S_FALSE - moniker is not running.
//
//  Algorithm:  Get the entry for the moniker equality buffer if there is
//              one. If there is one, then return NOERROR otherwise return
//              S_FALSE.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::IsRunning(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::IsRunning "
        "( %p )\n", this, pmnkeqbuf));

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    CScmRotEntry *psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );

    HRESULT hr = (psreRunning != NULL) ? S_OK : S_FALSE;

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::IsRunning "
        " ( %lx ) \n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::GetObject
//
//  Synopsis:   Get running object for input
//
//  Arguments:  [dwProcessID] - process id of object (optional)
//              [pmnkeqbuf] - moniker equality buffer
//              [psrkRegister] - output registration id.
//              [ppifdObject] - marshaled interface for registration
//
//  Returns:    NOERROR - got object
//              MK_E_UNAVAILABLE - registration could not be found
//
//  Algorithm:  If not process ID is input, then search for the first
//              matching entry that we can find. Otherwise, search the
//              hash for the entry with both the same key and the same
//              process id.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::GetObject(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    DWORD dwProcessID,
    MNKEQBUF *pmnkeqbuf,
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::GetObject "
        "( %lx , %p , %p , %p )\n", this, dwProcessID, pmnkeqbuf, psrkRegister,
            ppifdObject));

    HRESULT hr = MK_E_UNAVAILABLE;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    CScmRotEntry *psreRunning;

    if (dwProcessID == 0)
    {
        psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );
    }
    else
    {
        // Special search based on process ID - get the head of the list
        // for the bucket
        psreRunning = (CScmRotEntry *) _sht.GetBucketList(
            ScmRotHash(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize, 0));

        // Search list for a matching entry
        while (psreRunning != NULL)
        {
            if ((psreRunning->GetProcessID() == dwProcessID)
                && psreRunning->IsEqual(&pmnkeqbuf->abEqData[0],
                    pmnkeqbuf->cdwSize))
            {
                // We found a match so we are done.
                break;
            }

            // Try the next item in the bucket.
            psreRunning = (CScmRotEntry *) psreRunning->GetNext();
        }
    }
    
    if (psreRunning != NULL)
    {
        hr = E_OUTOFMEMORY;

        *ppifdObject = AllocateAndCopy(psreRunning->GetObject());

        if (*ppifdObject != NULL)
        {
            hr = NOERROR;
        }

        // Build return registration key
        psreRunning->SetScmRegKey(psrkRegister);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::GetObject "
        " ( %lx ) [ %p ] \n", this, hr, *ppifdObject));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::NoteChangeTime
//
//  Synopsis:   Set the time of last change for a ROT entry
//
//  Arguments:  [psrkRegister] - ID of entry to change
//              [pfiletime] - new time for the entry.
//
//  Returns:    NOERROR - time set
//              E_INVALIDARG - ROT entry could not be found
//
//  Algorithm:  Convert SCMREGKEY into a pointer to a ROT entry and then
//              update the time of that entry.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::NoteChangeTime(
    SCMREGKEY *psrkRegister,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::NoteChangeTime "
        "( %p , %p )\n", this, psrkRegister, pfiletime));

    HRESULT hr = E_INVALIDARG;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    CScmRotEntry *psre = GetEntryFromScmReg(psrkRegister);

    if (psre != NULL)
    {
        psre->SetTime(pfiletime);
        hr = S_OK;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::NoteChangeTime "
        " ( %lx ) \n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::GetTimeOfLastChange
//
//  Synopsis:   Get time of last change for a moniker in the ROT
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer
//              [pfiletime] - Where to put the time
//
//  Returns:    NOERROR - got the time
//              MK_E_UNAVAILABLE - couldn't find an entry/
//
//  Algorithm:  Search the hash for an entry with the same moniker. If
//              found, then copy out the time.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::GetTimeOfLastChange(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::GetTimeOfLastChange "
        "( %p , %p )\n", this, pmnkeqbuf, pfiletime));

    HRESULT hr = MK_E_UNAVAILABLE;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    CScmRotEntry *psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );

    if (psreRunning != NULL)
    {
        psreRunning->GetTime(pfiletime);
        hr = S_OK;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::GetTimeOfLastChange "
        " ( %lx ) \n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::EnumRunning
//
//  Synopsis:   Get a list of all the monikers that are currently running
//
//  Arguments:  [ppMkIFList] - Where to put list of monikers running
//
//  Returns:    NOERROR - got list
//              E_OUTOFMEMORY - couldn't allocate space for the list
//
//  Algorithm:  Loop through the ROT copying out the marshaled moniker buffers
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::EnumRunning(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    MkInterfaceList **ppMkIFList)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::EnumRunning "
        "( %p )\n", this, ppMkIFList));

    HRESULT hr = E_OUTOFMEMORY;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    *ppMkIFList = NULL;

    MkInterfaceList *pMkIFList = NULL;

    // This is the upper limit on how much space we'll need.
    DWORD dwSize = sizeof(MkInterfaceList) +
                   (_sht.GetCount() - 1) * sizeof(InterfaceData *);

    // Allocate buffer
    pMkIFList = (MkInterfaceList *) MIDL_user_allocate(dwSize);

    // We use this to keep track fof the number of monikers we are returning
    DWORD dwOffset = 0;

    if (pMkIFList != NULL)
    {
        // Iterate list getting the pointers
        CScmHashIter shi(&_sht);
        CScmRotEntry *psre;

        while ((psre = (CScmRotEntry *) shi.GetNext()) != NULL)
        {
            InterfaceData *pifdForOutput;

            if ( psre->WinstaDesktop() &&
                 (lstrcmpW( pwszWinstaDesktop, psre->WinstaDesktop() ) != 0) )
                continue;

            if ( S_OK != pToken->MatchToken2(psre->Token(), FALSE) )
                continue;

            if ( gbSAFERROTChecksEnabled )
            {
                HRESULT hr = pToken->CompareSaferLevels(psre->Token());
                // S_FALSE: pToken is of lesser authorization, i.e., this
                //          is untrusted code calling into trusted code.
                if (hr == S_FALSE)
                {
                    //DbgPrint("RPCSS: SCMROT: SAFER level did not match.\n");
                    continue;
                }
            }

            pifdForOutput = AllocateAndCopy(psre->GetMoniker());

            if (pifdForOutput == NULL)
            {
                goto Exit;
            }

            // Put copy in the array
            pMkIFList->apIFDList[dwOffset] = pifdForOutput;

            // We bump the count because it makes clean up easier
            dwOffset++;
        }

        // Teller caller and cleanup that everything went ok.
        hr = S_OK;

        // Set the output buffer to the buffer we have allocated.
        *ppMkIFList = pMkIFList;

        // Set the size of the object to return
        pMkIFList->dwSize = dwOffset;
    }

Exit:

    if (FAILED(hr))
    {
        // We failed so clean up
        if (pMkIFList != NULL)
        {
            // Clean up the moniker interfaces that were allocated
            for (DWORD i = 0; i < dwOffset; i++)
            {
                MIDL_user_free(pMkIFList->apIFDList[i]);
            }

            // Clean up the table structure itself
            MIDL_user_free(pMkIFList);
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::EnumRunning "
        " ( %lx ) [ %p ]\n", this, hr, *ppMkIFList));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::GetRotEntry
//
//  Synopsis:   Search ROT for entry that matches the equality buffer input.
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer to search for.
//
//  Returns:    NULL - no entry could be found
//              Pointer to ROT entry with matching key
//
//  Algorithm:  Calculate the hash value for the input buffer. The search
//              the hash table for the matching value.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotEntry *CScmRot::GetRotEntry(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::GetRotEntry "
        "( %p )\n", this, pmnkeqbuf));

    DWORD           dwHash;
    CScmRotEntry *  psre;

    dwHash = ScmRotHash(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize, 0);
    psre = (CScmRotEntry *) _sht.GetBucketList( dwHash );

    for ( ; psre != NULL; psre = (CScmRotEntry *) psre->GetNext() )
    {
        if ( psre->IsEqual(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize) )
        {
            //
            // Note that this routine is actually called during a Register
            // to see if there is a duplicate moniker and also during a
            // client Lookup.  This makes things a little complicated.
            //
            // The winsta\desktop param can only be null in two instances.
            // + While doing a Register from a service or RunAs server.  The
            //   pToken will also be null.
            // + While doing a ROT lookup during a secure remote activation.
            //   The pToken will be non-null.  We only check that the SIDs
            //   match in this case.
            //
            // During an usecure activation the pToken will be NULL.  The
            // winsta/desktop will actually be "" in this case (see
            // Activation) to allow us to distinguish just this case.
            //
            // The ROT entry's winsta\desktop can be null if a service or RunAs
            // server registered a globally available object.
            //

            // Existing registration is globally available.
            if ( ! psre->WinstaDesktop() )
                break;

            //
            // NULL token and winsta/desktop means a server is doing a register
            // for a globally available object, return the match.
            // NULL token but non-null ("") winsta/desktop is a lookup from a
            // remote unsecure client, no match.
            //
            if ( ! pToken )
            {
                if ( ! pwszWinstaDesktop )
                    break;
                else
                    continue;
            }

            ASSERT( psre->Token() );

            if ( pwszWinstaDesktop &&
                 (lstrcmpW( pwszWinstaDesktop, psre->WinstaDesktop() ) != 0) )
                continue;

            // Check to make sure the token matches
            if(S_OK != pToken->MatchToken2(psre->Token(), FALSE))
                continue;

            // Check to make sure that the safer token matches
            if ( gbSAFERROTChecksEnabled )
            {
                HRESULT hr = pToken->CompareSaferLevels(psre->Token());
                // S_FALSE: pToken is of lesser authorization, i.e., this
                //          is untrusted code calling into trusted code.
                if (hr == S_FALSE)
                {
                    //DbgPrint("RPCSS: SCMROT: SAFER level did not match.\n");
                    continue;
                }
            }

            break;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::GetRotEntry "
        " ( %p )\n", this, psre));

    return psre;
}



//+-------------------------------------------------------------------------
//
//  Function:   SCMCleanupROTEntries
//
//  Synopsis:   Revoke the ROT entries in the list.
//
//  Arguments:  pvFirstEntry:  First entry in the list.
//
//  History:    07-Mar-2002 JohnDoty Created
//
//--------------------------------------------------------------------------
void SCMCleanupROTEntries(
    void *pvFirstEntry)
{
    CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                     "SCMCleanupROTEntries: First entry @ 0x%p\n", pvFirstEntry));
    CScmRotEntry *pEntry = (CScmRotEntry *)pvFirstEntry;
    
    while (pEntry)
    {
        CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                         "SCMCleanupROTEntries: Removing entry 0x%p...\n", pEntry));
        CScmRotEntry *pEntryNext = pEntry->GetProcessNext();

        // Revoke this entry from the ROT.  Pass in NULL for the 
        // CServerOxid, since these entries are no longer associated
        // with the OXID.
        //
        SCMREGKEY srkReg;
        pEntry->SetScmRegKey(&srkReg);
        gpscmrot->Revoke(NULL, &srkReg, NULL, NULL);

        // Remove the reference this list held on me.
        pEntry->Release();

        pEntry = pEntryNext;
    }

    CairoleDebugOut((DEB_ROT | DEB_ROT_ADDREMOVE, 
                     "SCMCleanupROTEntries: Done\n", pvFirstEntry));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\scmsvc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        scmsvc.cxx
//
// Contents:    Initialization for win32 service controller.
//
// History:     14-Jul-92 CarlH     Created.
//              31-Dec-93 ErikGav   Chicago port
//              25-Aug-99 a-sergiv  Fixed ScmCreatedEvent vulnerability
//
//------------------------------------------------------------------------

#include "act.hxx"
#include <sddl.h>

#ifdef DFSACTIVATION
HANDLE  ghDfs = 0;
#endif

#define SCM_CREATED_EVENT  TEXT("ScmCreatedEvent")

DECLARE_INFOLEVEL(Cairole);

SC_HANDLE   g_hServiceController = 0;
PSID        psidMySid = NULL;
HANDLE      g_hVistaEvent = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   InitializeVistaEventIfNeeded
//
//  Synopsis:   Checks to see if vista (vis. studio analyzer) events are
//    enabled, and if so creates a named event.  Somebody looks at this
//    event I presume, but creating the event is the end of our 
//    responsibility for it.   Once created we keep it around forever.  Also,
//    this is a non-essential operation from our perspective, hence the 
//    void return value.
//
//  Arguments:  None.
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void InitializeVistaEventIfNeeded()
{
    // Create a named event for Vista to toggle event logging
	
    ASSERT(!g_hVistaEvent);

    LONG lResult;
    WCHAR wszValue[128];
    LONG lBufSize = sizeof(wszValue);

    ZeroMemory(wszValue, sizeof(wszValue));

    lResult = RegQueryValue(
                    HKEY_CLASSES_ROOT,
                    L"CLSID\\{6C736DB0-BD94-11D0-8A23-00AA00B58E10}\\EnableEvents",
                    wszValue,
                    &lBufSize);
    if ((lResult != ERROR_SUCCESS) || lstrcmp(wszValue, L"1"))
        return;

    //
    // Create security descriptor that grants the follow privs:
    //
    // EVENT_QUERY_STATE|EVENT_MODIFY_STATE|SYNCHRONIZE|READ_CONTROL
    //
    // to Everyone.  Dang me if this isn't easier than writing code! :)
    //
    const WCHAR wszStringSD[] = 
      SDDL_DACL  L":" L"(" SDDL_ACCESS_ALLOWED L";;0x00120003;;;" SDDL_EVERYONE L")";
    
    //
    // Turn that into a security descriptor.
    //
    PSECURITY_DESCRIPTOR psd;
    BOOL fRet = ConvertStringSecurityDescriptorToSecurityDescriptor(wszStringSD, 
                                                                    SDDL_REVISION,
                                                                    &psd,
                                                                    NULL);
    ASSERT(fRet && "ConvertStringSecurityDescriptorToSecurityDescriptor failed!");
    if (fRet)
    {
        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = psd;

        // The toggle event, which is signaled by LEC and checked by all.

        // The handle never closes during the process
        g_hVistaEvent = CreateEvent(
                                &sa,        /* Security */
                                TRUE,       /* Manual reset */
                                FALSE,      /* InitialState is non-signaled */
                                L"MSFT.VSA.IEC.STATUS.6c736db0" /* Name */
                                );
        // do not care if it succeeded or not
        LocalFree(psd);
    }

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeSCMBeforeListen
//
//  Synopsis:   Initializes OLE side of rpcss.  Put things in here that do
//              not depend on RPC being initialized, etc.
//
//  Arguments:  None.
//
//  Returns:    Status of initialization.    Note that this function is a bit
//    weak on cleanup in the face of errors, but this is okay since if this
//    function fails, RPCSS will not start.     
//
//--------------------------------------------------------------------------
DWORD
InitializeSCMBeforeListen( void )
{
    LONG        Status;
    SCODE       sc;
    RPC_STATUS  rs;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    UpdateState(SERVICE_START_PENDING);

    Status = RtlInitializeCriticalSection(&gTokenCS);
    if (!NT_SUCCESS(Status))
        return Status;

    // Allocate locks
    Status = OR_NOMEM;
    gpClientLock = new CSharedLock(Status);
    if (OR_OK != Status)
        return(Status);

    Status = OR_NOMEM;
    gpServerLock = new CSharedLock(Status);
    if (OR_OK != Status)
        return(Status);

    Status = OR_NOMEM;
    gpIPCheckLock = new CSharedLock(Status);
    if (OR_OK != Status)
        return(Status);

    g_hServiceController = OpenSCManager(NULL, NULL, GENERIC_EXECUTE);
    if (!g_hServiceController)
        return GetLastError();
	
    // Init random number generator
    if (!gRNG.Initialize())
        return (OR_NOMEM);

    //
    // Get my sid
    // This is simplified under the assumption that SCM runs as LocalSystem.
    // We should remove this code when we incorporate OLE service into the
    // Service Control Manager since this becomes duplicated code then.
    //
    Status = RtlAllocateAndInitializeSid (
        &NtAuthority,
        1,
        SECURITY_LOCAL_SYSTEM_RID,
        0, 0, 0, 0, 0, 0, 0,
        &psidMySid
        );
    if (!NT_SUCCESS(Status))
        return Status;

    UpdateState(SERVICE_START_PENDING);

    HRESULT hr = S_OK;

    hr = InitSCMRegistry();
    if (FAILED(hr))
        return ERROR_NOT_ENOUGH_MEMORY;

    //Initialize runas cache
    InitRunAsCache();  // returns void

    gpClassLock = new CSharedLock(Status);
    if (!gpClassLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpProcessLock = new CSharedLock(Status);
    if (!gpProcessLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpProcessListLock = new CSharedLock(Status);
    if (!gpProcessListLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpClassTable = new CServerTable(Status, ENTRY_TYPE_CLASS);
    if (!gpClassTable)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpProcessTable = new CServerTable(Status, ENTRY_TYPE_PROCESS);
    if (!gpProcessTable)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpSurrogateList = new CSurrogateList();
    if (!gpSurrogateList)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpRemoteMachineLock = new CSharedLock(Status);
    if (!gpRemoteMachineLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpRemoteMachineList = new CRemoteMachineList();
    if (!gpRemoteMachineList)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpNamedObjectTable = new CNamedObjectTable(Status);
    if (!gpNamedObjectTable || (Status != OR_OK))
        return ERROR_NOT_ENOUGH_MEMORY;

    UpdateState(SERVICE_START_PENDING);

#ifdef DFSACTIVATION
    DfsOpen( &ghDfs );
#endif

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSCM
//
//  Synopsis:   Initializes OLE side of rpcss.
//
//  Arguments:  None.
//
//  Returns:    ERROR_SUCCESS
//
//              (REVIEW: should we be returning an error whenever any of
//              the stuff in this function fails?)
//
//--------------------------------------------------------------------------
DWORD
InitializeSCM( void )
{
    RPC_STATUS  status;
    HRESULT     hr;

    // start the RPC service
    hr = InitScmRot();
    if (FAILED(hr))
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Note: some of these calls specify a callback function and some
    // don't.  The ones that don't must be able to receive unauthenticated
    // calls (ie, our remoted interfaces).
    //
    
    status = RpcServerRegisterIfEx(ISCM_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          LocalInterfaceOnlySecCallback); // expected to be local only
    ASSERT((status == 0) && "RpcServerRegisterIfEx failed!");

    status = RpcServerRegisterIfEx(ISCMActivator_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          LocalInterfaceOnlySecCallback); // expected to be local only
    ASSERT((status == 0) && "RpcServerRegisterIfEx failed!");

    status = RpcServerRegisterIfEx(IMachineActivatorControl_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          LocalInterfaceOnlySecCallback); // expected to be local only
    ASSERT((status == 0) && "RpcServerRegisterIfEx failed!");

    status = RpcServerRegisterIfEx(_IActivation_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          NULL); // must be able to accept unauthenticated calls
    ASSERT((status == 0) && "RpcServerRegisterIf failed!");

    status = RpcServerRegisterIfEx(_IRemoteSCMActivator_ServerIfHandle, 
                          NULL,
                          NULL,
                          0,
                          RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                          NULL); // must be able to accept unauthenticated calls
    ASSERT((status == 0) && "RpcServerRegisterIf failed!");

    UpdateState(SERVICE_START_PENDING);

    return ERROR_SUCCESS;
}


void
InitializeSCMAfterListen()
{
    //
    // This is for the OLE apps which start during boot.  They must wait for
    // rpcss to start before completing OLE calls that talk to rpcss.
    //
    // Need to do this work to make sure the DACL for the event doesn't have
    // WRITE_DAC and WRITE_OWNER on it.
    //
    // Rights quick reference:
    //   EVENT_QUERY_STATE   0x00000001
    //   EVENT_MODIFY_STATE  0x00000002
    //   READ_CONTROL        0x00020000
    //   WRITE_DAC           0x00040000
    //   WRITE_OWNER         0x00080000
    //   SYNCHRONIZE         0x00100000
    //
    // So:
    //   Everyone gets EVENT_QUERY_STATE  | READ_CONTROL | SYNCHRONIZE
    //   I        gets EVENT_MODIFY_STATE | WRITE_DAC | WRITE_OWNER
    //
    // Here we go... (this works because of C++ auto string concatenation)
    const WCHAR wszStringSD[] = 
      SDDL_DACL  L":" L"(" SDDL_ACCESS_ALLOWED L";;0x00120001;;;" SDDL_EVERYONE L")"
                      L"(" SDDL_ACCESS_ALLOWED L";;0x001C0002;;;" SDDL_PERSONAL_SELF L")" 
      ;
    //
    // Whew.  Make that into a security descriptor.
    //
    PSECURITY_DESCRIPTOR psd;
    BOOL fRet = ConvertStringSecurityDescriptorToSecurityDescriptor(wszStringSD, 
                                                                    SDDL_REVISION,
                                                                    &psd,
                                                                    NULL);
    ASSERT(fRet && "ConvertStringSecurityDescriptorToSecurityDescriptor failed!");
    if (fRet)
    {
        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = psd;

        // We leak this handle on purpose, so that other people can still find it by
        // name.
        HANDLE EventHandle = CreateEventT( &sa, TRUE, FALSE, SCM_CREATED_EVENT );
        if ( !EventHandle && GetLastError() == ERROR_ACCESS_DENIED )
            EventHandle = OpenEvent(EVENT_MODIFY_STATE, FALSE, SCM_CREATED_EVENT);

        if ( EventHandle )
            SetEvent( EventHandle );
        else
            ASSERT(0 && "Unable to get ScmCreatedEvent");

        LocalFree(psd);
    }

    // The vista event was originally being created inline in ServiceMain but
    // there is no point in creating it until we are ready for work.
    InitializeVistaEventIfNeeded();

    // Tell RPC to enable cleanup of idle connections.  This function only needs to be 
    // called one time.
    RPC_STATUS rpcstatus = RpcMgmtEnableIdleCleanup();
    ASSERT(rpcstatus == RPC_S_OK && "unexpected failure from RpcMgmtEnableIdleCleanup");
    // don't fail in free builds, this is an non-essential optimization

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\scmstage.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:       scmstage.cxx
//
//  Contents:   Implements a stateless object that implements ISystemActivator
//
//  Functions:               
//              CScmActivator::GetClassObject
//              CScmActivator::CreateInstance
//              GetComActivatorForStage
//              PerformScmStage
//
//  History:    Vinaykr   3/11/98     Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

// Global (only) instance of the default SCM-level activator
CScmActivator gScmActivator;

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::QueryInterface
//
//  Synopsis:   Dummy method
//
//----------------------------------------------------------------------------
STDMETHODIMP CScmActivator::QueryInterface( REFIID riid, LPVOID* ppv)
{
    ASSERT(0 && "This QI function should never be used");

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::AddRef
//
//  Synopsis:   Dummy method
//
//----------------------------------------------------------------------------
ULONG CScmActivator::AddRef(void)
{
    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::Release
//
//  Synopsis:   Dummy method
//
//----------------------------------------------------------------------------
ULONG CScmActivator::Release(void)
{
    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::GetClassObject
//
//  Synopsis:   Forwards to ActivateFromProperties.
//
//----------------------------------------------------------------------------
STDMETHODIMP CScmActivator::GetClassObject(
    IN  IActivationPropertiesIn   * pActIn,
    OUT IActivationPropertiesOut  ** ppActOut
    )
{
    return ActivateFromProperties(pActIn, ppActOut);
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::CreateInstance
//
//  Synopsis:   Forwards to ActivateFromProperties.
//
//----------------------------------------------------------------------------
STDMETHODIMP CScmActivator::CreateInstance(
    IN  IUnknown                  * pUnk,
    IN  IActivationPropertiesIn   * pActIn,
    OUT IActivationPropertiesOut  ** ppActOut
    )
{
    return ActivateFromProperties(pActIn, ppActOut);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetComActivatorForStage
//
//  Synopsis:   Returns default activator.
//
//----------------------------------------------------------------------------
ISystemActivator *GetComActivatorForStage(ACTIVATION_STAGE stage)
{
    ASSERT(stage == SERVER_MACHINE_STAGE && "Only SCM stage currently supported is SERVER");
    return &gScmActivator;
}


//+---------------------------------------------------------------------------
//
//  Function:   PerformScmStage
//
//  Synopsis:   Marshals and unmarshals activation properties and forwards to
//              ActivateFromPropertiesPreamble.   
//
//  Notes:      Currently this function doesn't look at the ACTIVATION_STAGE 
//              parameter; of course a SCM-level activator must be a 
//              SERVER_MACHINE_STAGE activator, if it's going to run at all.
//
//----------------------------------------------------------------------------
HRESULT PerformScmStage(ACTIVATION_STAGE stage,
                        PACTIVATION_PARAMS pActParams,
                        MInterfacePointer   * pInActProperties,
                        MInterfacePointer  ** ppOutActProperties
)
{
    if (pActParams == NULL || pInActProperties == NULL || ppOutActProperties == NULL)
        return E_INVALIDARG;
    
    if ( (pActParams->ORPCthis->version.MajorVersion != COM_MAJOR_VERSION) ||
         (pActParams->ORPCthis->version.MinorVersion > COM_MINOR_VERSION) )
        RpcRaiseException( RPC_E_VERSION_MISMATCH );

    HRESULT hr;

    ActivationPropertiesIn *pActPropsIn = new ActivationPropertiesIn();

    if (NULL == pActPropsIn)
    {
        return E_OUTOFMEMORY;
    }

    // AWFUL HACK ALERT:  This is too hacky even for the SCM
    ActivationStream ActStream((InterfaceData*)(((BYTE*)pInActProperties)+48));

    IActivationStageInfo *pStage;
    
    //
    // The UnmarshalInterface call will obtain an IComClassInfo for the requested
    // clsid;  this isn't the most obvious place to do it, but there it is....
    //
    // WARNING:  DO NOT REMOVE THIS.  It has a side-effect (gets the IComClassInfo)
    //
    hr = pActPropsIn->UnmarshalInterface(&ActStream, IID_IActivationStageInfo,
                                          (LPVOID*)&pStage);
    if (FAILED(hr))
    {
        pActPropsIn->Release();
        return hr;
    }

    // Set SCM Stage
/*  jjs -- this will get done in ActFromPropsPreamble....no need to do it twice...
    pStage->SetStageAndIndex(SERVER_MACHINE_STAGE, 0);
*/
    pStage->Release();

    // 
    //  Now call ActivateFromPropertiesPreamble....it will do some further processing,
    //    then kick off the activation delegation.    
    // 
    IActivationPropertiesOut *pActPropsOut;
    hr = ActivateFromPropertiesPreamble(pActPropsIn, &pActPropsOut, pActParams);

    //
    //  Do return processing...
    //
    *ppOutActProperties = NULL;

    DWORD relCount;
    if ((hr==S_OK) && (pActPropsOut))
    {
        DWORD destCtx;

        if (pActParams->RemoteActivation)
            destCtx = MSHCTX_DIFFERENTMACHINE;
        else
            destCtx = MSHCTX_LOCAL;

        if (pActParams->pActPropsOut == NULL)
        {
            pActPropsOut->QueryInterface(CLSID_ActivationPropertiesOut,
                                        (void**) &pActParams->pActPropsOut);
        }

        hr = ActPropsMarshalHelper(pActParams->pActPropsOut, IID_IActivationPropertiesOut,
                                   destCtx, MSHLFLAGS_NORMAL, ppOutActProperties);

        relCount = pActPropsOut->Release();
        ASSERT(relCount == 0);
    }

    relCount = pActPropsIn->Release();
    ASSERT(relCount == 0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\security.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       security.cxx
//
//  Contents:
//
//--------------------------------------------------------------------------

#include "act.hxx"

#include <alloca.h>
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>

// the constant generic mapping structure
GENERIC_MAPPING  sGenericMapping = {
        READ_CONTROL,
        READ_CONTROL,
        READ_CONTROL,
        READ_CONTROL};

// Well-known low-privilege service account sids
const SID sidLocalSystem = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
const SID sidLocalService = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SERVICE_RID };
const SID sidNetworkService = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_NETWORK_SERVICE_RID };

//-------------------------------------------------------------------------
//
// CheckForAccess
//
// Checks whether the given token has COM_RIGHTS_EXECUTE access in the
// given security descriptor.
//
//-------------------------------------------------------------------------
BOOL
CheckForAccess(
    IN  CToken *                pToken,
    IN  SECURITY_DESCRIPTOR *   pSD
    )
{
    // if we have an empty SD, deny everyone
    if (!pSD)
        return FALSE;

    //
    // Some history here:  we used to say, if pToken is NULL (implying an
    // unsecure activation), parse the security descriptor to see if 
    // Everyone is granted access, and if so, allow the activation to
    // proceed.   This was a DCOM-specific policy decision.  In .NET Server 
    // we changed instead to mapping an unsecure (unauthenticated) client 
    // to the Anonymous identity.   (Another DCOM-specific policy decision,
    // but it probably makes more sense than the original one).  And so we 
    // no longer parse the security descriptor, instead we just do a 
    // straight-forward access check.
    //
    HANDLE           hToken   = pToken->GetToken();
    BOOL             fAccess  = FALSE;
    BOOL             fSuccess = FALSE;
    DWORD            dwGrantedAccess;
    PRIVILEGE_SET    sPrivilegeSet;
    DWORD            dwSetLen = sizeof( sPrivilegeSet );

    sPrivilegeSet.PrivilegeCount = 1;
    sPrivilegeSet.Control        = 0;

    fSuccess = AccessCheck( (PSECURITY_DESCRIPTOR) pSD,
                            hToken,
                            COM_RIGHTS_EXECUTE,
                            &sGenericMapping,
                            &sPrivilegeSet,
                            &dwSetLen,
                            &dwGrantedAccess,
                            &fAccess );
    if (fSuccess && fAccess)
        return TRUE;

    if (!fSuccess)
    {
        CairoleDebugOut((DEB_ERROR, "Bad Security Descriptor 0x%08x, Access Check returned 0x%x\n", pSD, GetLastError() ));
    }

    return FALSE;
}
            
HRESULT IsLowPrivilegeServiceAccount (LPCWSTR pwszDomain, LPCWSTR pwszName, BOOL* pfSvcAccount)
{
    if (!pwszName || !pfSvcAccount)
    {
        return E_POINTER;
    }

    *pfSvcAccount = FALSE;

    HRESULT hr = S_OK;
    BYTE pbSid [sizeof (sidLocalService)] = {0};
    DWORD cbSid = sizeof (pbSid);

    WCHAR wszDomain [DNLEN + 1] = {0};
    DWORD cchDomain = sizeof (wszDomain) / sizeof (wszDomain[0]);
    SID_NAME_USE eUse;

    LPCWSTR pwszFullName = pwszName;
    LPWSTR pwszCopyFullName = NULL;

    // Build the full domain\account string if necessary
    if (pwszDomain)
    {
        SIZE_T cchFullNameLen = lstrlenW (pwszDomain) + 1 + lstrlenW (pwszName) + 1;

        SafeAllocaAllocate (pwszCopyFullName, cchFullNameLen * sizeof (WCHAR));
        if (!pwszCopyFullName)
        {
            return E_OUTOFMEMORY;
        }

        _snwprintf (pwszCopyFullName, cchFullNameLen, L"%s\\%s", pwszDomain, pwszName);
        pwszCopyFullName [cchFullNameLen - 1] = L'\0';

        pwszFullName = pwszCopyFullName;
    }

    // Lookup the sid for the account
    if (!LookupAccountName(NULL, pwszFullName, pbSid, &cbSid, wszDomain, &cchDomain, &eUse))
    {
        // Either our sid was too small, or a failure occurred.
        // If the former, returning *pfSvcAccount = FALSE is correct
        // If the latter, the subsequent call to LogonUser will catch it
        hr = S_FALSE;
    }
    else
    {
        // Compare to well known service sids
        if (eUse == SidTypeWellKnownGroup &&
            (EqualSid (pbSid, (PSID) &sidLocalService) || EqualSid (pbSid, (PSID) &sidNetworkService)))
        {
            *pfSvcAccount = TRUE;
        }
    }

    SafeAllocaFree (pwszCopyFullName);

    return hr;
}

HRESULT IsLocalSystemAccount(LPCWSTR pwszDomain, LPCWSTR pwszName, BOOL* pfLocalSystemAccount)
{
    if (!pwszName || !pfLocalSystemAccount)
    {
        return E_POINTER;
    }

    *pfLocalSystemAccount = FALSE;

    HRESULT hr = S_OK;
    BYTE pbSid [sizeof (sidLocalSystem)] = {0};
    DWORD cbSid = sizeof (pbSid);

    WCHAR wszDomain [DNLEN + 1] = {0};
    DWORD cchDomain = sizeof (wszDomain) / sizeof (wszDomain[0]);
    SID_NAME_USE eUse;

    LPCWSTR pwszFullName = pwszName;
    LPWSTR pwszCopyFullName = NULL;

    // Build the full domain\account string if necessary
    if (pwszDomain)
    {
        SIZE_T cchFullNameLen = lstrlenW (pwszDomain) + 1 + lstrlenW (pwszName) + 1;

        SafeAllocaAllocate (pwszCopyFullName, cchFullNameLen * sizeof (WCHAR));
        if (!pwszCopyFullName)
        {
            return E_OUTOFMEMORY;
        }

        _snwprintf (pwszCopyFullName, cchFullNameLen, L"%s\\%s", pwszDomain, pwszName);
        pwszCopyFullName [cchFullNameLen - 1] = L'\0';

        pwszFullName = pwszCopyFullName;
    }

    // Lookup the sid for the account
    if (!LookupAccountName(NULL, pwszFullName, pbSid, &cbSid, wszDomain, &cchDomain, &eUse))
    {
        // Either our sid was too small, or a failure occurred.
        // If the former, returning *pfLocalSystemAccount = FALSE is correct
        // If the latter, the subsequent call to LogonUser will catch it
        hr = S_FALSE;
    }
    else
    {
        // Compare to well known service sids
        if (eUse == SidTypeWellKnownGroup &&
            (EqualSid (pbSid, (PSID) &sidLocalSystem)))
        {
            *pfLocalSystemAccount = TRUE;
        }
    }

    SafeAllocaFree (pwszCopyFullName);

    return hr;
		
}

HANDLE
GetRunAsToken(
    DWORD   clsctx,
    WCHAR   *pwszAppID,
    WCHAR   *pwszRunAsDomainName,
    WCHAR   *pwszRunAsUserName,
    BOOL    fForLaunch)
{
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    WCHAR                 wszKey[CLSIDSTR_MAX+5];
    PLSA_UNICODE_STRING   psPassword;
    HANDLE                hToken;
    NTSTATUS Status;
    PKERB_INTERACTIVE_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_INTERACTIVE_LOGON);
    STRING Name;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    PUCHAR Where;
    UNICODE_STRING usRunAsUserName, usRunAsDomainName;
    PTOKEN_GROUPS TokenGroups = NULL;
    HRESULT hr = E_FAIL;
    
    if ( !pwszAppID )
    {
        // if we have a RunAs, we'd better have an appid....
        return 0;
    }
    ASSERT(gLSAHandle);
    ASSERT(gSidService);
    ASSERT(gpwszDefaultDomainName[0]);

    // formulate the access key
    lstrcpyW(wszKey, L"SCM:");
    lstrcatW(wszKey, pwszAppID );

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (USHORT)((lstrlenW(wszKey) + 1) * sizeof(WCHAR));
    sKey.MaximumLength       = (CLSIDSTR_MAX + 5) * sizeof(WCHAR);
    sKey.Buffer              = wszKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return 0;
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return 0;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Possible for LsaRetrievePrivateData to return success but with a NULL
    // psPassword.   If this happens we fail.
    if (!psPassword)
    {
        return 0;
    }

    //
    // Special case of NT AUTHORITY\System - cannot use LsaLogonUser to obtain such a
    // token, so we use our own process token.   Note that we currently only support
    // this on the server registration code-path, and not the server-launch code path.
    //
    if (!fForLaunch)
    {
    	BOOL fLocalSystemAccount = FALSE;
    	hr = IsLocalSystemAccount(pwszRunAsDomainName, pwszRunAsUserName, &fLocalSystemAccount);
    	if (SUCCEEDED(hr)) // keep going here in case of errors, LsaLogonUser will just fail below.
        {
            // If SYSTEM and user has supplied a blank password (for compatibility
            // reasons), use our own token
            if (fLocalSystemAccount && !lstrcmpiW(psPassword->Buffer, L""))
            {
                BOOL fResult = FALSE;
                HANDLE hProcess = NULL;
                HANDLE hProcessToken = NULL;
                hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
                if (hProcess)
                {
                    fResult = OpenProcessToken(hProcess, TOKEN_ALL_ACCESS, &hProcessToken);
                    ASSERT(!fResult || hProcessToken);
                    CloseHandle(hProcess);
                }
                return hProcessToken;
            }
        }
    }
	
    BOOLEAN b = RtlCreateUnicodeString(&usRunAsUserName, pwszRunAsUserName);
    if (FALSE == b) 
    {
       SecureZeroMemory(psPassword->Buffer, psPassword->Length);
       LsaFreeMemory( psPassword );
       return 0;
    }
    if ( (pwszRunAsDomainName[0] == L'.') && (pwszRunAsDomainName[1] == L'\0'))
       b = RtlCreateUnicodeString(&usRunAsDomainName, gpwszDefaultDomainName);
    else
       b = RtlCreateUnicodeString(&usRunAsDomainName, pwszRunAsDomainName);
    if (FALSE == b) 
    {
       RtlFreeUnicodeString(&usRunAsUserName);
       SecureZeroMemory(psPassword->Buffer, psPassword->Length);
       LsaFreeMemory( psPassword );
       return 0;
    }
    LogonInfoSize += usRunAsUserName.MaximumLength + usRunAsDomainName.MaximumLength + psPassword->MaximumLength ;
    LogonInfo = (PKERB_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);
    if (!LogonInfo) 
    {
       RtlFreeUnicodeString(&usRunAsUserName);
       RtlFreeUnicodeString(&usRunAsDomainName);
       SecureZeroMemory(psPassword->Buffer, psPassword->Length);
       LsaFreeMemory( psPassword );
       return NULL;
    }

    LogonInfo->MessageType = KerbInteractiveLogon;

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.MaximumLength = usRunAsUserName.MaximumLength ;
    LogonInfo->UserName.Length = usRunAsUserName.Length ;

    RtlCopyMemory( LogonInfo->UserName.Buffer,
		   usRunAsUserName.Buffer,
		   usRunAsUserName.MaximumLength );

    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where ;
    LogonInfo->LogonDomainName.MaximumLength = usRunAsDomainName.MaximumLength;
    LogonInfo->LogonDomainName.Length = usRunAsDomainName.Length ;

    RtlCopyMemory( LogonInfo->LogonDomainName.Buffer,
		   usRunAsDomainName.Buffer,
		   usRunAsDomainName.MaximumLength );

    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);
    
    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.MaximumLength = psPassword->MaximumLength;
    LogonInfo->Password.Length = psPassword->Length - sizeof(WCHAR); // The LSA API retrives length=maxlength

    RtlCopyMemory( LogonInfo->Password.Buffer,
		   psPassword->Buffer,
		   LogonInfo->Password.MaximumLength );

    // Clear the password
    SecureZeroMemory(psPassword->Buffer, psPassword->Length);
    LsaFreeMemory( psPassword );
    RtlFreeUnicodeString(&usRunAsUserName);
    RtlFreeUnicodeString(&usRunAsDomainName);
    Where += LogonInfo->Password.Length + sizeof(WCHAR);
    strncpy(
        SourceContext.SourceName,
        "DCOMSCM",sizeof(SourceContext.SourceName)
        );

    Status = NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );
    if (!NT_SUCCESS(Status))
    {
        SecureZeroMemory(LogonInfo, LogonInfoSize);
        LocalFree(LogonInfo);
	return NULL ;
    }

    RtlInitString( &Name, NEGOSSP_NAME_A);

    Status = LsaLookupAuthenticationPackage(
                gLSAHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
	SecureZeroMemory(LogonInfo, LogonInfoSize);
        LocalFree(LogonInfo);
	return NULL ;
    }
    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "DCOMSCM"
        );

    BOOL fSvcAccount = FALSE;
    if (FAILED (IsLowPrivilegeServiceAccount (pwszRunAsDomainName, pwszRunAsUserName, &fSvcAccount)))
    {
       SecureZeroMemory(LogonInfo, LogonInfoSize);
       LocalFree(LogonInfo);
       return NULL;
    }

    // Service accounts should have blank passwords
    ASSERT (!fSvcAccount || (psPassword->Buffer && !psPassword->Buffer[0]));

#define TOKEN_GROUP_COUNT   1
   
   // if local/network service, no need to add the serivce SID
   if (!fSvcAccount) 
   {
      TokenGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_ZEROINIT, sizeof(TOKEN_GROUPS) +
                    (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));
      if (TokenGroups == NULL) {
         SecureZeroMemory(LogonInfo, LogonInfoSize);
         LocalFree(LogonInfo);
         return NULL ;
      }
      
      // Add the service SID to the token so the resulting 
      // process can impersonate
      
      TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
      TokenGroups->Groups[0].Sid = gSidService;
      TokenGroups->Groups[0].Attributes =
              SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
              SE_GROUP_ENABLED_BY_DEFAULT;
   }
   Status = LsaLogonUser(
                    gLSAHandle,
                    &Name,
                    fSvcAccount ? Service : Batch,
                    PackageId,
                    LogonInfo,
                    LogonInfoSize,
                    TokenGroups, //NULL for service accounts
                    &SourceContext,
                    (PVOID *) &Profile,
                    &ProfileSize,
                    &LogonId,
                    &hToken,
                    &Quotas,
                    &SubStatus
                    );

    SecureZeroMemory(LogonInfo, LogonInfoSize);
    LocalFree(LogonInfo);
    LocalFree(TokenGroups);
    // Log the specifed user on
    if (!NT_SUCCESS(Status))
    {
        // a-sergiv (Sergei O. Ivanov), 6-17-99
        // Fix for com+ 9383/nt 272085

        // Apply event filters
        DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
        if(dwActLogLvl == 2)
            return 0;
        if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
            return 0;

        // for this message,
        // %1 is the error number string
        // %2 is the domain name
        // %3 is the user name
        // %4 is the CLSID
        HANDLE  LogHandle;
        LPWSTR  Strings[4]; // array of message strings.
        WCHAR   wszErrnum[20];
        WCHAR   wszClsid[GUIDSTR_MAX];

        // Save the error number
        wsprintf(wszErrnum, L"%lu",GetLastError() );
        Strings[0] = wszErrnum;

        // Put in the RunAs identity
        Strings[1] = pwszRunAsDomainName;
        Strings[2] = pwszRunAsUserName;

        // Get the clsid
        Strings[3] = pwszAppID;

        // Get the log handle, then report then event.
        LogHandle = RegisterEventSource( NULL,
                                          SCM_EVENT_SOURCE );

        if ( LogHandle )
            {
            ReportEvent( LogHandle,
                         EVENTLOG_ERROR_TYPE,
                         0,             // event category
                         EVENT_RPCSS_RUNAS_CANT_LOGIN,
                         NULL,          // SID
                         4,             // 4 strings passed
                         0,             // 0 bytes of binary
                         (LPCTSTR *)Strings, // array of strings
                         NULL );        // no raw data

            // clean up the event log handle
            DeregisterEventSource(LogHandle);
            }

        return 0;
    }
    else
    {
       if (Profile) 
       {
          LsaFreeReturnBuffer(Profile);
       }
    }

    return hToken;
}

BOOL
DuplicateTokenAsPrimary(
    HANDLE hUserToken,
    PSID psidUserSid,
    HANDLE *hPrimaryToken
    )

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSECURITY_DESCRIPTOR psdNewProcessTokenSD;
    NTSTATUS NtStatus;
    
    *hPrimaryToken = NULL;

    if (hUserToken == NULL) 
    {
        return(FALSE);
    }
    //
    // Create the security descriptor that we want to put in the Token.
    //
    CAccessInfo     AccessInfo(psidUserSid);
    psdNewProcessTokenSD = AccessInfo.IdentifyAccess(
            FALSE,
            TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS |
            TOKEN_ADJUST_DEFAULT | TOKEN_QUERY |
            TOKEN_DUPLICATE | TOKEN_IMPERSONATE | READ_CONTROL,
            TOKEN_QUERY
            );
    if (psdNewProcessTokenSD == NULL)
    {
        CairoleDebugOut((DEB_ERROR, "Failed to create SD for process token\n"));
        return(FALSE);
    }
    InitializeObjectAttributes(
                 &ObjectAttributes,
                 NULL,
                 0,
                 NULL,
                 psdNewProcessTokenSD
                 );
    NtStatus = NtDuplicateToken(
                 hUserToken,         // Duplicate this token
                 TOKEN_ALL_ACCESS, // Give me this access to the resulting token
                 &ObjectAttributes,
                 FALSE,             // EffectiveOnly
                 TokenPrimary,      // TokenType
                 hPrimaryToken     // Duplicate token handle stored here
                 );

    if (!NT_SUCCESS(NtStatus)) 
    {
        CairoleDebugOut((DEB_ERROR, "CreateAndSetProcessToken failed to duplicate primary token for new user process, status = 0x%lx\n", NtStatus));
        return(FALSE);
    }
    return TRUE;
}


BOOL
DuplicateTokenForSessionUse(
    HANDLE hUserToken,
    HANDLE *hDuplicate
    )

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSECURITY_DESCRIPTOR psdNewProcessTokenSD;
    NTSTATUS NtStatus;

    if (hUserToken == NULL) {
        return(TRUE);
    }

    *hDuplicate = NULL;
    

    InitializeObjectAttributes(
                 &ObjectAttributes,
                 NULL,
                 0,
                 NULL,
                 NULL
                 );


    NtStatus = NtDuplicateToken(
                 hUserToken,         // Duplicate this token
                 TOKEN_ALL_ACCESS, //Give me this access to the resulting token
                 &ObjectAttributes,
                 FALSE,             // EffectiveOnly
                 TokenPrimary,      // TokenType
                 hDuplicate     // Duplicate token handle stored here
                 );

    if (!NT_SUCCESS(NtStatus)) {
        CairoleDebugOut((DEB_ERROR, "CreateAndSetProcessToken failed to duplicate primary token for new user process, status = 0x%lx\n", NtStatus));
        return(FALSE);
    }
    return TRUE;
}

/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer.
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
* 31-Mar-94 AndyH       Copied from Winlogon, changed arg from pGlobals
\***************************************************************************/
PSID
GetUserSid(
    HANDLE hUserToken
    )
{
    BYTE achBuffer[100];
    PTOKEN_USER pUser = (PTOKEN_USER) &achBuffer;
    PSID pSid;
    DWORD dwBytesRequired;
    NTSTATUS NtStatus;
    BOOL fAllocatedBuffer = FALSE;

    NtStatus = NtQueryInformationToken(
                 hUserToken,                // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 sizeof(achBuffer),         // TokenInformationLength
                 &dwBytesRequired           // ReturnLength
                 );

    if (!NT_SUCCESS(NtStatus))
    {
        if (NtStatus != STATUS_BUFFER_TOO_SMALL)
        {
            ASSERT(NtStatus == STATUS_BUFFER_TOO_SMALL);
            return NULL;
        }

        //
        // Allocate space for the user info
        //

        pUser = (PTOKEN_USER) PrivMemAlloc(dwBytesRequired);
        if (pUser == NULL)
        {
            CairoleDebugOut((DEB_ERROR, "Failed to allocate %d bytes\n", dwBytesRequired));
            ASSERT(pUser != NULL);
            return NULL;
        }

        fAllocatedBuffer = TRUE;

        //
        // Read in the UserInfo
        //

        NtStatus = NtQueryInformationToken(
                     hUserToken,                // Handle
                     TokenUser,                 // TokenInformationClass
                     pUser,                     // TokenInformation
                     dwBytesRequired,           // TokenInformationLength
                     &dwBytesRequired           // ReturnLength
                     );

        if (!NT_SUCCESS(NtStatus))
        {
            CairoleDebugOut((DEB_ERROR, "Failed to query user info from user token, status = 0x%lx\n", NtStatus));
            ASSERT(NtStatus == STATUS_SUCCESS);
            PrivMemFree((HANDLE)pUser);
            return NULL;
        }
    }


    // Alloc buffer for copy of SID

    dwBytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = (PSID) PrivMemAlloc(dwBytesRequired);
    if (pSid == NULL)
    {
        CairoleDebugOut((DEB_ERROR, "Failed to allocate %d bytes\n", dwBytesRequired));
        if (fAllocatedBuffer == TRUE)
        {
            PrivMemFree((HANDLE)pUser);
        }
        return NULL;
    }

    // Copy SID

    NtStatus = RtlCopySid(dwBytesRequired, pSid, pUser->User.Sid);
    if (fAllocatedBuffer == TRUE)
    {
        PrivMemFree((HANDLE)pUser);
    }


    if (!NT_SUCCESS(NtStatus))
    {
        CairoleDebugOut((DEB_ERROR, "RtlCopySid failed, status = 0x%lx\n", NtStatus));
        ASSERT(NtStatus != STATUS_SUCCESS);
        PrivMemFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


HANDLE GetUserTokenForSession(
    ULONG ulSessionId
    )
{
    BOOL fRet = FALSE;
    HANDLE hToken = NULL;

    //
    // We used to have a lot of complicated code for doing this
    // logic.  The WTSQueryUserToken api replaces all of that
    // quite nicely.    Only downside is that wtsapi32.dll has a
    // moderately large dependency list.  Since under normal
    // conditions we won't need to use this api until after someone
    // logs on, we delay-load link to wtsapi32 to avoid the load
    // hit during boot.
    //
    fRet = WTSQueryUserToken(ulSessionId, &hToken);
    if (!fRet)
    {
        return NULL;
    }
    ASSERT(hToken);
    return hToken;
}

// Global default launch permissions
CSecDescriptor* gpDefaultLaunchPermissions;


CSecDescriptor*
GetDefaultLaunchPermissions()
{
    CSecDescriptor* pSD = NULL;

    gpClientLock->LockShared();
    
    pSD = gpDefaultLaunchPermissions;
    if (pSD)
        pSD->IncRefCount();

    gpClientLock->UnlockShared();

    return pSD;
}

void
SetDefaultLaunchPermissions(CSecDescriptor* pNewLaunchPerms)
{
    CSecDescriptor* pOldSD = NULL;

    gpClientLock->LockExclusive();
    
    pOldSD = gpDefaultLaunchPermissions;
    gpDefaultLaunchPermissions = pNewLaunchPerms;
    if (gpDefaultLaunchPermissions)
        gpDefaultLaunchPermissions->IncRefCount();

    gpClientLock->UnlockExclusive();

    if (pOldSD)
        pOldSD->DecRefCount();

    return;
}

    
CSecDescriptor::CSecDescriptor(SECURITY_DESCRIPTOR* pSD) : _lRefs(1)
{
    ASSERT(pSD);
    _pSD = pSD;   // we own it now
}

CSecDescriptor::~CSecDescriptor()
{
    ASSERT(_lRefs == 0);
    ASSERT(_pSD);
    PrivMemFree(_pSD);
}

void CSecDescriptor::IncRefCount()
{
    ASSERT(_lRefs > 0);
    LONG lRefs = InterlockedIncrement(&_lRefs);
}

void CSecDescriptor::DecRefCount()
{
    ASSERT(_lRefs > 0);
    LONG lRefs = InterlockedDecrement(&_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }
}

SECURITY_DESCRIPTOR* CSecDescriptor::GetSD() 
{
    ASSERT(_pSD);
    ASSERT(_lRefs > 0);
    return _pSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\stub_privact_s.c ===
/* Stub for generated file privact_s.c */
#include <rawprivact_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\stub_objsrv_c.c ===
/* Stub for generated file objsrv_c.c */
#include <objsrv_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   olescm
TARGETPATH=   ..\..\lib\$(DEST_TREE)\$(_OBJ_DIR)
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\..\common;
INCLUDES=     $(INCLUDES);..\..\..\com\inc;..\..\..\com\rot;..\..;..\..\objex
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\cs\inc
INCLUDES=     $(INCLUDES);$(COMP_OLE32_DIR)\actprops
INCLUDES=     $(INCLUDES);$(TERMSRV_INC_PATH)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)
INCLUDES=     $(INCLUDES);$(DS_INC_PATH)
INCLUDES=     $(INCLUDES);$(DS_INC_PATH)\crypto

C_DEFINES=    -DPERUSER_REGISTRY $(C_DEFINES)
C_DEFINES=    -DOLESCM $(C_DEFINES)

PRECOMPILED_INCLUDE=..\act.hxx

SOURCES=      \
              ..\activate.cxx      \
              ..\actmisc.cxx       \
              ..\addrrefresh.cxx   \
              ..\class.cxx         \
              ..\clsid.cxx         \
              ..\dbgprt.cxx        \
              ..\dfsext.cxx        \
              ..\dscmif.cxx        \
              ..\events.cxx        \
              ..\excladdr.cxx      \
              ..\macif.cxx         \
              ..\guidtbl.cxx       \
              ..\launch.cxx        \
              ..\mach.cxx          \
              ..\registry.cxx      \
              ..\rpcalloc.cxx      \
              ..\rotif.cxx         \
              ..\scmhash.cxx       \
              ..\scmif.cxx         \
              ..\scminfo.cxx       \
              ..\scmrot.cxx        \
              ..\scmstage.cxx      \
              ..\scmsvc.cxx        \
              ..\servers.cxx       \
              ..\srothint.cxx      \
              ..\remact.cxx        \
              ..\remactif.cxx      \
              ..\remsysif.cxx      \
              ..\security.cxx      \
              ..\surrogat.cxx      \
              ..\execclt.cxx       \
              ..\winsta.cxx        \
              ..\stub_irot_s.c     \
              ..\stub_scm_s.c      \
              ..\stub_scm_z.c      \
              ..\stub_srgtprot_s.c \
              ..\stub_privact_s.c  \
              ..\stub_objsrv_c.c

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\servers.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    servers.cxx

Abstract:


Author:


Revision History:

--*/

#include "act.hxx"

// Maximum number of times we will let the server tell us we are busy
#define MAX_BUSY_RETRIES 3

// Maximum number of times we will let the server tell us it has rejected
// the call, and the sleep time between retries.
#define MAX_REJECT_RETRIES  10
#define DELAYTIME_BETWEEN_REJECTS   1500    // 1.5 seconds

extern InterfaceData *AllocateAndCopy(InterfaceData *pifdIn);


BOOL
CServerList::InList(
    IN  CServerListEntry *  pServerListEntry
    )
{
    CListElement * pEntry;

    for ( pEntry = First(); pEntry; pEntry = pEntry->Next() )
        if ( pEntry == (CListElement *) pServerListEntry )
            return TRUE;

    return FALSE;
}

CServerListEntry::CServerListEntry(
    IN  CServerTableEntry *  pServerTableEntry,
    IN  CProcess *          pServerProcess,
    IN  IPID                ipid,
    IN  UCHAR               Context,
    IN  UCHAR               State,
	IN  UCHAR               SubContext
    )
{
    _pServerTableEntry = pServerTableEntry;
    _pServerTableEntry->Reference();

    // This process was already validated in ServerRegisterClsid.
    _pServerProcess = ReferenceProcess( pServerProcess, TRUE );

    _ipid = ipid;
    _hRpc = 0;
    _Context = Context;
    _SubContext = SubContext;
    _State = State;
    _NumCalls = 0;
    _lThreadToken = 0;
    _lSingleUseStatus = SINGLE_USE_AVAILABLE;  
    _dwServerFaults = 0;

    //
    // Get a unique registration number without taking a global lock.
    // Remember that gRegisterKey uses interlocked increment for ++.
    //
    for (;;)
    {
        _RegistrationKey = (DWORD) gRegisterKey;
        gRegisterKey++;
        if ( (_RegistrationKey + 1) == (DWORD) gRegisterKey )
            break;
    }
}

CServerListEntry::~CServerListEntry()
{
    ASSERT( (Previous() == NULL) && (Next() == NULL) );
	
    ASSERT(_lSingleUseStatus == SINGLE_USE_AVAILABLE || 
           _lSingleUseStatus == SINGLE_USE_TAKEN);

    if (_hRpc)
    {
        RPC_STATUS status = RpcBindingFree(&_hRpc);
        ASSERT(status == RPC_S_OK);        
        _hRpc = NULL;
    }

    ReleaseProcess( _pServerProcess );
    _pServerTableEntry->Release();
}

HANDLE
CServerListEntry::RpcHandle()
{
    HANDLE  hRpc;
    RPC_STATUS status;

    if (_hRpc)
        return _hRpc;

    hRpc = _pServerProcess->GetBindingHandle();
    if (!hRpc)
        return NULL;

    status = RpcBindingSetObject(hRpc, (GUID *)&_ipid);
    if (status == RPC_S_OK)
    {
        // Set mutual auth and IMPERSONATE
        RPC_SECURITY_QOS_V3 qos;
        ZeroMemory(&qos, sizeof(RPC_SECURITY_QOS_V3));

        qos.Version = RPC_C_SECURITY_QOS_VERSION_3;
        qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH | 
                           RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        qos.AdditionalSecurityInfoType = 0;
        qos.Sid = _pServerProcess->GetToken()->GetSid();

        status = RpcBindingSetAuthInfoEx(hRpc,
                                         NULL, // pass sid in QOS instead
                                         RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                         RPC_C_AUTHN_WINNT,
                                         NULL,
                                         RPC_C_AUTHZ_NONE,
                                         (RPC_SECURITY_QOS*)&qos);
    }

    if (status == RPC_S_OK)
    {
        if (InterlockedCompareExchangePointer((void**)&_hRpc, hRpc, NULL) == NULL)
        {
            hRpc = NULL;
        }
    }

    if (hRpc)
    {
        status = RpcBindingFree(&hRpc);
        ASSERT(status == RPC_S_OK);
        hRpc = NULL;
    }

    return _hRpc;
}

BOOL
CServerListEntry::Match(
    IN  CToken *    pToken,
    IN  BOOL        bRemoteActivation,
	IN  BOOL        bClientImpersonating,
	IN  WCHAR*      pwszWinstaDesktop,
    IN  BOOL        bSurrogate,
    IN  LONG        lThreadToken,
    IN  LONG        lSessionID,
    IN  DWORD       pid,
    IN  DWORD       dwProcessReqType,
    IN  DWORD       dwFlags
    )
{
    ASSERT(_lSingleUseStatus == SINGLE_USE_AVAILABLE || 
           _lSingleUseStatus == SINGLE_USE_TAKEN);

    // If server is suspended, don't use it.
    if ((_State & SERVERSTATE_SUSPENDED) && !(dwFlags & MATCHFLAG_ALLOW_SUSPENDED))
        return FALSE;

    // Is the process represented by this entry retired or suspended?
    if (!_pServerProcess->AvailableForActivations())
        return FALSE;
	
    // If looking for a surrogate, only allow surrogates
    if (bSurrogate && !(_State & SERVERSTATE_SURROGATE))
        return FALSE;
    
    // Did a custom activator specify a specific process to use? 
    if (dwProcessReqType == PRT_USE_THIS)
    {
        // The rule here is, if we are not the specified process, then we
        // bail.   If we are the right guy, then that's great but then we 
        // still need to perform all subsequent checks below.   A custom
        // activator may not override our normal security checks.  
        if (_pServerProcess->GetPID() != pid)
            return FALSE;      
    }
	
    // Is this a single-use registration that has already been
    // consumed - if so, don't use.   We will check this again
    // at the bottom after all other checks have been made.  But 
    // doing so here saves us time if there are a lot of these
    // servers coming and going.
    if (_State & SERVERSTATE_SINGLEUSE)
    {
        if (_lSingleUseStatus == SINGLE_USE_TAKEN)
            return FALSE;
    }

    // If server is running as a service, no need to go further
    if (SERVER_SERVICE == _Context)
        return TRUE;
	    
    // If server is a runas, might need to do more checking (ie, for
    // interactive user servers) below
    if (SERVER_RUNAS == _Context)
        goto EndMatch;
    
    //
    // If we reached here then we are an activate-as-activator server (at
    // least til we pass the EndMatch label down below)
    //
    ASSERT(_Context == SERVER_ACTIVATOR && "Unexpected server context");
    
    //
    // If the client is anonymous, then forget it
    //
    if (!pToken)
        return FALSE;
    
    // Notes on activator-as-activator client\server identity & desktop matching:
    //
    // -- If client was remote, then only client & server identity needs to match
    // -- If client was local, and not impersonating, then both client & server
    //    identity and client\server desktop need to match
    // -- If client was local, and impersonating, then client & server identity
    //    need to match, and token luid's need to match.  
    //
    // The reason for this is that apps from NT4 and before expect that act-as-
    // activator servers will always run on the client's desktop.   If the server
    // has the same identity as the client, this is fine.   Trouble arises when the
    // client is impersonating, and we put the server on the client's desktop -
    // sometimes the newly-launched server will not have permissions to the client's
    // desktop, and hence dies a quick death.    The above rules are meant to 
    // work around this, and allow us to simulataneously accommodate both legacy apps 
    // and new apps that activate objects while impersonating.
    
    if (!bRemoteActivation && !bClientImpersonating)
    {
        ASSERT(pwszWinstaDesktop);
        if (!pwszWinstaDesktop)
            return FALSE;
		
        if (lstrcmpW(pwszWinstaDesktop, _pServerProcess->WinstaDesktop()) != 0 )
            return FALSE;
    }
    else if (!bRemoteActivation)
    {
        // By matching luids in the local\impersonation case, we can 
        // indirectly try to enforce desktops that way.
        if (S_OK != pToken->MatchTokenLuid(_pServerProcess->GetToken()))
            return FALSE;
    }

    //
    // If the client isn't us, then forget it (remember, at this point we're still
    // an activate-as-activator server)
    //
    if ( S_OK != pToken->MatchToken2(_pServerProcess->GetToken(), FALSE) )
    {
        //DbgPrint("RPCSS: ServerListEntry %p: Token did not match.\n", this);
        return FALSE;
    }

    //
    // If the client is less trusted than us, then forget it as well.
    //
    if ( gbSAFERAAAChecksEnabled )
    {
        if (S_FALSE == pToken->CompareSaferLevels(_pServerProcess->GetToken()))
        {
            //DbgPrint("RPCSS: ServerListEntry %p: SAFER level did not match.\n", this);
            return FALSE;
        }
    }
    
EndMatch:
    BOOL bRet = FALSE;

    if (lThreadToken == _lThreadToken)
    {
        CToken* pServerToken = _pServerProcess->GetToken();
        ASSERT(pServerToken && "_pServerProcess did not have an associated token reference");
        
        if (pServerToken != NULL)
        {
            if (_SubContext == SUB_CONTEXT_RUNAS_INTERACTIVE)
            {
                if (lSessionID != INVALID_SESSION_ID)
                {
                    // User specified a destination session to use; check that this
                    // server is in that session
                    bRet = (pServerToken->MatchSessionID(lSessionID) == S_OK);
                }
                else
                {
                    // No dest. session specified.   The only thing left to check is
                    // if the user is local then the server we select should be in 
                    // that user's session.   If the user is not local, then this
                    // server must be in session 0 to be a match
                    if (pToken == NULL)
                    {
                        // anonymous client;  only thing to make sure is that server
                        // is running in session zero
                        bRet = (pServerToken->GetSessionId() == 0);
                    }
                    else
                    {
                        // else the server and client better be in the same session; note
                        // that if the client is from off-machine, then his session will
                        // be zero.    
                        bRet = (S_OK == pToken->MatchTokenSessionID(pServerToken));
                    }
                }
            }
            else
            {
                // Else the server is either a pure run-as server, or an activate-as-activator
                // server.   In either case, it is adequate for the activation.
                bRet = TRUE;
            }
        }
    }
	
    // If this server registered as single-use, we need to make sure 
    // no one else uses it.   The previous implementation would take
    // a write lock here and completely remove the entry from the list,
    // but I like this method better since it's more concurrent.
    if (bRet && (_State & SERVERSTATE_SINGLEUSE))
    {
        LONG lICERet;
        lICERet = InterlockedCompareExchange(&_lSingleUseStatus, 
                                             SINGLE_USE_TAKEN, 
                                             SINGLE_USE_AVAILABLE);
        if (lICERet != SINGLE_USE_AVAILABLE)                 
        {
            // Can't use this one, somebody else grabbed it
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL
CServerListEntry::CallServer(
    IN      PACTIVATION_PARAMS  pActParams,
    OUT     HRESULT *           phr )
/*--

  Notes:  jsimmons 02/10/01 -- I changed this function to return TRUE on
            most error paths.  The semantic meaning of this function's
            return value is "TRUE if we called a server or encountered a
            fatal error trying to do so".  Return values of FALSE are interpreted
            by the caller to mean "it's okay if I do a retry".   My belief
            is that we should not be doing retrys of any kind after most
            errors -- ie, a memory allocation failure should stop us dead 
            in our tracks.

--*/
{
    HANDLE          hRpc;
    DWORD           BusyRetries;
    DWORD           RejectRetries;
    BOOL            fDone;
    DWORD           CreateInstanceFlags;
    RPC_STATUS      status = RPC_S_OK;

    HRESULT hr;

    hRpc = RpcHandle();
    if (!hRpc)
    {
        *phr = E_OUTOFMEMORY;
        return TRUE;
    }

    BusyRetries = 0;
    RejectRetries = 0;    
    CreateInstanceFlags = 0;

#ifdef SERVER_HANDLER
    if ( pActParams->ClsContext & CLSCTX_ESERVER_HANDLER )
    {
        CreateInstanceFlags |= CREATE_EMBEDDING_SERVER_HANDLER;
        
        if ( gbDisableEmbeddingServerHandler )
        {
            CreateInstanceFlags |= DISABLE_EMBEDDING_SERVER_HANDLER;
            pActParams->pInstantiationInfo->SetInstFlag(CreateInstanceFlags);
        }
    }
#endif // SERVER_HANDLER

	    
    // Tell the server that we are using dynamic cloaking.
    pActParams->ORPCthis->flags |= ORPCF_DYNAMIC_CLOAKING;
    
    if (_State & SERVERSTATE_SURROGATE)
    {
        pActParams->pInstantiationInfo->SetIsSurrogate();
    }
    
    if (pActParams->MsgType == GETPERSISTENTINSTANCE)
    {
        ASSERT(pActParams->pInstanceInfo != NULL);
        if (pActParams->pIFDROT)
        {
            InterfaceData *newIfd = AllocateAndCopy((InterfaceData*)pActParams->pIFDROT);
            if (newIfd == NULL)
            {                               
                *phr = E_OUTOFMEMORY;
                return TRUE;
            }
            pActParams->pInstanceInfo->SetIfdROT((MInterfacePointer*)newIfd);
        }
    }
    
    // In case treat as changed the clsid set it now
    ASSERT(pActParams->pInstantiationInfo);
    pActParams->pInstantiationInfo->SetClsid(pActParams->Clsid);
    
    do
    {
        MInterfacePointer *pIFDIn, *pIFDOut=NULL;
        DWORD destCtx = MSHCTX_LOCAL;
        *phr = ActPropsMarshalHelper(pActParams->pActPropsIn,
                                     IID_IActivationPropertiesIn,
                                     destCtx,
                                     MSHLFLAGS_NORMAL,
                                     &pIFDIn);
        
        if (FAILED(*phr))
        {
            return TRUE;
        }

        //
        // Always impersonate the client before calling the server.
        //
        pActParams->pToken->Impersonate();    
        
        switch (pActParams->MsgType)
        {
        case GETCLASSOBJECT:
            
            status = RPC_S_OK;
            
            RpcTryExcept
              {
                  *phr = LocalGetClassObject(
                            hRpc,
                            pActParams->ORPCthis,
                            pActParams->Localthis,
                            pActParams->ORPCthat,
                            pIFDIn,
                            &pIFDOut);
              }
            RpcExcept(1)
              {
                  status = RpcExceptionCode();
              }
            RpcEndExcept;

            break;
            
        case GETPERSISTENTINSTANCE:
        case CREATEINSTANCE:

            status = RPC_S_OK;           
            
            RpcTryExcept
              {
                  *phr = LocalCreateInstance(
                            hRpc,
                            pActParams->ORPCthis,
                            pActParams->Localthis,
                            pActParams->ORPCthat,
                            NULL, //No punk outer from here
                            pIFDIn,
                            &pIFDOut);
              }
            RpcExcept(1)
              {
                  status = RpcExceptionCode();
              }
            RpcEndExcept;
            break;

        default:
            ASSERT(0 && "Unknown activation type");
            *phr = E_UNEXPECTED;
            break;
        } //Switch

        //
        // Un-impersonate
        //
        pActParams->pToken->Revert();

        MIDL_user_free(pIFDIn);

        if ((*phr == S_OK) && (status == RPC_S_OK ))
        {
            // AWFUL HACK ALERT:  This is too hacky even for the SCM
            ActivationStream ActStream((InterfaceData*)
                (((BYTE*)pIFDOut)+48));
            
            pActParams->pActPropsOut = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */ );
            if (pActParams->pActPropsOut != NULL)
            {
                IActivationPropertiesOut *dummy;
                hr = pActParams->pActPropsOut->UnmarshalInterface(&ActStream,
                                                 IID_IActivationPropertiesOut,
                                                 (LPVOID*)&dummy);
                if (FAILED(hr))
                {
                    pActParams->pActPropsOut->Release();
                    pActParams->pActPropsOut = NULL;
                    *phr = hr;
                }
                else
                    dummy->Release();
            }
            else
                *phr = E_OUTOFMEMORY;

            MIDL_user_free(pIFDOut);
        }
                
        // Determine if we need to retry the call. Assume not.
        fDone = TRUE;
        if (status == RPC_S_SERVER_TOO_BUSY)
        {
            // server RPC was busy, should we retry?
            if (BusyRetries++ < MAX_BUSY_RETRIES)
                fDone = FALSE;
        }
        else if (status == RPC_E_CALL_REJECTED)
        {
            // Take Note: this is somewhat broken, but was added as a hotfix for
            // Word Insert Excel'97 with Addins, where Excel registers it's CF
            // early then rejects calls until the addin's are ready, which could
            // take any amount of time. We give 3 tries, with a sleep between them
            // to give the app some CPU time and emulate the delay than a client
            // message filter would do.
            if (RejectRetries++ < MAX_REJECT_RETRIES)
            {
                Sleep(DELAYTIME_BETWEEN_REJECTS);
                fDone = FALSE;
            }
        }
    }
    while ( !fDone );
    
    // A RpcStatus of ERROR_ACCESS_DENIED means the server will never
    // accept calls from this user.  Don't retry the activation.
    if (status == ERROR_ACCESS_DENIED || status == E_ACCESSDENIED)
    {
        *phr = HRESULT_FROM_WIN32(status);
        return TRUE;
    }
    
    //
    // We get a non-zero rpcstat if there was a communication problem
    // with the server.  We get CO_E_SERVER_STOPPING if a server
    // consumes its own single use registration or was in the process of
    // revoking its registration when we called.
    //
    else if ( (status != RPC_S_OK) || (*phr == CO_E_SERVER_STOPPING) )
    {
        if ( status != RPC_S_OK )
        {
            //
            // Some rpc errors are of the 8001xxxx variety.  We shouldn't do
            // the hresult conversion of these.
            //
            if ( HRESULT_FACILITY( status ) == FACILITY_RPC )
                *phr = status;
            else
                *phr = HRESULT_FROM_WIN32(status);
        }
        
        // Decide whether to retry the activation.
        return RetryableError(*phr) ? FALSE : TRUE;
    }
    
    return TRUE;
}

BOOL 
CServerListEntry::ServerDied()
/*--

    ServerDied

    Used by callers to determine if the server process handle
    has been signalled.

--*/
{
    BOOL fServerDied = FALSE;

    HANDLE hProcess = _pServerProcess->GetProcessHandle();
    if (hProcess)
    {
        DWORD dwRet = WaitForSingleObject(hProcess, 0);
        if (dwRet == WAIT_OBJECT_0)
        {
            fServerDied = TRUE;
        }
        // else assume still alive on all other return values
    }

    return fServerDied;
}	

BOOL 
CServerListEntry::RetryableError(HRESULT hr)
/*--

    Returns TRUE if the error is such that the caller should attempt
    a retry of the activation, or FALSE otherwise.

--*/
{
    BOOL fRetry = TRUE;

    switch (hr)
    {
    case RPC_E_SYS_CALL_FAILED:
        // RPC_E_SYS_CALL_FAILED is not used by rpc, only ole32, and it
        // is not one we should be doing retrys on.
        fRetry = FALSE;
        break;

    default:
        fRetry = TRUE;
        break;
    }

    return fRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\stub_irot_s.c ===
/* Stub for generated file irot_s.c */
#include <irot_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\srothint.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       srothint.cxx
//
//  Contents:   Implementation of classes used in implementing the ROT hint
//              table in the SCM.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CScmRotHintTable::CScmRotHintTable
//
//  Synopsis:   Create SCM ROT hint table
//
//  Arguments:  [pwszName] - name for shared memory
//              [psid] - security ID
//
//  Algorithm:  Create and map in shared memory for the hint table
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotHintTable::CScmRotHintTable(WCHAR *pwszName)
{
    BOOL fCreated;
    PSECURITY_DESCRIPTOR pRotSecurityDescriptor = NULL;
    SID_IDENTIFIER_AUTHORITY SidAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID pSid;

    pSid = 0;

    fCreated = AllocateAndInitializeSid(
                &SidAuthWorld, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid );

    ASSERT(fCreated && "CRotHintTable::CRotHintTable No SID");

    if ( ! fCreated || ! pSid )
        return;

    CAccessInfo AccessInfo(pSid);

    pRotSecurityDescriptor = AccessInfo.IdentifyAccess (
        TRUE,
        FILE_MAP_READ,
        FILE_MAP_ALL_ACCESS
        );

    _hSm = CreateSharedFileMapping(pwszName,
          SCM_HASH_SIZE,
          SCM_HASH_SIZE,
          NULL,
          pRotSecurityDescriptor,
          PAGE_READWRITE,
          (void **) &_pbHintArray,
          &fCreated);

    ASSERT(_hSm && "CRotHintTable::CRotHintTable create SM failed");
    ASSERT(fCreated && "CRotHintTable::CRotHintTable Memory not created");

    FreeSid( pSid );

    if (_pbHintArray != NULL)
    {
        memset(_pbHintArray, 0, SCM_HASH_SIZE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\stub_scm_s.c ===
/* Stub for generated file scm_s.c */
#include <scm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\stub_scm_z.c ===
/* Stub for generated file scm_z.c */
#include <scm_z.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\wrapper\sap.h ===
#ifdef __cplusplus
extern "C" {
#endif

enum SAP_CONTROL_TYPE
{
    SAP_CTRL_FORCE_REGISTER,
    SAP_CTRL_MAYBE_REGISTER,
    SAP_CTRL_UPDATE_ADDRESS,
    SAP_CTRL_UNREGISTER
};

void
UpdateSap(
    enum SAP_CONTROL_TYPE action
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\wrapper\sources.inc ===
!IF 0

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcss
TARGETTYPE=DYNLINK
TARGETLIBS= \
           $(SDK_LIB_PATH)\rpcrt4.lib   \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\secur32.lib \
           $(SDK_LIB_PATH)\wtsapi32.lib \
           $(SDK_LIB_PATH)\userenv.lib \
           $(SDK_LIB_PATH)\mpr.lib \
           $(SDK_LIB_PATH)\netapi32.lib \
           $(SDK_LIB_PATH)\msi.lib \
           $(SDK_LIB_PATH)\winsta.lib \
           $(NET_LIB_PATH)\ndispnp.lib \
           $(DS_LIB_PATH)\rsa32.lib \
           $(DS_LIB_PATH)\randlib.lib \
           $(DS_LIB_PATH)\alloca.lib \
           $(COM_LIB_PATH)\clbcatq.lib \
           $(COM_LIB_PATH)\comutils.lib

DELAYLOAD = winsta.dll; wtsapi32.dll; userenv.dll; mpr.dll; netapi32.dll; msi.dll; clbcatq.dll
DLOAD_ERROR_HANDLER=kernel32.dll

INCLUDES=$(INCLUDES);$(DS_INC_PATH)
INCLUDES=$(INCLUDES);$(DS_INC_PATH)\crypto

USE_MSVCRT=1
MSC_WARNING_LEVEL=/W3 /WX
DLLDEF=..\dcomss.def
DLLENTRY=_DllMainCRTStartup

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\stub_srgtprot_s.c ===
/* Stub for generated file srgtprot_s.c */
#include <srgtprot_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\wrapper\epts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Epts.c

Abstract:

    Common code to listen to endpoints in the DCOM service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     6/16/1995    Bits 'n pieces
    Edwardr     7/17/1996    Added ncadg_mq
    Edwardr     5/01/1997    Added ncacn_http
    MazharM    10-12.98      Add pnp stuff
    KamenM     Oct 2000      Removed ncadg_mq

--*/

//#define NCADG_MQ_ON
//#define NETBIOS_ON
#if !defined(_M_IA64)
#define SPX_ON
#endif
//#define IPX_ON

#if !defined(SPX_ON) && !defined(IPX_ON)
#define SPX_IPX_OFF
#endif

#include <dcomss.h>
#include <winsvc.h>
#include <winsock2.h>

#if !defined(SPX_IPX_OFF)
#include <wsipx.h>
#include <svcguid.h>
#include "sap.h"
#endif

// Globals

#if !defined(SPX_IPX_OFF)
const IPX_BOGUS_NETWORK_NUMBER = 0xefcd3412;

BOOL gfDelayedAdvertiseSaps = FALSE;

typedef enum
    {
    SapStateUnknown,
    SapStateNoServices,
    SapStateEnabled,
    SapStateDisabled
    } SAP_STATE;

SAP_STATE SapState = SapStateUnknown;
#endif

enum RegistryState
{
    RegStateUnknown,
    RegStateMissing,
    RegStateYes,
    RegStateNo

} RegistryState = RegStateUnknown;

// Prototypes

#if !defined(SPX_IPX_OFF)
void  AdvertiseNameWithSap(void);
void  CallSetService( SOCKADDR_IPX * pipxaddr, BOOL fRegister );
#endif

//
// The index is the protseq tower id.
//

PROTSEQ_INFO
gaProtseqInfo[] =
    {
    /* 0x00 */ { STOPPED, 0, 0 },
    /* 0x01 */ { STOPPED, 0, 0 },
    /* 0x02 */ { STOPPED, 0, 0 },
    /* 0x03 */ { STOPPED, 0, 0 },
    /* 0x04 */ { STOPPED, L"ncacn_dnet_nsp", L"#69" },
    /* 0x05 */ { STOPPED, 0, 0 },
    /* 0x06 */ { STOPPED, 0, 0 },
    /* 0x07 */ { STOPPED, L"ncacn_ip_tcp",   L"135" },
    /* 0x08 */ { STOPPED, L"ncadg_ip_udp",   L"135" },

#ifdef NETBIOS_ON
    /* 0x09 */ { STOPPED, L"ncacn_nb_tcp",   L"135" },
#else
    /* 0x09 */ { STOPPED, 0, 0 },
#endif

    /* 0x0a */ { STOPPED, 0, 0 },
    /* 0x0b */ { STOPPED, 0, 0 },
#if defined(SPX_ON)
    /* 0x0c */ { STOPPED, L"ncacn_spx",      L"34280" },
#else
    /* 0x0c */ { STOPPED, 0, 0 },
#endif

#ifdef NETBIOS_ON
    /* 0x0d */ { STOPPED, L"ncacn_nb_ipx",   L"135" },
#else
    /* 0x0d */ { STOPPED, 0, 0 },
#endif

    /* 0x0e */ { STOPPED, L"ncadg_ipx",      L"34280" },
    /* 0x0f */ { STOPPED, L"ncacn_np",       L"\\pipe\\epmapper" },
    /* 0x10 */ { STOPPED, L"ncalrpc",        L"epmapper" },
    /* 0x11 */ { STOPPED, 0, 0 },
    /* 0x12 */ { STOPPED, 0, 0 },
#ifdef NETBIOS_ON
    /* 0x13 */ { STOPPED, L"ncacn_nb_nb",    L"135" },
#else
    /* 0x13 */ { STOPPED, 0, 0 },
#endif

    /* 0x14 */ { STOPPED, 0, 0 },
    /* 0x15 */ { STOPPED, 0, 0 }, // was ncacn_nb_xns - unsupported.
    /* 0x16 */ { STOPPED, L"ncacn_at_dsp", L"Endpoint Mapper" },
    /* 0x17 */ { STOPPED, L"ncadg_at_ddp", L"Endpoint Mapper" },
    /* 0x18 */ { STOPPED, 0, 0 },
    /* 0x19 */ { STOPPED, 0, 0 },
    /* 0x1A */ { STOPPED, 0, 0 },
    /* 0x1B */ { STOPPED, 0, 0 },
    /* 0x1C */ { STOPPED, 0, 0 },

#ifdef NCADG_MQ_ON
    /* 0x1D */ { STOPPED, L"ncadg_mq",  L"EpMapper"},
#else
    /* 0x1D */ { STOPPED, 0, 0 },
#endif

    /* 0x1E */ { STOPPED, 0, 0 },
    /* 0x1F */ { STOPPED, L"ncacn_http", L"593" },  // dcomhttp port assigned by IANA
    /* 0x20 */ { STOPPED, 0, 0 },
    };

#define PROTSEQ_IDS (sizeof(gaProtseqInfo)/sizeof(PROTSEQ_INFO))

#define ID_LPC (0x10)
#define ID_IPX (0x0E)

#if defined(SPX_ON)
#define ID_SPX (0x0C)
#endif

#define ID_HTTP (0x1F)

#define ID_TCP (0x07)

// Do not listen on all NICs by default.
// A reg key can be used to override this and listen on all NICs, but
// the override will break DG dynamic endpoint functionality when selective
// binding is enabled.
BOOL fListenOnInternet = FALSE;    // see bug 69332 (in old nt raid db)


BOOL
CreateSids(
    PSID*	ppsidBuiltInAdministrators,
    PSID*	ppsidSystem,
    PSID*	ppsidWorld
)
/*++

Routine Description:

    Creates and return pointers to three SIDs one for each of World,
    Local Administrators, and System.

Arguments:

    ppsidBuiltInAdministrators - Receives pointer to SID representing local
        administrators; 
    ppsidSystem - Receives pointer to SID representing System;
    ppsidWorld - Receives pointer to SID representing World.

Return Value:

    BOOL indicating success (TRUE) or failure (FALSE).

    Caller must free returned SIDs by calling FreeSid() for each returned
    SID when this function return TRUE; pointers should be assumed garbage
    when the function returns FALSE.

--*/
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Local
    // Administrators is in the "built in" domain.  The other SIDs, for
    // Authenticated users and system, is based directly off of the
    // authority. 
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppsidBuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authorities
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidSystem)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&WorldAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_WORLD_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidWorld)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

        FreeSid(*ppsidSystem);
        *ppsidSystem = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


PSECURITY_DESCRIPTOR
CreateSd(
    VOID
)
/*++

Routine Description:

    Creates and return a SECURITY_DESCRIPTOR with a DACL granting
    (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE) to World,
    and GENERIC_ALL to Local Administrators and System.

Arguments:

    None

Return Value:

    Pointer to the created SECURITY_DESCRIPTOR, or NULL if an error occurred.

    Caller must free returned SECURITY_DESCRIPTOR back to process heap by
    a call to HeapFree.

--*/
{
    PSID	psidWorld;
    PSID	psidBuiltInAdministrators;
    PSID	psidSystem;

    if (!CreateSids(&psidBuiltInAdministrators,
                    &psidSystem,
                    &psidWorld)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    Sd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(psidWorld) +
            GetLengthSid(psidBuiltInAdministrators) +
            GetLengthSid(psidSystem);

        Sd = HeapAlloc(GetProcessHeap(),
                       0,
                       SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!Sd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                            psidWorld)) {

                // Failed to build the ACE granting "WORLD"
                // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidBuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // (GENERIC_ALL) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidSystem)) {

                // Failed to build the ACE granting "System"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(Sd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(Sd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(psidWorld);
                FreeSid(psidBuiltInAdministrators);
                FreeSid(psidSystem);

                return Sd;
            }

            HeapFree(GetProcessHeap(),
                     0,
                     Sd);
        }

        FreeSid(psidWorld);
        FreeSid(psidBuiltInAdministrators);
        FreeSid(psidSystem);
    }

    return NULL;
}


RPC_STATUS
UseProtseqIfNecessary(
    IN USHORT id
    )
/*++

Routine Description:

    Listens to the well known RPC endpoint mapper endpoint
    for the protseq.  Returns very quickly if the process
    is already listening to the protseq.

Arguments:

    id - the tower id of protseq.  See GetProtseqId() if you don't
         already have this value.

Return Value:

    RPC_S_OK - no errors occured.
    RPC_S_OUT_OF_RESOURCES - when we're unable to setup security for the endpoint.
    RPC_S_INVALID_RPC_PROTSEQ - if id is unknown/invalid.

    Any error from RpcServerUseProtseqEp.

--*/
{
    RPC_STATUS status = RPC_S_OK;
    SECURITY_DESCRIPTOR *psd = NULL;
    RPC_POLICY Policy;

    Policy.Length = sizeof(RPC_POLICY);
    Policy.EndpointFlags = 0;

    if (fListenOnInternet)
        {
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS;
        }
    else
        {
        Policy.NICFlags = 0;
        }

    ASSERT(id);

    if (id == 0 || id >= PROTSEQ_IDS)
        {
        ASSERT(0);
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    if (gaProtseqInfo[id].state == STARTED)
        {
        return(RPC_S_OK);
        }

    if (id == ID_LPC)
        {
        // ncalrpc needs a security descriptor.

        psd = CreateSd();            

        if ( NULL == psd )
            {
            status = RPC_S_OUT_OF_RESOURCES;
            }
        }
    else
        {
        psd = NULL;
        }

    if (status == RPC_S_OK )
        {
        status = RpcServerUseProtseqEpEx(gaProtseqInfo[id].pwstrProtseq,
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 40,
                                       gaProtseqInfo[id].pwstrEndpoint,
                                       psd,
                                       &Policy);

        if ( NULL != psd )
            {
            HeapFree(GetProcessHeap(),
                     0,
                     psd);

            psd = NULL;
            }

        // No locking is done here, the RPC runtime may return duplicate
        // endpoint if two threads call this at the same time.
        if (status == RPC_S_DUPLICATE_ENDPOINT)
            {
            status = RPC_S_OK;
            }

#ifdef DEBUGRPC
        if (status != RPC_S_OK)
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "DCOMSS: Unable to listen to %S (0x%x)\n",
                       gaProtseqInfo[id].pwstrProtseq,
                       status));
            }
#endif

        if (status == RPC_S_OK)
            {
            gaProtseqInfo[id].state = STARTED;

#if !defined(SPX_IPX_OFF)
            if (
#if defined(IPX_ON)
                (id == ID_IPX) 
                  || 
#endif
#if defined(SPX_ON)
                (id == ID_SPX)
#endif
               )
                {
                UpdateSap(SAP_CTRL_MAYBE_REGISTER);
                }
#endif
            }
        }

    return(status);
}


PWSTR
GetProtseq(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Returns the unicode protseq give the protseqs tower id.

Arguments:

    ProtseqId - Tower id of the protseq in question.

Return Value:

    NULL if the id is invalid.

    non-NULL if the id is valid - note the pointer doesn't need to be freed.

--*/

{
    ASSERT(ProtseqId);

    if (ProtseqId < PROTSEQ_IDS)
        {
        return(gaProtseqInfo[ProtseqId].pwstrProtseq);
        }
    return(0);
}


PWSTR
GetEndpoint(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Returns the well known endpoint associated with the protseq.

Arguments:

    ProtseqId - the id (See GetProtseqId()) of the protseq in question.

Return Value:

    0 - Unknown/invalid id.

    !0 - The endpoint associated with the protseq.
         note: should not be freed.

--*/
{
    ASSERT(ProtseqId);

    if (ProtseqId < PROTSEQ_IDS)
        {
        return(gaProtseqInfo[ProtseqId].pwstrEndpoint);
        }
    return(0);
}


USHORT
GetProtseqId(
    IN PWSTR Protseq
    )
/*++

Routine Description:

    Returns the tower id for a protseq.

    This could be changed to a faster search, but remember that
    eventually the table will NOT be static.  (ie. we can't just
    create a perfect hash based on the static table).

Arguments:

    Protseq - a unicode protseq to lookup.  It is assumed
              to be non-null.

Return Value:

    0 - unknown/invalid protseq
    non-zero - the id.

--*/
{
    int i;
    ASSERT(Protseq);

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (    0 != gaProtseqInfo[i].pwstrProtseq
             && 0 == lstrcmpW(gaProtseqInfo[i].pwstrProtseq, Protseq))
            {
            return((USHORT)i);
            }
        }
    return(0);
}


USHORT
GetProtseqIdAnsi(
    IN PSTR pstrProtseq
    )
/*++

Routine Description:

    Returns the tower id for a protseq.

    This could be changed to a faster search, but remember that
    eventually the table will NOT be static.  (ie. we can't just
    create a perfect hash based on the static table).

Arguments:

    Protseq - an ansi (8 bit char) protseq to lookup.  It is assumed
              to be non-null.

Return Value:

    0 - unknown/invalid protseq
    non-zero - the id.

--*/
{
    int i;
    ASSERT(pstrProtseq);

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (0 != gaProtseqInfo[i].pwstrProtseq)
            {
            PWSTR pwstrProtseq = gaProtseqInfo[i].pwstrProtseq;
            PSTR  pstrT = pstrProtseq;

            while(*pstrT && *pwstrProtseq && *pstrT == *pwstrProtseq)
                {
                pstrT++;
                pwstrProtseq++;
                }
            if (*pstrT == *pwstrProtseq)
                {
                return((USHORT)i);
                }
            }
        }
    return(0);
}

const PWSTR NICConfigKey = L"System\\CurrentControlSet\\Services\\RpcSs";
const PWSTR ListenOnInternet = L"ListenOnInternet";


RPC_STATUS
InitializeEndpointManager(
    VOID
    )
/*++

Routine Description:

    Called when the dcom service starts.

Arguments:

    None

Return Value:

    RPC_S_OUT_OF_MEMORY - if needed

    RPC_S_OUT_OF_RESOURCES - usually on registry failures.

--*/
{
    HKEY hkey;
    DWORD size, type, value;
    RPC_STATUS status;

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           (PWSTR)NICConfigKey,
                           0,
                           KEY_READ,
                           &hkey);

    if (status != RPC_S_OK)
        {
        ASSERT(status == ERROR_FILE_NOT_FOUND);
        return(RPC_S_OK);
        }

    size = sizeof(value);
    status = RegQueryValueExW(hkey,
                              (PWSTR)ListenOnInternet,
                              0,
                              &type,
                              (PBYTE)&value,
                              &size);

    if ( status == RPC_S_OK )
    {
        if ((type != REG_SZ)
        || (*(PWSTR)&value != 'Y'
             && *(PWSTR)&value != 'y'
             && *(PWSTR)&value != 'N'
             && *(PWSTR)&value != 'n'))
            {
            goto Cleanup;
            }

    if (*(PWSTR)&value == 'Y'
       || *(PWSTR)&value == 'y')
       {
       fListenOnInternet = TRUE;
       }
    else
       {
       fListenOnInternet = FALSE;
       }
    }

Cleanup:
    RegCloseKey(hkey);
    return(RPC_S_OK);
}


BOOL
IsLocal(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Determines if the protseq id is local-only. (ncalrpc)

Arguments:

    ProtseqId - The id of the protseq in question.

Return Value:

    TRUE - if the protseq id is local-only
    FALSE - if the protseq id invalid or available remotely.

--*/
{
    return(ProtseqId == ID_LPC);
}


RPC_STATUS
DelayedUseProtseq(
    IN USHORT id
    )
/*++

Routine Description:

    If the protseq is not being used its state is changed
    so that a callto CompleteDelayedUseProtseqs() will actually
    cause the server to listen to the protseq.

    This is called when an RPC server registers an dynamic
    endpoint on this protocol.

Arguments:

    id - the id of the protseq you wish to listen to.

Return Value:

    0 - normally

    RPC_S_INVALID_RPC_PROTSEQ - if id is invalid.

--*/
{
#if !defined(SPX_IPX_OFF)
    // For IPX and SPX
    if ( 
#if defined(IPX_ON)
        (id == ID_IPX) 
          || 
#endif
#if defined(SPX_ON)
        (id == ID_SPX) 
#endif
       )
        {
        gfDelayedAdvertiseSaps = TRUE;
        }
#endif

    if (id < PROTSEQ_IDS)
        {
        if (gaProtseqInfo[id].pwstrProtseq != 0)
            {
            if (gaProtseqInfo[id].state == STOPPED)
                gaProtseqInfo[id].state = START;
            return(RPC_S_OK);
            }

        }
    return(RPC_S_INVALID_RPC_PROTSEQ);
}


VOID
CompleteDelayedUseProtseqs(
    VOID
    )
/*++

Routine Description:

    Start listening to any protseqs previously passed
    to DelayedUseProtseq().  No errors are returned,
    but informationals are printed on debug builds.

Arguments:

    None

Return Value:

    None

--*/
{
    USHORT i;

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (START == gaProtseqInfo[i].state)
            {
            RPC_STATUS status = UseProtseqIfNecessary(i);
#ifdef DEBUGRPC
            if (RPC_S_OK == status)
                ASSERT(gaProtseqInfo[i].state == STARTED);
#endif
            }
        }

#if !defined(SPX_IPX_OFF)
    if (gfDelayedAdvertiseSaps)
        {
        gfDelayedAdvertiseSaps = FALSE;
        UpdateSap(SAP_CTRL_MAYBE_REGISTER);
        }
#endif
}

#if !defined(SPX_IPX_OFF)

RPC_STATUS
ServiceInstalled(
    PWSTR ServiceName
    )
/*++

Routine Description:

    Tests if a service is installed.

Arguments:

    ServiceName - The unicode name (short or long) of the service
        to check.

Return Value:

    0 - service installed
    ERROR_SERVICE_DOES_NOT_EXIST - service not installed
    other - parameter or resource problem

--*/
{
    SC_HANDLE ScHandle;
    SC_HANDLE ServiceHandle;

    ScHandle = OpenSCManagerW(0, 0, GENERIC_READ);

    if (ScHandle == 0)
        {
        return(ERROR_SERVICE_DOES_NOT_EXIST);
        }

    ServiceHandle = OpenService(ScHandle, ServiceName, GENERIC_READ);

    if (ServiceHandle == 0)
        {
        #if DBG
        if (GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST)
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Failed %d opening the %S service\n",
                       GetLastError(),
                       ServiceName));
            }
        #endif

        CloseServiceHandle(ScHandle);
        return(ERROR_SERVICE_DOES_NOT_EXIST);
        }

    // Service installed

    CloseServiceHandle(ScHandle);
    CloseServiceHandle(ServiceHandle);

    return(RPC_S_OK);
}



const GUID RPC_SAP_SERVICE_TYPE = SVCID_NETWARE(0x640);

void
UpdateSap(
    enum SAP_CONTROL_TYPE action
    )
/*++

Routine Description:

    Starts, stops, or updates the periodic SPX SAP broadcasts that allow an RPC
    client to map the server name to an IPX address. To understand IPX and SAP,
    read "IPX Router Specification", Novell part # 107-000029-001.

    A SAP broadcast will be processed by several categories of machines
    - all machines in the local subnet(s) will have to read and discard the packet
    - routers connected to the local subnet(s) will add the data to the info they
      periodically exchange with other routers
    - Netware-compatible servers will add the info to their Bindery tables.

    That is why not all NT machines should SAP.

Arguments:

    action:

        SAP_CTRL_FORCE_REGISTER: begin sapping

        SAP_CTRL_MAYBE_REGISTER: begin sapping only if the Netware-compatible
                                 workstation and/or the SAP Agent service is
                                 installed. File/Print Svcs for Netware forces the
                                 SAP Agent, so it too will enable sapping.

        SAP_CTRL_UPDATE_ADDRESS: a net card was added or subtracted, or the network
                                 address changed.  Re-register if sapping is already
                                 active.

        SAP_CTRL_UNREGISTER:     stop sapping

--*/
{
    DWORD status;
    HKEY hKey;

    // Service paramaters
    NT_PRODUCT_TYPE type;

    if (RegistryState == RegStateUnknown)
        {
        // The registry key has absolute control of SAPing

        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Rpc"),
                              0,
                              KEY_READ,
                              &hKey);

        if (status == ERROR_SUCCESS)
            {
            WCHAR pwstrValue[8];
            DWORD dwType, dwLenBuffer;
            dwLenBuffer = sizeof(pwstrValue);


            status = RegQueryValueEx(hKey,
                                     TEXT("AdvertiseRpcService"),
                                     0,
                                     &dwType,
                                     (PBYTE)pwstrValue,
                                     &dwLenBuffer
                                    );

            if (   status == ERROR_SUCCESS
                && dwType == REG_SZ)
                {
                if (   pwstrValue[0] == 'y'
                    || pwstrValue[0] == 'Y' )
                    {
                    RegistryState = RegStateYes;
                    }
                else if (   pwstrValue[0] == 'n'
                         || pwstrValue[0] == 'N' )
                    {
                    RegistryState = RegStateNo;
                    }
                else
                    {
                    // Value in the registry is wrong, pretend it doesn't exist.
                    RegistryState = RegStateMissing;
                    }
                }
            else
                {
                // Bad or missing value in the registry, pretend is doesn't exist.
                RegistryState = RegStateMissing;
                }

            RegCloseKey(hKey);
            }
        }

    switch (action)
        {
        case SAP_CTRL_FORCE_REGISTER:
            if (RegistryState == RegStateNo)
                {
                // "no" in registry trumps any registration
                return;
                }

            if (SapState == SapStateEnabled)
                {
                // already active
                return;
                }
            break;

        case SAP_CTRL_MAYBE_REGISTER:
            if (RegistryState == RegStateNo)
                {
                // "no" in registry trumps any registration
                return;
                }

            if (SapState == SapStateEnabled)
                {
                // already registered
                return;
                }

            if (RegistryState == RegStateYes)
                {
                // don't check services, just register.
                break;
                }

            if (SapState == SapStateNoServices)
                {
                ASSERT( RegistryState != RegStateYes ); // in case checks are rearranged
                // the appropriate services are not installed
                return;
                }

            //
            // Getting here means we don't know yet whether the proper services are installed.
            //
            // Depending on configuration, this controls if automatic
            // listens (due to DCOM configuration) enable SAPing or not.

            type = NtProductWinNt;
            RtlGetNtProductType(&type);

            status = ERROR_SERVICE_DOES_NOT_EXIST;

            if (type != NtProductWinNt)
                {
                // Server platform, try NWCWorkstation
                status = ServiceInstalled(L"NWCWorkstation");
                }

            if (status == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                status = ServiceInstalled(L"NwSapAgent");
                }

            if (status == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                SapState = SapStateNoServices;
                return;
                }

            //
            // Proper services are installed.
            //
            break;

        case SAP_CTRL_UPDATE_ADDRESS:
            if (SapState != SapStateEnabled)
                {
                return;
                }
            break;

        case SAP_CTRL_UNREGISTER:
            if (SapState == SapStateDisabled ||
                SapState == SapStateNoServices)
                {
                // already not registered
                }
            break;

        default:

            ASSERT( 0 );
        }

    AdvertiseNameWithSap();
}


void
AdvertiseNameWithSap()
/*++

Parameters:

Description:

Returns:

--*/
{
    // winsock (socket, bind, getsockname) parameters
    SOCKADDR_IPX        new_ipxaddr;
    static SOCKADDR_IPX old_ipxaddr = { AF_IPX, { 0 }, { 0 }, 0 } ;
    static CRITICAL_SECTION * pCritsec;

    SOCKET       s;
    int          err;
    int          size;

    //
    // A critical section protects old_ipxaddr since several different events lead to
    // calling this function.  The following code makes sure that the critical
    // section is created, and that all threads are using the same one.
    //
    if (!pCritsec)
        {
        CRITICAL_SECTION * myCritsec = HeapAlloc( GetProcessHeap(), 0, sizeof(CRITICAL_SECTION));
        if (!myCritsec)
            {
            return;
            }

        err = RtlInitializeCriticalSection( myCritsec );
        if (!NT_SUCCESS(err))
            {
            HeapFree(GetProcessHeap(), 0, myCritsec);
            return;
            }

        myCritsec = (CRITICAL_SECTION *) InterlockedExchangePointer( (PVOID *) &pCritsec, myCritsec );
        if (myCritsec)
            {
            HeapFree(GetProcessHeap(), 0, myCritsec);
            }
        }

    //
    // Get this server's IPX address.
    //
    s = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
    if (s != -1)
        {
        size = sizeof(new_ipxaddr);

        memset(&new_ipxaddr, 0, sizeof(new_ipxaddr));
        new_ipxaddr.sa_family = AF_IPX;

        err = bind(s, (struct sockaddr *)&new_ipxaddr, sizeof(new_ipxaddr));
        if (err == 0)
            {
            err = getsockname(s, (struct sockaddr *)&new_ipxaddr, &size);
            }
        }
    else
        {
        err = -1;
        }

    if (err != 0)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: socket() or getsockname() failed %d, aborting SAP setup\n",
                   GetLastError()));

        return;
        }

    if (s != -1)
        {
        closesocket(s);
        }

    EnterCriticalSection( pCritsec );

    if (0 != memcmp( old_ipxaddr.sa_netnum,  new_ipxaddr.sa_netnum,  sizeof(old_ipxaddr.sa_netnum)) ||
        0 != memcmp( old_ipxaddr.sa_nodenum, new_ipxaddr.sa_nodenum, sizeof(old_ipxaddr.sa_nodenum)))
        {
        memcpy( &old_ipxaddr, &new_ipxaddr, sizeof(old_ipxaddr) );

        LeaveCriticalSection( pCritsec );

        if (*((long *) &new_ipxaddr.sa_netnum) != IPX_BOGUS_NETWORK_NUMBER)
            {
            CallSetService( &new_ipxaddr, TRUE);
            }
        else
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: SPX net number is bogus.  Not registering until a real address arrives. \n"));

            CallSetService( &new_ipxaddr, FALSE);
            }
        }
    else
        {
        LeaveCriticalSection( pCritsec );
        }
}


void
CallSetService(
    SOCKADDR_IPX * pipxaddr,
    BOOL fRegister
    )
/*++
Function Name:CallSetService

Parameters:

Description:

Returns:

--*/
{
    DWORD ignore;
    DWORD status;

    // SetService params
    WSAQUERYSETW     info;
    CSADDR_INFO      addresses;

    // GetComputerName parameters
    static WCHAR        buffer[MAX_COMPUTERNAME_LENGTH + 1];
    static BOOL         bufferValid = FALSE;

    if (!bufferValid)
        {
        // Get this server's name
        ignore = MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameW(buffer, &ignore))
            {
            return;
            }
        bufferValid = TRUE;
        }

    // We'll register only for the endpoint mapper port.  The port
    // value is not required but should be the same to avoid
    // confusing routers keeping track of SAPs...

    pipxaddr->sa_socket = htons(34280);

    // Fill in the service info structure.

    memset(&info, 0, sizeof(info));

    info.dwSize                     = sizeof(info);
    info.lpszServiceInstanceName    = buffer;
    info.lpServiceClassId           = (GUID *)&RPC_SAP_SERVICE_TYPE;
    info.lpszComment                = L"RPC Services";
    info.dwNameSpace                = NS_SAP;
    info.dwNumberOfCsAddrs          = 1;
    info.lpcsaBuffer                = &addresses;

    addresses.LocalAddr.iSockaddrLength = sizeof(SOCKADDR_IPX);
    addresses.LocalAddr.lpSockaddr = (LPSOCKADDR) pipxaddr;
    addresses.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR_IPX);
    addresses.RemoteAddr.lpSockaddr = (LPSOCKADDR) pipxaddr;
    addresses.iSocketType = AF_IPX;
    addresses.iProtocol = NSPROTO_IPX;

    status = WSASetService(&info,
                           fRegister ? RNRSERVICE_REGISTER : RNRSERVICE_DEREGISTER,
                           0);

    ASSERT(status == SOCKET_ERROR || status == 0);
    if (status == SOCKET_ERROR)
        {
        status = GetLastError();
        }

    if (status == 0)
        {
        if (fRegister)
            {
            SapState = SapStateEnabled;
            }
        else
            {
            SapState = SapStateDisabled;
            }
        }
    else
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: WSASetService(%s) failed %d\n",
                   fRegister ? "ENABLE" : "DISABLE",
                   status));
        }
    return;
}

#endif

extern void
DealWithDeviceEvent();


void RPC_ENTRY
UpdateAddresses( PVOID arg )
{
    // Calls to this function are serialized
    DealWithDeviceEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\winsta.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       winsta.cxx
//
//  Contents:   winstation caching code
//
//--------------------------------------------------------------------------

#include "act.hxx"


//
// Private Types.
//

//-------------------------------------------------------------------------
// Definitions for Runas Cache
// NOTE: This exists to overcome limitation on NT Winstations of 15
//       Reusing same token will map to same winstation. We also cache
//       winstation once we get it.
//-------------------------------------------------------------------------
const DWORD RUN_AS_TIMEOUT = 360000;

#define RUNAS_CACHE_SIZE 200

// The pUser and pGroups fields are assumed to point to one contiguous memory
// block that can be freed by a single call to Free(pUser).
WCHAR wszRunAsWinstaDesktop[RUNAS_CACHE_SIZE][100];
typedef struct SRunAsCache
{
    HANDLE              hToken;
    WCHAR                *pwszWinstaDesktop;
    WCHAR                *pwszWDStore;
    LONG                dwRefCount;
    DWORD               lHash;
    TOKEN_USER         *pUser;
    TOKEN_GROUPS       *pGroups;
    TOKEN_GROUPS       *pRestrictions;
    DWORD               lBirth;
    struct SRunAsCache *pNext;
    SRunAsCache()
    {
        hToken = NULL;
        pwszWinstaDesktop = NULL;
        pwszWDStore = NULL;
        dwRefCount = 0;
        lHash = 0;
        pUser = NULL;
        pGroups = NULL;
        pRestrictions = NULL;
        lBirth = 0;
        pNext = NULL;
    }
} SRunAsCache;


#define RUNAS_CACHECTRL_CREATENOTFOUND  1
#define RUNAS_CACHECTRL_REFERENCE       2
#define RUNAS_CACHECTRL_GETTOKEN        4

//Macro to invalidate an entry -- must be idempotent
#define INVALIDATE_RUNAS_ENTRY(pEntry) pEntry->lHash = 0

// Lock for LogonUser cache.
CRITICAL_SECTION gTokenCS;

// The run as cache is an array of entries divided into 2 circular lists.
// The gRunAsHead list contains cache entries in use with the most
// frequently used entries first.  The gRunAsFree list  contains free
// entries.
extern SRunAsCache gRunAsFree;

static SRunAsCache gRunAsCache[RUNAS_CACHE_SIZE];

SRunAsCache gRunAsHead;
SRunAsCache gRunAsFree;


//+-------------------------------------------------------------------------
//
//  Function: InitRunAsCache
//
//  Synopsis:       One time initialization of runas cache
//
//+-------------------------------------------------------------------------
void InitRunAsCache()
{
    for (int i=0; i < (RUNAS_CACHE_SIZE-1); i++)
    {
        gRunAsCache[i].pNext = &gRunAsCache[i+1];
        gRunAsCache[i].pwszWDStore = &wszRunAsWinstaDesktop[i][0];
    }

    gRunAsCache[i].pNext = &gRunAsFree;
    gRunAsCache[i].pwszWDStore = &wszRunAsWinstaDesktop[i][0];

    gRunAsHead.pNext = &gRunAsHead;
    gRunAsFree.pNext = &gRunAsCache[0];
}

//+-------------------------------------------------------------------------
//
//  Function:       HashSid
//
//  Synopsis:       Compute a DWORD hash for a SID.
//
//--------------------------------------------------------------------------
DWORD HashSid( PSID pVoid )
{
    SID *pSID   = (SID *) pVoid;
    DWORD lHash = 0;
    DWORD i;

    // Hash the identifier authority.
    for (i = 0; i < 6; i++)
        lHash ^= pSID->IdentifierAuthority.Value[i];

    // Hash the sub authority.
    for (i = 0; i < pSID->SubAuthorityCount; i++)
        lHash ^= pSID->SubAuthority[i];
    return lHash;
}

//+-------------------------------------------------------------------------
//
//  Function:       RunAsCache
//
//  Synopsis:       Return a token from the cache if present.  Otherwise
//                  return the original token.
//
//  Description:    This function caches LogonUser tokens because each
//                  token has its own windowstation.  Since there are
//                  a limited number of windowstations, by caching tokens
//                  we can reduce the number of windowstations used and thus
//                  allow more servers to be created.  The cache moves the
//                  most frequently used tokens to the head of the list and
//                  discards tokens from the end of the list when full.
//                  When the cache is full, alternating requests for different
//                  tokens will prevent the last token from having a chance
//                  to advance in the list.
//                  [vinaykr - 9/1/98]
//                  Token caching alone is not enough because Tokens time out.
//                  So we cache winstations and reference count them to 
//                  ensure proper allocation to a window station.
//
//  Notes:          Tokens in the cache must be timed out so that changes to
//                  the user name, user groups, user privileges, and user
//                  password take effect.  The timeout must be balanced
//                  between the need to cache as many tokens as possible and
//                  the fact that cached tokens are useless when the password
//                  changes.
//                  [vinaykr - 9/1/98]
//                  Time out removed in favour of reference counting.
//                  Entry cleaned up when reference count goes to 0.
//--------------------------------------------------------------------------
HRESULT RunAsCache(IN DWORD dwCacheCtrl,
                   IN HANDLE &hToken,
                   OUT SRunAsCache** ppRunAsCache)
{
    HRESULT       hr = S_OK;
    BOOL          fSuccess;
    DWORD         cbUser         = 0;
    DWORD         cbGroups       = 0;
    DWORD         cbRestrictions = 0;
    TOKEN_USER   *pUser          = NULL;
    TOKEN_GROUPS *pGroups;
    TOKEN_GROUPS *pRestrictions;
    DWORD         lHash;
    DWORD         i;
    HANDLE        hCopy = NULL;
    DWORD         lNow;
    SRunAsCache  *pCurr = NULL;
    SRunAsCache  *pPrev;
    SRunAsCache   sSwap;
	
    *ppRunAsCache = NULL;

    // Find out how large the user SID is.
    GetTokenInformation( hToken, TokenUser, NULL, 0, &cbUser );
    if (cbUser == 0) { hr = E_UNEXPECTED; goto Cleanup; }

    // Find out how large the group SIDs are.
    GetTokenInformation( hToken, TokenGroups, NULL, 0, &cbGroups );

    // Find out how large the restricted SIDs are.
    GetTokenInformation( hToken, TokenRestrictedSids, NULL, 0, &cbRestrictions );

    // Allocate memory to hold the SIDs.
    cbUser        = (cbUser + 7) & ~7;
    cbGroups      = (cbGroups + 7) & ~7;
    pUser         = (TOKEN_USER *) PrivMemAlloc( cbUser + cbGroups + cbRestrictions );
    pGroups       = (TOKEN_GROUPS *) (((BYTE *) pUser) + cbUser);
    pRestrictions = (TOKEN_GROUPS *) (((BYTE *) pGroups) + cbGroups);
    if (pUser == NULL) { hr = E_OUTOFMEMORY; goto Cleanup; }

    // Get the user SID.
    fSuccess = GetTokenInformation( hToken, TokenUser, pUser, cbUser, &cbUser );
    if (!fSuccess) { hr = HRESULT_FROM_WIN32(GetLastError()); goto Cleanup; }

    // Get the group SIDs.
    fSuccess = GetTokenInformation( hToken, TokenGroups, pGroups, cbGroups, &cbGroups );
    if (!fSuccess) { hr = HRESULT_FROM_WIN32(GetLastError()); goto Cleanup; }

    // Get the restricted SIDs.
    fSuccess = GetTokenInformation( hToken, TokenRestrictedSids, pRestrictions,
                                    cbRestrictions, &cbRestrictions );
    if (!fSuccess) { hr = HRESULT_FROM_WIN32(GetLastError()); goto Cleanup; }

    // Get the SID hash but skip the logon group that is unique for every
    // call to logon user.
    lHash = HashSid( pUser->User.Sid );
    for (i = 0; i < pGroups->GroupCount; i++)
        if ((pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) == 0)
            lHash ^= HashSid( pGroups->Groups[i].Sid );
    for (i = 0; i < pRestrictions->GroupCount; i++)
        lHash ^= HashSid( pRestrictions->Groups[i].Sid );

    // Take lock.
    EnterCriticalSection( &gTokenCS );

    // Look for an existing token.
    lNow  = GetTickCount();
    pPrev = &gRunAsHead;
    pCurr = pPrev->pNext;
    while (pPrev->pNext != &gRunAsHead)
    {
        // If the current entry is too old, delete it.
        //    (lNow - pCurr->lBirth >= RUN_AS_TIMEOUT))
        // [vinaykr 9/1] Changed to use refcount
        // If refcount is 0 delete entry
        if (!pCurr->dwRefCount)
        {
            CloseHandle( pCurr->hToken );
            PrivMemFree( pCurr->pUser );
            pPrev->pNext = pCurr->pNext;
            pCurr->pNext = gRunAsFree.pNext;
            gRunAsFree.pNext = pCurr;
        }
        else
        {
            // If the current entry matches, break.
            if (pCurr->lHash == lHash &&
                pCurr->pGroups->GroupCount == pGroups->GroupCount)
            {
                // Check the user SID.
                if (EqualSid(pCurr->pUser->User.Sid, pUser->User.Sid))
                {
                    // Check the group SIDs.
                    for (i = 0; i < pGroups->GroupCount; i++)
                        if ((pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) == 0)
                            if (!EqualSid( pCurr->pGroups->Groups[i].Sid,
                                           pGroups->Groups[i].Sid ))
                                break;

                    // If those matched, check the restricted SIDs
                    if (i >= pGroups->GroupCount)
                    {
                        for (i = 0; i < pRestrictions->GroupCount; i++)
                            if (!EqualSid( pCurr->pRestrictions->Groups[i].Sid,
                                           pRestrictions->Groups[i].Sid ))
                                    break;

                        if (i >= pRestrictions->GroupCount)
                            break;
                    }
                }
            }
            pPrev = pPrev->pNext;
        }
        pCurr = pPrev->pNext;
    }

    
    fSuccess = (pCurr != &gRunAsHead);

    // Found a token
    if (fSuccess)
    {
        // Duplicate this token if token requested
        if (dwCacheCtrl & RUNAS_CACHECTRL_GETTOKEN)
        {
            fSuccess = DuplicateTokenEx( pCurr->hToken, MAXIMUM_ALLOWED,
                                     NULL, SecurityDelegation, TokenPrimary,
                                     &hCopy );
        }

        if (fSuccess)
        {
            // Discard the passed in token and return a copy of the cached
            // token.
            CloseHandle( hToken );
            hToken = hCopy;
        }
    }

    // If not found, find an empty slot only if we are trying to 
    // set into this.  Note this can also be taken if unable to 
    // duplicate found token above.
    if ((!fSuccess) &&
        (dwCacheCtrl & RUNAS_CACHECTRL_CREATENOTFOUND))
    {
        // Duplicate this token.
        fSuccess = DuplicateTokenEx( hToken, MAXIMUM_ALLOWED, NULL,
                                     SecurityDelegation, TokenPrimary, &hCopy );

        if (fSuccess)
        {
            // Get an entry from the free list.
            if (gRunAsFree.pNext != &gRunAsFree)
            {
                pCurr            = gRunAsFree.pNext;
                gRunAsFree.pNext = pCurr->pNext;
                pCurr->pNext     = &gRunAsHead;
                pPrev->pNext     = pCurr;
            }

            // If no empty slot, release the last used entry.
            else
            {
                pCurr = pPrev;
                CloseHandle( pCurr->hToken );
                PrivMemFree( pCurr->pUser );
            }

            // Save the duplicate.
            pCurr->hToken        = hCopy;
            pCurr->lHash         = lHash;
            pCurr->pUser         = pUser;
            pCurr->pGroups       = pGroups;
            pCurr->pRestrictions = pRestrictions;
            pCurr->lBirth        = lNow;
            pCurr->dwRefCount    = 0;
            pCurr->pwszWinstaDesktop = NULL;
            pUser                = NULL;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    // If an entry was computed and a reference
    // to it was requested, refcount it.
    if (fSuccess)
    {
        if (dwCacheCtrl & RUNAS_CACHECTRL_REFERENCE)
            pCurr->dwRefCount++;
    }

    // Release lock.
    LeaveCriticalSection( &gTokenCS );

    // Free any resources allocated by the function.
Cleanup:
    if (pUser != NULL)
        PrivMemFree(pUser);

    if (SUCCEEDED(hr))
    {
        ASSERT(pCurr);
        *ppRunAsCache = pCurr;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//+
//+ Function: RunAsGetTokenElem
//+
//+ Synopsis: Gets token and/or Winstationdesktop string given a token 
//+           Assumption is that if an entry is found in the cache a handle
//+           to the entry is returned with a reference being taken on the
//+           entry. This handle can then be used for other operations and
//+           needs to be explicitly released to release the entry.
//+
//+-------------------------------------------------------------------------
HRESULT RunAsGetTokenElem(IN OUT HANDLE *pToken, 
                         OUT void **ppvElemHandle)
{
    HRESULT hr;
    SRunAsCache* pElem = NULL;

    *ppvElemHandle = NULL;

    hr = RunAsCache(RUNAS_CACHECTRL_REFERENCE |
                    RUNAS_CACHECTRL_GETTOKEN |
                    RUNAS_CACHECTRL_CREATENOTFOUND,
                    *pToken,
                    &pElem);
    if (SUCCEEDED(hr))
    {
        *ppvElemHandle = (void*)pElem;
    }
    
    return hr;
}


//+-------------------------------------------------------------------------
//+
//+ Function:   RunAsSetWinstaDesktop
//+
//+ Synopsis:   Given a handle to an entry, sets the desktop string
//+             Assumption is that entry is referenced and therefore
//+             a valid one.
//+
//+-------------------------------------------------------------------------
void RunAsSetWinstaDesktop(void *pvElemHandle, WCHAR *pwszWinstaDesktop)
{
    if (!pvElemHandle)
        return;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;
    ASSERT( (!pElem->pwszWinstaDesktop) ||
                (lstrcmpW(pElem->pwszWinstaDesktop, pwszWinstaDesktop) 
                ==0) );
    if (!pElem->pwszWinstaDesktop)
    {
        lstrcpyW(pElem->pwszWDStore, pwszWinstaDesktop);
        pElem->pwszWinstaDesktop = pElem->pwszWDStore;
    }
}

//+-------------------------------------------------------------------------
//+
//+ Function:   RunAsRelease
//+
//+ Synopsis:   Given a handle to an entry, releases reference on it
//+             Assumption is that entry is referenced and therefore
//+             a valid one.
//+
//+-------------------------------------------------------------------------
void RunAsRelease(void *pvElemHandle)
{
    if (!pvElemHandle)
        return;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;

    // When refcount goes to 0 allow lazy clean up based on token
    // time out

    // Take lock.
    EnterCriticalSection( &gTokenCS );

    if ((--pElem->dwRefCount) == 0)
    {
        INVALIDATE_RUNAS_ENTRY(pElem);
    }

    LeaveCriticalSection( &gTokenCS );
    // Release lock.
}

//+-------------------------------------------------------------------------
//+
//+ Function:   RunAsInvalidateAndRelease
//+
//+ Synopsis:   Given a handle to an entry, invalidates it and releases 
//+             reference on it in response to some error.
//+             Assumption is that entry is referenced and therefore
//+             a valid one.
//+
//+-------------------------------------------------------------------------
void RunAsInvalidateAndRelease(void *pvElemHandle)
{
    if (!pvElemHandle)
        return;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;

    // Take lock.
    EnterCriticalSection( &gTokenCS );

    INVALIDATE_RUNAS_ENTRY(pElem);

    // Release lock.
    LeaveCriticalSection( &gTokenCS );

    RunAsRelease(pvElemHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\olescm\surrogat.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    surrogat.cxx

Abstract:


Author:


Revision History:

--*/

#include "act.hxx"

CSurrogateList * gpSurrogateList;

//
// CSurrogateList
//

CSurrogateListEntry *
CSurrogateList::Lookup(
    IN  CToken *                pToken,
    IN  BOOL                    bRemoteActivation,
    IN  BOOL                    bClientImpersonating,
    IN  WCHAR *                 pwszWinstaDesktop,
    IN  WCHAR *                 pwszAppid
    )
{
    CSurrogateListEntry * pEntry;

    gpClassLock->LockShared();

    for ( pEntry = (CSurrogateListEntry *) First();
          pEntry;
          pEntry = (CSurrogateListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match(pToken, 
			               bRemoteActivation, 
						   bClientImpersonating,
						   pwszWinstaDesktop,
						   pwszAppid ) )
        {
            pEntry->Reference();
            break;
        }
    }

    gpClassLock->UnlockShared();

    return pEntry;
}

CSurrogateListEntry *
CSurrogateList::Lookup(
    IN  const CProcess * pProcess
    )
{
    CSurrogateListEntry * pEntry;

    gpClassLock->LockShared();

    for ( pEntry = (CSurrogateListEntry *) First();
          pEntry;
          pEntry = (CSurrogateListEntry *) pEntry->Next() )
    {
        if ( pEntry->Process() == pProcess )
            break;
    }

    gpClassLock->UnlockShared();

    return pEntry;
}

void
CSurrogateList::Insert(
    IN  CSurrogateListEntry *  pSurrogateListEntry
    )
{
    CSurrogateListEntry *   pEntry;
    CProcess *              pProcess;

    pProcess = pSurrogateListEntry->Process();

    gpClassLock->LockShared();

    for ( pEntry = (CSurrogateListEntry *) First();
          pEntry;
          pEntry = (CSurrogateListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match( pProcess->GetToken(), 
			                FALSE, 
							FALSE, 
							pProcess->WinstaDesktop(), 
							pSurrogateListEntry->_wszAppid ) )
        {
            pSurrogateListEntry->Release();
            pSurrogateListEntry = 0;
            break;
        }
    }

    if ( pSurrogateListEntry )
        CList::Insert( pSurrogateListEntry );

    gpClassLock->UnlockShared();
}


BOOL
CSurrogateList::InList(
    IN  CSurrogateListEntry *   pSurrogateListEntry
    )
{
    CListElement * pEntry;

    for ( pEntry = First(); pEntry; pEntry = pEntry->Next() )
        if ( pEntry == (CListElement *) pSurrogateListEntry )
            return TRUE;

    return FALSE;
}

BOOL 
CSurrogateList::RemoveMatchingEntry(
    IN CServerListEntry* pServerListEntry
    )
{
    BOOL fRemoved = FALSE;
    CListElement* pEntry = NULL;
    CSurrogateListEntry* pSurrogateListEntry = NULL;

    gpClassLock->LockExclusive();

    for (pEntry = First(); pEntry; pEntry = pEntry->Next())
    {
        
        pSurrogateListEntry = (CSurrogateListEntry*)pEntry;
        if (pSurrogateListEntry->_pServerListEntry == pServerListEntry)
        {
            // found matching surrogate entry; remove it
            gpSurrogateList->Remove(pSurrogateListEntry);
            fRemoved = TRUE;
            break;
        }       
    }

    gpClassLock->UnlockExclusive();

    if (fRemoved)
        pSurrogateListEntry->Release();

    return fRemoved;
}


//
// CSurrogateListEntry
//

CSurrogateListEntry::CSurrogateListEntry(
    IN  WCHAR *             pwszAppid,
    IN  CServerListEntry *  pServerListEntry
    )
{
    pServerListEntry->Reference();
    _pServerListEntry = pServerListEntry;
    lstrcpyW( _wszAppid, pwszAppid );
}

CSurrogateListEntry::~CSurrogateListEntry()
{
    _pServerListEntry->Release();
}

BOOL
CSurrogateListEntry::Match(
    IN  CToken *    pToken,
    IN  BOOL        bRemoteActivation,
	IN  BOOL        bClientImpersonating,
    IN  WCHAR *     pwszWinstaDesktop,
    IN  WCHAR *     pwszAppid
    )
{
    if ( lstrcmpW( pwszAppid, _wszAppid ) != 0 )
        return FALSE;

    return _pServerListEntry->Match( pToken, 
		                             bRemoteActivation, 
									 bClientImpersonating, 
									 pwszWinstaDesktop, 
									 TRUE );
}

BOOL
CSurrogateListEntry::LoadDll(
    IN  ACTIVATION_PARAMS * pActParams,
    OUT HRESULT *           phr
    )
{
    DWORD           BusyRetries;
    HRESULT         hr;
    BOOL            bRemove;
    HANDLE          hBinding;
    error_status_t  status;

    hBinding = _pServerListEntry->RpcHandle();
    if (!hBinding)
        return FALSE;

    ASSERT(pActParams->pToken);
    pActParams->pToken->Impersonate();

    BusyRetries = 0;

    do
    {
        hr = ObjectServerLoadDll(
                hBinding,
                pActParams->ORPCthis,
                pActParams->Localthis,
                pActParams->ORPCthat,
                &pActParams->Clsid,
                &status );
    } while ( (RPC_S_SERVER_TOO_BUSY == status) &&
              (BusyRetries++ < 5) );

    pActParams->pToken->Revert();

    if ( (status != RPC_S_OK) || (CO_E_SERVER_STOPPING == hr) )
    {
        gpClassLock->LockExclusive();

        bRemove = gpSurrogateList->InList( this );
        if ( bRemove )
            gpSurrogateList->Remove( this );

        gpClassLock->UnlockExclusive();

        if ( bRemove )
            Release();

        return FALSE;
    }

    *phr = hr;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dll\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dcomss\wrapper\start.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Start.c

Abstract:

    Process init and service controller interaction for dcomss.exe

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo    06-14-95    Cloned from the old endpoint mapper.
    MazharM    10-12.98    Add pnp stuff
    TarunA     12-11-98    Removed pnpmngr.h
    a-sergiv   25-08-99    Defined gC2Security for process-wide use

--*/

//#define NCADG_MQ_ON

#if !defined(_M_IA64)
#define SPX_ON
#endif

//#define IPX_ON

#if !defined(SPX_ON) && !defined(IPX_ON)
#define SPX_IPX_OFF
#endif

#include <dcomss.h>
#include <debnot.h>
#include <olesem.hxx>
#include <wtypes.h>
#include <objbase.h>
#include <winioctl.h>
#include <ntddndis.h>
#include <ndispnp.h>
#include <dbt.h>
#include <initguid.h>
#include <ndisguid.h>
#include <ndispnp.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#define SAFEALLOCA_ASSERT ASSERT
#include <alloca.h>

#ifndef SPX_IPX_OFF
#include "sap.h"
#endif

#include "../../com/inc/secdes.hxx"
#include "../olescm/mach.hxx"
#include "tls.h"
#include "memapi.hxx"

extern LONG g_bInSCM;  // from catalog
C2Security  gC2Security;
// Array of service status blocks and pointers to service control
// functions for each component service.

#define SERVICE_NAME L"RPCSS"
#define DEVICE_PREFIX   L"\\\\.\\"

VOID WINAPI ServiceMain(DWORD, PWSTR[]);

extern BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
);
void NotifyCOMOnSuspend();
void NotifyCOMOnResume();

extern DWORD gLockTlsIdx;
SERVICE_TABLE_ENTRY gaServiceEntryTable[] = {
    { SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
    { NULL, NULL }
    };

static SERVICE_STATUS        gServiceStatus;
static SERVICE_STATUS_HANDLE ghServiceHandle;

GUID gProcessGuid = GUID_NULL;


#define OFFSET_TO_PTR(val, start)              \
    (val) = ((val) == NULL) ? NULL : (PWCHAR) ( (PCHAR)(val) + (ULONG_PTR)(start))

EXTERN_C const IID IID_IAssertConfig;  // make the linker happy

void
CookupNodeId(PUCHAR NodeId)
/*++

Routine Description:

    This routine is called when all else fails.  Here we mix a bunch of
    system parameters together for a 47bit node ID.

Arguments:

    NodeId - Will be set to a value unlikly to be duplicated on another
             machine. It is not guaranteed to be unique even on this machine.
             But since UUIDs are (time + sequence) this is okay for
             a local UUID.

             It will be composed of:
             The computer name.
             The value of the performance counter.
             The system memory status.
             The total bytes and free bytes on C:
             The stack pointer (value).
             An LUID (locally unique ID)
             Plus whatever random stuff was in the NodeId to begin with.

             The NodeId returned is explicity made into a Multicast IEEE 802
             address so that it will not conflict with a 'real' IEEE 802
             based UUID.
--*/
{
    unsigned char LocalNodeId[6];                            // NOT initialized.
    unsigned char ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL BoolResult;
    ULONG i = MAX_COMPUTERNAME_LENGTH+1;
    LARGE_INTEGER largeInt;
    LUID luid;
    ULONG UNALIGNED *NodeIdPart1 = (ULONG *)&LocalNodeId[0]; // Bytes 0 - 3
    ULONG UNALIGNED *NodeIdPart2 = (ULONG *)&LocalNodeId[2]; // Bytes 2 - 5
    MEMORYSTATUS memStatus;
    ULONG SectorsPerCluster;
    ULONG BytesPerSector;
    ULONG TotalClusters;
    ULONG FreeClusters;

    // Initialize the LocalNodeId.  Seventeen is the most random, random number.

    memset(LocalNodeId, 17, sizeof(LocalNodeId));

    // The computer name is xor'ed in until it runs out.

    BoolResult =
    GetComputerNameA((CHAR *)ComputerName, &i);

    if (BoolResult)
        {
        unsigned char *p = ComputerName;
        i = 0;
        while(*p)
            {
            *( ((unsigned char *)LocalNodeId) + i) ^= *p++;
            if (++i > 6)
                {
                i = 0;
                }
            }
        }
    else
        {
        #if DBG
        DbgPrint ("GetComputerName failed - %d\n", GetLastError());
        #endif
        }

    // The performance counter is xor'ed into the LocalNodeId.

    BoolResult =
    QueryPerformanceCounter(&largeInt);

    if (BoolResult)
        {
        *NodeIdPart2 ^= largeInt.HighPart ^ largeInt.LowPart;
        *NodeIdPart1 ^= largeInt.HighPart ^ largeInt.LowPart;
        }
    else
        {
        #if DBG
        DbgPrint ("QueryPreformanceCount failed - %d\n", GetLastError());
        #endif
        }

    // The current SP is xor'ed into both parts of the LocalNodeId.

    *NodeIdPart1 ^= (ULONG_PTR)&LocalNodeId;
    *NodeIdPart2 ^= (ULONG_PTR)&LocalNodeId;

    // The memory status is Xor's into the LocalNodeId.
    memStatus.dwLength = sizeof(MEMORYSTATUS);

    GlobalMemoryStatus(&memStatus);

    *NodeIdPart1 ^= memStatus.dwMemoryLoad;
    *NodeIdPart2 ^= memStatus.dwTotalPhys;
    *NodeIdPart1 ^= memStatus.dwAvailPhys;
    *NodeIdPart1 ^= memStatus.dwTotalPageFile;
    *NodeIdPart2 ^= memStatus.dwAvailPageFile;
    *NodeIdPart2 ^= memStatus.dwTotalVirtual;
    *NodeIdPart1 ^= memStatus.dwAvailVirtual;

    // LUID's are good on this machine during this boot only.

    BoolResult =
    AllocateLocallyUniqueId(&luid);

    if (BoolResult)
        {
        *NodeIdPart1 ^= luid.LowPart;
        *NodeIdPart2 ^= luid.HighPart;
        }
    else
        {
        #if DBG
        DbgPrint ("Status %d\n", GetLastError());
        #endif
        }

    // Disk parameters and free space

    BoolResult =
    GetDiskFreeSpaceA("c:\\",
                      &SectorsPerCluster,
                      &BytesPerSector,
                      &FreeClusters,
                      &TotalClusters
                     );

    if (BoolResult)
        {
        *NodeIdPart2 ^= TotalClusters * SectorsPerCluster * BytesPerSector;
        *NodeIdPart1 ^= FreeClusters * SectorsPerCluster * BytesPerSector;
        }
    else
        {
        #if DBG
        DbgPrint ("GetDiskFreeSpace failed - %d\n", GetLastError());
        #endif
        }

    // Or in the 'multicast' bit to distinguish this NodeId
    // from all other possible IEEE 802 addresses.

    LocalNodeId[0] |= 0x80;

    memcpy(NodeId, LocalNodeId, 6);
}

BOOLEAN
getMacAddress (
    PUCHAR pMacAddress
    )
/*++
Function Name:getMacAddress

Parameters:

Description:

Returns:

--*/
{
    int i;
    UINT fStatus;
    int Size = 1024*5;
    PNDIS_ENUM_INTF Interfaces;
    UCHAR       OidVendData[16];

    Interfaces = (PNDIS_ENUM_INTF) I_RpcAllocate (Size);
    if (Interfaces == 0)
        {
        return FALSE;
        }

    if (NdisEnumerateInterfaces(Interfaces, Size))
        {
        UINT i;

        for (i = 0; i < Interfaces->TotalInterfaces; i++)
            {
            PUNICODE_STRING pDeviceName= &(Interfaces->Interface[i].DeviceName);
            UCHAR           PermMacAddr[6];

            fStatus = NdisQueryHwAddress(pDeviceName, pMacAddress, PermMacAddr, &OidVendData[0]);
            if (fStatus && (OidVendData[0] != 0xFF
                || OidVendData[1] != 0xFF
                || OidVendData[2] != 0xFF))
                {
                I_RpcFree (Interfaces);

                return TRUE;
                }
            }
        }

    I_RpcFree (Interfaces);

    return FALSE;
}


extern "C" void
DealWithDeviceEvent()
/*++
Function Name: DealWithDeviceEvent

Parameters:

Description:

Returns:

--*/
{
    UCHAR MacAddress[8];
    NTSTATUS NtStatus;

    if (getMacAddress(&MacAddress[0]))
        {
        NtStatus = NtSetUuidSeed((PCHAR) &MacAddress[0]);
        }
    else
        {
        CookupNodeId(&MacAddress[0]);

        ASSERT(MacAddress[0] & 0x80);

        NtStatus = NtSetUuidSeed((PCHAR) &MacAddress[0]);
        }

    if (!NT_SUCCESS(NtStatus))
        {
        #if DBG
        DbgPrint("NtSetUuidSeed failed\n", NtStatus);
        #endif
        }

#if !defined(SPX_IPX_OFF)
    UpdateSap( SAP_CTRL_UPDATE_ADDRESS );
#endif
}



void
DealWithPowerStatusEvent(DWORD dwEvent)
{
    switch (dwEvent)
    {
    //
    // First the events we care about
    // 
    case PBT_APMSUSPEND:             // System is suspending operation.
        NotifyCOMOnSuspend();
        break;

    case PBT_APMRESUMESUSPEND:       // Operation resuming after suspension.
        // This is the normal, user-initiated resume after a suspend.
        NotifyCOMOnResume();
        break;
    
    case PBT_APMRESUMEAUTOMATIC:     // Operation resuming automatically after event.
        // For our purposes this is a regular resume, since we don't have any
        // direct dialogue with the user.  Eg, wake-on-lan might cause this.
        NotifyCOMOnResume();
        break;

    case PBT_APMRESUMECRITICAL:      // Operation resuming after critical suspension. 
        // This means we're resuming w/o previously having had a suspend
        // notification.   May have lost state (ie, ping set timers may have
        // rundown).  Let's process the resume anyway, so that the ping set 
        // timers start from scratch (might save somebody from a transient app
        // error).
        NotifyCOMOnResume();
        break;

    //
    // And then the ones we don't care about.
    // 
    case PBT_APMBATTERYLOW:          // Battery power is low.
    case PBT_APMOEMEVENT:            // OEM-defined event occurred.
    case PBT_APMPOWERSTATUSCHANGE:   // Power status has changed.
	case PBT_APMQUERYSUSPEND:        // Request for permission to suspend.
    case PBT_APMQUERYSUSPENDFAILED:  // Suspension request denied. 
        break;

    default:
        ASSERT(!"Unexpected power event.  Check to see if we should be dealing with it somehow.");
        break;
    }

    return;
}


ULONG WINAPI
ServiceHandler(
    DWORD   dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData
    )
/*++

Routine Description:

    Lowest level callback from the service controller to
    cause this service to change our status.  (stop, start, pause, etc).

Arguments:

    opCode - One of the service "Controls" value.
            SERVICE_CONTROL_{STOP, PAUSE, CONTINUE, INTERROGATE, SHUTDOWN}.

Return Value:

    None

--*/
{
    switch(dwCode) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        default:
            #if DBG
            DbgPrint("%S: Unexpected service control message %d.\n", SERVICE_NAME, dwCode);
            #endif
            ASSERT(0);
            break;

        case SERVICE_CONTROL_INTERROGATE:
            // Service controller wants us to call SetServiceStatus.

            UpdateState(gServiceStatus.dwCurrentState);
            break ;

        case SERVICE_CONTROL_SHUTDOWN:
            // The machine is shutting down.  We'll be killed once we return.
            // Note, currently we don't register for these messages.
            break;

        case SERVICE_CONTROL_POWEREVENT:                        
            DealWithPowerStatusEvent(dwEventType);
            break;
        }

    return NO_ERROR;
}




VOID
UpdateState(
    DWORD dwNewState
    )
/*++

Routine Description:

    Updates this services state with the service controller.

Arguments:

    dwNewState - The next start for this service.  One of
            SERVICE_START_PENDING
            SERVICE_RUNNING

Return Value:

    None

--*/
{
    DWORD status = ERROR_SUCCESS;

    ASSERT( (dwNewState == SERVICE_RUNNING) ||
            (gServiceStatus.dwCurrentState != SERVICE_RUNNING) );

    switch (dwNewState)
        {

        case SERVICE_RUNNING:
        case SERVICE_STOPPED:
              gServiceStatus.dwCheckPoint = 0;
              gServiceStatus.dwWaitHint = 0;
              break;

        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
              ++gServiceStatus.dwCheckPoint;
              gServiceStatus.dwWaitHint = 30000L;
              break;

        default:
              ASSERT(0);
              status = ERROR_INVALID_SERVICE_CONTROL;
              break;
        }

   if (status == ERROR_SUCCESS)
       {
       gServiceStatus.dwCurrentState = dwNewState;
       if (!SetServiceStatus(ghServiceHandle, &gServiceStatus))
           {
           status  = GetLastError();
           }
       }

   #if DBG
   if (status != ERROR_SUCCESS)
       {
       DbgPrint("%S: Failed to update service state: %d\n", SERVICE_NAME, status);
       }
   #endif

   // We could return a status but how would we recover?  Ignore it, the
   // worst thing is that services will kill us and there's nothing
   // we can about it if this call fails.

   return;
}

    
VOID WINAPI
ServiceMain(
    DWORD argc,
    PWSTR argv[]
    )
/*++

Routine Description:

    Callback by the service controller when starting this service.

Arguments:

    argc - number of arguments, usually 1

    argv - argv[0] is the name of the service.
           argv[>0] are arguments passed to the service.

Return Value:

    None

--*/
{
    DWORD status = ERROR_SUCCESS;

    // COM needs power standby\resume events
    const DWORD RPCSS_CONTROLS = SERVICE_ACCEPT_POWEREVENT;

    //
    // Initialize SafeAlloca
    //
    SafeAllocaInitialize (
        (MAX_PATH + 3) * sizeof (WCHAR),    // alloca at most a MAX_PATH WCHAR buffer
        SAFEALLOCA_USE_DEFAULT,             // use default additional probe size
        NULL, NULL);                        // use default heap allocators

    // set the initial stack to 12K. This ensures enough commit
    // so that server threads don't need to extend their stacks
    RpcMgmtSetServerStackSize(3 * 4096);

    DealWithDeviceEvent();

    ASSERT(   (argc >= 1 && lstrcmpiW(argv[0], SERVICE_NAME) == 0)
           || (argc == 0 && argv == 0));

#if DBG==1

    // Note that we've completed running the static constructors
    ASSERT(g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);
    g_fDllState = DLL_STATE_NORMAL;

#endif

    // Create a secret guid for the process
    RPC_STATUS sc = UuidCreate (&gProcessGuid);
    if (sc != RPC_S_OK)
        return;

    // Initialize the mutex package
    status = RtlInitializeCriticalSection(&g_OleMutexCreationSem);
    if (!NT_SUCCESS(status))
        return;

    status = RtlInitializeCriticalSection(&g_OleGlobalLock);
    if (!NT_SUCCESS(status))
        return;

    // Init machine name object
    if (!gpMachineName->Initialize())
        return;
		
    // Initialize TLS
    gLockTlsIdx = TlsAlloc();
    if (gLockTlsIdx == -1)
        return;

    // Initialize catalog
    CatalogDllMain (NULL, DLL_PROCESS_ATTACH, NULL);

    // Tell catalog it's running in SCM
    g_bInSCM = TRUE;

    gServiceStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    gServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
    gServiceStatus.dwControlsAccepted        = RPCSS_CONTROLS;
    gServiceStatus.dwWin32ExitCode           = 0;
    gServiceStatus.dwServiceSpecificExitCode = 0;
    gServiceStatus.dwCheckPoint              = 0;
    gServiceStatus.dwWaitHint                = 3000L;

    ghServiceHandle = RegisterServiceCtrlHandlerEx(SERVICE_NAME,
                                                     ServiceHandler,
                                                     UIntToPtr(0xCAFECAFE) );

    if (0 == ghServiceHandle)
        {
        status = GetLastError();
        ASSERT(status != ERROR_SUCCESS);
        }

    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        }

    if (status == ERROR_SUCCESS)
        {
        // epts.c
        status = InitializeEndpointManager();
        }


    // Start Ep Mapper.
    if (status == ERROR_SUCCESS)
        {
        // ..\epmap\server.c
        UpdateState(SERVICE_START_PENDING);
        status = StartEndpointMapper();
        }

#ifdef NCADG_MQ_ON
    // Start MQ Manager Interface
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        status = StartMqManagement();
        }
#endif  // NCADG_MQ_ON
	
    // Do pre-listen olescm initialization
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        status = InitializeSCMBeforeListen();
        }

    // Start object resolver
    if (status == ERROR_SUCCESS)
        {
        // ..\objex\objex.cxx
        UpdateState(SERVICE_START_PENDING);
        status = StartObjectExporter();
        }

    // Start OLESCM
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        status = InitializeSCM();
        }

    // Start listening for RPC requests
    if (status == ERROR_SUCCESS)
        {
        status = RpcServerListen(1, 1234, TRUE);

        if (status == RPC_S_OK)
            {
            while (RpcMgmtIsServerListening(0) == RPC_S_NOT_LISTENING)
                {
                Sleep(100);
                }
            }
        }

    //
    // There is some initialization that must be done after we
    // have done the RpcServerListen.
    //
    if (status == ERROR_SUCCESS)
    {
        // ..\olescm\scmsvc.cxx
        UpdateState(SERVICE_START_PENDING);
        InitializeSCMAfterListen();
    }

    // Trim our working set - free space now at the cost of time later.
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_RUNNING);
        }
        
#ifdef DEBUGRPC
    if (status != ERROR_SUCCESS)
        {
        DbgPrint("RPCSS ServiceMain failed %d (%08x)\n", status, status);
        }
#endif
    NTSTATUS lsaStatus;
    if (status == ERROR_SUCCESS)
    {
       lsaStatus= ConnectToLsa();
       if (NT_SUCCESS(lsaStatus))
       {
	  lsaStatus = GetDefaultDomainName();
       }
    }
    if (status == ERROR_SUCCESS && NT_SUCCESS(lsaStatus))
        {
        ObjectExporterWorkerThread(0);
        ASSERT(0);
        }

    return;
}

void CleanupTLS()
{
    if(gLockTlsIdx == -1)
        return;

    LockEntry* pLockEntry = reinterpret_cast<LockEntry*>(TlsGetValue(gLockTlsIdx));
    TlsSetValue(gLockTlsIdx, 0);

    while(pLockEntry)
    {
        LockEntry* pNextLockEntry = pLockEntry->pNext;
        PrivMemFree(pLockEntry);
        pLockEntry = pNextLockEntry;
    }

    return;
}

extern "C" BOOL WINAPI DllMain(
HANDLE hInstance,
DWORD dwReason,
LPVOID lpvReserved)
{
    // Normally we would call CleanupTLS() and TlsFree()
    // from withing the DLL_PROCESS_DETACH case, but
    // since this is rpcss we should be running
    // until the machine shuts down.

    switch(dwReason)
    {
        case DLL_THREAD_DETACH:
            CleanupTLS();
            break;

        default:
            break;
    }

    return TRUE;
}

extern HRESULT PrivGetRPCSSInfo(REFCLSID rclsid, REFIID riid, void** pIntf);

extern "C"
{

STDAPI GetRPCSSInfo(REFCLSID rclsid, REFIID riid, void** ppv)
{
  return PrivGetRPCSSInfo(rclsid, riid, ppv);
};

STDAPI GetCatalogHelper(REFIID riid, void** ppv);
    
STDAPI CoGetComCatalog(REFIID riid, void** ppv)
{
    return GetCatalogHelper (riid, ppv);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dll\daytona\makefile.inc ===
$(O)\ole32p.def : ..\ole32.def
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /DPRIVATE /EP ..\ole32.def
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /DEXPORT_PRIVATE_API /Tc..\ole32.def > $@
$(CPPXX: =
)
<<NOKEEP

$(O)\ole32p.lib : $(O)\ole32p.def $(IMPLIB_DEPEND)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\ole32p.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dllhost\dllhst3g\assert.c ===
// HACKHACK - 

void _stdcall Win4AssertEx(char const * a, int b, char const * c)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dllhost\debug.cxx ===
//
// Debug.cpp -- COM+ Debugging Flags
//
// COM+ 1.0
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Jim Lyon, March 1998.
//  

#include <windows.h>
#include "debug.hxx"

#if DBG == 1

// The data returned by this module:
BOOL		DebugFlags::sm_fDebugBreakOnLaunchDllHost = FALSE;

DebugFlags 	DebugFlags::sm_singleton;		// the only object of this class


// Constructor: Its job is to initialize the static members of this class
DebugFlags::DebugFlags()
{
	HKEY hKey;

	if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\COM3\\Debug"), 0, KEY_READ, &hKey))
		return;			// no further initialization possible

	InitBoolean (hKey, TEXT("DebugBreakOnLaunchDllHost"), &sm_fDebugBreakOnLaunchDllHost);

	RegCloseKey (hKey);
}


// InitBoolean will initialize a boolean depending on a particular value in the registry.
// If the value starts with "Y" or "y", the boolean will be set to TRUE.
// If the value starts with "N" or "n", the boolean will be set to FALSE.
// If the value doesn't exist, or starts with anything else, the boolean will be unchanged.
void DebugFlags::InitBoolean (HKEY hKey, const TCHAR* tszValueName, BOOL* pf)
{
	TCHAR tszValue[20];
	unsigned long cbData = (sizeof tszValue) / (sizeof tszValue[0]);

	if (ERROR_SUCCESS != RegQueryValueEx (hKey, tszValueName, NULL, NULL, (BYTE*)tszValue, &cbData))
		return;

	if (((USHORT)tszValue[0] & 0xFFDF) == 'Y')
		*pf = TRUE;

	if (((USHORT)tszValue[0] & 0xFFDF) == 'N')
		*pf = FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\internal\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dllhost\surrogat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       surrogat.cxx
//
//  Contents:   Entry point for dll surrogate process
//
//  Synopsis:	this is the entry point for a surrogate process.  It must
//              perform the following tasks
//				1. Initialize OLE (multithreaded)
//              2. Create an object which implements ISurrogate, and register
//                 it with COM via CoRegisterSurrogateEx
//              3. Wait for all loaded dlls to be unloadable 
//              4. Uninitialize OLE
//
//  Functions:  WinMain
//              GetCommandLineArguments
//
//  History:    21-May-96 t-AdamE    Created
//				09-Apr-98 WilfR		 Modified for Unified Surrogate
//              07-Jul-01 EgidioS    Set env variable to load server flavor 
//                                   of URT when running in a server box.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "csrgt.hxx"
#include "surrogat.hxx"
#include "srgtdeb.hxx"

#include "debug.hxx"

DECLARE_INFOLEVEL(Surrogate); // debug only

// defined in unisrgt.idl (*.h)
STDAPI CoRegisterSurrogateEx( REFGUID rguidProcess, ISurrogate* pSurrogate );


int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    GUID 	   	guidProcessID;	// will hold the ProcessID of this surrogate
    CHAR 		rgargv[cCmdLineArguments][MAX_PATH + 1];
    LPSTR 		argv[] = {rgargv[iProcessIDArgument]};
	HRESULT hr;
	LPSTR 		pProcessID;
    WCHAR 		wszProcessID[MAX_GUIDSTR_LEN + 1];

#if DBG == 1
	// check registry flags to break on launch (for debug)
	if( DebugFlags::DebugBreakOnLaunchDllHost() )
	{
		DebugBreak();
	}
#endif
    // command line format should be:
    // New Style: (/ProcessID:<process guid>)
    // Old style: ({appid guid})
    if(GetCommandLineArguments(lpCmdLine, argv,cCmdLineArguments,MAX_PATH) < 1)
    {
		Win4Assert( !"GetCommandLineArguments failed" );
		return 0;
    }

    // First Try new Style 
	// separate the cmdline switch from the cmdline arg (at the ':')
	for( pProcessID = argv[iProcessIDArgument]; *pProcessID != 0; pProcessID++ )
	{
		// this will zap the colon
		if(*pProcessID == ':')
		{
			*pProcessID++ = '\0';
			break;
		}
	}

#if 0
	// verify that the cmdline switch is what we are looking for
	if((*pProcessID == 0) || 
			(lstrcmpiA(argv[iProcessIDArgument], szProcessIDSwitch) != 0))
	{
		Win4Assert( !"Couldn't find /ProcessID:" );
		return 0;
	} 
#else
	if((*pProcessID == 0) || 
			(lstrcmpiA(argv[iProcessIDArgument], szProcessIDSwitch) != 0))
        pProcessID = argv[iProcessIDArgument];
#endif

    // we need a unicode string in order to get a guid, so convert
    // the ansi clsid string to unicode
    if(!(MultiByteToWideChar(CP_ACP, 0, pProcessID, lstrlenA(pProcessID) + 1,
			     			 wszProcessID, MAX_GUIDSTR_LEN + 1)))
    {
		Win4Assert( !"MultiByteToWideChar failed" );
		return 0;
    }

    // convert the ProcessID from a string to a guid
    if(FAILED(CLSIDFromString(wszProcessID,&guidProcessID)))
    {
		Win4Assert( !"CLSIDFromString failed" );
		return 0;
    }

    if(FAILED(CoInitializeEx(NULL,COINIT_MULTITHREADED)))
    {
		Win4Assert( !"CoInitEx failed" );
		return 0;
    }

	// HACK: If Whistler server and above, force the process to use .NET mscorsvr.dll.
	//       For server apps. this version of the .NET runtime performs better.
	if (IsServerOS())
	{
		SetEnvironmentVariableW(L"ComPlus_BuildFlavor", L"SVR");
	}

    // Hand the thread to OLE for the duration
	hr = CoRegisterSurrogateEx(guidProcessID, NULL);

    CoUninitialize();

    // Because some of our threads don't exit cleanly, and can AV
    //  in those situations, we don't die gracefully.
    TerminateProcess(GetCurrentProcess(), 0);
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCommandLineArguments
//
//  Synopsis:   Parses a the application's command line into a format
//              similar to the
//              argv parameter of the entry point main for console apps
//              Spaces are the delimiters
//
//  Arguments:  [rgwszArgs] -- an array of pointers to allocated Unicode
//              buffers
//              [cMaxArgs] -- This is the size of the rgwszArgs array (the
//              maximum number of arguments the array can hold).  
//              [cMaxArgLen] -- The maximum size of each buffer
//
//  Returns:    if successful, the function returns the number of arguments
//              parsed from the command line.  If the length of any argument
//              exceeds cMaxArgLen, the function fails and returns 0.
//
//              The function quits parsing and returns as soon as either of
//              the following conditions is met:
//               1. It reaches the end of the string, or
//               2. It parses cMaxArgs arguments.
//
//  Notes:      does not work with quoted arguments
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
// REVIEW: when we had several commandline parameters this function was 
// justified, but now that the Surrogate has only one parameter, is all this
// really necessary?
int GetCommandLineArguments(LPSTR szCmdLine, LPSTR rgszArgs[], int cMaxArgs, int cMaxArgLen)
{
    int cchlen = lstrlenA(szCmdLine);
    int cArgsRetrieved = 0;
    int ichStart = 0;

    for(int ich = 0;ich < cchlen; ich++)
    {
		if(ichStart > cMaxArgLen)
		{
	    	return 0;
		}

		CHAR chcur = *(szCmdLine++);
		if(chcur == ' ')// REVIEW: no tab delimiting -- is this good?
		{
	    	if(ichStart)
	    	{
				rgszArgs[cArgsRetrieved++][ichStart] = '\0';
				ichStart = 0;

				if(cArgsRetrieved == cMaxArgs)
				{
					return cArgsRetrieved;
				}	

	    	}
		}
		else
		{
		    rgszArgs[cArgsRetrieved][ichStart++] = chcur;
		}
    }

    if(ichStart)
    {
		rgszArgs[cArgsRetrieved][ichStart] = '\0';
	    cArgsRetrieved++;
    }

    return cArgsRetrieved;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsServerOS
//
//  Synopsis:   Checks if we are running on a Whistler server machine. 
//
//  Arguments:  None.
//
//  Returns:    TRUE if Whistler server/advanced/datacenter.
//              FALSE otherwise.
//
//  Notes:      None.
//
//  History:    7-12-01   egidios   Created
//
//----------------------------------------------------------------------------
BOOL IsServerOS(void)
{
    // Note the following structure is only supported for NT 5.0
    OSVERSIONINFOEX osverex;
    osverex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (::GetVersionEx((OSVERSIONINFO*)&osverex))
    {
        if (osverex.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            if ((osverex.dwMajorVersion == 5 && osverex.dwMinorVersion >= 1) ||     // >= WinXP
                (osverex.dwMajorVersion > 5))									
            {
                if (osverex.wSuiteMask & VER_SUITE_PERSONAL)
                {
                    return FALSE;
                }
                else if (osverex.wProductType == VER_NT_WORKSTATION)
                {
					return FALSE;
				}
				else if (osverex.wProductType == VER_NT_SERVER)
                {
					return TRUE;
                }
                else if (osverex.wSuiteMask & VER_SUITE_ENTERPRISE)
                {
					return TRUE;
                }
                else if (osverex.wSuiteMask & VER_SUITE_DATACENTER)
                {
					return TRUE;
                }
			}
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\internal\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

# Paths
PUBLIC_IDL=..\..\public\

# Flags

MIDL_FLAGS= \
 $(MIDL_OPTIMIZATION) \
 -Zp8 \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -proxy nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 $(TARGET_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \

MES_MIDL_FLAGS= \
 -Oicf -no_format_opt -error all \
 -Zp8 -robust \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -proxy nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 $(TARGET_DEFINES) \
 -cpp_cmd $(TARGET_CPP)



SSWITCH=-prefix sstub _
CSWITCH=-prefix cstub _

# Targets

# only a header file generated
#$(O)\iface.h:  ..\iface.idl
#     $(MIDL) $(MIDL_FLAGS) -header $@ ..\iface.idl

# Local Resolver Interface for NT

$(O)\lclor.h:  ..\lclor.idl $(SDK_INC_PATH)\obase.idl ..\lclor.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -out $(O) -header lclor.h ..\lclor.idl

$(O)\orcb.h:  ..\orcb.idl $(SDK_INC_PATH)\obase.idl ..\orcb.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -out $(O) -header orcb.h ..\orcb.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server and the '_' prefixed client
$(O)\odeth.h : ..\odeth.idl ..\..\private\iface.idl ..\odeth.acf \
              $(SDK_INC_PATH)\obase.idl $(PUBLIC_IDL)\remunk.idl ..\comhndl.h
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header odeth.h \
        -client none -server none ..\odeth.idl

$(O)\rawodeth.h : ..\odeth.idl ..\..\private\iface.idl ..\odeth.acf \
                 $(SDK_INC_PATH)\obase.idl $(PUBLIC_IDL)\remunk.idl ..\comhndl.h
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header rawodeth.h \
        $(SSWITCH) -D RAW ..\odeth.idl

# only a header file generated
$(O)\irot.h:  ..\irot.idl ..\irot.acf
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\irot_c.c \
        -sstub $(O)\irot_s.c \
        -header $@ ..\irot.idl

# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\getif.h: ..\getif.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\getif_i.c \
        ..\getif.idl


# Only generate a header.  The object proxy and stub are made with
# mega.idl
!ifdef SERVER_HANDLER
$(O)\srvhdl.h: ..\srvhdl.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\srvhdl_i.c \
        ..\srvhdl.idl
!endif


# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\host.h: ..\host.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\host_i.c \
        ..\host.idl

# Only generate a header.  The object proxy and stub are made with
# mega.idl  --  this should be before actprops.idl
$(O)\custmact.h: ..\custmact.idl  ..\custmact.acf
     $(MIDL) $(MES_MIDL_FLAGS) \
        -cstub $(O)\custmact_c.c \
        -sstub $(O)\custmact_s.c \
        -header $@ \
        ..\custmact.idl


# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\serializ.h: ..\serializ.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\serializ_i.c \
        ..\serializ.idl

$(O)\buffer.h:  ..\buffer.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\buffer_i.c \
        ..\buffer.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server and the '_' prefixed client
$(O)\objsrv.h: ..\objsrv.idl ..\objsrv.acf
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -out $(O) -header objsrv.h \
        ..\objsrv.idl

$(O)\rwobjsrv.h: ..\objsrv.idl ..\objsrv.acf
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\objsrv_c.c \
        -server none -header $@ \
        -D RAW \
        ..\objsrv.idl

# COM+ surrogate protocol interface
$(O)\srgtprot.h: ..\srgtprot.idl ..\srgtprot.acf
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\srgtprot_c.c \
        -sstub $(O)\srgtprot_s.c \
        -header $@\
        ..\srgtprot.idl

# first MIDL invocation makes the server and the '_' prefixed client
# second MIDL invocation makes proxy for ole32.dll
$(O)\scm.h: ..\scm.idl ..\scm.acf
     $(MIDL) $(MIDL_FLAGS) \
        $(CSWITCH) \
        -cstub $(O)\scm_z.c \
        -sstub $(O)\scm_s.c \
        -header $@\
        ..\scm.idl

     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\scm_c.c \
        -server none -header $@ \
        ..\scm.idl

allidl:   $(O)\lclor.h $(O)\odeth.h $(O)\rawodeth.h $(O)\orcb.h \
          $(O)\irot.h $(O)\getif.h $(O)\host.h $(O)\objsrv.h $(O)\rwobjsrv.h  \
          $(O)\scm.h $(O)\custmact.h $(O)\serializ.h \
          $(O)\buffer.h $(O)\srgtprot.h
	
clean:
          -erase $(O)\*.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\internal\custmact_c_wrap.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       custmact_c_wrap.c
//
//  Contents:   Wrapper file
//
//  Functions:  Redefines MIDL_user_allocate\MIDL_user_free for the RPC 
//              functions defined in custmact.idl.
//
//  History:    24-Mar-01 JSimmons  Created
//
//--------------------------------------------------------------------------

#include <windows.h>

//--------------------------------------------------------------------------
//
// Why are we doing this?   We are doing this because RPC's pickling 
// functionality (encode, decode) has some issues when errors (typically
// out-of-mem) are encountered.  They do not guarantee the state of the
// out-params when encoding or decoding is ended prematurely.   One 
// suggestion was to modify MIDL_user_allocate to always zero out the 
// contents of any new allocation - this is undesirable from a perf 
// perspective, since it would impose a lot of unnecessary overhead
// for everybody.  Instead, we decided to overload alloc\free for 
// just those functions (encode\decode) that need it.   Our custom
// allocator will zero out any new memory allocations since RPC does
// not.  This will allow us to deterministically cleanup after any
// failed operations.   Fortunately all of the encode\decode functions
// are defined in one idl file, so this change is fairly localized.
//  
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   CUSTMACT_MIDL_user_allocate
//
//  Purpose:    allocates memory on behalf of midl-generated stubs.  The 
//              memory block is zeroed out before returning.
//
//--------------------------------------------------------------------------
void* __RPC_API CUSTMACT_MIDL_user_allocate(size_t cb)
{
    void* pv = MIDL_user_allocate(cb);
    if (pv)
    {
        ZeroMemory(pv, cb);
    }
    return pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   CUSTMACT_MIDL_user_free
//
//  Purpose:    frees memory allocated by CUSTMACT_MIDL_user_allocate
//
//--------------------------------------------------------------------------
void __RPC_API CUSTMACT_MIDL_user_free(void *pv)
{
    MIDL_user_free(pv);
}

//--------------------------------------------------------------------------
//
// Redefine MIDL_user_allocate and MIDL_user_free
//
// Note: Redefining MIDL_user_free is not strictly necessary since 
//   the regular MIDL_user_free would behave exactly the same as 
//   CUSTMACT_MIDL_user_free. I include it more for completeness 
//   than anything else.
//
//--------------------------------------------------------------------------
#define MIDL_user_allocate   CUSTMACT_MIDL_user_allocate
#define MIDL_user_free       CUSTMACT_MIDL_user_free

//--------------------------------------------------------------------------
// 
// Include the midl-generated code
// 
//--------------------------------------------------------------------------
#include "custmact_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\internal\comhndl.h ===
//+-------------------------------------------------------------------
//
//  File:	comhndl.h
//
//  Contents:	Implicit COM parameters on raw RPCcalls
//
//  History:	24 Apr 95   AlexMit	Created
//
//--------------------------------------------------------------------
#ifndef _COMHNDL_H_
#define _COMHNDL_H_

// Define the implicit COM RPC parameters.

#ifdef RAW
    #define COM_HANDLE \
    [in] handle_t rpc, \
    [in, ref] ORPCTHIS *orpcthis, \
    [in, ref] LOCALTHIS *localthis, \
    [out, ref] ORPCTHAT *orpcthat,
#else
    #define COM_HANDLE
#endif

// Define some extra stuff.

#ifdef DO_NO_IMPORTS
    #define IMPORT_OBASE
#else
    #define IMPORT_OBASE import "obase.idl";
#endif

#ifdef DO_NO_IMPORTS
    #define IMPORT_UNKNOWN
#else
    #define IMPORT_UNKNOWN import "unknwn.idl";
#endif

    // These dummy members adjust the procedure number.
    // Since these exist on the raw side, the names have to be
    // unique in all interfaces.
#ifdef RAW
    #define COM_DEFINES(X)                            \
    IMPORT_OBASE 				   \
    HRESULT DummyQueryInterface##X( COM_HANDLE [in] DWORD dummy ); \
    HRESULT DummyAddRef##X( COM_HANDLE [in] DWORD dummy ); \
    HRESULT DummyRelease##X( COM_HANDLE [in] DWORD dummy );
#else
    #define COM_DEFINES(X) IMPORT_UNKNOWN
#endif

#endif // _COMHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\dllhost\csrgt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       CSurrogate.cxx
//
//  Contents:   Class the implements the ISurrogate interface
//
//
//  History:    21-May-96 t-AdamE    Created
//				09-Apr-98 WilfR		 Updated for Unified Surrogate
//
//--------------------------------------------------------------------------

#include "csrgt.hxx"
#include "srgtdeb.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::~CSurrogate()
//
//  Synopsis:   destructor for CSurrogate
//
//  History:    4-09-98   WilfR   Created
//
//----------------------------------------------------------------------------
CSurrogate::~CSurrogate()
{
	if( _hEventSurrogateFree )
		CloseHandle( _hEventSurrogateFree );
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::Init()
//
//  Synopsis:   Initializes data structures with error results
//
//  History:    4-09-98   WilfR		Created
//
//----------------------------------------------------------------------------
BOOL CSurrogate::Init()
{
	// create the event to be signaled when we are freed
	return (_hEventSurrogateFree = 
			  CreateEvent(NULL,FALSE,FALSE,NULL)) != NULL ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::QueryInterface
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogate::QueryInterface(REFIID iid, LPVOID FAR * ppv)
{
    if (iid == IID_IUnknown)
    {
		*ppv = (void*)(IUnknown*)this;
		AddRef();
		return S_OK;
    }
    else if (iid == IID_ISurrogate)
    {
		*ppv = (void*)(ISurrogate*)this;
		AddRef();
		return S_OK;
    }

    return E_NOINTERFACE;

}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::AddRef()
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
ULONG CSurrogate::AddRef()
{
    InterlockedIncrement((LPLONG)&_cref);
    Win4Assert(_cref > 0);
    ULONG cref = _cref;	// NOTE: not thread safe but not worth worrying about
    return cref;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::Release()
//
//  Synopsis:   Decrements our Reference count -- note that this
//              implementation of ISurrogate does not delete the object
//              that implements it so that we can allocate it on the stack
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
ULONG CSurrogate::Release()
{
    Win4Assert(_cref >0);
    InterlockedDecrement((LPLONG)&_cref);
    ULONG cref = _cref; // NOTE: not thread safe but not worth worrying about
    return cref;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::LoadDllServer
//
//  Synopsis:   Loads information about the dll corresponding to the specified
//              clsid into our table of loaded dlls, which implicitly
//              loads the dll into the surrogate process
//
//  History:    6-21-96   t-Adame   Created
//				4-09-98	  WilfR		This is never called for the Unified 
//								    Surrogate
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogate::LoadDllServer( 
    /* [in] */ REFCLSID rclsid)
{
    SrgtDebugOut(DEB_SRGT_METHODCALL,"ISurrogate::LoadDllServer called\n",0);

	// TODO: I should probably put an assertion in here.
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::FreeSurrogate
//
//  Synopsis:   called by OLE when there are no external references to clients
//              of dll servers that were loaded by this object.  A call
//              to this function signals the surrogate process that it should
//              terminate
//
//  History:    6-21-96   t-Adame   Created
//				4-09-98	  WilfR		Modified for Unified Surrogate
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogate::FreeSurrogate()
{
    SrgtDebugOut(DEB_SRGT_METHODCALL,"ISurrogate::FreeSurrogate called\n",0);
    Win4Assert(_hEventSurrogateFree != NULL);

    return SetEvent(_hEventSurrogateFree) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::WaitForSurrogateFree
//
//  Synopsis:   sleep the main thread of the surrogate process until OLE
//              signals us via a call to FreeSurrogate that we should terminate.
//
//  History:    6-21-96   t-Adame   Created
//				4-09-98	  WilfR		Changed the name and implementation
//									for new Unified Surrogate. (implementation
//									was copied from 
//
//----------------------------------------------------------------------------
void CSurrogate::WaitForSurrogateFree()
{
    Win4Assert(_hEventSurrogateFree != NULL);

   	// wait for the FreeSurrogate method of ISurrogate to be called
   	// NOTE: in the previous incarnation of the surrogate we use to
   	// 		 timeout every 60 seconds to call CoFreeUnusedLibraries().
   	//       Since this was being done in the MTA and we do nothing to
   	//		 perform a similar tasks in the STAs we create its effectiveness
   	//		 is minimal.
   	
    WaitForSingleObject(_hEventSurrogateFree, INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\internal\oleprv.h ===
// oleprv.h - header files matching those needed by oleprv.idl
//

// internal interfaces used by DCOM
// this is private! (for now)

// NOTE: as entries are added to oleprv.idl, corresponding entries should
// be added here

#include "remunk.h"
#include "activate.h"
#include "catalog.h"
#include "objsrv.h"
#include "getif.h"

#ifdef SERVER_HANDLER
#include "srvhdl.h"
#endif

#include "odeth.h"
#include "host.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\private\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\public\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\internal\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

TARGETNAME= priidl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

MIDL_UUIDDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
MIDL_TLBDIR=$(O)
MIDL_PROTOCOL=dce

INCLUDES=     $(O);..\..\public;..\..\public\$(DEST_TREE)\$(O);..;$(SDK_INC_PATH);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\private;..\..\private\$(DEST_TREE)\$(O);..\..\private\$(DEST_TREE)\$(O)
C_DEFINES=$(C_DEFINES) /DUSE_COM_CONTEXT_DEF

SOURCES= \
              $(O)\serializ_i.c	\
              $(O)\buffer_i.c	\
              $(O)\lclor_c.c	\
              $(O)\lclor_s.c	\
              $(O)\odeth_c.c	\
              $(O)\orcb_c.c	\
              $(O)\orcb_s.c	\
              $(O)\getif_i.c	\
              $(O)\irot_c.c	\
              $(O)\srgtprot_c.c	\
              $(O)\scm_c.c	\
              custmact_c_wrap.c
	
UMTYPE=       windows

NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\private\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

# Paths

PUBLIC_IDL=..\..\public\

# Flags

MIDL_FLAGS= \
 $(MIDL_OPTIMIZATION) \
 -no_stamp \
 -Zp8 \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \

MES_MIDL_FLAGS= \
 -Oicf -no_format_opt -error all \
 -no_stamp \
 -Zp8 -robust \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP)



SSWITCH=-prefix sstub _
CSWITCH=-prefix cstub _

# Targets

# Dual (Raw/Object) local RPC interface for forwarding remote activation calls
# in DCOM95 -- RPCSS is the server

# first MIDL invocation makes the object header proxy and stub
# second MIDL invocation makes the client and the '_' prefixed server
# The client/server stubs for the object version are generated by mega.idl

# Only generate a header.
$(O)\iface.h:  ..\iface.idl
     $(MIDL) $(MIDL_FLAGS) -header $@ ..\iface.idl

$(O)\catalog.h: ..\catalog.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\catalog_i.c \
        ..\catalog.idl

$(O)\unisrgt.h: ..\unisrgt.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\unisrgt_i.c \
        ..\unisrgt.idl

# the object proxy and stub are made with mega.idl
$(O)\activate.h: ..\activate.idl
     $(MIDL) $(MES_MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\activate_i.c \
        ..\activate.idl

$(O)\partitions.h: ..\partitions.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\partitions_i.c \
        ..\partitions.idl

$(O)\stackwalk.h: ..\stackwalk.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\stackwalk_i.c \
        ..\stackwalk.idl

$(O)\machnames.h: ..\machnames.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\machnames_i.c \
        ..\machnames.idl

$(O)\globalopt.h: ..\globalopt.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\globalopt_i.c \
        ..\globalopt.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server
$(O)\privact.h: ..\privact.idl
     $(MIDL) $(MES_MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\privact_i.c \
        ..\privact.idl


$(O)\rawprivact.h: ..\privact.idl
     $(MIDL) $(MES_MIDL_FLAGS) \
        -cstub $(O)\rawprivact_c.c \
        -sstub $(O)\rawprivact_s.c \
        -header $@ \
        -D RAW \
        ..\privact.idl

$(O)\contxt.h: ..\contxt.idl
     $(MIDL)  $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\contxt_i.c \
        ..\contxt.idl

#We are running MIDL again here so we can overwrite
#the contxt_i.c that got created above.  We don't want
#the .h file so we delete it at the end.
     $(MIDL)  $(MIDL_FLAGS) \
        -client none -server none \
        -proxy nul \
        -D_OLE_PRVIDL_PASS_ \
        -iid $(O)\contxt_i.c \
        ..\contxt.idl

	del contxt.h

$(O)\asrtcfg.h: ..\asrtcfg.idl
     $(MIDL)  $(MIDL_FLAGS) \
         -client none -server none -header $@ \
         -proxy nul \
         -iid $(O)\asrtcfg_i.c \
          ..\asrtcfg.idl

allidl:   $(O)\iface.h $(O)\activate.h $(O)\contxt.h $(O)\privact.h $(O)\rawprivact.h $(O)\catalog.h \
	  $(O)\unisrgt.h $(O)\asrtcfg.h $(O)\partitions.h $(O)\stackwalk.h $(O)\machnames.h $(O)\globalopt.h

clean:
          -erase $(O)\*.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\private\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

TARGETNAME= prvidl
TARGETPATH= obj
TARGETTYPE= LIBRARY

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

PASS0_PUBLISH= \
	{..\activate.idl=$(PROJECT_INC_PATH)\activate.idl}\
	{$(O)\activate.h=$(PROJECT_INC_PATH)\activate.h}\
	{..\catalog.idl=$(PROJECT_INC_PATH)\catalog.idl}\
	{$(O)\catalog.h=$(PROJECT_INC_PATH)\catalog.h}\
	{..\contxt.idl=$(PROJECT_INC_PATH)\contxt.idl}\
	{$(O)\contxt.h=$(PROJECT_INC_PATH)\contxt.h}\
	{..\iface.idl=$(PROJECT_INC_PATH)\iface.idl}\
	{$(O)\iface.h=$(PROJECT_INC_PATH)\iface.h}\
	{..\machnames.idl=$(PROJECT_INC_PATH)\machnames.idl}\
	{$(O)\machnames.h=$(PROJECT_INC_PATH)\machnames.h}\
	{..\globalopt.idl=$(PROJECT_INC_PATH)\globalopt.idl}\
	{$(O)\globalopt.h=$(PROJECT_INC_PATH)\globalopt.h}\
	{..\partitions.idl=$(PROJECT_INC_PATH)\partitions.idl}\
	{$(O)\partitions.h=$(PROJECT_INC_PATH)\partitions.h}\
	{..\stackwalk.idl=$(PROJECT_INC_PATH)\stackwalk.idl}\
	{$(O)\stackwalk.h=$(PROJECT_INC_PATH)\stackwalk.h}\
	{..\privact.idl=$(PROJECT_INC_PATH)\privact.idl}\
	{$(O)\privact.h=$(PROJECT_INC_PATH)\privact.h}\
	{..\unisrgt.idl=$(PROJECT_INC_PATH)\unisrgt.idl}\
	{$(O)\unisrgt.h=$(PROJECT_INC_PATH)\unisrgt.h}

PASS1_PUBLISH= \
    {$(O)\prvidl.lib=$(PROJECT_LIB_PATH)\prvidl.lib}

MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)
MIDL_PROTOCOL=dce

INCLUDES=     obj;..\..\public;..\..\public\$(DEST_TREE)\obj;..\..\internal;..;$(SDK_INC_PATH);..\..\..\ih
_DEFINES=$(C_DEFINES) /DUSE_COM_CONTEXT_DEF

SOURCES= \
              $(O)\contxt_i.c \
              $(O)\unisrgt_i.c \
              $(O)\privact_i.c \
              $(O)\activate_i.c \
              $(O)\catalog_i.c  \
              $(O)\partitions_i.c \
              $(O)\stackwalk_i.c \
              $(O)\asrtcfg_i.c  \
              $(O)\machnames_i.c \
              $(O)\globalopt_i.c \
              privguid.c

UMTYPE=       windows

NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\public\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

MIDL_FLAGS= \
 $(MIDL_OPTIMIZATION) \
 -Zp8 \
 $(INCPATH0) \
 -oldnames \
 -char unsigned \
 -dlldata nul \
 -proxy nul \
 -out $(O)  \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) $(INCPATH0)

SSWITCH=-prefix sstub _

$(O)\dce.h:      ..\dce.idl
     $(MIDL) $(MIDL_FLAGS) -header dce.h  ..\dce.idl

#$(O)\obase.h:  ..\obase.idl
#     $(MIDL)  $(MIDL_FLAGS) -header obase.h ..\obase.idl

$(O)\objex.h:  ..\objex.idl $(SDK_INC_PATH)\obase.idl ..\objex.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -header objex.h ..\objex.idl

$(O)\remact.h : ..\remact.idl $(SDK_INC_PATH)\obase.idl ..\remact.acf
     $(MIDL) $(MIDL_FLAGS) -header remact.h \
        $(SSWITCH) ..\remact.idl

#$(O)\immact.h : ..\immact.idl ..\obase.idl
#     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -header immact.h ..\immact.idl

# only a header file generated
$(O)\remunk.h : ..\remunk.idl $(SDK_INC_PATH)\obase.idl
     $(MIDL) $(MIDL_FLAGS) -header remunk.h ..\remunk.idl

allidl:  $(O)\objex.h $(O)\remact.h $(O)\remunk.h

clean:
          -erase $(O)\*.h    >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\public\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

TARGETNAME= pubidl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)
MIDL_PROTOCOL=dce

MIDL_PROTOCOL=dce

INCLUDES= \
    $(O); \
    ..;\
    $(SDK_INC_PATH); \
    ..\..\..\ih; \


SOURCES= \
	      $(O)\objex_c.c  \
	      $(O)\objex_s.c  \
	      $(O)\remact_c.c \
	      $(O)\remact_s.c
	
UMTYPE=       windows

NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\idl\private\privguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:
//      privguid.c
//
//  Contents:
//      Definition of guids not defined elsewhere, or that are needed by
//    third-parties (eg COM+) via prvidl.lib.
//
//  History:
//              JSimmons    01-03-00        Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <initguid.h>

// Note:  these two guids are defined in ole32\ih\privguid.h.

// RPCSS's info object
DEFINE_OLEGUID(CLSID_RPCSSInfo,                     0x000003FF, 0, 0);

// Actpropsin clsid.
DEFINE_OLEGUID(CLSID_ActivationPropertiesIn,		0x00000338, 0, 0);

// ComActivator clsid
DEFINE_OLEGUID(CLSID_ComActivator,                  0x0000033c, 0, 0);

// Stackwalking
DEFINE_OLEGUID(CLSID_StackWalker,                   0x00000349, 0, 0);

// Local machine name comparisons
DEFINE_OLEGUID(CLSID_LocalMachineNames,             0x0000034a, 0, 0);

// Global options
DEFINE_OLEGUID(CLSID_GlobalOptions,             0x0000034b, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\debug.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		debug.h
//
//	Contents:
//		macros and declarations for debug support--all are appropriately
//		defined to nothing when not doing debug build
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - added file prologue; defined _DEBUG when
//			DBG==1; added "const" to ASSERTDATA macro
//
//-----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <debnot.h>

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#ifndef _CAIRO_
#include <ole2dbg.h>
#endif

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#define ASSERTDATA

#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, __FILE__, __LINE__))
#undef Puts
#define Puts(s) OutputDebugString(TEXT(s))

#else   //  !_DEBUG

#define ASSERTDATA
#define AssertSz(a, b) ((void)0)
#define Puts(s) ((void)0)

#endif  //  _DEBUG


// special Assert for asserts below (since the expression is so large)
// REVIEW, shouldn't these be in the debug.h file?
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, __FILE__, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(OLECHAR)) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutParam)

#define AssertOutPtrIface(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutIface)

#define AssertOutPtrFailed(p) \
	AssertOut((p) == NULL, \
	szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
	AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
	FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
	szBadOutStgm)


// assert data for above assert out macros; once per dll
// Note that since these are only used in asserts, we leave them as ANSI
#define ASSERTOUTDATA \
    char szCheckOutParam[] = "check out param"; \
    char szBadOutParam[] = "Out pointer param conventions not followed"; \
    char szBadOutIface[] = "Out pointer interface conventions not followed"; \
    char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
    char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
-
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    TCHAR ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#ifdef _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif // _DEBUG
#endif // NEVER
};

/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;

    #define CONSTRUCT_DEBUG m_Debug(this),

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif __cplusplus

#endif // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\dragopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	dragopt.h
//
//  Contents:   Intercomponent definitions to support the Drag/Drop optimization
//
//  Functions:
//
//  History:	dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    added PrivDragDrop
//              30-Sep-94 ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef _DRAGOPT_H

//+-------------------------------------------------------------------------
//
//  Function:   UnmarshalDragDataObject
//
//  Synopsis:   Handles unmarshaling of a marshaled data object
//
//  Arguments:  [pvMarshaledDataObject] - the marshaled buffer
//
//  Returns:    NULL - could not unmarshal
//              ~NULL - remote IDataObject
//
//  Algorithms: see com\rot\getif.cxx
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
IDataObject *UnmarshalDragDataObject(void *pvMarshaledDataObject);





//+-------------------------------------------------------------------------
//
//  Function:   CreateDragDataObject
//
//  Synopsis:   Handles unmarshaling of a marshaled data object
//
//  Arguments:  [pvMarshaledDataObject] - the marshaled buffer for data object
//              [dwSmId] - id of shared memory for formats.
//              [ppIDataObject] - where to put Drag data object
//
//  Returns:    NOERROR - created a data object
//              E_OUTOFMEMORY - could not allocate the Drag data object
//
//  Algorithms: see ole232\drag\ido.cpp
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CreateDragDataObject(
    void *pvMarshaledDataObject,
    DWORD dwSmId,
    IDataObject **ppIDataObject);

typedef void * DDInfo;

//+-------------------------------------------------------------------------
//
//  Function:  	FreeDragDropInfo
//
//  Synopsis:	frees a DDInfo handle (aka as a SPrivDragDrop struct)
//
//  Effects:
//
//  Arguments:	[hDDInfo]	-- handle to free
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void FreeDragDropInfo( DDInfo hDDInfo );


//
// Drag Drop interpreter op codes
//

typedef enum tagDRAGOP
{
        DRAGOP_ENTER = 1,
        DRAGOP_OVER  = 2,
        DRAGOP_LEAVE = 3,
        DRAGOP_DROP  = 4
} DRAGOP;

//+-------------------------------------------------------------------------
//
//  Function:	PrivDragDrop
//
//  Synopsis:  	Main entry point for the private version of the OLE
//		protocol.  Instead of using IDropTarget proxy/stubs,
//		we use a private rpc and do most of the work on the
//		drop target side.
//
//  Effects:
//
//  Arguments: 	[hwnd]	-- the target hwnd
//		[dop]	-- the drag drop operation to perform
//		[DOBuffer] -- the data object buffer to send
//		[pIDataObject] -- the data object interface (for the
//				  local case)
//		[grfKeyState] -- the keyboard state
//		[ptl]	-- the mouse position
//		[pdwEffect]   -- the drag drop effect
//		[hwndSource]  -- the window of the drag source.  Used
//				 to attach input queues for 16bit targets
//		[phDDInfo]    -- pointer to a DragDropInfo handle, for
//				 caching rpc info about the drop target.
//			         May not be NULL, but on DragEnter,
//				 should be a pointer to NULL.
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	see getif.cxx
//
//  History:    dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//  		08-Nov-94 alexgo    modified to use DRAGOP's
//		08-Jan-95 alexgo    added caching of RPC binding handles via
//				    DDInfo handles
//  Notes:
//
//--------------------------------------------------------------------------


HRESULT PrivDragDrop( HWND hwnd, DRAGOP dop, IFBuffer DOBuffer, IDataObject *
		pIDataObject,  DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect,
		HWND hwndSource, DDInfo *phDDInfo);

#endif // _DRAGOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\hkole32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       hkOle32.h
//
//  Contents:   OLE32 Hook Header File
//
//  Functions:
//
//  History:    29-Nov-94 Ben Lawrence, Don Wright   Created
//
//--------------------------------------------------------------------------
#ifndef _OLE32HK_H_
#define _OLE32HK_H_


#ifndef INITGUID
#define INITGUID
#endif /* INITGUID */

//#include "hkole32x.h"
//#include "hkoleobj.h"
//#include "hkLdInP.h"
#include "tchar.h"      // This is required for _TCHAR to be defined in dllcache.hxx
#include "ictsguid.h"
#include <windows.h>


//
// Prototypes for functions used by	\ole32\com\class\compobj.cxx
//
VOID
InitHookOle(
	VOID
    );

VOID
UninitHookOle(
    VOID
    );


// These should be removed after 4.0 RTM.
//
inline void CALLHOOKOBJECT(HRESULT MAC_hr, REFCLSID MAC_rclsid, REFIID MAC_riid, IUnknown** MAC_ppv)
{
}

inline void CALLHOOKOBJECTCREATE(HRESULT MAC_hr, REFCLSID MAC_rclsid, REFIID MAC_riid, IUnknown** MAC_ppv)
{
}


#ifdef DEFCLSIDS

//these are all undefined in ole32hk because they are private CLSIDs
//we define them here to null
#define GUID_NULL CLSID_HookOleObject //use this for now so it will compile

#define CLSID_ItemMoniker       CLSID_NULL
#define CLSID_FileMoniker       CLSID_NULL
#define CLSID_PointerMoniker    CLSID_NULL
#define CLSID_CompositeMoniker  CLSID_NULL
#define CLSID_AntiMoniker       CLSID_NULL
#define CLSID_PSBindCtx         CLSID_NULL

#endif /* DEFCLSIDS */


#endif  // _OLE32HK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\map_kv.h ===
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

#include    <memapi.hxx>

/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);

#ifdef WIN32
DECLARE_HANDLE(HMAPKEY);
#else
DECLARE_HANDLE32(HMAPKEY);
#endif

typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class FAR CMapKeyToValue : public CPrivAlloc
{
public:
        CMapKeyToValue(UINT cbValue, UINT cbKey = 0,
                int nBlockSize=10,
                LPFNHASHKEY lpfnHashKey = NULL,
                UINT nHashSize = 17);
        ~CMapKeyToValue();

        // number of elements
        int     GetCount() const { return m_nCount; }
        BOOL    IsEmpty() const { return m_nCount == 0; }

        // Lookup; return FALSE if not found
        BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
        BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
        BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

        // add a new (key, value) pair; return FALSE if out of memory
        BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
        BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

        // removing existing (key, ?) pair; return FALSE if no such key
        BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
        BOOL    RemoveHKey(HMAPKEY hKey);
        void    RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const
                        { return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
        void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey,
                                UINT FAR* pcbKey, LPVOID pValue) const;

        // return HMAPKEY for given key; returns NULL if not currently in map
        HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

        void    AssertValid() const;

private:
        // abstracts, somewhat, variable and fixed sized keys; size is really
        // m_cbKeyInAssoc.
        union CKeyWrap
        {
                BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
                struct
                {
                        LPVOID pKey;
                        UINT cbKey;
                };
        };

        // Association of one key and one value; NOTE: even though in general
        // the size of the key and value varies, for any given map,
        // the size of an assoc is fixed.
        struct CAssoc
        {
                CAssoc  FAR* pNext;
                UINT    nHashValue; // needed for efficient iteration
                CKeyWrap key;           // size is really m_cbKeyInAssoc
                // BYTE rgbValue[m_cbValue];
        };

        UINT    SizeAssoc() const
                { return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
        CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
        void    FreeAssoc(CAssoc FAR* pAssoc);
        BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

        BOOL    SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        void    GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
        void    FreeAssocKey(CAssoc FAR* pAssoc) const;
        void    GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
        void    GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
        void    SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

        BOOL    InitHashTable();

        UINT    m_cbValue;
        UINT    m_cbKey;                        // variable length if 0
        UINT    m_cbKeyInAssoc;         // always non-zero

        CAssoc  FAR* FAR* m_pHashTable;
        UINT    m_nHashTableSize;
        LPFNHASHKEY m_lpfnHashKey;

        int     m_nCount;
        CAssoc  FAR* m_pFreeList;
        struct CPlex FAR* m_pBlocks;
        int     m_nBlockSize;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\ictsguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       ICTGUID.h
//
//  Contents:	CLSIDs and IIDs for ICTS (Interface Conformance Test Suite)
//		Header File
//
//  Functions:	
//
//  History:	15-Jun-94 Garry Lenz    Created
//              12-Oct-94 Garry Lenz    Added IUnknownEx
//              12-Oct-94 Garry Lenz    Added IEnumGUID
//              13-Oct-94 Garry Lenz    Added Wrapper & Filter CLSIDs
//
//--------------------------------------------------------------------------

#ifndef _ICTSGUID_H_
#define _ICTSGUID_H_

#include <Windows.h>

//#ifdef INITGUID
    DEFINE_OLEGUID(IID_IUnknownEx,              0x0002AD00, 0, 0);
    DEFINE_OLEGUID(IID_IEnumGUID,               0x0002AD01, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleObject,         0x0002AD10, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleObject,          0x0002AD11, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleClass,           0x0002AD12, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleInstance,        0x0002AD13, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleInterface,       0x0002AD14, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleMethod,          0x0002AD15, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleWrapper,         0x0002AD1A, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleFilter,          0x0002AD1B, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleAPI,            0x0002AD20, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleLog,            0x0002AD30, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleLog,             0x0002AD31, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleWrapper,        0x0002ADA0, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_ComponentObject,   0x0002ADA1, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_CompoundDocument,  0x0002ADA2, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_DataTransfer,      0x0002ADA3, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_Linking,           0x0002ADA4, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_PersistentStorage, 0x0002ADA5, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_DragAndDrop,       0x0002ADA6, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_InPlaceActivation, 0x0002ADA7, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_Concurrency,       0x0002ADA8, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_Automation,        0x0002ADA9, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleFilter,         0x0002ADB0, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_ComponentObject,   0x0002ADB1, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_CompoundDocument,  0x0002ADB2, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_DataTransfer,      0x0002ADB3, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_Linking,           0x0002ADB4, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_PersistentStorage, 0x0002ADB5, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_DragAndDrop,       0x0002ADB6, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_InPlaceActivation, 0x0002ADB7, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_Concurrency,       0x0002ADB8, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_Automation,	0x0002ADB9, 0, 0);
#if 0
//#else
    extern "C"
     {
        extern IID IID_IUnknownEx;
        extern IID IID_IEnumGUID;

        extern CLSID CLSID_HookOleObject;
        extern IID IID_IHookOleObject;
        extern IID IID_IHookOleClass;
        extern IID IID_IHookOleInstance;
        extern IID IID_IHookOleInterface;
        extern IID IID_IHookOleMethod;
        extern IID IID_IHookOleWrapper;
        extern IID IID_IHookOleFilter;

        extern CLSID CLSID_HookOleAPI;

        extern CLSID CLSID_HookOleLog;
        extern IID IID_IHookOleLog;

        extern CLSID CLSID_HookOleWrapper;
        extern CLSID CLSID_HOW_ComponentObject;
        extern CLSID CLSID_HOW_CompoundDocument;
        extern CLSID CLSID_HOW_DataTransfer;
        extern CLSID CLSID_HOW_Linking;
        extern CLSID CLSID_HOW_PersistentStorage;
        extern CLSID CLSID_HOW_DragAndDrop;
        extern CLSID CLSID_HOW_InPlaceActivation;
        extern CLSID CLSID_HOW_Concurrency;

        extern CLSID CLSID_HookOleFilter;
        extern CLSID CLSID_HOF_ComponentObject;
        extern CLSID CLSID_HOF_CompoundDocument;
        extern CLSID CLSID_HOF_DataTransfer;
        extern CLSID CLSID_HOF_Linking;
        extern CLSID CLSID_HOF_PersistentStorage;
        extern CLSID CLSID_HOF_DragAndDrop;
        extern CLSID CLSID_HOF_InPlaceActivation;
        extern CLSID CLSID_HOF_Concurrency;
     }

#endif /* INITGUID */

#endif /* _ICTSGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\ole2ver.h ===
/*****************************************************************************\
*                                                                             *
* ole2ver.h -   OLE 2 Version Number Info                                     *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#ifndef _OLE2VER_H_
#define _OLE2VER_H_

#define rmm     23
#define rup     639

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\ole2com.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ole2com.h
//
//  Contents:   Common definitions shared by com and ole232
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-94   kevinro   Created
//              06-16-94  AlexT     Add FnAssert prototype
//                        07-26-94  AlexGo    Added CStabilize and CSafeRefCount
//              21-Dec-94 BruceMa   Wrap mbstowcs and wcstombs
//              23-Jan-95 t-ScottH  added Dump method to CSafeRefCount
//              08-Sep-95 murthys   Added declarations for compapi worker
//                                   used by com, stg, scm etc
//
//  Notes:
//      There are two versions of ole2int.h in the project. This is
//      unfortunate, but would be a major pain in the butt to fix.
//      What I have done is to extract the share parts of the two files,
//      and put them in this file. ole2int.h then includes this file.
//
//      Someday, somebody should reconcile all of the differences between the
//      two ole2int.h files, and rename them. Don't have time for that now,
//      so I have gone for the path of least resistance.
//                                                      KevinRo
//----------------------------------------------------------------------------
#ifndef _OLE2COM_H_
#define _OLE2COM_H_

#include <memapi.hxx>

//
// common compobj API worker functions used by com, stg, scm etc
//
// These definitions are shared between all of the components of OLE that
// use the common directory, such as SCM and COMPOBJ
//
//  format for string form of GUID is (leading identifier ????)
//  ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}

#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
#define CLSIDSTR_MAX (GUIDSTR_MAX)
#define IIDSTR_MAX   (GUIDSTR_MAX)

//
// Internal values used between OLE32 and SCM
//

#define APT_THREADED                  0
#define FREE_THREADED                 1
#define SINGLE_THREADED               2
#define BOTH_THREADED                 3
#define NEUTRAL_THREADED              4
#define GOT_FROM_ROT                  0x80000000


//
// Internal CLSCTX used for loading Proxy/Stub DLLs
//
#define CLSCTX_PS_DLL                 0x80000000

//
// The following flags are used to support loading INPROC items into 16-bit DLL's
//
#define CLSCTX_INPROC_HANDLERS (CLSCTX_INPROC_HANDLER16 | CLSCTX_INPROC_HANDLER)
#define CLSCTX_INPROC_SERVERS (CLSCTX_INPROC_SERVER16 | CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL)

// "common" compapi worker functions

INTERNAL_(int)  wStringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax);
INTERNAL wStringFromUUID(REFGUID rguid, LPWSTR lpsz);
void FormatHexNumW( unsigned long ulValue, unsigned long chChars, WCHAR *pwcStr);
void FormatHexNumA( unsigned long ulValue, unsigned long chChars, char *pchStr);

#define wStringFromGUID2T wStringFromGUID2

BOOL wThreadModelMatch(DWORD dwCallerThreadModel,DWORD dwDllThreadModel,DWORD dwContext);
LONG wQueryStripRegValue(HKEY hkey,LPCWSTR pwszSubKey,LPTSTR pwszValue, PLONG pcbValue);
LONG wGetDllInfo(HKEY hClsRegEntry,LPCWSTR pwszKey,LPTSTR pwszDllName,LONG *pclDllName,ULONG *pulDllThreadType);
BOOL wCompareDllName(LPCWSTR pwszPath, LPCWSTR pwszDllName, DWORD dwDllNameLen);

// compapi worker functions

INTERNAL wIsInternalProxyStubIID(REFIID riid, LPCLSID lpclsid);
INTERNAL wCoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);
INTERNAL wCLSIDFromOle1Class(LPCWSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign=FALSE);
INTERNAL wCLSIDFromString(LPWSTR lpsz, LPCLSID lpclsid);

#define wCLSIDFromProgID    wCLSIDFromOle1Class

INTERNAL_(int) wOle1ClassFromCLSID2(REFCLSID rclsid, LPWSTR lpsz, int cbMax);
INTERNAL wCoGetTreatAsClass(REFCLSID clsidOld, LPCLSID lpClsidNew);
INTERNAL wRegQueryPSClsid(REFIID riid, LPCLSID lpclsid);
INTERNAL wRegQuerySyncIIDFromAsyncIID(REFIID riid, LPCLSID lpiidSync);
INTERNAL wRegQueryAsyncIIDFromSyncIID(REFIID riid, LPCLSID lpiidAsync);
INTERNAL wCoGetPSClsid(REFIID riid, LPCLSID lpclsid);
INTERNAL wCoGetClassExt(LPCWSTR pwszExt, LPCLSID pclsid);
INTERNAL wRegGetClassExt(LPCWSTR lpszExt, LPCLSID pclsid);
INTERNAL wCoGetClassPattern(HANDLE hfile, CLSID *pclsid);
INTERNAL wCoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwContext, REFIID riid, LPVOID FAR* ppv);
INTERNAL_(HRESULT) wCoMarshalInterThreadInterfaceInStream(REFIID riid, LPUNKNOWN pUnk, LPSTREAM *ppStm);
INTERNAL_(HRESULT) wCoGetInterfaceAndReleaseStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv);
INTERNAL_(BOOL) wGUIDFromString(LPCWSTR lpsz, LPGUID pguid);
INTERNAL_(BOOL) wUUIDFromString(LPCWSTR lpsz, LPGUID pguid);
INTERNAL wStringFromCLSID(REFCLSID rclsid, LPWSTR FAR* lplpsz);
INTERNAL wStringFromIID(REFIID rclsid, LPWSTR FAR* lplpsz);
INTERNAL wIIDFromString(LPWSTR lpsz, LPIID lpiid);
INTERNAL_(BOOL) wCoIsOle1Class(REFCLSID rclsid);
INTERNAL wkProgIDFromCLSID(REFCLSID rclsid, LPWSTR FAR* ppszProgID);
INTERNAL wRegOpenClassKey(REFCLSID clsid, REGSAM samDesired, HKEY FAR* lphkeyClsid);
INTERNAL wRegOpenClassSubkey(REFCLSID rclsid, LPCWSTR lpszSubkey, HKEY *phkeySubkey);
INTERNAL wRegOpenFileExtensionKey(LPCWSTR pszFileExt, HKEY FAR* lphkeyClsid);
INTERNAL wRegOpenInterfaceKey(REFIID riid, HKEY * lphkeyIID);
INTERNAL wRegOpenProgIDKey(LPCWSTR pszProgID, HKEY FAR* lphkeyClsid);
INTERNAL wRegQueryClassValue(REFCLSID rclsid, LPCWSTR lpszSubKey,
                             LPWSTR lpszValue, int cbMax);

INTERNAL_(LONG) wRegOpenKeyEx(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult);

//
// There are two sets of possible keys. There are the 32 bit, as well as
// the 16 bit
//

const WCHAR wszCLSID[]     =  L"CLSID";

const WCHAR wszInprocServer[]   = L"InprocServer32";
const WCHAR wszInprocHandler[]  = L"InprocHandler32";
const WCHAR wszLocalServer[]    = L"LocalServer32";

const WCHAR wszActivateAtBits[] = L"ActivateAtBits";
const WCHAR wszActivateRemote[] = L"Remote";
const WCHAR wszDebug[]    = L"Debug";

const WCHAR wszLocalServer16[]   = L"LocalServer";
const WCHAR wszInprocServer16[]  = L"InprocServer";
const WCHAR wszInprocHandler16[] = L"InprocHandler";

const WCHAR wszOle2Dll[] = L"OLE2.DLL";

#define OLE2_DLL wszOle2Dll
#define OLE2_BYTE_LEN sizeof(OLE2_DLL)
#define OLE2_CHAR_LEN (sizeof(OLE2_DLL) / sizeof(WCHAR) - 1)


const WCHAR wszCLSIDBACK[] = L"CLSID\\";
#define CLSIDBACK wszCLSIDBACK
#define CLSIDBACK_BYTE_LEN sizeof(CLSIDBACK)
#define CLSIDBACK_CHAR_LEN (sizeof(CLSIDBACK) / sizeof(WCHAR) - 1)

#define KEY_LEN             256     //  max size of registry key
#define VALUE_LEN           256     //  max size of registry value

#ifdef _CAIRO_

#define _DCOM_          // enable definition of Cairo OLE COM extensions
#include <oleext.h>

#else

// These API's are exposed for Cairo but not for Daytona, so we declare
// them here for internal users

WINOLEAPI OleInitializeEx(LPVOID pvReserved, DWORD);
WINOLEAPI CoGetPersistentInstance(
    REFIID riid,
    DWORD dwCtrl,
    DWORD grfMode,
    OLECHAR *pwszName,
    struct IStorage *pstg,
    REFCLSID rclsidOle1,
    BOOL * pfOle1Loaded,
    void **ppvUnk);
#endif


//
// No longer in the Cairo DEF file.  We want to remove this as soon as
// oleutest can be changed to not use it.
//
WINOLEAPI CoNewPersistentInstance(
    REFCLSID rclsid,
    REFIID riid,
    DWORD dwCtrl,
    DWORD grfMode,
    OLECHAR *pwszCreateFrom,
    struct IStorage *pstgCreateFrom,
    OLECHAR *pwszNewName,
    void **ppunk);

#if DBG==1
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
ULONG GetInfoLevel(CHAR *pszKey, ULONG *pulValue, CHAR *pszdefval);
void StgDebugInit(void);
#endif

//
// The Storage entry points that are called from OLE entry points.
//
HRESULT Storage32DllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv);
STDAPI  Storage32DllRegisterServer(void);

#if defined(_M_I86SM) || defined(_M_I86MM)
#define _NEARDATA
#endif

#ifdef WIN32
#define HTASK DWORD         // Use Proccess id / Thread id
#endif


#ifdef WIN32
// we have to define these because they have been deleted from
// win32s, where only the ...Ex versions exist anymore.
// Now, that's backward compatibility!
# define SetWindowOrg(h,x,y)       SetWindowOrgEx((h),(x),(y),NULL)
# define SetWindowExt(h,x,y)       SetWindowExtEx((h),(x),(y),NULL)
# define SetViewportOrg(h,x,y)     SetViewportOrgEx((h),(x),(y),NULL)
# define SetViewportExt(h,x,y)     SetViewportExtEx((h),(x),(y),NULL)
# define SetBitmapDimension(h,x,y) SetBitmapDimensionEx((h),(x),(y),NULL)
#endif


#ifdef WIN32

# define _xstrcpy   lstrcpyW
# define _xstrcat   lstrcatW
# define _xstrlen   lstrlenW
# define _xstrchr   wcschr
# define _xstrcmp   lstrcmpW
# define _xstricmp  lstrcmpiW
# define _xstrtok   wcstok
# define _xisdigit(c)  (IsCharAlphaNumericW(c) && !IsCharAlphaW(c))

#else // !WIN32

# define _xstrcpy   _fstrcpy
# define _xstrcat   _fstrcat
# define _xstrlen   _fstrlen
# define _xstrchr   _fstrchr
# define _xstrcmp   _fstrcmp
# define _xstricmp  _fstricmp
# define _xstrtok   _fstrtok
# define _xisdigit(c)  isdigit(c)

#endif // WIN32

//+----------------------------------------------------------------------------
//
//      Macro:
//              GETPPARENT
//
//      Synopsis:
//              Given a pointer to something contained by a struct (or
//              class,) the type name of the containing struct (or class),
//              and the name of the member being pointed to, return a pointer
//              to the container.
//
//      Arguments:
//              [pmemb] -- pointer to member of struct (or class.)
//              [struc] -- type name of containing struct (or class.)
//              [membname] - name of member within the struct (or class.)
//
//      Returns:
//              pointer to containing struct (or class)
//
//      Notes:
//              Assumes all pointers are FAR.
//
//      History:
//              11/10/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------
#define GETPPARENT(pmemb, struc, membname) (\
                (struc FAR *)(((char FAR *)(pmemb))-offsetof(struc, membname)))

//STDSTATIC is intended to be used for static class methods
//only!!
#define STDSTATIC_(type)     static type EXPORT
#define STDSTATICIMP_(type)  type EXPORT

#ifdef WIN32
# define WEP_FREE_DLL 0
# define WEP_SYSTEM_EXIT 1
#endif

#ifndef _MAC

/* dll's instance and module handles */
extern HMODULE   g_hmodOLE2;
extern HINSTANCE g_hinst;

/* Variables for registered clipboard formats */
extern CLIPFORMAT g_cfObjectLink;
extern CLIPFORMAT g_cfOwnerLink;
extern CLIPFORMAT g_cfNative;
extern CLIPFORMAT g_cfLink;
extern CLIPFORMAT g_cfBinary;
extern CLIPFORMAT g_cfFileName;
extern CLIPFORMAT g_cfFileNameW;
extern CLIPFORMAT g_cfNetworkName;
extern CLIPFORMAT g_cfDataObject;
extern CLIPFORMAT g_cfEmbeddedObject;
extern CLIPFORMAT g_cfEmbedSource;
extern CLIPFORMAT g_cfLinkSource;
extern CLIPFORMAT g_cfOleDraw;
extern CLIPFORMAT g_cfLinkSrcDescriptor;
extern CLIPFORMAT g_cfObjectDescriptor;
extern CLIPFORMAT g_cfCustomLinkSource;
extern CLIPFORMAT g_cfPBrush;
extern CLIPFORMAT g_cfMSDraw;
extern CLIPFORMAT g_cfOlePrivateData;
extern CLIPFORMAT g_cfScreenPicture;  // used for XL and Word hack
                                      // see clipapi.cpp
extern CLIPFORMAT g_cfOleClipboardPersistOnFlush;
extern CLIPFORMAT g_cfMoreOlePrivateData;

#endif // _MAC


#include <utstream.h>

/*
 *      Warning disables:
 *
 *      We compile with warning level 4, with the following warnings
 *      disabled:
 *
 *      4355: 'this' used in base member initializer list
 *
 *              We don't see the point of this message and we do this all
 *              the time.
 *
 *      4505: Unreferenced local function has been removed -- the given
 *      function is local and not referenced in the body of the module.
 *
 *              Unfortunately, this is generated for every inline function
 *              seen in the header files that is not used in the module.
 *              Since we use a number of inlines, this is a nuisance
 *              warning.  It would be nice if the compiler distinguished
 *              between inlines and regular functions.
 *
 *      4706: Assignment within conditional expression.
 *
 *              We use this style of programming extensively, so this
 *              warning is disabled.
 */
#pragma warning(disable:4355)
#pragma warning(disable:4068)

/*
 *      MACROS for Mac/PC core code
 *
 *      The following macros reduce the proliferation of #ifdefs.  They
 *      allow tagging a fragment of code as Mac only, PC only, or with
 *      variants which differ on the PC and the Mac.
 *
 *      Usage:
 *
 *
 *      h = GetHandle();
 *      Mac(DisposeHandle(h));
 *
 *
 *      h = GetHandle();
 *      MacWin(h2 = h, CopyHandle(h, h2));
 *
 */
#ifdef _MAC
#define Mac(x) x
#define Win(x)
#define MacWin(x,y) x
#else
#define Mac(x)
#define Win(x) x
#define MacWin(x,y) y
#endif

//
// The following includes an interface that is common between the
// WOW thunk layer, and the 32-bit version of OLE.
//

#include <thunkapi.hxx>         // WOW thunking interfaces

//
// A call to CoInitializeWOW will set the following variable. When set,
// it points to a VTABLE of functions that we can call in the thunk
// DLL. Only used when running in a VDM.
//
extern LPOLETHUNKWOW g_pOleThunkWOW;


// debug versions of interlocked increment/decrement; not accurate
// under multi-threading conditions, but better than the return value
// of the Interlocked increment/decrement functions.
inline DWORD InterlockedAddRef(DWORD *pRefs)
{
#if DBG==1
    DWORD refs = *pRefs + 1;
    InterlockedIncrement((LPLONG)pRefs);
    return refs;
#else
    return InterlockedIncrement((LPLONG)pRefs);
#endif
}

inline DWORD InterlockedRelease(DWORD *pRefs)
{
#if DBG==1
    DWORD refs = *pRefs - 1;
    return InterlockedDecrement((LPLONG)pRefs) == 0 ? 0 : refs;
#else
    return InterlockedDecrement((LPLONG)pRefs);
#endif
}


// helper for getting stable pointers during destruction or other times;
// NOTE: not thread safe; must provide higher level synchronization
inline void SafeReleaseAndNULL(IUnknown **ppUnk)
{
    if (*ppUnk != NULL)
    {
        IUnknown *pUnkSave = *ppUnk;
        *ppUnk = NULL;
        pUnkSave->Release();
    }
}



/***********************************************************************/
/*      FILE FORMAT RELATED INFO                        ****/

// Coponent object stream information

#define COMPOBJ_STREAM                          OLESTR("\1CompObj")
#define BYTE_ORDER_INDICATOR 0xfffe    // for MAC it could be different
#define COMPOBJ_STREAM_VERSION 0x0001

// OLE defines values for different OSs
#define OS_WIN  0x0000
#define OS_MAC  0x0001
#define OS_NT   0x0002

// HIGH WORD is OS indicator, LOW WORD is OS version number
extern DWORD gdwOrgOSVersion;
extern DWORD gdwOleVersion;

// Ole streams information
#define OLE_STREAM OLESTR("\1Ole")
#define OLE_PRODUCT_VERSION 0x0200 /* (HIGH BYTE major version) */
#define OLE_STREAM_VERSION 0x0001

#define OLE10_NATIVE_STREAM OLESTR("\1Ole10Native")
#define OLE10_ITEMNAME_STREAM OLESTR("\1Ole10ItemName")
#define OLE_PRESENTATION_STREAM OLESTR("\2OlePres000")
#define OLE_MAX_PRES_STREAMS 1000
#define OLE_CONTENTS_STREAM OLESTR("CONTENTS")
#define OLE_INVALID_STREAMNUM (-1)

/************************************************************************/
/****           Storage APIs internally used                         ****/
/************************************************************************/

STDAPI  ReadClipformatStm(LPSTREAM lpstream, DWORD FAR* lpdwCf);
STDAPI  WriteClipformatStm(LPSTREAM lpstream, CLIPFORMAT cf);

STDAPI  WriteMonikerStm (LPSTREAM pstm, LPMONIKER pmk);
STDAPI  ReadMonikerStm (LPSTREAM pstm, LPMONIKER FAR* pmk);

STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem);
STDAPI_(LPSTREAM) CloneMemStm(HANDLE hMem);
STDAPI_(void)     ReleaseMemStm (LPHANDLE hMem, BOOL fInternalOnly = FALSE);

STDAPI GetClassFileEx( LPCWSTR lpszFileName,
                       CLSID FAR *pcid,
                       REFCLSID clsidOle1);

/*************************************************************************/
/***            Initialization code for individual modules             ***/
/*************************************************************************/

INTERNAL_(void) DDEWEP (
    BOOL fSystemExit
);

INTERNAL_(BOOL) DDELibMain (
        HANDLE  hInst,
        WORD    wDataSeg,
        WORD    cbHeapSize,
        LPWSTR  lpszCmdLine
);

BOOL    InitializeRunningObjectTable(void);

HRESULT GetObjectFromRotByPath(
            WCHAR *pwszPath,
            IUnknown **ppvUnk);

void    DestroyRunningObjectTable(void);


/**************************************************************************
                                        'lindex' related macros
***************************************************************************/

#define DEF_LINDEX (-1)

//+-------------------------------------------------------------------------
//
//  Function:   IsValidLINDEX
//
//  Synopsis:   Tests for valid combination of aspect and lindex
//
//  Arguments:  [dwAspect] -- aspect (part of FORMATETC)
//              [lindex]   -- lindex (part of FORMATETC)
//
//  Returns:    TRUE for valid lindex, else FALSE
//
//  History:    20-Jun-94 AlexT     Created
//
//  Notes:      Here is the spec for lindex values:
//
//              dwAspect            lindex values
//              --------            -------------
//              DVASPECT_CONTENT    -1
//              DVASPECT_DOCPRINT   anything
//              DVASPECT_ICON       -1
//              DVASPECT_THUMBNAIL  -1
//
//              So, we test for lindex == -1 or aspect == DOCPRINT
//
//--------------------------------------------------------------------------

inline BOOL IsValidLINDEX(DWORD dwAspect, LONG lindex)
{
    return((DEF_LINDEX == lindex) || (DVASPECT_DOCPRINT == dwAspect));
}

//+-------------------------------------------------------------------------
//
//  Function:   HasValidLINDEX
//
//  Synopsis:   Tests for valid combination of aspect and lindex
//
//  Arguments:  [pFormatEtc] -- pFormatEtc to test
//
//  Returns:    TRUE for valid lindex, else FALSE
//
//  History:    20-Jun-94 AlexT     Created
//
//  Notes:      See IsValidLINDEX, above
//
//--------------------------------------------------------------------------

inline BOOL HasValidLINDEX(FORMATETC const *pFormatEtc)
{
    return(IsValidLINDEX(pFormatEtc->dwAspect, pFormatEtc->lindex));
}

#define INIT_FORETC(foretc) { \
        (foretc).ptd = NULL; \
        (foretc).lindex = DEF_LINDEX; \
        (foretc).dwAspect = DVASPECT_CONTENT; \
}

// Only DDE layer will test for these values. And only for advises on cached
// formats do we use these values

#define ADVFDDE_ONSAVE          0x40000000
#define ADVFDDE_ONCLOSE         0x80000000




// Used in Ole Private Stream
typedef enum tagOBJFLAGS
{
        OBJFLAGS_LINK=1L,
        OBJFLAGS_DOCUMENT=2L,   // this bit is owned by container and is
                                // propogated through saves
        OBJFLAGS_CONVERT=4L,
        OBJFLAGS_CACHEEMPTY=8L  // this bit indicates cache empty status
} OBJFLAGS;


/*****************************************
 Prototypes for dde\client\ddemnker.cpp
******************************************/

INTERNAL DdeBindToObject
        (LPCOLESTR  szFile,
        REFCLSID clsid,
        BOOL       fPackageLink,
        REFIID   iid,
        LPLPVOID ppv);

INTERNAL DdeIsRunning
        (CLSID clsid,
        LPCOLESTR szFile,
        LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning);


/**************************************
 Prototypes for moniker\mkparse.cpp
***************************************/

INTERNAL Ole10_ParseMoniker
        (LPMONIKER pmk,
        LPOLESTR FAR* pszFile,
        LPOLESTR FAR* pszItem);

STDAPI CreateOle1FileMoniker(LPWSTR, REFCLSID, LPMONIKER FAR*);

/****************************************************************************/
/*                              Utility APIs, might get exposed later                                           */
/****************************************************************************/

STDAPI  OleGetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetcIn,
                                                LPSTGMEDIUM pmedium, BOOL fGetOwnership);
STDAPI  OleSetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetc,
                                                STGMEDIUM FAR * pmedium, BOOL fRelease);
STDAPI  OleDuplicateMedium(LPSTGMEDIUM lpMediumSrc, LPSTGMEDIUM lpMediumDest);

STDAPI_(BOOL)    OleIsDcMeta (HDC hdc);

STDAPI SzFixNet( LPBINDCTX pbc, LPOLESTR szUNCName, LPOLESTR FAR * lplpszReturn,
    UINT FAR * pEndServer, BOOL fForceConnection = TRUE);

FARINTERNAL ReadFmtUserTypeProgIdStg
        (IStorage FAR * pstg,
        CLIPFORMAT FAR* pcf,
        LPOLESTR FAR* pszUserType,
        LPOLESTR         szProgID);

//+-------------------------------------------------------------------------
//
//  Function:   IsWOWProcess(), BOOL inline
//
//  Synopsis:   Tests whether or not we are running in a WOW process
//
//  Returns:    TRUE if in WOW process, FALSE otherwise
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-95 murthys   created
//
//  Notes:
//
//--------------------------------------------------------------------------

inline BOOL IsWOWProcess()
{
        return (BOOL) ( NULL == g_pOleThunkWOW ? FALSE : TRUE );
}

//+-------------------------------------------------------------------------
//
//  Function:   IsWOWThread(), BOOL inline
//
//  Synopsis:   Tests whether or not we are running in a 16-bit thread in a
//              WOW process
//
//  Returns:    TRUE if in 16-bit thread in a WOW process, FALSE otherwise
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-95 murthys   created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOLEAN TLSIsWOWThread();

inline BOOL IsWOWThread()
{
        return (BOOL) ( IsWOWProcess() ? TLSIsWOWThread(): FALSE );
}

//+-------------------------------------------------------------------------
//
//  Function:   IsWOWThreadCallable(), BOOL inline
//
//  Synopsis:   Tests whether or not we can call into OLETHK32.
//
//  Returns:    TRUE if WOW thread is callable, FALSE if not
//
//  Algorithm:  Tests the g_pOleThunkWOW pointer to see if it is non-zero
//              and not set to -1. -1 means we are in wow, but OLETHK32
//              has already been unloaded.  Also, checks to see if we're in
//              amidst a DLL_THREAD_DETACH.  We will not allow calls to 16-bit
//              side in this case as it may have already been cleaned up.
//
//  History:    dd-mmm-yy Author    Comment
//              19-mar-95 KevinRo   Created
//              15-Nov-95 MurthyS   Renamed from IsWowCallable
//              29-Jan-95 MurthyS   Added check for DLL_THREAD_DETACH
//
//  Notes:
//              Assumes that IsWOWThread() was called and returned TRUE!
//
//--------------------------------------------------------------------------

BOOLEAN TLSIsThreadDetaching();

inline BOOL IsWOWThreadCallable()
{
    return (BOOL) (( NULL == g_pOleThunkWOW ? FALSE :
                  ( INVALID_HANDLE_VALUE == g_pOleThunkWOW ? FALSE:TRUE)) &&
                  !(TLSIsThreadDetaching()));
}

/****************************************************************************/
/*                   Stabilization classes                                  */
/*        These are used to stabilize objects during re-entrant calls       */
/****************************************************************************/

#ifndef CO_E_RELEASED
#define CO_E_RELEASED  -2147467246L
#endif

typedef void * IFBuffer;

//+-------------------------------------------------------------------------
//
//  Function:   GetMarshalledInterfaceBuffer
//
//  Synopsis:   marshals the given interface into an allocated buffer.  The
//              buffer is returned
//
//  Effects:
//
//  Arguments:  [refiid]        -- the iid of the interface to marshal
//              [punk]          -- the IUnknown to marshal
//              [pIFBuf]        -- where to return the buffer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  calls CoMarshalInterface(MSHFLAGS_TABLESTRONG)
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetMarshalledInterfaceBuffer( REFIID riid, IUnknown *punk, IFBuffer
            *pIFBuf);

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseMarshalledInterfaceBuffer
//
//  Synopsis:   releases the buffer allocated by GetMarshalledInterfaceBuffer
//
//  Effects:
//
//  Arguments:  [IFBuf]         -- the interface buffer to release
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  calls CoReleaseMarshalData to undo the TABLE_STRONG
//              marshalling
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT ReleaseMarshalledInterfaceBuffer( IFBuffer IFBuf );


#define E_UNSPEC        E_FAIL

#include <widewrap.h>
#include <stkswtch.h>
#include <shellapi.h>

#ifdef WIN32 // REVIEW, just using this for tracking
# define OLE_E_NOOLE1 MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x00FE)
#endif // WIN32


/***********************************************************************/
/*        Wrap mbstowcs and wcstombs which are unsafe to use           */
/*        since they rely on crt.dll                                   */
/*                                                                     */
/*   Note: cCh in both cases is the output buffer size, not a          */
/*         string length.                                              */
/*                                                                     */
/***********************************************************************/

#define mbstowcs(x, y, z) DONT_USE_mbstowcs___USE_MultiByteToWideChar_INSTEAD
#define wcstombs(x, y, z) DONT_USE_wcstombs___USE_WideCharToMultiByte_INSTEAD



//------------------------------------------------------------------
//
//  Dynamically Loaded System APIs
//
//  OLEs implementations of these system APIs dynamically load the
//  system DLLs.  Since these are rarely used APIs we dynamically
//  load them to reduce the load time of OLE32.DLL
//
//  The implementations can be found in com\util\dynload.cxx
//
//------------------------------------------------------------------

// Our own load library helper.
BOOL LoadSystemProc(LPSTR szDll, LPCSTR szProc,
                    HINSTANCE *phInst, FARPROC *ppfnProc);

// HOOK OLE macros for wrapping interface pointers
#include    <hkole32.h>

// ----------------------------------------------------------------------------
// API/Method trace output
// ----------------------------------------------------------------------------

#include <trace.hxx>


// ----------------------------------------------------------------------------
// Catalog related declarations: these are defined in ..\..\common\ccompapi.cxx
// ----------------------------------------------------------------------------

#include <catalog.h>

HRESULT InitializeCatalogIfNecessary();
HRESULT UninitializeCatalog();
extern IComCatalog *gpCatalog;
extern IComCatalogSCM *gpCatalogSCM;

// ----------------------------------------------------------------------------
// Specialized registry functions for HKCR.  These are defined in reghelp.cxx
// ----------------------------------------------------------------------------
#include <reghelp.hxx>

#endif  // _OLE2COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\ole2sp.h ===
/* ole2sp.h - semi-private info; only for test apps within the development group
*/

#if !defined( _OLE2SP_H_ )
#define _OLE2SP_H_

#include <shellapi.h>

// For MAC, M_PROLOG and M_EPILOG are macros which assist us in setting up the A5
// world for a DLL when a method in the DLL is called from outside the DLL.

#ifdef _MAC

#define _MAX_PATH 260

#ifdef __cplusplus

class  CSetA5
{
public:
    CSetA5 (ULONG savedA5){ A5save = SetA5(savedA5);}
    ~CSetA5 (){ SetA5(A5save);}

private:
    ULONG A5save;
};

pascal long     GetA5(void) = 0x2E8D;

#define M_PROLOG(where) CSetA5 Dummy((where)->savedA5)
#define SET_A5          ULONG savedA5
#define GET_A5()        savedA5 = GetA5()

// These macros assist Mac in manually saving/setting/restoring A5 in routines that contain
// goto's.

#define A5_PROLOG(where) ULONG A5save = SetA5(where->savedA5)
#define RESTORE_A5()     SetA5(A5save)

// Lets MAC name our segments without ifdef's.

#define NAME_SEG(x)

#endif // ccplus

#else

#define M_PROLOG(where)
#define SET_A5
#define GET_A5()
#define A5_PROLOG(where)
#define RESTORE_A5()
#define NAME_SEG(x)

//
//  By defining SEG(x) to code_seg(), we make #pragma SEG(x) a nop and
//  eliminate lots of unknown pragma warnings...    02/18/94
//

#define SEG(x)  code_seg()

#define IGetProcAddress(a,b) GetProcAddress((a),(b))

#endif


#define ReportResult(a,b,c,d) ResultFromScode(b)


#ifdef WIN32
#define MAP16(v16)
#define MAP32(v32) v32
#define MAP1632(v16,v32)   v32
#else
#define MAP16(v16) v16
#define MAP32(v32)
#define MAP1632(v16,v32)   v16
#endif


/****** Misc defintions ***************************************************/

#ifdef __TURBOC__
#define implement struct huge
#else
#define implement struct
#endif
#define ctor_dtor private
#define implementations private
#define shared_state private

// helpers for internal methods and functions which follow the same convention
// as the external ones

#ifdef __cplusplus
#define INTERNALAPI_(type) extern "C" type
#else
#define INTERNALAPI_(type) type
#endif

#define INTERNAL HRESULT
#define INTERNAL_(type) type
#define FARINTERNAL HRESULT FAR
#define FARINTERNAL_(type) type FAR
#define NEARINTERNAL HRESULT NEAR
#define NEARINTERNAL_(type) type NEAR



//BEGIN REVIEW: We may not need all the following ones

#define OT_LINK     1L
#define OT_EMBEDDED 2L
#define OT_STATIC   3L


//END REVIEW .....


/****** Old Error Codes    ************************************************/

#define S_OOM               E_OUTOFMEMORY
#define S_BADARG            E_INVALIDARG
#define S_BLANK             E_BLANK
#define S_FORMAT            E_FORMAT
#define S_NOT_RUNNING       E_NOTRUNNING
#define E_UNSPEC            E_FAIL



/****** Macros for nested clases ******************************************/

/* To overcome problems with nested classes on MAC
 *
 * NC(a,b) is used to define a member function of a nested class:
 *
 * STDMETHODIMP_(type) NC(ClassName,NestedClassName)::MemberFunction(...)
 *
 * DECLARE_NC(a,b) is used within a class declaration to let a nested class
 * access it container class:
 *
 * class ClassName {
 *     ..............
 *
 *     class NestedClassName {
 *         .............
 *     };
 *     DECLARE_NC(ClassName,NestedClassName)
 *     ..............
 * };
 */

#ifdef _MAC

#define NESTED_CLASS(a,b) struct a##_##b
#define NC(a,b) a##__##b
#define NC1(a,b) a##_##b
#define DECLARE_NC(a,b) typedef a##::##b a##__##b; friend a##__##b;
#define DECLARE_NC2(a,b) typedef a##::a##_##b a##__##b; friend a##__##b;

#else

#define NC(a,b) a##::##b
#define DECLARE_NC(a,b) friend b;

#endif


/****** More Misc defintions **********************************************/


// LPLPVOID should not be made a typedef.  typedef won't compile; worse
// within complicated macros the compiler generates unclear error messages
//
#define LPLPVOID void FAR * FAR *

#define UNREFERENCED(a) ((void)(a))

#ifndef BASED_CODE
#ifdef WIN32
#define BASED_CODE
#else
#define BASED_CODE __based(__segname("_CODE"))
#endif
#endif


/****** Standard IUnknown Implementation **********************************/

/*
 *      The following macro declares a nested class CUnknownImpl,
 *      creates an object of that class in the outer class, and
 *      declares CUnknownImpl to be a friend of the outer class.  After
 *      writing about 20 class headers, it became evident that the
 *      implementation of CUnknownImpl was very similar in all cases,
 *      and this macro captures the similarity.  The classname
 *      parameter is the name of the outer class WITHOUT the leading
 *      "C"; i.e., for CFileMoniker, classname is FileMoniker.
 */

#define noError return NOERROR

#ifdef _MAC

#define STDUNKDECL(cclassname,classname) NESTED_CLASS(cclassname, CUnknownImpl):IUnknown { public: \
    NC1(cclassname,CUnknownImpl)( cclassname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: cclassname FAR* m_p##classname; }; \
    DECLARE_NC2(cclassname, CUnknownImpl) \
    NC(cclassname, CUnknownImpl) m_Unknown;

#else  // _MAC

#define STDUNKDECL( ignore, classname ) implement CUnknownImpl:IUnknown { public: \
    CUnknownImpl( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: C##classname FAR* m_p##classname; }; \
    DECLARE_NC(C##classname, CUnknownImpl) \
    CUnknownImpl m_Unknown;
#endif

/*
 *      The following macro implements all the methods of a nested
 *      CUnknownImpl class EXCEPT FOR QUERYINTERFACE.  This macro was
 *      written after about 20 classes were written in which the
 *      implementations of CUnknownImpl were all the same.
 */

#ifdef WIN32

#define STDUNKIMPL(classname) \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::AddRef( void )             \
{                                                                              \
    InterlockedIncrement((LONG *)&m_p##classname->m_refs);                     \
                                                                               \
    return m_p##classname->m_refs;                                             \
}                                                                              \
                                                                               \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::Release( void )            \
{                                                                              \
    ULONG culRefs = 0;                                                         \
                                                                               \
    culRefs = InterlockedDecrement((LONG *)&m_p##classname->m_refs);           \
                                                                               \
    if (culRefs == 0)                                                          \
    {                                                                          \
        delete m_p##classname;                                                 \
    }                                                                          \
                                                                               \
    return culRefs;                                                            \
}

#else

#define STDUNKIMPL(classname) \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::AddRef( void ){ \
    return ++m_p##classname->m_refs; } \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::Release( void ){ \
    if (--m_p##classname->m_refs == 0) { delete m_p##classname; return 0; } \
    return m_p##classname->m_refs;}

#endif  //  WIN32


/*
 *      The following macro implements class::CUnknownImpl::QueryInterface IN
 *      THE SPECIAL CASE IN WHICH THE OUTER CLASS PRESENTS ONLY ONE INTERFACE
 *      OTHER THAN IUNKNOWN AND IDEBUG.  This is not universally the case,
 *      but it is common enough that this macro will save time and space.
 */

#ifdef _DEBUG
#define STDDEB_QI(classname) \
    if (IsEqualGUID(iidInterface, IID_IDebug)) \
         {*ppv = (void FAR *)&(m_p##classname->m_Debug); return 0;} else
#else
#define STDDEB_QI(classname)
#endif

#ifdef WIN32

#define STDUNK_QI_IMPL(classname, interfacename) \
STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface                     \
    (REFIID iidInterface, void FAR * FAR * ppv)                                \
{                                                                              \
    HRESULT hres = S_OK;                                                       \
                                                                               \
    if (IsEqualIID(iidInterface,IID_IUnknown))                                 \
    {                                                                          \
        *ppv = (void FAR *)&m_p##classname->m_Unknown;                         \
        AddRef();                                                              \
    }                                                                          \
    else if (IsEqualIID(iidInterface,IID_I##interfacename))                    \
    {                                                                          \
        *ppv = (void FAR *) &(m_p##classname->m_##classname);                  \
        m_p##classname->m_pUnkOuter->AddRef();                                 \
    }                                                                          \
    else STDDEB_QI(classname)                                                  \
    {                                                                          \
        *ppv = NULL;                                                           \
        hres = ResultFromScode(E_NOINTERFACE);                                 \
    }                                                                          \
                                                                               \
    return hres;                                                               \
}

#else

STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface                     \
    (REFIID iidInterface, void FAR * FAR * ppv) { \
    if (IsEqualGUID(iidInterface,IID_IUnknown)) {\
        *ppv = (void FAR *)&m_p##classname->m_Unknown;\
        AddRef(); noError;\
    } else if (IsEqualGUID(iidInterface, IID_I##interfacename)) { \
        *ppv = (void FAR *) &(m_p##classname->m_##classname);                  \
        m_p##classname->m_pUnkOuter->AddRef(); return NOERROR; \
    } else \
        STDDEB_QI(classname) \
        {*ppv = NULL; return ResultFromScode(E_NOINTERFACE);} \
}
#endif


/*
 *      The following macro implements the IUnknown methods inherited
 *      by the implementation of another interface.  The implementation
 *      is simply to delegate all calls to m_pUnkOuter.  Parameters:
 *      ocname is the outer class name, icname is the implementation
 *      class name.
 *
 */

#define STDUNKIMPL_FORDERIVED(ocname, icname) \
 STDMETHODIMP NC(C##ocname,C##icname)::QueryInterface \
(REFIID iidInterface, LPLPVOID ppvObj) { \
    return m_p##ocname->m_pUnkOuter->QueryInterface(iidInterface, ppvObj);} \
 STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::AddRef(void) { \
    return m_p##ocname->m_pUnkOuter->AddRef(); } \
 STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::Release(void) { \
    return m_p##ocname->m_pUnkOuter->Release(); }


/****** Debug defintions **************************************************/

#include <debug.h>


/****** Other API defintions **********************************************/

// low level reg.dat access (in compobj.dll)
STDAPI CoGetInProcDll(REFCLSID rclsid, BOOL fServer, LPOLESTR lpszDll, int cbMax);
STDAPI CoGetLocalExe(REFCLSID rclsid, LPOLESTR lpszExe, int cbMax);


// simpler alternatives to public apis
// WINOLEAPI_(int) StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax);
#define StringFromCLSID2(rclsid, lpsz, cbMax) \
    StringFromGUID2(rclsid, lpsz, cbMax)

#define StringFromIID2(riid, lpsz, cbMax) \
    StringFromGUID2(riid, lpsz, cbMax)

STDAPI_(int) Ole1ClassFromCLSID2(REFCLSID rclsid, LPOLESTR lpsz, int cbMax);
STDAPI_(BOOL) GUIDFromString(LPCOLESTR lpsz, LPGUID pguid);
STDAPI CLSIDFromOle1Class(LPCOLESTR lpsz, LPCLSID lpclsid, BOOL fForceAssign=FALSE);
STDAPI_(BOOL)  CoIsHashedOle1Class(REFCLSID rclsid);
STDAPI       CoOpenClassKey(REFCLSID clsid, BOOL bOpenForWrite, HKEY FAR* lphkeyClsid);


// were public; now not
STDAPI  SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument);
STDAPI  GetDocumentBitStg(LPSTORAGE pStg);


INTERNAL CreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/*
 * Some docfiles stuff
 */

#define STGM_DFRALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE)
#define STGM_DFALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE)
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)


/*
 * Some moniker stuff
 */
//REVIEW32:  Should this get exported publicly??

STDAPI Concatenate(LPMONIKER pmkFirst, LPMONIKER pmkRest,
                LPMONIKER FAR * ppmkComposite );

/*
 * Drag and Drop Interface Property Name
 */
#define OLE_DROP_TARGET_PROP    L"OleDropTargetInterface"
#define OLE_DROP_TARGET_PROPA   "OleDropTargetInterface"

#define OLE_DROP_TARGET_MARSHALHWND     L"OleDropTargetMarshalHwnd"
#define OLE_DROP_TARGET_MARSHALHWNDA    "OleDropTargetMarshalHwnd"

 /*
 * Private Clipboard Window IDataObject property name
 */
#define CLIPBOARD_DATA_OBJECT_PROP      L"ClipboardDataObjectInterface"

#endif // _OLE2SP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\ole1cls.h ===
/*****************************************************************************\
*                                                                             *
* ole1cls.h -   Master definition of GUIDs for OLE1 classes					  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* This file is the master definition of all GUIDs for OLE1 classes.

   All such GUIDs are of the form:

       0003xxxx-0000-0000-C000-000000000046

    The last parameter to DEFINE_OLE1GUID is the old 1.0 class name,
    i.e., its key in the registration database.

    Do not remove or change GUIDs.

    Do not add anything to this file except comments and DEFINE_OLE1GUID macros.
*/

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif

#ifdef WIN32
#define LSTR(x) L##x
#else
#define LSTR(x) x
#endif


DEFINE_OLE1GUID(CLSID_ExcelWorksheet,	0x00030000, 0, 0, LSTR("ExcelWorksheet"));
DEFINE_OLE1GUID(CLSID_ExcelChart,	0x00030001, 0, 0, LSTR("ExcelChart"));
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,	0x00030002, 0, 0, LSTR("ExcelMacrosheet"));
DEFINE_OLE1GUID(CLSID_WordDocument,	0x00030003, 0, 0, LSTR("WordDocument"));
DEFINE_OLE1GUID(CLSID_MSPowerPoint,	0x00030004, 0, 0, LSTR("MSPowerPoint"));
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,	0x00030005, 0, 0, LSTR("MSPowerPointSho"));
DEFINE_OLE1GUID(CLSID_MSGraph,		0x00030006, 0, 0, LSTR("MSGraph"));
DEFINE_OLE1GUID(CLSID_MSDraw,		0x00030007, 0, 0, LSTR("MSDraw"));
DEFINE_OLE1GUID(CLSID_Note_It,		0x00030008, 0, 0, LSTR("Note-It"));
DEFINE_OLE1GUID(CLSID_WordArt,		0x00030009, 0, 0, LSTR("WordArt"));
DEFINE_OLE1GUID(CLSID_PBrush,		0x0003000a, 0, 0, LSTR("PBrush"));
DEFINE_OLE1GUID(CLSID_Equation, 	0x0003000b, 0, 0, LSTR("Equation"));
DEFINE_OLE1GUID(CLSID_Package,		0x0003000c, 0, 0, LSTR("Package"));
DEFINE_OLE1GUID(CLSID_SoundRec, 	0x0003000d, 0, 0, LSTR("SoundRec"));
DEFINE_OLE1GUID(CLSID_MPlayer,		0x0003000e, 0, 0, LSTR("MPlayer"));

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,	0x0003000f, 0, 0, LSTR("ServerDemo"));
DEFINE_OLE1GUID(CLSID_Srtest,		0x00030010, 0, 0, LSTR("Srtest"));
DEFINE_OLE1GUID(CLSID_SrtInv,		0x00030011, 0, 0, LSTR("SrtInv"));
DEFINE_OLE1GUID(CLSID_OleDemo,		0x00030012, 0, 0, LSTR("OleDemo"));

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,0x00030013, 0, 0, LSTR("CoromandelIntegra"));
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, LSTR("CoromandelObjServer"));

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, LSTR("StanfordGraphics"));

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,	0x00030016, 0, 0, LSTR("DGraphCHART"));
DEFINE_OLE1GUID(CLSID_DGraphDATA,	0x00030017, 0, 0, LSTR("DGraphDATA"));

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,	0x00030018, 0, 0, LSTR("PhotoPaint"));
DEFINE_OLE1GUID(CLSID_CShow,		0x00030019, 0, 0, LSTR("CShow"));
DEFINE_OLE1GUID(CLSID_CorelChart,	0x0003001a, 0, 0, LSTR("CorelChart"));
DEFINE_OLE1GUID(CLSID_CDraw,		0x0003001b, 0, 0, LSTR("CDraw"));

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0, 	0x0003001c, 0, 0, LSTR("HJWIN1.0"));

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,	0x0003001d, 0, 0, LSTR("ObjMakerOLE"));

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,		0x0003001e, 0, 0, LSTR("FYI"));
DEFINE_OLE1GUID(CLSID_FYIView,		0x0003001f, 0, 0, LSTR("FYIView"));

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,	0x00030020, 0, 0, LSTR("Stickynote"));

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, LSTR("ShapewareVISIO10"));
DEFINE_OLE1GUID(CLSID_ImportServer,	0x00030022, 0, 0, LSTR("ImportServer"));


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest, 	0x00030023, 0, 0, LSTR("SrvrTest"));

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,	0x00030024, 0, 0, LSTR("OLE2_Embedded_Link"));

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,		0x00030025, 0, 0, LSTR("Cltest"));

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, LSTR("MS_ClipArt_Gallery"));

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,	0x00030027, 0, 0, LSTR("MSProject"));

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,	0x00030028, 0, 0, LSTR("MSWorksChart"));

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, LSTR("MSWorksSpreadsheet"));

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,		0x0003002A, 0, 0, LSTR("MinSvr"));
DEFINE_OLE1GUID(CLSID_HierarchyList,	0x0003002B, 0, 0, LSTR("HierarchyList"));
DEFINE_OLE1GUID(CLSID_BibRef,		0x0003002C, 0, 0, LSTR("BibRef"));
DEFINE_OLE1GUID(CLSID_MinSvrMI, 	0x0003002D, 0, 0, LSTR("MinSvrMI"));
DEFINE_OLE1GUID(CLSID_TestServ, 	0x0003002E, 0, 0, LSTR("TestServ"));

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,	0x0003002F, 0, 0, LSTR("AmiProDocument"));

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,	0x00030030, 0, 0, LSTR("WPGraphics"));
DEFINE_OLE1GUID(CLSID_WPCharts, 	0x00030031, 0, 0, LSTR("WPCharts"));


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma, 	0x00030032, 0, 0, LSTR("Charisma"));
DEFINE_OLE1GUID(CLSID_Charisma_30,	0x00030033, 0, 0, LSTR("Charisma_30"));
DEFINE_OLE1GUID(CLSID_CharPres_30,	0x00030034, 0, 0, LSTR("CharPres_30"));

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,		0x00030035, 0, 0, LSTR("Draw"));

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,	0x00030036, 0, 0, LSTR("Designer_40"));


#undef DEFINE_OLE1GUID

/* as we discover OLE 1 servers we will add them to the end of this list;
   there is room for 64K of them!
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\olecoll.h ===
// Microsoft OLE library.
// Copyright (C) 1992 Microsoft Corporation,
// All rights reserved.

// olecoll.h - global defines for collections and element definitions

#ifndef __OLECOLL_H__
#define __OLECOLL_H__


// ---------------------------------------------------------------------------
// general defines for collections

typedef void FAR* POSITION;

#define BEFORE_START_POSITION ((POSITION)LongToPtr(-1L))
#define _AFX_FP_OFF(thing) (*((UINT FAR*)&(thing)))
#define _AFX_FP_SEG(lp) (*((UINT FAR*)&(lp)+1))

#ifdef _DEBUG
#define ASSERT_VALID(p) p->AssertValid()
#else
#define ASSERT_VALID(p)
#endif


#endif //!__OLECOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\oletemp.h ===
// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L
#define EMBDHLP_INPROC_SERVER    0x0001L
#define EMBDHLP_CREATENOW    0x00000000L
#define EMBDHLP_DELAYCREATE  0x00010000L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\olerem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       olerem.h
//
//  Synopsis:   this file contain the base definitions for types and APIs
//              exposed by the ORPC layer to upper layers.
//
//+-------------------------------------------------------------------------
#if !defined( _OLEREM_H_ )
#define _OLEREM_H_

// default transport for same-machine communication
#define LOCAL_PROTSEQ L"ncalrpc"


// -----------------------------------------------------------------------
// Internal Interface used by handlers.
//
// NOTE: connect happens during unmarshal
// NOTE: implemented as part of the std identity object
//
//
//  History
//              12-Dec-96   Gopalk      Added new function to obtain
//                                      connection status with the
//                                      server object on the client side
// -----------------------------------------------------------------------
interface IProxyManager : public IUnknown
{
    STDMETHOD(CreateServer)(REFCLSID rclsid, DWORD clsctx, void *pv) = 0;
    STDMETHOD_(BOOL, IsConnected)(void) = 0;
    STDMETHOD(LockConnection)(BOOL fLock, BOOL fLastUnlockReleases) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(GetConnectionStatus)(void) = 0;

#ifdef SERVER_HANDLER
    STDMETHOD(CreateServerWithEmbHandler)(REFCLSID rclsid, DWORD clsctx,
                                          REFIID riidEmbedSrvHandler,
                                          void **ppEmbedSrvHandler, void *pv) = 0;
#endif // SERVER_HANDLER
};


STDAPI GetInProcFreeMarshaler(IMarshal **ppIM);


#include <obase.h>  // ORPC base definitions

typedef const IPID &REFIPID;    // reference to Interface Pointer IDentifier
typedef const OID  &REFOID;     // reference to Object IDentifier
typedef const OXID &REFOXID;    // reference to Object Exporter IDentifier
typedef const MID  &REFMID;     // reference to Machine IDentifier

typedef GUID MOXID;             // OXID + MID
typedef const MOXID &REFMOXID;  // reference to OXID + MID
typedef GUID MOID;              // OID + MID
typedef const MOID &REFMOID;    // reference to OID + MID


// flag for default handler to pass to CreateIdentityHandler
#define STDID_CLIENT_DEFHANDLER 0x401

STDAPI CreateIdentityHandler(IUnknown *pUnkOuter, DWORD flags,
                             CObjectContext *pServerCtx, DWORD dwAptId,
                             REFIID riid, void **ppv);


// DDE Init/Cleanup Functions
INTERNAL CheckInitDde(BOOL fServingObject);
void CheckUninitDde(BOOL fLastUninit);


#include <iface.h>

#endif // _OLEREM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\map_up.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapUintPtr : public CPrivAlloc
{
public:
	// Construction
	CMapUintPtr(UINT nBlockSize=10) 
		: m_mkv(sizeof(void FAR*), sizeof(UINT), nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(UINT key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(UINT key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(UINT key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(UINT key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(UINT)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, UINT FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(UINT key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(UINT)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#ifndef __PLEX_H__
#define __PLEX_H__

struct FAR CPlex    // warning variable length structure
{
	CPlex FAR* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	INTERNAL_(void FAR*) data() { return this+1; }

	static INTERNAL_(CPlex FAR*) Create(CPlex FAR* FAR& head, UINT nMax, UINT cbElement);

	INTERNAL_(void) FreeDataChain();       // free this one and links
};

#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\resource.h ===
#define CURNONE  1
#define CURMOVE  2
#define CURCOPY  3
#define CURLINK  4
#define CURSCROLLMOVE 5
#define CURSCROLLCOPY 6
#define CURSCROLLLINK 7

// used by "..\src\def\geticon.c"
#define DEFICON 8

// used by the StdProgressIndicator dialog
#define IDD_DIALOG1                     101
#define IDC_TEXT                        102
#define IDC_PROGRESS1                   1000
// text for the cancel message
#define IDS_CAPTION                     201
#define IDS_TEXT                        202
// clipboard format strings
#define IDS_OBJECTLINK                  203
#define IDS_OWNERLINK                   204
#define IDS_NATIVE                      205
#define IDS_BINARY                      206
#define IDS_FILENAME                    207
#define IDS_FILENAMEW                   208
#define IDS_NETWORKNAME                 209
#define IDS_DATAOBJECT                  210
#define IDS_EMBEDDEDOBJECT              211
#define IDS_EMBEDSOURCE                 212
#define IDS_CUSTOMLINKSOURCE            213
#define IDS_LINKSOURCE                  214
#define IDS_OBJECTDESCRIPTOR            215
#define IDS_LINKSOURCEDESCRIPTOR        216
#define IDS_OLEDRAW                     217
#define IDS_PBRUSH                      218
#define IDS_MSDRAW                      219
#define IDS_OLEPRIVATEDATA              220
#define IDS_SCREENPICTURE               221
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\privguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       privguid.h
//
//  Contents:   This file is the master definition of all OLE2 product
//              GUIDs (public and private).
//
// * All GUIDs used by the ole32 product are of the form:
//
//              xxxxxxxx-xxxx-xxxY-C000-000000000046
//
//              This range is broken down as follows:
//
//         000000xx-0000-0000-C000-000000000046 compobj IIDs
//         000001xx-0000-0000-C000-000000000046 ole2 IIDs
//         000002xx-0000-0000-C000-000000000046 16bit ole2 smoke test
//         000003xx-0000-0000-C000-000000000046 ole2 CLSIDs
//         000004xx-0000-0000-C000-000000000046 ole2 sample apps (see DouglasH)
//
//              Other interesting ranges are as follows:
//
//         0003xxxx-0000-0000-C000-000000000046 ole1 CLSIDs (ole1cls.h)
//         0004xxxx-0000-0000-C000-000000000046 hashed ole1 CLSIDs
//
//  History:
//              24-Oct-94 BruceMa   Added this file header
//              24-Oct-94 BruceMa   Added IMallocSpy
//              07-Dec-01 JohnDoty  Added IInitializeSpy, brought up to 
//                                  date with version in oledrt, to make
//                                  this one the master list.
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////
// Range 0x000 - 0x0ff : compobj IIDs -
//             IID_IUnknown,            0x00000000L
//             IID_IClassFactory,       0x00000001L
//             IID_IMalloc,             0x00000002L
//             IID_IMarshal,            0x00000003L

//             IID_ILockBytes,          0x0000000aL
//             IID_IStorage,            0x0000000bL
//             IID_IStream,             0x0000000cL
//             IID_IEnumSTATSTG,        0x0000000dL

//             IID_IBindCtx,            0x0000000eL
//             IID_IMoniker,            0x0000000fL
//             IID_IRunningObjectTable, 0x00000010L
//             IID_IInternalMoniker,    0x00000011L

//             IID_IRootStorage,        0x00000012L
//             IID_IDfReserved1,        0x00000013L
//             IID_IDfReserved2,        0x00000014L
//             IID_IDfReserved3,        0x00000015L

//             IID_IMessageFilter,      0x00000016L

//             CLSID_StdMarshal,        0x00000017L

//             IID_IStdMarshalInfo,     0x00000018L

//             IID_IExternalConnection, 0x00000019L

//             IID_IWeakRef,            0x0000001aL

/* interface for subpieces of standard remoting */
DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);
DEFINE_OLEGUID(IID_IRemoteHdlr,         0x0000001cL, 0, 0);

//             IID_IMallocSpyf,         0x0000001dL, 0, 0);

//             IID_ITrackingMoniker,    0x0000001eL

//             IID_IMultiQI,            0x00000020L
//             IID_IInternalUnknown,    0x00000021L, 0, 0);
//             IID_ISurrogate,          0x00000022L, 0, 0);
//             IID_ISynchronize,        0x00000023L  obsolete
//             IID_IAsyncSetup          0x00000024L  obsolete
//             IID_ISynchronizeMutex,   0x00000025L
//             IID_IUrlMon,             0x00000026L
//             CLSID_AggStdMarshal,     0x00000027L
//             IID_IDebugMalloc,        0x00000028L
//             IID_IAsyncManager        0x0000002AL
//             IID_IWaitMultiple        0x0000002BL  obsolete
//             IID_ISynchronizeEvent    0x0000002CL  obsolete
//             IID_ITypeMarshal         0x0000002DL
//             IID_ITypeFactory         0x0000002EL
//             IID_IRecordInfo          0x0000002FL
//             IID_ISynchronize,        0x00000030L
//             IID_ISynchronizeHandle,  0x00000031L
//             IID_ISynchronizeEvent,   0x00000032L
//             IID_ISynchronizeContainer, 0x00000033L
//             IID_IInitializeSpy       0x00000034L

/* NOTE: LSB values 0x30 through 0xff are unused */

////////////////////////////////////////////////////////////////////////////
// Range 0x100 - 0x180 : upper layer IIDs -
//             IID_IEnumUnknown,        0x00000100L
//             IID_IEnumString,         0x00000101L
//             IID_IEnumMoniker,        0x00000102L
//             IID_IEnumFORMATETC,      0x00000103L
//             IID_IEnumOLEVERB,        0x00000104L
//             IID_IEnumSTATDATA,       0x00000105L

//             IID_IEnumGeneric,        0x00000106L
//             IID_IEnumHolder,         0x00000107L
//             IID_IEnumCallback,       0x00000108L

//             IID_IPersistStream,      0x00000109L
//             IID_IPersistStorage,     0x0000010aL
//             IID_IPersistFile,        0x0000010bL
//             IID_IPersist,            0x0000010cL

//             IID_IViewObject,         0x0000010dL
//             IID_IDataObject,         0x0000010eL
//             IID_IAdviseSink,         0x0000010fL
//             IID_IDataAdviseHolder,   0x00000110L
//             IID_IOleAdviseHolder,    0x00000111L

//             IID_IOleObject,          0x00000112L
//             IID_IOleInPlaceObject,   0x00000113L
//             IID_IOleWindow,          0x00000114L
//             IID_IOleInPlaceUIWindow, 0x00000115L
//             IID_IOleInPlaceFrame,    0x00000116L
//             IID_IOleInPlaceActiveObject, 0x00000117L

//             IID_IOleClientSite,      0x00000118L
//             IID_IOleInPlaceSite,     0x00000119L

//             IID_IParseDisplayName,   0x0000011aL
//             IID_IOleContainer,       0x0000011bL
//             IID_IOleItemContainer,   0x0000011cL

//             IID_IOleLink,            0x0000011dL
//             IID_IOleCache,           0x0000011eL
//             IID_IOleManager,         0x0000011fL
//             IID_IOlePresObj,         0x00000120L

//             IID_IDropSource,         0x00000121L
//             IID_IDropTarget,         0x00000122L

//             IID_IDebug,              0x00000123L
//             IID_IDebugStream,        0x00000124L

//             IID_IAdviseSink2,        0x00000125L

//             IID_IRunnableObject,     0x00000126L

//             IID_IViewObject2,        0x00000127L
//             IID_IOleCache2,          0x00000128L
//             IID_IOleCacheControl,    0x00000129L
//             IID_IContinue,           0x0000012AL

//             IID_IDocConnect,         0x00000130L
//             IID_IRemUnknown,         0x00000131L
//             IID_ILocalSystemActivator, 0x00000132L
//             IID_IOSCM,               0x00000133L
//             IID_IRundown,            0x00000134L
//             IID_InterfaceFromWindowProp, 0x00000135L
//             IID_IDSCM                0x00000136L
//             IID_IObjClient           0x00000137L

/* NOTE: LSB values 0x2a through 0xff are unused */

//             IID_IPropertyStorage,    0x00000138L
//             IID_IEnumSTATPROPSTG,    0x00000139L
//             IID_IPropertySetStorage, 0x0000013AL
//             IID_IEnumSTATPROPSETSTG, 0x0000013BL

//             IID_IRemUnknownN,        0x0000013CL
//             IID_INonNDRStub,         0x0000013DL
DEFINE_OLEGUID(IID_INonNDRStub, 0x0000013DL, 0, 0);


//             IID_IClientSecurity      0x0000013DL
//             IID_IServerSecurity      0x0000013EL
//
//             IID_IMacDragHelper       0x0000013FL

//             IID_IClassActivator      0x00000140L
//             IID_IDLLHost             0x00000141L
//             IID_IRemoteQI            0x00000142L
//             IID_IRemUnknown2,        0x00000143L
//             IID_IRPCOptions          0x00000144L


//             IID_IForegroundTransfer  0x00000145L
//             IID_IGlobalInterfaceTable 0x00000146L
//             IID_IPrivateStorage      0x00000147L
DEFINE_OLEGUID(IID_IPrivateStorage, 0x00000147L, 0, 0);
//             IID_IComBinding          0x00000148L
//             IID_IRpcHelper           0x00000149L

//             IID_IAsyncRpcBuffer      0x00000148L
//             IID_ICallFactory         0x00000149L
//             IID_IDisconnectSink      0x0000014AL
//             IID_AsyncIAdviseSink     0x00000150L
//             IID_AsyncIAdviseSink2    0x00000151L
//             IID_CPPRpcChannelBuffer  0x00000152L
//             IID_IMiniMoniker         0x00000153L
//             IID_IStdCallObject       0x00000154L
DEFINE_OLEGUID(IID_IStdCallObject,      0x00000154L, 0, 0);
//             IID_IMacDragObject       0x00000155L
//             IID_IAssertConfig        0x00000156L
//             IID_IStackWalkerSymbol   0x00000157L
//             IID_IStackWalkerStack    0x00000158L
//             IID_IStackWalker         0x00000159L
//             IID_ILocalMachineName    0x0000015AL
//             IID_IGlobalOptions       0x0000015BL

DEFINE_OLEGUID(IID_IStdPolicySet,       0x000001c7L, 0, 0);
DEFINE_OLEGUID(IID_IStdObjectContext,   0x000001c9L, 0, 0);
DEFINE_OLEGUID(IID_IStdWrapper,         0x000001caL, 0, 0);
DEFINE_OLEGUID(IID_IStdCtxChnl,         0x000001ccL, 0, 0);
DEFINE_OLEGUID(IID_IDestInfo,           0x000001cdL, 0, 0);
DEFINE_OLEGUID(IID_IStdFreeMarshal,     0x000001d0L, 0, 0);
DEFINE_OLEGUID(IID_IStdIDObject,        0x000001d1L, 0, 0);

// Range 0x180 - 0x18F is reserved for the category interfaces.
//             IID_?                    0x00000180L
//             IID_?                    0x00000181L
//             IID_?                    0x00000182L
//             IID_?                    0x00000183L
//             IID_?                    0x00000184L
//             IID_?                    0x00000185L
//             IID_?                    0x00000186L
//             IID_?                    0x00000187L
//             IID_?                    0x00000188L
//             IID_?                    0x00000189L
//             IID_?                    0x0000018AL
//             IID_?                    0x0000018BL
//             IID_?                    0x0000018CL
//             IID_?                    0x0000018DL
//             IID_?                    0x0000018EL
//             IID_?                    0x0000018FL

//
// Range 0x1a0 - 0x1bF is reserved for Activation interfaces
//             IID_ISystemActivator       0x000001a0L
//             IID_IInitActivationProperties 0x000001a1L
//             IID_IActivationPropertiesIn 0x000001a2L
//             IID_IActivationPropertiesOut 0x000001a3L
//             IID_IServerLocationInfo    0x000001a4L
//             IID_IActivationContextInfo 0x000001a5L
//             IID_ISecurityInfo          0x000001a6L
//             IID_IActivationAgentInfo   0x000001a7L
//             IID_IActivationStageInfo   0x000001a8L
//             IID_IOpaqueDataInfo        0x000001a9L
//             IID_IScmRequestInfo        0x000001aAL
//             IID_IInstantiationInfo     0x000001aBL
//             IID_ILegacyInfo            0x000001aCL
//             IID_IInstanceInfo          0x000001aDL
//             IID_IPrivActivationContextInfo 0x000001aEL
//             IID_IActivationProperties  0x000001aFL
//             IID_IPrivActivationPropertiesOut 0x000001b0L
//             IID_ISerializableParent    0x000001b1L
//             IID_ISerializable          0x000001b2L
//             IID_ISerializer            0x000001b3L
//             IID_IBuffer                0x000001b4L
//             IID_IPrivActivationPropertiesIn 0x000001b5L
//             IID_IScmReplyInfo          0x000001b6L
//             IID_IActivator             0x000001b7L
//             IID_IStandardActivator     0x000001b8L
//             IID_ISpecialSystemProperties 0x000001b9L


//
// Range 0x1c0 - 0x1dE is reserved for Context interfaces
//             IID_IContext               0x000001c0L
//             IID_IEnumContextProperties 0x000001c1L
//             IID_IPolicy                0x000001c2L
//             IID_IPolicySet             0x000001c3L
//             IID_IPolicyMaker           0x000001c4L
//             IID_RpcCall                0x000001c5L
//             IID_IObjContext            0x000001c6L
//             IID_IStdPolicySet          0x000001c7L
//             IID_IMarshalEnvoy          0x000001c8L
//             IID_IStdObjectContext      0x000001c9L
//             IID_IStdWrapper            0x000001cAL
//             IID_ICallback              0x000001cBL
//             IID_IStdCtxChnl            0x000001cCL
//             IID_IDestInfo              0x000001cDL
//             IID_IComThreadingInfo      0x000001cEL
//             IID_IMarshal2              0x000001cFL
//             IID_IStdFreeMarshaler      0x000001d0L
//             IID_IStdIDObject           0x000001d1L
//             IID_IPAControl             0x000001d2L
//             IID_IServicesSink          0x000001d3L
//             IID_ISurrogateService      0x000001d4L
//             IID_IProcessLock           0x000001d5L
//             IID_ICall                  0x000001d6L
//             IID_IComObjectIdentity     0x000001d7L
//             IID_IAggregator            0x000001d8L
//             IID_IComDispatchInfo       0x000001d9L
//             IID_IContextCallback       0x000001daL
//             IID_IInternalCtxUnknown    0x000001dcL




//
// Range 0x1df - 0x1ff is reserved for Class Info interfaces
//             IID_IClassClassicInfo2      0x000001dfL
//             IID_IComCatalog             0x000001e0L
//             IID_IComClassInfo           0x000001e1L
//             IID_IClassClassicInfo       0x000001e2L
//             IID_IComApplInfo2           0x000001e3L
//             IID_IComClassInfo2          0x000001e4L
//             IID_IClassActivityInfo      0x000001e5L
//             IID_IClassTransactionInfo   0x000001e6L
//             IID_IClassJitActivationInfo 0x000001e7L
//             IID_IClassSecurityInfo      0x000001e8L
//             IID_IClassRetInfo           0x000001e9L
//             IID_IClassLoadBalancingInfo 0x000001eaL
//             IID_IClassObjectPoolingInfo 0x000001ebL
//             IID_IComApplInfo            0x000001ecL
//             IID_IComProcessInfo         0x000001edL
//             IID_IProcessServerInfo      0x000001eeL
//             IID_IRoleInfo               0x000001efL
//             IID_IServerGroupInfo        0x000001f0L
//             IID_IRetQueueInfo           0x000001f1L
//             IID_IPartitionProperty      0x000001f2L
//             IID_IClassIISIntrinsics     0x000001f3L
//             IID_IClassComTIIntrinsics   0x000001f4L
//             IID_IComServices            0x000001f5L
//             IID_IClassTrackingInfo      0x000001f6L
//             IID_IInterfaceInfo          0x000001f7L
//             IID_IPartitionLookup        0x000001f8L
//             IID_IConstructString        0x000001f9L
//             IID_IComCatalog2            0x000001faL
//             IID_IReplaceClassInfo       0x000001fbL
//             IID_IUserToken              0x000001fcL
//             IID_IComCatalogSCM          0x000001fdL
//             IID_IGetCatalogObject       0x000001feL
//             IID_IComCatalogSettings     0x000001ffL
//
//
DEFINE_OLEGUID(IID_IPropertyStorage_Old,    0x66600014, 0, 8);
DEFINE_OLEGUID(IID_IEnumSTATPROPSTG_Old,    0x66600015, 0, 8);
DEFINE_OLEGUID(IID_IPropertySetStorage_Old, 0x66650000L, 0, 8);
DEFINE_OLEGUID(IID_IEnumSTATPROPSETSTG_Old, 0x66650001L, 0, 8);


////////////////////////////////////////////////////////////////////////////
// Range 0x300 - 0x3ff : internal CLSIDs

// Don't change this
#define MIN_INTERNAL_CLSID 0x00000300

DEFINE_OLEGUID(CLSID_StdOleLink,        0x00000300, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemStm,         0x00000301, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemBytes,       0x00000302, 0, 0);
DEFINE_OLEGUID(CLSID_FileMoniker,       0x00000303, 0, 0);
DEFINE_OLEGUID(CLSID_ItemMoniker,       0x00000304, 0, 0);
DEFINE_OLEGUID(CLSID_AntiMoniker,       0x00000305, 0, 0);
DEFINE_OLEGUID(CLSID_PointerMoniker,    0x00000306, 0, 0);
// NOT TO BE USED                       0x00000307, 0, 0);
DEFINE_OLEGUID(CLSID_PackagerMoniker,   0x00000308, 0, 0);
DEFINE_OLEGUID(CLSID_CompositeMoniker,  0x00000309, 0, 0);
// NOT TO BE USED                       0x0000030a, 0, 0);
DEFINE_OLEGUID(CLSID_DfMarshal,         0x0000030b, 0, 0);

// NOT TO BE USED 0x30c - 0x315 - old PS CLSID's

//             CLSID_Picture_Metafile,  0x00000315
//             CLSID_Picture_Dib,       0x00000316

DEFINE_OLEGUID(CLSID_RemoteHdlr,        0x00000317, 0, 0);
DEFINE_OLEGUID(CLSID_RpcChannelBuffer,  0x00000318, 0, 0);
//             CLSID_Picture_EnhMetafile,0x00000319
DEFINE_OLEGUID(CLSID_ClassMoniker,      0x0000031A, 0, 0);
DEFINE_OLEGUID(CLSID_ErrorObject,       0x0000031B, 0, 0);
DEFINE_OLEGUID(ERROR_EXTENSION,         0x0000031C, 0, 0);
//             CLSID_DCOMAccessControl, 0x0000031D
DEFINE_OLEGUID(CLSID_MachineMoniker,    0x0000031E, 0, 0);
DEFINE_OLEGUID(CLSID_UrlMonWrapper,     0x0000031F, 0, 0);


DEFINE_OLEGUID(CLSID_PSOlePrx32,        0x00000320, 0, 0);
DEFINE_OLEGUID(IID_ITrackingMoniker,    0x00000321, 0, 0);
DEFINE_OLEGUID(CLSID_StaticMarshal,     0x00000322, 0, 0);
DEFINE_OLEGUID(CLSID_StdGlobalInterfaceTable, 0x00000323, 0, 0);
//DEFINE_OLEGUID(CLSID_Synchronize_AutoComplete,     0x00000324, 0, 0); //obsolete
//DEFINE_OLEGUID(CLSID_Synchronize_ManualResetEvent, 0x00000325, 0, 0); //obsolete
//DEFINE_OLEGUID(CLSID_WaitMultiple,                 0x00000326, 0, 0); //obsolete

// OBJREF Moniker                                  0x00000327
DEFINE_OLEGUID(CLSID_ObjrefMoniker,                0x00000327, 0, 0);
DEFINE_OLEGUID(CLSID_ComBinding,                   0x00000328, 0, 0);
DEFINE_OLEGUID(CLSID_StdAsyncManager,              0x00000329, 0, 0);
DEFINE_OLEGUID(CLSID_RpcHelper,                    0x0000032a, 0, 0);

DEFINE_OLEGUID(CLSID_StdEvent,                     0x0000032b, 0, 0);
DEFINE_OLEGUID(CLSID_ManualResetEvent,             0x0000032c, 0, 0);
DEFINE_OLEGUID(CLSID_SynchronizeContainer,         0x0000032d, 0, 0);
DEFINE_OLEGUID(CLSID_PipePSFactory,                0x0000032e, 0, 0);

// CLSID_AllClasses,                               0x00000330
// CLSID_LocalMachineClasses,                      0x00000331
// CLSID_CurrentUserClasses,                       0x00000332
// CLSID_PolicySet                                 0x00000333
DEFINE_OLEGUID(CONTEXT_EXTENSION,                  0x00000334, 0, 0);
DEFINE_OLEGUID(CLSID_ObjectContext,                0x00000335, 0, 0);
DEFINE_OLEGUID(CLSID_StdWrapper,                   0x00000336, 0, 0);
//DEFINE_OLEGUID(CLSID_StdWrapperUnmarshaler,      0x00000337, 0, 0);
DEFINE_OLEGUID(CLSID_ActivationPropertiesIn,       0x00000338, 0, 0);
DEFINE_OLEGUID(CLSID_ActivationPropertiesOut,      0x00000339, 0, 0);
DEFINE_OLEGUID(CLSID_InProcFreeMarshaler,          0x0000033a, 0, 0);
DEFINE_OLEGUID(CLSID_ContextMarshaler,             0x0000033b, 0, 0);
DEFINE_OLEGUID(CLSID_ComActivator,                 0x0000033c, 0, 0);
DEFINE_OLEGUID(CLSID_UserContextMarshaler,         0x0000033d, 0, 0);
//DEFINE_OLEGUID(SERVERHR_EXTENSION,               0x0000033e, 0, 0);


DEFINE_OLEGUID(CLSID_RemoteUnknownPSFactory,       0x00000340, 0, 0);
DEFINE_OLEGUID(CLSID_ATHostActivator,              0x00000341, 0, 0);
DEFINE_OLEGUID(CLSID_MTHostActivator,              0x00000342, 0, 0);
DEFINE_OLEGUID(CLSID_NTHostActivator,              0x00000343, 0, 0);

DEFINE_OLEGUID(CLSID_InprocActpropsUnmarshaller,   0x00000344, 0, 0);
DEFINE_OLEGUID(CLSID_ActivationProperties,         0x00000345, 0, 0);

// Catalog object
DEFINE_OLEGUID(CLSID_COMCatalog,                   0x00000346, 0, 0);

// for the session moniker; created by gilleg
DEFINE_OLEGUID(CLSID_SessionMoniker,               0x00000347, 0, 0);

// assertion and logging API
//DEFINE_OLEGUID(CLSID_AssertionAPI,               0x00000348, 0, 0);
// Change this if you need another slot for internal clsid

// Stackwalking
DEFINE_OLEGUID(CLSID_StackWalker,                   0x00000349, 0, 0);

// Local machine name comparisons
DEFINE_OLEGUID(CLSID_LocalMachineNames,             0x0000034a, 0, 0);

// Set Global options in ole32
DEFINE_OLEGUID(CLSID_GlobalOptions,                 0x0000034b, 0, 0);

#define MAX_INTERNAL_CLSID              0x0000034c

// These guids are not implemented by ole32, so they are not in the 
// "internal clsid" range.  I started them at the top of the reserved
// range, working backwards.
DEFINE_OLEGUID(CLSID_RPCSSInfo,                     0x000003FF, 0, 0);

DEFINE_OLEGUID(CLSID_ServerHandler,     0x00020322, 0, 0);
DEFINE_OLEGUID(CLSID_ClientSiteHandler, 0x00020323, 0, 0);
DEFINE_OLEGUID(CLSID_PSDispatch,        0x00020420, 0, 0);

/* NOTE: LSB values 0x1a through 0xff are unused */

DEFINE_OLEGUID(IID_IHookOleObject,      0x0002AD11, 0, 0);

DEFINE_OLEGUID(CLSID_StdComponentCategoriesMgr, 0x0002E005, 0, 0);
DEFINE_OLEGUID(CLSID_GblComponentCategoriesMgr, 0x0002E006, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\stdidx.h ===
#ifndef _STDIDX_H_
#define _STDIDX_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL IsInterfaceImplementedByProxy(REFIID riid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\privoa.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       privoa.h
//
//  Contents:   Definitions for OleAut32.dll wrappers
//
//  Classes:
//
//  History:    20-Jun-96 MikeHill  Created.
//              06-May-98 MikeHill  Added SafeArray wrappers.
//
//  Notes:
//      This file has macros, function prototypes, and global
//      externs that enable the OleAut32 wrapper functions.
//      These functions load OleAut32.dll if necessary, and forward
//      the call.
//
//----------------------------------------------------------------------------

#ifndef _PRIV_OA_H_
#define _PRIV_OA_H_

// OleAut32 function prototypes

typedef BSTR (STDAPICALLTYPE SYS_ALLOC_STRING)(LPCOLESTR pwsz);
typedef VOID (STDAPICALLTYPE SYS_FREE_STRING)(BSTR bstr);
typedef BOOL (STDAPICALLTYPE SYS_REALLOC_STRING_LEN)(BSTR* pbstr, OLECHAR* pch, UINT cch);
typedef UINT (STDAPICALLTYPE SYS_STRING_BYTE_LEN)(BSTR bstr);
typedef UINT (STDAPICALLTYPE FNTYPE_SysStringLen)(BSTR bstr);

typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_ACCESS_DATA)(SAFEARRAY * psa, void HUGEP** ppvData);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_GET_L_BOUND)(SAFEARRAY * psa, UINT nDim, LONG * plLbound);
typedef UINT    (STDAPICALLTYPE SAFE_ARRAY_GET_DIM)(SAFEARRAY * psa);
typedef UINT    (STDAPICALLTYPE SAFE_ARRAY_GET_ELEM_SIZE)(SAFEARRAY * psa);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_GET_U_BOUND)(SAFEARRAY * psa, UINT nDim, LONG * plUbound);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_UNACCESS_DATA)(SAFEARRAY * psa);
typedef SAFEARRAY* (STDAPICALLTYPE SAFE_ARRAY_CREATE_EX)(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound, PVOID pvExtra);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_GET_VARTYPE)(SAFEARRAY * psa, VARTYPE * pvt);

typedef SAFEARRAY* (STDAPICALLTYPE FNTYPE_SafeArrayCreate)(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound);
typedef HRESULT    (STDAPICALLTYPE FNTYPE_SafeArrayPutElement)(SAFEARRAY* psa, long* pIdx, void* pv );
typedef HRESULT    (STDAPICALLTYPE FNTYPE_SafeArrayDestroy)(SAFEARRAY* psa );

typedef void    (STDAPICALLTYPE FNTYPE_VariantInit)(VARIANTARG * pvarg);
typedef HRESULT (STDAPICALLTYPE FNTYPE_VariantClear)(VARIANTARG * pvarg);
typedef HRESULT (STDAPICALLTYPE FNTYPE_VariantCopy)(VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
typedef HRESULT (STDAPICALLTYPE FNTYPE_VariantChangeTypeEx)(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt);


typedef unsigned long             BSTR_USER_SIZE      (     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * BSTR_USER_MARSHAL   (  unsigned long __RPC_FAR *, unsigned char __RPC_FAR*, BSTR __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * BSTR_USER_UNMARSHAL (unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
typedef void                      BSTR_USER_FREE      (     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

typedef unsigned long             LPSAFEARRAY_USER_SIZE       (     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * LPSAFEARRAY_USER_MARSHAL    (  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * LPSAFEARRAY_USER_UNMARSHAL  (unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
typedef void                      LPSAFEARRAY_USER_FREE       (     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 


// The Wrapper routines, and function pointers for them.

#define DECLARE_OLEAUT_FUNCTION( fname )    \
    FNTYPE_##fname  Load##fname;            \
    EXTERN_C FNTYPE_##fname *pfn##fname;


SYS_ALLOC_STRING  LoadSysAllocString;
EXTERN_C SYS_ALLOC_STRING *pfnSysAllocString;

SYS_FREE_STRING  LoadSysFreeString;
EXTERN_C SYS_FREE_STRING *pfnSysFreeString;

SYS_REALLOC_STRING_LEN  LoadSysReAllocStringLen;
EXTERN_C SYS_REALLOC_STRING_LEN *pfnSysReAllocStringLen;

SYS_STRING_BYTE_LEN LoadSysStringByteLen;
EXTERN_C SYS_STRING_BYTE_LEN *pfnSysStringByteLen;

DECLARE_OLEAUT_FUNCTION( SysStringLen );

SAFE_ARRAY_ACCESS_DATA LoadSafeArrayAccessData;
EXTERN_C SAFE_ARRAY_ACCESS_DATA *pfnSafeArrayAccessData;

SAFE_ARRAY_GET_L_BOUND LoadSafeArrayGetLBound;
EXTERN_C SAFE_ARRAY_GET_L_BOUND *pfnSafeArrayGetLBound;

SAFE_ARRAY_GET_DIM LoadSafeArrayGetDim;
EXTERN_C SAFE_ARRAY_GET_DIM *pfnSafeArrayGetDim;

SAFE_ARRAY_GET_ELEM_SIZE LoadSafeArrayGetElemsize;
EXTERN_C SAFE_ARRAY_GET_ELEM_SIZE *pfnSafeArrayGetElemsize;

SAFE_ARRAY_GET_U_BOUND LoadSafeArrayGetUBound;
EXTERN_C SAFE_ARRAY_GET_U_BOUND *pfnSafeArrayGetUBound;

SAFE_ARRAY_GET_VARTYPE LoadSafeArrayGetVartype;
EXTERN_C SAFE_ARRAY_GET_VARTYPE *pfnSafeArrayGetVartype;

SAFE_ARRAY_UNACCESS_DATA LoadSafeArrayUnaccessData;
EXTERN_C SAFE_ARRAY_UNACCESS_DATA *pfnSafeArrayUnaccessData;

SAFE_ARRAY_CREATE_EX LoadSafeArrayCreateEx;
EXTERN_C SAFE_ARRAY_CREATE_EX *pfnSafeArrayCreateEx;

DECLARE_OLEAUT_FUNCTION( SafeArrayCreate );
DECLARE_OLEAUT_FUNCTION( SafeArrayPutElement );
DECLARE_OLEAUT_FUNCTION( SafeArrayDestroy );

DECLARE_OLEAUT_FUNCTION( VariantClear );
DECLARE_OLEAUT_FUNCTION( VariantInit );
DECLARE_OLEAUT_FUNCTION( VariantCopy );
DECLARE_OLEAUT_FUNCTION( VariantChangeTypeEx );


EXTERN_C BSTR_USER_SIZE LoadBSTR_UserSize;
EXTERN_C BSTR_USER_SIZE *pfnBSTR_UserSize;

EXTERN_C BSTR_USER_MARSHAL LoadBSTR_UserMarshal;
EXTERN_C BSTR_USER_MARSHAL *pfnBSTR_UserMarshal;

EXTERN_C BSTR_USER_UNMARSHAL LoadBSTR_UserUnmarshal;
EXTERN_C BSTR_USER_UNMARSHAL *pfnBSTR_UserUnmarshal;

EXTERN_C BSTR_USER_FREE LoadBSTR_UserFree;
EXTERN_C BSTR_USER_FREE *pfnBSTR_UserFree;

EXTERN_C LPSAFEARRAY_USER_SIZE LoadLPSAFEARRAY_UserSize;
EXTERN_C LPSAFEARRAY_USER_SIZE *pfnLPSAFEARRAY_UserSize;

EXTERN_C LPSAFEARRAY_USER_MARSHAL LoadLPSAFEARRAY_UserMarshal;
EXTERN_C LPSAFEARRAY_USER_MARSHAL *pfnLPSAFEARRAY_UserMarshal;

EXTERN_C LPSAFEARRAY_USER_UNMARSHAL LoadLPSAFEARRAY_UserUnmarshal;
EXTERN_C LPSAFEARRAY_USER_UNMARSHAL *pfnLPSAFEARRAY_UserUnmarshal;

EXTERN_C LPSAFEARRAY_USER_FREE LoadLPSAFEARRAY_UserFree;
EXTERN_C LPSAFEARRAY_USER_FREE *pfnLPSAFEARRAY_UserFree;


// Macros to ease the calling of the above function pointers

#define PrivSysAllocString(pwsz)                    (*pfnSysAllocString)(pwsz)
#define PrivSysFreeString(bstr)                     (*pfnSysFreeString)(bstr)
#define PrivSysReAllocStringLen(pbstr,olestr,ui)    (*pfnSysReAllocStringLen)(pbstr, olestr, ui)
#define PrivSysStringByteLen(pbstr)                 (*pfnSysStringByteLen)(pbstr)
#define PrivSysStringLen(pbstr)                     (*pfnSysStringByteLen)(pbstr)

#define PrivSafeArrayAccessData(psa,ppvData)        (*pfnSafeArrayAccessData)(psa, ppvData )
#define PrivSafeArrayGetLBound(psa,nDim, plLbound)  (*pfnSafeArrayGetLBound)( psa, nDim, plLbound )
#define PrivSafeArrayGetDim(psa)                    (*pfnSafeArrayGetDim)( psa )
#define PrivSafeArrayGetElemsize(psa)               (*pfnSafeArrayGetElemsize)( psa )
#define PrivSafeArrayGetUBound(psa,nDim, plUbound)  (*pfnSafeArrayGetUBound)( psa, nDim, plUbound )
#define PrivSafeArrayGetVartype(psa, pvt)           (*pfnSafeArrayGetVartype)( psa, pvt )
#define PrivSafeArrayUnaccessData(psa)              (*pfnSafeArrayUnaccessData)( psa )
#define PrivSafeArrayCreateEx(vt,cDims,rgsabound,pvExtra) \
                                                    (*pfnSafeArrayCreateEx)(vt, cDims, rgsabound, pvExtra)
#define PrivSafeArrayCreate(vt,cDims,rgsabound)     (*pfnSafeArrayCreate)(vt, cDims, rgsabound)
#define PrivSafeArrayPutElement(psa, pIdx, pv)      (*pfnSafeArrayPutElement)(psa, pIdx, pv)
#define PrivSafeArrayDestroy( psa )                 (*pfnSafeArrayDestroy)(psa)

#define PrivVariantClear(pvarg)                     (*pfnVariantClear)( pvarg )
#define PrivVariantInit(pvarg)                      (*pfnVariantInit)(pvarg)
#define PrivVariantCopy(pvargDest,pvargSrc)         (*pfnVariantCopy)( pvargDest, pvargSrc )
#define PrivVariantChangeTypeEx(pvargDest,pvarSrc,lcid,wFlags,vt)   \
                                                    (*pfnVariantChangeTypeEx)( pvargDest, pvarSrc, lcid, wFlags, vt )

                

#endif // ! _PRIV_OA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\thkreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       thkreg.cxx
//
//  Contents:   Contains constants used to read the registry for modifiable
//              WOW behavior for OLE.
//
//  History:    22-Jul-94 Ricksa    Created
//		09-Jun-95 Susia	    Chicago optimization added
//
//--------------------------------------------------------------------------
#ifndef _THKREG_H_
#define _THKREG_H_


// Name of key for OLE WOW special behavior
#define OLETHK_KEY                  TEXT("OleCompatibility")  
// Factor by which to slow duration of WOW RPC calls
#define OLETHK_SLOWRPCTIME_VALUE    TEXT("SlowRpcTimeFactor")

// Default factor to slow duration of WOW RPC calls
#define OLETHK_DEFAULT_SLOWRPCTIME 4

#endif // _THKREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\stkswtch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       stkswtch.h
//
//  Contents:   Stack Switching proto types and macros
//
//  Classes:
//
//  Functions:
//
//  History:    12-10-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#ifndef _STKSWTCH_
#define _STKSWTCH_

// For non-chicago platrforms: define all SSxxx APIs
// back to the original user api

#define SSSendMessage                  	SendMessage
#define SSReplyMessage                 	ReplyMessage
#define SSCallWindowProc               	CallWindowProc
#define SSDefWindowProc                	DefWindowProc
#define SSPeekMessage  	    		PeekMessage
#define SSGetMessage		    	GetMessage
#define SSDispatchMessage		DispatchMessage
#define SSWaitMessage			WaitMessage
#define SSMsgWaitForMultipleObjects	MsgWaitForMultipleObjects
#define SSDirectedYield  	    	DirectedYield
#define SSDialogBoxParam		DialogBoxParam
#define SSDialogBoxIndirectParam  	DialogBoxIndirectParam
#define SSCreateWindowExA              	CreateWindowExA
#define SSCreateWindowExW              	CreateWindowExW
#define SSDestroyWindow                	DestroyWindow
#define SSMessageBox			MessageBox

#define SSOpenClipboard             	OpenClipboard
#define SSCloseClipboard              	CloseClipboard
#define SSGetClipboardOwner           	GetClipboardOwner
#define SSSetClipboardData            	SetClipboardData
#define SSGetClipboardData          	GetClipboardData
#define SSRegisterClipboardFormatA    	RegisterClipboardFormatA
#define SSEnumClipboardFormats        	EnumClipboardFormats
#define SSGetClipboardFormatNameA     	GetClipboardFormatNameA
#define SSEmptyClipboard              	EmptyClipboard
#define SSIsClipboardFormatAvailable  	IsClipboardFormatAvailable
#define SSCreateProcessA                CreateProcessA
#define SSInSendMessage                 InSendMessage
#define SSInSendMessageEx               InSendMessageEx

#define SSAPI(x) x
#define StackDebugOut(x)
#define StackAssert(x)
#define SSOnSmallStack()

#endif // _STKSWTCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\tls.h ===
//+---------------------------------------------------------------------------
//
//  File:       tls.hxx
//
//  Purpose:    manage thread local storage for OLE
//
//  Notes:      The gTlsIndex is initialized at process attach time.
//              The per-thread data is allocated in CoInitialize in
//              single-threaded apartments or on first use in
//              multi-threaded apartments.
//
//              The non-inline routines are in ..\com\class\tls.cxx
//
//  History:    16-Jun-94   BruceMa    Don't decrement 0 thread count
//              17-Jun-94   Bradloc    Added punkState for VB94
//              20-Jun-94   Rickhi     Commented better
//              06-Jul-94   BruceMa    Support for CoGetCurrentProcess
//              19-Jul-94   CraigWi    Removed TLSGetEvent (used cache instead)
//              21-Jul-94   AlexT      Add TLSIncOleInit, TLSDecOleInit
//              21-Aug-95   ShannonC   Removed TLSSetMalloc, TLSGetMalloc
//              06-Oct-95   Rickhi     Simplified. Made into a C++ class.
//              01-Feb-96   Rickhi     On Nt, access TEB directly
//              30-May-96   ShannonC   Add punkError
//              12-Sep-96   rogerg     Add pDataObjClip
//              26-Nov-96   Gopalk     Add IsOleInitialized
//              13-Jan-97   RichN      Add pContextObj
//              10-Feb-99   TarunA     Add cAsyncSends
//----------------------------------------------------------------------------
#ifndef _TLS_HXX_
#define _TLS_HXX_


#include <rpc.h>                            // UUID


//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx

//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct tagCallEntry
{
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;


//+-------------------------------------------------------------------
//
//  Struct:     LockEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
#define LOCKS_PER_ENTRY         16
typedef struct tagLockEntry
{
    tagLockEntry  *pNext;                // ptr to next entry
    WORD wReaderLevel[LOCKS_PER_ENTRY];  // reader nesting level
} LockEntry;


//+-------------------------------------------------------------------
//
//  Struct:     ContextStackNode
//
//  Synopsis:   Stack of contexts used with Services Without Components
//
//+-------------------------------------------------------------------
typedef struct tagContextStackNode
{
    tagContextStackNode* pNext;
    CObjectContext* pSavedContext;
    CObjectContext* pServerContext;
    CCtxCall* pClientCall;
    CCtxCall* pServerCall;
    CPolicySet* pPS;
} ContextStackNode;

//+-------------------------------------------------------------------
//
//  Struct:     InitializeSpyNode
//
//  Synopsis:   Node in a linked list of Initialize Spy registrations
//
//+-------------------------------------------------------------------
typedef struct tagInitializeSpyNode
{
    tagInitializeSpyNode *pNext;  
    tagInitializeSpyNode *pPrev;
    DWORD                 dwRefs;
    DWORD                 dwCookie;
    IInitializeSpy       *pInitSpy;
} InitializeSpyNode;

//+-------------------------------------------------------------------
//
//  Struct:     VerifierTlsData
//
//  Synopsis:   Per-thread data needed by the COM verifier
//
//+-------------------------------------------------------------------
typedef struct tagVerifierTlsData
{
    LPVOID rgpvLastInitStack[MAX_STACK_DEPTH];
    LPVOID rgpvLastUninitStack[MAX_STACK_DEPTH];
    LPVOID rgpvLastOleInitStack[MAX_STACK_DEPTH];
    LPVOID rgpvLastOleUninitStack[MAX_STACK_DEPTH];
    LPVOID rgpvLastEnterSWC[MAX_STACK_DEPTH];
    LPVOID rgpvLastLeaveSWC[MAX_STACK_DEPTH];
} VerifierTlsData;

//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
    // jsimmons 5/23/2001
    // Alert Alert:  nefarious folks (eg, URT) are looking in our TLS at
    // various stuff.   They expect that pCurrentCtx will be at a certain
    // offset from the beginning of the tls struct. So don't add, delete, or 
    // move any members within this block.

/////////////////////////////////////////////////////////////////////////////////////////
// ********* BEGIN "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    CSmAllocator       *pSmAllocator;       // per thread docfile allocator

    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    CMessageCall       *pCallInfo;          // channel call info
    CAsyncCall         *pFreeAsyncCall;     // ptr to available call object for this thread.
    CClientCall        *pFreeClientCall;    // ptr to available call object for this thread.

    CObjServer         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    CObjectContext     *pCurrentCtx;        // Current context
/////////////////////////////////////////////////////////////////////////////////////////
//  ********* END "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////

    CObjectContext     *pEmptyCtx;          // Empty context

    CObjectContext     *pNativeCtx;         // Native context
    ULONGLONG           ContextId;          // Uniquely identifies the current context
    CComApartment      *pNativeApt;         // Native apartment for the thread.
    IUnknown           *pCallContext;       // call context object
    CCtxCall           *pCtxCall;           // Context call object

    CPolicySet         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    CAptCallCtrl       *pCallCtrl;          // call control for RPC for this apartment

    CSrvCallState      *pTopSCS;            // top server-side callctrl state
    IMessageFilter     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    IUnknown           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    IDataObject         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    IUnknown            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    CAsyncCall*           pAsyncCallList;   // async calls outstanding
    CSurrogatedObjectList *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

    ContextStackNode* pContextStack;        // Context stack node for SWC.

    InitializeSpyNode  *pFirstSpyReg;       // First registered IInitializeSpy
    InitializeSpyNode  *pFirstFreeSpyReg;   // First available spy registration

    VerifierTlsData    *pVerifierData;      // Per-thread info for the COM verifier (if enabled)

    // Put small types here, for packing purposes
    DWORD               dwMaxSpy;           // First free IInitializeSpy cookie

    BYTE                cCustomMarshallerRecursion;     // Number of times the custom unmarshaller path (GetCustomUnmarshaler)
                                                        // has been taken recursively in CoUnmarshalInterface

    void               *pDragCursors;       // Per thread drag cursor table.

    IUnknown           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif
} SOleTlsData;

//
// Constants used by TLS entries
//

#define MAX_CUSTOM_MARSHALLER_RECURSION 16

//+---------------------------------------------------------------------------
//
//  class       COleTls
//
//  Synopsis:   class to abstract thread-local-storage in OLE.
//
//  Notes:      To use Tls in OLE, functions should define an instance of
//              this class on their stack, then use the -> operator on the
//              instance to access fields of the SOleTls structure.
//
//              There are two instances of the ctor. One just Assert's that
//              the SOleTlsData has already been allocated for this thread. Most
//              internal code should use this ctor, since we can assert that if
//              the thread made it this far into our code, tls has already been
//              checked.
//
//              The other ctor will check if SOleTlsData exists, and attempt to
//              allocate and initialize it if it does not. This ctor will
//              return an HRESULT. Functions that are entry points to OLE32
//              should use this version.
//
//+---------------------------------------------------------------------------
class COleTls
{
public:
    COleTls();
    COleTls(HRESULT &hr);
    COleTls(BOOL fDontAllocateIfNULL);

    // to get direct access to the data structure
    SOleTlsData * operator->(void) { return _pData; }
    operator SOleTlsData *()       { return _pData; }

    // Helper functions
    BOOL         IsNULL() { return (_pData == NULL) ? TRUE : FALSE; }

private:

    HRESULT      TLSAllocData(); // allocates an SOleTlsData structure

    SOleTlsData * _pData;        // ptr to OLE TLS data
};

extern SOleTlsData *TLSLookupThreadId(DWORD dwThreadId);


//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Most internal code should use this version of the ctor,
//              assuming that some outer-layer function has already verified
//              the existence of the tls_data.
//
//+---------------------------------------------------------------------------
__forceinline COleTls::COleTls()
{
    _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
    Win4Assert(_pData && "Illegal attempt to use TLS before Initialized");
}

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Special version for CoUninitialize which will not allocate
//              (or assert) if the TLS is NULL. It can then be checked with
//              IsNULL member function.
//
//+---------------------------------------------------------------------------
__forceinline COleTls::COleTls(BOOL fDontAllocateIfNULL)
{
    _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
}

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Peripheral OLE code that can not assume that some outer-layer
//              function has already verified the existence of the SOleTlsData
//              structure for the current thread should use this version of
//              the ctor.
//
//+---------------------------------------------------------------------------
__forceinline COleTls::COleTls(HRESULT &hr)
{
    _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
    if (_pData)
        hr = S_OK;
    else
        hr = TLSAllocData();
}

//+---------------------------------------------------------------------------
//
// Enum:       APTKIND
//
// Synopsis:   These are the apartment models COM understands.  The
//             GetCurrentApartmentKind functions return one of these values
//             identifying which apartment the currently executing thread
//             is in.
//
//-----------------------------------------------------------------------------
typedef enum tagAPTKIND
{
    APTKIND_NEUTRALTHREADED     = 0x01,
    APTKIND_MULTITHREADED       = 0x02,
    APTKIND_APARTMENTTHREADED   = 0x04
} APTKIND;


//+---------------------------------------------------------------------------
//
// Thread IDs for the various apartment types.  STA uses the currently
// executing TID.
//
//----------------------------------------------------------------------------
#define MTATID  0x0             // thread id of the MTA
#define NTATID  0xFFFFFFFF      // thread id of the NTA

typedef DWORD HAPT;
const   HAPT  haptNULL = 0;

//+---------------------------------------------------------------------------
//
//  Function:   GetCurrentApartmentId
//
//  Synopsis:   Returns the apartment id that the current thread is executing
//              in. If this is the Multi-threaded apartment, it returns 0; if
//              it is the Neutral-threaded apartment, it returns 0xFFFFFFFF.
//
//+---------------------------------------------------------------------------
inline DWORD GetCurrentApartmentId()
{
    HRESULT hr;
    COleTls Tls(hr);

    //
    // If TLS is not initialized, this is a MTA apartment.
    //
    if (FAILED(hr))
    {
        return MTATID;
    }
    else
    {
        return (Tls->dwFlags & OLETLS_INNEUTRALAPT) ? NTATID :
               (Tls->dwFlags & OLETLS_APARTMENTTHREADED) ? GetCurrentThreadId() :
               MTATID;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DoATClassCreate
//
//  Synopsis:   Put a given Class Factory on a new ApartmentModel thread.
//
//+---------------------------------------------------------------------------

HRESULT DoATClassCreate(LPFNGETCLASSOBJECT pfn,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk);


//+---------------------------------------------------------------------------
//
//  Function:   IsSTAThread
//
//  Synopsis:   returns TRUE if the current thread is for a
//              single-threaded apartment, FALSE otherwise
//
//+---------------------------------------------------------------------------
inline BOOL IsSTAThread()
{
    COleTls Tls;
    return (Tls->dwFlags & OLETLS_APARTMENTTHREADED) ? TRUE : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsMTAThread
//
//  Synopsis:   returns TRUE if the current thread is for a
//              multi-threaded apartment, FALSE otherwise
//
//+---------------------------------------------------------------------------
inline BOOL IsMTAThread()
{
    COleTls Tls;
    return (Tls->dwFlags & OLETLS_APARTMENTTHREADED) ? FALSE : TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOleInitialized
//
//  Synopsis:   returns TRUE if the current thread is for a
//              multi-threaded apartment, FALSE otherwise
//
//+---------------------------------------------------------------------------
inline BOOL IsOleInitialized()
{
    COleTls Tls(FALSE);
    return((!Tls.IsNULL() && Tls->cOleInits>0) ? TRUE : FALSE);
}

BOOL    IsApartmentInitialized();
IID    *TLSGetLogicalThread();
BOOLEAN TLSIsWOWThread();
BOOLEAN TLSIsThreadDetaching();
void    CleanupTlsState(SOleTlsData *pTls, BOOL fSafe);

inline HWND TLSGethwndSTA()
{
    COleTls Tls;

    return(Tls->hwndSTA);
}

inline void TLSSethwndSTA(HWND hwnd)
{
    COleTls Tls;

    Tls->hwndSTA = hwnd;
}

#endif // _TLS_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\verole.h ===
#define rmj		1
#define rmm		824
#define rup		1
#define szVerName	""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\valid.h ===
#ifndef __IH_VALID__H__
#define __IH_VALID__H__

#include "apcompat.hxx"

#if DBG==1 && defined(WIN32)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !ValidateInPointers() || !IsBadReadPtr ((pv),(cb)))
#define IsValidReadPtrIn(pv,cb)  ((cb == 0 || pv) && (!ValidateInPointers() || !IsBadReadPtr ((pv),(cb))))
#define IsValidPtrOut(pv,cb) ((cb == 0 || pv) && (!ValidateOutPointers() || !IsBadWritePtr((pv),(cb))))
#define IsValidCodePtr(pv) (pv && (!ValidateCodePointers() || !IsBadCodePtr ((pv))))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

DECLARE_DEBUG(VDATE);

#define VdateAssert(exp, msg) \
    VDATEInlineDebugOut( DEB_FORCE, "%s:%s; File: %s Line: %d\n", #exp, msg, __FILE__, __LINE__ )

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv, "Invalid in ptr"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv, "Invalid in ptr"), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    VdateAssert(pv, "Invalid in ptr"); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in ptr"), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { VdateAssert(pv, "Invalid in ptr"); goto label; }


//** READ POINTER IN validation macros:
#define VDATEREADPTRIN( pv, TYPE ) \
        if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid in read ptr"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEREADPTRIN( pv, TYPE, retval) \
        if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid in read ptr"), retval)
#define VOID_VDATEREADPTRIN( pv, TYPE ) \
        if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) {\
    VdateAssert(pv,"Invalid in read ptr"); return; }

//** READ POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEREADPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEREADPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), retval); \
         goto label; }
#define VOID_VDATEREADPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { VdateAssert(pv, "Invalid in read ptr"); goto label; }

//** READ POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEREADPTRIN_LABEL(pv, cb, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATESIZEREADPTRIN_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), retval); \
         goto label; }
#define VOID_VDATESIZEREADPTRIN_LABEL(pv, cb, label) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { VdateAssert(pv, "Invalid in read ptr"); goto label; }


//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid out ptr"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid out ptr"), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv,"Invalid out ptr"),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv,"Invalid out ptr"),retval); \
         goto label; }

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEPTROUT_LABEL(pv, cb, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid out ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATESIZEPTROUT_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid out ptr"), retval); \
         goto label; }


//** POINTER is NULL validation macros
#define VDATEPTRNULL_LABEL(pv, label, retVar) \
        if ((pv) != NULL) \
        { retVar = (VdateAssert(pv, "Ptr should be NULL"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRNULL_LABEL(pv, retval, label, retVar) \
        if ((pv) != NULL) \
        { retVar = (VdateAssert(pv, "Ptr should be NULL"), retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (VdateAssert(pv,"Invalid interface"), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (VdateAssert(pv,"Invalid interface"),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    VdateAssert(pv,"Invalid interface"); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (VdateAssert(pv,"Invalid interface"),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (VdateAssert(pv,"Invalid interface"),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        VdateAssert(pv,"Invalid interface"); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (VdateAssert(iid,"Invalid iid"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    VdateAssert(iid,"Invalid iid"); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (VdateAssert(iid,"Invalid iid"),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        VdateAssert(iid,"Invalid iid"); retVar = retval;  goto label; }


#else // _DEBUG


#define VdateAssert(exp, msg)	((void)0)

//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER IN validation macros:
#define VDATEREADPTRIN( pv, TYPE ) if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEREADPTRIN( pv, TYPE, retval ) if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEREADPTRIN( pv, TYPE ) if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEREADPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEREADPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEREADPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** READ POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEREADPTRIN_LABEL(pv, cb, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATESIZEREADPTRIN_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATESIZEREADPTRIN_LABEL(pv, cb, label) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { goto label; }


//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEPTROUT_LABEL(pv, cb, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATESIZEPTROUT_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = retval; \
         goto label; }


//** POINTER is NULL validation macros
#define VDATEPTRNULL_LABEL(pv, label, retVar) \
        if ((pv) != NULL) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRNULL_LABEL(pv, retval, label, retVar) \
        if ((pv) != NULL) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif

#endif // __IH_VALID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\warningcontrol.h ===
#pragma once

//
// Should fix eventually
//
#pragma warning(disable :4189)   // 'identifier' : local variable is initialized but not referenced
#pragma warning(disable :4238)   // nonstandard extension used : class rvalue used as lvalue
#pragma warning(disable :4389)   // 'operator' : signed/unsigned mismatch
#pragma warning(disable :4505)   // 'function' : unreferenced local function has been removed
#pragma warning(disable :4509)   // nonstandard extension used: 'function' uses SEH and 'object' has destructor
#pragma warning(disable :4510)   // 'class' : default constructor could not be generated
#pragma warning(disable :4610)   // object 'class' can never be instantiated - user-defined constructor required
#pragma warning(disable :4702)   // unreachable code

//
// Might consider fixing
//
#pragma warning(disable :4101)   // 'identifier' : unreferenced local variable
#pragma warning(disable :4245)   // 'conversion' : conversion from 'type1' to 'type2', signed/unsigned mismatch

//
// Probably ignorable
//
#pragma warning(disable :4057)   // 'operator' : 'identifier1' indirection to slightly different base types from 'identifier2'
#pragma warning(disable :4100)   // "'%$S' : unreferenced formal parameter"
#pragma warning(disable :4127)   // "conditional expression is constant"
#pragma warning(disable :4152)   // non standard extension, function/data ptr conversion in expression
#pragma warning(disable :4201)   // "nonstandard extension used : nameless struct/union"
#pragma warning(disable :4211)   // nonstandard extension used : redefined extern to static
#pragma warning(disable :4232)   // nonstandard extension used : 'identifier' : address of dllimport 'dllimport' is not static, identity not guaranteed
#pragma warning(disable :4239)   // nonstandard extension used : 'token' : conversion from 'type' to 'type'
#pragma warning(disable :4310)   // cast truncates constant value
#pragma warning(disable :4324)   // 'struct_name' : structure was padded due to __declspec(align())
#pragma warning(disable :4512)   // 'class' : assignment operator could not be generated
#pragma warning(disable :4706)   // assignment within conditional expression
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\utils.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		utils.h
//
//	Contents:
//		prototypes and constants for OLE internal utility routines
//
//	Classes:
//
//	Functions:
//
//	History:
//		11/28/93 - ChrisWe - file inspection and cleanup begins
//		11/29/93 - ChrisWe - remove signature for non-existent
//			function UtGlobalHandlCpy; moved manifest constants
//			to be with functions they are used with (OPCODE_*,
//			CONVERT_*); removed default parameters from functions;
//			replace '!' with '~' in STREAMTYPE_OTHER definition
//		04/07/94 - AlexGo  - added UtCreateStorageOnHGlobal
//
//-----------------------------------------------------------------------------

#ifndef _UTILS_H_
#define _UTILS_H_

// We need to serialize the placeable metafile structure in the same format
// that was used by WIN16, since RECT used LONGs under Win32.
// We ensure that no padding is added by using the #pragma pack() calls.

#pragma pack(1)
typedef struct tagWIN16RECT
{
	WORD left;
	WORD top;
	WORD right;
	WORD bottom;
} WIN16RECT;

typedef struct tagPLACEABLEMETAHEADER
{
	DWORD key;	/* must be PMF_KEY */
#define PMF_KEY 0x9ac6cdd7
	WORD hmf;	/* must be zero */
	WIN16RECT bbox;	/* bounding rectangle of the metafile */
	WORD inch;	/* # of metafile units per inch must be < 1440 */
			/* most apps use 576 or 1000 */
	DWORD reserved;	/* must be zero */
	WORD checksum;
} PLACEABLEMETAHEADER;
#pragma pack()

//+-------------------------------------------------------------------------
//
//  Function:   UtGetUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given a string length, and two pointers (one ANSI, one
//              OLESTR), returns the UNICODE version of whichever string
//              is valid.
//
//  Effects:    Memory is allocated on the caller's pointer for new OLESTR
//
//  Arguments:  [ulLength]      -- length of string in CHARACTERS (not bytes)
//                                 (including terminator)
//              [szANSI]        -- candidate ANSI string
//              [szOLESTR]      -- candidate OLESTR string
//              [pstr]          -- OLESTR OUT parameter
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//              E_ANSITOUNICODE      if ANSI cannot be converted to UNICODE
//
//  Algorithm:  If szOLESTR is available, a simple copy is performed
//              If szOLESTR is not available, szANSI is converted to UNICODE
//              and the result is copied.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//  Notes:      Only one of the two input strings (ANSI or UNICODE) should
//              be set on entry.
//
//--------------------------------------------------------------------------

INTERNAL UtGetUNICODEData( ULONG, LPSTR, LPOLESTR, LPOLESTR *);


//+-------------------------------------------------------------------------
//
//  Function:   UtPutUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given an OLESTR and two possible buffer pointer, one ANSI
//              and the other OLESTR, this fn tries to convert the string
//              down to ANSI.  If it succeeds, it allocates memory on the
//              ANSI ptr for the result.  If it fails, it allocates memory
//              on the UNICODE ptr and copies the input string over.  The
//              length of the final result (ANSI or UNICODE) is returned
//              in dwResultLen.
//
//  Arguments:  [ulLength]      -- input length of OLESTR str
//              [str]           -- the OLESTR to store
//              [pszANSI]       -- candidate ANSI str ptr
//              [pszOLESTR]     -- candidate OLESTR str ptr
//              [pdwResultLen]  -- where to store the length of result
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL UtPutUNICODEData(
      ULONG        ulLength,
      LPOLESTR     str,
      LPSTR      * pszANSI,
      LPOLESTR   * pszOLESTR,
      DWORD      * pdwResultLen );

//+----------------------------------------------------------------------------
//
//	Function:
//		UtDupGlobal, internal
//
//	Synopsis:
//		Duplicate the contents of an HGlobal into a new HGlobal.  If
//		there is no allocated memory, no new global is allocated.
//
//	Arguments:
//		[hsrc] -- the source HGLobal; need not be locked
//		[uiFlags] -- flags to be passed on to GlobalAlloc()
//
//	Returns:
//		The new HGLOBAL, if successful, or NULL
//
//	History:
//		11/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtDupGlobal(HANDLE hSrc, UINT uiFlags);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtIsFormatSupported, internal
//
//	Synopsis:
//		Checks a data object to see if it will accept
//		IDataObject::SetData() and/or IDataObject::GetData() calls
//		on the specified format.  The direction of transfer is specified
//		with the dwDirection flags.  The function returns TRUE only
//		if all requested transfers are possible.
//
//	Arguments:
//		[lpObj] -- the data object to check for the format
//		[dwDirection] -- a combination of values from DATADIR_*
//		[cfFormat] -- the format to look for
//
//	Returns:
//		TRUE, if transfers of [cfFormat] are supported in [dwDirection],
//		FALSE otherwise
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup; noted that
//			enumerators are expected to be able to return
//			formats for multiple DATADIR_* flags
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtIsFormatSupported(LPDATAOBJECT lpObj, DWORD dwDirection,
		CLIPFORMAT cfFormat);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDupString, internal
//
//	Synopsis:
//		Copies the argument string into a new string allocated
//		using the task allocator
//
//	Arguments:
//		[lpszIn] -- the string to duplicate
//
//	Returns:
//		a pointer to a copy of [lpszIn], or NULL if the allocator
//		could not be acquired, or was out of memory
//
//	History:
//		11/28/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------
FARINTERNAL_(LPOLESTR) UtDupString(LPCOLESTR lpszIn);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetProtseqFromTowerId
//
//  Synopsis: 	Get protseq string from DCE TowerID 
//
//  Effects:
//
//  Arguments: 	[wTowerId]	-- TowerID to retrieve
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//              06-Feb-97   Ronans      Converted to utility fn
//
//--------------------------------------------------------------------------
FARINTERNAL_(LPCWSTR) utGetProtseqFromTowerId(USHORT wTowerId);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetTowerId
//
//  Synopsis: 	Get DCE TowerId for protseq string
//
//  Effects:
//
//  Arguments: 	[pwszProtseq]	-- string to look up
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//              06-Feb-97   Ronans      Converted to utility fn
//
//--------------------------------------------------------------------------
FARINTERNAL_(USHORT) utGetTowerId(LPCWSTR pwszProtseq);


//+-------------------------------------------------------------------------
//
//  Function: 	UtDupStringA
//
//  Synopsis: 	Duplicates an ANSI string using the TASK allocator
//
//  Effects:
//
//  Arguments:	[pszAnsi]	-- the string to duplicate
//
//  Requires:
//
//  Returns:	the newly allocated string duplicate or NULL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

LPSTR UtDupStringA( LPCSTR pszAnsi );

//+----------------------------------------------------------------------------
//
//	Function:
//		UtCopyFormatEtc, internal
//
//	Synopsis:
//		Copies a format etc, creating copies of data structures
//		pointed to inside (the target device descriptor.)
//
//	Arguments:
//		[pFetcIn] -- pointer to the FORMATETC to copy
//		[pFetcCopy] -- pointer to where to copy the FORMATETC to
//
//	Returns:
//		FALSE if pointed to data could not be copied because it
//			could not be allocated
//		TRUE otherwise
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtCopyFormatEtc(FORMATETC FAR* pFetcIn,
		FORMATETC FAR* pFetcCopy);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCompareFormatEtc, internal
//
//	Synopsis:
//
//	Arguments:
//		[pFetcLeft] -- pointer to a FORMATETC
//		[pFetcRight] -- pointer to a FORMATETC
//
//	Returns:
//		UTCMPFETC_EQ is the two FORMATETCs match exactly
//		UTCMPFETC_NEQ if the two FORMATETCs do not match
//		UTCMPFETC_PARTIAL if the left FORMATETC is a subset of the
//			right: fewer aspects, null target device, or
//			fewer media
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(int) UtCompareFormatEtc(FORMATETC FAR* pFetcLeft,
		FORMATETC FAR* pFetcRight);
#define UTCMPFETC_EQ 0		/* exact match */
#define UTCMPFETC_NEQ 1		/* no match */
#define UTCMPFETC_PARTIAL (-1)	/* partial match; left is subset of right */


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCompareTargetDevice, internal
//
//	Synopsis:
//		Compares two target devices to see if they are the same
//
//	Arguments:
//		[ptdLeft] -- pointer to a target device description
//		[ptdRight] -- pointer to a target device description
//
//	Returns:
//		TRUE if the two devices are the same, FALSE otherwise
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtCompareTargetDevice(DVTARGETDEVICE FAR* ptdLeft,
		DVTARGETDEVICE FAR* ptdRight);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCopyStatData, internal
//
//	Synopsis:
//		Copies the contents of one STATDATA into another, including
//		creating a copy of data pointed to, and incrementing the
//		reference count on the advise sink to reflect the copy.
//
//	Arguments:
//		[pSDIn] -- the source STATDATA
//		[pSDCopy] -- where to copy the information to
//
//	Returns:
//		FALSE if memory could not be allocated for the copy of
//		the target device, TRUE otherwise
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtCopyStatData(STATDATA FAR* pSDIn, STATDATA FAR* pSDCopy);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtReleaseStatData, internal
//
//	Synopsis:
//		Release resources associated with the argument STATDATA; this
//		frees the device description within the FORMATETC, and releases
//		the advise sink, if there is one.
//
//	Arguments:
//		[pStatData] -- The STATDATA to clean up
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void) UtReleaseStatData(STATDATA FAR* pStatData);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDupPalette, internal
//
//	Synopsis:
//		Creates a duplicate palette.
//
//	Arguments:
//		[hpalette] -- the palette to duplicate
//
//	Returns:
//		if successful, a handle to the duplicate palette; if any
//		allocations or calls fail during the duplication process, NULL
//
//	History:
//		11/29//93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HPALETTE) UtDupPalette(HPALETTE hpalette);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtPaletteSize, internal
//
//	Synopsis:
//		Returns the size of a color table for a palette given the
//		number of bits of color desired.
//
//	Arguments:
//		[lpHeader] -- ptr to BITMAPINFOHEADER structure
//
//	Returns:
//		Size in bytes of color information
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - change bit count argument to unsigned,
//			and return value to size_t
//
//		07/18/94 - DavePl - Fixed for 16, 24, 32bpp DIBs
//
//-----------------------------------------------------------------------------
FARINTERNAL_(size_t) UtPaletteSize(BITMAPINFOHEADER *);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtFormatToTymed, internal
//
//	Synopsis:
//		Maps a clipboard format to a medium used to transport it.
//
//	Arguments:
//		[cf] -- the clipboard format to map
//
//	Returns:
//		a TYMED_* value
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(DWORD) UtFormatToTymed(CLIPFORMAT cf);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtQueryPictFormat, internal
//
//	Synopsis:
//		Check to see if the argument data object supports one of
//		our preferred data formats for presentations:
//		CF_METAFILEPICT, CF_DIB, CF_BITMAP, in that order.  Returns
//		TRUE, if success, and alters the given format descriptor
//		to match the supported format.  The given format descriptor
//		is not altered if there is no match.
//
//	Arguments:
//		[lpSrcDataObj] -- the data object to query
//		[lpforetc] - the format descriptor
//
//	Returns:
//		TRUE if a preferred format is found, FALSE otherwise
//
//	Notes:
//
//	History:
//		11/09/93 - ChrisWe - modified to not alter the descriptor
//			if no match is found
//		11/09/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtQueryPictFormat(LPDATAOBJECT lpSrcDataObj,
		LPFORMATETC lpforetc);
								

//+----------------------------------------------------------------------------
//
//	Function:
//		UtConvertDibToBitmap, internal
//
//	Synopsis:
//		Converts a DIB to a bitmap, returning a new handle to the
//		bitmap.  The original DIB is left untouched.
//
//	Arguments:
//		[hDib] -- handle to the DIB to convert
//
//	Returns:
//		if successful, and handle to the new bitmap
//
//	Notes:
//		REVIEW, the function uses the screen DC when creating the
//		new bitmap.  It may be the case that the bitmap was intended
//		for another target, in which case this may not be appropriate.
//		It may be necessary to alter this function to take a DC as
//		an argument.
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HBITMAP) UtConvertDibToBitmap(HANDLE hDib);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtConvertBitmapToDib, internal
//
//	Synopsis:
//		Creates a Device Independent Bitmap capturing the content of
//		the argument bitmap.
//
//	Arguments:
//		[hBitmap] -- Handle to the bitmap to convert
//		[hpal] -- color palette for the bitmap; may be null for
//			default stock palette
//
//	Returns:
//		Handle to the DIB.  May be null if any part of the conversion
//		failed.
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtConvertBitmapToDib(HBITMAP hBitmap, HPALETTE hpal);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetClassId, internal
//
//	Synopsis:
//		Attempt to find the class id of the object.  First,
//		query for IOleObject, and if successful, call
//		IOleObject::GetUserClassID().  If that fails, query for
//		IPersist, and if successful, call IPersist::GetClassID.
//
//	Arguments:
//		[lpUnk] -- pointer to an IUnknown instance
//		[lpClsid] -- pointer to where to copy the class id to
//
//	Returns:
//		TRUE, if the class id was obtained, or FALSE otherwise
//		If unsuccessful, *[lpClsid] is set to CLSID_NULL
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - change to return BOOL to indicate success
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtGetClassID(LPUNKNOWN lpUnk, CLSID FAR* lpClsid);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCopyTargetDevice, internal
//
//	Synopsis:
//		Allocates a new target device description, and copies
//		the given one into it
//
//	Arguments:
//		[ptd] -- pointer to a target device
//
//	Returns:
//		NULL, if the no memory can be allocated
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(DVTARGETDEVICE FAR*) UtCopyTargetDevice(DVTARGETDEVICE FAR* ptd);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetIconData, internal
//
//	Synopsis:
//		Attempts to get the icon for an object.
//
//	Arguments:
//		[lpSrcDataObj] -- The source data object
//		[rclsid] -- the class id the object is known to be
//			(may be CLSID_NULL)
//		[lpforetc] -- the format of the data to fetch
//		[lpstgmed] -- a place to return the medium it was fetched on
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//		REVIEW, this method seems to assume that the contents of
//		lpforetc are correct for fetching an icon.  It passes this
//		on to [lpSrcDataObj]->GetData first, and if that fails,
//		calls OleGetIconOfClass, without checking the requested
//		format in lpforetc.  This could fetch anything
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetIconData(LPDATAOBJECT lpSrcDataObj, REFCLSID rclsid,
		LPFORMATETC lpforetc, LPSTGMEDIUM lpstgmed);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDoStreamOperation, internal
//
//	Synopsis:
//		Iterate over the streams in [pstgSrc], performing the
//		operation indicated by [iOpCode] to those that are specified
//		by [grfAllowedStmTypes].
//
//	Arguments:
//		[pstgSrc] -- source IStorage instance
//		[pstgDst] -- destination IStorage instance; may be null for
//			some operations (OPCODE_REMOVE)
//		[iOpCode] -- 1 value from the OPCODE_* values below
//		[grfAllowedStmTypes] -- a logical or of one or more of the
//			STREAMTYPE_* values below
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STDAPI UtDoStreamOperation(LPSTORAGE pstgSrc, LPSTORAGE pstgDst,
		int iOpCode, DWORD grfAllowedStmTypes);

#define OPCODE_COPY		1 /* copy the stream from pstgSrc to pstgDst */
#define OPCODE_REMOVE		2 /* delete the stream from pstgSrc */
#define OPCODE_MOVE		3 /* move the stream from pstgSrc to pstgDst */
#define OPCODE_EXCLUDEFROMCOPY	4
		 /* unimplemented, undocumented, intent unknown */

#define	STREAMTYPE_CONTROL	0x00000001 /* OLE 0x1 stream (REVIEW const) */
#define	STREAMTYPE_CACHE	0x00000002 /* OLE 0x2 stream (REVIEW const) */
#define	STREAMTYPE_CONTAINER	0x00000004 /* OLE 0x3 stream (REVIEW const) */
#define STREAMTYPE_OTHER \
	(~(STREAMTYPE_CONTROL | STREAMTYPE_CACHE | STREAMTYPE_CONTAINER))
#define	STREAMTYPE_ALL		0xFFFFFFFF /* all stream types are allowed */


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetPresStreamName, internal
//
//	Synopsis:
//		Modify [lpszName] to be a presentation stream name based
//		on [iStreamNum].
//
//	Arguments:
//		[lpszName] -- a copy of OLE_PRESENTATION_STREAM; see below
//		[iStreamNum] -- the number of the stream
//
//	Notes:
//		The digit field of [lpszName] is always completely overwritten,
//		allowing repeated use of UtGetPresStreamName() on the same
//		string; this removes the need to repeatedly start with a fresh
//		copy of	OLE_PRESENTATION_STREAM each time this is used in a
//		loop.
//
//		The validity of the implementation depends on the values of
//		OLE_PRESENTATION_STREAM and OLE_MAX_PRES_STREAMS; if those
//		change, the implementation must change
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void)UtGetPresStreamName(LPOLESTR lpszName, int iStreamNum);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtRemoveExtraOlePresStreams, internal
//
//	Synopsis:
//		Deletes presentation streams in [pstg] starting with the
//		presentation numbered [iStart].  All streams after that one
//		(numbered sequentially) are deleted, up to OLE_MAX_PRES_STREAMS.
//
//	Arguments:
//		[pstg] -- the IStorage instance to operate on
//		[iStart] -- the number of the first stream to remove
//
//	Returns:
//
//	Notes:
//		The presentation stream names are generated with
//		UtGetPresStreamName().
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void) UtRemoveExtraOlePresStreams(LPSTORAGE pstg, int iStart);

//+-------------------------------------------------------------------------
//
//  Function:	UtCreateStorageOnHGlobal
//
//  Synopsis:	creates a storage on top of an HGlobal
//
//  Effects:
//
//  Arguments: 	[hGlobal]	-- the memory on which to create the
//				   storage
//		[fDeleteOnRelease]	-- if TRUE, then delete the memory
//					   ILockBytes once the storage is
//					   released.
//		[ppStg]		-- where to put the storage interface
//		[ppILockBytes]	-- where to put the underlying ILockBytes,
//				   maybe NULL.  The ILB must be released.
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	create an ILockBytes on HGLOBAL and then create the docfile
//		on top of the ILockBytes
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT UtCreateStorageOnHGlobal( HGLOBAL hGlobal, BOOL fDeleteOnRelease,
		IStorage **ppStg, ILockBytes **ppILockBytes );


//+-------------------------------------------------------------------------
//
//  Function: 	UtGetTempFileName
//
//  Synopsis:	retrieves a temporary filename (for use in GetData, TYMED_FILE
//		and temporary docfiles)
//
//  Effects:
//
//  Arguments: 	[pszPrefix]	-- prefix of the temp filename
//		[pszTempName]	-- buffer that will receive the temp path.
//				   must be MAX_PATH or greater.
//
//  Requires:
//
//  Returns:	HRESULT;
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tries to get a file in the temp directory, failing that, in
//		the windows directory
//
//  History:    dd-mmm-yy Author    Comment
// 		07-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT	UtGetTempFileName( LPOLESTR pszPrefix, LPOLESTR pszTempName );
							

//+----------------------------------------------------------------------------
//
//	Function:
//		UtHGLOBALToStm, internal
//
//	Synopsis:
//		Write the contents of an HGLOBAL to a stream
//
//	Arguments:
//		[hdata] -- handle to the data to write out
//		[dwSize] -- size of the data to write out
//		[pstm] -- stream to write the data out to;  on exit, the
//			stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT UtHGLOBALtoStm(HANDLE hdata, DWORD dwSize, LPSTREAM pstm);

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoHGLOBAL, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target HGLOBAL
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[hGlobalTgt] 	-- the target HGLOBAL
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the target hglobal is not large
//		enough
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoHGLOBAL( HGLOBAL hGlobalSrc, DWORD dwSize,
		HGLOBAL hGlobalTgt);


//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoStorage, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target storage
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[hpStg] 		-- the target storage
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the source HGLOBAL did not
//		originally have a storage layered on top of it.
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoStorage( HGLOBAL hGlobalSrc, IStorage *pStg);


//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoFile, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target file
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[pszFileName] 	-- the target file
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoFile( HGLOBAL hGlobalSrc, DWORD dwSize,
		LPCOLESTR pszFileName);


/*** Following routines can be found in convert.cpp *****/

//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHGLOBALFromStm, internal
//
//	Synopsis:
//		Create a new HGLOBAL, and read [dwSize] bytes into it
//		from [lpstream].
//
//	Arguments:
//		[lpstream] -- the stream to read the content of the new
//			HGLOBAL from;  on exit, points just past the data read
//		[dwSize] -- the amount of material to read from the stream
//		[lphPres] -- pointer to where to return the new handle
//
//	Returns:
//		HRESULT
//
//	Notes:
//		In case of any error, the new handle is freed.  If the
//		amount of material expected from [lpstream] is less than
//		[dwSize], nothing is returned.
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHGLOBALFromStm(LPSTREAM lpstream, DWORD dwSize,
		 HANDLE FAR* lphPres);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHDIBFromDIBFileStm, internal
//
//	Synopsis:
//		Produce a handle to a DIB from a file stream
//
//	Arguments:
//		[pstm] -- the stream to read the DIB from;  on exit, the
//			stream is positioned just past the data read
//		[lphdata] -- pointer to where to return the handle to the data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHDIBFromDIBFileStm(LPSTREAM pstm, HANDLE FAR* lphdata);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHMFPICT, internal
//
//	Synopsis:
//		Given a handle to a METAFILE, conjure up a handle to a
//		METAFILEPICT, based on the metafile
//
//	Arguments:
//		[hMF] -- handle to the METAFILE
//		[fDeleteOnError] -- if TRUE, delete the METAFILE [hMF] in there
//			is any error
//		[xExt] -- the x extent of the desired METAFILEPICT
//		[yExt] -- the y extent of the desired METAFILEPICT
//
//	Returns:
//		Handle to the new METAFILEPICT, if successful, or NULL
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtGetHMFPICT(HMETAFILE hMF, BOOL fDeletOnError,
		DWORD xExt, DWORD yExt);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHMFFromMFStm, internal
//
//	Synopsis:
//		Create a handle to a METAFILE, loaded with content from
//		the given stream
//
//	Arguments:
//		[lpstream] -- the source stream to initialize the METAFILE with;
//			on exit, the stream is positioned just past the
//			data read
//		[dwSize] -- the amount of material to read from [lpstream]
//		[fConvert] -- if TRUE, tries to convert a Macintosh QuickDraw
//			file to METAFILE format
//		[lphPres] -- pointer to where to return the new handle to
//			the metafile
//
//	Returns:
//		HRESULT
//
//	Notes:
//		If [dwSize] is too large, and goes past the end of the
//		stream, the error causes everything allocated to be freed,
//		and nothing is returned in [lphPres].
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHMFFromMFStm(LPSTREAM lpstream, DWORD dwSize,
		BOOL fConvert, HANDLE FAR* lphPres);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetSizeAndExtentsFromPlaceableMFStm, internal
//
//	Synopsis:
//		Obtain the size, width, and height of the metafile stored
//		in a placeable metafile stream.
//
//	Arguments:
//		[lpstream] -- the stream to read the placeable metafile
//			from;  on exit, the stream is positioned at the
//			beginning of the metafile header, after the
//			placeable metafile header.
//		[pdwSize] -- a pointer to where to return the size of the
//			metafile;  may be NULL
//		[plWidth] -- a pointer to where to return the width of the
//			metafile;  may be NULL
//		[plHeight] -- a pointer to where to return the height of the
//			metafile;  may be NULL
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetSizeAndExtentsFromPlaceableMFStm(LPSTREAM pstm,
		DWORD FAR* dwSize, LONG FAR* plWidth, LONG FAR* plHeight);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHMFPICTFromPlaceableMFStm, internal
//
//	Synopsis:
//		Create a handle to a METAFILEPICT initialized from a
//		placeable METAFILE stream.
//
//	Arguments:
//		[pstm] -- the stream to load the METAFILE from; on exit
//			points just past the METAFILE data
//		[lphdata] -- pointer to where to return the handle to the
//			new METAFILEPICT
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHMFPICTFromPlaceableMFStm(LPSTREAM pstm, HANDLE FAR* lphdata);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetDibExtents, internal
//
//	Synopsis:
//		Return the width and height of a DIB, in HIMETRIC units
//		per pixel.
//
//	Arguments:
//		[lpbmi] -- pointer to a BITMAPINFOHEADER
//		[plWidth] -- pointer to where to return the width
//			REVIEW, this should be a DWORD
//		[plHeight] -- pointer to where to return the height
//			REVIEW, this should be a DWORD
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void) UtGetDibExtents(LPBITMAPINFOHEADER lpbmi,
		LONG FAR* plWidth, LONG FAR* plHeight);
#ifdef LATER
FARINTERNAL_(void) UtGetDibExtents(LPBITMAPINFOHEADER lpbmi,
		DWORD FAR* pdwWidth, DWORD FAR* pdwHeight);
#endif


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHDIBToDIBFileStm, internal
//
//	Synopsis:
//		Given a handle to a DIB, write out out a DIB file stream.
//
//	Arguments:
//		[hdata] -- handle to the DIB
//		[dwSize] -- the size of the DIB
//		[pstm] -- the stream to write the DIB out to;  on exit, the
//			stream is positioned after the DIB data; the DIB
//			data is prepended with a BITMAPFILEHEADER
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHDIBToDIBFileStm(HANDLE hdata, DWORD dwSize, LPSTREAM pstm);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDIBStmToDIBFileStm, internal
//
//	Synopsis:
//		copy convert a DIB in a stream to a DIB file stream
//
//	Arguments:
//		[pstmDIB] -- the source DIB
//			REVIEW, what does CopyTo do to the stream pointer?
//		[dwSize] -- the size of the source DIB
//		[pstmDIBFile] -- where to write the converted DIB file stream;
//			should not be the same as [pstmDIB]; on exit, the
//			stream is positioned after the DIB file data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtDIBStmToDIBFileStm(LPSTREAM pstmDIB, DWORD dwSize,
		LPSTREAM pstmDIBFile);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHDIBFileToOlePresStm, internal
//
//	Synopsis:
//		Given a handle to a DIB file, write it out to a stream
//
//	Arguments:
//		[hdata] -- the handle to the DIB file
//		[pstm] -- the stream to write it out to;  on exit, the
//			stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//		A small header with size information precedes the DIB file
//		data.
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHDIBFileToOlePresStm(HANDLE hdata, LPSTREAM pstm);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHMFToMFStm, internal
//
//	Synopsis:
//		Given a handle to a METAFILE, write it out to a METAFILE stream
//
//	Arguments:
//		[lphMF] -- a *pointer* to a handle to a METAFILE
//			REVIEW, why is this a pointer?
//		[dwSize] -- the size of the METAFILE
//		[lpstream] -- the stream to write the METAFILE out to;  on
//			exit, the stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHMFToMFStm(HANDLE FAR* lphMF, DWORD dwSize, LPSTREAM lpstream);
							

//+----------------------------------------------------------------------------
//
//	Function:
//		UtHMFToPlaceableMFStm, internal
//
//	Synopsis:
//		Given a handle to a METAFILE, write it to a stream as a
//		placeable METAFILE
//
//	Arguments:
//		[lphMF] -- a *pointer* to a METAFILE handle
//			REVIEW, why is this a pointer?
//		[dwSize] -- size of the METAFILE
//		[lWidth] -- width of the metafile
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[lHeight] -- height of the metafile
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[pstm] -- the stream to write the data to;  on exit, the stream
//			is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHMFToPlaceableMFStm(HANDLE FAR* lphMF, DWORD dwSize,
		LONG lWidth, LONG lHeight, LPSTREAM pstm);		


//+----------------------------------------------------------------------------
//
//	Function:
//		UtNFStmToPlaceableMFStm, internal
//
//	Synopsis:
//		Copy converts a METAFILE in a stream to a placeable METAFILE
//		in another stream.
//
//	Arguments:
//		[pstmMF] -- the IStream instance from which to read the
//			original METAFILE, positioned at the METAFILE
//			REVIEW, where does CopyTo leave this stream pointer?
//		[dwSize] -- the size of the source METAFILE
//		[lWidth] -- the width of the source METAFILE
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[lHeight] -- the height of the source METAFILE
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[pstmPMF] -- the IStream instance to which to write the
//			placeable METAFILE;  on exit, the stream is positioned
//			after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtMFStmToPlaceableMFStm(LPSTREAM pstmMF, DWORD dwSize,
		LONG lWidth, LONG lHeight, LPSTREAM pstmPMF);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtWriteOlePresStmHeader, internal
//
//	Synopsis:
//		Write out the header information for an Ole presentation stream.
//
//	Arguments:
//		[lpstream] -- the stream to write to;  on exit, the stream is
//			positioned after the header information
//		[pforetc] -- pointer to the FORMATETC for the presentation
//			data
//		[dwAdvf] -- the advise control flags for this presentation
//
//	Returns:
//		HRESULT
//
//	Notes:
//		This writes the clipboard information, the target device
//		information, if any, some FORMATETC data, and the advise
//		control flags.
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtWriteOlePresStmHeader(LPSTREAM lppstream, LPFORMATETC pforetc,
		DWORD dwAdvf);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtReadOlePresStmHeader, internal
//
//	Synopsis:
//		Reads the presentation description information from an Ole
//			presentation stream, as written by
//			UtWriteOlePresStmHeader().
//
//	Arguments:
//		[pstm] -- the IStream instance to read the presentation
//			description data from
//		[pforetc] -- pointer to the FORMATETC to initialize based
//			on data in the stream
//		[pdwAdvf] -- pointer to where to put the advise flags for
//			this presentation;  may be NULL
//		[pfConvert] -- pointer to a flag that is set to TRUE if
//			the presentation will require conversion from
//			Macintosh PICT format.
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtReadOlePresStmHeader(LPSTREAM pstm, LPFORMATETC pforetc,
		DWORD FAR* pdwAdvf, BOOL FAR* pfConvert);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtOlePresStmToContentsStm, internal
//
//	Synopsis:
//		Copy the content of a presentation stream to a contents stream,
//		adjusting the format as necessary.
//
//	Arguments:
//		[pstg] -- the IStorage instance in which the presentation
//			stream is, and in which to create the contents stream
//		[lpszPresStm] -- the name of the source presentation stream
//		[fDeletePresStm] -- flag that indicates that the presentation
//			stream should be deleted if the copy and convert is
//			successful.  This is ignored if the source was
//			DVASPECT_ICON.
//		[puiStatus] -- pointer to a UINT where status bits from
//			the CONVERT_* values below may be returned.
//
//	Returns:
//		HRESULT
//
//	Notes:
//		The content stream is named by the constant OLE_CONTENTS_STREAM.
//
//	History:
//		12/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pstg, LPOLESTR lpszPresStm,
		BOOL fDeletePresStm, UINT FAR* puiStatus);
#define CONVERT_NOSOURCE	0x0001
#define CONVERT_NODESTINATION	0x0002
#define CONVERT_SOURCEISICON	0x0004

// 2nd variation
FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pSrcStg, LPOLESTR lpszPresStm,
		LPSTREAM pDestStm, UINT FAR* puiStatus);					

FARINTERNAL UtGetHMFPICTFromMSDrawNativeStm(LPSTREAM pstm, DWORD dwSize,
		HANDLE FAR* lphdata);

FARINTERNAL UtPlaceableMFStmToMSDrawNativeStm(LPSTREAM pstmPMF,
		LPSTREAM pstmMSDraw);
			
FARINTERNAL UtDIBFileStmToPBrushNativeStm(LPSTREAM pstmDIBFile,
		LPSTREAM pstmPBrush);

FARINTERNAL UtContentsStmTo10NativeStm(LPSTORAGE pstg, REFCLSID rclsid,
		BOOL fDeleteContents, UINT FAR* puiStatus);

FARINTERNAL Ut10NativeStmToContentsStm(LPSTORAGE pstg, REFCLSID rclsid,
		BOOL fDeleteSrcStm);
							

//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHPRESFromNative, internal
//
//	Synopsis:
//		Get a handle to a presentation from a native representation.
//
//	Arguments:
//		[pstg] -- the storage in which the native content is
//		[cfFormat] -- the native format to attempt to read
//		[fOle10Native] -- attempt to read the OLE10_NATIVE_STREAM
//			stream in that format; if this is FALSE, we read the
//			OLE_CONTENTS_STREAM
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtGetHPRESFromNative(LPSTORAGE pstg,
		LPSTREAM pstm, CLIPFORMAT cfFormat, BOOL fOle10Native);

//+-------------------------------------------------------------------------
//
//  Function:  	ConvertPixelsToHIMETRIC
//
//  Synopsis: 	Converts a pixel dimension to HIMETRIC units
//
//  Effects:
//
//  Arguments: 	[hdcRef]        -- the reference DC
//		[ulPels]	-- dimension in pixel measurement
//		[pulHIMETRIC]	-- OUT param of converted HIMETRIC result
//		[tDimension]	-- indicates XDIMENSION or YDIMENSION of input
//
//  Returns:	S_OK, E_FAIL
//
//  Algorithm:	screen_mm * input_pels	      HIMETRICS/
//              ----------------------    *    	      /    == HIMETRICS
//                    screen_pels		     /mm
//
//  History:    dd-mmm-yy Author    Comment
//   		04-Aug-94 Davepl    Created
//
//  Notes:	We need to know whether the input size is in the X or
//		Y dimension, since the aspect ratio could vary
//
//--------------------------------------------------------------------------

// This enumeration is used to indicate in which diretion a
// dimension, when passed as a parameter, is to be relative to.
// This is needed for our Pixel -> HIMETRIC conversion function,
// since the aspect ratio could vary by dimension.

typedef enum tagDIMENSION
{
	XDIMENSION = 'X',
	YDIMENSION = 'Y'
} DIMENSION;

FARINTERNAL ConvertPixelsToHIMETRIC (HDC hdcRef,
				     ULONG lPels,
				     ULONG * pulHIMETRIC,
				     DIMENSION tDimension);

//+-------------------------------------------------------------------------
//
//  Function:  	IsTaskName
//
//  Synopsis: 	Determines if the passed name is the current task
//
//  Effects:
//
//  Arguments: 	[lpszIn]        -- Task name
//
//  Returns:	TRUE, FALSE
//
//  History:    dd-mmm-yy Author    Comment
//   		03-Mar-95 Scottsk    Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
FARINTERNAL_(BOOL) IsTaskName(LPCWSTR lpszIn);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetModuleName
//
//  Synopsis: 	Get Module Name for current module
//
//  Effects:
//
//  Arguments: 	[lpszModuleName]        -- Buffer to hold module name
//              [dwLength]              -- length in characters
//
//  Returns:	S_OK, E_UNEXPECTED, E_OUTOFMEMORY
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-97 Ronans    Created
//
//--------------------------------------------------------------------------
FARINTERNAL utGetModuleName(LPWSTR lpszModuleName, DWORD dwLength);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetAppIdForModule
//
//  Synopsis: 	Get AppID for the current module in string form
//
//  Effects:
//
//  Arguments: 	[lpszAppId]     -- Buffer to hold string represntation of AppId
//              [dwLength]      -- length of buffer in characters
//
//  Returns:	S_OK, E_UNEXPECTED, E_OUTOFMEMORY or error value from 
//              registry functions.
//
//  History:    dd-mmm-yy Author    Comment
//	            06-Feb-97 Ronans	Created
//
//--------------------------------------------------------------------------
FARINTERNAL utGetAppIdForModule(LPWSTR lpszAppId, DWORD dwLength);


//+-------------------------------------------------------------------------
//
//  Function:   UtGetDvtd16Info
//              UtConvertDvtd16toDvtd32
//
//              UtGetDvtd32Info
//              UtConvertDvtd32toDvtd16
//
//  Synopsis:   Utility functions for converting Ansi to Unicode DVTARGETDEVICEs
//
//  Algorithm:  UtGetDvtdXXInfo gets sizing data, which is then passed to
//              UtConvertDvtdXXtoDvtdXX to perform the conversion.
//
//  History:    06-May-94 AlexT     Created
//
//  Notes:      Here's a sample usage of these functions:
//
//              //  pdvtd16 is a Ansi DVTARGETDEVICE
//              DVTDINFO dvtdInfo;
//              DVTARGETDEVICE pdvtd32;
//
//              hr = UtGetDvtd16Info(pdvtd16, &dvtdInfo);
//              // check hr
//              pdvtd32 = CoTaskMemAlloc(dvtdInfo.cbConvertSize);
//              // check pdvtd32
//              hr = UtConvertDvtd16toDvtd32(pdvtd16, &dvtdInfo, pdvtd32);
//              // check hr
//              // pdvtd32 now contains the converted data
//
//--------------------------------------------------------------------------

typedef struct
{
    UINT cbConvertSize;
    UINT cchDrvName;
    UINT cchDevName;
    UINT cchPortName;
} DVTDINFO, *PDVTDINFO;

extern "C" HRESULT UtGetDvtd16Info(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                   PDVTDINFO pdvtdInfo);
extern "C" HRESULT UtConvertDvtd16toDvtd32(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE *pdvtd32);
extern "C" HRESULT UtGetDvtd32Info(DVTARGETDEVICE const *pdvtd32,
                                   PDVTDINFO pdvtdInfo);
extern "C" HRESULT UtConvertDvtd32toDvtd16(DVTARGETDEVICE const *pdvtd32,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE UNALIGNED *pdvtd16);
class CStdIdentity;

HRESULT CreateEmbeddingServerHandler(CStdIdentity *pStdId, IUnknown **ppunkServerHandler);

// Number to wide-char conversion routine.  See xtow.c for description.
extern "C" BOOL __cdecl our_ultow(
	unsigned long val,
	wchar_t *buf,
	int bufsize,
	int radix
	);

#endif // _UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\utstream.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		utstream.h
//
//	Contents:
//		Ole stream utility routines
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/07/93 - ChrisWe - file inspection and cleanup; removed
//			redeclarations of ReadStringStream, and
//			WriteStringStream which are declared in ole2sp.h;
//			made default params on StSetSize explicit; removed
//			signatures of obsolete (non-existent) atom reading and
//			writing routines
//
//-----------------------------------------------------------------------------

#ifndef _UTSTREAM_H_
#define _UTSTREAM_H_




// REVIEW, isn't this obsolete now, as StWrite is?
FARINTERNAL_(HRESULT) StRead(IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen);

#define StWrite(lpstream, lpBuf, ulLen) lpstream->Write(lpBuf, ulLen, NULL)

//+----------------------------------------------------------------------------
//
//	Function:
//		StSetSize, internal
//
//	Synopsis:
//		Sets the size of the stream, using IStream::SetSize().  Saves
//		the caller having to deal with the requisite ULARGE_INTEGER
//		parameter, by initializing one from the [dwSize] argument.
//
//	Arguments:
//		[pstm] -- the stream to set the size of
//		[dwSize] -- the size to set
//		[fRelative] -- if TRUE, indicates that the size is [dwSize]
//			plus the current seek position in the stream; if
//			FALSE, sets [dwSize] as the absolute size
//
//	Returns:
//		HRESULT
//
//	Notes:
//		REVIEW, this seems crocked.  When would you ever call
//		this with [fRelative] == TRUE, and a non-zero [dwSize]?
//
//	History:
//		12/07/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL StSetSize(LPSTREAM pstm, DWORD dwSize, BOOL fRelative);


// REVIEW, are the the following functions necessary anymore?
FARINTERNAL StSave10NativeData(IStorage FAR* pstgSave, HANDLE hNative,
		BOOL fIsOle1Interop);

FARINTERNAL StRead10NativeData(IStorage FAR* pstgSave, HANDLE FAR *phNative);

FARINTERNAL StSave10ItemName(IStorage FAR* pstg, LPCSTR szItemName);



//+---------------------------------------------------------------------------
//
//  Class:      CStmBuf, Base class.
//
//  Synopsis:   Internal buffered Streams.
//
//  Interfaces: CStmBuf    - Constructor.
//             ~CStmBuf    - Destructor.
//              Release    - Release interface (used with OpenStream).
//
//  History:    20-Feb-95    KentCe     Created.
//
//  Notes:      This is a simple buffered class for internal use only.
//
//----------------------------------------------------------------------------
class CStmBuf
{
public:
            CStmBuf();
            ~CStmBuf();

protected:
    IStream * m_pStm;           // Stream Interface to read/write.

    BYTE  m_aBuffer[256];       // Small read/write buffer.

    PBYTE m_pBuffer;            // Pointer into read/write buffer.
    ULONG m_cBuffer;            // Count of characters in read/write buffer.
};


//+---------------------------------------------------------------------------
//
//  Class:      CStmBufRead
//
//  Synopsis:   Internal buffered read of Streams.
//
//  Interfaces: Init       - Defines stream to read.
//              OpenStream - Opens a stream for reading.
//              Read       - Read from the stream.
//              ReadLong   - Read a long value from the stream.
//              Release    - Release interface (used with OpenStream).
//
//  History:    20-Feb-95    KentCe     Created.
//
//  Notes:      This is a simple buffered read class for internal use only.
//
//----------------------------------------------------------------------------
class CStmBufRead : public CStmBuf
{
public:
    void    Init(IStream * pstm);
    HRESULT OpenStream(IStorage * pstg, const OLECHAR * pwcsName);
    HRESULT Read(PVOID pBuf, ULONG cBuf);
    HRESULT ReadLong(LONG * plValue);
    void    Release();

private:
    void    Reset(void);
};


//+---------------------------------------------------------------------------
//
//  Class:      CStmBufWrite
//
//  Synopsis:   Internal buffered write of Streams.
//
//  Interfaces: Init         - Defines stream to write.
//              OpenOrCreateStream - Opens/Creates a stream for writing.
//              CreateStream - Creates a stream for writing.
//              Write        - Write to the stream.
//              WriteLong    - Write a long value to the stream.
//              Flush        - Flush buffer to the disk subsystem.
//              Release      - Release interface.
//
//  History:    20-Feb-95    KentCe     Created.
//
//  Notes:      This is a simple buffered write class for internal use only.
//
//----------------------------------------------------------------------------
class CStmBufWrite : public CStmBuf
{
public:
    void    Init(IStream * pstm);
    HRESULT OpenOrCreateStream(IStorage * pstg, const OLECHAR * pwcsName);
    HRESULT CreateStream(IStorage * pstg, const OLECHAR * pwcsName);
    HRESULT Write(void const * pBuf, ULONG cBuf);
    HRESULT WriteLong(LONG lValue);
    HRESULT Flush(void);
    void    Release();

private:
    void    Reset(void);
};


//
//  The following was moved from the ole2sp.h file to keep stream related API's
//  in one place.
//

//  Utility function not in the spec; in ole2.dll.
//  Read and write length-prefixed strings.  Open/Create stream.
//  ReadStringStream does allocation, returns length of
//  required buffer (strlen + 1 for terminating null)

STDAPI  ReadStringStream( CStmBufRead & StmRead, LPOLESTR FAR * ppsz );
STDAPI  WriteStringStream( CStmBufWrite & StmWrite, LPCOLESTR psz );
STDAPI  OpenOrCreateStream( IStorage FAR * pstg, const OLECHAR FAR * pwcsName,
                                                      IStream FAR* FAR* ppstm);

//
// The following versions of StringStream are used with ANSI data
//
STDAPI  ReadStringStreamA( CStmBufRead & StmRead, LPSTR FAR * ppsz );


// read and write ole control stream (in ole2.dll)
STDAPI  WriteOleStg (LPSTORAGE pstg, IOleObject FAR* pOleObj,
                     DWORD dwReserved, LPSTREAM FAR* ppstmOut);
STDAPI WriteOleStgEx(LPSTORAGE pstg, IOleObject* pOleObj, DWORD dwReserved, 
                     DWORD dwGivenFlags, LPSTREAM* ppstmOut);
STDAPI  ReadOleStg (LPSTORAGE pstg, DWORD FAR* pdwFlags,
                DWORD FAR* pdwOptUpdate, DWORD FAR* pdwReserved,
                LPMONIKER FAR* ppmk, LPSTREAM FAR* pstmOut);
STDAPI ReadM1ClassStm(LPSTREAM pstm, CLSID FAR* pclsid);
STDAPI WriteM1ClassStm(LPSTREAM pstm, REFCLSID rclsid);
STDAPI ReadM1ClassStmBuf(CStmBufRead & StmRead, CLSID FAR* pclsid);
STDAPI WriteM1ClassStmBuf(CStmBufWrite & StmWrite, REFCLSID rclsid);

#endif // _UTSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ih\widewrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.h
//
//  Contents:   Wrapper functions for Win32c API used by 32-bit OLE 2
//
//  History:    12-27-93   ErikGav   Created
//              06-14-94   KentCe    Various Chicago build fixes.
//
//----------------------------------------------------------------------------

#ifndef _WIDEWRAP_H_
#define _WIDEWRAP_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING WIDEWRAP.H from " __FILE__)
#endif  /* RC_INVOKED */

//
// These are the definitions for NT
//
#define CreateFileT CreateFileW
#define DeleteFileT DeleteFileW
#define RegisterClipboardFormatT RegisterClipboardFormatW
#define GetClipboardFormatNameT GetClipboardFormatNameW
#define RegQueryValueT RegQueryValueW
#define RegSetValueT RegSetValueW
#define RegisterWindowMessageT RegisterWindowMessageW
#define RegOpenKeyExT RegOpenKeyExW
#define RegQueryValueExT RegQueryValueExW
#define CreateWindowExT CreateWindowExW
#define RegisterClassT RegisterClassW
#define UnregisterClassT UnregisterClassW
#define wsprintfT wsprintfW
#define CreateWindowT CreateWindowW
#define GetPropT GetPropW
#define SetPropT SetPropW
#define RemovePropT RemovePropW
#define GetProfileIntT GetProfileIntW
#define GlobalAddAtomT GlobalAddAtomW
#define GlobalGetAtomNameT GlobalGetAtomNameW
#define GetModuleFileNameT GetModuleFileNameW
#define CharPrevT CharPrevW
#define CreateFontT CreateFontW
#define LoadLibraryT LoadLibraryW
#define LoadLibraryExT LoadLibraryExW
#define RegDeleteKeyT RegDeleteKeyW
#define CreateProcessT CreateProcessW
#define RegEnumKeyExT RegEnumKeyExW
#define AppendMenuT AppendMenuW
#define OpenEventT OpenEventW
#define CreateEventT CreateEventW
#define GetDriveTypeT GetDriveTypeW
#define GetFileAttributesT GetFileAttributesW
#define RegEnumKeyT RegEnumKeyW
#define RegEnumValueT RegEnumValueW
#define FindFirstFileT FindFirstFileW
#define GetComputerNameT GetComputerNameW
#define GetShortPathNameT GetShortPathNameW
#define GetFullPathNameT GetFullPathNameW
#define SearchPathT SearchPathW
#define GlobalFindAtomT GlobalFindAtomW
#define GetClassNameT GetClassNameW
#define CreateFileMappingT CreateFileMappingW
#define OpenFileMappingT OpenFileMappingW
#define WNDCLASST WNDCLASSW

#endif  // _WIDEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ilib\daytona\makefile.inc ===
#
#   Get the UUIDs from built directory in common
#
uuid:	proxyb_i.c psfbuf_i.c rchanb_i.c stubb_i.c

proxyb_i.c: ..\..\common\daytona\proxyb_i.c
	copy ..\..\common\daytona\proxyb_i.c

psfbuf_i.c: ..\..\common\daytona\psfbuf_i.c
	copy ..\..\common\daytona\psfbuf_i.c

rchanb_i.c: ..\..\common\daytona\rchanb_i.c
	copy ..\..\common\daytona\rchanb_i.c

stubb_i.c: ..\..\common\daytona\stubb_i.c
	copy ..\..\common\daytona\stubb_i.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ilib\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   uuid
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\common\$(DEST_TREE);..\..\ih

C_DEFINES=    $(C_DEFINES)

SOURCES=      \
              ..\uuidole.cxx

UMTYPE=       windows
UMAPPL=
UMTEST=
UMLIBS=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ilib\uuidole.cxx ===
/*
	uuid.cpp  Include guid's to produce a GUID lib file.

	THIS IS TEMPORARY!!!

*/

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include <privguid.h>
#include <ole1cls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\precomp2.inc ===
#//+---------------------------------------------------------------
#//
#//  File:	precom2.inc
#//
#//  Contents:	directives for global precompiled include file when the
#//		sources file is two directories below ole232 (or wherever
#//		this file is located.  We could easily have precomp3 and
#//		precomp4 for other areas.  The ole2int.obj\* files should not
#//		otherwise be mentioned in the sources files.
#//
#//  History:	18-May-94   CraigWi	Created
#//             23-May-94   BillMo      Cairo fixed.
#//----------------------------------------------------------------

!ifdef OLE32ROOT
PCH_ROOT=$(OLE32ROOT)\ole232
!else
PCH_ROOT=..\..
!endif

INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\le2int.h
PRECOMPILED_TARGET=..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\le2int.pch
PRECOMPILED_OPTION=/Yule2int.h /Fp..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\le2int.pch
PRECOMPILED_OBJ=$(PCH_ROOT)\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\le2int.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\advise\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   advise
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\daholder.cpp \
              ..\oaholder.cpp

UMTYPE=       windows
USE_IOSTREAM=1

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\advise\daholder.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		daholder.cpp
//
//	Contents:
//		concrete implementation of IDataAdviseHolder, a helper
//		class for OLE server implementors
//
//	Classes:
//		CDAHolder
//
//	Functions:
//		CreateDataAdviseHolder
//
//	History:
//              01/20/95 - t-ScottH- added Dump methods to CDAHolder and
//                                   CEnumSTATDATA classes
//                                   added DumpCDAHolder & DumpCEnumSTATDATA APIs
//                                   put class definitions in header file daholder.h
//              03/09/94 - AlexGo  - fixed bugs with the enumerator and
//                                   disconnecting of bad advise sinks
//		01/24/94 - AlexGo  - first pass at conversion to Cairo-style
//				     memory allocation
//		01/11/94 - AlexGo  - added VDATEHEAP macros to all functions and
//			methods
//		12/09/93 - ChrisWe - fix test for error code after CoGetMalloc()
//			in CDAHolder::Advise
//		11/22/93 - ChrisWe - replace overloaded ==, != with
//			IsEqualIID and IsEqualCLSID
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#include "daholder.h"

#ifdef _DEBUG
#include "dbgdump.h"
#endif // _DEBUG

#pragma SEG(daholder)

NAME_SEG(DaHolder)
ASSERTDATA

//+----------------------------------------------------------------------------
//
//	Function:
//		CreateDataAdviseHolder, public
//
//	Synopsis:
//		Creates an instance of the CDAHolder class
//
//	Arguments:
//		[ppDAHolder] -- pointer to where to return the created
//			IDataAdviseHolder instance
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CreateDataAdviseHolder)
STDAPI CreateDataAdviseHolder(IDataAdviseHolder FAR* FAR* ppDAHolder)
{
	OLETRACEIN((API_CreateDataAdviseHolder, PARAMFMT("ppDAHolder= %p"), ppDAHolder));

        VDATEHEAP();
        VDATEPTROUT(ppDAHolder, IDataAdviseHolder*);

	*ppDAHolder = new FAR CDAHolder(); // task memory; use MEMCTX_TASK below

	CALLHOOKOBJECTCREATE(*ppDAHolder ? NOERROR : E_OUTOFMEMORY,
			     CLSID_NULL,
			     IID_IDataAdviseHolder,
			     (IUnknown **)ppDAHolder);

	HRESULT hr;

	hr = *ppDAHolder ? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);

	OLETRACEOUT((API_CreateDataAdviseHolder, hr));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::CDAHolder, public
//
//	Synopsis:
//		constructor
//
//	Effects:
//		returns with reference count set to 1
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_ctor)
CDAHolder::CDAHolder() : CSafeRefCount(NULL)
{
	VDATEHEAP();

	// set reference count
	SafeAddRef();

	// connections run from [1..infinity)
	m_dwConnection = 1;

	// there are no STATDATA entries yet
	m_iSize = 0;
	m_pSD = NULL;

	GET_A5();
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::~CDAHolder, private
//
//	Synopsis:
//		destructor
//
//	Effects:
//		frees resources associated with the CDAHolder
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

CDAHolder::~CDAHolder()
{
	VDATEHEAP();

	int iData; // counts array entries as we scan the array
	STATDATA FAR *pSD; // used to scan the array of STATDATA

	// release the array, if we've allocated it

	// REVIEW: If we want to be really safe, we should release
	// the stat data's either before or after our destructor.
	// The release of the advise sinks in the statdata elements
	// could possible result in us being re-entered (a potential
	// awkward state for the middle of a class destructor).

	// However, since nobody should be accesssing the advise
	// holder if we get to the destructor (since the reference
	// count would have to be zero), we are going to bag on
	// this modification for Daytona RC1.

	if (m_pSD)
	{
		for(pSD = m_pSD, iData = 0; iData < m_iSize; ++pSD, ++iData)
			UtReleaseStatData(pSD);

		PubMemFree(m_pSD);
	}
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[iid] -- IID of the desired interface
//		[ppv] -- pointer to a location to return the interface at
//
//	Returns:
//		E_NOINTERFACE, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_QueryInterface)
STDMETHODIMP CDAHolder::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
	VDATEHEAP();

	M_PROLOG(this);

	if (IsEqualIID(iid, IID_IUnknown) ||
			IsEqualIID(iid, IID_IDataAdviseHolder))
	{
		*ppv = (IDataAdviseHolder FAR *)this;
		AddRef();
		return NOERROR;
	}

	*ppv = NULL;
	return ReportResult(0, E_NOINTERFACE, 0, 0);
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_AddRef)
STDMETHODIMP_(ULONG) CDAHolder::AddRef()
{
	VDATEHEAP();

	M_PROLOG(this);

	return SafeAddRef();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Release,  public
//
//	Synopsis:
//		implementa IUnknown::Release
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_Release)
STDMETHODIMP_(ULONG) CDAHolder::Release()
{
	VDATEHEAP();

	M_PROLOG(this);

	return SafeRelease();

}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Advise, public
//
//	Synopsis:
//		Add a new advise sink to the list of advise sinks
//		managed by the data advise holder, and which will be notified
//		if a change is indicated using other IDataAdviseHolder
//		methods.  A data format is specified, and new data will be
//		sent to the sink in that format, when a change occurs.
//
//	Arguments:
//		[pDataObject] -- the source data object that presentations
//			should be taken from if an advise is to occur
//			immediately
//		[pFetc] -- The data format the advise sink is interested in
//		[advf] -- control flags
//		[pAdvSink] -- the advise sink being registered
//		[pdwConnection] -- a token that can be used to identify the
//			advise sink later on
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//		08/02/94 - AlexGo  - stabilized
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_Advise)
STDMETHODIMP CDAHolder::Advise(LPDATAOBJECT pDataObj, FORMATETC FAR* pFetc,
		DWORD advf, IAdviseSink FAR* pAdvSink,
		DWORD FAR* pdwConnection)
{
	VDATEHEAP();

	M_PROLOG(this);
	int iSDScan; // index of the scan of SD array entries
	int iSDFree; // index of first free SD entry, or (-1)
	STATDATA FAR *pSD; // scans across the array of STATDATA entries

	if( IsZombie() )
	{
		return ResultFromScode(CO_E_RELEASED);
	}

	CStabilize stabilize((CSafeRefCount *)this);

	if (pDataObj)
		VDATEIFACE(pDataObj);
	
	VDATEPTRIN(pFetc, FORMATETC);
	VDATEIFACE(pAdvSink);

        if (!HasValidLINDEX(pFetc))
        {
            return(DV_E_LINDEX);
        }

	// Validate where to return the connection.
	if (pdwConnection)
	{
		VDATEPTRIN(pdwConnection, DWORD);

		// Default to error case
		*pdwConnection = 0;
	}

	// scan and remove all unconnected advise sinks
	for(iSDFree = (-1), pSD = m_pSD, iSDScan = 0; iSDScan < m_iSize;
			++pSD, ++iSDScan)
	{
		// REVIEW, why do we have to go polling these?
		if (!pSD->pAdvSink || !IsValidInterface(pSD->pAdvSink))
		{
			// not valid, don't try to release
			pSD->pAdvSink = NULL;
			goto RemoveBadSD;
		}
		else if (!CoIsHandlerConnected(pSD->pAdvSink))
		{
			// sink no longer connected, release
		RemoveBadSD:
			// release any data.  UtReleaseStatData will
			// zero out the statdata structure.
			UtReleaseStatData(pSD);

		}

		// if we're still looking for a free entry, note if this one
		// is free
		if ((iSDFree == (-1)) && (pSD->dwConnection == 0))
			iSDFree = iSDScan;
	}
	
	// should we send the data immediately?
	if (advf & ADVF_PRIMEFIRST)
	{
		// We are not going to honor ADVF_PRIMEFIRST if pDataObj is
		// NULL, even when ADVF_NODATA is specfied. We want it to be
		// this way so that the apps which don't have any data at
		// startup time, could pass in NULL for pDataObject and
		// prevent us from sending any OnDataChange() notification.
		// Later when they have the data avaliable they can call
		// SendOnDataChange. (SRINIK)
		
		if (pDataObj)
		{
			STGMEDIUM stgmed;

			stgmed.tymed = TYMED_NULL;
			stgmed.pUnkForRelease = NULL;

			if (advf & ADVF_NODATA)
			{
				// don't sent data, send only the notification
				pAdvSink->OnDataChange(pFetc, &stgmed);
			
			}
			else
			{
				// get data from object and send it to sink
				if (pDataObj->GetData(pFetc,
						 &stgmed) == NOERROR)
				{
					pAdvSink->OnDataChange(pFetc, &stgmed);
					ReleaseStgMedium(&stgmed);
				}
			}
		
			// if we only have to advise once, we've done so, and
			// needn't make an entry in the advise array
			if (advf & ADVF_ONLYONCE)
				return NOERROR;
		}
	}	
		
	// remove the ADVF_PRIMEFIRST from flags.
	advf &= (~ADVF_PRIMEFIRST);
			
	// find a free list entry we can use, if we haven't got one
	if (iSDFree == (-1))
	{
		HRESULT hr;

		// REVIEW, can we share array reallocation code with
		// oaholder.cpp?  Why can't we just use realloc?

		// didn't find any free array entries above; since that
		// scanned the whole array, have to allocate new entries
		// here

		pSD = (STATDATA FAR *)PubMemAlloc(sizeof(STATDATA)*(m_iSize+
				CDAHOLDER_GROWBY));

		if (pSD == NULL)
			hr = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		else
		{
			// copy the old data over, if any, and free it
			if (m_pSD)
			{
				_xmemcpy((void FAR *)pSD, (void FAR *)m_pSD,
						sizeof(STATDATA)*m_iSize);

				PubMemFree(m_pSD);
			}

			// initialize newly allocated memory

			_xmemset((void FAR *)(pSD+m_iSize), 0,
					sizeof(STATDATA)*CDAHOLDER_GROWBY);

			// this is the index of the first free element
			iSDFree = m_iSize;

			// set up the STATDATA array
			m_pSD = pSD;
			m_iSize += CDAHOLDER_GROWBY;

			hr = NOERROR;
		}

		if (hr != NOERROR)
		{
			return(hr);
		}
	}

	// if we got here, we can add the new entry, and its index is iSDFree

	// point at the new element
	pSD = m_pSD+iSDFree;

	// Let the advise get added to the list			
	UtCopyFormatEtc(pFetc, &pSD->formatetc);
	pSD->advf = advf;
	pAdvSink->AddRef();
	pSD->pAdvSink = pAdvSink;
	pSD->dwConnection = m_dwConnection++;

	// return connection if user requested it
	if (pdwConnection)
		*pdwConnection = pSD->dwConnection;

	return NOERROR;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Unadvise, public
//
//	Synopsis:
//		removes the advise sink specified from the list of those
//		registered to receive notifications from this data advise
//		holder
//
//	Arguments:
//		[dwConnection] -- token that identifies which advise sink
//			to remove; this will have come from Advise().
//
//	Returns:
//		OLE_E_NOCONNECTION, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_Unadvise)
STDMETHODIMP CDAHolder::Unadvise(DWORD dwConnection)
{
	VDATEHEAP();

	M_PROLOG(this);
	int iData; // index into the STATDATA array
	STATDATA FAR *pSD; // pointer into the STATDATA array

	// protect this against being released via a circular reference
	CStabilize stabilize((CSafeRefCount *)this);

	for (pSD = m_pSD, iData = 0; iData < m_iSize; ++pSD, ++iData)
	{
		// is this the entry we're looking for?
		if (pSD->dwConnection == dwConnection)
		{
			// release resources for the entry.  UtReleaseStatData
			// will zero the statdata.

			UtReleaseStatData(pSD);

			return NOERROR;
		}
	}

	// if we found what we were looking for in the loop, we'd return
	// from there, and never get here.  Since we didn't, it must be
	// that there's no such connection
	return ReportResult(0, OLE_E_NOCONNECTION, 0, 0);
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::SendOnDataChange, public
//
//	Synopsis:
//		Send an OnDataChange notification to all advise sinks
//		registered with this data advise holder.
//
//	Arguments:
//		[pDataObject] -- the data object to get data from to send
//			to the advise sinks
//		[dwReserved] --
//		[advf] -- control flags
//
//	Returns:
//		S_OK
//
//	Notes:
//		More than one advise sink may be interested in obtaining
//		data in the same format.  It may be expensive for the data
//		object to create copies of the data in requested formats.
//		Therefore, when a change is signalled, the data formats
//		are cached.  As each advise sink is to be notified, we
//		check to see if the format it is requesting has already been
//		gotten from the data object (with GetData().)  If it has,
//		then we simply send that copy again.  If not, we get the
//		new format, and add that to the cache.
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_SendOnDataChange)
STDMETHODIMP CDAHolder::SendOnDataChange(IDataObject FAR* pDataObject,
		DWORD dwReserved, DWORD advf)
{
	VDATEHEAP();

	A5_PROLOG(this);
	HRESULT hresult = NOERROR; // error status so far
	UINT cFetcTotal; // maximum number of formats we will cache
	UINT cFetcGotten; // the actual number of formats in the cache
	UINT cFetc; // the index of the format in the cache under consideration
	FORMATETC FAR* rgFetc; // a record of the cached presentations
	STGMEDIUM FAR* rgStgmed; // the cached data presentations
	UINT cStatData; // a counter for the STATDATA array elements
	STATDATA FAR *pSD; // a pointer into the array of STATDATA elements

	VDATEIFACE(pDataObject);
	
	// in the worst case, every advise sink has requested a unique
	// data format, and we won't get any duplicates.  This means that
	// we will wind up caching all of them.
	cFetcTotal = m_iSize;

	// if there are no entries, there's nothing to do
	if (cFetcTotal == 0)
		return NOERROR;

	// some advise sinks may use these notifications to change their
	// requested notifications; due to possible circular references,
	// this could to lead to a release of this holder.  Protect against
	// this here; this is released after most work is done, towards the
	// end of this function
	CStabilize stabilize((CSafeRefCount *)this);

	// alloc rgFetc and rgStgmed to accomodate all the cache entries
	// if either fails to be allocated, we quit
	rgFetc = (FORMATETC FAR *)PubMemAlloc(cFetcTotal * sizeof(FORMATETC));
	rgStgmed = (STGMEDIUM FAR *)PubMemAlloc(cFetcTotal * sizeof(STGMEDIUM));

	if (rgFetc == NULL || rgStgmed == NULL)
	{
		hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		goto FreeExit;
	}

	// zero out STDMEDIUM entries
	_xmemset((void FAR *)rgStgmed, 0, sizeof(STGMEDIUM)*cFetcTotal);
		
	// ensure we have the right data and send to each advise sink
	// note the loop is bounded by cFetcTotal, preventing additional
	// sinks from being notified, if they are registered during these
	// notifications.  cStatData is not used in the loop body, so it
	// counts down

	for (cFetcGotten = 0, pSD = m_pSD, cStatData = cFetcTotal;
			cStatData; ++pSD, --cStatData)
	{
		// if this slot is not in use, skip it
		if (!pSD->dwConnection)
			continue;

		// if the sink is not interested in presentation data,
		// proceed to notify it immediately, unless this notification
		// is announcing the termination of the source
		if ((pSD->advf & ADVF_NODATA) &&
				!(advf & ADVF_DATAONSTOP))
		{
			STGMEDIUM stgmed;

			// don't sent data; use format from collection
			// and null STGMEDIUM.
			// REVIEW, should this be done once, up above?
			stgmed.tymed = TYMED_NULL;
			stgmed.pUnkForRelease = NULL;
			pSD->pAdvSink->OnDataChange(&pSD->formatetc, &stgmed);

			// REVIEW, what does this do for NULL?
			// if nothing, we can share a stdmedNULL, as above
			ReleaseStgMedium(&stgmed);

			// clean up at end of loop
			goto DataSent;
		}
		
		// if the sink is interested in data at the time of
		// termination, and the source is not terminating, OR, the
		// sink is not interested in data at the time of termination,
		// and we are terminating, skip this sink, and proceed
		if ((pSD->advf & ADVF_DATAONSTOP) !=
				(advf & ADVF_DATAONSTOP))
			continue;
		
		// check the requested format against the list of formats
		// for which we've already retrieved the presentation data.
		// if there is a match, proceed to send that data immediately
		// from here on in this loop body, cFetc is the index of the
		// data presentation to send to the current sink
		// REVIEW PERF: this is an n-squared algorithm;
		// we check the array of cached presentations for each
		// advise sink
		for (cFetc = 0; cFetc < cFetcGotten; ++cFetc)
		{
			// if match, continue outer loop
			if (UtCompareFormatEtc(&rgFetc[cFetc],
					&pSD->formatetc) == UTCMPFETC_EQ)
				goto SendThisOne;
		}

		// if we get here, we have not already fetched presentation	
		// data that matches the requested format

		// init FORMATETC (copy of needed one)
		// STDMEDIUM was initialized after its allocation to all NULL
		rgFetc[cFetcGotten] = pSD->formatetc;

		// get the data in the requested format from the data object
		// REVIEW: assume STGMEDIUM untouched if error
		// (i.e., still null)
		hresult = pDataObject->GetData(&rgFetc[cFetcGotten],
				&rgStgmed[cFetcGotten]);

		// REVIEW, what is this checking?
		AssertOutStgmedium(hresult, &rgStgmed[cFetcGotten]);

		// the presentation to send is the newly cached one
		// there is now one more entry in the cache array
		cFetc = cFetcGotten++;

	SendThisOne:
		// when we get here, rgFetc[cFetc] is the format to send to the
		// current advise sink

		// send change notification with requested data

                // The advise sink could have disappeared in the meantime
                // (if the the GetData call above resulted in an Unadvise,
                // for example), so we must validate the pAdvSInk first.
                // pSD will remain a valid regardless, and the advise
                // flags will have been zero'd, so it is safe to proceed
                // through the loop without "continue"ing.

                if (pSD->pAdvSink)
                {
		        pSD->pAdvSink->OnDataChange(&rgFetc[cFetc],
			        	&rgStgmed[cFetc]);
                }


	DataSent:
		// When we get here, something has been sent, possibly
		// an empty storage medium

		// if the sink requested to only be notified once, we
		// can free it here
		if (pSD->advf & ADVF_ONLYONCE)
		{
 			// free the stat data.  UtReleaseStatData will
			// zero the statdata, thus marking the connection
			// as invalid.

			UtReleaseStatData(pSD);

 		}
	}

	// free all stgmeds retrieved; FORMATETC.ptd was not allocated
	for (cFetc =  0; cFetc < cFetcGotten; ++cFetc)
		ReleaseStgMedium(&rgStgmed[cFetc]);
	
	hresult = NOERROR;

FreeExit:
	if (rgFetc != NULL)
		PubMemFree(rgFetc);

	if (rgStgmed != NULL)
		PubMemFree(rgStgmed);

	RESTORE_A5();

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDAHolder::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CDAHolder::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCSafeRefCount;
    char *pszSTATDATA;
    dbgstream dstrPrefix;
    dbgstream dstrDump(1000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Next Connection ID       = " << m_dwConnection << endl;

    dstrDump << pszPrefix << "No. of STATDATA elements = " << m_iSize << endl;

    for (i = 0; i < m_iSize; i++)
    {
        pszSTATDATA = DumpSTATDATA( &m_pSD[i], ulFlag, nIndentLevel + 1) ;
        dstrDump << pszPrefix << "STATDATA element: " << i << endl;
        dstrDump << pszSTATDATA;
        CoTaskMemFree(pszSTATDATA);
    }

    // clean up and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif //_DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCDAHolder, public (_DEBUG only)
//
//  Synopsis:   calls the CDAHolder::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pIDAH]         - pointer to IDAHolder (which we cast to CDAHolder)
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//  This API !!REQUIRES!! that class CDAHolder inherits from IDataAdviseHolder
//  first in order that we can pass in a parameter as a pointer to an
//  IDataAdviseHolder and then cast it to a CDAHolder.
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCDAHolder(IDataAdviseHolder *pIDAH, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pIDAH == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    CDAHolder *pCDAH = (CDAHolder *)pIDAH;

    hresult = pCDAH->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::CEnumSTATDATA, public
//
//	Synopsis:
//		constructor
//
//	Effects:
//		sets reference count to 1
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_ctor)
CEnumSTATDATA::CEnumSTATDATA(CDAHolder FAR* pHolder, int iDataStart)
{
	VDATEHEAP();

	GET_A5();

	// set reference count
	m_refs = 1;

	// first element to examine for return
	m_iDataEnum = iDataStart;

	// initialize pointer to holder, and addref, so it doesn't go
	// away while enumerator is alive
	(m_pHolder = pHolder)->AddRef();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::~CDAHolder, private
//
//	Synopsis:
//		destructor
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_dtor)
CEnumSTATDATA::~CEnumSTATDATA()
{
	VDATEHEAP();

	M_PROLOG(this);

	m_pHolder->Release();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[iid] -- IID of the desired interface
//		[ppv] -- pointer to a location to return the interface at
//
//	Returns:
//		E_NOINTERFACE, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_QueryInterface)
STDMETHODIMP CEnumSTATDATA::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
	VDATEHEAP();

	M_PROLOG(this);

	if (IsEqualIID(iid, IID_IUnknown) ||
			IsEqualIID(iid, IID_IEnumSTATDATA))
	{
		*ppv = (IEnumSTATDATA FAR *)this;
		AddRef();
		return NOERROR;
	}

	*ppv = NULL;
	return ReportResult(0, E_NOINTERFACE, 0, 0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CEnumSTATDATA_AddRef)
STDMETHODIMP_(ULONG) CEnumSTATDATA::AddRef()
{
	VDATEHEAP();

	M_PROLOG(this);

	return ++m_refs;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::Release, public
//
//	Synopsis:
//		implementa IUnknown::Release
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Release)
STDMETHODIMP_(ULONG) CEnumSTATDATA::Release()
{
	VDATEHEAP();

	M_PROLOG(this);

	if (--m_refs == 0)
	{
		delete this;
		return 0;
	}

	return m_refs;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::Next, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Next()
//
//	Effects:
//
//	Arguments:
//		[celt] -- number of elements requested on this call
//		[rgelt] -- pointer to an array of STATDATAs where copies of
//			the elements can be returned
//		[pceltFectched] -- a pointer to where to return the number of
//			elements actually fetched.  May be NULL
//
//	Returns:
//		S_FALSE, S_OK
//
//	Notes:
//
//	History:
//              03/09/94 - AlexGo  - the enumerator no longer enumerates
//                                   "empty" statdata's in the m_pSD array.
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Next)
STDMETHODIMP CEnumSTATDATA::Next(ULONG celt, STATDATA FAR *rgelt,
		ULONG FAR* pceltFetched)
{
	VDATEHEAP();

	M_PROLOG(this);
	UINT ielt; // count of the number of elements fetched so far

	for (ielt = 0; (ielt < celt) && (m_iDataEnum < m_pHolder->m_iSize);
			m_iDataEnum++)
	{
                if( m_pHolder->m_pSD[m_iDataEnum].dwConnection != 0)
                {
                        ielt++;
                        // copy all bits; AddRef and copy DVTARGETDEVICE
                        // separately
	                UtCopyStatData(&m_pHolder->m_pSD[m_iDataEnum],
                                rgelt++);
                }
  	}

	// return number of elements fetched, if required
	if (pceltFetched)
		*pceltFetched = ielt;

	// no error, if exactly the requested number of elements was fetched
	return ielt == celt ? NOERROR : ReportResult(0, S_FALSE, 0, 0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Skip, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Skip
//
//	Arguments:
//		[celt] -- the number of elements in the collection to skip
//			over
//
//	Returns:
//		S_FALSE, S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Skip)
STDMETHODIMP CEnumSTATDATA::Skip(ULONG celt)
{
	VDATEHEAP();

	M_PROLOG(this);
	STATDATA FAR *pSD; // scans over the array of STATDATA entries

	// if the enumeration would take us off the end of the array
	// mark the enumeration as complete
	if (m_iDataEnum + celt > (ULONG)m_pHolder->m_iSize)
	{
		m_iDataEnum = m_pHolder->m_iSize;
	
		return ReportResult(0, S_FALSE, 0, 0);
	}


	// skip over valid entries in the array, counting down until
	// we don't have to skip over any more, or until we get to
	// the end of the array
	for(pSD = m_pHolder->m_pSD+m_iDataEnum;
			celt && (m_iDataEnum < m_pHolder->m_iSize);
			++m_iDataEnum)
	{
		// if the connection is valid, count it as a skipped
		// enumerated item
		if (pSD->dwConnection != 0)
			--celt;
	}

	// if we could skip them all, indicate by non-error return
	if (celt == 0)
		return(NOERROR);

	return(ReportResult(0, S_FALSE, 0, 0));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Reset, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Reset
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Reset)
STDMETHODIMP CEnumSTATDATA::Reset()
{
	VDATEHEAP();

	M_PROLOG(this);

	// move back to the beginning of the STATDATA array
	m_iDataEnum = 0;

	return NOERROR;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Clone, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Clone
//
//	Arguments:
//		none
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Clone)
STDMETHODIMP CEnumSTATDATA::Clone(LPENUMSTATDATA FAR* ppenum)
{
	VDATEHEAP();

	M_PROLOG(this);

	*ppenum = new FAR CEnumSTATDATA(m_pHolder, m_iDataEnum);

	return *ppenum ? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::EnumAdvise, public
//
//	Synopsis:
//		implements IDataAdviseHolder::EnumAdvise
//
//	Effects:
//		creates an enumerator for the registered advise sinks
//
//	Arguments:
//		[ppenumAdvise] -- a pointer to where to return the enumerator
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_EnumAdvise)
STDMETHODIMP CDAHolder::EnumAdvise(IEnumSTATDATA FAR* FAR* ppenumAdvise)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEPTROUT(ppenumAdvise, IEnumSTATDATA FAR*);

	// REVIEW, memory leak if bad ppenumAdvise pointer
	*ppenumAdvise = new FAR CEnumSTATDATA(this, 0);

	return *ppenumAdvise ? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumSTATDATA::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEnumSTATDATA::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDAH;
    dbgstream dstrPrefix;
    dbgstream dstrDump(1000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References     = " << m_refs       << endl;

    dstrDump << pszPrefix << "Index to next element = " << m_iDataEnum  << endl;

    if (m_pHolder != NULL)
    {
        pszDAH = DumpCDAHolder(m_pHolder, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "Data Advise Holder: "                 << endl;
        dstrDump << pszDAH;
        CoTaskMemFree(pszDAH);
    }
    else
    {
    dstrDump << pszPrefix << "pCDAHolder            = " << m_pHolder    << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEnumSTATDATA, public (_DEBUG only)
//
//  Synopsis:   calls the CEnumSTATDATA::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pESD]          - pointer to CEnumSTATDATA
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEnumSTATDATA(CEnumSTATDATA *pESD, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pESD == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pESD->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\api.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   api.cpp
//
//  Contents:   OLE2 api definitions.
//
//  Classes:    none
//
//  Functions:  OleRun
//              OleIsRunning
//              OleLockRunning
//              OleSetContainedObject
//              OleNoteObjectVisible
//              OleGetData
//              OleSetData
//              OleSave
//              ReadClassStg
//              WriteClassStg
//              WriteFmtUserTypeStg
//              ReadFmtUserTypeStg
//              ReadM1ClassStm  (internal)
//              WriteM1ClassStm (internal)
//              ReadClassStm
//              WriteClassStm
//              ReleaseStgMedium
//              OleDuplicateData
//              ReadOleStg  (internal)
//              WriteOleStg (internal)
//              GetDocumentBitStg (internal and unused)
//              GetConvertStg
//              SetConvertStg
//              ReadClipformatStm
//              WriteClipformatStm
//              WriteMonikerStm
//              ReadMonikerStm
//              OleDraw
//              CreateObjectDescriptor (internal (for now))
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Buffer version of Read/WriteM1ClassStm.
//              04-Jun-94 alexgo    added CreateObjectDescriptor and
//                                  enhanced metafile support
//              25-Jan-94 alexgo    first pass at Cairo-style memory allocation
//              11-Jan-94 chriswe   fixed broken asserts
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//                      and fixed compile warnings
//              08-Dec-93 ChrisWe  added necessary casts to GlobalLock() calls
//                      resulting from removing bogus GlobalLock() macros in
//                      le2int.h
//              21-Oct-93 Alex Gounares (alexgo)  32-bit port, commented
//                      and substantial cleanup
//              (curts)  11/01/92   Added OleDuplicateMedium
//              (srinik) 06/22/92   Moved ReadStringStream, WriteStringStream
//                      to "utstream.cpp"
//              (barrym) 06/02/92   Moved OleSave, ReadClassStg,
//                      WriteClassStg, added
//                      OleSaveCompleted, OleIsDirty
//              28-May-92 Srini Koppolu (srinik)  Original Author
//
//--------------------------------------------------------------------------


// REVIEW FINAL: probably want to change all pstm->Read into StRead(pstm...)
// except if spec issue 313 is accepted in which case we change StRead into
// pstm->Read.

#include <le2int.h>
#pragma SEG(api)

#define COMPOBJSTM_HEADER_SIZE  7

FARINTERNAL_(HBITMAP) BmDuplicate(HBITMAP hold, DWORD FAR* lpdwSize,
    LPBITMAP lpBm);

NAME_SEG(Api)
ASSERTDATA

#define MAX_STR 512

DWORD gdwFirstDword = (DWORD)MAKELONG(COMPOBJ_STREAM_VERSION,
                BYTE_ORDER_INDICATOR);
DWORD gdwOleVersion = MAKELONG(OLE_STREAM_VERSION, OLE_PRODUCT_VERSION);


//+-------------------------------------------------------------------------
//
//  Function:   OleRun
//
//  Synopsis:   Calls IRunnableObject->Run on a given object
//
//  Effects:    Usually puts on object in the RunningObjectTable
//
//  Arguments:  [lpUnkown]  --  Pointer to the object
//
//  Requires:
//
//  Returns:    The  HRESULT from the Run method.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    ported to 32bit
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRun)
STDAPI  OleRun(IUnknown FAR* lpUnknown)
{
    OLETRACEIN((API_OleRun, PARAMFMT("lpUnknown= %p"), lpUnknown));

    VDATEHEAP();

    HRESULT         hresult;
    IRunnableObject FAR*    pRO;

    VDATEIFACE_LABEL(lpUnknown, errRtn, hresult);

    if (lpUnknown->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, assume already running
        hresult = NOERROR;
        goto errRtn;
    }

    hresult = pRO->Run(NULL);
    pRO->Release();

errRtn:
    OLETRACEOUT((API_OleRun, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleIsRunning
//
//  Synopsis:   calls IRunnableObject->IsRunning on the given object
//
//  Effects:    Usually returns whether or not an object is in the
//      Running Object Table.
//
//  Arguments:  [lpOleObj]  --  pointer to the object
//
//  Requires:
//
//  Returns:    TRUE or FALSE (from IRO->IsRunning)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    ported to 32bit
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleIsRunning)
STDAPI_(BOOL)  OleIsRunning(IOleObject FAR* lpOleObj)
{
    OLETRACEIN((API_OleIsRunning, PARAMFMT("lpOleObj= %p"), lpOleObj));

    VDATEHEAP();

    IRunnableObject FAR*    pRO;
    BOOL            bRetval;

    GEN_VDATEIFACE_LABEL(lpOleObj, FALSE, errRtn, bRetval);

    if (lpOleObj->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, assume already running
        bRetval = TRUE;
        goto errRtn;
    }

    bRetval = pRO->IsRunning();
    pRO->Release();

errRtn:
    OLETRACEOUTEX((API_OleIsRunning, RETURNFMT("%B"), bRetval));

    return bRetval;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleLockRunning
//
//  Synopsis:   calls IRunnableObject->LockRunning on the given object
//
//  Effects:    The object usually ends up calling CoLockObjectExternal
//      on itself
//
//  Arguments:  [lpUnknown]           --  pointer to the object
//      [fLock]              --  TRUE == lock running
//                                       FALSE == unlock running
//      [fLastUnlockCloses]  --  if TRUE, IRO->LockRunning
//                                       is supposed to call IOO->Close
//                                       if this was the last unlock
//
//  Requires:
//
//  Returns:    HRESULT from IRunnableObject->LockRunning()
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    32bit port, changed GEN_VDATEIFACE
//                  to VDATEIFACE to fix a bug
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleLockRunning)
STDAPI  OleLockRunning(LPUNKNOWN lpUnknown, BOOL fLock, BOOL fLastUnlockCloses)
{
    OLETRACEIN((API_OleLockRunning, PARAMFMT("lpUnknown= %p, fLock= %B, fLastUnlockCloses= %B"),
                lpUnknown, fLock, fLastUnlockCloses));

    VDATEHEAP();

    IRunnableObject FAR*    pRO;
    HRESULT         hresult;

    VDATEIFACE_LABEL(lpUnknown, errRtn, hresult);

    if (lpUnknown->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, no locks
        hresult = NOERROR;
        goto errRtn;
    }

        hresult = pRO->LockRunning(fLock, fLastUnlockCloses);
        pRO->Release();

errRtn:
    OLETRACEOUT((API_OleLockRunning, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleSetContainedObject
//
//  Synopsis:   calls IRunnableObject->SetContainedObject on the given object
//
//  Effects:    Usually has the effect of calling CoLockObjectExternal
//      (lpUnkown, !fContained, FALSE).
//
//  Arguments:  [lpUnknown]  --  pointer to the object
//      [fContained] --  if TRUE, the object is an embedding
//
//  Requires:
//
//  Returns:    HRESULT from the IRO->SetContainedObject call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-92 alexgo    32bit port, changed GEN_VDATEIFACE to
//                  VDATEIFACE to fix a bug
//
//  Notes:  Containers usually call OleSetContainedObject(..,TRUE) after
//      OleLoad or OleCreate.  The basic idea is to tell OLE that
//      the object is an embedding.  The real effect is to unlock
//      the object (since all objects start out locked) so that
//      other connections may determine it's fate while invisible.
//      OleNoteObjectVisible, for instance, would be called to lock
//      the object when it become visible.
//
//
//--------------------------------------------------------------------------

#pragma SEG(OleSetContainedObject)
STDAPI OleSetContainedObject(LPUNKNOWN lpUnknown, BOOL fContained)
{
    OLETRACEIN((API_OleSetContainedObject, PARAMFMT("lpUnknown= %p, fContained= %B"),
                lpUnknown, fContained));

    VDATEHEAP();

    IRunnableObject FAR*    pRO;
    HRESULT         hresult;

    VDATEIFACE_LABEL(lpUnknown, errRtn, hresult);

    if (lpUnknown->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, assume container-ness doesn't matter
        hresult = NOERROR;
        goto errRtn;
    }

    hresult = pRO->SetContainedObject(fContained);
    pRO->Release();

errRtn:
    OLETRACEOUT((API_OleSetContainedObject, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleNoteObjectVisible
//
//  Synopsis:   Simple calls CoLockObjectExternal
//
//  Effects:
//
//  Arguments:  [lpUnknown] --  pointer to the object
//      [fVisible]  --  if TRUE, then lock the object,
//              if false, then unlock
//
//  Requires:
//
//  Returns:    HRESULT from CoLockObjectExternal
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleNoteObjectVisible)
STDAPI OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
{
    OLETRACEIN((API_OleNoteObjectVisible, PARAMFMT("pUnknown= %p, fVisible= %B"),
                                pUnknown, fVisible));

    VDATEHEAP();

    // NOTE: we as fLastUnlockReleases=TRUE here because there would
    // otherwise be no other way to fully release the stubmgr.  This
    // means that objects can't use this mechanism to hold invisible
    // objects alive.
    HRESULT hr;

    hr = CoLockObjectExternal(pUnknown, fVisible, TRUE);

    OLETRACEOUT((API_OleNoteObjectVisible, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleSave
//
//  Synopsis:   Writes the CLSID to the storage and calls IPersistStorage->
//      Save()
//
//  Effects:
//
//  Arguments:  [pPS]          --  pointer to the IPersistStorage interface
//                                 on the object to be saved
//      [pstgSave]     --  pointer to the storage to which the object
//                                 should be saved
//      [fSameAsLoad]  --  FALSE indicates a SaveAs operation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      22-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleSave)
STDAPI  OleSave(
    IPersistStorage FAR*    pPS,
    IStorage FAR*       pstgSave,
    BOOL            fSameAsLoad
)
{
    OLETRACEIN((API_OleSave, PARAMFMT("pPS= %p, pstgSave= %p, fSameAsLoad= %B"),
                pPS, pstgSave, fSameAsLoad));

    VDATEHEAP();

    HRESULT     hresult;
    CLSID       clsid;

    VDATEIFACE_LABEL(pPS, errRtn, hresult);
    VDATEIFACE_LABEL(pstgSave, errRtn, hresult);

    if (hresult = pPS->GetClassID(&clsid))
    {
        goto errRtn;
    }

    if (hresult = WriteClassStg(pstgSave, clsid))
    {
        goto errRtn;
    }

    if ((hresult = pPS->Save(pstgSave, fSameAsLoad)) == NOERROR)
    {
        hresult = pstgSave->Commit(0);
    }

errRtn:
    OLETRACEOUT((API_OleSave, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadClassStg
//
//  Synopsis:   Calls IStorage->Stat to get the CLSID from the given storage
//
//  Effects:
//
//  Arguments:  [pstg]    -- pointer to the storage
//      [pclsid]  -- place to return the CLSID
//
//  Requires:
//
//  Returns:    HRESULT from the IS->Stat call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      22-Oct-93 alexgo    32bit port, fixed bug with invalid
//                  [pclsid] and error on IS->Stat
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(ReadClassStg)
STDAPI ReadClassStg( IStorage FAR * pstg, LPCLSID pclsid)
{
    OLETRACEIN((API_ReadClassStg, PARAMFMT("pstg= %p, pclsid= %p"),
                pstg, pclsid));

    VDATEHEAP();

    HRESULT         hresult;
    STATSTG statstg;

    VDATEIFACE_LABEL(pstg, errRtn, hresult);
    VDATEPTROUT_LABEL(pclsid, CLSID, errRtn, hresult);

    if ((hresult = pstg->Stat(&statstg, STATFLAG_NONAME)) != NOERROR)
    {
        *pclsid = CLSID_NULL;
        goto errRtn;
    }

    *pclsid = statstg.clsid;

errRtn:
    OLETRACEOUT((API_ReadClassStg, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteClassStg
//
//  Synopsis:   Calls IStorage->SetClass to store the CLSID in the given
//      storage
//
//  Effects:
//
//  Arguments:  [pstg]  --  pointer to the storage
//      [clsid] --  the CLSID to write into the storage
//
//  Requires:
//
//  Returns:    HRESULT from the IS->SetClass call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      22-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(WriteClassStg)
STDAPI WriteClassStg( IStorage FAR * pstg, REFCLSID clsid)
{
    OLETRACEIN((API_WriteClassStg, PARAMFMT("pstg= %p, clsid= %I"),
                pstg, &clsid));

    VDATEHEAP();

    HRESULT hr;

    VDATEIFACE_LABEL(pstg, errRtn, hr);

    // write clsid in storage (what is read above)
    hr = pstg->SetClass(clsid);

errRtn:
    OLETRACEOUT((API_WriteClassStg, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadM1ClassStm
//
//  Synopsis:   Reads -1L, CLSID from the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      --  pointer to the stream
//              [pclsid]    --  where to put the clsid
//
//  Requires:
//
//  Returns:    HRESULT from the ReadM1ClassStm.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-Oct-93 alexgo    32bit port
//              20-Feb-95 KentCe    Convert to buffered stream reads.
//
//  Notes:      Internal API.
//
//              Reads -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI ReadM1ClassStm(LPSTREAM pStm, LPCLSID pclsid)
{
    VDATEHEAP();
    CStmBufRead StmRead;
    HRESULT error;


    StmRead.Init(pStm);

    error = ReadM1ClassStmBuf(StmRead, pclsid);

    if (error != NOERROR)
        *pclsid = CLSID_NULL;

    StmRead.Release();

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteM1ClassStm
//
//  Synopsis:   Writes -1L, CLSID to the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      --  pointer to the stream
//              [clsid]     --  CLSID to be written
//
//  Requires:
//
//  Returns:    HRESULT from the WriteM1ClassStm
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-84 alexgo    changed dw from a DWORD to a LONG
//              24-Oct-93 alexgo    32bit port
//              20-Feb-95 KentCe    Convert to buffered stream writes.
//
//  Notes:      Internal API.
//
//              Writess -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI WriteM1ClassStm(LPSTREAM pStm, REFCLSID clsid)
{
    VDATEHEAP();

    CStmBufWrite StmWrite;
    HRESULT error;

    VDATEIFACE( pStm );


    StmWrite.Init(pStm);

    error = WriteM1ClassStmBuf(StmWrite, clsid);
    if (FAILED(error))
    {
        goto errRtn;
    }

    error = StmWrite.Flush();

errRtn:
    StmWrite.Release();

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadM1ClassStmBuf
//
//  Synopsis:   Reads -1L and CLSID from the given buffered stream.
//
//  Arguments:  [StmRead]   --  Stream Read Object.
//              [pclsid]    --  Where to put the clsid
//
//  Returns:    HRESULT from the StmRead.Read's
//
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Convert to buffered stream reads.
//              24-Oct-93 alexgo    32bit port
//
//  Notes:      Internal API.
//
//              Reads -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI ReadM1ClassStmBuf(CStmBufRead & StmRead, LPCLSID pclsid)
{
    VDATEHEAP();

    HRESULT error;
    LONG lValue;


    if ((error = StmRead.ReadLong(&lValue)) != NOERROR)
    {
        goto errRtn;
    }

    if (lValue == -1)
    {
        // have a GUID
        error = StmRead.Read((void FAR *)pclsid, sizeof(CLSID));
    }
    else
    {
        // this is now an error; we don't allow string form
        // of clsid anymore
        error = ResultFromScode(E_UNSPEC);
    }

errRtn:
    if (error != NOERROR)
    {
        *pclsid = CLSID_NULL;
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteM1ClassStmBuf
//
//  Synopsis:   Writes -1L and CLSID to the given buffered stream.
//
//  Arguments:  [StmRead]   --  Stream Write Object.
//              [pclsid]    --  Where to read the clsid
//
//  Returns:    HRESULT from the StmWrite.Write's
//
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Convert to buffered stream reads.
//              24-Oct-93 alexgo    32bit port
//
//  Notes:      Internal API.
//
//              Writess -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI WriteM1ClassStmBuf(CStmBufWrite & StmWrite, REFCLSID clsid)
{
    VDATEHEAP();

    HRESULT error;

    // format is -1L followed by GUID
    if ((error = StmWrite.WriteLong(-1)) != NOERROR)
        return error;

    return StmWrite.Write((LPVOID)&clsid, sizeof(clsid));
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadClassStm
//
//  Synopsis:   Reads the CLSID from the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      -- pointer to the stream
//      [pclsid]    -- where to put the clsid
//
//  Requires:
//
//  Returns:    HRESULT from the IStream->Read
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      24-Oct-93 alexgo     32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(ReadClassStm)
// reads CLSID from stream swapping bytes on big-endian machines
STDAPI ReadClassStm(LPSTREAM pStm, LPCLSID pclsid)
{
    OLETRACEIN((API_ReadClassStm, PARAMFMT("pStm= %p, pclsid= %p"), pStm, pclsid));

    VDATEHEAP();
    HRESULT error;

    VDATEIFACE_LABEL( pStm, errRtn, error );
    VDATEPTROUT_LABEL(pclsid, CLSID, errRtn, error);

    if ((error = StRead(pStm, (void FAR *)pclsid, sizeof(CLSID)))
        != NOERROR)
        *pclsid = CLSID_NULL;

errRtn:
    OLETRACEOUT((API_ReadClassStm, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteClassStm
//
//  Synopsis:   Writes the class ID to the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      --  pointer to the stream
//      [clsid]     --  CLSID to write to the stream
//
//  Requires:
//
//  Returns:    HRESULT from the IStream->Write call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      24-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(WriteClassStm)
// writes CLSID to stream swapping bytes on big-endian machines
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID clsid)
{
    OLETRACEIN((API_WriteClassStm, PARAMFMT("pStm= %p, clsid= %I"), pStm, &clsid));

    VDATEHEAP();

    HRESULT hr;

    VDATEIFACE_LABEL( pStm, errRtn, hr);

    hr = pStm->Write(&clsid, sizeof(clsid), NULL);

errRtn:
    OLETRACEOUT((API_WriteClassStm, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseStgMedium
//
//  Synopsis:   Releases any resources held by a storage medium
//
//  Arguments:  [pMedium]   --  pointer to the storage medium
//
//  Returns:    nothing
//
//  History:    dd-mmm-yy Author    Comment
//              24-Oct-93 alexgo    32-bit port
//              15-May-94 DavePl    Added EMF support
//
//--------------------------------------------------------------------------


#pragma SEG(ReleaseStgMedium)
STDAPI_(void) ReleaseStgMedium( LPSTGMEDIUM pMedium )
{
    OLETRACEIN((API_ReleaseStgMedium, PARAMFMT("pMedium= %p"), pMedium));

    VDATEHEAP();

    if (pMedium) {

        BOOL fPunkRel;

        //VDATEPTRIN rejects NULL
        VOID_VDATEPTRIN_LABEL( pMedium, STGMEDIUM, errRtn);
        fPunkRel = pMedium->pUnkForRelease != NULL;

        switch (pMedium->tymed) {
            case TYMED_HGLOBAL:
                if (pMedium->hGlobal != NULL && !fPunkRel)
                    Verify(GlobalFree(pMedium->hGlobal) == 0);
                break;

            case TYMED_GDI:
                if (pMedium->hGlobal != NULL && !fPunkRel)
                    DeleteObject(pMedium->hGlobal);
                break;

            case TYMED_ENHMF:
                if (pMedium->hEnhMetaFile != NULL && !fPunkRel)
                {
                        Verify(DeleteEnhMetaFile(pMedium->hEnhMetaFile));
                };
                break;

            case TYMED_MFPICT:
                if (pMedium->hGlobal != NULL && !fPunkRel) {
                    LPMETAFILEPICT  pmfp;

                    if ((pmfp = (LPMETAFILEPICT)GlobalLock(pMedium->hGlobal)) == NULL)
                        break;

                    DeleteMetaFile(pmfp->hMF);
                    GlobalUnlock(pMedium->hGlobal);
                    Verify(GlobalFree(pMedium->hGlobal) == 0);
                }
                break;

            case TYMED_FILE:
                if (pMedium->lpszFileName != NULL) {
                    if (!IsValidPtrIn(pMedium->lpszFileName, 1))
                        break;
                    if (!fPunkRel) {
                        DeleteFile(pMedium->lpszFileName);
                    }

        //  WARNING: there was a bug in the 16bit code that the filename
        //  string was not being freed if pUnkForRelease was NULL. the
        //  spec says it should delete the string, so we follow the spec
        //  here.

                    PubMemFree(pMedium->lpszFileName);
                    pMedium->lpszFileName = NULL;

                }
                break;

            case TYMED_ISTREAM:
                if (pMedium->pstm != NULL &&
                    IsValidInterface(pMedium->pstm))
                    pMedium->pstm->Release();
                break;

            case TYMED_ISTORAGE:
                if (pMedium->pstg != NULL &&
                    IsValidInterface(pMedium->pstg))
                    pMedium->pstg->Release();
                break;

            case TYMED_NULL:
                break;

            default:
                AssertSz(FALSE, "Invalid medium in ReleaseStgMedium");
        }


        if (pMedium->pUnkForRelease) {
            if (IsValidInterface(pMedium->pUnkForRelease))
                pMedium->pUnkForRelease->Release();
            pMedium->pUnkForRelease = NULL;
        }

        // NULL out to prevent unwanted use of just freed data.
        // Note: this must be done AFTER punkForRelease is called
        // because our special punkForRelease used in remoting
        // needs the tymed value.

        pMedium->tymed = TYMED_NULL;

    }

errRtn:
    OLETRACEOUTEX((API_ReleaseStgMedium, NORETURN));

    return;
}

#ifdef MAC_REVIEW

 This API must be written for MAC and PICT format.
#endif


//+-------------------------------------------------------------------------
//
//  Function:   OleDuplicateData
//
//  Synopsis:   Duplicates data from the given handle and clipboard format
//
//  Effects:
//
//  Arguments:  [hSrc]      --  handle to the data to be duplicated
//              [cfFormat]  --  format of [hSrc]
//              [uiFlags]   --  any flags (such a GMEM_MOVEABLE) for
//                              memory allocation
//
//  Requires:
//
//  Returns:    a HANDLE to the duplicated resource
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-May-94 alexgo    added support for enhanced metafiles
//              24-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleDuplicateData)
STDAPI_(HANDLE) OleDuplicateData
        (HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
{
        HANDLE  hDup;

        OLETRACEIN((API_OleDuplicateData, PARAMFMT("hSrc= %h, cfFormat= %d, uiFlags= %x"),
                        hSrc, cfFormat, uiFlags));

        VDATEHEAP();

        if (!hSrc)
        {
                hDup = NULL;
                goto errRtn;
        }

        switch( cfFormat )
        {
        case CF_BITMAP:
                hDup = (HANDLE) BmDuplicate ((HBITMAP)hSrc, NULL, NULL);
                break;

        case CF_PALETTE:
                hDup = (HANDLE) UtDupPalette ((HPALETTE)hSrc);
                break;

        case CF_ENHMETAFILE:
                hDup = (HANDLE) CopyEnhMetaFile((HENHMETAFILE)hSrc, NULL);
                break;

        case CF_METAFILEPICT:
                if (uiFlags == NULL)
                {
                        uiFlags = GMEM_MOVEABLE;
                }

                LPMETAFILEPICT lpmfpSrc;
                LPMETAFILEPICT lpmfpDst;

                if (!(lpmfpSrc = (LPMETAFILEPICT) GlobalLock (hSrc)))
                {
                        hDup = NULL;
                        goto errRtn;
                }

                if (!(hDup = UtDupGlobal (hSrc, uiFlags)))
                {
                        GlobalUnlock(hSrc);
                        hDup = NULL;
                        goto errRtn;
                }

                if (!(lpmfpDst = (LPMETAFILEPICT) GlobalLock (hDup)))
                {
                        GlobalUnlock(hSrc);
                        GlobalFree (hDup);
                        hDup = NULL;
                        goto errRtn;
                }

                *lpmfpDst = *lpmfpSrc;
                lpmfpDst->hMF = CopyMetaFile (lpmfpSrc->hMF, NULL);
                GlobalUnlock (hSrc);
                GlobalUnlock (hDup);
                break;

        default:
                if (uiFlags == NULL)
                {
                        uiFlags = GMEM_MOVEABLE;
                }

                hDup = UtDupGlobal (hSrc, uiFlags);
        }

errRtn:
        OLETRACEOUTEX((API_OleDuplicateData, RETURNFMT("%h"), hDup));

        return hDup;
}


//+-------------------------------------------------------------------------
//
//  Function:   BmDuplicate
//
//  Synopsis:   Duplicates a bitmap
//
//  Effects:
//
//  Arguments:  [hold]      -- the source bitmap
//      [lpdwSize]  -- where to put the bitmap size
//      [lpBm]      -- where to put the new bitmap
//
//  Requires:
//
//  Returns:    A handle to the new bitmap
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      25-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(BmDuplicate)
FARINTERNAL_(HBITMAP) BmDuplicate
    (HBITMAP hold, DWORD FAR* lpdwSize, LPBITMAP lpBm)
{
    VDATEHEAP();

        HBITMAP     hnew = NULL;
        HANDLE      hMem;
        LPVOID      lpMem;
        DWORD       dwSize;
        BITMAP      bm;
        SIZE        extents;

        extents.cx = extents.cy = 0;

        // REVIEW (davepl): The bitmap pointer here was being cast to LPOLESTR
        // for some reason. It's takes a void pointer!

        GetObject (hold, sizeof(BITMAP), &bm);
        dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes)  *
            ((DWORD) bm.bmPlanes);

        if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
            return NULL;

        if (!(lpMem = GlobalLock (hMem)))
        goto errRtn;

    GlobalUnlock (hMem);

        // REVIEW(davepl): This should probably use GetDIBits() instead

        GetBitmapBits (hold, dwSize, lpMem);
        if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL)) {
            if (!SetBitmapBits (hnew, dwSize, lpMem)) {
            DeleteObject (hnew);
            hnew = NULL;
            goto errRtn;
        }
    }

    if (lpdwSize)
        *lpdwSize = dwSize;

    if (lpBm)
        *lpBm = bm;

    if (hnew && GetBitmapDimensionEx(hold, &extents) && extents.cx && extents.cy)
        SetBitmapDimensionEx(hnew, extents.cx, extents.cy, NULL);

errRtn:
    if (hMem)
        GlobalFree (hMem);

    return hnew;
}





//+-------------------------------------------------------------------------
//
//  Function:   ReadOleStg
//
//  Synopsis:   Internal API to read private OLE information from
//      the OLE_STREAM in the given storage
//
//  Effects:
//
//  Arguments:  [pstg]      -- pointer to the storage
//      [pdwFlags]  -- where to put flags stored in the
//                 the stream (may be NULL)
//      [pdwOptUpdate]  -- where to put the update flags
//                 (may be NULL)
//      [pdwReserved]   -- where to put the reserved value
//                 (may be NULL)
//      [ppmk]      -- where to put the moniker
//                 (may be NULL)
//      [ppstmOut]  -- where to put the OLE_STREAM pointer
//                 (may be NULL)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(ReadOleStg)
STDAPI ReadOleStg
    (LPSTORAGE pstg, DWORD FAR* pdwFlags, DWORD FAR* pdwOptUpdate,
     DWORD FAR* pdwReserved, LPMONIKER FAR* ppmk, LPSTREAM FAR* ppstmOut)
{
    OLETRACEIN((API_ReadOleStg,
        PARAMFMT("pdwFlags= %p, pdwOptUpdate= %p, pdwReserved= %p, ppmk= %p, ppstmOut= %p"),
        pdwFlags, pdwOptUpdate, pdwReserved, ppmk, ppstmOut));

    VDATEHEAP();

    HRESULT         error;
    IStream FAR *       pstm;
    DWORD           dwBuf[4];
    LPMONIKER       pmk;
    LPOLESTR            szClassName = OLE_STREAM;

    if (ppmk)
    {
        VDATEPTROUT_LABEL( ppmk, LPMONIKER, errNoFreeRtn, error);
        *ppmk = NULL;
    }

    if (ppstmOut){
        VDATEPTROUT_LABEL( ppstmOut, LPSTREAM, errNoFreeRtn, error);
        *ppstmOut = NULL;
    }
    VDATEIFACE_LABEL( pstg, errNoFreeRtn, error);

    if ((error = pstg->OpenStream(szClassName, NULL,
        (STGM_READ | STGM_SHARE_EXCLUSIVE), 0, &pstm)) != NOERROR) {
        // This error is OK for some callers (ex: default handler)
        // of this function. They depend on NOERROR or this error
        // code. So, don't change the error code.
        error = ReportResult(0, STG_E_FILENOTFOUND, 0, 0);
        goto errNoFreeRtn;
    }

    // read Ole version number, flags, Update options, reserved field
    if ((error = StRead (pstm, dwBuf, 4*sizeof(DWORD))) != NOERROR)
        goto errRtn;

    if (dwBuf[0] != gdwOleVersion) {
        error = ResultFromScode(DV_E_CLIPFORMAT);
        goto errRtn;
    }

    if (pdwFlags)
        *pdwFlags = dwBuf[1];

    if (pdwOptUpdate)
        *pdwOptUpdate = dwBuf[2];

    AssertSz(dwBuf[3] == NULL,"Reserved field in OLE STREAM is not NULL");

    if (dwBuf[3] != NULL) {
        error = ResultFromScode(DV_E_CLIPFORMAT);
        goto errRtn;
    }

    if (pdwReserved)
        *pdwReserved = dwBuf[3];

    if ((error = ReadMonikerStm (pstm, &pmk)) != NOERROR)
        goto errRtn;

    if (ppmk)
        *ppmk = pmk;
    else if (pmk)
        pmk->Release();

errRtn:
    if (pstm) {
        if ((error == NOERROR) && (ppstmOut != NULL))
            *ppstmOut = pstm;
        else
            pstm->Release();
    }

errNoFreeRtn:
    OLETRACEOUT((API_ReadOleStg, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function: WriteOleStg
//
//  Synopsis: Writes private OLE info into an OLE_STREAM in the given storage.
//
//  Arguments:  [pstg]       [in]  -- pointer to the storage
//              [pOleObj]    [in]  -- object from which to get info to write
//                                    (may be NULL)
//              [dwReserved] [in]  -- reserved
//              [ppstmOut]   [out] -- pointer to return the private stream
//                                    (may be NULL)
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy    Author    Comment
//              Oct 27, 93   alexgo    32bit port
//              Oct 23, 96   gopalk    Changed to call WriteOleStgEx
//
//--------------------------------------------------------------------------

#pragma SEG(WriteOleStg)
STDAPI WriteOleStg(LPSTORAGE pstg, IOleObject* pOleObj, DWORD dwReserved, 
                   LPSTREAM* ppstmOut)
{
    OLETRACEIN((API_WriteOleStg, 
                PARAMFMT("pstg=%p, pOleObj=%p, dwReserved=%x, ppstmOut=%p, "),
                pstg, pOleObj, dwReserved, ppstmOut));

    // Local variable
    HRESULT error;

    do {
        // Validation Checks
        VDATEHEAP();
        if(ppstmOut && !IsValidPtrOut(ppstmOut, sizeof(LPSTREAM))) {
            error = ResultFromScode(E_INVALIDARG);
            break;
        }
        if(!IsValidInterface(pstg)) {
            error = ResultFromScode(E_INVALIDARG);
            break;
        }
        if(pOleObj && !IsValidInterface(pOleObj)) {
            error = ResultFromScode(E_INVALIDARG);
            break;
        }
        
        // Call WriteOleStgEx
        error = WriteOleStgEx(pstg, pOleObj, dwReserved, 0, ppstmOut);
    } while(FALSE);

    OLETRACEOUT((API_WriteOleStg, error));
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function: WriteOleStgEx (Internal)
//
//  Synopsis: Writes private OLE info into an OLE_STREAM in the given storage.
//
//  Arguments:  [pstg]         [in]  -- pointer to the storage
//              [pOleObj]      [in]  -- object from which to get info to write
//                                      (may be NULL)
//              [dwReserved]   [in]  -- reserved
//              [ppstmOut]     [out] -- pointer to return the private stream
//                                      (may be NULL)
//              [dwGivenFlags] [in]  -- Additional object flags to be set
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy    Author    Comment
//              Oct 23, 96   gopalk    Creation
//
//--------------------------------------------------------------------------
STDAPI WriteOleStgEx(LPSTORAGE pstg, IOleObject* pOleObj, DWORD dwReserved, 
                     DWORD dwGivenFlags, LPSTREAM* ppstmOut)
{
    // Local Variables
    HRESULT error = NOERROR;
    IStream* pstm = NULL;
    IOleLink* pLink;
    LPMONIKER pmk;
    DWORD dwUpdOpt;
    ULONG cbRead;
    DWORD objflags;
    ULARGE_INTEGER ularge_integer;
    LARGE_INTEGER large_integer;

    // Initialize out parameter
    if(ppstmOut)
        *ppstmOut = NULL;

    // Open or Create OLE_STREAM
    error = OpenOrCreateStream(pstg, OLE_STREAM, &pstm);
    if(error == NOERROR) {
        // Write Ole version
        error = pstm->Write(&gdwOleVersion, sizeof(DWORD), NULL);
        if(error == NOERROR) {
            // Read existing Objflags to preserve doc bit
            if(pstm->Read(&objflags, sizeof(DWORD), &cbRead) != NOERROR ||
               cbRead != sizeof(DWORD))
                objflags = 0;

            // Only preserve docbit
            objflags &= OBJFLAGS_DOCUMENT;
            // Set the given flags
            objflags |= dwGivenFlags;

            // Obtain link update options 
            dwUpdOpt = 0L;
            if(pOleObj != NULL &&
               pOleObj->QueryInterface(IID_IOleLink, (void **)&pLink) == NOERROR) {
                objflags |= OBJFLAGS_LINK;
                pLink->GetUpdateOptions(&dwUpdOpt);
                pLink->Release();
            }

            // Seek to the Objflags field. We could be off due to the above read
            LISet32(large_integer, sizeof(DWORD));
            error = pstm->Seek(large_integer, STREAM_SEEK_SET, NULL);
            if(error == NOERROR) {
                // Write Objflags and link update options
                DWORD dwBuf[3];

                dwBuf[0] = objflags;
                dwBuf[1] = dwUpdOpt;
                Win4Assert(dwReserved == NULL);
                dwBuf[2] = 0L;

                error = pstm->Write(dwBuf, 3*sizeof(DWORD), NULL);
                if(error == NOERROR) {
                    // Obtain object moniker
                    pmk = NULL;
                    if(pOleObj != NULL) {
                       error = pOleObj->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
                                                   OLEWHICHMK_OBJREL, &pmk);
                       if(SUCCEEDED(error) && !IsValidInterface(pmk)) {
                           Win4Assert(FALSE);
                           pmk = NULL;
                       }
                       else if(FAILED(error) && pmk) {
                           Win4Assert(FALSE);
                           if(!IsValidInterface(pmk))
                               pmk = NULL;
                       }

                       // Write Object moniker
                       error = WriteMonikerStm(pstm, pmk);
                       if(pmk)
                           pmk->Release();

                       // Truncate the stream to remove any existing data
                       if(error == NOERROR) {
                           LISet32(large_integer, 0);
                           error = pstm->Seek(large_integer, STREAM_SEEK_CUR, 
                                              &ularge_integer);
                           if(error == NOERROR)
                               pstm->SetSize(ularge_integer);
                       }
                    }
                }
            }
        }
        
        if(error==NOERROR && ppstmOut)
            *ppstmOut = pstm;
        else
            pstm->Release();
    }
            
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetBitOleStg
//
//  Synopsis:   internal function to write private OLE info into
//      OLE_STREAM on the given storage
//
//  Effects:
//
//  Arguments:  [pstg]      -- pointer to the storage
//      [mask]      -- mask for old values
//      [value]     -- values to write
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  writes (old_values & mask ) | value into the stream
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32-bit port, fixed bugs
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(SetBitOleStg)

static INTERNAL SetBitOleStg(LPSTORAGE pstg, DWORD mask, DWORD value)
{
    VDATEHEAP();

    IStream FAR *       pstm = NULL;
    HRESULT         error;
    DWORD           objflags = 0;
    LARGE_INTEGER       large_integer;

    VDATEIFACE( pstg );

    if (error = pstg->OpenStream(OLE_STREAM, NULL, STGM_SALL, 0, &pstm))
    {
        if (STG_E_FILENOTFOUND != GetScode(error))
            goto errRtn;

        if ((error = pstg->CreateStream(OLE_STREAM, STGM_SALL,
            0, 0, &pstm)) != NOERROR)
            goto errRtn;

        DWORD dwBuf[5];

        dwBuf[0] = gdwOleVersion;
        dwBuf[1] = objflags;
        dwBuf[2] = 0L;
        dwBuf[3] = 0L;
        dwBuf[4] = 0L;

        if ((error = pstm->Write(dwBuf, 5*sizeof(DWORD), NULL))
            != NOERROR)
            goto errRtn;
    }

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL))
        != NOERROR)
        goto errRtn;

    if ((error =  StRead(pstm, &objflags, sizeof(objflags))) != NOERROR)
        goto errRtn;

    objflags = (objflags & mask) | value;

    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL))
        != NOERROR)
        goto errRtn;

    error = pstm->Write(&objflags, sizeof(DWORD), NULL);

errRtn:// close and return error code.
    if (pstm)
        pstm->Release();
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetFlagsOleStg
//
//  Synopsis:   Internal function to get the private ole flags from a
//      given storage
//
//  Effects:
//
//  Arguments:  [pstg]      --  pointer to the storage
//      [lpobjflags]    --  where to put the flags
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port, fixed bugs (error return)
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(GetFlagsOleStg)

static INTERNAL GetFlagsOleStg(LPSTORAGE pstg, LPDWORD lpobjflags)
{
    VDATEHEAP();

    IStream FAR *       pstm = NULL;
    HRESULT         error;
    LARGE_INTEGER       large_integer;

    VDATEIFACE( pstg );

    if ((error = pstg->OpenStream(OLE_STREAM, NULL,
                    (STGM_READ | STGM_SHARE_EXCLUSIVE),
                    0, &pstm)) != NOERROR)
        goto errRtn;

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL))
        != NOERROR)
        goto errRtn;

    error =  StRead(pstm, lpobjflags, sizeof(*lpobjflags));

errRtn:
    if (pstm)
        pstm->Release();
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDocumentBitStg
//
//  Synopsis:   returns the doc bit from the given storage
//
//  Effects:
//
//  Arguments:  [pStg]      --  pointer to the storage
//
//  Requires:
//
//  Returns:    NOERROR if the doc bit is set, S_FALSE if not
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//      REVIEW32:: Nobody seems to use this function.  Nuke it.
//
//--------------------------------------------------------------------------


#pragma SEG(GetDocumentBitStg)
// get doc bit; return NOERROR if on; S_FALSE if off
STDAPI GetDocumentBitStg(LPSTORAGE pStg)
{
    OLETRACEIN((API_GetDocumentBitStg, PARAMFMT("pStg= %p"), pStg));

    VDATEHEAP();

    DWORD objflags;
    HRESULT error;

    if ((error = GetFlagsOleStg(pStg, &objflags)) == NOERROR)
    {
        if(!(objflags&OBJFLAGS_DOCUMENT))
        {
                error = ResultFromScode(S_FALSE);
        }
    }

    OLETRACEOUT((API_GetDocumentBitStg, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetDocumentBitStg
//
//  Synopsis:   Writes the document bit to the given storage
//
//  Effects:
//
//  Arguments:  [pStg]      --  pointer to the storage
//      [fDocument] --  TRUE, storage is a document, false
//                  otherwise
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32-bit port
//
//  Notes:
//      REVIEW32: nobody seems to use this function, nuke it
//
//--------------------------------------------------------------------------


#pragma SEG(SetDocumentBitStg)
// set doc bit according to fDocument
STDAPI SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument)
{
    OLETRACEIN((API_SetDocumentBitStg, PARAMFMT("pStg= %p, fDocument= %B"),
                                pStg, fDocument));

    VDATEHEAP();

    HRESULT hr;

    hr = SetBitOleStg(pStg, fDocument ? -1L : ~OBJFLAGS_DOCUMENT,
        fDocument ? OBJFLAGS_DOCUMENT : 0);

    OLETRACEOUT((API_SetDocumentBitStg, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetConvertStg
//
//  Synopsis:   Gets the convert bit from the given storage
//
//  Effects:
//
//  Arguments:  [pStg]      -- pointer to the storage
//
//  Requires:
//
//  Returns:    NOERROR if set, S_FALSE if not
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(GetConvertStg)
STDAPI GetConvertStg(LPSTORAGE pStg)
{
    OLETRACEIN((API_GetConvertStg, PARAMFMT("pStg= %p"), pStg));

    VDATEHEAP();

    DWORD objflags;
    HRESULT error;

    if ((error = GetFlagsOleStg(pStg, &objflags)) != NOERROR)
    {
        goto errRtn;
    }

    if (objflags&OBJFLAGS_CONVERT)
    {
        error = NOERROR;
    }
    else
    {
        error = ResultFromScode(S_FALSE);
    }

errRtn:
    OLETRACEOUT((API_GetConvertStg, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetConvertStg
//
//  Synopsis:   Sets the convert bit in a storage
//
//  Effects:
//
//  Arguments:  [pStg]      -- pointer to the storage
//      [fConvert]  -- convert bit
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(SetConvertStg)
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
{
    OLETRACEIN((API_SetConvertStg, PARAMFMT("pStg= %p, fConvert= %B"),
                                pStg, fConvert));

    VDATEHEAP();

    HRESULT hr;

    hr = SetBitOleStg(pStg, fConvert ? -1L : ~OBJFLAGS_CONVERT,
        fConvert ? OBJFLAGS_CONVERT : 0);

    OLETRACEOUT((API_SetConvertStg, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ReadClipformatStm
//
//  Synopsis:   Reads the clipboard format from the given stream
//
//  Effects:    If the clipboard format is a length followed by a
//              string, then the string is read and registered as a
//              clipboard format (and the new format number is returned).
//
//  Arguments:  [lpstream]      -- pointer to the stream
//              [lpdwCf]        -- where to put the clipboard format
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  the format of the stream must be one of the following:
//              0           No clipboard format
//              -1 DWORD    predefined windows clipboard format in
//                          the second dword.
//              -2 DWORD    predefined mac clipboard format in the
//                          second dword.  This may be obsolete or
//                          irrelevant for us.  REVIEW32
//              num STRING  clipboard format name string (prefaced
//                          by length of string).
//
//  History:    dd-mmm-yy Author    Comment
//              27-Oct-93 alexgo    32bit port, fixed ifdef and NULL
//                                  pointer bugs
//
//              17-Mar-94 davepl    Revereted to ANSI string reads
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI ReadClipformatStm(LPSTREAM lpstream, DWORD FAR* lpdwCf)
{
    VDATEHEAP();

    HRESULT     error;
    DWORD       dwValue;

    VDATEIFACE(lpstream);
    VDATEPTROUT(lpdwCf, DWORD);

    if (error = StRead(lpstream, &dwValue, sizeof(DWORD)))
    {
        return error;
    }

    if (dwValue == NULL)
    {
        // NULL cf value
        *lpdwCf = NULL;

    }
    else if (dwValue == -1L)
    {
        // Then this is a NON-NULL predefined windows clipformat.
        // The clipformat values follows

        if (error = StRead(lpstream, &dwValue, sizeof(DWORD)))
            return error;

        *lpdwCf = dwValue;

    }
    else if (dwValue == -2L)
    {
        // Then this is a NON-NULL MAC clipboard format.
        // The clipformat value follows. For MAC the CLIPFORMAT
        // is 4 bytes

        if (error = StRead(lpstream, &dwValue, sizeof(DWORD)))
        {
            return error;
        }
        *lpdwCf = dwValue;
        return ResultFromScode(OLE_S_MAC_CLIPFORMAT);
    }
    else
    {
        char szACF[MAX_STR];

        if (error = StRead(lpstream, szACF, dwValue))
        {
            return error;
        }

        if (((*lpdwCf = (DWORD) SSRegisterClipboardFormatA(szACF))) == 0)
        {
            return ResultFromScode(DV_E_CLIPFORMAT);
        }
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteClipformatStm
//
//  Synopsis:   Writes the clipboard format the given stream
//
//  Arguments:  [lpstream]      -- pointer to the stream
//              [cf]            -- the clipboard format
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    cast -1 to a DWORD to remove compile
//                                  warning
//              27-Oct-93 alexgo    32bit port
//              16-Mar-94 davepl    Revereted to ANSI string writes
//
//  Notes:      see ReadClipformatStm for a description of the
//              data layout in the stream
//
//--------------------------------------------------------------------------


#pragma SEG(WriteClipformatStm)
STDAPI WriteClipformatStm(LPSTREAM lpstream, CLIPFORMAT cf)
{
    VDATEHEAP();

    HRESULT     error;

    VDATEIFACE( lpstream );

    //REVIEW32  where did 0xC000 come from???  Is this
    //portable to NT && Chicago???  Try to replace with a constant.
    //(although there don't seem to be any :( )

    if (cf < 0xC000)
    {
        DWORD dwBuf[2];
        DWORD dwSize = sizeof(DWORD);

        if (cf == NULL)
        {
            dwBuf[0] = NULL;
        }
        else
        {
            // write -1L, to indicate NON NULL predefined
            // clipboard format

            dwBuf[0] = (DWORD)-1L;
            dwBuf[1] = (DWORD)cf;
            dwSize += sizeof(DWORD);
        }

        if (error = StWrite(lpstream, dwBuf, dwSize))
        {
            return error;
        }

    }
    else
    {
        // it is a registerd clipboard format

        char szACF[MAX_STR];
        ULONG len;

        // Get the name of the clipboard format

        len = SSGetClipboardFormatNameA(cf, szACF, sizeof(szACF));
        if (0 == len)
        {
            return ResultFromScode(E_UNSPEC);
        }

        ++len;          // Account for NULL terminator
        if (error = StWrite(lpstream, &len, sizeof(len)))
        {
            return error;
        }

        // Write it (plus terminator) to the stream
        if (error = StWrite(lpstream, szACF, len))
        {
            return error;
        }
    }

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   WriteMonikerStm
//
//  Synopsis:   Writes the persistent state of the given moniker to the
//      given stream.  Internal
//
//  Effects:
//
//  Arguments:  [pstm]      --  pointer to the stream
//      [pmk]       --  pointer to the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(WriteMonikerStm)
// write size long followed by persistent moniker
STDAPI WriteMonikerStm (LPSTREAM pstm, LPMONIKER pmk)
{
    VDATEHEAP();

    DWORD   cb = NULL;
    ULARGE_INTEGER  dwBegin;
    ULARGE_INTEGER  dwEnd;
    HRESULT   error;
    LARGE_INTEGER large_integer;

    VDATEIFACE( pstm );

    if (pmk == NULL)
        return pstm->Write(&cb, sizeof(DWORD), NULL);
    else {
        VDATEIFACE( pmk );
        // get the begining position
        LISet32( large_integer, 0 );
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_CUR, &dwBegin)) != NOERROR)
            return error;

        // skip the moniker size DWORD
        LISet32( large_integer, 4);
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_CUR, NULL)) != NOERROR)
            return error;

        if ((error = OleSaveToStream (pmk, pstm)) != NOERROR)
            return error;

        // get the end position
        LISet32( large_integer, 0);
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_CUR, &dwEnd)) != NOERROR)
            return error;

        // moniker data size
        cb = dwEnd.LowPart - dwBegin.LowPart;

        // seek to the begining position
        LISet32( large_integer, dwBegin.LowPart);
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_SET,NULL)) != NOERROR)
            return error;

        // write moniker info size
        if ((error = pstm->Write(&cb, sizeof(DWORD),
            NULL)) != NOERROR)
            return error;

        // seek to the end position
        LISet32( large_integer, dwEnd.LowPart);
        return pstm->Seek (large_integer, STREAM_SEEK_SET, NULL);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ReadMonikerStm
//
//  Synopsis:   Reads a moniker from the given stream (inverse of
//      WriteMonikerStm)
//
//  Effects:
//
//  Arguments:  [pstm]      -- pointer to the stream
//      [ppmk]      -- where to put the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(ReadMonikerStm)
// read size long followed by persistent moniker
STDAPI ReadMonikerStm (LPSTREAM pstm, LPMONIKER FAR* ppmk)
{
    VDATEHEAP();

    HRESULT     error;
    DWORD       cb;

    VDATEPTROUT( ppmk, LPMONIKER );
    *ppmk = NULL;
    VDATEIFACE( pstm );

    if ((error =  StRead (pstm, &cb, sizeof(DWORD))) != NOERROR)
        return error;

    if (cb == NULL)
        return NOERROR;

    return OleLoadFromStream (pstm, IID_IMoniker, (LPLPVOID) ppmk);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleDraw
//
//  Synopsis:   Calls IViewObject->Draw on the given object
//
//  Effects:    Draws something on the screen :)
//
//  Arguments:  [lpUnk]     -- pointer to the object
//              [dwAspect]  -- aspect to draw (NORMAL, ICON, etc)
//              [hdcDraw]   -- the device context to use
//              [lprcBounds]    -- the rectangle in which to draw
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Apr-94 alexgo    fixed usage of MAKELONG (only
//                                  for 16bit)
//              27-Oct-93 alexgo    32bit port
//
//  Notes:
//      On Win32, RECT and RECTL are identical structures, thus there
//      is no need to convert from RECT to RECTL with MAKELONG.
//
//--------------------------------------------------------------------------

#pragma SEG(OleDraw)
STDAPI OleDraw (LPUNKNOWN lpUnk, DWORD dwAspect, HDC hdcDraw,
    LPCRECT lprcBounds)
{
        HRESULT                 error;
        IViewObject FAR*        lpView;

        OLETRACEIN((API_OleDraw, PARAMFMT("lpUnk= %p, dwAspect= %x, hdcDraw= %h, lprcBounds= %tr"),
                        lpUnk, dwAspect, hdcDraw, lprcBounds));

        VDATEHEAP();


        VDATEIFACE_LABEL( lpUnk, errRtn, error );
        VDATEPTRIN_LABEL( lprcBounds, RECT, errRtn, error);

        if ((error = lpUnk->QueryInterface (IID_IViewObject,
                (LPLPVOID)&lpView)) != NOERROR)
        {
                error = ResultFromScode(DV_E_NOIVIEWOBJECT);
                goto errRtn;
        }

        error = lpView->Draw (dwAspect, DEF_LINDEX, 0, 0, 0,
                hdcDraw, (LPCRECTL)lprcBounds, 0, 0,0);
        lpView->Release();

errRtn:
        OLETRACEOUT((API_OleDraw, error));

        return error;
}

//+----------------------------------------------------------------------------
//
//      Function:
//              CreateObjectDescriptor, static
//
//      Synopsis:
//              Creates and initializes an OBJECTDESCRIPTOR from the given
//              parameters
//
//      Arguments:
//              [clsid] -- the class ID of the object being transferred
//              [dwAspect] -- the display aspect drawn by the source of the
//                      transfer
//              [psizel] -- pointer to the size of the object
//              [ppointl] -- pointer to the mouse offset in the object that
//                      initiated a drag-drop transfer
//              [dwStatus] -- the OLEMISC status flags for the object
//                      being transferred
//              [lpszFullUserTypeName] -- the full user type name of the
//                      object being transferred
//              [lpszSrcOfCopy] -- a human readable name for the object
//                      being transferred
//
//      Returns:
//              If successful, A handle to the new OBJECTDESCRIPTOR; otherwise
//              NULL.
//
//      Notes:
//              REVIEW, this seems generally useful for anyone using the
//              clipboard, or drag-drop; perhaps it should be exported.
//
//      History:
//              12/07/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CreateObjectDescriptor)
INTERNAL_(HGLOBAL) CreateObjectDescriptor(CLSID clsid, DWORD dwAspect,
                const SIZEL FAR *psizel, const POINTL FAR *ppointl,
                DWORD dwStatus, LPOLESTR lpszFullUserTypeName,
                LPOLESTR lpszSrcOfCopy)
{
        VDATEHEAP();

        DWORD dwFullUserTypeNameBLen; // length of lpszFullUserTypeName in BYTES
        DWORD dwSrcOfCopyBLen; // length of lpszSrcOfCopy in BYTES
        HGLOBAL hMem; // handle to the object descriptor
        LPOBJECTDESCRIPTOR lpOD; // the new object descriptor

        // Get the length of Full User Type Name; Add 1 for the null terminator
        if (!lpszFullUserTypeName)
                dwFullUserTypeNameBLen = 0;
        else
                dwFullUserTypeNameBLen = (_xstrlen(lpszFullUserTypeName) +
                                1) * sizeof(OLECHAR);

        // Get the Source of Copy string and it's length; Add 1 for the null
        // terminator
        if (lpszSrcOfCopy)
                dwSrcOfCopyBLen = (_xstrlen(lpszSrcOfCopy) + 1) *
                                sizeof(OLECHAR);
        else
        {
                // No src moniker so use user type name as source string.
                lpszSrcOfCopy =  lpszFullUserTypeName;
                dwSrcOfCopyBLen = dwFullUserTypeNameBLen;
        }

        // allocate the memory where we'll put the object descriptor
        hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                        sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameBLen +
                        dwSrcOfCopyBLen);
        if (hMem == NULL)
                goto error;

        lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem);
        if (lpOD == NULL)
                goto error;

        // Set the FullUserTypeName offset and copy the string
        if (!lpszFullUserTypeName)
        {
                // zero offset indicates that string is not present
                lpOD->dwFullUserTypeName = 0;
        }
        else
        {
                lpOD->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
                _xmemcpy(((BYTE FAR *)lpOD)+lpOD->dwFullUserTypeName,
                                (const void FAR *)lpszFullUserTypeName,
                                dwFullUserTypeNameBLen);
        }

        // Set the SrcOfCopy offset and copy the string
        if (!lpszSrcOfCopy)
        {
                // zero offset indicates that string is not present
                lpOD->dwSrcOfCopy = 0;
        }
        else
        {
                lpOD->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR) +
                                dwFullUserTypeNameBLen;
                _xmemcpy(((BYTE FAR *)lpOD)+lpOD->dwSrcOfCopy,
                                (const void FAR *)lpszSrcOfCopy,
                                dwSrcOfCopyBLen);
        }

        // Initialize the rest of the OBJECTDESCRIPTOR
        lpOD->cbSize = sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameBLen +
                        dwSrcOfCopyBLen;
        lpOD->clsid = clsid;
        lpOD->dwDrawAspect = dwAspect;
        lpOD->sizel = *psizel;
        lpOD->pointl = *ppointl;
        lpOD->dwStatus = dwStatus;

        GlobalUnlock(hMem);
        return(hMem);

error:
        if (hMem)
        {
                GlobalUnlock(hMem);
                GlobalFree(hMem);
        }

        return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\advise\oaholder.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		oaholder.cpp
//
//	Contents:
//		COAHolder, a concrete implementation of IOleAdviseHolder,
//		a helper class
//
//	Classes:
//		COAHolder
//
//	Functions:
//		CreateOleAdviseHolder
//
//	History:
//              31-Jan-95 t-ScottH  added _DEBUG only Dump method to the
//                                  COAHolder class and a DumpCOAHolder
//                                  API
//		03/10/94 - RickSa - added call logging and fixed bugs with
//			inserting advises
//		01/24/94 - AlexGo  - first pass at converting to Cairo style
//			memory allocation
//		01/11/93 - AlexGo  - added VDATEHEAP macros to all functions
//			and methods
//		11/22/93 - ChrisWe - replace overloaded ==, != with
//			IsEqualIID and IsEqualCLSID
//		10/28/93 - ChrisWe - file cleanup and inspection for Cairo
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#include <oaholder.h>
#include <limits.h>

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

#pragma SEG(oaholder)

NAME_SEG(OaHolder)
ASSERTDATA

//+----------------------------------------------------------------------------
//
//	Function:
//		CreateDataAdviseHolder, public API
//
//	Synopsis:
//		Creates an instance of the COAHolder
//
//	Arguments:
//		[ppOAHolder] -- place to return pointer to newly allocated
//			advise holder
//
//	Returns:
//		E_INVALIDARG, if ppOAHolder is NULL
//		E_OUTOFMEMORY
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CreateOleAdviseHolder)
STDAPI CreateOleAdviseHolder(IOleAdviseHolder FAR* FAR* ppOAHolder)
{
	OLETRACEIN((API_CreateOleAdviseHolder, PARAMFMT("ppOAHolder= %p"), ppOAHolder));

	VDATEHEAP();

	HRESULT hr;

	VDATEPTROUT_LABEL(ppOAHolder, IOleAdviseHolder FAR* FAR*, errRtn, hr);

	LEDebugOut((DEB_ITRACE, "%p _IN CreateOleAdviseHolder ( %p )"
		"\n", NULL, ppOAHolder));

	
	*ppOAHolder = new FAR COAHolder(); // task memory; hard coded below

	hr = *ppOAHolder
		? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);

	LEDebugOut((DEB_ITRACE, "%p OUT CreateOleAdviseHolder ( %lx )\n",
		"[ %p ]\n", NULL, hr, *ppOAHolder));

	CALLHOOKOBJECTCREATE(hr, CLSID_NULL, IID_IOleAdviseHolder,
			     (IUnknown **)ppOAHolder);

errRtn:
	OLETRACEOUT((API_CreateOleAdviseHolder, hr));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::COAHolder, public
//
//	Synopsis:
//		Initializes COAHolder
//
//	Effects:
//		Sets reference count to 1
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_ctor)
COAHolder::COAHolder() : CSafeRefCount(NULL)
{
	VDATEHEAP();

	// set reference count to 1
	SafeAddRef();

	// no sink pointers yet
	m_iSize = 0;
	m_ppIAS = NULL;

	GET_A5();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::~COAHolder, private
//
//	Synopsis:
//		destructor, frees managed advise sinks
//
//	Arguments:
//		none
//
//	Requires:
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_dtor)
COAHolder::~COAHolder()
{
	VDATEHEAP();

	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	M_PROLOG(this);
	
	// free the array, if there is one
	if (m_ppIAS)
	{
		// walk the array of advise sinks, freeing things
		for (ppIAS = m_ppIAS, iAdv = 0; iAdv < m_iSize; ++ppIAS, ++iAdv)
		{
			SafeReleaseAndNULL((IUnknown **)ppIAS);
		}

		// free the array
		PubMemFree(m_ppIAS);
	}
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[iid] -- the interface pointer desired
//		[ppv] -- pointer to where to return the requested interface
//			pointer
//
//	Returns:
//		E_NOINTERFACE, if requested interface not available
//		S_OK
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_QueryInterface)
STDMETHODIMP COAHolder::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEPTROUT(ppv, LPVOID FAR *);

	LEDebugOut((DEB_ITRACE,
		"%p _IN COAHolder::QueryInterface ( %p , %p )"
		"\n", this, iid, ppv));

	HRESULT hr = ReportResult(0, E_NOINTERFACE, 0, 0);

	if (IsEqualIID(iid, IID_IUnknown) ||
			IsEqualIID(iid, IID_IOleAdviseHolder))
	{
		*ppv = (IOleAdviseHolder FAR *)this;
		AddRef();
		hr = NOERROR;
	}
	else
	{
		*ppv = NULL;
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::QueryInterface ( %lx )"
		" [ %p ]\n", this, hr, *ppv));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_AddRef)
STDMETHODIMP_(ULONG) COAHolder::AddRef()
{
	ULONG	cRefs;

	VDATEHEAP();

	M_PROLOG(this);

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::AddRef (  )\n", this));

	cRefs = SafeAddRef();

	LEDebugOut((DEB_ITRACE, "%p OUT	COAHolder::AddRef ( %lu )\n", this,
		cRefs));

	return cRefs;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::Release, public
//
//	Synopsis:
//		implements IUnknown::Release
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_Release)
STDMETHODIMP_(ULONG) COAHolder::Release()
{
	VDATEHEAP();

	M_PROLOG(this);

	ULONG cRefs;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::Release ( )\n", this ));

	cRefs = SafeRelease();

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::Release ( %lu )\n", this,
		cRefs));

	return cRefs;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::Advise, public
//
//	Synopsis:
//		implements IOleAdviseHolder::Advise
//
//	Effects:
//		Adds the newly specified advise sink the the list of
//		advisees that will be notified when a change is indicated
//		via other IOleAdviseHolder methods on this object
//
//	Arguments:
//		[pAdvSink] -- the new advise sink to add the the list
//		[pdwConnection] -- pointer to a DWORD where an identifier will
//			be returned that can be used to identify this sink
//			later
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//              03/15/94 - AlexT    Zero out new space after a realloc
//		08/02/94 - AlexGo  - stabilized
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_Advise)
STDMETHODIMP COAHolder::Advise(IAdviseSink FAR* pAdvSink,
		DWORD FAR* pdwConnection)
{
	VDATEHEAP();

	int iAdv;  // records the first free entry found, or (-1)
	int iAdvScan; // counts across array entries
	IAdviseSink FAR *FAR *ppIAS; // points at the array entry being examined
	IAdviseSink FAR *pIAS; // the actual entry at *ppIAS

	M_PROLOG(this);
	VDATEIFACE(pAdvSink);
	HRESULT hr = NOERROR;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::Advise ( %p , %p )"
		"\n", this, pAdvSink, pdwConnection));

 	// Validate where to return the connection.
	if (pdwConnection)
	{
		VDATEPTRIN(pdwConnection, DWORD);

		// Default to error case
		*pdwConnection = 0;
	}

	// check our zombie state and stabilize.  If we are in a zombie
	// state, we do not want to be adding new advise sinks.

	CStabilize stabilize((CSafeRefCount *)this);

	if( IsZombie() )
	{
		hr = ResultFromScode(CO_E_RELEASED);
		goto errRtn;
	}


	// find an empty slot and clean up disconnected handlers
	for (iAdv = (-1), ppIAS = m_ppIAS, iAdvScan = 0;
			iAdvScan < m_iSize; ++ppIAS, ++iAdvScan)
	{
		if ((pIAS = *ppIAS) == NULL)
		{
			// NULL entries are handled below, to catch
			// any of the below cases creating new NULL values
			;
		}
		else if (!IsValidInterface(pIAS))
		{
			// not valid; don't try to release
			*ppIAS = NULL;
		}
		else if (!CoIsHandlerConnected(pIAS))
		{
			// advise sink not connected to server anymore; release
			// REVIEW, why do we have to constantly poll these
			// to see if they are ok?
			pIAS->Release();
			*ppIAS = NULL;
		}

		// if first NULL, save rather than extend array
		if ((*ppIAS == NULL) && (iAdv == (-1)))
			iAdv = iAdvScan;
	}

	// if we didn't find an empty slot, we have to add space
	if (iAdv == (-1))
	{

		ppIAS = (IAdviseSink FAR * FAR *)PubMemRealloc(m_ppIAS,
			sizeof(IAdviseSink FAR *)*(m_iSize + COAHOLDER_GROWBY));
				
		if (ppIAS != NULL)
		{
                        // zero out new space
                        _xmemset((void FAR *) (ppIAS + m_iSize), 0,
                                 sizeof(IAdviseSink *) * COAHOLDER_GROWBY);
			// this is the index of the new element to use
			iAdv = m_iSize;

			// replace the old array
			m_ppIAS = ppIAS;
			m_iSize += COAHOLDER_GROWBY;
		}
		else
		{
			// quit if there was an error
			hr = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		}
	}

	if (SUCCEEDED(hr))
	{
		// if we get here, iAdv is the element to use; if the addition
		// was not possible, function would have returned before now
		pAdvSink->AddRef();
		m_ppIAS[iAdv] = pAdvSink;

		// if user wants cookie back, return it
		if (pdwConnection)
		{
			// NOTE: this +1 is balanced by -1 in Unadvise()
			*pdwConnection = iAdv + 1;
		}
	}

errRtn:

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::Advise ( %lx )"
		" [ %p ]\n", this, hr,
			(pdwConnection)? *pdwConnection : 0));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::Unadvise, public
//
//	Synopsis:
//		implementat IOleAdviseHolder::Unadvise
//
//	Effects:
//		removes the specified advise sink from the list of sinks that
//		are notified when other IOleAdviseHolder methods are used on
//		this
//
//	Arguments:
//		[dwConnection] -- The token that identifies the connection;
//			this would have been obtained previously from a
//			call to Advise()
//
//	Returns:
//		OLE_E_NOCONNECTION, if the connection token is invalid
//		S_OK
//
//	Notes: 	We do not have to stabilize this call since the only
//		outgoing call is the Release at the end
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_Unadvise)
STDMETHODIMP COAHolder::Unadvise(DWORD dwConnection)
{
	VDATEHEAP();

	M_PROLOG(this);

	HRESULT hr = NOERROR;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::Unadvise ( %lu )"
		"\n", this, dwConnection));

	IAdviseSink FAR* pAdvSink; // the requested advise sink, if there is one
	int iAdv = (int)dwConnection - 1; // adjust connection index

	// check that the connection token is valid, and if so, check that
	// there is a connection for it
	if (((LONG)dwConnection <= 0)
		|| (iAdv >= m_iSize)
		|| ((LONG)dwConnection > INT_MAX)
		|| ((pAdvSink = m_ppIAS[iAdv]) == NULL)
		|| !IsValidInterface(pAdvSink))
	{
		hr = ReportResult(0, OLE_E_NOCONNECTION, 0, 0);
	}
	else
	{
	    // remove the advise sink from the array
	    m_ppIAS[iAdv] = NULL;

	    // release the advise sink; NB, due to circular references, this
	    // may release this advise holder--[this] may not be valid on
	    // return!
	    pAdvSink->Release();
	}

	// NB!!  If any outgoing calls are added, this function will have
	// to be stabilized

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::Unadvise ( %lx )"
		" \n", this, hr));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::EnumAdvise, public
//
//	Synopsis:
//		implements IOleAdviseHolder::EnumAdvise()
//
//	Effects:
//		returns an enumerator
//
//	Arguments:
//		[ppenumAdvise] -- pointer to where to return a pointer to
//			an enumerator
//
//	Returns:
//		E_NOTIMPL
//
//	Notes:
//		currently not implemented.
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_EnumAdvise)
STDMETHODIMP COAHolder::EnumAdvise(IEnumSTATDATA FAR* FAR* ppenumAdvise)
{
	VDATEHEAP();

	M_PROLOG(this);

	// This is currently not implemented
	HRESULT hr = ReportResult(0, E_NOTIMPL, 0, 0);

	VDATEPTROUT(ppenumAdvise, IEnumSTATDATA FAR*);
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::EnumAdvise ( )"
		"\n", this));

	*ppenumAdvise = NULL;

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::EnumAdvise ( %lx )"
		"[ %p ]\n", this, hr, *ppenumAdvise));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnRename(), public
//
//	Synopsis:
//		Multicast the OnRename OLE compound document notification,
//		to all interested parties
//
//	Arguments:
//		[pmk] -- the new name of the object
//
//	Returns:
//		S_OK
//
//	Notes:
//		This may release the advise holder, since some objects may
//		Unadvise() themselves at the time they receive this
//		notification.  To prevent the multicasting code from crashing,
//		the multicast loop is bracketed with AddRef()/Release().  Note
//		that the bracketing Release() may release the advise holder,
//		at which point [this] may no longer be valid.
//
//		In a similar vein, other parties may add new Advise sinks
//		during these notifications.  To avoid getting caught in
//		an infinite loop, we copy the number of advise sinks at the
//		beginning of the function, and do not refer to the current
//		number.  If some parties are removed, and re-added, they may
//		be notified more than once, if they happen to be moved to
//		a later spot in the array of advise sinks.
//		REVIEW, copied this comment from previous stuff, and it
//		sounds BOGUS.  Since new entries are always put in the first
//		empty slot, the current number always has to settle down,
//		and won't grow without bound, unless some bogus app is
//		continually registering itself when it gets a notification
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnRename)
STDMETHODIMP COAHolder::SendOnRename(IMoniker FAR* pmk)
{
	VDATEHEAP();

	M_PROLOG(this);
	VDATEIFACE(pmk);

	HRESULT hr = NOERROR;
	
	int iAdvLim = m_iSize; // copy the current number of sink entries
	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnRename ( %p )"
		"\n", this, pmk));

	// protect the COAHolder
	CStabilize stabilize((CSafeRefCount *)this);

	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		if (*ppIAS != NULL)
			(*ppIAS)->OnRename(pmk);
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnRename ( %lx )"
		" \n", this, hr));

	return hr;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnSave(), public
//
//	Synopsis:
//		Multicast the OnSave OLE compound document notification,
//		to all interested parties
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//		See notes for COAHolder::SendOnRename().
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnSave)
STDMETHODIMP COAHolder::SendOnSave(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	HRESULT hr = NOERROR;
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnSave (  )"
		"\n", this ));

	int iAdvLim = m_iSize; // copy the current number of sink entries
	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	// protect the COAHolder
	CStabilize stabilize((CSafeRefCount *)this);

	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		if (*ppIAS != NULL)
			(*ppIAS)->OnSave();
	}


	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnSave ( %lx )"
		" \n", this, hr));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnClose(), public
//
//	Synopsis:
//		Multicast the OnClose OLE compound document notification,
//		to all interested parties
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//		See notes for COAHolder::SendOnRename().
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnClose)
STDMETHODIMP COAHolder::SendOnClose(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	HRESULT hr = NOERROR;
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnClose (  )"
		"\n", this));

	int iAdvLim = m_iSize; // copy the current number of sink entries
	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	// protect the COAHolder
	CStabilize stabilize((CSafeRefCount *)this);

	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		if (*ppIAS != NULL)
			(*ppIAS)->OnClose();
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnClose ( %lx )"
		" \n", this, hr));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnLinkSrcChange, public
//
//	Synopsis:
//		Multicasts IAdviseSink2::OnLinkSrcChange notification to any
//		advise sinks managed by the COAHolder that provide the
//		IAdviseSink2 interface
//
//	Arguments:
//		[pmk] -- the new moniker to the link source
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		12/31/93 - ChrisWe - fixed assert
//		11/01/93 - ChrisWe - made a member of COAHolder
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnLinkSrcChange)
HRESULT COAHolder::SendOnLinkSrcChange(IMoniker FAR* pmk)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEIFACE(pmk);

	HRESULT hr = NOERROR;
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnLinkSrcChange ( %p )"
		"\n", this, pmk));

	int iAdvLim = m_iSize; // records the number of entries at start
	int iAdv; // counts entries
	IAdviseSink FAR *FAR *ppIAS; // walks over the array of advise sinks
	
	// protect this from being released through circular references
      	CStabilize stabilize((CSafeRefCount *)this);

	// multicast notification
	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		IAdviseSink FAR* pAdvSink;
		IAdviseSink2 FAR* pAdvSink2;

		// REVIEW, this seems to require that the number of
		// advisees can only stay the same, or increase.  Why should
		// we care?
		Assert(iAdvLim <= m_iSize);

		// get pointer to current advise sink
		pAdvSink = *ppIAS;

		// if we have an advise sink, and it accepts IAdviseSink2
		// notifications, send one
		if ((pAdvSink != NULL) &&
				pAdvSink->QueryInterface(IID_IAdviseSink2,
				(LPVOID FAR*)&pAdvSink2) == NOERROR)
		{
			pAdvSink2->OnLinkSrcChange(pmk);
			pAdvSink2->Release();
		}
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnLinkSrcChange ( %lx )"
		" \n", this, hr));

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     COAHolder::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT COAHolder::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCSafeRefCount;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of Advise Sinks = " << m_iSize << endl;
    for (i = 0; i < m_iSize; i++)
    {
        dstrDump << pszPrefix << "pIAdviseSink [" << i << "]    = " << m_ppIAS[i]  << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCOAHolder, public (_DEBUG only)
//
//  Synopsis:   calls the COAHolder::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pESD]          - pointer to COAHolder
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCOAHolder(COAHolder *pOAH, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pOAH == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pOAH->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\lockbyte.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	lockbyte.cpp
//
//  Contents:	Apis for working with the standard ILockByte implementation
//		on memory
//
//  Classes:
//
//  Functions:	CreateILockBytesOnHGlobal
//		GetHGlobalFromILockBytes
//
//  History:    dd-mmm-yy Author    Comment
//		11-Jan-93 alexgo    added VDATEHEAP macros to every function
//				    fixed compile warnings
//		16-Dec-93 alexgo    fixed bad memory bugs
//		02-Dec-93 alexgo    32bit port
//		15-Sep-92 jasonful  author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(lockbyte)

#include "memstm.h"
#include <reterr.h>

NAME_SEG(LockBytes)
ASSERTDATA


//+-------------------------------------------------------------------------
//
//  Function:  	CreateILockBytesOnHGlobal 
//
//  Synopsis:   Creates a CMemBytes on the given HGlobal
//
//  Effects:    
//
//  Arguments: 	[hGlobal]	-- the memory to use (may be NULL) 
//		[fDeleteOnRelease]	-- if TRUE, then [hGlobal will
//					   be freed when CMemBytes is
//					   freed via a Release
//		[pplkbyt]	-- where to put the pointer to the CMemByte
//				   instance
//  Requires:   
//
//  Returns:    HRESULT
//
//  Signals:    
//
//  Modifies:   
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		11-Jan-94 alexgo    removed initialization of cbSize to -1
//			 	    to fix a compile warning
//		16-Dec-93 alexgo    fixed bogus usage of MAKELONG (turned
//				    into a GlobalLock)
//		02-Dec-93 alexgo    32bit port, fixed memory leak bug
//
//  Notes:  	REVIEW32:  It's fine to *ask* for shared memory on NT, you
//		just won't get it.  We need to make sure that any callers
//		(looks like apps at the moment) don't have the wrong idea :)
//
//--------------------------------------------------------------------------

#pragma SEG(CreateILockBytesOnHGlobal)
STDAPI CreateILockBytesOnHGlobal
	(HGLOBAL			hGlobal,
	BOOL				fDeleteOnRelease,
	LPLOCKBYTES FAR*		pplkbyt)
{
	OLETRACEIN((API_CreateILockBytesOnHGlobal,
		PARAMFMT("hGlobal= %h, fDeleteOnRelease= %B, pplkbyt= %p"),
		hGlobal, fDeleteOnRelease, pplkbyt));

	VDATEHEAP();

	HANDLE				hMem	= NULL; 						
	struct MEMSTM FAR*   		pData	= NULL;
	ILockBytes FAR* 	 	pBytes	= NULL;
	DWORD 		 		cbSize;
	BOOL				fAllochGlobal = FALSE;
	HRESULT 			hresult;

	VDATEPTROUT_LABEL (pplkbyt, LPLOCKBYTES, SafeExit, hresult);
	*pplkbyt = NULL;

    	if (NULL==hGlobal)
	{
		hGlobal = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, 0);
	    	if (hGlobal == NULL)
	    	{
    	    		goto ErrorExit;
    	    	}
    	    	fAllochGlobal = TRUE;
    	    	
    		cbSize = 0;
	}
	else
	{
		cbSize = (ULONG) GlobalSize (hGlobal);
		// Is there a way to verify a zero-sized handle?
		if (cbSize!=0)
		{
			// verify validity of passed-in handle
			if (NULL==GlobalLock(hGlobal))
			{
				// bad handle
				hresult = ResultFromScode (E_INVALIDARG);
				goto SafeExit;
			}
			GlobalUnlock (hGlobal);
		}
	}

	hMem = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, sizeof (MEMSTM));
    if (hMem == NULL)
	{
		if (fAllochGlobal && hGlobal )
		{
			GlobalFree(hGlobal);
		}
        goto ErrorExit;
  	}

	pData = (MEMSTM FAR *)GlobalLock(hMem);
	
    	if (pData == NULL)
    	{
   	    goto FreeMem;
	}

	pData->cRef = 0;
   	pData->cb = cbSize;
	pData->fDeleteOnRelease = fDeleteOnRelease;
	pData->hGlobal = hGlobal;

    	pBytes = CMemBytes::Create(hMem); // Create the ILockBytes
    	
    	if (pBytes == NULL)
    	{
        	goto FreeMem;
        }

    	*pplkbyt = pBytes;
    	GlobalUnlock(hMem);

        CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_ILockBytes,
                             (IUnknown **)pplkbyt);
    	
	hresult = NOERROR;
	goto SafeExit;
	
FreeMem:
	if (pData)
	{
		GlobalUnlock(hMem);
	}	
	if (hMem)
	{
	    GlobalFree(hMem);
	}

	if (fAllochGlobal && hGlobal )
	{
		GlobalFree(hGlobal);
	}
ErrorExit:
	Assert (0);

	hresult = ResultFromScode(E_OUTOFMEMORY);

SafeExit:
	OLETRACEOUT((API_CreateILockBytesOnHGlobal, hresult));

	return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function: 	GetHGlobalFromILockBytes  
//
//  Synopsis:   Retrieves the hGlobal the ILockBytes was created with
//
//  Effects:    
//
//  Arguments:  [plkbyt]	-- pointer to the ILockBytes implementation
//		[phglobal]	-- where to put the hglobal
//
//  Requires:   
//
//  Returns:    HRESULT
//
//  Signals:    
//
//  Modifies:   
//
//  Algorithm:  hacked--does a pointer cast and checks the signature :( :(
//
//  History:    dd-mmm-yy Author    Comment
//		02-Dec-93 alexgo    32bit port
//
//  Notes:      
//
//--------------------------------------------------------------------------

#pragma SEG(GetHGlobalFromILockBytes)
STDAPI GetHGlobalFromILockBytes
	(LPLOCKBYTES 	plkbyt,
	HGLOBAL	FAR*	phglobal)
{
	OLETRACEIN((API_GetHGlobalFromILockBytes, 
		PARAMFMT("plkbyt= %p, phglobal= %p"),
		plkbyt, phglobal));

	VDATEHEAP();

	HRESULT hresult;
	CMemBytes FAR* pCMemByte;
	MEMSTM FAR* pMem;

	VDATEIFACE_LABEL(plkbyt, errRtn, hresult);
	VDATEPTROUT_LABEL (phglobal, HANDLE, errRtn, hresult);

        CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_ILockBytes,(IUnknown **)&plkbyt);
	
	*phglobal = NULL;
	pCMemByte = (CMemBytes FAR*)plkbyt;

	if (!IsValidReadPtrIn (&(pCMemByte->m_dwSig), sizeof(ULONG))
		|| pCMemByte->m_dwSig != LOCKBYTE_SIG)
	{
		// we were passed someone else's implementation of ILockBytes
		hresult = ResultFromScode (E_INVALIDARG);
		goto errRtn;
	}

	pMem= pCMemByte->m_pData;
	if (NULL==pMem)
	{
		Assert (0);
		hresult = ResultFromScode (E_OUTOFMEMORY);
		goto errRtn;
	}
	Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
	Verify (*phglobal = pMem->hGlobal);

	hresult = NOERROR;

errRtn:
	OLETRACEOUT((API_GetHGlobalFromILockBytes, hresult));

	return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\memstm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       memstm.cpp
//
//  Contents:   Implementations of IStream and ILockBytes on memory
//              (versus the file system)
//
//  Classes:    CMemStm
//              CMemBytes
//              CMarshalMemStm
//              CMarshalMemBytes
//
//  Functions:  CreateMemStm
//              CloneMemStm
//              ReleaseMemStm
//              CreateStreamOnHGlobal
//              GetHGlobalFromStream
//              CMemStmUnMarshal
//              CMemBytesUnMarshall
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  added Dump methods to CMemStm and CMemBytes
//                                  (_DEBUG only)
//                                  added DumpCMemStm and CMemBytes APIs
//              04-Nov-94 ricksa    Made CMemStm class multithread safe.
//              24-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocation
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function &
//                                  method, fixed compile warnings, removed
//                                  custom marshalling code.  Memory streams
//                                  and ILockBytes now use standard
//                                  marshalling.
//              16-Dec-93 alexgo    fixed memory reference bugs (bad pointer)
//              02-Dec-93 alexgo    32bit port, implement CMemStm::CopyTo
//              11/22/93 - ChrisWe - replace overloaded ==, != with
//                      IsEqualIID and IsEqualCLSID
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(memstm)

#include <nturtl.h>
#include "memstm.h"
#include "sem.hxx"
#include <reterr.h>

#ifdef _DEBUG
#include "dbgdump.h"
#endif // _DEBUG

NAME_SEG(CMemStm)
ASSERTDATA


// CRefMutexSem implementation
//
// Instances of this class are shared among all CMemStm objects 
// cloned from a common CMemStm object, as well as their parent.
//
// This guarantees synchronization between all instances of CMemStm that share common data

CRefMutexSem::CRefMutexSem() : m_lRefs(1)
{
    // Note: we begin life with one reference
}

CRefMutexSem* CRefMutexSem::CreateInstance()
{
    CRefMutexSem* prefMutexSem = NULL;
    prefMutexSem = new CRefMutexSem();
    if (prefMutexSem != NULL)
    {
    	if (prefMutexSem->FInit() == FALSE)
    	{
    	    ASSERT(FALSE);
    	    delete prefMutexSem;
    	    prefMutexSem = NULL;
    	}
    }
    return prefMutexSem;
}

BOOL CRefMutexSem::FInit()
{
    return m_mxs.FInit();	
}

ULONG CRefMutexSem::AddRef()
{
    return InterlockedIncrement (&m_lRefs);    
}

ULONG CRefMutexSem::Release()
{
    LONG lRefs = InterlockedDecrement (&m_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }

    return lRefs;
}

void CRefMutexSem::RequestCS()
{
    m_mxs.Request();
}

void CRefMutexSem::ReleaseCS()
{
    m_mxs.Release();
}   

const CMutexSem2* CRefMutexSem::GetMutexSem()
{
    return &m_mxs;
}


inline CRefMutexAutoLock::CRefMutexAutoLock (CRefMutexSem* pmxs)
{
    Win4Assert (pmxs != NULL);

    m_pmxs = pmxs;
    m_pmxs->RequestCS();

    END_CONSTRUCTION (CRefMutexAutoLock);
}

inline CRefMutexAutoLock::~CRefMutexAutoLock()
{
    m_pmxs->ReleaseCS();
}
    
// Shared memory IStream implementation
//

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::CMemStm
//
//  Synopsis:   constructor for memory stream
//
//  Arguments:  none
//
//  History:    20-Dec-94   Rickhi      moved from h file
//
//--------------------------------------------------------------------------
CMemStm::CMemStm()
{
    m_hMem = NULL;
    m_pData = NULL;
    m_pos = 0;
    m_refs = 0;
    m_pmxs = NULL;
}

CMemStm::~CMemStm()
{
    if (m_pmxs != NULL)
    {
        m_pmxs->Release();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::QueryInterface
//
//  Synopsis:   retrieves the requested interface
//
//  Effects:
//
//  Arguments:  [iidInterface]  -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              11-Jan-94 alexgo    removed QI for IMarshal so that
//                                  the standard marshaller is used.
//                                  This is fix marshalling across
//                                  process on 32bit platforms.
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_QueryInterface)
STDMETHODIMP CMemStm::QueryInterface(REFIID iidInterface,
        void FAR* FAR* ppvObj)
{
        VDATEHEAP();

        HRESULT         error;

        VDATEPTROUT( ppvObj, LPVOID );
        *ppvObj = NULL;
        VDATEIID( iidInterface );

        // Two interfaces supported: IUnknown, IStream

        if (m_pData != NULL && (IsEqualIID(iidInterface, IID_IStream) ||
                IsEqualIID(iidInterface, IID_ISequentialStream) ||
                IsEqualIID(iidInterface, IID_IUnknown)))
        {

                AddRef();   // A pointer to this object is returned
                *ppvObj = this;
                error = NOERROR;
        }
        else
        {                 // Not accessible or unsupported interface
                *ppvObj = NULL;
                error = ResultFromScode(E_NOINTERFACE);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Dec-93 alexgo    32bit port
//              04-Nov-94 ricksa    Modified for multithreading
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_AddRef)
STDMETHODIMP_(ULONG) CMemStm::AddRef(void)
{
        VDATEHEAP();

        return InterlockedIncrement((LONG *) &m_refs);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes the object when ref count == 0
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              16-Dec-93 alexgo    added GlobalUnlock of the MEMSTM handle
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Release)
STDMETHODIMP_(ULONG) CMemStm::Release(void)
{
        VDATEHEAP();

        // The reason for this here is that there is a race when releasing
        // this object. If two threads are trying to release this object
        // at the same time, there is a case where the first one dec's
        // the ref count & then loses the processor to the second thread.
        // This second thread decrements the reference count to 0 and frees
        // the memory. The first thread can no longer safely examine the
        // internal state of the object.
        ULONG ulResult = InterlockedDecrement((LONG *) &m_refs);

        if (ulResult == 0)
        {
                // this MEMSTM handle was GlobalLock'ed in ::Create
                // we unlock it here, as we no longer need it.
                GlobalUnlock(m_hMem);

                ReleaseMemStm(&m_hMem);

                delete this;
        }

        return ulResult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Read
//
//  Synopsis:   reads [cb] bytes from the stream
//
//  Effects:
//
//  Arguments:  [pb]            -- where to put the data read
//              [cb]            -- the number of bytes to read
//              [pcbRead]       -- where to put the actual number of bytes
//                                 read
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  uses xmemcpy
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Read)
STDMETHODIMP CMemStm::Read(void HUGEP* pb, ULONG cb, ULONG FAR* pcbRead)
{
        VDATEHEAP();

        HRESULT         error = NOERROR;
        ULONG           cbRead = cb;

        if(cb)
        {
            VDATEPTROUT( pb, char);
        }

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        if (pcbRead)
        {
                VDATEPTROUT( pcbRead, ULONG );
                *pcbRead = 0L;
        }

	// cbRead + m_pos could cause roll-over.
        if ( ( (cbRead + m_pos) > m_pData->cb) || ( (cbRead + m_pos) < m_pos) )
        {
                // Caller is asking for more bytes than we have left
                if(m_pData->cb > m_pos)
                    cbRead = m_pData->cb - m_pos;
                else
                    cbRead = 0;
        }

        if (cbRead > 0)
        {
                Assert (m_pData->hGlobal);
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                        m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        LEERROR(1, "GlobalLock Failed!");

                        return ResultFromScode (STG_E_READFAULT);
                }
                // overlap is currently considered a bug (see the discussion
                // on the Write method
                _xmemcpy(pb, pGlobal + m_pos, cbRead);
                GlobalUnlock (m_pData->hGlobal);
                m_pos += cbRead;
        }

        if (pcbRead != NULL)
        {
                *pcbRead = cbRead;
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Write
//
//  Synopsis:   Writes [cb] bytes into the stream
//
//  Effects:
//
//  Arguments:  [pb]            -- the bytes to write
//              [cb]            -- the number of bytes to write
//              [pcbWritten]    -- where to put the number of bytes written
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  resizes the internal buffer (if needed), then uses xmemcpy
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port, fixed bug dealing with
//                                  0-byte sized memory
//              06-Dec-93 alexgo    handle overlap case.
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Write)
STDMETHODIMP CMemStm::Write(void const HUGEP* pb, ULONG cb,
        ULONG FAR* pcbWritten)
{
        VDATEHEAP();

        HRESULT                 error = NOERROR;
        ULONG                   cbWritten = cb;
        ULARGE_INTEGER          ularge_integer;
        BYTE HUGEP*             pGlobal;

        if(cb)
        {
            VDATEPTRIN( pb , char );
        }

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        if (pcbWritten != NULL)
        {
                *pcbWritten = 0;
        }

        if (cbWritten + m_pos > m_pData->cb)
        {
                ULISet32( ularge_integer, m_pos+cbWritten );
                error = SetSize(ularge_integer);
                if (error != NOERROR)
                {
                        goto Exit;
                }
        }

        // we don't write anything if 0 bytes are asked for for two
        // reasons: 1. optimization, 2. m_pData->hGlobal could be a
        // handle to a zero-byte memory block, in which case GlobalLock
        // will fail.

        if( cbWritten > 0 )
        {
                pGlobal = (BYTE HUGEP *)GlobalLock (m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        LEERROR(1, "GlobalLock Failed!");

                        return ResultFromScode (STG_E_WRITEFAULT);
                }

                // we use memmove here instead of memcpy to handle the
                // overlap case.  Recall that the app originally gave
                // use the memory for the memstm.  He could (either through
                // a CopyTo or through really strange code), be giving us
                // this region to read from, so we have to handle the overlapp
                // case.  The same argument also applies for Read, but for
                // now, we'll consider overlap on Read a bug.
                _xmemmove(pGlobal + m_pos, pb, cbWritten);
                GlobalUnlock (m_pData->hGlobal);

                m_pos += cbWritten;
        }

        if (pcbWritten != NULL)
        {
                *pcbWritten = cbWritten;
        }

Exit:

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Seek
//
//  Synopsis:   Moves the internal seek pointer
//
//  Effects:
//
//  Arguments:  [dlibMoveIN]    -- the amount to move by
//              [dwOrigin]      -- flags to control whether seeking is
//                                 relative to the current postion or
//                                 the begging/end.
//              [plibNewPosition]       -- where to put the new position
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Seek)
STDMETHODIMP CMemStm::Seek(LARGE_INTEGER dlibMoveIN, DWORD dwOrigin,
        ULARGE_INTEGER FAR* plibNewPosition)
{
        VDATEHEAP();

        HRESULT                 error  = NOERROR;
        LONG                    dlibMove = dlibMoveIN.LowPart ;
        ULONG                   cbNewPos = dlibMove;

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        if (plibNewPosition != NULL)
        {
                VDATEPTROUT( plibNewPosition, ULONG );
                ULISet32(*plibNewPosition, m_pos);
        }

        switch(dwOrigin)
        {

        case STREAM_SEEK_SET:
                if (dlibMove >= 0)
                {
                        m_pos = dlibMove;
                }
                else
                {
                        error = ResultFromScode(STG_E_SEEKERROR);
                }

                break;

        case STREAM_SEEK_CUR:
                if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
                {
                        m_pos += dlibMove;
                }
                else
                {
                        error = ResultFromScode(STG_E_SEEKERROR);
                }
                break;

        case STREAM_SEEK_END:
                if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pData->cb))
                {
                        m_pos = m_pData->cb + dlibMove;
                }
                else
                {
                        error = ResultFromScode(STG_E_SEEKERROR);
                }
                break;

        default:
                error = ResultFromScode(STG_E_SEEKERROR);
        }

        if (plibNewPosition != NULL)
        {
                ULISet32(*plibNewPosition, m_pos);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::SetSize
//
//  Synopsis:   Sets the size of our memory
//
//  Effects:
//
//  Arguments:  [cb]    -- the new size
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  calls GlobalRealloc
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port, added assert
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_SetSize)
STDMETHODIMP CMemStm::SetSize(ULARGE_INTEGER cb)
{
        VDATEHEAP();

        HANDLE hMemNew;

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        // make sure we aren't in overflow conditions.

        AssertSz(cb.HighPart == 0,
                "MemStream::More than 2^32 bytes asked for");

        if (m_pData->cb == cb.LowPart)
        {
                return NOERROR;
        }

        hMemNew = GlobalReAlloc(m_pData->hGlobal, max (cb.LowPart,1),
                        GMEM_SHARE | GMEM_MOVEABLE);

        if (hMemNew == NULL)
        {
                return ResultFromScode (E_OUTOFMEMORY);
        }

        m_pData->hGlobal = hMemNew;
        m_pData->cb = cb.LowPart;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::CopyTo
//
//  Synopsis:   Copies data from [this] stream to [pstm]
//
//  Effects:
//
//  Arguments:  [pstm]          -- the stream to copy to
//              [cb]            -- the number of bytes to copy
//              [pcbRead]       -- where to return the number of bytes read
//              [pcbWritten]    -- where to return the number of bytes written
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  does an IStream->Write to the given stream
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              03-Dec-93 alexgo    original implementation
//
//  Notes:      This implementation assumes that the address space
//              is not greater than ULARGE_INTEGER.LowPart (which is
//              for for 32bit operating systems).  64bit NT may need
//              to revisit this code.
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_CopyTo)
STDMETHODIMP CMemStm::CopyTo(IStream FAR *pstm, ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR * pcbRead, ULARGE_INTEGER FAR * pcbWritten)
{
        VDATEHEAP();

        ULONG   cbRead          = cb.LowPart;
        ULONG   cbWritten       = 0;
        HRESULT hresult         = NOERROR;

        // pstm cannot be NULL

        VDATEPTRIN(pstm, LPSTREAM);

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        // the spec says that if cb is it's maximum value (all bits set,
        // since it's unsigned), then we will simply read the copy of
        // this stream

        if ( ~(cb.LowPart) == 0 && ~(cb.HighPart) == 0 )
        {
                cbRead = m_pData->cb - m_pos;
        }
        else if ( cb.HighPart > 0 )
        {
                // we assume that our memory stream cannot
                // be large enough to accomodate very large (>32bit)
                // copy to requests.  Since this is probably an error
                // on the caller's part, we assert.

                AssertSz(0, "WARNING: CopyTo request exceeds 32 bits");

                // set the Read value to what's left, so that "Ignore"ing
                // the assert works properly.

                cbRead = m_pData->cb - m_pos;
        }
        else if ( cbRead + m_pos > m_pData->cb )
        {
                // more bytes were requested to read than we had left.
                // cbRead is set to the amount remaining.

                cbRead = m_pData->cb - m_pos;
        }

        // now write the data to the stream

        if ( cbRead > 0 )
        {
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                                m_pData->hGlobal);

                if( pGlobal == NULL )
                {
                        LEERROR(1, "GlobalLock failed");

                        return ResultFromScode(STG_E_INSUFFICIENTMEMORY);
                }

                hresult = pstm->Write(pGlobal + m_pos, cbRead, &cbWritten);

                // in the error case, the spec says that the return values
                // may be meaningless, so we do not need to do any special
                // error handling here

                GlobalUnlock(m_pData->hGlobal);
        }

        // increment our seek pointer and set the out parameters

        m_pos += cbRead;

        if( pcbRead )
        {
                ULISet32(*pcbRead, cbRead);
        }

        if( pcbWritten )
        {
                ULISet32(*pcbWritten, cbWritten);
        }

        return hresult;

}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Commit
//
//  Synopsis:   Does nothing, no transactions available on memory streams
//
//  Effects:
//
//  Arguments:  [grfCommitFlags]
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Commit)
STDMETHODIMP CMemStm::Commit(DWORD grfCommitFlags)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Revert
//
//  Synopsis:   does nothing, as no transactions are supported on memory
//              streams
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Revert)
STDMETHODIMP CMemStm::Revert(void)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::LockRegion
//
//  Synopsis:   not supported in OLE2.01
//
//  Effects:
//
//  Arguments:  [libOffset]
//              [cb]
//              [dwLockType]
//
//  Requires:
//
//  Returns:    STG_E_INVALIDFUNCTION
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_LockRegion)
STDMETHODIMP CMemStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
        DWORD dwLockType)
{
        VDATEHEAP();

        return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::UnlockRegion
//
//  Synopsis:   not implemented for OLE2.01
//
//  Effects:
//
//  Arguments:  [libOffset]
//              [cb]
//              [dwLockType]
//
//  Requires:
//
//  Returns:    STG_E_INVALIDFUNCTION
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_UnlockRegion)
STDMETHODIMP CMemStm::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        VDATEHEAP();

        return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Stat
//
//  Synopsis:   Returns info about this stream
//
//  Effects:
//
//  Arguments:  [pstatstg]      -- the STATSTG to fill with info
//              [statflag]      -- status flags, unused
//
//  Requires:
//
//  Returns:    NOERROR, E_INVALIDARG
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//              01-Jun-94 AlexT     Set type correctly
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Stat)
STDMETHODIMP CMemStm::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
        VDATEHEAP();

        VDATEPTROUT( pstatstg, STATSTG );

        memset ( pstatstg, 0, sizeof(STATSTG) );

        pstatstg->type                  = STGTY_STREAM;
        pstatstg->cbSize.LowPart        = m_pData->cb;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Clone
//
//  Synopsis:   creates a new instance of this stream pointing to the
//              same data at the same position (same seek pointer)
//
//  Effects:
//
//  Arguments:  [ppstm]         -- where to put the new CMemStm pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Clone)
STDMETHODIMP CMemStm::Clone(IStream FAR * FAR *ppstm)
{
        VDATEHEAP();

        CMemStm FAR*    pCMemStm;

        VDATEPTROUT (ppstm, LPSTREAM);

        *ppstm = pCMemStm = CMemStm::Create(m_hMem, m_pmxs);

        if (pCMemStm == NULL)
        {
                return ResultFromScode(E_OUTOFMEMORY);
        }

        pCMemStm->m_pos = m_pos;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Create
//
//  Synopsis:   Creates a new CMemStm.  [hMem] must be a handle to a MEMSTM
//              block.
//
//  Effects:
//
//  Arguments:  [hMem]  -- handle to a MEMSTM block
//
//  Requires:
//
//  Returns:    CMemStm *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Dec-93 alexgo    fixed memory access bug
//              03-Dec-93 alexgo    32bit port
//              20-Sep-2000 mfeingol Added Mutex inheritance
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Create)
STDSTATICIMP_(CMemStm FAR*) CMemStm::Create(HANDLE hMem, CRefMutexSem* pmxs)
{
        VDATEHEAP();

        CMemStm FAR* pCMemStm = NULL;
        struct MEMSTM FAR* pData;

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData != NULL)
        {
            pCMemStm = new CMemStm;

            if (pCMemStm != NULL)
            {
                // Initialize CMemStm
                pCMemStm->m_hMem = hMem;
                InterlockedIncrement ((LPLONG) &(pCMemStm->m_pData = pData)->cRef); // AddRefMemStm
                pCMemStm->m_refs = 1;
                pCMemStm->m_dwSig = STREAM_SIG;

                if (pmxs != NULL)
                {
                    // Addref the input
                    pmxs->AddRef();
                }
                else
                {
                    // Create a new mutex (implicit addref)
                    pmxs = CRefMutexSem::CreateInstance();
                }

                if (pmxs != NULL)
                {
                    // Give the CMemStm a mutex
                    pCMemStm->m_pmxs = pmxs;
                }
                else
                {
                    // uh-oh, low on memory
                    delete pCMemStm;
                    pCMemStm = NULL;

                    GlobalUnlock(hMem);
                }
            }
            else
            {
                // uh-oh, low on memory
                GlobalUnlock(hMem);
            }
        }

        // we do *not* unlock the memory now, the memstm structure should
        // be locked for the lifetime of any CMemStm's that refer to it.
        // when the CMemStm is destroyed, we will release our lock on
        // hMem.

        return pCMemStm;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CMemStm::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszMEMSTM;
    char *pszCMutexSem;
    dbgstream dstrPrefix;
    dbgstream dstrDump(400);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Impl. Signature   = " << m_dwSig      << endl;

    dstrDump << pszPrefix << "No. of References = " << m_refs       << endl;

    dstrDump << pszPrefix << "Seek pointer      = " << m_pos        << endl;

    dstrDump << pszPrefix << "Memory handle     = " << m_hMem       << endl;

    if (m_pData != NULL)
    {
        pszMEMSTM = DumpMEMSTM(m_pData, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "MEMSTM:" << endl;
        dstrDump << pszMEMSTM;
        CoTaskMemFree(pszMEMSTM);
    }
    else
    {
        dstrDump << pszPrefix << "MEMSTM            = " << m_pData      << endl;
    }

    pszCMutexSem = DumpCMutexSem ((CMutexSem2*) m_pmxs->GetMutexSem());
    dstrDump << pszPrefix << "Mutex             = " << pszCMutexSem << endl;
    CoTaskMemFree(pszCMutexSem);

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMemStm, public (_DEBUG only)
//
//  Synopsis:   calls the CMemStm::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pMS]           - pointer to CMemStm
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMemStm(CMemStm *pMS, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pMS == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pMS->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   CreateMemStm
//
//  Synopsis:   Allocates memory and creates a CMemStm for it.
//
//  Effects:
//
//  Arguments:  [cb]    -- the number of bytes to allocate
//              [phMem] -- where to put a handle to the MEMSTM structure
//
//  Requires:
//
//  Returns:    LPSTREAM to the CMemStream
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:      phMem must be free'd with ReleaseMemStm (because of ref
//              counting and the nested handle)
//
//--------------------------------------------------------------------------

#pragma SEG(CreateMemStm)
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem)
{
        VDATEHEAP();

        HANDLE          h;
        LPSTREAM        pstm = NULL;

        if (phMem)
        {
                *phMem = NULL;
        }

        h = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, cb);
        if (NULL==h)
        {
                return NULL;
        }

        if (CreateStreamOnHGlobal (h, TRUE, &pstm) != NOERROR)
        {
                GlobalFree(h);	// COM+ 22886
                return NULL;
        }
        if (phMem)
        {
                // retrieve handle from just-created CMemStm
                *phMem = ((CMemStm FAR*)pstm)->m_hMem;

                // use pointer to bump ref count
                Assert(((CMemStm FAR*)pstm)->m_pData != NULL);
                InterlockedIncrement ((LPLONG) &((CMemStm FAR*)pstm)->m_pData->cRef);  // AddRefMemStm
        }
        return pstm;
}


//+-------------------------------------------------------------------------
//
//  Function:   CloneMemStm
//
//  Synopsis:   Clones a memory stream
//
//  Effects:
//
//  Arguments:  [hMem]  -- a handle to the MEMSTM block
//
//  Requires:
//
//  Returns:    LPSTREAM
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------
#pragma SEG(CloneMemStm)

STDAPI_(LPSTREAM) CloneMemStm(HANDLE hMem)
{
        VDATEHEAP();

        return CMemStm::Create(hMem, NULL); // Create the stream
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseMemStm
//
//  Synopsis:   Releases the memory used by a MEMSTM structure (including
//              the nested handle)
//
//  Effects:
//
//  Arguments:  [phMem]         -- pointer the MEMSTM handle
//              [fInternalOnly] -- if TRUE, then only the actual memory
//                                 that MEMSTM refers to is freed
//                                 (not the MEMSTM structure itself)
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   sets *phMem to NULL on success
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port and fixed bad memory access
//                                  bug
//
//  Notes:      REVIEW32:  look at taking out the second argument
//
//--------------------------------------------------------------------------

#pragma SEG(ReleaseMemStm)
STDAPI_(void) ReleaseMemStm (LPHANDLE phMem, BOOL fInternalOnly)
{
        VDATEHEAP();

        struct MEMSTM FAR*      pData;

        pData = (MEMSTM FAR*) GlobalLock(*phMem);

        // check for NULL pointer in case handle got freed already
        // decrement ref count and free if no refs left
        if (pData != NULL && InterlockedDecrement ((LPLONG) &pData->cRef) == 0)
        {
                if (pData->fDeleteOnRelease)
                {
                        Verify (0==GlobalFree (pData->hGlobal));
                }

                if (!fInternalOnly)
                {
                        GlobalUnlock(*phMem);
                        Verify (0==GlobalFree(*phMem));
                        goto End;
                }
        }

        GlobalUnlock(*phMem);
End:
        *phMem = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateStreamOnHGlobal
//
//  Synopsis:   Creates a CMemStm from the given hGlobal (if [hGlobal] is
//              NULL, we allocate a zero byte one)
//
//  Effects:
//
//  Arguments:  [hGlobal]               -- the memory
//              [fDeleteOnRelease]      -- whether the memory should be
//                                         release on delete
//              [ppstm]                 -- where to put the stream
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-93 alexgo    removed initialization of cbSize to -1
//                                  to fix compile warning
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CreateStreamOnHGlobal)
STDAPI CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm)
{
        OLETRACEIN((API_CreateStreamOnHGlobal, PARAMFMT("hGlobal= %h, fDeleteOnRelease= %B, ppstm= %p"),
                hGlobal, fDeleteOnRelease, ppstm));

        VDATEHEAP();

        HANDLE                  hMem      = NULL;
        struct MEMSTM FAR*      pData     = NULL;
        LPSTREAM                pstm      = NULL;
        DWORD                   cbSize;
        BOOL                    fAllocated = FALSE;
        HRESULT hresult;

        VDATEPTROUT_LABEL (ppstm, LPSTREAM, SafeExit, hresult);

        *ppstm = NULL;

        if (NULL==hGlobal)
        {
                hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, 0);
                if (hGlobal == NULL)
                {
                        goto FreeMem;
                }
                cbSize = 0;
                fAllocated = TRUE;
        }
        else
        {
                cbSize = (ULONG) GlobalSize (hGlobal);
                // Is there a way to verify a zero-sized handle?
                // we currently do no verification for them
                if (cbSize!=0)
                {
                        // verify validity of passed-in handle
                        if (NULL==GlobalLock(hGlobal))
                        {
                                // bad handle
                                hresult = ResultFromScode (E_INVALIDARG);
                                goto SafeExit;
                        }
                        GlobalUnlock (hGlobal);
                }
        }

        hMem = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, sizeof (MEMSTM));
        if (hMem == NULL)
        {
                goto FreeMem;
        }

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData == NULL)
        {
                GlobalUnlock(hMem);
                goto FreeMem;
        }

        pData->cRef = 0;
        pData->cb = cbSize;
        pData->fDeleteOnRelease = fDeleteOnRelease;
        pData->hGlobal = hGlobal;
        GlobalUnlock(hMem);

        pstm = CMemStm::Create(hMem, NULL);

        if (pstm == NULL)
        {
                goto FreeMem;
        }

        *ppstm = pstm;

        CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)ppstm);
        hresult = NOERROR;
        goto SafeExit;

FreeMem:
        if (hGlobal && fAllocated)
        {
	        Verify(0==GlobalFree(hGlobal));
        }
        if (hMem)
        {
            Verify(0==GlobalFree(hMem));
        }

        LEERROR(1, "Out of memory!");

        hresult = ResultFromScode(E_OUTOFMEMORY);

SafeExit:

        OLETRACEOUT((API_CreateStreamOnHGlobal, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetHGlobalFromStream
//
//  Synopsis:   Retrieves the HGLOBAL to the memory from the given stream
//              pointer (must be a pointer to a CMemByte structure)
//
//  Effects:
//
//  Arguments:  [pstm]          -- pointer to the CMemByte
//              [phglobal]      -- where to put the hglobal
//
//  Requires:
//
//  Returns:    HRESULT (E_INVALIDARG, E_OUTOFMEMORY, NOERROR)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(GetHGlobalFromStream)
STDAPI GetHGlobalFromStream(LPSTREAM pstm, HGLOBAL FAR* phglobal)
{
        OLETRACEIN((API_GetHGlobalFromStream, PARAMFMT("pstm= %p, phglobal= %p"),
                pstm, phglobal));

        VDATEHEAP();

        HRESULT hresult;
        CMemStm FAR* pCMemStm;
        MEMSTM FAR* pMem;

        VDATEIFACE_LABEL (pstm, errRtn, hresult);
        VDATEPTROUT_LABEL(phglobal, HANDLE, errRtn, hresult);
        CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pstm);

        pCMemStm = (CMemStm FAR*) pstm;

        if (!IsValidReadPtrIn (&(pCMemStm->m_dwSig), sizeof(ULONG))
                || pCMemStm->m_dwSig != STREAM_SIG)
        {
                // we were passed someone else's implementation of ILockBytes
                hresult = ResultFromScode (E_INVALIDARG);
                goto errRtn;
        }

        pMem= pCMemStm->m_pData;
        if (NULL==pMem)
        {
                LEERROR(1, "Out of memory!");

                hresult = ResultFromScode (E_OUTOFMEMORY);
                goto errRtn;
        }
        Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
        Verify (*phglobal = pMem->hGlobal);

        hresult = NOERROR;

errRtn:
        OLETRACEOUT((API_GetHGlobalFromStream, hresult));

        return hresult;
}


//////////////////////////////////////////////////////////////////////////
//
// Shared memory ILockBytes implementation
//

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::QueryInterface
//
//  Synopsis:   returns the requested interface pointer
//
//  Effects:    a CMarshalMemBytes will be created if IID_IMarshal is
//              requested
//
//  Arguments:  [iidInterface]  -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    removed QI for IMarshal so that
//                                  the standard marshaller will be used.
//                                  This is to enable correct operation on
//                                  32bit platforms.
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_QueryInterface)
STDMETHODIMP CMemBytes::QueryInterface(REFIID iidInterface,
        void FAR* FAR* ppvObj)
{
        VDATEHEAP();

        HRESULT                 error;

        VDATEPTROUT( ppvObj, LPVOID );
        *ppvObj = NULL;
        VDATEIID( iidInterface );

        if (m_pData != NULL && (IsEqualIID(iidInterface, IID_ILockBytes) ||
                IsEqualIID(iidInterface, IID_IUnknown)))
        {
                InterlockedIncrement ((LPLONG) &m_refs);   // A pointer to this object is returned
                *ppvObj = this;
                error = NOERROR;
        }
        else
        {
                *ppvObj = NULL;
                error = ResultFromScode(E_NOINTERFACE);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::AddRef
//
//  Synopsis:   Incrememts the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMemBytes::AddRef(void)
{
        VDATEHEAP();

        return InterlockedIncrement ((LPLONG) &m_refs);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-93 alexgo    added GlobalUnlock to match the Global
//                                  Lock in Create
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMemBytes::Release(void)
{
        VDATEHEAP();

        ULONG ulRefs = InterlockedDecrement ((LPLONG) &m_refs);

        if (ulRefs != 0)
        {
                return ulRefs;
        }

        // GlobalUnlock the m_hMem that we GlobalLocke'd in Create
        GlobalUnlock(m_hMem);

        ReleaseMemStm(&m_hMem);

        delete this;
        return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::ReadAt
//
//  Synopsis:   reads [cb] bytes from starting position [ulOffset]
//
//  Effects:
//
//  Arguments:  [ulOffset]      -- the offset to start reading from
//              [pb]            -- where to put the data
//              [cb]            -- the number of bytes to read
//              [pcbRead]       -- where to put the number of bytes actually
//                                 read
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:  just calls xmemcpy
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_ReadAt)
STDMETHODIMP CMemBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP* pb,
        ULONG cb, ULONG FAR* pcbRead)
{
        VDATEHEAP();

        HRESULT         error   = NOERROR;
        ULONG           cbRead  = cb;

        VDATEPTROUT( pb, char );

        // make sure we don't offset out of the address space!
        AssertSz(ulOffset.HighPart == 0,
                "CMemBytes: offset greater than 2^32");

        if (pcbRead)
        {
                *pcbRead = 0L;
        }

        if (cbRead + ulOffset.LowPart > m_pData->cb)
        {

                if (ulOffset.LowPart > m_pData->cb)
                {
                        // the offset overruns the size of the memory
                        cbRead = 0;
                }
                else
                {
                        // just read what's left
                        cbRead = m_pData->cb - ulOffset.LowPart;
                }
        }

        if (cbRead > 0)
        {
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                        m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        LEERROR(1, "GlobalLock failed!");

                        return ResultFromScode (STG_E_READFAULT);
                }
                _xmemcpy(pb, pGlobal + ulOffset.LowPart, cbRead);
                GlobalUnlock (m_pData->hGlobal);
        }

        if (pcbRead != NULL)
        {
                *pcbRead = cbRead;
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::WriteAt
//
//  Synopsis:   writes [cb] bytes at [ulOffset] in the stream
//
//  Effects:
//
//  Arguments:  [ulOffset]      -- the offset at which to start writing
//              [pb]            -- the buffer to read from
//              [cb]            -- the number of bytes to write
//              [pcbWritten]    -- where to put the number of bytes written
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_WriteAt)
STDMETHODIMP CMemBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP* pb,
        ULONG cb, ULONG FAR* pcbWritten)
{
        VDATEHEAP();

        HRESULT         error           = NOERROR;
        ULONG           cbWritten       = cb;
        BYTE HUGEP*     pGlobal;

        VDATEPTRIN( pb, char );

        // make sure the offset doesn't go beyond our address space!

        AssertSz(ulOffset.HighPart == 0, "WriteAt, offset greater than 2^32");

        if (pcbWritten)
        {
                *pcbWritten = 0;
        }

        if (cbWritten + ulOffset.LowPart > m_pData->cb)
        {
                ULARGE_INTEGER ularge_integer;
                ULISet32( ularge_integer, ulOffset.LowPart + cbWritten);
                error = SetSize( ularge_integer );
                if (error != NOERROR)
                {
                        goto Exit;
                }
        }

        // CMemBytes does not allow zero-sized memory handles

        pGlobal = (BYTE HUGEP *)GlobalLock (m_pData->hGlobal);

        if (NULL==pGlobal)
        {
                LEERROR(1, "GlobalLock failed!");

                return ResultFromScode (STG_E_WRITEFAULT);
        }

        _xmemcpy(pGlobal + ulOffset.LowPart, pb, cbWritten);
        GlobalUnlock (m_pData->hGlobal);


        if (pcbWritten != NULL)
        {
                *pcbWritten = cbWritten;
        }

Exit:
        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Flush
//
//  Synopsis:   Flushes internal state to disk
//              Not needed for memory ILockBytes
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_Flush)
STDMETHODIMP CMemBytes::Flush(void)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::SetSize
//
//  Synopsis:   Sets the size of the memory buffer
//
//  Effects:
//
//  Arguments:  [cb]    -- the new size
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_SetSize)
STDMETHODIMP CMemBytes::SetSize(ULARGE_INTEGER cb)
{
        VDATEHEAP();

        HANDLE          hMemNew;

        AssertSz(cb.HighPart == 0,
                "SetSize: trying to set to more than 2^32 bytes");

        if (m_pData->cb == cb.LowPart)
        {
                return NOERROR;
        }

        hMemNew = GlobalReAlloc(m_pData->hGlobal, max (cb.LowPart, 1),
                GMEM_SHARE | GMEM_MOVEABLE);

        if (hMemNew == NULL)
        {
                return ResultFromScode(E_OUTOFMEMORY);
        }

        m_pData->hGlobal = hMemNew;
        m_pData->cb = cb.LowPart;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::LockRegion
//
//  Synopsis:   Locks a region.  Since only we have access to the memory,
//              nothing needs to be done (note that the *app* also may
//              access, but there's not much we can do about that)
//
//  Effects:
//
//  Arguments:  [libOffset]     -- offset to start with
//              [cb]            -- the number of bytes in the locked region
//              [dwLockType]    -- the type of lock to use
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_LockRegion)
STDMETHODIMP CMemBytes::LockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::UnlockRegion
//
//  Synopsis:   Unlocks a region; since only we have access to the memory,
//              nothing needs to be done.
//
//  Effects:
//
//  Arguments:  [libOffset]     -- the offset to start with
//              [cb]            -- the number of bytes in the region
//              [dwLockType]    -- the lock type
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_UnlockRegion)
STDMETHODIMP CMemBytes::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Stat
//
//  Synopsis:   returns status information
//
//  Effects:
//
//  Arguments:  [pstatstg]      -- where to put the status info
//              [statflag]      -- status flags (ignored)
//
//  Requires:
//
//  Returns:    NOERROR, E_INVALIDARG
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//              01-Jun-94 AlexT     Set type correctly
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_Stat)
STDMETHODIMP CMemBytes::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
        VDATEHEAP();

        VDATEPTROUT( pstatstg, STATSTG );

        memset ( pstatstg, 0, sizeof(STATSTG) );

        pstatstg->type                  = STGTY_LOCKBYTES;
        pstatstg->cbSize.LowPart        = m_pData->cb;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Create
//
//  Synopsis:   Creates an instance of CMemBytes
//
//  Effects:
//
//  Arguments:  [hMem]  -- handle to the memory (must be a MEMSTM block)
//
//  Requires:
//
//  Returns:    CMemBytes *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-93 alexgo    fixed bad pointer bug (took out
//                                  GlobalUnlock)
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_Create)
STDSTATICIMP_(CMemBytes FAR*) CMemBytes::Create(HANDLE hMem)
{
        VDATEHEAP();

        CMemBytes FAR*          pCMemBytes = NULL;
        struct MEMSTM FAR*      pData;

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData != NULL)
        {
                Assert (pData->hGlobal);

                pCMemBytes = new CMemBytes;

                if (pCMemBytes != NULL)
                {
                        // Initialize CMemBytes
                        pCMemBytes->m_dwSig = LOCKBYTE_SIG;
                        pCMemBytes->m_hMem = hMem;
                        InterlockedIncrement ((LPLONG) &(pCMemBytes->m_pData = pData)->cRef); // AddRefMemStm
                        pCMemBytes->m_refs = 1;
                        CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_ILockBytes,
                                             (IUnknown **)&pCMemBytes);
                }
                else
                {
                        // uh-oh, low on memory
                        GlobalUnlock(hMem);
                }
        }

        // we don't GlobalUnlock(hMem) until we destory this CMemBytes
        return pCMemBytes;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CMemBytes::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszMEMSTM;
    dbgstream dstrPrefix;
    dbgstream dstrDump(400);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Impl. Signature   = " << m_dwSig  << endl;

    dstrDump << pszPrefix << "No. of References = " << m_refs   << endl;

    dstrDump << pszPrefix << "Memory handle     = " << m_hMem   << endl;

    if (m_pData != NULL)
    {
        pszMEMSTM = DumpMEMSTM(m_pData, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "MEMSTM:"                      << endl;
        dstrDump << pszMEMSTM;
        CoTaskMemFree(pszMEMSTM);
    }
    else
    {
        dstrDump << pszPrefix << "MEMSTM            = " << m_pData  << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMemBytes, public (_DEBUG only)
//
//  Synopsis:   calls the CMemBytes::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pMB]           - pointer to CMemBytes
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMemBytes(CMemBytes *pMB, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pMB == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pMB->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\create.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       create.cpp
//
//  Contents:   creation and miscellaneous APIs
//
//  Classes:
//
//  Functions:  OleCreate
//              OleCreateEx
//              OleCreateFromData
//              OleCreateFromDataEx
//              OleCreateLinkFromData
//              OleCreateLinkFromDataEx
//              OleCreateLink
//              OleCreateLinkEx
//              OleCreateLinkToFile
//              OleCreateLinkToFileEx
//              OleCreateFromFile
//              OleCreateFromFileEx
//              OleDoAutoConvert
//              OleLoad
//              OleCreateStaticFromData
//              OleQueryCreateFromData
//              OleQueryLinkFromData
//              CoIsHashedOle1Class     (internal)
//              EnsureCLSIDIsRegistered (internal)
//
//  History:    dd-mmm-yy Author    Comment
//              26-Apr-96 davidwor  Moved validation into separate function.
//              01-Mar-96 davidwor  Added extended create functions.
//              16-Dec-94 alexgo    added call tracing
//              07-Jul-94 KevinRo   Changed RegQueryValue to RegOpenKey in
//                                  strategic places.
//              10-May-94 KevinRo   Reimplemented OLE 1.0 interop
//              24-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocation
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              10-Dec-93 AlexT     header clean up - include ole1cls.h
//              08-Dec-93 ChrisWe   added necessary casts to GlobalLock() calls
//                      resulting from removing bogus GlobalLock() macros in
//                      le2int.h
//              29-Nov-93 ChrisWe   changed call to UtIsFormatSupported to
//                                      take a single DWORD of direction flags
//              22-Nov-93 ChrisWe   replaced overloaded == with IsEqualxID
//              28-Oct-93 alexgo    32bit port
//              24-Aug-92 srinik    created
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(create)

#include <create.h>
#include <ole1cls.h>    //  Only needed to get CLSID_WordDocument

// HACK ALERT!!  This is needed for the MFC OleQueryCreateFromData hack
#include <clipdata.h>

NAME_SEG(Create)
ASSERTDATA

//used in wCreateObject

#define STG_NONE        0
#define STG_INITNEW     1
#define STG_LOAD        2


#define QUERY_CREATE_NONE               0
#define QUERY_CREATE_OLE                1
#define QUERY_CREATE_STATIC             2

INTERNAL        wDoUpdate(IUnknown FAR* lpUnknown);


//+-------------------------------------------------------------------------
//
//  Function:   wGetEnumFormatEtc
//
//  Synopsis:   retrieves a FormatEtc enumerator
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the data object
//              [dwDirection]   -- direction
//              [ppenum]        -- where to put the enumerator
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  asks the data object for the enumerator
//              if it returns OLE_S_USEREG, then get try to get the
//              clsid from IOleObject::GetUserClassID and enumerate
//              the formats from the registry.
//
//  History:    dd-mmm-yy Author    Comment
//              24-Apr-94 alexgo    author
//              13-Mar-95 scottsk   Added hack for the Bob Calendar
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT wGetEnumFormatEtc( IDataObject *pDataObj, DWORD dwDirection,
        IEnumFORMATETC **ppIEnum)
{
    HRESULT         hresult;
    IOleObject *    pOleObject;
    CLSID           clsid;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN wGetEnumFormatEtc ( %p , %p , %lx )"
        "\n", NULL, pDataObj, ppIEnum, dwDirection));

    hresult = pDataObj->EnumFormatEtc(dwDirection, ppIEnum);

    if( hresult == ResultFromScode(OLE_S_USEREG) )
    {
        hresult = pDataObj->QueryInterface(IID_IOleObject,
                (void **)&pOleObject);

        if( hresult != NOERROR )
        {
            // return E_FAIL vs E_NOINTERFACE
            hresult = ResultFromScode(E_FAIL);
            goto errRtn;
        }

        hresult = pOleObject->GetUserClassID(&clsid);

        if( hresult == NOERROR )
        {
            hresult = OleRegEnumFormatEtc(clsid, dwDirection,
                    ppIEnum);
        }

        pOleObject->Release();
    }
    else if (*ppIEnum == NULL && hresult == NOERROR)
    {
        // HACK ALERT:  NT Bug #8350.   MS Bob Calendar returns success from
        // IDO::EnumFormatEtc and sets *ppIEnum = NULL on the IDO used during
        // drag-drop.  Massage the return value to be failure.
        hresult = E_FAIL;
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT wGetEnumFormatEtc ( %lx ) [ %p ]\n",
        NULL, hresult, *ppIEnum));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleCreate
//
//  Synopsis:   Creates and runs an object of the requested CLSID
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the CLSID of the object to create
//              [iid]           -- the interface to request on the object
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [lpFormatEtc]   -- rendering format, if OLERENDER_FORMAT is
//                                 specified in renderopt.
//              [lpClientSite]  -- the client site for the object
//              [lpStg]         -- the object's storage
//              [lplpObj]       -- where to put the pointer to the created
//                                 object
//
//  Requires:   HRESULT
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              05-May-94 alexgo    fixed error case if cache initialization
//                                  fails.
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreate)
STDAPI  OleCreate
(
    REFCLSID                rclsid,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateEx(rclsid, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateEx
//
//  Synopsis:   Creates and runs an object of the requested CLSID
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the CLSID of the object to create
//              [iid]           -- the interface to request on the object
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- the client site for the object
//              [lpStg]         -- the object's storage
//              [lplpObj]       -- where to put the pointer to the created
//                                 object
//
//  Requires:   HRESULT
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              05-May-94 alexgo    fixed error case if cache initialization
//                                  fails.
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateEx)
STDAPI  OleCreateEx
(
    REFCLSID                rclsid,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateEx,
                PARAMFMT("rclsid= %I, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
                &rclsid, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    HRESULT                 error;
    FORMATETC               formatEtc;
    LPFORMATETC             lpFormatEtc;
    BOOL                    fAlloced = FALSE;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateEx ( %p , %p , %lx , %lx , %lx ,"
      "%p , %p , %p , %p , %p , %p , %p )\n", 0, &rclsid, &iid, dwFlags,
      renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
      lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, errRtn, error );
    *lplpObj = NULL;

    VDATEIID_LABEL( iid, errRtn, error);

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
        &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
        goto LExit;

    if ((error = wCreateObject(rclsid, FALSE,
                               iid, lpClientSite, lpStg,
                               STG_INITNEW, lplpObj)) != NOERROR)
        goto LExit;

    // No need to Run the object if no caches are requested.
    if ((renderopt != OLERENDER_NONE) && (renderopt != OLERENDER_ASIS))
    {
        if ((error = OleRun((LPUNKNOWN) *lplpObj)) != NOERROR)
            goto LExit;

        if ((error = wInitializeCacheEx(NULL, rclsid, renderopt,
            cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
            *lplpObj))
            != NOERROR)
        {
            // if this fails, we need to call Close
            // to shut down the embedding (the reverse of Run).
            // the final release below will be the final
            // one to nuke the memory image.
            IOleObject *    lpOleObject;

            if( ((IUnknown *)*lplpObj)->QueryInterface(
                IID_IOleObject, (void **)&lpOleObject) == NOERROR )
            {
                Assert(lpOleObject);
                lpOleObject->Close(OLECLOSE_NOSAVE);
                lpOleObject->Release();
            }
        }
    }

LExit:

    if (fAlloced)
        PubMemFree(lpFormatEtc);

    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateEx ( %lx ) [ %p ]\n", 0,
      error, *lplpObj));

    error = wReturnCreationError(error);

errRtn:
    OLETRACEOUT((API_OleCreateEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromData
//
//  Synopsis:   Creates an embedded object from an IDataObject pointer
//              (such as an data object from the clipboard or from a drag
//              and drop operation)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object from which
//                                 the object should be created
//              [iid]           -- interface ID to request
//              [renderopt]     -- rendering options (same as OleCreate)
//              [lpFormatEtc]   -- render format options (same as OleCreate)
//              [lpClientSite]  -- client site for the object
//              [lpStg]         -- storage for the object
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromData)
STDAPI  OleCreateFromData
(
  IDataObject FAR*            lpSrcDataObj,
  REFIID                      iid,
  DWORD                       renderopt,
  LPFORMATETC                 lpFormatEtc,
  IOleClientSite FAR*         lpClientSite,
  IStorage FAR*               lpStg,
  void FAR* FAR*              lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateFromDataEx(lpSrcDataObj, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromDataEx
//
//  Synopsis:   Creates an embedded object from an IDataObject pointer
//              (such as an data object from the clipboard or from a drag
//              and drop operation)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object from which
//                                 the object should be created
//              [iid]           -- interface ID to request
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- client site for the object
//              [lpStg]         -- storage for the object
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromDataEx)
STDAPI  OleCreateFromDataEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    HRESULT     hresult;
    CLIPFORMAT      cfFormat;
    WORD            wStatus;

    OLETRACEIN((API_OleCreateFromDataEx,
        PARAMFMT("lpSrcDataObj= %p, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpSrcDataObj, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateFromDataEx ( %p , %p , %lx , %lx ,"
        " %lx , %p , %p , %p , %p , %p , %p , %p )\n", 0, lpSrcDataObj, &iid,
        dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, hresult );
    *lplpObj = NULL;

    VDATEIFACE_LABEL( lpSrcDataObj, errRtn, hresult );
    VDATEIID_LABEL( iid, errRtn, hresult );

    hresult = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (hresult != NOERROR)
        goto errRtn;

    wStatus = wQueryEmbedFormats(lpSrcDataObj, &cfFormat);

    if (!(wStatus & QUERY_CREATE_OLE))
    {
        if (wStatus & QUERY_CREATE_STATIC)
        {
            hresult = OLE_E_STATIC;
        }
        else
        {
            hresult = DV_E_FORMATETC;
        }

        goto errRtn;
    }

    // We can create an OLE object.

    // See whether we have to create a package

    if (cfFormat == g_cfFileName || cfFormat == g_cfFileNameW)
    {
        hresult = wCreatePackageEx(lpSrcDataObj, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, FALSE /*fLink*/, lplpObj);
    }
    else
    {
        hresult =  wCreateFromDataEx(lpSrcDataObj, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, lplpObj);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateFromDataEx ( %lx ) [ %p ]\n",
        0, hresult, *lplpObj));

safeRtn:

    OLETRACEOUT((API_OleCreateFromDataEx, hresult));

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkFromData
//
//  Synopsis:   Creates a link from a data object (e.g. for Paste->Link)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface ID
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- format to render (if renderopt ==
//                                 OLERENDER_FORMAT)
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLinkFromData)
STDAPI  OleCreateLinkFromData
(
  IDataObject FAR*            lpSrcDataObj,
  REFIID                      iid,
  DWORD                       renderopt,
  LPFORMATETC                 lpFormatEtc,
  IOleClientSite FAR*          lpClientSite,
  IStorage FAR*                lpStg,
  void FAR* FAR*               lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateLinkFromDataEx(lpSrcDataObj, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkFromDataEx
//
//  Synopsis:   Creates a link from a data object (e.g. for Paste->Link)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLinkFromDataEx)
STDAPI  OleCreateLinkFromDataEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateLinkFromDataEx,
        PARAMFMT("lpSrcDataObj= %p, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpSrcDataObj, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    HRESULT         error;
    FORMATETC       formatEtc;
    LPFORMATETC     lpFormatEtc = NULL;
    BOOL            fAlloced = FALSE;
    CLIPFORMAT      cfFormat;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateLinkFromDataEx ( %p , %p , %lx,"
        " %lx, %lx , %p , %p , %p, %p , %p , %p, %p )\n", NULL, lpSrcDataObj,
        &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, error );
    *lplpObj = NULL;

    VDATEIFACE_LABEL( lpSrcDataObj, errRtn, error );
    VDATEIID_LABEL( iid, errRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    cfFormat = wQueryLinkFormats(lpSrcDataObj);

    if (cfFormat == g_cfLinkSource) {
        CLSID                   clsidLast;
        LPMONIKER               lpmkSrc;
        LPDATAOBJECT    lpBoundDataObj = NULL;

        // we are going to create a normal link
        if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
            &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
        {
            goto errRtn;
        }

        if ((error = wGetMonikerAndClassFromObject(lpSrcDataObj,
            &lpmkSrc, &clsidLast)) != NOERROR)
        {
            goto errRtn;
        }

        if (wQueryUseCustomLink(clsidLast)) {
            // the object supports Custom Link Source, so bind
            // to the object and pass its IDataObject pointer
            // to wCreateLinkEx()

            if (BindMoniker(lpmkSrc, NULL /*grfOpt*/, IID_IDataObject,
                (LPLPVOID) &lpBoundDataObj) == NOERROR)
            {
                lpSrcDataObj = lpBoundDataObj;
            }
        }

        // otherwise continue to use StdOleLink implementation
        error = wCreateLinkEx(lpmkSrc, clsidLast, lpSrcDataObj, iid,
            dwFlags, renderopt, cFormats, rgAdvf, lpFormatEtc, lpAdviseSink,
            rgdwConnection, lpClientSite, lpStg, lplpObj);

        // we don't need the moniker anymore
        lpmkSrc->Release();

        // we would have bound in the custom link source case,
        // release the pointer
        if (lpBoundDataObj)
        {
            if (error == NOERROR && (dwFlags & OLECREATE_LEAVERUNNING))
                OleRun((LPUNKNOWN)*lplpObj);

            lpBoundDataObj->Release();
        }

    } else if (cfFormat == g_cfFileName || cfFormat == g_cfFileNameW) {
        // See whether we have to create a packaged link

        error = wCreatePackageEx(lpSrcDataObj, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, TRUE /*fLink*/, lplpObj);
    }
    else
    {
        error = DV_E_FORMATETC;
    }

errRtn:

    if (fAlloced)
        PubMemFree(lpFormatEtc);

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateLinkFromDataEx ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:

    OLETRACEOUT((API_OleCreateLinkFromDataEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLink
//
//  Synopsis:   Create a link to the object referred to by a moniker
//
//  Effects:
//
//  Arguments:  [lpmkSrc]       -- source of the link
//              [iid]           -- interface requested
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- rendering format (if needed)
//              [lpClientSite]  -- pointer to the client site for the link
//              [lpStg]         -- storage for the link
//              [lplpObj]       -- where to put the link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLink)
STDAPI  OleCreateLink
(
    IMoniker FAR*           lpmkSrc,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateLinkEx(lpmkSrc, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkEx
//
//  Synopsis:   Create a link to the object referred to by a moniker
//
//  Effects:
//
//  Arguments:  [lpmkSrc]       -- source of the link
//              [iid]           -- interface requested
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site for the link
//              [lpStg]         -- storage for the link
//              [lplpObj]       -- where to put the link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLinkEx)
STDAPI  OleCreateLinkEx
(
    IMoniker FAR*           lpmkSrc,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateLinkEx,
        PARAMFMT("lpmkSrc= %p, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpmkSrc, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    FORMATETC       formatEtc;
    LPFORMATETC     lpFormatEtc;
    BOOL            fAlloced = FALSE;
    HRESULT         error;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateLinkEx ( %p , %p , %lx, %lx,"
        " %lx , %p , %p , %p, %p , %p , %p , %p )\n", NULL, lpmkSrc, &iid,
        dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, errRtn, error );
    *lplpObj = NULL;

    VDATEIFACE_LABEL( lpmkSrc, errRtn, error);
    VDATEIID_LABEL( iid, errRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
        &formatEtc, &lpFormatEtc, &fAlloced)) == NOERROR)
    {
        error = wCreateLinkEx(lpmkSrc, CLSID_NULL, NULL /* lpSrcDataObj */,
            iid, dwFlags, renderopt, cFormats, rgAdvf, lpFormatEtc,
            lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);

        if (fAlloced)
            PubMemFree(lpFormatEtc);
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateLinkEx ( %lx ) [ %p ]\n", NULL,
        error, *lplpObj));

errRtn:
    OLETRACEOUT((API_OleCreateLinkEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkToFile
//
//  Synopsis:   Creates a link object to the file specified in [lpszFileName]
//
//  Effects:
//
//  Arguments:  [lpszFileName]  --  the name of the file
//              [iid]           --  interface ID requested
//              [renderopt]     --  rendering options
//              [lpFormatEtc]   --  format in which to render (if [renderopt]
//                                  == OLERENDER_FORMAT);
//              [lpClientSite]  --  pointer to the client site for the link
//              [lpStg]         --  pointer to the storage for the object
//              [lplpObj]       --  where to put a pointer to new link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port, fixed memory leak in error
//                                      case
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateLinkToFile)
STDAPI  OleCreateLinkToFile
(
    LPCOLESTR                       lpszFileName,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateLinkToFileEx(lpszFileName, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}



//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkToFileEx
//
//  Synopsis:   Creates a link object to the file specified in [lpszFileName]
//
//  Effects:
//
//  Arguments:  [lpszFileName]  --  the name of the file
//              [iid]           --  interface ID requested
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  --  pointer to the client site for the link
//              [lpStg]         --  pointer to the storage for the object
//              [lplpObj]       --  where to put a pointer to new link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port, fixed memory leak in error
//                                      case
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateLinkToFileEx)
STDAPI  OleCreateLinkToFileEx
(
    LPCOLESTR               lpszFileName,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateLinkToFileEx,
        PARAMFMT("lpszFileName= %ws, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpszFileName, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    LPMONIKER       lpmkFile = NULL;
    LPDATAOBJECT    lpDataObject = NULL;
    HRESULT         error;
    BOOL            fPackagerMoniker = FALSE;
    CLSID           clsidFile;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateLinkToFileEx ( \"%s\" , %p , %lx ,"
        " %lx , %lx , %p , %p , %p, %p , %p , %p , %p )\n", NULL, lpszFileName,
        &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, error );
    *lplpObj = NULL;

    VDATEPTRIN_LABEL( (LPVOID)lpszFileName, OLECHAR, logRtn, error );
    VDATEIID_LABEL( iid, logRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto logRtn;

    if (((error = wGetMonikerAndClassFromFile(lpszFileName,
        TRUE /*fLink*/, &lpmkFile, &fPackagerMoniker, &clsidFile,&lpDataObject))
        != NOERROR))
    {
        goto logRtn;
    }

    Verify(lpmkFile);

   if (fPackagerMoniker) {
        // wValidateFormatEtc() will be done in wCreateFromFile()

        Assert(NULL == lpDataObject); // Shouldn't be a BoundDataObject for Packager.

        error =  wCreateFromFileEx(lpmkFile,lpDataObject, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, lplpObj);

    } else {
        FORMATETC       formatEtc;
        LPFORMATETC     lpFormatEtc;
        BOOL            fAlloced = FALSE;

        if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
            &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
        {
            goto ErrRtn;
        }

        error = wCreateLinkEx(lpmkFile, clsidFile, lpDataObject,
            iid, dwFlags, renderopt, cFormats, rgAdvf, lpFormatEtc,
            lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);

        if (fAlloced)
            PubMemFree(lpFormatEtc);
    }

ErrRtn:

    if (lpmkFile)
    {
        lpmkFile->Release();
    }

    // if the moniker was bound in CreateFromFile, release it now.
    if (lpDataObject)
    {
        lpDataObject->Release();
    }

    if (error == NOERROR && !lpAdviseSink) {
        wStuffIconOfFileEx(lpszFileName, TRUE /*fAddLabel*/,
            renderopt, cFormats, rgFormatEtc, (LPUNKNOWN) *lplpObj);
    }

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateLinkToFileEx ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:
    OLETRACEOUT((API_OleCreateLinkToFileEx, error));

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromFile
//
//  Synopsis:   Creates an ole object for embedding from a file (for
//              InstertObject->From File type things)
//
//  Effects:
//
//  Arguments:  [rclsid]        -- CLSID to use for creating the object
//              [lpszFileName]  -- the filename
//              [iid]           -- the requested interface ID
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- rendering format (if needed)
//              [lpClientSite]  -- pointer to the object's client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromFile)
STDAPI  OleCreateFromFile
(
    REFCLSID                rclsid,
    LPCOLESTR                       lpszFileName,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateFromFileEx(rclsid, lpszFileName, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromFileEx
//
//  Synopsis:   Creates an ole object for embedding from a file (for
//              InstertObject->From File type things)
//
//  Effects:
//
//  Arguments:  [rclsid]        -- CLSID to use for creating the object
//              [lpszFileName]  -- the filename
//              [iid]           -- the requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the object's client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromFileEx)
STDAPI  OleCreateFromFileEx
(
    REFCLSID                rclsid,
    LPCOLESTR               lpszFileName,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateFromFileEx,
        PARAMFMT("rclsid= %I, lpszFileName= %ws, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        &rclsid, lpszFileName, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    LPMONIKER               lpmkFile = NULL;
    LPDATAOBJECT            lpDataObject = NULL;
    HRESULT                 error;
    CLSID                   clsid;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateFromFileEx ( %p , \"%s\" , %p ,"
        " %lx , %lx , %lx , %p , %p , %p , %p , %p , %p , %p )\n", NULL,
        &rclsid, lpszFileName, &iid, dwFlags, renderopt, cFormats, rgAdvf,
        rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg,
        lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, error );
    *lplpObj = NULL;

    VDATEPTRIN_LABEL( (LPVOID)lpszFileName, char, errRtn, error );
    VDATEIID_LABEL( iid, errRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    if (((error = wGetMonikerAndClassFromFile(lpszFileName,
        FALSE /*fLink*/, &lpmkFile, NULL /*lpfPackagerMoniker*/,
        &clsid,&lpDataObject)) != NOERROR))
    {
        goto errRtn;
    }

    Verify(lpmkFile);

    // wValidateFormatEtc() will be done in wCreateFromFile()
    error = wCreateFromFileEx(lpmkFile,lpDataObject, iid, dwFlags, renderopt, cFormats,
        rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite,
        lpStg, lplpObj);

    if (lpDataObject)
    {
        lpDataObject->Release();
    }

    if (lpmkFile)
    {
        lpmkFile->Release();
    }


    if (error == NOERROR && !lpAdviseSink) {
        wStuffIconOfFileEx(lpszFileName, FALSE /*fAddLabel*/,
            renderopt, cFormats, rgFormatEtc, (LPUNKNOWN) *lplpObj);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateFromFileEx ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:

    OLETRACEOUT((API_OleCreateFromFileEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleDoAutoConvert
//
//  Synopsis:   Converts the storage to use the clsid given in
//              [pClsidNew].  Private ole streams are updated with the new
//              info
//
//  Effects:
//
//  Arguments:  [pStg]          -- storage to modify
//              [pClsidNew]     -- pointer to the new class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  this function should be rewritten to use
//              the new internal API for writing to ole-private streams
//
//--------------------------------------------------------------------------

#pragma SEG(OleDoAutoConvert)
STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
{
    OLETRACEIN((API_OleDoAutoConvert, PARAMFMT("pStg= %p, pClsidNew= %I"),
        pStg, pClsidNew));

    VDATEHEAP();

    HRESULT error;
    CLSID clsidOld;
    CLIPFORMAT cfOld;
    LPOLESTR lpszOld = NULL;
    LPOLESTR lpszNew = NULL;

    if ((error = ReadClassStg(pStg, &clsidOld)) != NOERROR) {
        clsidOld = CLSID_NULL;
        goto errRtn;
    }

    if ((error = OleGetAutoConvert(clsidOld, pClsidNew)) != NOERROR)
        goto errRtn;

    // read old fmt/old user type; sets out params to NULL on error
    error = ReadFmtUserTypeStg(pStg, &cfOld, &lpszOld);
    Assert(error == NOERROR || (cfOld == NULL && lpszOld == NULL));

    // get new user type name; if error, set to NULL string
    if ((error = OleRegGetUserType(*pClsidNew, USERCLASSTYPE_FULL,
        &lpszNew)) != NOERROR)
        lpszNew = NULL;

    // write class stg
    if ((error = WriteClassStg(pStg, *pClsidNew)) != NOERROR)
        goto errRtn;

    // write old fmt/new user type;
    if ((error = WriteFmtUserTypeStg(pStg, cfOld, lpszNew)) != NOERROR)
        goto errRewriteInfo;

    // set convert bit
    if ((error = SetConvertStg(pStg, TRUE)) != NOERROR)
        goto errRewriteInfo;

    goto okRtn;

errRewriteInfo:
    (void)WriteClassStg(pStg, clsidOld);
    (void)WriteFmtUserTypeStg(pStg, cfOld, lpszOld);

errRtn:
    *pClsidNew = clsidOld;

okRtn:
    PubMemFree(lpszOld);
    PubMemFree(lpszNew);

    OLETRACEOUT((API_OleDoAutoConvert, error));
    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleLoad
//
//  Synopsis:   Loads an object from the given storage
//
//  Effects:
//
//  Arguments:  [lpStg]         -- the storage to load from
//              [iid]           -- the requested interface ID
//              [lpClientSite]  -- client site for the object
//              [lplpObj]       -- where to put the pointer to the
//                                 new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleLoad)
STDAPI  OleLoad
(
    IStorage FAR*           lpStg,
    REFIID                  iid,
    IOleClientSite FAR*     lpClientSite,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleLoad, PARAMFMT("lpStg= %p, iid= %I, lpClientSite= %p, lplpObj= %p"),
        lpStg, &iid, lpClientSite, lplpObj));

    VDATEHEAP();

    HRESULT error;

    LEDebugOut((DEB_TRACE, "%p _IN OleLoad ( %p , %p , %p , %p )\n",
        NULL, lpStg, &iid, lpClientSite, lplpObj));

    if ((error = OleLoadWithoutBinding(lpStg, FALSE, iid, lpClientSite, lplpObj))
        == NOERROR) {
        // The caller specify that he want a disconnected object by
        // passing NULL for pClientSite
        if (lpClientSite != NULL)
            wBindIfRunning((LPUNKNOWN) *lplpObj);
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleLoad ( %lx ) [ %p ]\n", NULL, error,
        (error == NOERROR ? *lplpObj : NULL)));

    OLETRACEOUT((API_OleLoad, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleLoadWithoutBinding
//
//  Synopsis:   Internal function to load/create an object from a storage
//              called by OleLoad, etc.
//
//  Effects:
//
//  Arguments:  [lpStg]         -- storage to load from
//              [iid]           -- requested interface ID
//              [lpClientSite]  -- pointer to the client site
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  this function is only used in a few, known
//              places.  we can maybe get rid of the VDATEPTR's.
//
//--------------------------------------------------------------------------


INTERNAL  OleLoadWithoutBinding
(
    IStorage FAR*           lpStg,
    BOOL                    fPermitCodeDownload,    //new parameter to control whether code download occurs or not      -RahulTh (11/20/97)
    REFIID                  iid,
    IOleClientSite FAR*     lpClientSite,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    HRESULT error;
    CLSID   clsid;

    VDATEPTROUT( lplpObj, LPVOID );
    *lplpObj = NULL;
    VDATEIID( iid );
    VDATEIFACE( lpStg );

    if (lpClientSite)
        VDATEIFACE( lpClientSite );

    error = OleDoAutoConvert(lpStg, &clsid);

    // error only used when clsid could not be read (when CLSID_NULL)
    if (IsEqualCLSID(clsid, CLSID_NULL))
        return error;

    return wCreateObject (clsid, fPermitCodeDownload, iid, lpClientSite, lpStg, STG_LOAD,
        lplpObj);
}




//+-------------------------------------------------------------------------
//
//  Function:   OleCreateStaticFromData
//
//  Synopsis:   Creates a static ole object from the data in [lpSrcDataObject]
//              If [lpFormatEtcIn] is NULL, then the best possible
//              presentation is extracted.
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface ID for the new object
//              [renderopt]     -- redering options
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              08-Jun-94 davepl    Added EMF support
//              28-Oct-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateStaticFromData)
STDAPI OleCreateStaticFromData(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtcIn,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateStaticFromData,
        PARAMFMT("lpSrcDataObj= %p, iid= %I, renderopt= %x, lpFormatEtcIn= %te, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpSrcDataObj, &iid, renderopt, lpFormatEtcIn, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    IOleObject FAR*         lpOleObj = NULL;
    IOleCache FAR*          lpOleCache = NULL;
    HRESULT                 error;
    FORMATETC               foretc;
    FORMATETC               foretcCache;
    STGMEDIUM               stgmed;
    CLSID                   clsid;
    BOOL                    fReleaseStgMed = TRUE;
    LPOLESTR                        lpszUserType = NULL;


    LEDebugOut((DEB_TRACE, "%p _IN OleCreateStaticFromData ( %p , %p , %lx ,"
        " %p , %p , %p , %p , %p )\n", NULL, lpSrcDataObj, &iid, renderopt,
        lpFormatEtcIn, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL(lplpObj, LPVOID, safeRtn, error);
    *lplpObj = NULL;
    VDATEIFACE_LABEL( lpSrcDataObj, logRtn, error );
    VDATEIID_LABEL(iid, logRtn, error);

    //VDATEPTRIN rejects NULL
    if ( lpFormatEtcIn )
        VDATEPTRIN_LABEL( lpFormatEtcIn, FORMATETC, logRtn, error );
    VDATEIFACE_LABEL(lpStg, logRtn, error);
    if (lpClientSite)
        VDATEIFACE_LABEL(lpClientSite, logRtn, error);

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
    {
        error = E_INVALIDARG;
        goto logRtn;
    }

    if ((error = wValidateFormatEtc (renderopt, lpFormatEtcIn, &foretc))
            != NOERROR)
    {
        goto logRtn;
    }

    if (renderopt == OLERENDER_DRAW)
    {
        if (!UtQueryPictFormat(lpSrcDataObj, &foretc))
        {
            error = DV_E_CLIPFORMAT;
            goto logRtn;
        }
    }

    // Set the proper CLSID, or return error if that isn't possible

    if (foretc.cfFormat == CF_METAFILEPICT)
    {
        clsid = CLSID_StaticMetafile;
    }
    else if (foretc.cfFormat == CF_BITMAP ||  foretc.cfFormat == CF_DIB)
    {
        clsid = CLSID_StaticDib;
    }
    else if (foretc.cfFormat == CF_ENHMETAFILE)
    {
        clsid = CLSID_Picture_EnhMetafile;
    }
    else
    {
        error = DV_E_CLIPFORMAT;
        goto logRtn;
    }

    error = lpSrcDataObj->GetData(&foretc, &stgmed);
    if (NOERROR != error)
    {
        // We should support the case where the caller wants one of
        // CF_BITMAP and CF_DIB, and the object supports the other
        // one those 2 formats. In this case we should do the proper
        // conversion. Finally the cache that is going to be created
        // would be a DIB cache.

        AssertOutStgmedium(error, &stgmed);

        if (foretc.cfFormat == CF_DIB)
        {
            foretc.cfFormat = CF_BITMAP;
            foretc.tymed = TYMED_GDI;
        }
        else if (foretc.cfFormat == CF_BITMAP)
        {
            foretc.cfFormat = CF_DIB;
            foretc.tymed = TYMED_HGLOBAL;
        }
        else
        {
            goto logRtn;
        }

        error = lpSrcDataObj->GetData(&foretc, &stgmed);
        if (NOERROR != error)
        {
            AssertOutStgmedium(error, &stgmed);
            goto logRtn;
        }
    }

    AssertOutStgmedium(error, &stgmed);

    foretcCache = foretc;
    foretcCache.dwAspect = foretc.dwAspect = DVASPECT_CONTENT;
    foretcCache.ptd = NULL;

    // Even when the caller asks for bitmap cache we create the DIB cache.

    BITMAP_TO_DIB(foretcCache);

    error = wCreateObject (clsid, FALSE,
                           IID_IOleObject, lpClientSite,
                           lpStg, STG_INITNEW, (LPLPVOID) &lpOleObj);

    if (NOERROR != error)
    {
        goto errRtn;
    }

    if (lpOleObj->QueryInterface(IID_IOleCache, (LPLPVOID) &lpOleCache)
            != NOERROR)
    {
        goto errRtn;
    }

    error = lpOleCache->Cache (&foretcCache, ADVF_PRIMEFIRST,
                        NULL /*pdwConnection*/);

    if (FAILED(error))
    {
        goto errRtn;
    }

    //REVIEW32: err, are we sure this is a good idea???
    //clearing out the error, that is

    error = NOERROR;

    // take ownership of the data
    foretc.ptd = NULL;
    if ((error = lpOleCache->SetData (&foretc, &stgmed,
            TRUE)) != NOERROR)
        goto errRtn;

    // Write format and user type
    error = lpOleObj->GetUserType(USERCLASSTYPE_FULL, &lpszUserType);
    AssertOutPtrParam(error, lpszUserType);
    WriteFmtUserTypeStg(lpStg, foretcCache.cfFormat, lpszUserType);
    if (lpszUserType)
        PubMemFree(lpszUserType);

    fReleaseStgMed = FALSE;

    error = lpOleObj->QueryInterface (iid, lplpObj);

errRtn:
    if (fReleaseStgMed)
        ReleaseStgMedium(&stgmed);

    if (lpOleCache)
        lpOleCache->Release();

    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    if (lpOleObj)
        lpOleObj->Release();

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateStaticFromData ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:
    OLETRACEOUT((API_OleCreateStaticFromData, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleQueryCreateFromData
//
//  Synopsis:   Finds out what we can create from a data object (if anything)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object of interest
//
//  Requires:
//
//  Returns:    NOERROR         -- an OLE object can be created
//              QUERY_CREATE_STATIC     -- a static object can be created
//              S_FALSE         -- nothing can be created
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleQueryCreateFromData)
STDAPI  OleQueryCreateFromData (LPDATAOBJECT lpSrcDataObj)
{
    OLETRACEIN((API_OleQueryCreateFromData, PARAMFMT("lpSrcDataObj= %p"), lpSrcDataObj));

    VDATEHEAP();
    VDATEIFACE( lpSrcDataObj );
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&lpSrcDataObj);

    CLIPFORMAT      cfFormat;
    WORD            wStatus = wQueryEmbedFormats(lpSrcDataObj, &cfFormat);
    HRESULT hr;

    if (wStatus & QUERY_CREATE_OLE)
        // OLE object can be created
        hr = NOERROR;
    else if (wStatus & QUERY_CREATE_STATIC)
        // static object can be created
        hr = ResultFromScode(OLE_S_STATIC);
    else    // no object can be created
        hr = ResultFromScode(S_FALSE);

    OLETRACEOUT((API_OleQueryCreateFromData, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wQueryEmbedFormats
//
//  Synopsis:   Enumerates the formats of the object and looks for
//              ones that let us create either an embeded or static object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]          -- pointer to the data object
//              [lpcfFormat]            -- place to put the clipboard format
//                                         of the object
//  Returns:    WORD -- bit flag of QUERY_CREATE_NONE, QUERY_CREATE_STATIC
//                      and QUERY_CREATE_OLE
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//              08-Jun-94 davepl    Optimized by unwinding while() loop
//              22-Aug-94 alexgo    added MFC hack
//
//--------------------------------------------------------------------------

static const unsigned int MAX_ENUM_STEP = 20;

INTERNAL_(WORD) wQueryEmbedFormats
(
    LPDATAOBJECT    lpSrcDataObj,
    CLIPFORMAT FAR* lpcfFormat
)
{
    VDATEHEAP();

    // This adjusts the number of formats requested per enumeration
    // step.  If we are running in the WOW box, we should only ask
    // for one at a time since it is unknown how well old code will
    // support bulk enumerations.

    ULONG ulEnumSize = IsWOWThread() ? 1 : MAX_ENUM_STEP;

    FORMATETC               fetcarray[MAX_ENUM_STEP];
    IEnumFORMATETC FAR*     penm;
    ULONG                   ulNumFetched;
    HRESULT                 error;
    WORD                    wStatus = QUERY_CREATE_NONE;
                    // no object can be created
    BOOL                    fDone   = FALSE;

    *lpcfFormat = NULL;

    // Grab the enumerator.  If this fails, just return
    // QUERY_CREATE_NONE

    error = wGetEnumFormatEtc(lpSrcDataObj, DATADIR_GET, &penm);
    if (error != NOERROR)
    {
        return QUERY_CREATE_NONE;
    }

    // Enumerate over the formats available in chunks for ulEnumSize.  For
    // each format we were able to grab, check to see if the clipformat
    // indicates that we have a creation candidate (static or otherwise),
    // and set bits in the bitmask as appropriate

    while (!fDone && (SUCCEEDED(penm->Next(ulEnumSize, fetcarray, &ulNumFetched))))
    {
      // We will normally get at least one, unless there are 0,
      // ulEnumSize, 2*ulEnumSize, and so on...

      if (ulNumFetched == 0)
        break;

      for (ULONG c=0; c<ulNumFetched; c++)
      {
        // We care not about the target device

        if (NULL != fetcarray[c].ptd)
        {
          PubMemFree(fetcarray[c].ptd);
        }

        CLIPFORMAT cf = fetcarray[c].cfFormat;

          // In these cases it is an internal
          // format which is a candidate for
          // OLE creation directly.

        if (cf == g_cfEmbedSource       ||
          cf == g_cfEmbeddedObject    ||
          cf == g_cfFileName          ||
          cf == g_cfFileNameW)
        {
          wStatus |= QUERY_CREATE_OLE;
          *lpcfFormat = cf;
          fDone = TRUE;
          break;
        }
          // These formats indicate it is a
          // candidate for static creation.

        else if (cf == CF_METAFILEPICT  ||
            cf == CF_DIB           ||
            cf == CF_BITMAP        ||
            cf == CF_ENHMETAFILE)
        {
          wStatus = QUERY_CREATE_STATIC;
          *lpcfFormat = cf;

        }
      } // end for

      if (fDone)
      {
        // Starting at the _next_ formatetc, free up
        // any remaining target devices among the
        // fetcs we got in the enumeration step.

        for (++c; c<ulNumFetched; c++)
        {
          if(fetcarray[c].ptd)
          {
            PubMemFree(fetcarray[c].ptd);
          }
        }
      }

    } // end while



    if (!(wStatus & QUERY_CREATE_OLE))
    {
        // MFC HACK ALERT!!  MFC3.0 used to re-implement
        // OleQueryCreateFromData themselves because they did not
        // want to make the QI RPC below.  Since they do a great
        // many of these calls, making the RPC can be expensive
        // and destabilising for them (as this hack is being put
        // in just weeks before final release of Windows NT 3.5).
        //
        // Note that this changes the behaviour of clipboard from
        // 16bit.  You will no longer know that you can paste objects
        // that only support IPersistStorage but offer no data in
        // in their IDataOjbect implementation.

        CClipDataObject ClipDataObject; // just allocate one of these
                        // on the stack.  We won't
                        // do any real work with
                        // this except look at the
                        // vtable.
        IPersistStorage FAR* lpPS;


        // MFC HACK (continued):  If we are working with a clipboard
        // data object, then we do not want to make the QI call
        // below.  We determine if the given data object is a
        // clipboard data object by comparing vtable addresses.

        // REVIEW:  this will potentially break if we make all objects
        // use the same IUnknown implementation

        if( (*(DWORD *)lpSrcDataObj) !=
            (*(DWORD *)((IDataObject *)&ClipDataObject)) )
        {

            if (lpSrcDataObj->QueryInterface(IID_IPersistStorage,
                (LPLPVOID)&lpPS) == NOERROR)
            {
                lpPS->Release();
                wStatus |= QUERY_CREATE_OLE;
                    // OLE object can be created
            }
        }
    }

    penm->Release();
    return wStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleQueryLinkFromData
//
//  Synopsis:   Calls wQueryLinkFormats to determine if a link could be
//              created from this data object.
//
//  Arguments:  [lpSrcDataObj]  -- the data object
//
//  Returns:    NOERROR, if a link can be created, S_FALSE otherwise
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

STDAPI  OleQueryLinkFromData (LPDATAOBJECT lpSrcDataObj)
{
    OLETRACEIN((API_OleQueryLinkFromData, PARAMFMT("lpSrcDataObj= %p"),
                                                                                        lpSrcDataObj));

    VDATEHEAP();
        VDATEIFACE( lpSrcDataObj );
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&lpSrcDataObj);

    HRESULT hr = NOERROR;

    if(wQueryLinkFormats(lpSrcDataObj) == NULL)
    {
        hr = ResultFromScode(S_FALSE);
    }

    OLETRACEOUT((API_OleQueryLinkFromData, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wQueryLinkFormats
//
//  Synopsis:   Enumerates the formats of a data object to see if
//              a link object could be created from one of them
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//
//  Returns:    CLIPFORMAT of the data in the object that would enable
//              link object creation.
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//              14-Jun-94 davepl    Added bulk enumeration for non-Wow runs
//
//--------------------------------------------------------------------------


INTERNAL_(CLIPFORMAT) wQueryLinkFormats(LPDATAOBJECT lpSrcDataObj)
{
    VDATEHEAP();

    // This adjusts the number of formats requested per enumeration
    // step.  If we are running in the WOW box, we should only ask
    // for one at a time since it is unknown how well old code will
    // support bulk enumerations.

    ULONG ulEnumSize = IsWOWThread() ? 1 : MAX_ENUM_STEP;

    FORMATETC               fetcarray[MAX_ENUM_STEP];
    IEnumFORMATETC FAR*     penm;
    ULONG                   ulNumFetched;
    HRESULT                 error;
    BOOL                    fDone    = FALSE;
    CLIPFORMAT              cf       = 0;


    // Grab the enumerator.  If this fails, just return
    // QUERY_CREATE_NONE

    error = wGetEnumFormatEtc(lpSrcDataObj, DATADIR_GET, &penm);
    if (error != NOERROR)
    {
        return (CLIPFORMAT) 0;
    }

    // Enumerate over the formats available in chunks for ulEnumSize.  For
    // each format we were able to grab, check to see if the clipformat
    // indicates that we have a creation candidate (static or otherwise),
    // and set bits in the bitmask as appropriate

    while (!fDone && (SUCCEEDED(penm->Next(ulEnumSize, fetcarray, &ulNumFetched))))
    {
      // We will normally get at least one, unless there are 0,
      // ulEnumSize, 2*ulEnumSize, and so on...

      if (ulNumFetched == 0)
        break;

      for (ULONG c=0; c<ulNumFetched; c++)
      {
        // We care not about the target device

        if (NULL != fetcarray[c].ptd)
        {
          PubMemFree(fetcarray[c].ptd);
        }

        CLIPFORMAT cfTemp = fetcarray[c].cfFormat;

          // In these cases it is an internal
          // format which is a candidate for
          // OLE creation directly.

        if (cfTemp == g_cfLinkSource       ||
          cfTemp == g_cfFileName         ||
          cfTemp == g_cfFileNameW)
        {
          cf = cfTemp;
          fDone = TRUE;
          break;
        }

      } // end for

      if (fDone)
      {
        // Starting at the _next_ formatetc, free up
        // any remaining target devices among the
        // fetcs we got in the enumeration step.

        for (++c; c<ulNumFetched; c++)
        {
          if(fetcarray[c].ptd)
          {
            PubMemFree(fetcarray[c].ptd);
          }
        }
      }  // end if

    } // end while


    penm->Release();
    return cf;
}


//+-------------------------------------------------------------------------
//
//  Function:   wClearRelativeMoniker
//
//  Synopsis:   Replaces an old relative moniker with the absolute moniker
//              Internal function
//
//  Effects:
//
//  Arguments:  [pInitObj]      -- the original object
//              [pNewObj]       -- the object to which to set the new
//                                 absolute moniker
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wClearRelativeMoniker)
INTERNAL_(void) wClearRelativeMoniker
    (LPUNKNOWN      pInitObj,
    LPUNKNOWN       pNewObj)
{
    VDATEHEAP();

    LPOLELINK       pOleLink = NULL;
    LPMONIKER       pmkAbsolute = NULL;
    CLSID           clsidLink = CLSID_NULL;
    LPOLEOBJECT     pOleObj=NULL;

    if (NOERROR==pInitObj->QueryInterface (IID_IOleLink,
                                                (LPLPVOID) &pOleLink))
    {
        // Get absolute moniker ...
        pOleLink->GetSourceMoniker (&pmkAbsolute);
        Assert(pmkAbsolute == NULL || IsValidInterface(pmkAbsolute));
        if (NOERROR==pInitObj->QueryInterface (IID_IOleObject,
                                                    (LPLPVOID) &pOleObj))
        {
            // .. and its class
            pOleObj->GetUserClassID (&clsidLink);
            pOleObj->Release();
            pOleObj = NULL;
        }
        pOleLink->Release();
        pOleLink = NULL;
    }
    if (pmkAbsolute &&
        NOERROR==pNewObj->QueryInterface (IID_IOleLink,
        (LPLPVOID) &pOleLink))
    {
        // Restore the absolute moniker.  This will effectively
        // overwrite the old relative moniker.
        // This is important because when copying and pasting a link
        // object between documents, the relative moniker is never
        // correct.  Sometimes, though, it might happen to bind
        // to a different object, which is confusing to say the least.
        pOleLink->SetSourceMoniker (pmkAbsolute, clsidLink);
    }
    if (pOleLink)
        pOleLink->Release();
    if (pOleObj)
        pOleObj->Release();
    if (pmkAbsolute)
        pmkAbsolute->Release();
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreateFromDataEx
//
//  Synopsis:   This function does the real work of creating from data.
//              Basically, the data is GetData'ed from the data object,
//              copied into a storage, and then loaded
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:   HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wCreateFromDataEx)
INTERNAL wCreateFromDataEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    #define OLE_TEMP_STG    "\1OleTempStg"

    HRESULT                 error = NOERROR;
    IPersistStorage FAR*    lpPS = NULL;
    FORMATETC               formatEtc;
    LPFORMATETC             lpFormatEtc;
    BOOL                    fAlloced = FALSE;
    FORMATETC               foretcTmp;
    STGMEDIUM               medTmp;

    if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
        &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
    {
        return error;
    }

    *lplpObj = NULL;

    INIT_FORETC(foretcTmp);
    medTmp.pUnkForRelease = NULL;


    // try to get "EmbeddedObject" data

    LPSTORAGE       lpstgSrc = NULL;

    foretcTmp.cfFormat      = g_cfEmbeddedObject;
    foretcTmp.tymed         = TYMED_ISTORAGE;

    if (lpSrcDataObj->QueryGetData(&foretcTmp) != NOERROR)
        goto Next;

    if ((error = StgCreateDocfile (NULL,
            STGM_SALL|STGM_CREATE|STGM_DELETEONRELEASE,
            NULL, &lpstgSrc)) != NOERROR)
        goto errRtn;

    medTmp.tymed = TYMED_ISTORAGE;
    medTmp.pstg = lpstgSrc;

    if ((error = lpSrcDataObj->GetDataHere(&foretcTmp, &medTmp))
        == NOERROR)
    {
        // lpSrcDataObj passed to this api is a wrapper object
        // (which offers g_cfEmbeddedObject) for the original
        // embedded object. Now we got the original embedded object
        // data into medTmp.pstg.

        // copy the source data into lpStg.
        if ((error = lpstgSrc->CopyTo (0, NULL, NULL, lpStg))
            != NOERROR)
            goto errEmbeddedObject;

        // By doing the following we will be getting a data object
        // pointer to original embedded object, which we can use to
        // initialize the cache of the object that we are going to
        // create. We can not use the lpSrcDataObj passed to this api,
        // 'cause the presentation data that it may give through the
        // GetData call may be the one that it generated for the
        // object. (ex: the container can create an object with
        // olerender_none an then draw it's own representaion
        // (icon, etc) for the object.

        LPDATAOBJECT lpInitDataObj = NULL;

        // We pass a NULL client site so we know wClearRelativeMoniker
        // will be able to get the absolute moniker, not the relative.
        if ((error = OleLoadWithoutBinding (lpstgSrc, FALSE,
                                            IID_IDataObject,
                                            /*lpClientSite*/NULL, (LPLPVOID) &lpInitDataObj))
            != NOERROR)
            goto errEmbeddedObject;

        if (renderopt != OLERENDER_ASIS )
            UtDoStreamOperation(lpStg,              /* pstgSrc */
                NULL,                           /* pstgDst */
                OPCODE_REMOVE,  /* operation to performed */
                STREAMTYPE_CACHE);
                    /* stream to be operated upon */

        error = wLoadAndInitObjectEx(lpInitDataObj, iid, renderopt,
                cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
                lpClientSite, lpStg, lplpObj);

        if (NOERROR==error)
            wClearRelativeMoniker (lpInitDataObj,
                (LPUNKNOWN)*lplpObj);

        if (lpInitDataObj)
            lpInitDataObj->Release();

        // HACK ALERT!!  If wLoadAndInitObject failed, it may have been
        // because the little trick above with OleLoadWithoutBinding doesn't
        // work with all objects.  Some OLE1 objects (Clipart Gallery in
        // particular) don't like offer presentions without being edited.
        //
        // So if there was an error, we'll just try again with the *real*
        // data object passed into us.  Needless to say, it would be much
        // nicer to do this in the first place, but that breaks the old
        // behavior.

        if( error != NOERROR )
        {
            error = wLoadAndInitObjectEx( lpSrcDataObj, iid, renderopt,
                    cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
                    lpClientSite, lpStg, lplpObj);
        }

    }

errEmbeddedObject:
    if (lpstgSrc)
        lpstgSrc->Release();

    goto errRtn;

Next:

    // try to get "EmbedSource" data

    foretcTmp.cfFormat      = g_cfEmbedSource;
    foretcTmp.tymed         = TYMED_ISTORAGE;

    medTmp.tymed = TYMED_ISTORAGE;
    medTmp.pstg = lpStg;

    if ((error = lpSrcDataObj->GetDataHere(&foretcTmp, &medTmp))
        == NOERROR)
    {
        error = wLoadAndInitObjectEx(lpSrcDataObj, iid, renderopt,
                cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
                lpClientSite, lpStg, lplpObj);
        goto errRtn;
    }

    // If we have come here, and if the object doesn't support
    // IPersistStorage, then we will fail.

    if ((error = wSaveObjectWithoutCommit(lpSrcDataObj, lpStg, FALSE))
            != NOERROR)
        goto errRtn;;

    if (renderopt != OLERENDER_ASIS )
        UtDoStreamOperation(lpStg,      /* pstgSrc */
                    NULL,   /* pstgDst */
                    OPCODE_REMOVE,
                    /* operation to performed */
                    STREAMTYPE_CACHE);
                    /* stream to be operated upon */

    error = wLoadAndInitObjectEx(lpSrcDataObj, iid, renderopt,
            cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, lplpObj);

errRtn:
    if (fAlloced)
        PubMemFree(lpFormatEtc);

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreateLinkEx
//
//  Synopsis:   Creates a link by binding the moniker (if necessary),
//              doing a GetData into a storage, and then loading the
//              object from the storage.
//
//  Effects:
//
//  Arguments:  [lpmkSrc]       -- moniker to the link source
//              [rclsid]        -- clsid of the link source
//              [lpSrcDataObj]  -- pointer to the source data object
//                                 (may be NULL)
//              [iid]           -- requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- storage for the link object
//              [lplpObj]       -- where to put the pointer to the new
//                                 link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wCreateLinkEx)
INTERNAL wCreateLinkEx
(
    IMoniker FAR*           lpmkSrc,
    REFCLSID                rclsid,
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    IPersistStorage FAR *   lpPS = NULL;
    IOleLink FAR*           lpLink = NULL;
    IDataObject FAR*        lpBoundDataObj = NULL;
    HRESULT                 error;
    CLSID                   clsidLast = rclsid;
    BOOL                    fNeedsUpdate = FALSE;

    if (!lpSrcDataObj && ((renderopt != OLERENDER_NONE)
        || (IsEqualCLSID(rclsid,CLSID_NULL))
        || wQueryUseCustomLink(rclsid))) {

        // if renderopt is not OLERENDER_NONE, then we must have
        // a data obj pointer which will be used to initialize cache.

        // We also bind if we are not able to find from regdb whether
        // the class has custom link implementation or not

        if ((error = BindMoniker(lpmkSrc, NULL /* grfOpt */,
            IID_IDataObject, (LPLPVOID) &lpBoundDataObj))
            != NOERROR) {

            if (OLERENDER_NONE != renderopt)
                return ResultFromScode(
                    OLE_E_CANT_BINDTOSOURCE);


        // else we assume StdOleLink and continue with creation
        } else {
            lpSrcDataObj = lpBoundDataObj;

            if (IsEqualCLSID(clsidLast, CLSID_NULL))
                UtGetClassID((LPUNKNOWN)lpSrcDataObj,
                    &clsidLast);
        }
    }

    // Deal with CustomLinkSource
    // (see notes below)
    if (lpSrcDataObj) {
        STGMEDIUM       medTmp;
        FORMATETC       foretcTmp;

        INIT_FORETC(foretcTmp);
        foretcTmp.cfFormat = g_cfCustomLinkSource;
        foretcTmp.tymed = TYMED_ISTORAGE;

        if (lpSrcDataObj->QueryGetData(&foretcTmp) == NOERROR) {
            medTmp.tymed = TYMED_ISTORAGE;
            medTmp.pstg     = lpStg;
            medTmp.pUnkForRelease = NULL;

            if (error = lpSrcDataObj->GetDataHere(&foretcTmp,
                &medTmp))
                goto errRtn;

            error = wLoadAndInitObjectEx(lpSrcDataObj, iid,
                renderopt, cFormats, rgAdvf, rgFormatEtc,
                lpAdviseSink, rgdwConnection, lpClientSite,
                lpStg, lplpObj);

            // This is a really strange peice of logic,
            // spaghetti code at it's finest.  Basically,
            // this says that if there is *NOT* a
            // custom link source, then we want to do the
            // logic of wCreateObject, etc. below.  If we
            // got to this line in the code, then we
            // *did* have a custom link source, so
            // don't do the stuff below (thus the goto).

            // REVIEW32: If there are any bugs in here,
            // then rewrite this in a more sensible fashion.
            // I'm leaving as is for now due to time constraints.

            goto errRtn;
        }
    }

    // Otherwise
    if ((error = wCreateObject (CLSID_StdOleLink, FALSE,
                                iid, lpClientSite,
                                lpStg, STG_INITNEW, lplpObj)) != NOERROR)
        goto errRtn;

    if (lpSrcDataObj)
    {
        BOOL fCacheNodeCreated = FALSE;

        if ((error = wInitializeCacheEx(lpSrcDataObj, clsidLast,
            renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
            rgdwConnection, *lplpObj, &fCacheNodeCreated)) != NOERROR)
        {

            if (error != NOERROR && fCacheNodeCreated)
            {
                fNeedsUpdate = TRUE;
                error = NOERROR;
            }

        }
    }

errRtn:

    if (error == NOERROR && *lplpObj)
        error = ((LPUNKNOWN) *lplpObj)->QueryInterface(IID_IOleLink,
                            (LPLPVOID) &lpLink);

    if (error == NOERROR && lpLink && (dwFlags & OLECREATE_LEAVERUNNING)) {
        // This will connect to the object if it is already running.
        lpLink->SetSourceMoniker (lpmkSrc, clsidLast);
    }

    // We bound to the object to initialize the cache. We don't need
    // it anymore
    if (lpBoundDataObj)
    {
        if (error == NOERROR && (dwFlags & OLECREATE_LEAVERUNNING))
            OleRun((LPUNKNOWN)*lplpObj);

        // this will give a chance to the object to go away, if it can
        wDoLockUnlock(lpBoundDataObj);
        lpBoundDataObj->Release();
    }

    // If the source object started running as a result of BindMoniker,
    // then we would've got rid of it by now.

    if (error == NOERROR && lpLink)
    {
        if ( !(dwFlags & OLECREATE_LEAVERUNNING) ) {
            // This will connect to the object if it is already running.
            lpLink->SetSourceMoniker (lpmkSrc, clsidLast);
        }

        if (fNeedsUpdate) {
            // relevant cache data is not available from the
            // lpSrcDataObj. So do Update and get the right cache
            // data.
            error = wDoUpdate ((LPUNKNOWN) *lplpObj);

            if (GetScode(error) == CACHE_E_NOCACHE_UPDATED)
                error = ReportResult(0, DV_E_FORMATETC, 0, 0);
        }

        // Release on lpLink is necessary only if error == NOERROR
        lpLink->Release();

    }

    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCreateFromFileEx
//
//  Synopsis:   Creates an ole object from a file by binding the given
//              moniker and creating the object from the IDataObject pointer
//
//  Effects:
//
//  Arguments:  [lpmkFile]      -- moniker to the file
//              [iid]           -- requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage for the new object
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wCreateFromFileEx)
INTERNAL wCreateFromFileEx
(
    LPMONIKER               lpmkFile,
    LPDATAOBJECT            lpDataObject,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    LPOLECLIENTSITE         lpClientSite,
    LPSTORAGE               lpStg,
    LPLPVOID                lplpObj
)
{
    VDATEHEAP();

    HRESULT         error;
    LPDATAOBJECT    lpLocalDataObj;


    if (!lpDataObject)
    {
        if ((error = BindMoniker(lpmkFile, NULL, IID_IDataObject,
            (LPLPVOID) &lpLocalDataObj)) != NOERROR)
            return error;
    }
    else
    {
        lpLocalDataObj = lpDataObject;
    }

    Verify(lpLocalDataObj);

    error = wCreateFromDataEx(lpLocalDataObj, iid, dwFlags, renderopt, cFormats,
        rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite,
        lpStg, lplpObj);

    if (error == NOERROR && (dwFlags & OLECREATE_LEAVERUNNING))
        OleRun((LPUNKNOWN)*lplpObj);

    // If we bound locally release it now, else it is up to the caller to do the right thing.

    if (!lpDataObject)
    {
        wDoLockUnlock(lpLocalDataObj);
        lpLocalDataObj->Release();
    }

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   CoIsHashedOle1Class
//
//  Synopsis:   Determines whether or not a CLSID is an OLE1 class
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID in question
//
//  Requires:
//
//  Returns:    TRUE if ole1.0, FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  This is a strange function..consider nuking
//              it for 32bit, we may not need it (only used in 1 place)
//
//--------------------------------------------------------------------------


#pragma SEG(CoIsHashedOle1Class)
STDAPI_(BOOL) CoIsHashedOle1Class(REFCLSID rclsid)
{
    VDATEHEAP();

    CLSID clsid = rclsid;
    clsid.Data1 = 0L;
    WORD wHiWord = HIWORD(rclsid.Data1);
    return IsEqualGUID(clsid, IID_IUnknown) && wHiWord==4;
}



//+-------------------------------------------------------------------------
//
//  Function:   EnsureCLSIDIsRegistered
//
//  Synopsis:   Checks to see if the clsid is in the registration database,
//              if not, puts it there
//
//  Effects:
//
//  Arguments:  [clsid]         -- the clsid in question
//              [pstg]          -- storage to get more info about the
//                                 clsid if we need to register it
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(EnsureCLSIDIsRegistered)
void EnsureCLSIDIsRegistered
    (REFCLSID       clsid,
    LPSTORAGE       pstg)
{
    VDATEHEAP();

    LPOLESTR        szProgId = NULL;

    if (NOERROR == ProgIDFromCLSID (clsid, &szProgId))
    {
        PubMemFree(szProgId);
    }
    else
    {
        // This is the case of getting a hashed CLSID from a file from
        // another machine and the ProgId is not yet in the reg db,
        // so we must get it from the storage.
        // This code should rarely be executed.
        CLIPFORMAT      cf = 0;
        CLSID           clsidT;
        OLECHAR                 szProgId[256];

        if (ReadFmtUserTypeStg (pstg, &cf, NULL) != NOERROR)
            return;
        // Format is the ProgId
        if (0==GetClipboardFormatName (cf, szProgId, 256))
            return;
        // Will force registration of the CLSID if the ProgId (the OLE1
        // classname) is registered
        CLSIDFromProgID (szProgId, &clsidT);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreateObject
//
//  Synopsis:   Calls CoCreateInstance to create an object, a defhandler
//              is created if necessary and CLSID info is written to
//              the storage.
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class id of the object to create
//              [iid]           -- the requested interface ID
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- storage for the object
//              [wfStorage]     -- flags for the STORAGE, one of
//                                 STG_NONE, STD_INITNEW, STG_LOAD,
//                                 defined at the beginning of this file
//              [ppv]           -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-94 alexgo    fixed memory leak
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wCreateObject)
INTERNAL        wCreateObject
(
    CLSID                   clsid,
    BOOL                    fPermitCodeDownload,    //parameter added in order to control whether code download occurs or not  -RahulTh (11/20/97)
    REFIID                  iid,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR *          lpStg,
    WORD                    wfStorage,
    void FAR* FAR*          ppv
)
{
    VDATEHEAP();

    HRESULT         error;
    DWORD           dwClsCtx;
    IOleObject* pOleObject = NULL;
    DWORD dwMiscStatus = 0;
    DWORD dwAddClsCtx;

    dwAddClsCtx = fPermitCodeDownload?0:CLSCTX_NO_CODE_DOWNLOAD;
    *ppv = NULL;

    CLSID clsidNew;
    if (wfStorage == STG_INITNEW
        && SUCCEEDED(OleGetAutoConvert (clsid, &clsidNew)))
        // Insert an object of the new class
        clsid = clsidNew;


    if (wfStorage == STG_LOAD && CoIsHashedOle1Class (clsid))
        EnsureCLSIDIsRegistered (clsid, lpStg);


    if (IsWOWThread())
    {
        // CLSCTX needs to be turned on for possible 16 bit inproc server
        // such as OLE controls
        dwClsCtx = CLSCTX_INPROC | CLSCTX_INPROC_SERVER16 | dwAddClsCtx;
    }
    else
    {
        dwClsCtx = CLSCTX_INPROC | dwAddClsCtx;
    }

    if ((error = CoCreateInstance (clsid, NULL /*pUnkOuter*/,
            dwClsCtx, iid, ppv)) != NOERROR) {

        // if not OleLoad or error other than class not registered,
        // exit
        if (wfStorage != STG_LOAD || GetScode(error)
            != REGDB_E_CLASSNOTREG)
            goto errRtn;

        // OleLoad and class not registered: use default handler
        // directly
        if ((error = OleCreateDefaultHandler(clsid, NULL, iid, ppv))
                != NOERROR)
            goto errRtn;
    }

    AssertSz(*ppv, "HRESULT is OK, but pointer is NULL");

    // Check if we have client site
    if(lpClientSite) {
        // QI for IOleObject on the server
        error = ((IUnknown *)*ppv)->QueryInterface(IID_IOleObject, (void **)&pOleObject);
        if(error == NOERROR) {
            // Get the MiscStatus bits
            error = pOleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

            // Set the client site first if OLEMISC_SETCLIENTSITEFIRST bit is set
            if(error == NOERROR && (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)) {
                error = pOleObject->SetClientSite(lpClientSite);
                if(error != NOERROR) {
                    pOleObject->Release();
                    goto errRtn;
                }
            }
            else if(error != NOERROR) {
                error = NOERROR;
                dwMiscStatus = 0;
            }
        }
        else
            goto errRtn;
    }

    if (wfStorage != STG_NONE)
    {
        IPersistStorage FAR* lpPS;

        if ((error = ((LPUNKNOWN) *ppv)->QueryInterface(
            IID_IPersistStorage, (LPLPVOID)&lpPS)) != NOERROR)
        {
            goto errRtn;
        }

        if (wfStorage == STG_INITNEW)
        {
            error = WriteClassStg(lpStg, clsid);

            if (SUCCEEDED(error))
            {
                error = lpPS->InitNew (lpStg);
            }
        }
        else
        {
            error = lpPS->Load (lpStg);
        }

        lpPS->Release();

        if (FAILED(error))
        {
            goto errRtn;
        }

    }


    if(lpClientSite) {
        // Assert that pOleObject is set
        Win4Assert(IsValidInterface(pOleObject));

        // Set the client site if it has not been set already
        if(!(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
            error = pOleObject->SetClientSite (lpClientSite);

        // Release the object
        pOleObject->Release();

        if (FAILED(error))
            goto errRtn;
    }

    AssertSz(error == NOERROR, "Invalid code path");

    return NOERROR;

errRtn:

    if (*ppv) {
        ((LPUNKNOWN) *ppv)->Release();
        *ppv = NULL;
    }

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   wLoadAndInitObjectEx
//
//  Synopsis:   Loads and binds an object from the given storage.
//              A cacle is initialized from the data object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object to initialize
//                                 the cache with
//              [iid]           -- requested interface ID
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site.
//              [lpStg]         -- storage for the new object
//              [lplpObj]       -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wLoadAndInitObjectEx)
INTERNAL wLoadAndInitObjectEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    HRESULT                 error;
    CLSID                   clsid;

    if ((error = OleLoadWithoutBinding(lpStg, FALSE, iid, lpClientSite,
            lplpObj)) != NOERROR)
        return error;

    UtGetClassID((LPUNKNOWN) *lplpObj, &clsid);

    error = wInitializeCacheEx(lpSrcDataObj, clsid, renderopt,
        cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
        *lplpObj);

    if (error != NOERROR) {
        // relevant cache data is not available from the lpSrcDataObj.
        // So do Update and get the right cache data.
        error = wDoUpdate ((LPUNKNOWN) *lplpObj);
    }

    if (GetScode(error) == CACHE_E_NOCACHE_UPDATED) {
        error = ReportResult(0, DV_E_FORMATETC, 0, 0);
        goto errRtn;
    }

    if (error == NOERROR)
        wBindIfRunning((LPUNKNOWN) *lplpObj);

errRtn:
    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wInitializeCacheEx
//
//  Synopsis:   Query's for IOleCache on the given object and calls IOC->Cache
//              to initialize a cache node.
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to data to initialize the cache
//                                 with
//              [rclsid]        -- CLSID to use if an icon is needed
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpNewObj]      -- the object on which the cache should
//                                 be initialized
//              [pfCacheNodeCreated]    -- where to return a flag indicating
//                                         whether or not a cache node was
//                                         created
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              31-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


// This routine modifies lpFormatEtc's fields.

#pragma SEG(wInitializeCacheEx)
INTERNAL wInitializeCacheEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFCLSID                rclsid,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    void FAR*               lpNewObj,
    BOOL FAR*               pfCacheNodeCreated
)
{
    VDATEHEAP();

    IDataObject FAR*        lpNewDataObj = NULL;
    IOleCache FAR*          lpOleCache = NULL;
    HRESULT                 error = NOERROR;
    LPFORMATETC             lpFormatEtc;
    DWORD                   advf;
    STGMEDIUM               stgmed;
    DWORD                   dwConnId = 0;
    BOOL                    fIconCase;

    if (pfCacheNodeCreated)
        *pfCacheNodeCreated = FALSE;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (lpAdviseSink) {
        if ((error = ((IUnknown FAR*)lpNewObj)->QueryInterface(IID_IDataObject,
            (LPLPVOID) &lpNewDataObj)) != NOERROR)
            return error;
    }
    else {
        if (((IUnknown FAR*)lpNewObj)->QueryInterface(IID_IOleCache,
            (LPLPVOID) &lpOleCache) != NOERROR)
            return wQueryFormatSupport(lpNewObj, renderopt, rgFormatEtc);
    }

    for (ULONG i=0; i<cFormats; i++)
    {
        advf = (rgAdvf ? rgAdvf[i] : ADVF_PRIMEFIRST);
        lpFormatEtc = &rgFormatEtc[i];
        fIconCase = FALSE;

        if (lpFormatEtc->dwAspect == DVASPECT_ICON) {
            if (lpFormatEtc->cfFormat == NULL) {
                lpFormatEtc->cfFormat = CF_METAFILEPICT;
                lpFormatEtc->tymed = TYMED_MFPICT;
            }
            fIconCase = (lpFormatEtc->cfFormat == CF_METAFILEPICT);
        }

        if (lpAdviseSink)
        {
            // if icon case, must use these advise flags or the icon
            // data won't get passed back correctly
            if (fIconCase)
                advf |= (ADVF_PRIMEFIRST | ADVF_ONLYONCE);

            // should we send the data immediately?
            if ((advf & ADVF_PRIMEFIRST) && lpSrcDataObj)
            {
                stgmed.tymed = TYMED_NULL;
                stgmed.pUnkForRelease = NULL;

                if (advf & ADVF_NODATA)
                {
                    // don't sent data, send only the notification
                    lpAdviseSink->OnDataChange(lpFormatEtc, &stgmed);
                }
                else
                {
                    if (fIconCase)
                        error = UtGetIconData(lpSrcDataObj, rclsid, lpFormatEtc, &stgmed);
                    else
                        error = lpSrcDataObj->GetData(lpFormatEtc, &stgmed);

                    if (error != NOERROR)
                        goto errRtn;

                    // send data to sink and release stdmedium
                    lpAdviseSink->OnDataChange(lpFormatEtc, &stgmed);
                    ReleaseStgMedium(&stgmed);
                }

                if (advf & ADVF_ONLYONCE)
                    continue;

                // remove the ADVF_PRIMEFIRST from flags.
                advf &= (~ADVF_PRIMEFIRST);
            }

            // setup advisory connection
            if ((error = lpNewDataObj->DAdvise(lpFormatEtc, advf,
                lpAdviseSink, &dwConnId)) != NOERROR)
                goto errRtn;

            // optionally stuff the id in the array
            if (rgdwConnection)
                rgdwConnection[i] = dwConnId;
        }
        else
        {
            if (fIconCase)
                advf = ADVF_NODATA;

            // Create a cache of already specified view format.
            // In case of olerender_draw, lpFormatEtc->cfFormat would have already
            // been set to NULL.

            error = lpOleCache->Cache(lpFormatEtc, advf, &dwConnId);

            if (FAILED(GetScode(error))) {
                if (! ((dwConnId != 0) && fIconCase) )
                    goto errRtn;

                // In icon case we can ignore the cache's QueryGetData failure
            }

            error = NOERROR;
            if (pfCacheNodeCreated)
                *pfCacheNodeCreated = TRUE;

            if (fIconCase) {
                if ((error = UtGetIconData(lpSrcDataObj, rclsid, lpFormatEtc,
                    &stgmed)) == NOERROR) {
                    if ((error = lpOleCache->SetData(lpFormatEtc, &stgmed,
                        TRUE)) != NOERROR)
                        ReleaseStgMedium(&stgmed);
                }
            }
        }
    }

    if (error == NOERROR && !lpAdviseSink && lpSrcDataObj)
        error = lpOleCache->InitCache(lpSrcDataObj);

errRtn:
    if (lpNewDataObj)
        lpNewDataObj->Release();
    if (lpOleCache)
        lpOleCache->Release();
    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wReturnCreationError
//
//  Synopsis:   modifies the return code, used internally in creation api's
//
//  Effects:
//
//  Arguments:  [hresult]       -- the original error code
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL wReturnCreationError(HRESULT hresult)
{
    VDATEHEAP();

    if (hresult != NOERROR) {
        SCODE sc = GetScode(hresult);

        if (sc == CACHE_S_FORMATETC_NOTSUPPORTED
                || sc == CACHE_E_NOCACHE_UPDATED)
            return ReportResult(0, DV_E_FORMATETC, 0, 0);
    }

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wGetMonikerAndClassFromFile
//
//  Synopsis:   gets a moniker and class id from the given file
//
//  Effects:
//
//  Arguments:  [lpszFileName]  -- the file
//              [fLink]         -- passed onto CreatePackagerMoniker
//              [lplpmkFile]    -- where to put the pointer to the file
//                                 moniker
//              [lpfPackagerMoniker]    -- where to put a flag indicating
//                                         whether or not a packager moniker
//                                         was created.
//              [lpClsid]       -- where to put the class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//              10-May-94 KevinRo   Reimplemented OLE 1.0 interop
//              03-Mar-95 ScottSk   Added STG_E_FILENOTFOUND
//
//
//--------------------------------------------------------------------------


INTERNAL wGetMonikerAndClassFromFile
(
    LPCOLESTR               lpszFileName,
    BOOL                    fLink,
    LPMONIKER FAR*          lplpmkFile,
    BOOL FAR*               lpfPackagerMoniker,
    CLSID FAR*              lpClsid,
    LPDATAOBJECT *          lplpDataObject
)
{
    HRESULT hrFileMoniker;
    HRESULT hresult = S_OK;
    BOOL fHaveBoundClsid = FALSE;
    LPMONIKER  lpFileMoniker;

    VDATEHEAP();

    *lplpDataObject = NULL;
    *lplpmkFile = NULL;

     // To ensure the same error codes are returned as before we don't return immediately if CreateFileMoniker fails.
    hrFileMoniker = CreateFileMoniker((LPOLESTR)lpszFileName, &lpFileMoniker);
    Assert( (NOERROR == hrFileMoniker) || (NULL == lpFileMoniker) );

    if (NOERROR == hrFileMoniker)
    {
    LPBINDCTX pbc;

        if (SUCCEEDED(CreateBindCtx( 0, &pbc )))
        {
            if (S_OK == lpFileMoniker->IsRunning(pbc,NULL,NULL))
            {

                // If the Object is Running Bind and get the CLSID
                if (NOERROR == lpFileMoniker->BindToObject(pbc, NULL, IID_IDataObject,
                        (LPLPVOID) lplpDataObject))
                {
                    fHaveBoundClsid = UtGetClassID((LPUNKNOWN)*lplpDataObject,lpClsid);
                    Assert( (TRUE == fHaveBoundClsid) || (IsEqualCLSID(*lpClsid, CLSID_NULL)) );
                }

            }

            pbc->Release();
        }
    }

    if (!fHaveBoundClsid)
    {
        // Call GetClassFileEx directly (rather than going through GetClassFile).
        hresult = GetClassFileEx ((LPOLESTR)lpszFileName, lpClsid, CLSID_NULL);
        Assert( (NOERROR == hresult) || (IsEqualCLSID(*lpClsid, CLSID_NULL)) );

        if (NOERROR == hresult)
            fHaveBoundClsid = TRUE;
    }


    // If have a CLSID at this point see if its insertable.
    if (fHaveBoundClsid)
    {

        Assert(!IsEqualCLSID(*lpClsid, CLSID_NULL));

        // Check whether we need package this file, even though it is an
        // OLE class file.
        if (!wNeedToPackage(*lpClsid))
        {
            if (lpfPackagerMoniker != NULL)
            {
                *lpfPackagerMoniker = FALSE;
            }

            *lplpmkFile = lpFileMoniker;
            return hrFileMoniker;
        }
    }

    //
    // We didnt' find an OLE insertable object or couldn't get the CLSID. Therefore, create a
    // packager moniker for it.
    //

     // If Bound to the DataObject, release it.
    if (*lplpDataObject)
    {
        (*lplpDataObject)->Release();
        *lplpDataObject = NULL;
    }


    // If GetClassFileEx() failed because the file was not found or could not be openned.
    // don't try to bind with Packager.
    if (hresult == MK_E_CANTOPENFILE)
    {
        if (NOERROR == hrFileMoniker)
        {
            lpFileMoniker->Release();
        }

        return STG_E_FILENOTFOUND;
    }

    // If we failed to create the file moniker its finally safe to bail without changing the error code.
    if (NOERROR != hrFileMoniker)
    {
        return hrFileMoniker;
    }

    if (lpfPackagerMoniker != NULL)
    {
        *lpfPackagerMoniker = TRUE;
    }

    hresult =  CreatePackagerMonikerEx(lpszFileName,lpFileMoniker,fLink,lplpmkFile);
    lpFileMoniker->Release();

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreatePackageEx
//
//  Synopsis:   Internal function, does a IDO->GetData for a filename, and
//              then creates either a link or normal object from that file
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- the source for the filename
//              [iid]           -- the requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- client site for the object
//              [lpStg]         -- storage for the object
//              [fLink]         -- if TRUE, create a link
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Gets a filename from the data object (converting to Unicode
//              if necessary) and then creates either an embedding or link
//              from that filename.
//
//  History:    dd-mmm-yy Author    Comment
//              24-Apr-94 alexgo    rewrote to handle FileNameW
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wCreatePackageEx)
INTERNAL wCreatePackageEx
(
    LPDATAOBJECT            lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    LPOLECLIENTSITE         lpClientSite,
    LPSTORAGE               lpStg,
    BOOL                    fLink,
    LPLPVOID                lplpObj
)
{
    VDATEHEAP();

    FORMATETC               formatetc;
    STGMEDIUM               medium;
    HRESULT                 hresult;
    CLSID                   clsid = CLSID_NULL;
    LPOLESTR                pszFileName = NULL;
    OLECHAR                 szFileName[MAX_PATH +1];        // in case we
                                // have to
                                // translate

    LEDebugOut((DEB_ITRACE, "%p _IN wCreatePackageEx ( %p , %p , %lx , %lx ,"
        " %lx , %p , %p , %p , %p , %p , %p , %lu , %p )\n", NULL, lpSrcDataObj,
        &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, fLink, lplpObj));

    INIT_FORETC(formatetc);
    formatetc.cfFormat      = g_cfFileNameW;
    formatetc.tymed         = TYMED_HGLOBAL;

    // zero the medium
    _xmemset(&medium, 0, sizeof(STGMEDIUM));

    // we don't need to do a QueryGetData, because we will have only
    // gotten here on the advice of a formatetc enumerator from the
    // data object (and thus, one of the GetData calls should succeed).


    hresult = lpSrcDataObj->GetData(&formatetc, &medium);

    // if we couldn't get the Unicode filename for some reason, try
    // for the ANSI version

    if( hresult != NOERROR )
    {
        char *          pszAnsiFileName;
        DWORD           cwchSize;

        formatetc.cfFormat = g_cfFileName;
        // re-NULL the medium, just in case it was messed up by
        // the first call above

        _xmemset( &medium, 0, sizeof(STGMEDIUM));

        hresult = lpSrcDataObj->GetData(&formatetc, &medium);

        if( hresult == NOERROR )
        {
            pszAnsiFileName = (char *)GlobalLock(medium.hGlobal);

            cwchSize = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                pszAnsiFileName, -1, szFileName, MAX_PATH);

            if( cwchSize == 0 )
            {
                GlobalUnlock(medium.hGlobal);
                ReleaseStgMedium(&medium);
                hresult = ResultFromScode(E_FAIL);
            }
            else
            {
                pszFileName = szFileName;
            }
            // we will Unlock at the end of the routine
        }
    }
    else
    {
        pszFileName = (LPOLESTR)GlobalLock(medium.hGlobal);
    }

    if( hresult == NOERROR )
    {
        if (fLink)
        {
            hresult = OleCreateLinkToFileEx(pszFileName, iid,
                dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc,
                lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);
        }
        else
        {
            hresult = OleCreateFromFileEx(clsid, pszFileName, iid,
                dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc,
                lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);
        }

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT wCreatePackageEx ( %lx ) [ %p ]\n",
        NULL, hresult, *lplpObj));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateCreateParams
//
//  Synopsis:   Validate the incoming create parameters
//
//  Effects:
//
//  Arguments:  [cFormats]      -- the number of elements in rgAdvf
//              [rgAdvf]        -- array of advise flags
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              26-Apr-96 davidwor  added function
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateCreateParams)
INTERNAL wValidateCreateParams
(
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg
)
{
    HRESULT     hresult = NOERROR;

    VDATEHEAP();

    if (dwFlags != (dwFlags & OLECREATE_LEAVERUNNING)) {
        VdateAssert(dwFlags, "Invalid creation flags");
        hresult = ResultFromScode(E_INVALIDARG);
        goto errRtn;
    }

    if (renderopt == OLERENDER_DRAW && cFormats > 1) {
        VdateAssert(cFormats, "Multiple formats not allowed with OLERENDER_DRAW");
        hresult = ResultFromScode(E_INVALIDARG);
        goto errRtn;
    }

    if (renderopt != OLERENDER_FORMAT)
        VDATEPTRNULL_LABEL( lpAdviseSink, errRtn, hresult );

    if (cFormats == 0) {
        VDATEPTRNULL_LABEL( rgAdvf, errRtn, hresult );
        VDATEPTRNULL_LABEL( rgFormatEtc, errRtn, hresult );
        VDATEPTRNULL_LABEL( rgdwConnection, errRtn, hresult );
    }
    else {
        VDATESIZEREADPTRIN_LABEL( rgAdvf, cFormats * sizeof(DWORD), errRtn, hresult );
        VDATESIZEREADPTRIN_LABEL( rgFormatEtc, cFormats * sizeof(FORMATETC), errRtn, hresult );
        if ( rgdwConnection ) {
            VDATESIZEPTROUT_LABEL( rgdwConnection, cFormats * sizeof(DWORD), errRtn, hresult );
            _xmemset(rgdwConnection, 0, cFormats * sizeof(DWORD));
        }
    }

    if ((hresult = wValidateAdvfEx(cFormats, rgAdvf)) != NOERROR)
        goto errRtn;

    VDATEIFACE_LABEL( lpStg, errRtn, hresult );
    if ( lpAdviseSink )
        VDATEIFACE_LABEL( lpAdviseSink, errRtn, hresult );
    if ( lpClientSite )
        VDATEIFACE_LABEL( lpClientSite, errRtn, hresult );

errRtn:
    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateAdvfEx
//
//  Synopsis:   Validate the incoming array of ADVF values
//
//  Effects:
//
//  Arguments:  [cFormats]      -- the number of elements in rgAdvf
//              [rgAdvf]        -- array of advise flags
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              19-Mar-96 davidwor  added function
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateAdvfEx)
INTERNAL wValidateAdvfEx
(
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf
)
{
    VDATEHEAP();

    if ((cFormats != 0) != (rgAdvf != NULL))
        return ResultFromScode(E_INVALIDARG);

    for (ULONG i=0; i<cFormats; i++)
    {
        if (rgAdvf[i] != (rgAdvf[i] & MASK_VALID_ADVF))
        {
            VdateAssert(rgAdvf, "Invalid ADVF value specified");
            return ResultFromScode(E_INVALIDARG);
        }
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateFormatEtc
//
//  Synopsis:   Validate the incoming formatetc and initialize the
//              out formatetc with the correct info
//
//  Effects:
//
//  Arguments:  [renderopt]     -- rendering option
//              [lpFormatEtc]   -- the incoming formatetc
//              [lpMyFormatEtc] -- the out formatetc
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:  The original comments,
//
// Validate the lpFormatEtc that's been passed to the creation APIs. And then
// initialize our formateEtc structure with the appropriate info.
//
// We allow NULL lpFormatEtc if the render option is olerender_draw
// We ignore lpFormatEtc if the render option is olerender_none
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateFormatEtc)
INTERNAL wValidateFormatEtc
(
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    LPFORMATETC             lpMyFormatEtc
)
{
    VDATEHEAP();

    SCODE sc = S_OK;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (renderopt == OLERENDER_FORMAT) {
        if (!lpFormatEtc || !lpFormatEtc->cfFormat) {
            sc = E_INVALIDARG;
            goto errRtn;
        }

        if (lpFormatEtc->tymed !=
            UtFormatToTymed(lpFormatEtc->cfFormat)) {
            sc = DV_E_TYMED;
            goto errRtn;
        }

    } else if (renderopt == OLERENDER_DRAW) {
        if (lpFormatEtc) {
            if (lpFormatEtc->cfFormat != NULL) {
                VdateAssert(lpFormatEtc->cfFormat,"NON-NULL clipformat specified with OLERENDER_DRAW");
                sc = DV_E_CLIPFORMAT;
                goto errRtn;
            }

            if (lpFormatEtc->tymed != TYMED_NULL) {
                VdateAssert(lpFormatEtc->tymed,"TYMED_NULL is not specified with OLERENDER_DRAW");
                sc = DV_E_TYMED;
                goto errRtn;
            }
        }
    } else {
        VdateAssert(renderopt, "Unexpected value for OLERENDER_ option");
        sc = E_INVALIDARG;
        goto errRtn;
    }

    if (lpFormatEtc) {
        if (!HasValidLINDEX(lpFormatEtc))
        {
          sc = DV_E_LINDEX;
          goto errRtn;
        }

        VERIFY_ASPECT_SINGLE(lpFormatEtc->dwAspect)

        *lpMyFormatEtc = *lpFormatEtc;

    } else {
        INIT_FORETC(*lpMyFormatEtc);
        lpMyFormatEtc->tymed    = TYMED_NULL;
        lpMyFormatEtc->cfFormat = NULL;
    }

errRtn:
    return ReportResult(0, sc, 0, 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateFormatEtcEx
//
//  Synopsis:   Validate the incoming formatetc and initialize the
//              out formatetc with the correct info
//
//  Effects:
//
//  Arguments:  [renderopt]     -- rendering option
//              [lpcFormats]    -- the number of elements in rgFormatEtc
//              [rgFormatEtc]   -- array of rendering formats
//              [lpFormatEtc]   -- place to store valid formatetc if only one
//              [lplpFormatEtc] -- the out array of formatetcs
//              [lpfAlloced]    -- place to store whether array was allocated
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:  The original comments,
//
// Validate the lpFormatEtc that's been passed to the creation APIs. And then
// initialize our formateEtc structure with the appropriate info.
//
// We allow NULL lpFormatEtc if the render option is olerender_draw
// We ignore lpFormatEtc if the render option is olerender_none
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateFormatEtcEx)
INTERNAL wValidateFormatEtcEx
(
    DWORD                   renderopt,
    ULONG FAR*              lpcFormats,
    LPFORMATETC             rgFormatEtc,
    LPFORMATETC             lpFormatEtc,
    LPFORMATETC FAR*        lplpFormatEtc,
    LPBOOL                  lpfAlloced
)
{
    LPFORMATETC             lpfmtetc;

    VDATEHEAP();

    SCODE sc = S_OK;

    *lplpFormatEtc = lpFormatEtc;
    *lpfAlloced = FALSE;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (renderopt != OLERENDER_FORMAT && renderopt != OLERENDER_DRAW) {
        VdateAssert(renderopt, "Unexpected value for OLERENDER_ option");
        return ResultFromScode(E_INVALIDARG);
    }

    if ((*lpcFormats != 0) != (rgFormatEtc != NULL))
        return ResultFromScode(E_INVALIDARG);

    if (*lpcFormats <= 1) {
        if (*lpcFormats == 0)
            *lpcFormats = 1;
        return wValidateFormatEtc(renderopt, rgFormatEtc, lpFormatEtc);
    }

    *lplpFormatEtc = (LPFORMATETC)PubMemAlloc(*lpcFormats * sizeof(FORMATETC));
    if (!*lplpFormatEtc)
        return E_OUTOFMEMORY;

    *lpfAlloced = TRUE;

    for (ULONG i=0; i<*lpcFormats; i++)
    {
        lpfmtetc = &rgFormatEtc[i];

        if (renderopt == OLERENDER_FORMAT)
        {
            if (!lpfmtetc->cfFormat) {
                sc = E_INVALIDARG;
                goto errRtn;
            }

            if (lpfmtetc->tymed !=
                UtFormatToTymed(lpfmtetc->cfFormat)) {
                sc = DV_E_TYMED;
                goto errRtn;
            }
        }
        else if (renderopt == OLERENDER_DRAW)
        {
            if (lpfmtetc->cfFormat != NULL) {
                VdateAssert(lpfmtetc->cfFormat,"NON-NULL clipformat specified with OLERENDER_DRAW");
                sc = DV_E_CLIPFORMAT;
                goto errRtn;
            }

            if (lpfmtetc->tymed != TYMED_NULL) {
                VdateAssert(lpfmtetc->tymed,"TYMED_NULL is not specified with OLERENDER_DRAW");
                sc = DV_E_TYMED;
                goto errRtn;
            }
        }

        if (!HasValidLINDEX(lpfmtetc))
        {
            sc = DV_E_LINDEX;
            goto errRtn;
        }

        VERIFY_ASPECT_SINGLE(lpfmtetc->dwAspect)

        (*lplpFormatEtc)[i] = *lpfmtetc;
    }

errRtn:
    if (sc != S_OK) {
        PubMemFree(*lplpFormatEtc);
        *lpfAlloced = FALSE;
    }
    return ReportResult(0, sc, 0, 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   wQueryFormatSupport
//
//  Synopsis:   check to see whether we will be able to Get and SetData of
//              the given format
//
//  Effects:
//
//  Arguments:  [lpObj]         -- pointer to the object
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- the formatetc in question
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Internal function, calls UtIsFormatSupported (which calls
//              EnumFormatEtc and checks all of the formats) if renderopt
//              is OLERENDER_FORMAT
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wQueryFormatSupport)
INTERNAL wQueryFormatSupport
    (LPVOID lpObj, DWORD renderopt, LPFORMATETC lpFormatEtc)
{
    VDATEHEAP();

    IDataObject FAR*        lpDataObj;
    HRESULT                 error = NOERROR;

    if (renderopt == OLERENDER_FORMAT)
    {
        if ((error = ((IUnknown FAR*) lpObj)->QueryInterface(
            IID_IDataObject, (LPLPVOID)&lpDataObj)) == NOERROR)
        {
            if (!UtIsFormatSupported(lpDataObj,
                    DATADIR_GET | DATADIR_SET,
                    lpFormatEtc->cfFormat))
                error = ResultFromScode(DV_E_CLIPFORMAT);

            lpDataObj->Release();
        }
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wGetMonikerAndClassFromObject
//
//  Synopsis:   Gets the moniker and class ID from the given object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- the data object
//              [lplpmkSrc]     -- where to put a pointer to the moniker
//              [lpclsidLast]   -- where to put the clsid
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Mar-95 alexgo    added a hack for CorelDraw5
//              01-Nov-93 alexgo    32bit port
//
//  Notes:      see also wGetMonikerAndClassFromFile
//
//--------------------------------------------------------------------------



#pragma SEG(wGetMonikerAndClassFromObject)
INTERNAL wGetMonikerAndClassFromObject(
    LPDATAOBJECT            lpSrcDataObj,
    LPMONIKER FAR*          lplpmkSrc,
    CLSID FAR*              lpclsidLast
)
{
    VDATEHEAP();

    HRESULT                 error;
    FORMATETC               foretcTmp;
    STGMEDIUM               medium;
    LPMONIKER               lpmkSrc = NULL;
    LARGE_INTEGER   large_integer;

    INIT_FORETC(foretcTmp);
    foretcTmp.cfFormat = g_cfLinkSource;
    foretcTmp.tymed    = TYMED_ISTREAM;

    // 16bit OLE had a bug where the medium was uninitialized at this
    // point.  Corel5, when doing a paste-link to itself, actually
    // checked the tymed and compared it with TYMED_NULL.  So here
    // we set the value to something recognizeable.
    //
    // NB!  In the thunk layer, if we are *NOT* in Corel Draw, this
    // value will be reset to TYMED_NULL.

    if( IsWOWThread() )
    {
        medium.tymed = 0x66666666;
    }
    else
    {
        medium.tymed = TYMED_NULL;
    }
    medium.pstm  = NULL;
    medium.pUnkForRelease = NULL;

    if ((error = lpSrcDataObj->GetData(&foretcTmp, &medium)) != NOERROR)
            return ReportResult(0, OLE_E_CANT_GETMONIKER, 0, 0);

    LISet32( large_integer, 0 );
    if ((error = (medium.pstm)->Seek (large_integer, STREAM_SEEK_SET,
        NULL)) != NOERROR)
        goto FreeStgMed;

    // get moniker from the stream
    if ((error = OleLoadFromStream (medium.pstm, IID_IMoniker,
        (LPLPVOID) lplpmkSrc)) != NOERROR)
        goto FreeStgMed;

    // read class stm; if error, use CLSID_NULL (for compatibility with
    // prior times when the clsid was missing).
    ReadClassStm(medium.pstm, lpclsidLast);

FreeStgMed:
    ReleaseStgMedium (&medium);
    if (error != NOERROR)
        return ReportResult(0, OLE_E_CANT_GETMONIKER, 0, 0);

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   wDoLockUnlock
//
//  Synopsis:   tickles an object by locking and unlocking, used to resolve
//              ambiguities with stub manager locks
//
//  Effects:    the object may go away as a result of this call, if the
//              object is invisible and the lock count goes to zero as
//              a result of locking/unlocking.
//
//  Arguments:  [lpUnk]         -- pointer to the object to lock/unlock
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wDoLockUnlock)
void wDoLockUnlock(IUnknown FAR* lpUnk)
{
    VDATEHEAP();

    IRunnableObject FAR* pRO;

    if (lpUnk->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        == NOERROR)
    {       // increase lock count
        if (pRO->LockRunning(TRUE, FALSE) == NOERROR)
            // decrease lock count
            pRO->LockRunning(FALSE, TRUE);
        pRO->Release();
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   wSaveObjectWithoutCommit
//
//  Synopsis:   Saves an object without committing (to preserve the
//              container's undo state)
//
//  Effects:
//
//  Arguments:  [lpUnk]         -- pointer to the object
//              [pstgSave]      -- storage in which to save
//              [fSameAsLoad]   -- indicates SaveAs operation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL wSaveObjectWithoutCommit
    (LPUNKNOWN lpUnk, LPSTORAGE pstgSave, BOOL fSameAsLoad)
{
    VDATEHEAP();

    LPPERSISTSTORAGE                pPS;
    HRESULT                         error;
    CLSID                           clsid;

    if (error = lpUnk->QueryInterface(IID_IPersistStorage, (LPLPVOID)&pPS))
        return error;

    if (error = pPS->GetClassID(&clsid))
        goto errRtn;

    if (error = WriteClassStg(pstgSave, clsid))
        goto errRtn;

    if (error = pPS->Save(pstgSave, fSameAsLoad))
        goto errRtn;

    pPS->SaveCompleted(NULL);

errRtn:
    pPS->Release();
    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStuffIconOfFileEx
//
//  Synopsis:   Retrieves the icon if file [lpszFile] and stuffs it into
//              [lpUnk]'s cache
//
//  Effects:
//
//  Arguments:  [lpszFile]      -- the file where the icon is stored
//              [fAddLabel]     -- if TRUE, adds a label to the icon
//                                 presentation
//              [renderopt]     -- must be OLERENDER_DRAW or
//                                 OLERENDER_FORMAT for anything to happen
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgFormatEtc]   -- array of rendering formats, aspect must be
//                                 DVASPECT_ICON and the clipboard format
//                                 must be NULL or CF_METAFILE for anything
//                                 to happen
//              [lpUnk]         -- pointer to the object in which the icon
//                                 should be stuffed
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//              REVIEW32: maybe we should support enhanced metafiles for NT
//
//--------------------------------------------------------------------------


#pragma SEG(wStuffIconOfFileEx)
INTERNAL wStuffIconOfFileEx
(
    LPCOLESTR       lpszFile,
    BOOL            fAddLabel,
    DWORD           renderopt,
    ULONG           cFormats,
    LPFORMATETC     rgFormatEtc,
    LPUNKNOWN       lpUnk
)
{
    VDATEHEAP();

    IOleCache FAR*  lpOleCache;
    HRESULT         error;
    BOOL            fFound = FALSE;
    FORMATETC       foretc;
    STGMEDIUM       stgmed;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (rgFormatEtc == NULL)
        return NOERROR; // in this case we default to DVASPECT_CONTENT

    for (ULONG i=0; i<cFormats; i++)
    {
        if ((rgFormatEtc[i].dwAspect == DVASPECT_ICON) &&
            (rgFormatEtc[i].cfFormat == NULL ||
             rgFormatEtc[i].cfFormat == CF_METAFILEPICT))
        {
           foretc = rgFormatEtc[i];
           fFound = TRUE;
        }
    }

    if (!fFound)
        return NOERROR;

    foretc.cfFormat = CF_METAFILEPICT;
    foretc.tymed = TYMED_MFPICT;

    if ((error = lpUnk->QueryInterface(IID_IOleCache,
        (LPLPVOID) &lpOleCache)) != NOERROR)
        return error;

    stgmed.tymed = TYMED_MFPICT;
    stgmed.pUnkForRelease = NULL;

    // get icon data of file, from registration database
    if (!(stgmed.hGlobal = OleGetIconOfFile((LPOLESTR) lpszFile,
        fAddLabel))) {
        error = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    // take ownership of the data
    if ((error = lpOleCache->SetData(&foretc, &stgmed, TRUE)) != NOERROR)
        ReleaseStgMedium(&stgmed);

errRtn:
    lpOleCache->Release();
    return error;

}


//+-------------------------------------------------------------------------
//
//  Function:   wNeedToPackage
//
//  Synopsis:   Determines whether or not a given CLSID should be
//              packaged.
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID
//
//  Requires:
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Looks for the reg key PackageOnFileDrop, or if it's a
//              Word document, or if it is insertable, or if it's an OLE1
//              class
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//              03-Jun-94 AlexT     Just check for Insertable key (instead
//                                    of requiring a value)
//
//  Notes:
//--------------------------------------------------------------------------



INTERNAL_(BOOL) wNeedToPackage(REFCLSID rclsid)
{
    VDATEHEAP();

    HKEY    hkeyClsid;
    HKEY    hkeyTmp;
    HKEY    hkeyTmp2;
    BOOL    fPackage = FALSE;
    LPOLESTR        lpszProgID;
    DWORD   dw;
    LONG    cbValue = sizeof(dw);
    LONG    lRet;
    CLSID       clsidNew;

    if (NOERROR != OleGetAutoConvert (rclsid, &clsidNew))
    {
        if (NOERROR != CoGetTreatAsClass (rclsid, &clsidNew))
        {
                clsidNew = rclsid;
        }
    }

    if (CoOpenClassKey(clsidNew, FALSE, &hkeyClsid) != NOERROR)
        return TRUE;    // NON-OLE file, package it

    if (ProgIDFromCLSID(clsidNew, &lpszProgID) == NOERROR) {
        // see whether we can open this key

        dw = (DWORD) OpenClassesRootKey(lpszProgID,
            &hkeyTmp);

        PubMemFree(lpszProgID);

        if (dw == ERROR_SUCCESS) {
            // This is definitely a OLE insertable file.
            lRet = RegOpenKeyEx(hkeyTmp,
                     OLESTR("PackageOnFileDrop"),
                     0, KEY_READ,
                     &hkeyTmp2);
            // Check whether we need to package this file
            if (ERROR_SUCCESS == lRet)
            {
              RegCloseKey(hkeyTmp2);
              fPackage = TRUE;
            }
            else if (IsEqualCLSID(clsidNew, CLSID_WordDocument))
            {
            // Hack to make sure Word documents are always
            // Packaged on file drop.  We write the key here
            // so that we can say that a file is Packaged if
            // and only if its ProgID has the "PackageOnFileDrop"
            // key.
                RegSetValue (hkeyTmp,
                    OLESTR("PackageOnFileDrop"),
                    REG_SZ, (LPOLESTR)NULL, 0);
                fPackage = TRUE;
            }

            RegCloseKey(hkeyTmp);

            if (fPackage) {
                RegCloseKey(hkeyClsid);
                return TRUE;
            }
        }
    }

    // There is no "PackageOnFileDrop" key defined.

    // See whether this is an "Insertable" class by checking for the
    // existence of the Insertable key - we don't require a value

    lRet = RegOpenKeyEx(hkeyClsid, OLESTR("Insertable"), 0, KEY_READ, &hkeyTmp);

    if (ERROR_SUCCESS == lRet)
    {
      //  Insertable key exists - close it and return
      RegCloseKey(hkeyTmp);
      goto errRtn;
    }

    //
    // See whether this is a "Ole1Class" class by opening the
    // registry key Ole1Class. We don't require a value
    //
    cbValue = sizeof(dw);
    lRet = RegOpenKeyEx(hkeyClsid,OLESTR("Ole1Class"), 0, KEY_READ, &hkeyTmp);
    if (ERROR_SUCCESS == lRet)
    {
      RegCloseKey(hkeyTmp);
      goto errRtn;
    }
    else
    {
      fPackage = TRUE;
    }

errRtn:
    RegCloseKey(hkeyClsid);
    return fPackage;
}

//+-------------------------------------------------------------------------
//
//  Function:   wDoUpdate
//
//  Synopsis:   calls IOleObject->Update() on the given object, internal
//              function
//
//  Effects:
//
//  Arguments:  [lpUnkown]      -- the object to update
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wDoUpdate)
INTERNAL  wDoUpdate(IUnknown FAR* lpUnknown)
{
    VDATEHEAP();

    HRESULT                 error = NOERROR;
    IOleObject FAR*         lpOle;

    if (lpUnknown->QueryInterface (IID_IOleObject, (LPLPVOID)&lpOle)
        == NOERROR) {
        error = lpOle->Update();
        lpOle->Release();
    }

    return error;
}




//+-------------------------------------------------------------------------
//
//  Function:   wBindIfRunning
//
//  Synopsis:   calls IOleLink->BindIfRunning() on the given object
//
//  Effects:
//
//  Arguments:  [lpUnk]         -- the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL_(void) wBindIfRunning(LPUNKNOWN lpUnk)
{
    VDATEHEAP();

    IOleLink FAR* lpLink;

    if (lpUnk->QueryInterface (IID_IOleLink, (LPLPVOID)&lpLink)
        == NOERROR)
    {
        lpLink->BindIfRunning();
        lpLink->Release();
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   wQueryUseCustomLink
//
//  Synopsis:   look at the registry and see if the class ID has a custom
//              link regisetered
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID in question
//
//  Requires:
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL_(BOOL) wQueryUseCustomLink(REFCLSID rclsid)
{
    VDATEHEAP();

    // see whether it has Custom Link implementation
    HKEY    hkeyClsid;
    HKEY    hkeyTmp;
    BOOL    bUseCustomLink = FALSE;

    if (SUCCEEDED(CoOpenClassKey(rclsid, FALSE, &hkeyClsid)))
    {
        DWORD   dw;
        dw = RegOpenKeyEx(hkeyClsid,OLESTR("UseCustomLink"), 0, KEY_READ, &hkeyTmp);

        if (ERROR_SUCCESS == dw)
        {
            RegCloseKey(hkeyTmp);
            bUseCustomLink = TRUE;
        }

        RegCloseKey(hkeyClsid);
    }

    return bUseCustomLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   base
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc;..\..\..\com\inc

SOURCES=      \
              ..\privstm.cpp  \
              ..\api.cpp      \
              ..\create.cpp   \
              ..\lockbyte.cpp \
              ..\memstm.cpp   \
              ..\ole2.cpp

LINKLIBS=     ..\..\common\daytona\$(O)\common.lib
UMTYPE=       windows
USE_IOSTREAM=1

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\privstm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       privstm.cpp
//
//  Contents:   Handles all reading/writing of the \1CompObj stream
//
//  Functions:  Implements:
//
//              INTERNAL ReadCompObjStm
//              INTERNAL WriteCompObjStm
//              INTERNAL ClipfmtToStm
//              INTERNAL StmToClipfmt
//              INTERNAL GetUNICODEUserType
//              INTERNAL GetUNICODEProgID
//              INTERNAL GetUNICODEClipFormat
//              INTERNAL PutUNICODEUserType
//              INTERNAL PutUNICODEProgID
//              INTERNAL PutUNICODEClipFormat
//              INTERNAL UtGetUNICODEData
//              INTERNAL ANSIStrToStm
//              INTERNAL ANSIStmToStr
//
//              STDAPI   WriteFmtUserTypeStg
//              STDAPI   ReadFmtUserTypeStg
//              STDAPI   ReadFmtProgIdStg
//
//  History:    dd-mmm-yy Author    Comment
//              08-Feb-94 davepl    Created
//
//
//  Notes:      The CompObj stream (in 16-bit OLE) contained fields for
//              the ClassID, UserType, Clipboard format, and (in later
//              versions only) ProgID.  These were always written in ANSI
//              format.
//
//              The file format has been extended such that ANSI data is
//              written to the stream in much the same way as before.  The
//              key difference is that in the event the internal UNICODE
//              versions of this data cannot be losslessly converted to
//              ANSI, the ANSI version is written as a NULL string, and
//              the UNICODE version follows at the end of the stream.  This
//              way, 16-bit apps see as much of what they expect as possible,
//              and 32-bit apps can write UNICODE transparently in a
//              backwards-compatible way.
//
//              The file format of the stream is:
//
//         (A)  WORD    Byte Order
//              WORD    Format Version
//              DWORD   Original OS ver         Always Windows 3.1
//              DWORD   -1
//              CLSID   Class ID
//              ULONG   Length of UserType
//              <var>   User Type string        ANSI
//              <var>   Clipformat              ANSI (when using string tag)
//              ----------------------------
//         (B)  ULONG   Length of Prog ID
//              <var>   Prog ID                 ANSI (not always present)
//              ----------------------------
//         (C)  ULONG   Magic Number            Signified UNICODE data present
//              ULONG   Length of UserType
//              ULONG   User Type string        UNICODE
//              <var>   Clipformat              UNICODE (when tag is string)
//              ULONG   Length of Prog ID
//              <var>   Prog ID                 UNICODE
//
//              Section (A) is always present.  Section (B) is present when
//              stream has been written by a later 16-bit app or by a
//              32-bit app.   Section (C) is present when written by a
//              32-bit app.
//
//              If a string is present in UNICODE, the ANSI version will be
//              NULL (a zero for length and _no_ <var> data).  When the
//              UNICODE section is present, strings that were not needed
//              because the ANSI conversion was successful are written
//              as NULL (again, zero len and no <var> data).
//
//              A NULL clipboard format is written as a 0 tag.
//
//              In order to read any field, the entire string is read into
//              an internal object, and the fields are extracted individually.
//              In order to write an fields, the stream is read into the
//              object (if possible), the fields updated, and then rewritten
//              as an atomic object.
//
//--------------------------------------------------------------------------


#include <le2int.h>

static const ULONG COMP_OBJ_MAGIC_NUMBER = 0x71B239F4;

#define MAX_CFNAME 400          // Maximum size of a clipformat name
                                // (my choice, none documented)

const DWORD gdwFirstDword = (DWORD)MAKELONG(COMPOBJ_STREAM_VERSION,
                                            BYTE_ORDER_INDICATOR);

enum TXTTYPE
{
    TT_UNICODE = 0, TT_ANSI = 1
};

// This is the data object into which the stream is read prior to
// extracting fields.

struct CompObjHdr                 // The leading data in the CompObj stream
{
   DWORD       m_dwFirstDword;    // First DWORD, byte order and format ver
   DWORD       m_dwOSVer;         // Originating OS Ver (eg: Win31)
   DWORD       m_unused;          // Always a -1L in the stream
   CLSID       m_clsClass;        // Class ID of this object
};

class CompObjStmData : public CPrivAlloc
{
public:

    CompObjHdr  m_hdr;
    ULONG       m_cchUserType;     // Number of CHARACTERS in UserType
    ULONG       m_cchProgID;       // Number of CHARACTERS in ProgID
    DWORD       m_dwFormatTag;     // Clipformat type (none, string, clip, etc)
    ULONG       m_ulFormatID;      // If tag is std clipformat, what type?

    LPOLESTR    m_pszOUserType;    // Pointer to OLESTR UserType
    LPOLESTR    m_pszOProgID;      // Pointer to OLESTR ProgID

    LPSTR       m_pszAUserType;    // Pointer to ANSI UserType
    LPSTR       m_pszAProgID;      // Pointer to ANSI ProgID

    TXTTYPE     ttClipString;      // Format needed for the clipformat string

    CompObjStmData(void)
    {
        memset(this, 0, sizeof(CompObjStmData));
        ttClipString = TT_ANSI;   // By default, use ANSI Clipformat
    };

    ~CompObjStmData(void)
    {
        PubMemFree(m_pszOUserType);
        PubMemFree(m_pszOProgID);
        PubMemFree(m_pszAUserType);
        PubMemFree(m_pszAProgID);
    };
};

// Prototypes for fns declared in this file

INTERNAL ReadCompObjStm      (IStorage *, CompObjStmData *);
INTERNAL WriteCompObjStm     (IStorage *, CompObjStmData *);
INTERNAL ClipfmtToStm        (CStmBufWrite &, ULONG, ULONG, TXTTYPE);
INTERNAL StmToClipfmt        (CStmBufRead &, DWORD *, DWORD *, TXTTYPE);
INTERNAL GetUNICODEUserType  (CompObjStmData *, LPOLESTR *);
INTERNAL GetUNICODEProgID    (CompObjStmData *, LPOLESTR *);
INTERNAL GetClipFormat       (CompObjStmData *, DWORD *, DWORD *);
INTERNAL PutUNICODEUserType  (CompObjStmData *, LPOLESTR);
INTERNAL PutUNICODEProgID    (CompObjStmData *, LPOLESTR);
INTERNAL PutClipFormat       (CompObjStmData *, DWORD, DWORD);
INTERNAL ANSIStrToStm        (CStmBufWrite &, LPCSTR);
INTERNAL ANSIStmToStr        (CStmBufRead & StmRead, LPSTR * pstr, ULONG *);

STDAPI   WriteFmtUserTypeStg (IStorage *, CLIPFORMAT, LPOLESTR);
STDAPI   ReadFmtUserTypeStg  (IStorage *, CLIPFORMAT *, LPOLESTR *);
STDAPI   ReadFmtProgIdStg    (IStorage *, LPOLESTR *);

//+-------------------------------------------------------------------------
//
//  Function:   ReadCompObjStm, PRIVATE INTERNAL
//
//  Synopsis:   Reads the \1CompObj stream into an internal data structure
//              that will contain the best-case representation of that
//              stream (ie: ANSI where possible, UNICODE where needed).
//
//  Effects:    Reads ANSI data where available.  At end of standard ANSI
//              data, looks for ANSI ProgID field.  If found, looks for
//              MagicNumber indicating UNICODE data is to follow.  If this
//              matches, UNICODE strings are pulled from the stream.  They
//              should only be found where the ANSI version was NULL
//              (because it could not be converted from UNICODE).
//
//              Capable of reading 3 stream formats seamlessly:
//              - Original ANSI sans ProgID field
//              - Extended OLE 2.01 version with ProgID
//              - Extended OLE 2/32 version with ProgID and UNICODE extensions
//
//  Arguments:  [pstg]      -- ptr to IStorage to read from
//              [pcod]      -- ptr to already-allocated CompObjData object
//
//  Returns:    NOERROR             on success
//              INVALIDARG          on missing pcod
//              Various I/O         on stream missing, read errors, etc
//              E_OUTOFMEMORY       on any allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//  Notes:      Any memory allocated herein will be allocated on
//              pointers in the pcod object, which will be freed by its
//              destructor when it exits scope or is deleted explicitly.
//
//--------------------------------------------------------------------------

INTERNAL ReadCompObjStm(IStorage * pstg, CompObjStmData * pcod)
{
    VDATEHEAP();

    HRESULT         hr;                  // Result code
    const ULONG     RESERVED    = 0;     // For reserved parameters
    ULONG           ulSize      = 0;     // Holder for length of ProgID string
    BOOL            fExtStm     = 1;     // Could this be ext with UNICODE?
    CStmBufRead     StmRead;


    Win4Assert(pcod);

    // Validate the pstg interface
    VDATEIFACE(pstg);

    // Open the CompObj stream
    if (FAILED(hr = StmRead.OpenStream(pstg, COMPOBJ_STREAM))) // L"\1CompObj"
    {
        goto errRtn;
    }

    // Read the header from the CompObj stream:
    //
    // WORD     Byte Order Indicator        02 bytes
    // WORD     Format version              02 bytes
    // DWORD    Originating OS version      04 bytes
    // DWORD    -1                          04 bytes
    // CLSID    Class ID                    16 bytes
    //                                      --------
    //                                      28 bytes == sizeof(dwBuf)

    Win4Assert(sizeof(CompObjHdr) == 28 &&
                "Warning: possible packing error in CompObjHdr struct");

    hr = StmRead.Read(&pcod->m_hdr, sizeof(CompObjHdr));
    if (FAILED(hr))
    {
        goto errRtn;
    }

    // NB: There used to be a check against the OS version here,
    //     but since the version number has been forced to always
    //     be written as Win3.1, checking it would be redundant.

    //  Win4Assert(pcod->m_hdr.m_dwOSVer == 0x00000a03);
#if DBG==1
    if (pcod->m_hdr.m_dwOSVer != 0x00000a03)
    {
        LEDebugOut((DEB_WARN, "ReadCompObjStm found unexpected OSVer %lx",
                    pcod->m_hdr.m_dwOSVer));
    }
#endif

    // Get the User type string from the stream (ANSI FORMAT!)
    if (FAILED(hr = ANSIStmToStr(StmRead, &pcod->m_pszAUserType,
                        &pcod->m_cchUserType)))
    {
        goto errRtn;
    }

    // Get the clipboard format data from the stream
    if (FAILED(hr =     StmToClipfmt(StmRead,         // Stream to read from
                            &pcod->m_dwFormatTag,     // DWORD clip format
                             &pcod->m_ulFormatID,     // DWORD clip type
                                      TT_ANSI)))      // Use ANSI
    {
        goto errRtn;
    }

    // We have to special-case the ProgID field, because it may not
    // be present in objects written by early (pre-2.01) versions
    // of OLE.  We only continue when ProgID can be found, but
    // its absence is not an error, so return what we have so far.

    hr = StmRead.Read(&ulSize, sizeof(ULONG));

    if (FAILED(hr))
    {
        //  We were unable to read the size field;  make sure ulSize is 0
        ulSize = 0;
    }

    // The ProgID can be no longer than 39 chars plus a NULL.  Other
    // numbers likely indicate garbage.

    if (ulSize > 40 || 0 == ulSize)
    {
#if DBG==1
        if (ulSize > 40)
        {
            LEDebugOut((DEB_WARN,"ReadCompObjStm: ulSize > 40 for ProgID\n"));
        }
#endif
        fExtStm = 0;    // No ProgID implies no UNICODE to follow
    }

    // If it looks like we have a hope of findind the ProgID and maybe
    // even UNICODE, try to fetch the ProdID

    if (fExtStm)
    {
        // Allocate memory for string on our ProgID pointer
        pcod->m_pszAProgID = (char *) PubMemAlloc(ulSize);
        if (NULL == pcod->m_pszAProgID)
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto errRtn;
        }
        if (FAILED(hr = StmRead.Read(pcod->m_pszAProgID, ulSize)))
        {
            // OK, we give up on ProgID and the UNICODE, but that's
            // _not_ reason to fail, since ProgID could just be missing

            pcod->m_cchProgID = 0;
            PubMemFree(pcod->m_pszAProgID);
            pcod->m_pszAProgID = NULL;
            fExtStm = 0;
        }
        else
        {
            // We managed to get ProgID from the stream, so set the
            // length in pcod and go looking for the UNICODE...
            pcod->m_cchProgID = ulSize;
        }
    }

    // See if we can find the Magic number

    DWORD dwMagic = 0;
    if (fExtStm)
    {
        if (FAILED(StmRead.Read(&dwMagic, sizeof(dwMagic))))
        {
            fExtStm = 0;
        }
    }

    if (fExtStm && dwMagic != COMP_OBJ_MAGIC_NUMBER)
    {
        fExtStm = 0;
    }

    // If fExtStm is still TRUE, we go ahead and read the UNICODE

    if (fExtStm)
    {
        // Get the UNICODE version of the user type
        if (FAILED(hr = ReadStringStream(StmRead, &pcod->m_pszOUserType)))
        {
            goto errRtn;
        }

        // Get the clipboard format (UNICODE)

        DWORD dwFormatTag;
        ULONG ulFormatID;
        if (FAILED(hr =  StmToClipfmt(StmRead,         // Stream to read from
                                     &dwFormatTag,     // DWORD clip format
                                      &ulFormatID,     // DWORD clip type
                                       TT_UNICODE)))   // Use UNICODE
        {
            goto errRtn;
        }

        // If we found some form of clipboard format, that implies the ANSI
        // was missing, so set up all of the fields based on this data.

        if (dwFormatTag)
        {
            pcod->m_dwFormatTag = dwFormatTag;
            pcod->m_ulFormatID  = ulFormatID;
        }

        // Get the UNICODE version of the ProgID.  If there was any UNICODE at
        // all, we know for sure there is a UNICODE ProgID, so no special casing
        // as was needed for the ANSI version

        if (FAILED(hr = ReadStringStream(StmRead, &pcod->m_pszOProgID)))
        {
            goto errRtn;
        }
        if (pcod->m_pszOProgID)
        {
            pcod->m_cchProgID = _xstrlen(pcod->m_pszOProgID) + 1;
        }
    }

    //  We successfully read the CompObj stream
    hr = NOERROR;

errRtn:

    StmRead.Release();

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   StmToClipfmt, PRIVATE INTERNAL
//
//  Synopsis:   Reads the clipboard format from the given stream.  Caller
//              specifies whether or not the string format description,
//              if present, should be expected in ANSI or UNICODE format.
//
//  Effects:    If the clipboard format is a length followed by a
//              string, then the string is read and registered as a
//              clipboard format (and the new format number is returned).
//
//  Arguments:  [lpstream]      -- pointer to the stream
//              [lpdwCf]        -- where to put the clipboard format
//              [lpdTag]        -- format type (string, clip, etc)
//              [ttType]        -- text type TT_ANSI or TT_UNICODE
//
//  Returns:    hr
//
//  Algorithm:  the format of the stream must be one of the following:
//
//              0           No clipboard format
//              -1 DWORD    predefined windows clipboard format in
//                          the second dword.
//              -2 DWORD    predefined mac clipboard format in the
//                          second dword.  This may be obsolete or
//                          irrelevant for us.  REVIEW32
//              num STRING  clipboard format name string (prefaced
//                          by length of string).
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL StmToClipfmt
    (CStmBufRead & StmRead,
     DWORD     * lpdTag,
     DWORD     * lpdwCf,
     TXTTYPE     ttText)
{
    VDATEHEAP();

    HRESULT     hr;
    DWORD       dwValue;

    VDATEPTROUT(lpdwCf, DWORD);

    Win4Assert (lpdwCf);            // These ptrs are always required
    Win4Assert (lpdTag);

    // Read the format type tag from the stream

    if (FAILED(hr = StmRead.Read(&dwValue, sizeof(DWORD))))
    {
        return hr;
    }

    *lpdTag = dwValue;

    // If the tag is zero, there is no clipboard format info

    if (dwValue == 0)
    {
        *lpdwCf = 0;            // NULL cf value
    }

    // If it is -1, then it is a standard Windows clipboard format

    else if (dwValue == -1L)
    {
        // Then this is a NON-NULL predefined windows clipformat.
        // The clipformat values follows

        if (FAILED(hr = StmRead.Read(&dwValue, sizeof(DWORD))))
        {
            return hr;
        }
        *lpdwCf = dwValue;
    }

    // If it is -2, it is a MAC format

    else if (dwValue == -2L)
    {
        // Then this is a NON-NULL MAC clipboard format.
        // The clipformat value follows. For MAC the CLIPFORMAT
        // is 4 bytes

        if (FAILED(hr = StmRead.Read(&dwValue, sizeof(DWORD))))
        {
            return hr;
        }
        *lpdwCf = dwValue;
        return ResultFromScode(OLE_S_MAC_CLIPFORMAT);
    }

    // Anything but a 0, -1, or -2 indicates a string is to follow, and the
    // DWORD we already read is the length of the that string

    else
    {
        // Allocate enough memory for whatever type of string it is
        // we expect to find, and read the string

        if (dwValue > MAX_CFNAME)
        {
                return ResultFromScode(DV_E_CLIPFORMAT);
        }

        if (TT_ANSI == ttText)          // READ ANSI
        {
            char szCf[MAX_CFNAME+1] = {0};

            if (FAILED(hr = StmRead.Read(szCf, dwValue)))
            {
                return hr;
            }

            // Try to register the clipboard format and return the result
            // (Note: must explicitly call ANSI version)

            if (((*lpdwCf = (DWORD) SSRegisterClipboardFormatA(szCf))) == 0)
            {
                return ResultFromScode(DV_E_CLIPFORMAT);
            }
        }
        else                // READ UNICODE
        {
            OLECHAR wszCf[MAX_CFNAME+1] = {0};

            Win4Assert(dwValue < MAX_CFNAME);
            if (FAILED(hr=StmRead.Read(wszCf, dwValue * sizeof(OLECHAR))))
            {
                return hr;
            }

            // Try to register the clipboard format and return the result

            if (((*lpdwCf = (DWORD) RegisterClipboardFormat(wszCf))) == 0)
            {
                return ResultFromScode(DV_E_CLIPFORMAT);
            }
        }
    }
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetUNICODEUserType, PRIVATE INTERNAL
//
//  Synopsis:   Given a CompObjStmData object, returns the User Type
//              in UNICODE format, converting the ANSI rep as required.
//
//  Effects:    Allocates memory on the caller's ptr to hold the string
//
//  Arguments:  [pcod]      -- The CompObjStmData object
//              [pstr]      -- Pointer to allocate resultant string on
//
//  Returns:    NOERROR         on success
//              E_OUTOFMEMORY   on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL GetUNICODEUserType
    ( CompObjStmData * pcod,
      LPOLESTR       * pstr )
{
    VDATEHEAP();
    HRESULT hr = NOERROR;

    // Validate and NULL the OUT parameter, or return if none given
    if (pstr)
    {
        VDATEPTROUT(pstr, LPOLESTR);
        *pstr = NULL;
    }
    else
    {
        return(NOERROR);
    }

    // Either get the UNICODE string, or convert the ANSI version and
    // get it as UNICODE.

    if (pcod->m_cchUserType)
    {
        hr = UtGetUNICODEData( pcod->m_cchUserType,
                            pcod->m_pszAUserType,
                            pcod->m_pszOUserType,
                                            pstr );
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetUNICODEProgID, PRIVATE INTERNAL
//
//  Synopsis:   Given a CompObjStmData object, returns the ProgID string
//              in UNICODE format, converting the ANSI rep as required.
//
//  Effects:    Allocates memory on the caller's ptr to hold the string
//
//  Arguments:  [pcod]      -- The CompObjStmData object
//              [pstr]      -- Pointer to allocate resultant string on
//
//  Returns:    NOERROR         on success
//              E_OUTOFMEMORY   on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL GetUNICODEProgID
    ( CompObjStmData * pcod,
      LPOLESTR       * pstr )
{
    VDATEHEAP();
    HRESULT hr = NOERROR;

    // Validate and NULL the OUT parameter, or return if none given
    if (pstr)
    {
        VDATEPTROUT(pstr, LPOLESTR);
        *pstr = NULL;
    }
    else
    {
        return(NOERROR);
    }

    // Either get the UNICODE string, or convert the ANSI version and
    // get it as UNICODE.

    if (pcod->m_cchProgID)
    {
        hr = UtGetUNICODEData( pcod->m_cchProgID,
                            pcod->m_pszAProgID,
                            pcod->m_pszOProgID,
                                          pstr );
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClipFormat, PRIVATE INTERNAL
//
//  Synopsis:   Given a CompObjStmData object, extracts the clipboard format
//              type (none, standard, string).
//
//  Effects:    If string type, memory is allocated on the caller's ptr
//
//  Arguments:  [pcod]          -- The CompObjStmData object to extract from
//              [pdwFormatID]   -- Tag type OUT parameter
//              [pdwFormatTag]  -- Tag OUT parameter
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failures
//              OLE_S_MAC_CLIPFORMAT as a warning that a MAC fmt is returned
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL GetClipFormat
    ( CompObjStmData * pcod,
      DWORD          * pdwFormatID,
      DWORD          * pdwFormatTag )
{
    VDATEHEAP();
    *pdwFormatTag = (DWORD) pcod->m_dwFormatTag;
    *pdwFormatID = pcod->m_ulFormatID;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   PutUNICODEUserType, PRIVATE INTERNAL
//
//  Synopsis:   Given a UNICODE string, stores it in the CompObjDataStm
//              object in ANSI if possible.  If the UNICODE -> ANSI
//              conversion is not possible, it is stored in the object
//              in UNICODE.
//
//  Notes:      Input string is duplicated, so it adds no references
//              to the string passed in.
//
//  Arguments:  [pcod]           -- The CompObjDataStm object
//              [szUser]         -- The UNICODE UserType string
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL PutUNICODEUserType(CompObjStmData * pcod, LPOLESTR szUser)
{
    VDATEHEAP();

    HRESULT hr;

    // If no string supplied, clear UserType fields, otherwise
    // if it can be converted to ANSI, store it an ANSI.  Last
    // resort, store it as UNICODE.

    if (NULL == szUser)
    {
        pcod->m_cchUserType = 0;

        PubMemFree(pcod->m_pszAUserType);
        PubMemFree(pcod->m_pszOUserType);
        pcod->m_pszAUserType = NULL;
        pcod->m_pszOUserType = NULL;
    }
    else
    {
        if (FAILED(hr = UtPutUNICODEData( _xstrlen(szUser)+1,
                                                   szUser,
                                    &pcod->m_pszAUserType,
                                    &pcod->m_pszOUserType,
                                    &pcod->m_cchUserType )))
        {
            return(hr);
        }

    }
    return(NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   PutUNICODEProgID, PRIVATE INTERNAL
//
//  Synopsis:   Given a UNICODE string, stores it in the CompObjDataStm
//              object in ANSI if possible.  If the UNICODE -> ANSI
//              conversion is not possible, it is stored in the object
//              in UNICODE.
//
//  Notes:      Input string is duplicated, so it adds no references
//              to the string passed in.
//
//  Arguments:  [pcod]           -- The CompObjDataStm object
//              [szProg]         -- The UNICODE ProgID string
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------


INTERNAL PutUNICODEProgID(CompObjStmData * pcod, LPOLESTR szProg)
{
    VDATEHEAP();

    HRESULT hr;

    // If no string supplied, clear ProgID fields, otherwise
    // if it can be converted to ANSI, store it an ANSI.  Last
    // resort, store it as UNICODE.

    if (NULL == szProg)
    {
        pcod->m_cchProgID = 0;
        PubMemFree(pcod->m_pszAProgID);
        PubMemFree(pcod->m_pszOProgID);
        pcod->m_pszAProgID = NULL;
        pcod->m_pszOProgID = NULL;
    }
    else
    {
        if (FAILED(hr = UtPutUNICODEData( _xstrlen(szProg)+1,
                                                   szProg,
                                      &pcod->m_pszAProgID,
                                      &pcod->m_pszOProgID,
                                       &pcod->m_cchProgID )))
        {
            return(hr);
        }

    }
    return(NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   PutClipFormat
//
//  Synopsis:   Stores the clipformat in the internal data structure
//
//  Effects:    Input string is duplicated as required, so no references are
//              kept by this function.
//
//  Arguments:  [pcod]          -- The CompObjStmData object
//              [dwFormatTag]   -- Format tag (string, clipboard, none)
//              [ulFormatID]    -- If format tag is clipboard, what format
//
//  Returns:    NOERROR              on success
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL PutClipFormat
    ( CompObjStmData * pcod,
      DWORD            dwFormatTag,
      ULONG            ulFormatID
    )
{
    VDATEHEAP();
    pcod->m_dwFormatTag = (ULONG) dwFormatTag;
    pcod->m_ulFormatID = ulFormatID;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   WriteCompObjStm, PRIVATE INTERNAL
//
//  Synopsis:   Writes CompObjStmData object to the CompObj stream in
//              the IStorage provided.
//
//              First the ANSI fields are written (including the ProgID),
//              followed by a MagicNumber, followed by whatever OLESTR
//              versions were required because ANSI fields could not be
//              converted.
//
//              Destroys any existing CompObj stream!
//
//  Arguments:  [pstg]      -- The IStorage to write the stream to
//              [pcod]      -- The CompObjStmData object to write out
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//              Various I/O          on stream failures
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL WriteCompObjStm(IStorage * pstg, CompObjStmData * pcod)
{
    VDATEHEAP();

    HRESULT         hr          = NOERROR;
    const ULONG     RESERVED    = 0;
    const ULONG     ulMagic     = COMP_OBJ_MAGIC_NUMBER;
    CStmBufWrite    StmWrite;


    // The CompObjStmData parameter must be supplied
    if (NULL == pcod)
    {
        return ResultFromScode(E_INVALIDARG);
    }

    VDATEIFACE(pstg);

    // Open the CompObj stm for writing (and overwrite it if
    // if already exists, which is why we _don't_ specify the
    // STGM_FAILIFTHERE flag)

    if (FAILED(hr = StmWrite.CreateStream(pstg, COMPOBJ_STREAM)))
    {
        goto errRtn;
    }

    // Set up the header

    pcod->m_hdr.m_dwFirstDword = gdwFirstDword;

    // The OSVer _must_ be Win 3.10 (0a03), since the old DLL will bail if
    // it finds anything else.

    pcod->m_hdr.m_dwOSVer      = 0x00000a03;     // gdwOrgOSVersion;
    pcod->m_hdr.m_unused       = (DWORD) -1;

    if (ReadClassStg(pstg, &pcod->m_hdr.m_clsClass) != NOERROR)
    {
        pcod->m_hdr.m_clsClass = CLSID_NULL;
    }

    // Write the CompObj stream header

    Win4Assert(sizeof(CompObjHdr) == 28 &&
               "Warning: possible packing error in CompObjHdr struct");

    if (FAILED(hr = StmWrite.Write(pcod, sizeof(CompObjHdr))))
    {
        goto errRtn;
    }

    // Write the ANSI UserType

    if (FAILED(hr = ANSIStrToStm(StmWrite, pcod->m_pszAUserType)))
    {
        goto errRtn;
    }

    if (TT_ANSI == pcod->ttClipString)
    {
        if (FAILED(hr = ClipfmtToStm(StmWrite,     // the stream
                             pcod->m_dwFormatTag,  // format tag
                              pcod->m_ulFormatID,  // format ID
                                         TT_ANSI)))// TRUE==use ANSI
        {
            goto errRtn;
        }
    }
    else
    {
        const ULONG ulDummy = 0;
        if (FAILED(hr = StmWrite.Write(&ulDummy, sizeof(ULONG))))
        {
            goto errRtn;
        }
    }

    // Write the ANSI ProgID

    if (FAILED(hr = ANSIStrToStm(StmWrite, pcod->m_pszAProgID)))
    {
        goto errRtn;
    }

    // Write the Magic Number

    if (FAILED(hr = StmWrite.Write(&ulMagic, sizeof(ULONG))))
    {
        goto errRtn;
    }

    // Write the OLESTR version of UserType

    if (FAILED(hr = WriteStringStream(StmWrite, pcod->m_pszOUserType)))
    {
        goto errRtn;
    }

    // If we have to write a UNICODE clipformat string, do it now.  If
    // ANSI was sufficient, just write a 0 to the stream here.

    if (TT_UNICODE == pcod->ttClipString)
    {
        if (FAILED(hr = ClipfmtToStm(StmWrite,      // the stream
                             pcod->m_dwFormatTag,   // format tag
                              pcod->m_ulFormatID,   // format ID
                                      TT_UNICODE))) // FALSE==use UNICODE
        {
            goto errRtn;
        }
    }
    else
    {
        const ULONG ulDummy = 0;
        if (FAILED(hr = StmWrite.Write(&ulDummy, sizeof(ULONG))))
        {
            goto errRtn;
        }
    }

    // Write the OLESTR version of ProgID

    if (FAILED(hr = WriteStringStream(StmWrite, pcod->m_pszOProgID)))
    {
        goto errRtn;
    }

    hr = StmWrite.Flush();

    // That's it.. clean up and exit

errRtn:

    StmWrite.Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ClipFtmToStm, PRIVATE INTERNAL
//
//  Synopsis:   Writes out the clipboard format information at the
//              current point in the stream.  A flag is available
//              to specify whether or not the string format desc
//              (if present) is in ANSI or UNICODE format.
//
//  Arguments:  [pstm]          -- the stream to write to
//              [dwFormatTag]   -- format tag (string, clipfmt, etc)
//              [ulFormatID]    -- if clipfmt, which one
//              [szClipFormat]  -- if string format, the string itself
//              [ttText]        -- text type: TT_ANSI or TT_UNICODE
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL ClipfmtToStm
    ( CStmBufWrite & StmWrite,
      DWORD         dwFormatTag,
      ULONG         ulFormatID,
      TXTTYPE       ttText )

{
    VDATEHEAP();

    HRESULT hr;

    const ULONG ulDummy = 0;
    switch((DWORD)dwFormatTag)
    {

    // If the tag is 0, there is no clipboard format info.

    case 0:

        if (FAILED(hr = StmWrite.Write(&ulDummy, sizeof(ULONG))))
        {
            return(hr);
        }

        return(NOERROR);

    // In the -1 and -2 cases (yes, I wish there were constants too) all we
    // need to write is the format ID

    case -1:
    case -2:

        // Write the format tag to the stream
        if (FAILED(hr = StmWrite.Write(&dwFormatTag, sizeof(dwFormatTag))))
        {
                return hr;
        }
        return(StmWrite.Write(&ulFormatID, sizeof(ulFormatID)));


    // In all other cases, we need to write the string raw with termination
    // (ie: the format tag we've already written was the length).

    default:


        if (TT_ANSI == ttText)
        {
            char szClipName[MAX_CFNAME+1] = {0};
            int cbLen = SSGetClipboardFormatNameA(ulFormatID, szClipName, MAX_CFNAME);
            if (cbLen == 0)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
            cbLen++;    // Account for NULL terminator
            szClipName[cbLen] = '\0';
            // Write the format tag to the stream
            if (FAILED(hr = StmWrite.Write(&cbLen, sizeof(cbLen))))
            {
                return hr;
            }

            return (StmWrite.Write(szClipName, cbLen));

        }
        else
        {
            OLECHAR wszClipName[MAX_CFNAME+1] = {0};
            int ccLen = GetClipboardFormatName(ulFormatID, wszClipName, MAX_CFNAME);
            if (ccLen == 0)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
            ccLen++;    // Account for NULL terminator
            wszClipName[ccLen] = OLESTR('\0');

            // Write the format tag to the stream
            if (FAILED(hr = StmWrite.Write(&ccLen, sizeof(ccLen))))
            {
                return hr;
            }

            return (StmWrite.Write(wszClipName, ccLen*sizeof(OLECHAR)));
        }

    } // end switch()
}

//+-------------------------------------------------------------------------
//
//  Function:   ANSIStrToStm, PRIVATE INTERNAL
//
//  Synopsis:   Writes an ANSI string out to a stream, preceded by a ULONG
//              indicating its length (INCLUDING TERMINATOR).  If the
//              string is 0-length, or a NULL ptr is passed in, just
//              the length (0) is written, and no blank string is stored
//              in the stream.
//
//  Arguments:  [pstm]          -- the stream to write to
//              [str]           -- the string to write
//
//
//
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL ANSIStrToStm(CStmBufWrite & StmWrite, LPCSTR str)
{
    VDATEHEAP();

    HRESULT hr;
    ULONG ulDummy = 0;
    ULONG ulLen;

    // If the pointer is NULL or if it is valid but points to
    // a 0-length string, _just_ write the 0-length, but no
    // string.

    if (NULL == str || (ulLen = (ULONG) strlen(str) + 1) == 1)
    {
        return(StmWrite.Write(&ulDummy, sizeof(ulDummy)));
    }

    if (FAILED(hr = StmWrite.Write(&ulLen, sizeof(ulLen))))
    {
        return(hr);
    }

    return StmWrite.Write(str, ulLen);

}

//+-------------------------------------------------------------------------
//
//  Function:   ANSIStmToStr, PRIVATE INTERNAL
//
//  Synopsis:   Reads a string from a stream, which is preceded by a ULONG
//              giving its length.  If the string OUT parameter is NULL,
//              the string is read but not returned.  If the parameter is
//              a valid pointer, memory is allocated on it to hold the str.
//
//  Arguments:  [pstm]          -- the stream to write to
//              [pstr]          -- the caller's string pointer
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL ANSIStmToStr(CStmBufRead & StmRead, LPSTR * pstr, ULONG * pulLen)
{
    VDATEHEAP();
    LPSTR szTmp = NULL;
    ULONG ulTmp;
    HRESULT hr;

    if (pstr)
    {
        VDATEPTROUT(pstr, LPSTR);
        *pstr = NULL;
    }

    if (pulLen)
    {
        VDATEPTROUT(pulLen, ULONG *);
        *pulLen = 0;
    }

    // Find out how many bytes are to follow as a string

    if (FAILED(hr = StmRead.Read(&ulTmp, sizeof(ulTmp))))
    {
        return(hr);
    }

    // If none, we can just return now

    if (0 == ulTmp)
    {
        return(NOERROR);
    }

    if (pulLen)
    {
        *pulLen = ulTmp;
    }

    // Allocate a buffer to read the string into

    szTmp = (LPSTR) PubMemAlloc(ulTmp);
    if (NULL == szTmp)
    {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    if (FAILED(hr = StmRead.Read(szTmp, ulTmp)))
    {
        PubMemFree(szTmp);
        return(hr);
    }

    // If the caller wanted the string, assign it over, otherwise
    // just free it now.

    if (pstr)
    {
        *pstr = szTmp;
    }
    else
    {
        PubMemFree(szTmp);
    }

    return(NOERROR);

}

//+-------------------------------------------------------------------------
//
//  Function:   ReadFmtUserTypeStg
//
//  Synopsis:   Read ClipFormat, UserType from CompObj stream
//
//  Arguments:  [pstg] -- storage containing CompObj stream
//              [pcf]  -- place holder for clip format, may be NULL
//              [ppszUserType] -- place holder for User Type, may be NULL
//
//  Returns:    If NOERROR, *pcf is clip format and *ppszUserType is User Type
//              If ERROR, *pcf is 0 and *ppszUserType is NULL
//
//  Modifies:
//
//  Algorithm:
//
//  History:    ??-???-?? ?         Ported
//              15-Jul-94 AlexT     Make sure *pcf & *pszUserType are clear
//                                  on error
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI ReadFmtUserTypeStg
    ( IStorage   * pstg,
      CLIPFORMAT * pcf,
      LPOLESTR   * ppszUserType )
{
    OLETRACEOUTEX((API_ReadFmtUserTypeStg,
                        PARAMFMT("pstg= %p, pcf= %p, ppszUserType= %p"),
                        pstg, pcf, ppszUserType));

    VDATEHEAP();
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);

    HRESULT hr;
    CompObjStmData cod;

    do
    {
        // Read the CompObj stream
        hr = ReadCompObjStm(pstg, &cod);
        if (FAILED(hr))
        {
            //  clean up and return
            break;
        }

        // Extract the clipboard format
        if (NULL != pcf)
        {
            ULONG ulFormatID  = 0;
            DWORD dwFormatTag = 0;

            if (FAILED(hr = GetClipFormat(&cod, &ulFormatID, &dwFormatTag))
                && GetScode(hr) != OLE_S_MAC_CLIPFORMAT)
            {
                //  clean up and return
                break;
            }

            *pcf = (CLIPFORMAT) ulFormatID;
        }

        // Extract the User Type
        if (NULL != ppszUserType)
        {
            if (FAILED(hr = GetUNICODEUserType(&cod, ppszUserType)))
            {
                //  clean up and return
                break;
            }
        }

        hr = S_OK;
    } while (FALSE);

    if (FAILED(hr))
    {
        //  Make sure the out parameters are zeroed out in the failure case

        if (NULL != pcf)
        {
            *pcf = 0;
        }

        if (NULL != ppszUserType)
        {
            *ppszUserType = NULL;
        }
    }

    OLETRACEOUT((API_ReadFmtUserTypeStg, hr));

    return(hr);
}

STDAPI ReadFmtProgIdStg
    ( IStorage   * pstg,
      LPOLESTR   * pszProgID )
{
    VDATEHEAP();

    HRESULT hr;
    CompObjStmData cod;

    // Read the CompObj stream
    if (FAILED(hr = ReadCompObjStm(pstg, &cod)))
    {
        return(hr);

    }

    // Extract the User Type
    if (pszProgID)
    {
        if (FAILED(hr = GetUNICODEProgID(&cod, pszProgID)))
        {
            return(hr);
        }
    }
    return(NOERROR);
}



STDAPI WriteFmtUserTypeStg
    ( LPSTORAGE     pstg,
      CLIPFORMAT    cf,
      LPOLESTR      szUserType)
{
    OLETRACEIN((API_WriteFmtUserTypeStg, PARAMFMT("pstg= %p, cf= %x, szUserType= %ws"),
        pstg, cf, szUserType));

    VDATEHEAP();
    HRESULT hr;
    CompObjStmData cod;
    CLSID clsid;
    LPOLESTR szProgID = NULL;

    VDATEIFACE_LABEL(pstg, errRtn, hr);

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);


    // Read the CompObj stream.  If it's not there, we don't care,
    // we'll build a new one.  Some errors, such as E_OUTOFMEMORY, cannot
    // be overlooked, so we must return them.

    if (FAILED(hr = ReadCompObjStm(pstg, &cod)))
    {
        if (hr == ResultFromScode(E_OUTOFMEMORY))
        {
            goto errRtn;
        }
    }

    // Set the User Type in the Object.

    if (szUserType)
    {
        if (FAILED(hr = PutUNICODEUserType(&cod, szUserType)))
        {
            goto errRtn;
        }
    }

    // Set the ProgID field

    if (ReadClassStg(pstg, &clsid) != NOERROR)
    {
            clsid = CLSID_NULL;
    }

    if (SUCCEEDED(ProgIDFromCLSID (clsid, &szProgID)))
    {
        PutUNICODEProgID(&cod, szProgID);
    }

    if (szProgID)
    {
        PubMemFree(szProgID);
    }

    // Set the clipboard format.  0xC000 is a magical constant which
    // bounds the standard clipboard format type IDs

    if (cf < 0xC000)
    {
        if (0 == cf)
        {
                PutClipFormat(&cod, 0, 0);      // NULL format
        }
        else
        {
                PutClipFormat(&cod, (DWORD)-1, cf); // Standard format
        }
    }
    else
    {
        PutClipFormat(&cod, MAX_CFNAME, cf);    // Custom format

    }

    // Now we have all the info in the CompObjData object.
    // Now we can write it out to the stream as a big atomic object.

    if (FAILED(hr = WriteCompObjStm(pstg, &cod)))
    {
        if (hr == ResultFromScode(E_OUTOFMEMORY))
        {
            goto errRtn;
        }
    }

    hr = NOERROR;

errRtn:
    OLETRACEOUT((API_WriteFmtUserTypeStg, hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\base\ole2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ole2.cpp
//
//  Contents:   LibMain and initialization routines
//
//  Classes:
//
//  Functions:  LibMain
//              OleInitialize
//              OleInitializeWOW
//              OleInitializeEx
//              OleUnitialize
//              OleBuildVersion - !WIN32
//
//
//  History:    dd-mmm-yy Author    Comment
//              16-Feb-94 AlexT     alias OleBuildVersion, remove OleGetMalloc
//                                  remove DisableThreadLibaryCalls
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              10-Dec-93 alexgo    added support for LEDebugOut
//              06-Dec-93 ChrisWe   remove declaration of ClipboardInitialize()
//                      and ClipboardUninitialize(), which are declared in
//                      clipbrd.h; include that instead
//              15-Mar-94 KevinRo   Added OleInitializeWOW();
//
//--------------------------------------------------------------------------


#include <le2int.h>
#include <clipbrd.h>
#include <dragopt.h>
#include <drag.h>

#pragma SEG(ole)

#include <olerem.h>
#include <ole2ver.h>
#include <thunkapi.hxx>
#include <olesem.hxx>

#include <verify.hxx>

//
// DECLARE_INFOLEVEL is a macro used with cairo-style debugging output.
// it creates a global variable LEInfoLevel which contains bits flags
// of the various debugging output that should be sent to the debugger.
//
// Note that info level may be set within the debugger once ole232.dll
// has loaded.
//
// Currently LEInfoLevel defaults to DEB_WARN | DEB_ERROR
//
DECLARE_INFOLEVEL(LE);
DECLARE_INFOLEVEL(Ref);
DECLARE_INFOLEVEL(DD);
DECLARE_INFOLEVEL(VDATE);

NAME_SEG(Ole2Main)
// these are globals

HMODULE         g_hmodOLE2 = NULL;
HINSTANCE       g_hinst = NULL;
ULONG           g_cOleProcessInits = 0;

CLIPFORMAT      g_cfObjectLink = NULL;
CLIPFORMAT      g_cfOwnerLink = NULL;
CLIPFORMAT      g_cfNative = NULL;
CLIPFORMAT      g_cfLink = NULL;
CLIPFORMAT      g_cfBinary = NULL;
CLIPFORMAT      g_cfFileName = NULL;
CLIPFORMAT      g_cfFileNameW = NULL;
CLIPFORMAT      g_cfNetworkName = NULL;
CLIPFORMAT      g_cfDataObject = NULL;
CLIPFORMAT      g_cfEmbeddedObject = NULL;
CLIPFORMAT      g_cfEmbedSource = NULL;
CLIPFORMAT      g_cfCustomLinkSource = NULL;
CLIPFORMAT      g_cfLinkSource = NULL;
CLIPFORMAT      g_cfLinkSrcDescriptor = NULL;
CLIPFORMAT      g_cfObjectDescriptor = NULL;
CLIPFORMAT      g_cfOleDraw = NULL;
CLIPFORMAT      g_cfPBrush = NULL;
CLIPFORMAT      g_cfMSDraw = NULL;
CLIPFORMAT      g_cfOlePrivateData = NULL;
CLIPFORMAT      g_cfScreenPicture = NULL;
CLIPFORMAT      g_cfOleClipboardPersistOnFlush= NULL;
CLIPFORMAT      g_cfMoreOlePrivateData = NULL;

ATOM            g_aDropTarget = NULL;
ATOM            g_aDropTargetMarshalHwnd = NULL;

ASSERTDATA

ASSERTOUTDATA

// more globals

extern UINT     uOmPostWmCommand;
extern UINT     uOleMessage;
extern COleStaticMutexSem g_mxsSingleThreadOle;


// this dummy function is used to avoid a copy of the environment variables.
// NOTE: the moniker and dde code still use the windows heap.

extern "C" void _setenvp(void) {
        VDATEHEAP();
 }


//+---------------------------------------------------------------------------
//
//  Function:   OleInitializeWOW
//  Synopsis:   Entry point to initialize the 16-bit WOW thunk layer.
//
//  Effects:    This routine is called when OLE32 is loaded by a VDM.
//              It serves two functions: It lets OLE know that it is
//              running in a VDM, and it passes in the address to a set
//              of functions that are called by the thunk layer. This
//              allows normal 32-bit processes to avoid loading the WOW
//              DLL since the thunk layer references it.
//
//  Arguments:  [vlpmalloc] -- 16:16 pointer to the 16 bit allocator.
//              [lpthk] -- Flat pointer to the OleThunkWOW virtual
//                         interface. This is NOT an OLE/IUnknown style
//                         interface.
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-15-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleInitializeWOW( LPMALLOC vlpmalloc, LPOLETHUNKWOW lpthk )
{
    OLETRACEIN((API_OleInitializeWOW, PARAMFMT("vlpmalloc= %x, lpthk= %p"),
                                                                                vlpmalloc, lpthk));

    SetOleThunkWowPtr(lpthk);

    HRESULT hr;

    hr = OleInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    OLETRACEOUT((API_OleInitializeWOW, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleInitialize
//
//  Synopsis:   Initializes OLE in single threaded mode
//
//  Effects:
//
//  Arguments:  [pMalloc]       -- the memory allocator to use
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI OleInitialize(void * pMalloc)
{
    OLETRACEIN((API_OleInitialize, PARAMFMT("pMalloc= %p"), pMalloc));

    VDATEHEAP();

    HRESULT hr;

    hr = OleInitializeEx( pMalloc, COINIT_APARTMENTTHREADED );

    OLETRACEOUT((API_OleInitialize, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleInitializeEx
//
//  Synopsis:   Initializes ole
//
//  Effects:
//
//  Arguments:  [pMalloc]       -- the task memory allocator to use
//              [flags]         -- single or multi-threaded
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Dec-93 alexgo    32bit port
//              24-May-94 AlexT     Propagate CoInitializeEx's return code
//              21-Jul-94 AlexT     Allow nested OleInit/Uninit calls
//              24-Aug-94 AlexT     Return S_OK for first success and S_FALSE
//                                  thereafter (unless an allocator was
//                                  passed in)
//              14-Aug-96 SatishT   Changed the test for notification of Explorer
//                                  to only use the gfShellInitialized flag
//
//  Notes:      This routine may be called multiple times per apartment
//
//--------------------------------------------------------------------------
#pragma SEG(OleInitialize)
STDAPI OleInitializeEx(LPVOID pMalloc, ULONG ulFlags)
{
    OLETRACEIN((API_OleInitialize, PARAMFMT("pMalloc= %p, ulFlags= %x"), pMalloc, ulFlags));
    VDATEHEAP();

    HRESULT hr;
#if DBG==1
    HRESULT hrCoInit = S_OK;
#endif
    DWORD cThreadOleInits;

    hr = CoInitializeEx(pMalloc, ulFlags);

    if (SUCCEEDED(hr))
    {
        Assert (g_hmodOLE2);
#if DBG==1
        hrCoInit = hr;
#endif

        COleTls tls;
        cThreadOleInits = ++ tls->cOleInits;

        do
        {
            // We only want to do the below initialization once per apartment
            if (cThreadOleInits > 1)
            {
                // We've already been this way before, just return
                Assert(SUCCEEDED(hr) && "Bad OleInitializeEx logic");
                break;
            }

            // single thread registration of DDE and clipboard formats.
            // Only do this once per process.

            COleStaticLock lck(g_mxsSingleThreadOle);

            if (++g_cOleProcessInits != 1)
            {
                // already done the per-process initialization
                break;
            }

            // initialized DDE only if any server objects have
            // already been registered.
            hr = CheckInitDde(FALSE);
            if (FAILED(hr))
            {
                Assert (!"DDELibMain failed()");
                break;
            }

            // Only need to do the initialization once so check the global
            // that gets assigned last.

            if( !g_aDropTarget )
            {
                // on NT3.51, clipboard formats are pre-registered for us by user32.
                // (This is done in file \ntuser\kernel\server.c.)
                // We know they are going to be sequential.  This gives us a
                // good performance improvement (since the clipboard formats never
                // change.

                g_cfObjectLink = (CLIPFORMAT) RegisterClipboardFormat(OLESTR("ObjectLink"));

                g_cfOwnerLink = g_cfObjectLink + 1;
                Assert(g_cfOwnerLink == RegisterClipboardFormat(OLESTR("OwnerLink")));

                g_cfNative = g_cfObjectLink + 2;
                Assert(g_cfNative == RegisterClipboardFormat(OLESTR("Native")));

                g_cfBinary = g_cfObjectLink + 3;
                Assert(g_cfBinary == RegisterClipboardFormat(OLESTR("Binary")));

                g_cfFileName = g_cfObjectLink + 4;
                Assert(g_cfFileName == RegisterClipboardFormat(OLESTR("FileName")));

                g_cfFileNameW = g_cfObjectLink + 5;
                Assert(g_cfFileNameW ==
                        RegisterClipboardFormat(OLESTR("FileNameW")));

                g_cfNetworkName = g_cfObjectLink + 6;
                Assert(g_cfNetworkName  ==
                        RegisterClipboardFormat(OLESTR("NetworkName")));

                g_cfDataObject = g_cfObjectLink + 7;
                Assert(g_cfDataObject ==
                        RegisterClipboardFormat(OLESTR("DataObject")));

                g_cfEmbeddedObject = g_cfObjectLink + 8;
                Assert(g_cfEmbeddedObject ==
                        RegisterClipboardFormat(OLESTR("Embedded Object")));

                g_cfEmbedSource = g_cfObjectLink + 9;
                Assert(g_cfEmbedSource ==
                        RegisterClipboardFormat(OLESTR("Embed Source")));

                g_cfCustomLinkSource = g_cfObjectLink + 10;
                Assert(g_cfCustomLinkSource  ==
                        RegisterClipboardFormat(OLESTR("Custom Link Source")));

                g_cfLinkSource = g_cfObjectLink + 11;
                Assert(g_cfLinkSource ==
                        RegisterClipboardFormat(OLESTR("Link Source")));

                g_cfObjectDescriptor = g_cfObjectLink + 12;
                Assert(g_cfObjectDescriptor ==
                        RegisterClipboardFormat(OLESTR("Object Descriptor")));

                g_cfLinkSrcDescriptor = g_cfObjectLink + 13;
                Assert(g_cfLinkSrcDescriptor ==
                        RegisterClipboardFormat(OLESTR("Link Source Descriptor")));

                g_cfOleDraw = g_cfObjectLink + 14;
                Assert(g_cfOleDraw == RegisterClipboardFormat(OLESTR("OleDraw")));

                g_cfPBrush = g_cfObjectLink + 15;
                Assert(g_cfPBrush == RegisterClipboardFormat(OLESTR("PBrush")));

                g_cfMSDraw = g_cfObjectLink + 16;
                Assert(g_cfMSDraw == RegisterClipboardFormat(OLESTR("MSDraw")));

                g_cfOlePrivateData = g_cfObjectLink + 17;
                Assert(g_cfOlePrivateData ==
                        RegisterClipboardFormat(OLESTR("Ole Private Data")));

                g_cfScreenPicture = g_cfObjectLink + 18;
                Assert(g_cfScreenPicture  ==
                    RegisterClipboardFormat(OLESTR("Screen Picture")));

                g_cfOleClipboardPersistOnFlush = g_cfObjectLink + 19;

                /* turned off till NtUser group checks in for 335613 
                Assert(g_cfOleClipboardPersistOnFlush ==
                    RegisterClipboardFormat(OLESTR("OleClipboardPersistOnFlush")));
                */

                g_cfMoreOlePrivateData = g_cfObjectLink + 20;

                /* turned off till NtUser group checks in for 335613 
                Assert(g_cfMoreOlePrivateData ==
                    RegisterClipboardFormat(OLESTR("MoreOlePrivateData")));
                */

                g_aDropTarget = GlobalAddAtom(OLE_DROP_TARGET_PROP);
                AssertSz(g_aDropTarget, "Couldn't add drop target atom\n");

                g_aDropTargetMarshalHwnd = GlobalAddAtom(OLE_DROP_TARGET_MARSHALHWND);
                AssertSz(g_aDropTargetMarshalHwnd, "Couldn't add drop target hwnd atom\n");

            }

            // Used in Inplace editing
            uOmPostWmCommand = RegisterWindowMessage(OLESTR("OM_POST_WM_COMMAND"));
            uOleMessage      = RegisterWindowMessage(OLESTR("OLE_MESSAHE"));

        } while (FALSE); // end of do


        if (FAILED(hr))
        {
            // clean up and break out
            CheckUninitDde(FALSE);

            tls->cOleInits--;
            CoUninitialize();
        }
        else
        {
            Assert(SUCCEEDED(hr) && "Bad OleInitializeEx logic");

            //  If we're overriding the allocator, we return whatever
            //  CoInitializeEx returned

            if (NULL != pMalloc)
            {
                Assert(hr == hrCoInit && "Bad OleInit logic");
            }
            else if (1 == cThreadOleInits)
            {
                //  First successful call to OleInitializeEx - S_OK
                hr = S_OK;
            }
            else
            {
                //  Second or greater succesful call to OleInitializeEx - S_FALSE
                hr = S_FALSE;
            }

            // Notify the COM verifier about the oleinit, for tracking purposes.
            CoVrfNotifyOleInit();
        }
    }

    OLETRACEOUT((API_OleInitialize, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleUnitialize
//
//  Synopsis:   Unitializes OLE, releasing any grabbed resources
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Dec-93 alexgo    32bit port
//              21-Jul-94 AlexT     Allow nested OleInit/Uninit calls
//
//  Notes:
//
//--------------------------------------------------------------------------
#pragma SEG(OleUninitialize)
STDAPI_(void) OleUninitialize(void)
{
    OLETRACEIN((API_OleUninitialize, NOPARAM));

    VDATEHEAP();

    COleTls tls(TRUE);

    if (tls.IsNULL() || 0 == tls->cOleInits)
    {
        CoVrfNotifyExtraOleUninit();

        LEDebugOut((DEB_ERROR,
                    "(0 == thread inits) Unbalanced call to OleUninitialize\n"));
        goto errRtn;
    }

    if (0 == -- tls->cOleInits)
    {
        // This thread has called OleUninitialize for the last time. Check if
        // we need to do per process uninit now.

        ClipboardUninitialize(); // Must be first thing
        CheckUninitDde(FALSE);

        COleStaticLock lck(g_mxsSingleThreadOle);

        if (--g_cOleProcessInits == 0)
        {

            DragDropProcessUninitialize();

            // after this point, the uninit should not fail (because we don't
            // have code to redo the init).
            CheckUninitDde(TRUE);

#if DBG==1
            // check for unreleased globals
            UtGlobalFlushTracking();
#endif
        }
    }

    // Notify the COM verifier about the oleuninit, for tracking purposes.
    CoVrfNotifyOleUninit();

    //  We call CoInitialize each time we call OleInitialize, so here we
    //  balance that call
    CoUninitialize();

errRtn:
    OLETRACEOUTEX((API_OleUninitialize, NORETURN));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\cache\cachenod.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		   cachenode.cpp
//
//	Classes:
//		   CCacheNode
//
//	Functions:
//
//	History:
//                 Gopalk            Creation         Aug 23, 1996
//-----------------------------------------------------------------------------

#include <le2int.h>

#include <olepres.h>
#include <cachenod.h>

#include <mf.h>
#include <emf.h>
#include <gen.h>

// forward declaration
HRESULT wGetData(LPDATAOBJECT lpSrcDataObj, LPFORMATETC lpforetc,
                 LPSTGMEDIUM lpmedium);

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Initialize, private
//
//	Synopsis:
//		Routine used by the CCacheNode constructors to do common
//		initialization.
//
//	Arguments:
//		[advf] -- ADVF flag
//		[pOleCache] -- COleCache this cache node belongs to
//
//	Notes:
//		[pOleCache] is not reference counted; the cache node is
//		considered to be a part of the implementation of COleCache,
//		and is owned by COleCache.
//
//	History:
//              13-Feb-95 t-ScottH  initialize m_dwPresBitsPos and new
//                                  data member m_dwPresFlag
//		11/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
void CCacheNode::Initialize(DWORD advf, LPSTORAGE pStg)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::Initialize(%lx, %p)\n", 
                this, advf, pStg));

    // initialize member variables
    m_clsid = CLSID_NULL;
    m_advf = advf;
    m_lWidth = 0;
    m_lHeight = 0;
    m_dwFlags = 0;    
    m_pStg = pStg;
    m_iStreamNum = OLE_INVALID_STREAMNUM;
    m_dwPresBitsPos = 0;
    m_fConvert = FALSE;
    m_pPresObj = NULL;
    m_pPresObjAfterFreeze = NULL;
    m_pDataObject = NULL;
    m_dwAdvConnId = 0;
#ifdef _DEBUG
    m_dwPresFlag = 0;
#endif // _DEBUG

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::Initialize()\n", this));
    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		  CCacheNode::CCacheNode, public
//
//	Synopsis:
//                Constructor - use this constructor when the cache node is
//			to be loaded later
//
//	Arguments:
//		[pOleCache] -- pointer to the COleCache that owns this node
//
//	Notes:
//
//	History:
//		11/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
CCacheNode::CCacheNode()
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::CacheNode()\n", this));

    m_foretc.cfFormat = 0;
    m_foretc.ptd = NULL;
    m_foretc.dwAspect = 0;
    m_foretc.lindex = DEF_LINDEX;
    m_foretc.tymed = TYMED_HGLOBAL;

    Initialize(0, NULL);

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::CacheNode()\n", this));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::CCacheNode, public
//
//	Synopsis:
//		constructor - use this constructor when all the data to
//			initialize the cache node is available now
//
//	Arguments:
//		[lpFormatEtc] - the format for the presentation that this
//			cache node will hold
//		[advf] - the advise control flags, from ADVF_*
//		[pOleCache] -- pointer to the COleCache that owns this node
//
//	Notes:
//
//	History:
//		11/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
CCacheNode::CCacheNode(LPFORMATETC lpFormatEtc, DWORD advf, LPSTORAGE pStg)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::CacheNode(%p, %lx, %p)\n",
                this, lpFormatEtc, advf, pStg));

    UtCopyFormatEtc(lpFormatEtc, &m_foretc);
    BITMAP_TO_DIB(m_foretc);
    Initialize(advf, pStg);

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::CacheNode()\n", this));
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::~CCacheNode, private
//
//	Synopsis:
//		destructor
//
//	Notes:
//
//	History:
//		11/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
CCacheNode::~CCacheNode()
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::~CacheNode()\n", this ));
   
    // Destroy the presentation objects
    if(m_pPresObj) {
        m_pPresObj->Release();
        m_pPresObj = NULL;
    }
    if(m_pPresObjAfterFreeze) {
        m_pPresObjAfterFreeze->Release();
        m_pPresObjAfterFreeze = NULL;
    }	

    // Delete the ptd if it is non-null
    if(m_foretc.ptd) {
        PubMemFree(m_foretc.ptd);
        m_foretc.ptd = NULL;
    }
    
    // Assert that there is no pending advise connection
    Win4Assert(!m_dwAdvConnId);
    if(m_dwAdvConnId) {
        Win4Assert(m_pDataObject);
        TearDownAdviseConnection(m_pDataObject);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::~CacheNode()\n", this));
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::SetStg, public
//
//	Synopsis:
//		Set storage in which the presentation gets saved
//
//	Arguments:
//		[pStg] -- Storage pointer
//
//	Returns:
//		OLE_E_ALREADY_INITIALIZED or NOERROR
//
//	History:
//               Gopalk            Creation        Aug 26, 1996
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::SetStg(LPSTORAGE pStg)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::SetStg(%p)\n", this, pStg));

    HRESULT error;
    if(m_pStg) {
        error = CO_E_ALREADYINITIALIZED;
        Win4Assert(FALSE);
    }
    else {
        // Save the storage without addref
        m_pStg = pStg;
        error = NOERROR;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::SetStg(%lx)\n", this, error));
    return(error);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Load, public
//
//	Synopsis:
//		Load a cache node from a stream; only loads the presentation
//		header. (REVIEW, need to see presentation object::Load)
//
//	Arguments:
//		[lpstream] -- the stream to load the presentation out of
//		[iStreamNum] -- the stream number
//
//	Returns:
//		REVIEW
//		DV_E_LINDEX, for invalid lindex in stream
//		S_OK
//
//	Notes:
//		As part of the loading, the presentation object gets created,
//		and loaded from the stream.
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::Load(LPSTREAM lpstream, int iStreamNum, BOOL fDelayLoad)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::Load(%lx, %d)\n",
                this, lpstream, iStreamNum));
    HRESULT error = NOERROR;

    if(IsNativeCache()) {
        // Native Cache node
        // Update state
        SetLoadedStateFlag();
        ClearFrozenStateFlag();

        // We make the conservative assumption that the native cache 
        // is not blank
        SetDataPresentFlag();
    }
    else {
        // Normal cache node.
        // Read the presentation stream header
        m_foretc.ptd = NULL;
        m_fConvert = FALSE;
        error = UtReadOlePresStmHeader(lpstream, &m_foretc, &m_advf, &m_fConvert);
        if(error==NOERROR) {
            // Set the starting position of pres object data
            SetPresBitsPos(lpstream, m_dwPresBitsPos);

            // Assume that the presentation is blank
            ClearDataPresentFlag();
            m_lWidth = 0;
            m_lHeight = 0;

            // Load desired state
            if(m_foretc.cfFormat) {
                if(fDelayLoad) {
                    DWORD dwBuf[4];

                    // Read the extent and size of presentation data
                    dwBuf[0]  = 0L;
                    dwBuf[1]  = 0L;
                    dwBuf[2]  = 0L;
                    dwBuf[3]  = 0L;
                    error = lpstream->Read(dwBuf, sizeof(dwBuf), NULL);
                
                    if(error == NOERROR) {
                        Win4Assert(!dwBuf[0]);
                        m_lWidth = dwBuf[1];
                        m_lHeight = dwBuf[2];
                        if(dwBuf[3]) {
                            SetDataPresentFlag();
                            Win4Assert(m_lWidth!=0 && m_lHeight!=0);
                        }
                        else {
                            Win4Assert(m_lWidth==0 && m_lHeight==0);
                        }
                    }
                }
                else {
                    // Create the pres object
                    error = CreateOlePresObj(&m_pPresObj, m_fConvert);
    
                    // Load the data into pres object
                    if(error == NOERROR)
                        error = m_pPresObj->Load(lpstream, FALSE);

                    // Update data present flag
                    if(!m_pPresObj->IsBlank())
                        SetDataPresentFlag();
                }
            }

            // Update rest of state
            if(error == NOERROR) {
                SetLoadedStateFlag();
                SetLoadedCacheFlag();
                ClearFrozenStateFlag();
                m_iStreamNum = iStreamNum;
            }
        }

	// Clean up if presentation could not be loaded
	if(error != NOERROR) {
            // Delete the ptd if it is non-null
            if(m_foretc.ptd)
                PubMemFree(m_foretc.ptd);
            if(m_pPresObj) {
                m_pPresObj->Release();
                m_pPresObj = NULL;
            }

            // Initialize. Gopalk
            INIT_FORETC(m_foretc);
            m_advf = 0;
            m_fConvert = FALSE;
            m_iStreamNum = OLE_INVALID_STREAMNUM;
            ClearLoadedStateFlag();
            ClearLoadedCacheFlag();
            ClearFrozenStateFlag();
            ClearDataPresentFlag();
	}	
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::Load ( %lx )\n", this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Save, public
//
//	Synopsis:
//		Saves a cache node, including its presentation object,
//		to a stream.
//
//	Arguments:
//		[pstgSave] -- the storage that will contain the stream
//		[fSameAsLoad] -- is this storage the same one we loaded from
//		[iStreamNum] -- the stream number to save to
//		[fDrawCache] -- used to indicate whether or not the cached
//			presentation is to be used for drawing; if false,
//			the presentation is discarded after saving
//		[fSaveIfSavedBefore] -- instructs the method to save this
//			cache node, even if it's been saved before
//		[lpCntCachesNotSaved] -- a running count of the number of
//			caches that have not been saved
//
//	Returns:
//		REVIEW
//		S_OK
//
//	Notes:
//
//	History:
//              03/10/94 - AlexT   - Don't call SaveCompleted if we don't save!
//                                   (see logRtn, below)
//		01/11/94 - AlexGo  - fixed compile error (signed/unsigned
//				     mismatch)
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::Save(LPSTORAGE pstgSave, BOOL fSameAsLoad, int iStreamNum)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::Save(%p, %lu, %d)\n",
                this, pstgSave, fSameAsLoad, iStreamNum));

    HRESULT error = NOERROR;
    OLECHAR szNewName[sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR)];

    // Create the new presentation stream name
    if(IsNormalCache()) {
        _xstrcpy(szNewName, OLE_PRESENTATION_STREAM);	
        if(iStreamNum)
            UtGetPresStreamName(szNewName, iStreamNum);		
    }

    if(InLoadedState() && (IsNativeCache() || m_iStreamNum>0)) {
        // The cache node is in loaded state       

        // The CONTENTS stream need not be updated for both Save and SaveAs cases
        // when the native cache node is in loaded state because the container 
        // does copy the CONTENTS stream before invoking SaveAs on the cache.

        if(IsNormalCache()) {
            if(fSameAsLoad) {
                // We are being asked to save to the current storage
                if(m_iStreamNum!=iStreamNum) {
                    // We are being asked to save in to a different stream
                    // We can rename the old stream to a new name
                    OLECHAR szOldName[sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR)];

                    // Assert that the new stream number is less 
                    // than the current stream number
                    Win4Assert(m_iStreamNum>iStreamNum);

                    // Create the old presentation stream name
                    _xstrcpy(szOldName, OLE_PRESENTATION_STREAM);
                    if(m_iStreamNum!=0)
                        UtGetPresStreamName(szOldName, m_iStreamNum);

                    // Delete the stream with the new name, if there is one
                    pstgSave->DestroyElement(szNewName);

                    // Rename the old stream
                    error = pstgSave->RenameElement(szOldName, szNewName);

                    // If NOERROR, update the state
                    if(error==NOERROR) {
                        m_iStreamNum = iStreamNum;
                        SetLoadedStateFlag();
                    }
                }
            }
            else {
                // We are being asked to save to a new storage and 
                // we are in loaded state. We can do efficient stream copy
                LPSTREAM lpstream;

                // Open or Create the new stream in the given storage
                error = OpenOrCreateStream(pstgSave, szNewName, &lpstream);
                if(error==NOERROR) {
	            LPSTREAM pstmSrc;

                    // Get source stream
                    if(pstmSrc = GetStm(FALSE /*fSeekToPresBits*/, STGM_READ)) {
                        ULARGE_INTEGER ularge_int;

                        // initialize to copy all of stream
                        ULISet32(ularge_int, (DWORD)-1L);

                        error = pstmSrc->CopyTo(lpstream, ularge_int, NULL, NULL);

                        // release the source stream
                        pstmSrc->Release();
                    }
                    
                    // Remember the starting position of presentation bits
                    m_dwSavedPresBitsPos = m_dwPresBitsPos;
                
                    // Assuming that we opened an existing pres stream, 
                    // truncate the rest of it before releasing it
                    StSetSize(lpstream, 0, TRUE);
                    lpstream->Release();
                }
            }
        }
    }
    else {
        // Either the node is not in loaded state or it represents presentation 0
        LPOLEPRESOBJECT pPresObj;

        if(IsNativeCache()) {
            // Native cache needs to be saved in CONTENTS stream
            STGMEDIUM stgmed;
            FORMATETC foretc;

            // Open or Create "CONTENTS" stream
            error = OpenOrCreateStream(pstgSave, OLE_CONTENTS_STREAM, &stgmed.pstm);
            if(error==NOERROR) {
                stgmed.pUnkForRelease = NULL;
                stgmed.tymed = TYMED_ISTREAM;
                foretc = m_foretc;
                foretc.tymed = TYMED_ISTREAM;

                // Get the latest presentation.
                if(m_pPresObjAfterFreeze && !m_pPresObjAfterFreeze->IsBlank()) {
                    Win4Assert(InFrozenState());
                    pPresObj = m_pPresObjAfterFreeze;
                }
                else if(m_pPresObj)
                    pPresObj = m_pPresObj;
                else {
                    // PresObj has not yet been created. This happens
                    // for newly created static presentation without a
                    // corresponding set data.

                    BOOL bIsBlank = IsBlank();
                    Win4Assert(bIsBlank);

                    if(!bIsBlank && fSameAsLoad)
                    {
                        error = NO_ERROR;
                        goto scoop;
                    }

                    error = CreateOlePresObj(&m_pPresObj, FALSE /* fConvert */);
                    pPresObj = m_pPresObj;
                }
                                
                // Save the native presentation
                if(error==NOERROR)
                    error = pPresObj->GetDataHere(&foretc, &stgmed);

                // Assuming that we opened an existing CONTENTS stream, 
                // truncate the rest of it before releasing it
                StSetSize(stgmed.pstm, 0, TRUE);

scoop:
                stgmed.pstm->Release();
            }
        }
        else {
            // Normal cache needs to be saved in PRESENTATION stream
            LPSTREAM lpstream;

            // Ensure that PresObj exists for presentation 0
            if(m_iStreamNum==0 && InLoadedState() && 
               m_foretc.cfFormat && !m_pPresObj) {
                // This can happen only after a discard cache. We force
                // load the presentation for the following save to succeed
                error = CreateAndLoadPresObj(FALSE);
                Win4Assert(error == NOERROR);
            }

            if(error == NOERROR) {
                // Open or Create the new stream in the given storage
                error = OpenOrCreateStream(pstgSave, szNewName, &lpstream);
                if(error == NOERROR) {
                    // Write the presentation stream header
                    error = UtWriteOlePresStmHeader(lpstream, &m_foretc, m_advf);
                    if(error == NOERROR) {
                        // Remember the starting position of presentation bits
                        if(fSameAsLoad)
                            SetPresBitsPos(lpstream, m_dwPresBitsPos);
                        else
                            SetPresBitsPos(lpstream, m_dwSavedPresBitsPos);

                        if(m_foretc.cfFormat != NULL) {
                            // Get the latest presentation.
                            if(m_pPresObjAfterFreeze && 
                               !m_pPresObjAfterFreeze->IsBlank()) {
                                Win4Assert(InFrozenState());
                                pPresObj = m_pPresObjAfterFreeze;
                            }
                            else
                                pPresObj = m_pPresObj;

                            // Save the presentation
                            if(pPresObj)
                                error = pPresObj->Save(lpstream);
                            else {
                                // This happens for newly created presentations that
	                        // are blank. Write header that represents blank 
                                // presentation
                                Win4Assert(IsBlank());
                                Win4Assert(m_iStreamNum!=0);

                                DWORD dwBuf[4];

                                dwBuf[0]  = 0L;
	                        dwBuf[1]  = 0L;
	                        dwBuf[2]  = 0L;
	                        dwBuf[3]  = 0L;
                                error = lpstream->Write(dwBuf, sizeof(dwBuf), NULL);
                            }
                        }
                    }

                    // Assuming that we opened an existing pres stream, truncate the
                    // stream to the current position and release it
                    StSetSize(lpstream, 0, TRUE);
                    lpstream->Release();
                }
            }
        }

        // If NOERROR and fSameAsLoad, update state
        if(error==NOERROR && fSameAsLoad) {
            SetLoadedStateFlag();
            if(IsNormalCache())
                m_iStreamNum = iStreamNum;
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::Save(%lx)\n", this, error));
    return error;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::SetPresBitsPos, private
//
//	Synopsis:
//		Sets CCacheNode::m_dwPresBitsPos to the point where the
//		presentation begins in the stream associated with this cache
//		node.
//
//	Arguments:
//		[lpStream] --  the stream the cache node is being saved to
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------
void CCacheNode::SetPresBitsPos(LPSTREAM lpStream, DWORD& dwPresBitsPos)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::SetPresBitsPos(%p)\n",
                this, lpStream));

    LARGE_INTEGER large_int;
    ULARGE_INTEGER ularge_int;

    // Retrieve the current position at which the pres object data starts
    LISet32(large_int, 0);
    lpStream->Seek(large_int, STREAM_SEEK_CUR, &ularge_int);
    dwPresBitsPos = ularge_int.LowPart;

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::SetPresBitsPos()\n", this));
    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::CreatePresObject, public
//
//	Synopsis:
//		Create the presentation object for the cache node.  If there
//		is no clipboard format (cfFormat), then query the source data
//		object for one of our preferred formats.  If there is no
//		source data object, no error is returned, but no presentation
//		is created
//
//	Arguments:
//		[lpSrcDataObj] -- data object to use as the basis for the
//			new presentation
//		[fConvert] -- REVIEW, what's this for?
//
//	Returns:
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
/* HRESULT CCacheNode::CreatePresObject(LPDATAOBJECT lpSrcDataObj, BOOL fConvert)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::CreatePresObject(%p, %lu)\n",
                this, lpSrcDataObj, fConvert));

    // Is the nodes formatetc supported by the data object
    BOOL fFormatSupported = TRUE;
    HRESULT error = NOERROR;
			    
    // Assert that pres object has not yet been created
    Win4Assert(!m_pPresObj);
    
    // Check whether object supports the cachenode's format. If the
    // cachenode format field is NULL, the query will be made for
    // standard formats
    if(lpSrcDataObj)
        fFormatSupported = QueryFormatSupport(lpSrcDataObj);

    // Create the pres object if we know the format of this node
    if(m_foretc.cfFormat!=NULL) {
        // Change BITMAP to DIB
        BITMAP_TO_DIB(m_foretc);

        error = CreateOlePresObject(&m_pPresObj, fConvert);
        if(error==NOERROR && !fFormatSupported)
            error =  ResultFromScode(CACHE_S_FORMATETC_NOTSUPPORTED);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::CreatePresObj(%lx)\n",
                this, error));
    return error;
} */

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::CreateOlePresObj, private
//
//	Synopsis:
//		Creates a presentation object, according to the clipboard
//		format m_foretc.cfFormat
//
//	Arguments:
//		[ppPresObject] -- pointer to where to return the pointer to
//			the newly created presentation object
//		[fConvert] -- REVIEW, what's this for?
//
//	Returns:
//		DV_E_CLIPFORMAT, if object doesn't support one of the standard
//			formats
//		E_OUTOFMEMORY, if we can't allocate the presentation object
//		S_OK
//
//	Notes:
//
//	History:
//              13-Feb-95 t-ScottH  added m_dwPresFlag to track type of
//                                  IOlePresObject
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::CreateOlePresObj(LPOLEPRESOBJECT* ppPresObj, BOOL fConvert)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::CreateOlePresObj(%p,%lu)\n",
                this, ppPresObj, fConvert));

    HRESULT error = NOERROR;

    switch(m_foretc.cfFormat)
    {
    case NULL:
        // Pres object cannot be created 
        *ppPresObj = NULL;
        error = DV_E_CLIPFORMAT;
        break;
	    
    case CF_METAFILEPICT:
        *ppPresObj = new CMfObject(NULL, m_foretc.dwAspect, fConvert);
        #ifdef _DEBUG
        // for use with debugger extensions and dump method
        m_dwPresFlag = CN_PRESOBJ_MF;
        #endif // _DEBUG
        break;

    case CF_ENHMETAFILE:
        *ppPresObj = new CEMfObject(NULL, m_foretc.dwAspect);
        #ifdef _DEBUG
        // for use with debugger extensions and dump method
        m_dwPresFlag = CN_PRESOBJ_EMF;
        #endif // _DEBUG
        break;
		    
    default:
        *ppPresObj = new CGenObject(NULL, m_foretc.cfFormat, m_foretc.dwAspect);
        #ifdef _DEBUG
        // for use with debugger extensions and dump method
        m_dwPresFlag = CN_PRESOBJ_GEN;
        #endif // _DEBUG
    }

    if(error==NOERROR && !*ppPresObj)
        error = ResultFromScode(E_OUTOFMEMORY);

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::CreateOlePresObj(%lx)\n",
                this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::GetStm, public
//
//	Synopsis:
//		Get the stream the presentation is stored in.  Optionally
//		position the stream at the point where the presentation
//		data begins
//
//	Arguments:
//		[fSeekToPresBits] -- position the stream so that the
//			presentation bits would be the next read/written
//		[dwStgAccess] -- the access mode (STGM_*) to open the stream
//			with
//
//	Returns:
//		NULL, if there is no stream, or the stream cannot be opened
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
LPSTREAM CCacheNode::GetStm(BOOL fSeekToPresBits, DWORD dwStgAccess)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::GetStm(%lu, %lx)\n",
	        this, fSeekToPresBits, dwStgAccess));

    LPSTREAM pstm = NULL;
    OLECHAR szName[sizeof(OLE_PRESENTATION_STREAM)/sizeof(OLECHAR)];	

    // This function should only get called for normal cache nodes
    Win4Assert(IsNormalCache());
    Win4Assert(this!=NULL);

    // There has to be a valid stream number and storage
    if(m_iStreamNum!=OLE_INVALID_STREAMNUM && m_pStg) {
        // Generate the stream name
        _xstrcpy(szName, OLE_PRESENTATION_STREAM);
        if(m_iStreamNum)
            UtGetPresStreamName(szName, m_iStreamNum);

        // Attempt to open the stream
        if(m_pStg->OpenStream(szName, NULL, (dwStgAccess | STGM_SHARE_EXCLUSIVE),
                              NULL, &pstm) == NOERROR) {
            // if we're to position the stream at the presentation, do so
            if(fSeekToPresBits) {		
                LARGE_INTEGER large_int;

                LISet32(large_int, m_dwPresBitsPos);	
                if(pstm->Seek(large_int, STREAM_SEEK_SET, NULL)!=NOERROR) {
                    // We could not seek to pres object bits
                    // Release the stream and return null
                    pstm->Release();
                    pstm = NULL;
                }
            }
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::GetStm(%p)\n", this, pstm));
    return(pstm);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Update, public
//
//	Synopsis:
//		Updates the presentation object in this cache node from
//		the given data object.  The update is only done if the
//		[grfUpdf] flags match m_advf specifications, and if
//		there is actually a presentation to update.
//
//	Arguments:
//		[lpDataObj] -- the data object to use as a source of data
//		[grfUpdf] -- the update control flags
//
//	Returns:
//		S_FALSE
//		S_OK
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::Update(LPDATAOBJECT lpDataObj, DWORD grfUpdf, BOOL& fUpdated)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::Update(%p, %lx)\n",
                this, lpDataObj, grfUpdf));
    
    STGMEDIUM medium; // the medium of the presentation
    FORMATETC foretc; // the format of the presentation
    HRESULT error = ResultFromScode(CACHE_S_SAMECACHE);
    
    // There should be a data object for updating
    if(!lpDataObj) {
	error = ResultFromScode(E_INVALIDARG);
        goto errRtn;
    }

    // If cfFormat is NULL, try setting it
    if(!m_foretc.cfFormat) {
        if(QueryFormatSupport(lpDataObj)) {
            // We could update our cfFormat
            ClearLoadedStateFlag();
        }
        else {
            // We still could not set the cfFormat
            error = ResultFromScode(OLE_E_BLANK);
            goto errRtn;
        }
    }

    // Check the flags and update

    // If the update flag is UPDFCACHE_ONLYIFBLANK and the pres object is
    // is not blank, simply return
    if((grfUpdf & UPDFCACHE_ONLYIFBLANK) && (!IsBlank()))
	goto errRtn;
	    
    // If the update flag UPDFCACHE_NODATACACHE is not set and the pres object
    // flag is ADVF_NODATA, simply return
    if(!(grfUpdf & UPDFCACHE_NODATACACHE) && (m_advf & ADVF_NODATA))
	goto errRtn;

    // Update if both NODATA flags are set
    if((grfUpdf & UPDFCACHE_NODATACACHE) && (m_advf & ADVF_NODATA))
	goto update;

    // Update if both ONSAVE flags are set
    if((grfUpdf & UPDFCACHE_ONSAVECACHE) && (m_advf & ADVFCACHE_ONSAVE))
        goto update;
    
    // Update if both ONSTOP flags are set
    if((grfUpdf & UPDFCACHE_ONSTOPCACHE) && (m_advf & ADVF_DATAONSTOP))
        goto update;
    
    // Update if this cache node is blank
    if((grfUpdf & UPDFCACHE_IFBLANK) && IsBlank())
        goto update;

    // Update if this is a normal cache node that gets live updates
    if((grfUpdf & UPDFCACHE_NORMALCACHE) && 
        !(m_advf & (ADVF_NODATA | ADVFCACHE_ONSAVE | ADVF_DATAONSTOP)))
        goto update;
    
    // If we have reached here, do not update
    goto errRtn;

update:	
    // Initialize the medium
    medium.tymed = TYMED_NULL;
    medium.hGlobal = NULL;
    medium.pUnkForRelease = NULL;

    // Make a copy of the desired format; this may mutate below
    foretc = m_foretc;
    
    // Let the object create the medium.
    if(wGetData(lpDataObj, &foretc, &medium) == NOERROR) {
        // Make the cache take the ownership of the data
        error = SetDataWDO(&foretc, &medium, TRUE, fUpdated, lpDataObj);
        if(error != NOERROR)
            ReleaseStgMedium(&medium);
    }
    else
        error = ResultFromScode(E_FAIL);
    
errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::Update(%lx)\n",this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::SetDataWDO, public
//
//	Synopsis:
//		Data is set into the presentation object, if this cache node
//		is not frozen.  If the cache node is frozen, then the
//		new presentation data is stashed into the m_pPresObjAfterFreeze
//		presentation object, which is created, if there isn't already
//		one.  If data is successfully set in the presentation object,
//		and the node is not frozen, the cache is notified that this
//		is dirty.
//
//	Arguments:
//		[lpForetc] -- the format of the new data
//		[lpStgmed] -- the storage medium the new data is one
//		[fRelease] -- passed on to the presentation object; indicates
//			whether or not to release the storage medium
//              [pDataObj] -- pointer to the revelant source data object
//
//	Returns:
//		E_FAIL
//		REVIEW, result from presentationObject::SetData
//		S_OK
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::SetDataWDO(LPFORMATETC lpForetc, LPSTGMEDIUM lpStgmed,
                               BOOL fRelease, BOOL& fUpdated, IDataObject *pDataObj)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::SetDataWDO(%p, %p, %lu, %p)\n",
                this, lpForetc, lpStgmed, fRelease, pDataObj));

    HRESULT hresult = NOERROR;

    // Initialize
    fUpdated = FALSE;

    // If the cache node is in frozen state, save the data in the 
    // m_pPresObjAfterFreeze
    if(InFrozenState()) {    
        // If PresObjAfterFreeze has not yet been created, create it
        if(!m_pPresObjAfterFreeze)
            hresult = CreateOlePresObj(&m_pPresObjAfterFreeze, FALSE);

        // Hold the data in PresObjAfterFreeze
        if(hresult == NOERROR)
            hresult = m_pPresObjAfterFreeze->SetDataWDO(lpForetc, lpStgmed, 
                                                        fRelease, pDataObj);
    }
    else {
        // If PresObj has not yet been created, create it
        if(!m_pPresObj)
            hresult = CreateOlePresObj(&m_pPresObj, FALSE /* fConvert */);
        
        // Hold the data in PresObj
        if(hresult == NOERROR)
            hresult = m_pPresObj->SetDataWDO(lpForetc, lpStgmed, 
                                             fRelease, pDataObj);
        
        // Update state
        if(hresult == NOERROR) {
            // Set or clear the data present flag
            if(m_pPresObj->IsBlank())
                ClearDataPresentFlag();
            else
                SetDataPresentFlag();
            
            // Indicate that the cache node has been updated
            fUpdated = TRUE;
        }

    }

    // If suceeded in holding the data, clear loaded state flag
    if(hresult == NOERROR)
        ClearLoadedStateFlag();

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::SetDataWDO(%lx)\n", this, hresult));		    
    return hresult;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::GetExtent, public
//
//	Synopsis:
//		Extents of this cache node presentation
//
//	Arguments:
//		[dwAspect][in]     -- Aspect for which the extent is desired
//              [pSizel]  [in/out] -- Sizel structure for returning the extent 
//                            
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::GetExtent(DWORD dwAspect, SIZEL* pSizel)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::GetExtent(%lx, %p)\n",
                this, dwAspect, pSizel));
    
    HRESULT error = NOERROR;

    if(!(dwAspect & m_foretc.dwAspect))
        error = ResultFromScode(DV_E_DVASPECT);
    else if(IsBlank()) {
        // This case also catches new blank presentation caches
        pSizel->cx = 0;
        pSizel->cy = 0;
        error = ResultFromScode(OLE_E_BLANK);
    }
    else {
        // Check for existence of pres object
        if(!m_pPresObj && IsNormalCache()) {
            // The Presobj has not yet been created
            // This happens for old presentation caches only
            Win4Assert(InLoadedState());
            pSizel->cx = m_lWidth;
            pSizel->cy = m_lHeight;
        }
        else { 
            // If PresObj has not yet been created for native cache,
            // create and load the PresObj
            if(!m_pPresObj && IsNativeCache())
                error = CreateAndLoadPresObj(FALSE);

            // Get extent information from PresObj
            if(error == NOERROR)
                error = m_pPresObj->GetExtent(dwAspect, pSizel);
        }

        // Ensure extents are positive
        if(error == NOERROR) {
            pSizel->cx = LONG_ABS(pSizel->cx);
            pSizel->cy = LONG_ABS(pSizel->cy);

            // Sanity check
            Win4Assert(pSizel->cx != 1234567890);
            Win4Assert(pSizel->cx != 1234567890);
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::GetExtent(%lx)\n", this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::GetData, public
//
//	Synopsis:
//		Obtains the cache node presentation data
//
//	Arguments:
//		[pforetc] [in]  -- FormatEtc of the presentation desired
//              [pmedium] [out] -- Storage medium in which data is returned 
//                            
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::GetData(LPFORMATETC pforetc, LPSTGMEDIUM pmedium)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::GetData(%p, %p)\n",
                this, pforetc, pmedium));
    
    HRESULT error = NOERROR;

    if(IsBlank()) {
        // This case also catches new blank presentation caches
        error = ResultFromScode(OLE_E_BLANK);
    }
    else {
        // Check for existence of pres object
        if(!m_pPresObj) {
            // The PresObj has not yet been created, create and load it
            // This happens for old presentation caches only
            Win4Assert(InLoadedState());
            error = CreateAndLoadPresObj(FALSE);        
        }

        // Get data from pres object
        if(error == NOERROR)
            error = m_pPresObj->GetData(pforetc, pmedium);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::GetData(%lx)\n", this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::GetDataHere, public
//
//	Synopsis:
//		Obtains the cache node presentation data
//
//	Arguments:
//		[pforetc] [in]     -- FormatEtc of the presentation desired
//              [pmedium] [in/out] -- Storage medium in which data is returned 
//                            
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::GetDataHere(LPFORMATETC pforetc, LPSTGMEDIUM pmedium)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::GetData(%p, %p)\n",
                this, pforetc, pmedium));
    
    HRESULT error = NOERROR;

    if(IsBlank()) {
        // This case also catches new blank presentation caches
        error = ResultFromScode(OLE_E_BLANK);
    }
    else {
        // Check for existence of pres object
        if(!m_pPresObj) {
            // The PresObj has not yet been created, create and load it
            // This happens for old presentation caches only
            Win4Assert(InLoadedState());
            error = CreateAndLoadPresObj(FALSE);
        }

        // Get data from pres object
        if(error == NOERROR)
            error = m_pPresObj->GetDataHere(pforetc, pmedium);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::GetDataHere(%lx)\n", this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Draw, public
//
//	Synopsis:
//		Draws the presentation data on the specified hDC
//
//	Arguments:
//                            
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::Draw(void* pvAspect, HDC hicTargetDev, HDC hdcDraw,
                         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                         BOOL (CALLBACK *pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::Draw(%p, %p, %p, %p, %p, %p)\n",
                this, pvAspect, lprcBounds, lprcWBounds, pfnContinue, dwContinue));
    
    HRESULT error = NOERROR;

    if(IsBlank()) {
        // This case also catches new blank presentation caches
        error = ResultFromScode(OLE_E_BLANK);
    }
    else {
        // Check for existence of pres object
        if(!m_pPresObj) {
            // The PresObj has not yet been created, create and load it
            // This happens for old presentation caches only
            Win4Assert(InLoadedState());
            error = CreateAndLoadPresObj(FALSE);        
        }

        // Get draw from pres object
        if(error == NOERROR)
            error = m_pPresObj->Draw(pvAspect, hicTargetDev, hdcDraw, lprcBounds,
                                     lprcWBounds, pfnContinue, dwContinue);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::Draw(%lx)\n", this, error));
    return error;
}    
    
//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::GetColorSet, public
//
//	Synopsis:
//		Draws the presentation data on the specified hDC
//
//	Arguments:
//                            
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::GetColorSet(void* pvAspect, HDC hicTargetDev, 
                                LPLOGPALETTE* ppColorSet)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::GetColorSet(%p, %p)\n",
                this, pvAspect, ppColorSet));
    
    HRESULT error = NOERROR;

    if(IsBlank()) {
        // This case also catches new blank presentation caches
        error = ResultFromScode(OLE_E_BLANK);
    }
    else {
        // Check for existence of pres object
        if(!m_pPresObj) {
            // The PresObj has not yet been created, create and load it
            // This happens for old presentation caches only
            Win4Assert(InLoadedState());
            error = CreateAndLoadPresObj(FALSE);        
        }

        // Get color set from pres object
        if(error == NOERROR)
            error = m_pPresObj->GetColorSet(pvAspect, hicTargetDev, ppColorSet);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::GetColorSet(%lx)\n", this, error));
    return error;
} 

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::CreateAndLoadPresObj, private
//
//	Synopsis:
//		Creates and loads the pres object
//
//	Arguments:
//              [fHeaderOnly] - True if only pres obj header needs to be loaded
//                              This option is used for GetExtent as there is no
//                              need to load entire pres obj for getting extents
//                              Further, this routine should be called only for
//                              previously cached presentations
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::CreateAndLoadPresObj(BOOL fHeaderOnly)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::CreateAndLoadPresObj(%lx)\n",
                this, fHeaderOnly));
    
    HRESULT error = NOERROR;
    
    // Check for existence of pres object
    if(!m_pPresObj) {
        if(IsNativeCache()) {
            // Native cache node
            
            // Check if cache has storage
            if(m_pStg) {
                BOOL fOle10Native, fUpdated;
                STGMEDIUM stgmed;
            
                // Is the native an Ole 1.0 class
                if(CoIsOle1Class(m_clsid))
                    fOle10Native = TRUE;
                else
                    fOle10Native = FALSE;

                // Obtain global with the native data.
                // Due to auto convert case, the native stream may be in the
                // old CfFormat and consequently, trying to read in the new
                // CfFormat can fail. Gopalk
                stgmed.pUnkForRelease = NULL;
                stgmed.tymed = m_foretc.tymed;
                stgmed.hGlobal = UtGetHPRESFromNative(m_pStg, NULL, m_foretc.cfFormat,
                                                      fOle10Native);

				// We may be dealing with old-styled static object. Such
				// objects are supposed to be converted during loading, but
				// some are not, for reasons such as lack of access rights.
				if(!stgmed.hGlobal)
				{
					// Convert OlePres to CONTENTS in-memory.
					IStream *pMemStm = NULL;
					HRESULT hr;
					
					hr = CreateStreamOnHGlobal(NULL, TRUE, &pMemStm);
					if(SUCCEEDED(hr) && pMemStm)
					{
						UINT uiStatus = 0;

						hr = UtOlePresStmToContentsStm(m_pStg, OLE_PRESENTATION_STREAM, pMemStm, &uiStatus);
						if(SUCCEEDED(hr) && uiStatus == 0)
						{
							// rewind the stream
							LARGE_INTEGER dlibMove = {0};
							pMemStm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

							// 2nd try
							stgmed.hGlobal = UtGetHPRESFromNative(NULL, pMemStm, m_foretc.cfFormat, fOle10Native);
						}

						pMemStm->Release();
					}
				}

                // Set the data on native cache node
                if(stgmed.hGlobal) {
                    error = SetData(&m_foretc, &stgmed, TRUE, fUpdated);
                    if(error != NOERROR)
                        ReleaseStgMedium(&stgmed);
                }
                else {
                    // This happens when the native data is not in the correct format
                    Win4Assert(FALSE);
                    error = ResultFromScode(DV_E_CLIPFORMAT);
                }
            }
            else {
                Win4Assert(FALSE);
                error = ResultFromScode(OLE_E_BLANK);
            }
        }
        else {
            // Normal cache node
            error = CreateOlePresObj(&m_pPresObj, m_fConvert);
    
            // Load the data into pres object
            if(error == NOERROR) {
                LPSTREAM pStream;

                // Open presentation stream and seek to the pres obj bits
                pStream = GetStm(TRUE, STGM_READ);
                if(pStream) {
                    // Load pres object
                    error = m_pPresObj->Load(pStream, fHeaderOnly);
                    pStream->Release();
                }
                else {
                    // This can happen only when m_pStg is NULL
                    Win4Assert(!m_pStg);
                    Win4Assert(FALSE);
                    error = ResultFromScode(OLE_E_BLANK);
                }
            }
            
            // Assert that the state matches current state
            if(error == NOERROR) {
                SIZEL extent;
            
                Win4Assert(m_pPresObj->IsBlank()==IsBlank());
                m_pPresObj->GetExtent(m_foretc.dwAspect, &extent);
                Win4Assert(extent.cx==m_lWidth && extent.cy==m_lHeight);
            }
        }
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::CreateAndLoadPresObj(%lx)\n",
                this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::DiscardPresentation, public
//
//	Synopsis:
//		Discards the presentation objects so that we hit the storage
//              for presentation data in future
//
//	Arguments:
//              NONE
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::DiscardPresentation(LPSTREAM pGivenStream)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::DiscardPresentation()\n", this));

    HRESULT error = NOERROR;
    LPSTREAM pStream;

    // We are being forced to destroy presentation object rather than 
    // discarding its presentation data due to a flaw in the current design
    // of presentation objects. The presentation objects do not discard their
    // extent information along with their presentation data. This causes us
    // to get latest extent information in future IOleCache::GetExtent() calls
    // which is not the desired behavior. Gopalk

    // Revert state 
    if(IsNativeCache()) {
        // Native Cache node
        // Update state
        SetLoadedStateFlag();
        ClearFrozenStateFlag();

        // We make the conservative assumption that the native cache 
        // is not blank
        SetDataPresentFlag();
    }
    else {
        // Normal cache node
        if(m_iStreamNum == OLE_INVALID_STREAMNUM) {
            // New cache node
            Win4Assert(!InLoadedState());

            // Simply update state
            ClearFrozenStateFlag();
            ClearDataPresentFlag();
            m_lWidth = 0;
            m_lHeight = 0;
        }
        else {
            // Old cache node
            if(InLoadedState()) {            
                // The cache node is still in loaded state
                BOOL fUpdated;
                SIZEL Extent;

                // Unfreeze the cache node to get the latest saved presentation
                if(InFrozenState())
                    Unfreeze(fUpdated);
                Win4Assert(!m_pPresObjAfterFreeze);
                Win4Assert(!InFrozenState());

                // Obtain the latest extent. 
                // This could happen due to Unfreeze above
		if(m_pPresObj) {
                    error = m_pPresObj->GetExtent(m_foretc.dwAspect, &Extent);
                    m_lWidth = Extent.cx;
                    m_lHeight = Extent.cy;
		}

                // Update state
                if(error == NOERROR)
                    SetLoadedCacheFlag();
            }
            else {
                // Open presentation stream and read header from it
                pStream = GetStm(TRUE, STGM_READ);
                if(pStream) {
                    // Read presentation header
                    if(m_foretc.cfFormat) {
                        DWORD dwBuf[4];

                        // Read the extent and size of presentation data
                        dwBuf[0]  = 0L;
                        dwBuf[1]  = 0L;
                        dwBuf[2]  = 0L;
                        dwBuf[3]  = 0L;
                        error = pStream->Read(dwBuf, sizeof(dwBuf), NULL);

                        if(error == NOERROR) {
                            Win4Assert(!dwBuf[0]);
                            m_lWidth = dwBuf[1];
                            m_lHeight = dwBuf[2];
                            if(dwBuf[3]) {
                                SetDataPresentFlag();
                                Win4Assert(m_lWidth!=0 && m_lHeight!=0);
                            }
                            else {
                                ClearDataPresentFlag();
                                Win4Assert(m_lWidth==0 && m_lHeight==0);
                            }
                        }
                    }
                    else {
                        // Assume that the presentation is blank
                        ClearDataPresentFlag();
                        m_lWidth = 0;
                        m_lHeight = 0;
                    }
			
                    // Update rest of the state
                    if(error == NOERROR) {
                        SetLoadedStateFlag();
                        SetLoadedCacheFlag();
                        ClearFrozenStateFlag();
                    }

                    // Release the stream
                    pStream->Release();
		}
                else {
                    // This can happen only when m_pStg is NULL
                    Win4Assert(!m_pStg);
                    error = ResultFromScode(E_UNEXPECTED);
                }
            }
        }
    }
    
    // Destroy both presentation objects
    if(m_pPresObj && error==NOERROR) {
        m_pPresObj->Release();
        m_pPresObj = NULL;
    }
    if(m_pPresObjAfterFreeze && error==NOERROR) {
        m_pPresObjAfterFreeze->Release();
        m_pPresObjAfterFreeze = NULL;
    }

    LEDebugOut((DEB_ITRACE, "%p _OUT CCacheNode::DiscardPresentation(%lx)\n",
                this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Freeze, public
//
//	Synopsis:
//		Freeze the cachenode.  From here on, OnDataChange() is ignored
//		until this node is unfrozen (Unfreeze().)  This is not
//		persistent across Save/Load.  (If we receive OnDataChange(),
//		the new data is stashed away in m_pPresAfterFreeze, but is
//		not exported to the outside of the cache node.)
//
//	Arguments:
//		none
//
//	Returns:
//		VIEW_S_ALREADY_FROZEN
//		S_OK
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::Freeze()
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::Freeze()\n", this));

    HRESULT hresult = NOERROR;

    if(InFrozenState())
        hresult = ResultFromScode(VIEW_S_ALREADY_FROZEN);
    else
        SetFrozenStateFlag();

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::Freeze(%lx)\n", this, hresult));

    return hresult;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::Unfreeze, public
//
//	Synopsis:
//		Unfreeze the cachenode.  If there have been changes to
//		the presentation data since the node was frozen, the node
//		is updated to reflect those changes.  From this point on,
//		OnDataChange() notifications are no longer ignored.
//
//	Arguments:
//		fChanged [out] - set to TRUE when cache node is updated
//
//	Returns:
//		OLE_E_NOCONNECTION, if the node was not frozen (REVIEW scode)
//		S_OK
//
//	Notes:
//
//	History:
//		11/06/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::Unfreeze(BOOL& fUpdated)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::UnFreeze(%p)\n", this, &fUpdated));

    HRESULT hresult = NOERROR;
	
    // Initilaize
    fUpdated = FALSE;

    if(InFrozenState()) {
	// Cache node is no longer in frozen state
	ClearFrozenStateFlag();

        // Check to see if we have m_pPresObjAfterFreeze
	if(m_pPresObjAfterFreeze) {
            // Check if the frozen presentation object is blank
            if(m_pPresObjAfterFreeze->IsBlank()) {
                // Release and reset the frozen presentation object
                m_pPresObjAfterFreeze->Release();
                m_pPresObjAfterFreeze = NULL;
            }
            else {
                // Release the original presentation object
                if(m_pPresObj)
	            m_pPresObj->Release();

                // Make m_pPresObjAfterFreeze the current one and set
                // data present flag
	        m_pPresObj = m_pPresObjAfterFreeze;
                SetDataPresentFlag();
            
                // Cache node is updated
                fUpdated = TRUE;

                // Reset the m_pPresObjAfterFreeze to NULL
                m_pPresObjAfterFreeze = NULL;
            }
        }
    }
    else {
        // The cachenode is not frozen
        hresult = ResultFromScode(OLE_E_NOCONNECTION);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::UnFreeze(%lx)\n", this, hresult));
    return hresult;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::QueryFormatSupport, private
//
//	Synopsis:
//		Check to see if the data object supports the presentation
//		format specified for this cache node.  If no format is
//		specified, check for any of our preferred formats.  If
//		the format is CF_DIB, and that is not available, check for
//		CF_BITMAP.
//
//	Arguments:
//		[lpDataObj] -- the data object
//
//	Returns:
//		TRUE if the format is supported, FALSE otherwise
//
//	Notes:
//
//	History:
//		11/09/93 - ChrisWe - no longer necessary to reset format
//			after UtQueryPictFormat, since that leaves descriptor
//			untouched now
//		11/09/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
BOOL CCacheNode::QueryFormatSupport(LPDATAOBJECT lpDataObj)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::QueryFormatSupport(%p)\n",
                this, lpDataObj));

    BOOL fRet = FALSE;

    if(lpDataObj) {
	if(m_foretc.cfFormat) {
            // Check to see if cachenode format is supported
            if(lpDataObj->QueryGetData(&m_foretc) == NOERROR)
                fRet = TRUE;
            else {
                // If the cachenode format was DIB that was not supported,
                // check to see if BITMAP is supported instead
                if(m_foretc.cfFormat == CF_DIB) {
	            FORMATETC foretc = m_foretc;

	            foretc.cfFormat = CF_BITMAP;
	            foretc.tymed = TYMED_GDI;
	            if (lpDataObj->QueryGetData(&foretc) == NOERROR)
                        fRet = TRUE;
                }
            }
        }
        else {
            // Check for our preferred formats
            fRet = UtQueryPictFormat(lpDataObj, &m_foretc);
            if(fRet)
               BITMAP_TO_DIB(m_foretc);
	}		
    }

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::QueryFormatSupport(%lu)\n",
                this, fRet));
    return fRet;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::SetupAdviseConnection, private
//
//	Synopsis:
//		Set up data advise sourced by the server object, and sunk
//		by this cache node, if there is a valid data object.
//
//	Arguments:
//		none
//
//	Returns:
//		OLE_E_BLANK, if no presentation object exists or can be
//			created
//		DATA_E_FORMATETC
//		OLE_E_ADVISENOTSUPPORTED
//		S_OK, indicates successful advise, or no data object
//
//	Notes:
//
//	History:
//		11/09/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::SetupAdviseConnection(LPDATAOBJECT pDataObj,
                                          IAdviseSink* pAdviseSink)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::SetupAdviseConnection(%p, %p)\n",
                this, pDataObj, pAdviseSink));

    DWORD grfAdvf; 
    HRESULT hresult = NOERROR;

    if(pDataObj && pAdviseSink) {
        // Assert that there is no pending advise connection
        Win4Assert(!m_pDataObject && !m_dwAdvConnId);

        // If cfFormat is NULL, try setting it
        if(!m_foretc.cfFormat) {
            if(QueryFormatSupport(pDataObj)) {
                // We could update our cfFormat
                ClearLoadedStateFlag();
            }
            else {
                // We still could not set the cfFormat
		hresult = ResultFromScode(OLE_E_BLANK);
            }
        }

        // Check if cfFormat is set and ADVF_NODATA is not set in advise flags
        if(m_foretc.cfFormat && !(m_advf & ADVF_NODATA)) {
            // copy and massage the base advise control flags
            grfAdvf = m_advf;

            // only the DDE layer looks for these 2 bits
            grfAdvf |= (ADVFDDE_ONSAVE | ADVFDDE_ONCLOSE);

            // If we were to get data when it is saved, get it instead when
            // the object is stopped
            if(grfAdvf & ADVFCACHE_ONSAVE) {
	        grfAdvf &= (~ADVFCACHE_ONSAVE);
	        grfAdvf |= ADVF_DATAONSTOP;
            }
	
	    // These two flags are not meaningful to the cache
	    // REVIEW, why not?
	    grfAdvf &= (~(ADVFCACHE_NOHANDLER | ADVFCACHE_FORCEBUILTIN));
	
            // If we already have data, then remove the ADVF_PRIMEFIRST
            if(!IsBlank())
                grfAdvf &= (~ADVF_PRIMEFIRST);
	
            // Set up the advise with the data object, using massaged flags
            hresult = pDataObj->DAdvise(&m_foretc, grfAdvf, pAdviseSink, 
                                        &m_dwAdvConnId);
            if(hresult!=NOERROR) {
                // The advise failed. If the requested format was CF_DIB,
                // try for CF_BITMAP instead.
                if(m_foretc.cfFormat == CF_DIB) {
                    FORMATETC foretc;

                    // create new format descriptor
                    foretc = m_foretc;
                    foretc.cfFormat = CF_BITMAP;
                    foretc.tymed = TYMED_GDI;

                    // request advise
                    hresult = pDataObj->DAdvise(&foretc, grfAdvf, pAdviseSink,
                                                &m_dwAdvConnId);
                }
            }
            
            // Save the data object for future sanity check
            if(hresult == NOERROR)
                m_pDataObject = pDataObj;
        }
    }
    else {
        Win4Assert(FALSE);
        hresult = ResultFromScode(E_INVALIDARG);
    }


    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::SetupAdviseConnection(%lx)\n",
                this, hresult));
    return hresult;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::TearDownAdviseConnection, private
//
//	Synopsis:
//		Remove advise connection from data object to this sink.  Returns
//		immediately if there is no advise connection.
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		11/09/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::TearDownAdviseConnection(LPDATAOBJECT pDataObj)
{
    LEDebugOut((DEB_ITRACE, "%p _IN CCacheNode::TearDownAdviseConnection(%p)\n",
                this, pDataObj));

    HRESULT error = NOERROR;

    // Check if currently there is an advisory connection
    if(m_dwAdvConnId) {
        // Check for valid data object
        if(pDataObj) {
            // Assert that Advise and Unadvise are on the same dataobject
            Win4Assert(pDataObj==m_pDataObject);
            // UnAdvise
            pDataObj->DUnadvise(m_dwAdvConnId);
        }
        
        //  clear the connection ID
        m_dwAdvConnId = 0;
        m_pDataObject = NULL;
    }
    else
        Win4Assert(!m_pDataObject);

    LEDebugOut((DEB_ITRACE, "%p OUT CCacheNode::TearDownAdviseConnection(%lx)\n",
                this, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::SaveTOCEntry, private
//
//	Synopsis:
//		Saves the TOC information in the given stream
//
//	Arguments:
//              pStream [in] - Stream in which to save TOC
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::SaveTOCEntry(LPSTREAM pStream, BOOL fSameAsLoad)
{
    LEDebugOut((DEB_ITRACE, "%p _IN SaveTOCEntry(%p)\n", pStream));

    HRESULT error;
    DWORD dwBuf[9];
    SIZEL Extent;

    // Save the clipboard format
    error = WriteClipformatStm(pStream, m_foretc.cfFormat);
    if(error == NOERROR) {
        // Obtain rest of formatetc
        if(m_foretc.ptd)
            dwBuf[0] = m_foretc.ptd->tdSize;
        else
            dwBuf[0] = 0;
        dwBuf[1] = m_foretc.dwAspect;
        dwBuf[2] = m_foretc.lindex;
        dwBuf[3] = m_foretc.tymed;
        
        // Initialize extents
        dwBuf[4] = 1234567890;
        dwBuf[5] = 1234567890;

        // Obtain latest extent if this is a normal cache
        if(IsNormalCache()) {
            if(m_pPresObjAfterFreeze && !m_pPresObjAfterFreeze->IsBlank()) {
                Win4Assert(InFrozenState());
                error = m_pPresObjAfterFreeze->GetExtent(m_foretc.dwAspect, &Extent);
            }
            else if(m_pPresObj)
                error = m_pPresObj->GetExtent(m_foretc.dwAspect, &Extent);
            else {
                Extent.cx = m_lWidth;
                Extent.cy = m_lHeight;
            }
            // Gen PresObj returns OLE_E_BLANK for cfformats other than DIB and BITMAP
            if(error == NOERROR) {
                dwBuf[4] = Extent.cx;
                dwBuf[5] = Extent.cy;
            }
            else if(error == ResultFromScode(OLE_E_BLANK)) {
                Win4Assert(m_foretc.cfFormat != CF_DIB);
                Win4Assert(m_foretc.cfFormat != CF_METAFILEPICT);
                Win4Assert(m_foretc.cfFormat != CF_ENHMETAFILE);
                dwBuf[4] = 0;
                dwBuf[5] = 0;
            }
        }

        // Obtain cache node flags, advise flags and presentation bits position
        dwBuf[6] = m_dwFlags;
        dwBuf[7] = m_advf;
        if(fSameAsLoad)
            dwBuf[8] = m_dwPresBitsPos;
        else
            dwBuf[8] = m_dwSavedPresBitsPos;
#if DBG==1
        if (IsNormalCache()) {
            Win4Assert(dwBuf[8]);
        }
#endif
        
        // Save the obtained state
        error = pStream->Write(dwBuf, sizeof(dwBuf), NULL);

        // Finally, save target device
        if(error==NOERROR && m_foretc.ptd)
            error = pStream->Write(m_foretc.ptd, m_foretc.ptd->tdSize, NULL);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT SaveTOCEntry(%lx)\n", NULL, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::LoadTOCEntry, private
//
//	Synopsis:
//		Loads the TOC information in the given stream
//
//	Arguments:
//              pStream [in]        - Stream from which to load TOC
//              iStreamNum [in/out] - Presentation stream number of the cache
//
//	Returns:
//		NOERROR on success
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
HRESULT CCacheNode::LoadTOCEntry(LPSTREAM pStream, int& iStreamNum)
{
    LEDebugOut((DEB_ITRACE, "%p _IN LoadTOCEntry(%p)\n", pStream));

    HRESULT error;
    DWORD cfFormat, dwBuf[9];
    ULONG ulBytesRead;

    // Load the clipboard format
    error = ReadClipformatStm(pStream, &cfFormat);
    if(error == NOERROR) {
        // Load remaining state
        error = pStream->Read(dwBuf, sizeof(dwBuf), &ulBytesRead);
        if(ulBytesRead == sizeof(dwBuf)) {
            // Load target device
            if(dwBuf[0]) {
                m_foretc.ptd = (DVTARGETDEVICE *) PubMemAlloc(dwBuf[0]);
                if(m_foretc.ptd) {
                    error = pStream->Read(m_foretc.ptd, dwBuf[0], &ulBytesRead);
                    if(ulBytesRead != dwBuf[0]) {
			PubMemFree(m_foretc.ptd);
			m_foretc.ptd = NULL;
                        error = ResultFromScode(E_FAIL);
                    }
                }
                else
                    error = ResultFromScode(E_OUTOFMEMORY);
            }
            else
                m_foretc.ptd = NULL;
            
            // Check if TOC data was read successfully
            if(error == NOERROR) {
                // Update cache node data
                m_foretc.cfFormat = (CLIPFORMAT) cfFormat;
                m_foretc.dwAspect = dwBuf[1];
                m_foretc.lindex = dwBuf[2];
                m_foretc.tymed = dwBuf[3];
                m_lWidth = dwBuf[4];
                m_lHeight = dwBuf[5];
                m_dwFlags = dwBuf[6];
                m_advf = dwBuf[7];
                m_dwPresBitsPos = dwBuf[8];

                // Update state on the node
                SetLoadedStateFlag();
                ClearFrozenStateFlag();
                if(IsNormalCache()) {
                    SetLoadedCacheFlag();
                    m_iStreamNum = iStreamNum++;        
                }

#if DBG==1
                // Sanity Checks
                if (IsNormalCache()) {
                    Win4Assert(m_lWidth!=1234567890);
                    Win4Assert(m_lHeight!=1234567890);
                    Win4Assert(m_dwPresBitsPos);
                }
#endif  
            }
        }
        else
            error = ResultFromScode(E_FAIL);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT LoadTOCEntry(%lx)\n", NULL, error));
    return error;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::operator=, public
//
//	Synopsis:
//		Assignment operator implementation for cache node 
//
//	Arguments:
//		[rCN] -- CacheNode object that is on the RHS 
//                       of assignment statement
//
//	Returns:
//		CacheNode object that is on the LHS of the assignment 
//              statement so that chaining of assinments is possible
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
const CCacheNode& CCacheNode::operator=(const CCacheNode& rCN)
{
    // Check to see, if this a=a case
    if(this==&rCN)
        return(*this);

    // Self destroy
    CCacheNode::~CCacheNode();

    // Now, make a copy
    if(!UtCopyFormatEtc((LPFORMATETC) &rCN.m_foretc, &m_foretc))
        SetOutOfMemoryFlag();

    m_advf = rCN.m_advf;
    m_lWidth = rCN.m_lWidth;
    m_lHeight = rCN.m_lHeight;
    m_dwFlags = rCN.m_dwFlags;
    m_pStg = rCN.m_pStg;
    m_iStreamNum = rCN.m_iStreamNum;
    m_dwPresBitsPos = rCN.m_dwPresBitsPos;
    m_pPresObj = rCN.m_pPresObj;
    if(m_pPresObj)
        m_pPresObj->AddRef();
    m_pPresObjAfterFreeze = rCN.m_pPresObjAfterFreeze;
    if(m_pPresObjAfterFreeze)
        m_pPresObjAfterFreeze->AddRef();
    m_pDataObject = rCN.m_pDataObject;
    m_dwAdvConnId = rCN.m_dwAdvConnId;
#ifdef _DEBUG
    m_dwPresFlag = rCN.m_dwPresFlag;
#endif // _DEBUG

    return(*this);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CCacheNode::operator==, public
//
//	Synopsis:
//		Equality operator implementation for cache node 
//
//	Arguments:
//		[rCN] -- CacheNode object that is on the RHS 
//                       of the equality expression
//
//	Returns:
//		1 if both the CacheNode objects are equal, 0 otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
/*int CCacheNode::operator==(CCacheNode& rCN)
{
    if(m_foretc.cfFormat == rCN.m_foretc.cfFormat)
        if(m_foretc.dwAspect == rCN.m_foretc.dwAspect)
            if(m_foretc.lindex == rCN.m_foretc.lindex)
                if(UtCompareTargetDevice(m_foretc.ptd, rCN.m_foretc.ptd))
                    return(1);

    return(0);
}
*/
//+----------------------------------------------------------------------------
//
//	Function:
//		wGetData, internal
//
//	Synopsis:
//		Fetch the data from the data object in the requested format.
//		If the fetch fails, and the requested format was CF_DIB,
//		try CF_BITMAP as an alternative.
//
//	Arguments:
//		[lpSrcDataObj] -- source data object
//		[lpforetc] -- desired data format
//		[lpmedium] -- if successful, the storage medium containing
//			the requested data
//
//	Returns:
//		DATA_E_FORMATETC
//		S_OK
//
//	Notes:
//
//	History:
//		11/09/93 - ChrisWe - modified to not alter the requested
//			format unless the subsequent CF_BITMAP request succeeds.
//		11/09/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT wGetData(LPDATAOBJECT lpSrcDataObj, LPFORMATETC lpforetc,
                 LPSTGMEDIUM lpmedium)
{
    LEDebugOut((DEB_ITRACE, "%p _IN wGetData(%p, %p, %p)\n", 
                NULL, lpSrcDataObj, lpforetc, lpmedium));

    HRESULT hresult;

    // Get the data in the requested format
    hresult = lpSrcDataObj->GetData(lpforetc, lpmedium);
    if(hresult!=NOERROR) {
        // GetData failed.  If the requested format was CF_DIB,
        // then try CF_BITMAP instead.
        if(lpforetc->cfFormat == CF_DIB) {
            FORMATETC foretc;

            // copy the base format descriptor; try CF_BITMAP
            foretc = *lpforetc;
            foretc.cfFormat = CF_BITMAP;
            foretc.tymed = TYMED_GDI;

            hresult = lpSrcDataObj->GetData(&foretc, lpmedium);
            if(hresult == NOERROR) {
                lpforetc->cfFormat = CF_BITMAP;
                lpforetc->tymed = TYMED_GDI;
            }
        }

        // GetData failed.  If the requested format was CF_ENHMETAFILE,
        // retry for metafilepict instead.
        if(lpforetc->cfFormat == CF_ENHMETAFILE) {
            FORMATETC foretc;

            foretc = *lpforetc;
            foretc.cfFormat = CF_METAFILEPICT;
            foretc.tymed = TYMED_MFPICT;

            hresult = lpSrcDataObj->GetData(&foretc, lpmedium);
            if(hresult == NOERROR) {
                lpforetc->cfFormat = CF_METAFILEPICT;
                lpforetc->tymed = TYMED_MFPICT;
            }
        }
    }

    AssertOutStgmedium(hresult, lpmedium);

    LEDebugOut((DEB_ITRACE, "%p OUT wGetData(%lx)\n", NULL, hresult));
    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\cache\enumtors.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              enumerators.cpp
//
//      Contents:
//              Enumerators implementation
//
//      Classes:
//              CStatData      - STATDATA class with methods suitable for 
//                               embedding in the place holder object
//              CEnumStatData  - STATDATA Enumerator
//              CFormatEtc     - FORMATETC class with methods suitable for
//                               embedding in the place holder object
//              CEnumFormatEtc - FORMATETC Enumerator
//
//      History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
          
#include <le2int.h>
#include "enumtors.h"

//+----------------------------------------------------------------------------
//
//	Member:
//		CStatData::CStatData, public
//
//	Synopsis:
//		Constructor
//
//	Arguments:
//		[foretc]       [in] -- FormatEtc
//              [dwAdvf]       [in] -- Advise Flags
//              [pAdvSink]     [in] -- Advise Sink 
//              [dwConnection] [in] -- Connection ID
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CStatData::CStatData(FORMATETC* foretc, DWORD dwAdvf, IAdviseSink* pAdvSink, 
                     DWORD dwConnID)
{
    // validation check

    // Initialize 
    m_ulFlags = 0;
    m_dwAdvf = dwAdvf;
    if(pAdvSink && IsValidInterface(pAdvSink)) {
        m_pAdvSink = pAdvSink;
        m_pAdvSink->AddRef();
    }
    else
        m_pAdvSink = NULL;
    m_dwConnID = dwConnID;
    
    // Copy the FormatEtc
    if(!UtCopyFormatEtc(foretc, &m_foretc))
        m_ulFlags |= SDFLAG_OUTOFMEMORY;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CStatData::~CStatData, public
//
//	Synopsis:
//		Destructor
//
//	Arguments:
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CStatData::~CStatData()
{
    // Release the advise sink
    if(m_pAdvSink)
        m_pAdvSink->Release();
    
    // Delete the ptd if it is non-null
    if(m_foretc.ptd)
        PubMemFree(m_foretc.ptd);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CStatData::operator=, public
//
//	Synopsis:
//		Equality operator
//
//	Arguments:
//              rStatData [in] - The RHS value 
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
const CStatData& CStatData::operator=(const CStatData& rStatData)
{
    // Check to see, if this a=a case
    if(this==&rStatData)
        return(*this);

    // Self destroy
    CStatData::~CStatData();

    // Initialize 
    m_ulFlags = 0;
    m_dwAdvf = rStatData.m_dwAdvf;
    m_pAdvSink = rStatData.m_pAdvSink;
    if(m_pAdvSink)
        m_pAdvSink->AddRef();
    m_dwConnID = rStatData.m_dwConnID;
    
    // Copy the FormatEtc
    if(!UtCopyFormatEtc((LPFORMATETC) &rStatData.m_foretc, &m_foretc))
        m_ulFlags |= SDFLAG_OUTOFMEMORY;

    return(*this);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumStatData::CreateEnumStatData, public
//
//	Synopsis:
//		A static member functions that creates a properly constructed
//              StatData Enumerator given the cachenode array of the cache
//
//	Arguments:
//		[pCacheArray]  [in] -- Array of CacheNode maintained by COleCache
//
//      Returns:
//              Pointer to a properly constructed cache enumerator interface
//              NULL otherwise.
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
LPENUMSTATDATA CEnumStatData::CreateEnumStatData(CArray<CCacheNode>* pCacheArray)
{
    CEnumStatData* EnumStatData = new CEnumStatData(pCacheArray);
    if(EnumStatData && !(EnumStatData->m_ulFlags & CENUMSDFLAG_OUTOFMEMORY))
        return ((IEnumSTATDATA *) EnumStatData);

    if(EnumStatData)
        EnumStatData->Release();

    return(NULL);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumStatData::CEnumStatData, private
//
//	Synopsis:
//		Constructor
//
//	Arguments:
//		[pCacheArray]  [in] -- Array of CacheNode maintained by COleCache
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CEnumStatData::CEnumStatData(CArray<CCacheNode>* pCacheArray)
{
    // Local variables
    ULONG i, CNindex, SDindex;
    LPCACHENODE lpCacheNode;
    CStatData* pStatData;

    // Initilaize
    m_ulFlags = 0;
    m_refs = 1;

    // Create the StatData array
    m_pSDArray = CArray<CStatData>::CreateArray(pCacheArray->Length());
    if(m_pSDArray) {
        // Enumerate the cache nodes
        pCacheArray->Reset(CNindex);
        for(i=0;i<pCacheArray->Length();i++) {
            // Get the next cache node
            lpCacheNode = pCacheArray->GetNext(CNindex);
            // pCacheNode cannot be null
            Win4Assert(lpCacheNode);

            // Create a StatData object representing the cachenode
            CStatData StatData((FORMATETC *)lpCacheNode->GetFormatEtc(),
                               lpCacheNode->GetAdvf(), NULL, CNindex);
            if(StatData.m_ulFlags & SDFLAG_OUTOFMEMORY) {
                m_ulFlags |= CENUMSDFLAG_OUTOFMEMORY;
                break;
            }
            
            // Add the StatData object to the array
            SDindex = m_pSDArray->AddItem(StatData);
            if(SDindex) {
                // Get the newly added StatData object
                pStatData = m_pSDArray->GetItem(SDindex);
                Win4Assert(pStatData);
            
                if(pStatData->m_ulFlags & SDFLAG_OUTOFMEMORY) {
                    m_ulFlags |= CENUMSDFLAG_OUTOFMEMORY;
                    break;
                }
            }
            else {
                m_ulFlags |= CENUMSDFLAG_OUTOFMEMORY;
                break;
            }

            // Check if cachenode format is CF_DIB
            if(lpCacheNode->GetFormatEtc()->cfFormat == CF_DIB) {
                // We need to add CF_BITMAP format also.
                // Add another StatData item
                SDindex = m_pSDArray->AddItem(StatData);
            
                if(SDindex) {
                    // Get the newly added StatData object
                    pStatData = m_pSDArray->GetItem(SDindex);
                    Win4Assert(pStatData);
                    
                    if(pStatData->m_ulFlags & SDFLAG_OUTOFMEMORY) {
                        m_ulFlags |= CENUMSDFLAG_OUTOFMEMORY;
                        break;
                    }
                    else {
                        pStatData->m_foretc.cfFormat = CF_BITMAP;
                        pStatData->m_foretc.tymed = TYMED_GDI;
                    }
                }
                else {
                    m_ulFlags |= CENUMSDFLAG_OUTOFMEMORY;
                    break;
                }
            }
        }
    }
    else
        m_ulFlags |= CENUMSDFLAG_OUTOFMEMORY;

    // Reset the index
    if(m_pSDArray)
        m_pSDArray->Reset(m_index);

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumStatData::CEnumStatData, private
//
//	Synopsis:
//		Copy constructor
//
//	Arguments:
//		[EnumStatData] [in] -- StatData Enumerator to be copied
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CEnumStatData::CEnumStatData(CEnumStatData& EnumStatData)
{
    // Initialize
    m_ulFlags = EnumStatData.m_ulFlags;
    m_refs = 1;
    m_index = EnumStatData.m_index;

    // Copy the StatData array and add ref it
    m_pSDArray = EnumStatData.m_pSDArray;
    if(m_pSDArray)
        m_pSDArray->AddRef();
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumStatData::~CEnumStatData, private
//
//	Synopsis:
//		Desstructor
//
//	Arguments:
//              NONE
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CEnumStatData::~CEnumStatData()
{
    if(m_pSDArray) {
        m_pSDArray->Release();
        m_pSDArray = NULL;
    }

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumStatData::QueryInterface, public
//
//	Synopsis:
//              Implements IUnknown::QueryInterface
//
//      Arguments:
//              [iid] [in]  -- IID of the desired interface
//              [ppv] [out] -- pointer to where the requested interface is returned
//
//      Returns:
//              NOERROR if the requested interface is available
//              E_NOINTERFACE otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumStatData::QueryInterface(REFIID riid, LPVOID* ppv)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Get the requested Interface
    if(IsEqualIID(riid, IID_IUnknown))
        *ppv = (void *)(IUnknown *) this;
    else if(IsEqualIID(riid, IID_IEnumSTATDATA))
        *ppv = (void *)(IEnumSTATDATA *) this;
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    // AddRef through the interface being returned
    ((IUnknown *) *ppv)->AddRef();

    return(NOERROR);
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumStatData::AddRef, public
//
//      Synopsis:
//              Implements IUnknown::AddRef
//
//      Arguments:
//              None
//
//      Returns:
//              Object's reference count
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumStatData::AddRef()
{
    // Validation checks
    VDATEHEAP();
    if(!VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    return m_refs++;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumStatData::Release, public
//
//      Synopsis:
//              Implements IUnknown::Release
//
//      Arguments:
//              None
//
//      Returns:
//              Object's reference count
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumStatData::Release()
{
    // Validation checks
    VDATEHEAP();
    if(!VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    if(--m_refs == 0) {
        delete this;
        return 0;
    }

    return m_refs;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumStatData::Next, public
//
//      Synopsis:
//              Implements IEnumSTATDATA::Next
//
//      Arguments:
//              [celt]         [in]     -- the number of items the caller likes
//                                         to be returned
//              [rgelt]        [in]     -- a pointer to an array where items are
//                                         to be returned
//              [pceltFetched] [in/out] -- a pointer where the count of actual
//                                         number of items returned. May be NULL
//
//      Returns:
//              NOERROR if the number of items returned is same as requested
//              S_FALSE if fewer items are returned
//              E_OUTOFMEMORY if memory allocation was not successful for 
//                            copying the target device of FORMATETC 
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumStatData::Next(ULONG celt, STATDATA* rgelt, ULONG* pceltFetched)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    if(celt<1)
        return E_INVALIDARG;
    if(celt>1 && pceltFetched==NULL && !IsWOWThread())
        return E_INVALIDARG;
    if(!IsValidPtrOut(rgelt, sizeof(rgelt[0])*celt))
        return E_INVALIDARG;
    if(pceltFetched)
        VDATEPTROUT(pceltFetched, ULONG);

    // Local variables
    HRESULT error=NOERROR;
    ULONG cntFetched;
    CStatData* pStatData;

    // Enumerate the StatData Array
    for(cntFetched=0;cntFetched<celt;cntFetched++) {
        // Fetch the next StatData object
        pStatData = m_pSDArray->GetNext(m_index);
        if(!pStatData) {
            error = S_FALSE;
            break;
        }

        // Copy the FormatEtc
        if(!UtCopyFormatEtc(&pStatData->m_foretc, &rgelt[cntFetched].formatetc)) {
            error = ResultFromScode(E_OUTOFMEMORY);
            break;
        }
        // Copy the rest of StatData fields
        rgelt[cntFetched].advf = pStatData->m_dwAdvf;
        rgelt[cntFetched].pAdvSink = pStatData->m_pAdvSink;
        if(rgelt[cntFetched].pAdvSink)
            rgelt[cntFetched].pAdvSink->AddRef();
        rgelt[cntFetched].dwConnection = pStatData->m_dwConnID;
    }

    // Copy the number of items being returned
    if(pceltFetched)
        *pceltFetched = cntFetched;

    return error;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumStatData::Skip, public
//
//      Synopsis:
//              Implements IEnumSTATDATA::Skip
//
//      Arguments:
//              [celt] [in] -- the number of items the caller likes to be skipped
//
//      Returns:
//              NOERROR if the number of items skipped is same as requested
//              S_FALSE if fewer items are returned
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumStatData::Skip(ULONG celt)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variables
    HRESULT error=NOERROR;
    ULONG cntSkipped;
    CStatData* pStatData;

    // Enumerate the StatData Array
    for(cntSkipped=0;cntSkipped<celt;cntSkipped++) {
        // Fetch the next StatData object
        pStatData = m_pSDArray->GetNext(m_index);
        if(!pStatData) {
            error = S_FALSE;
            break;
        }
    }

    return error;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumStatData::Reset, public
//
//      Synopsis:
//              Implements IEnumSTATDATA::Reset
//
//      Arguments:
//              NONE
//
//      Returns:
//              NOERROR
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumStatData::Reset()
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Reset the current index
    m_pSDArray->Reset(m_index);

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumStatData::Clone, public
//
//      Synopsis:
//              Implements IEnumSTATDATA::Clone
//
//      Arguments:
//              [ppenum] [out] -- pointer where the newly created StatData 
//                                enumerator is returned
//
//      Returns:
//              NOERROR if a new StatData enumerator is returned
//              E_OUTOFMEMORY otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumStatData::Clone(LPENUMSTATDATA* ppenum)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEPTROUT(ppenum, LPENUMSTATDATA);

    // Create a new StatData enumerator
    CEnumStatData* EnumStatData = new CEnumStatData(*this);
    if(EnumStatData)
        *ppenum = (IEnumSTATDATA *) EnumStatData;
    else
        return ResultFromScode(E_OUTOFMEMORY);

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CFormatEtc::CFormatEtc, public
//
//	Synopsis:
//		Constructor
//
//	Arguments:
//		[foretc]       [in] -- FormatEtc
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CFormatEtc::CFormatEtc(FORMATETC* foretc)
{    
    // Initialize
    m_ulFlags = 0;

    // Copy the FormatEtc
    if(!UtCopyFormatEtc(foretc, &m_foretc))
        m_ulFlags |= FEFLAG_OUTOFMEMORY;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CFormatEtc::~CFormatEtc, public
//
//	Synopsis:
//		Destructor
//
//	Arguments:
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CFormatEtc::~CFormatEtc()
{  
    // Delete the ptd if it is non-null
    if(m_foretc.ptd)
        PubMemFree(m_foretc.ptd);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CFormatEtc::operator=, public
//
//	Synopsis:
//		Equality operator
//
//	Arguments:
//              rFormatEtc [in] - The RHS value 
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
const CFormatEtc& CFormatEtc::operator=(const CFormatEtc& rFormatEtc)
{
    // Check to see, if this a=a case
    if(this==&rFormatEtc)
        return(*this);

    // Self destroy
    CFormatEtc::~CFormatEtc();

    // Copy the FormatEtc
    if(!UtCopyFormatEtc((LPFORMATETC) &rFormatEtc.m_foretc, &m_foretc))
        m_ulFlags |= FEFLAG_OUTOFMEMORY;

    return(*this);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumFormatEtc::CreateEnumFormatEtc, public
//
//	Synopsis:
//		A static member function that creates a properly constructed
//              FormatEtc Enumerator given the cachenode array of the cache
//
//	Arguments:
//		[pCacheArray]  [in] -- Array of CacheNode maintained by COleCache
//
//      Returns:
//              Pointer to a properly constructed FormatEtc enumerator interface
//              NULL otherwise.
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
LPENUMFORMATETC CEnumFormatEtc::CreateEnumFormatEtc(CArray<CCacheNode>* pCacheArray)
{
    CEnumFormatEtc* EnumFormatEtc = new CEnumFormatEtc(pCacheArray);
    if(EnumFormatEtc && !(EnumFormatEtc->m_ulFlags & CENUMFEFLAG_OUTOFMEMORY))
        return ((IEnumFORMATETC *) EnumFormatEtc);

    if(EnumFormatEtc)
        EnumFormatEtc->Release();

    return(NULL);
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumFormatEtc::CEnumFormatEtc, private
//
//	Synopsis:
//		Constructor
//
//	Arguments:
//		[pCacheArray]  [in] -- Array of CacheNode maintained by COleCache
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CEnumFormatEtc::CEnumFormatEtc(CArray<CCacheNode>* pCacheArray)
{
    // Local variables
    ULONG i, CNindex, FEindex;
    LPCACHENODE lpCacheNode;
    CFormatEtc* pFormatEtc;

    // Initilaize
    m_ulFlags = 0;
    m_refs = 1;

    // Create the FormatEtc array
    m_pFEArray = CArray<CFormatEtc>::CreateArray(pCacheArray->Length());
    if(m_pFEArray) {
        // Enumerate the cache nodes
        pCacheArray->Reset(CNindex);
        for(i=0;i<pCacheArray->Length();i++) {
            // Get the next cache node
            lpCacheNode = pCacheArray->GetNext(CNindex);
            // pCacheNode cannot be null
            Win4Assert(lpCacheNode);

            // Create a FormatEtc object representing the cachenode
            CFormatEtc FormatEtc((FORMATETC *)lpCacheNode->GetFormatEtc());
            if(FormatEtc.m_ulFlags & FEFLAG_OUTOFMEMORY) {
                m_ulFlags |= CENUMFEFLAG_OUTOFMEMORY;
                break;
            }

            // Add the FormatEtc object to the array
            FEindex = m_pFEArray->AddItem(FormatEtc);
            if(FEindex) {
                // Get the newly added FormatEtc object
                pFormatEtc = m_pFEArray->GetItem(FEindex);
                Win4Assert(pFormatEtc);
            
                if(pFormatEtc->m_ulFlags & FEFLAG_OUTOFMEMORY) {
                    m_ulFlags |= CENUMFEFLAG_OUTOFMEMORY;
                    break;
                }
            }
            else {
                m_ulFlags |= CENUMFEFLAG_OUTOFMEMORY;
                break;
            }

            // Check if cachenode format is CF_DIB
            if(lpCacheNode->GetFormatEtc()->cfFormat == CF_DIB) {
                // We need to add CF_BITMAP format also.
                // Add another FormatEtc object
                FEindex = m_pFEArray->AddItem(FormatEtc);
            
                if(FEindex) {
                    // Get the newly added FormatEtc object
                    pFormatEtc = m_pFEArray->GetItem(FEindex);
                    Win4Assert(pFormatEtc);
                    
                    if(pFormatEtc->m_ulFlags & FEFLAG_OUTOFMEMORY) {
                        m_ulFlags |= CENUMFEFLAG_OUTOFMEMORY;
                        break;
                    }
                    else {
                        pFormatEtc->m_foretc.cfFormat = CF_BITMAP;
                        pFormatEtc->m_foretc.tymed = TYMED_GDI;
                    }
                }
                else {
                    m_ulFlags |= CENUMFEFLAG_OUTOFMEMORY;
                    break;
                }
            }
        }
    }
    else
        m_ulFlags |= CENUMFEFLAG_OUTOFMEMORY;

    // Reset the index
    if(m_pFEArray)
        m_pFEArray->Reset(m_index);

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumFormatEtc::CEnumFormatEtc, private
//
//	Synopsis:
//		Copy constructor
//
//	Arguments:
//		[EnumFormatEtc] [in] -- FormatEtc Enumerator to be copied
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CEnumFormatEtc::CEnumFormatEtc(CEnumFormatEtc& EnumFormatEtc)
{
    // Initialize
    m_ulFlags = EnumFormatEtc.m_ulFlags;
    m_refs = 1;
    m_index = EnumFormatEtc.m_index;

    // Copy the FormatEtc array and add ref it
    m_pFEArray = EnumFormatEtc.m_pFEArray;
    if(m_pFEArray)
        m_pFEArray->AddRef();
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumFormatEtc::~CEnumFormatEtc, private
//
//	Synopsis:
//		Desstructor
//
//	Arguments:
//              NONE
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
CEnumFormatEtc::~CEnumFormatEtc()
{
    if(m_pFEArray) {
        m_pFEArray->Release();
        m_pFEArray = NULL;
    }

    return;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumFormatEtc::QueryInterface, public
//
//	Synopsis:
//              Implements IUnknown::QueryInterface
//
//      Arguments:
//              [iid] [in]  -- IID of the desired interface
//              [ppv] [out] -- pointer to where the requested interface is returned
//
//      Returns:
//              NOERROR if the requested interface is available
//              E_NOINTERFACE otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumFormatEtc::QueryInterface(REFIID riid, LPVOID* ppv)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Get the requested Interface
    if(IsEqualIID(riid, IID_IUnknown))
        *ppv = (void *)(IUnknown *) this;
    else if(IsEqualIID(riid, IID_IEnumFORMATETC))
        *ppv = (void *)(IEnumFORMATETC *) this;
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    // AddRef through the interface being returned
    ((IUnknown *) *ppv)->AddRef();

    return(NOERROR);
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumFormatEtc::AddRef, public
//
//      Synopsis:
//              Implements IUnknown::AddRef
//
//      Arguments:
//              None
//
//      Returns:
//              Object's reference count
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef()
{
    // Validation checks
    VDATEHEAP();
    if(!VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    return m_refs++;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumFormatEtc::Release, public
//
//      Synopsis:
//              Implements IUnknown::Release
//
//      Arguments:
//              None
//
//      Returns:
//              Object's reference count
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumFormatEtc::Release()
{
    // Validation checks
    VDATEHEAP();
    if(!VerifyThreadId())
        return((ULONG) RPC_E_WRONG_THREAD);

    if(--m_refs == 0) {
        delete this;
        return 0;
    }

    return m_refs;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumFormatEtc::Next, public
//
//      Synopsis:
//              Implements IEnumFORMATETC::Next
//
//      Arguments:
//              [celt]         [in]     -- the number of items the caller likes
//                                         to be returned
//              [rgelt]        [in]     -- a pointer to an array where items are
//                                         to be returned
//              [pceltFetched] [in/out] -- a pointer where the count of actual
//                                         number of items returned. May be NULL
//
//      Returns:
//              NOERROR if the number of items returned is same as requested
//              S_FALSE if fewer items are returned
//              E_OUTOFMEMORY if memory allocation was not successful for 
//                            copying the target device of FORMATETC 
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumFormatEtc::Next(ULONG celt, FORMATETC* rgelt, ULONG* pceltFetched)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    if(celt<1)
        return E_INVALIDARG;
    if(celt>1 && pceltFetched==NULL && !IsWOWThread())
        return E_INVALIDARG;
    if(!IsValidPtrOut(rgelt, sizeof(rgelt[0])*celt))
        return E_INVALIDARG;
    if(pceltFetched)
        VDATEPTROUT(pceltFetched, ULONG);

    // Local variables
    HRESULT error=NOERROR;
    ULONG cntFetched;
    CFormatEtc* pFormatEtc;

    // Enumerate the FormatEtc Array
    for(cntFetched=0;cntFetched<celt;cntFetched++) {
        // Fetch the next FormatEtc object
        pFormatEtc = m_pFEArray->GetNext(m_index);
        if(!pFormatEtc) {
            error = S_FALSE;
            break;
        }

        // Copy the FormatEtc
        if(!UtCopyFormatEtc(&pFormatEtc->m_foretc, &rgelt[cntFetched])) {
            error = ResultFromScode(E_OUTOFMEMORY);
            break;
        }
    }

    // Copy the number of items being returned
    if(pceltFetched)
        *pceltFetched = cntFetched;

    return error;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumFormatEtc::Skip, public
//
//      Synopsis:
//              Implements IEnumFORMATETC::Skip
//
//      Arguments:
//              [celt] [in] -- the number of items the caller likes to be skipped
//
//      Returns:
//              NOERROR if the number of items skipped is same as requested
//              S_FALSE if fewer items are returned
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumFormatEtc::Skip(ULONG celt)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Local variables
    HRESULT error=NOERROR;
    ULONG cntSkipped;
    CFormatEtc* pFormatEtc;

    // Enumerate the FormatEtc Array
    for(cntSkipped=0;cntSkipped<celt;cntSkipped++) {
        // Fetch the next FormatEtc object
        pFormatEtc = m_pFEArray->GetNext(m_index);
        if(!pFormatEtc) {
            error = S_FALSE;
            break;
        }
    }

    return error;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumFormatEtc::Reset, public
//
//      Synopsis:
//              Implements IEnumFORMATETC::Reset
//
//      Arguments:
//              NONE
//
//      Returns:
//              NOERROR
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumFormatEtc::Reset()
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);

    // Reset the current index
    m_pFEArray->Reset(m_index);

    return NOERROR;
}

//+----------------------------------------------------------------------------
//
//      Member:
//              CEnumFormatEtc::Clone, public
//
//      Synopsis:
//              Implements IEnumFORMATETC::Clone
//
//      Arguments:
//              [ppenum] [out] -- pointer where the newly created FormatEtc 
//                                enumerator is returned
//
//      Returns:
//              NOERROR if a new FormatEtc enumerator is returned
//              E_OUTOFMEMORY otherwise
//
//	History:
//               Gopalk            Creation        Sep 04, 96
//
//-----------------------------------------------------------------------------
STDMETHODIMP CEnumFormatEtc::Clone(LPENUMFORMATETC* ppenum)
{
    // Validation checks
    VDATEHEAP();
    VDATETHREAD(this);
    VDATEPTROUT(ppenum, LPENUMFORMATETC);

    // Create a FormatEtc enumerator
    CEnumFormatEtc* EnumFormatEtc = new CEnumFormatEtc(*this);
    if(EnumFormatEtc)
        *ppenum = (IEnumFORMATETC *) EnumFormatEtc;
    else
        return ResultFromScode(E_OUTOFMEMORY);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\cache\dacache.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              dacache.cpp
//
//      Contents:
//              implementation of the data advise cache - CDataAdviseCache
//
//      Classes:
//              CDataAdviseCache
//
//      Functions:
//
//      History:
//              31-Jan-95 t-ScottH  add Dump method to CDataAdviseCache and
//                                  DumpCDataAdviseCache API
//              24-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocation
//              01/11/94 - AlexGo  - added VDATEHEAP macros to every function
//                      and method
//              11/02/93 - ChrisWe - file inspection and cleanup
//              12/15/92 - JasonFul - Created
//
//-----------------------------------------------------------------------------

#include <le2int.h>

#pragma SEG(dacache)

#include <dacache.h>
#include <reterr.h>

#ifdef _DEBUG
#include <dbgdump.h>
#include <daholder.h>
#endif // _DEBUG

ASSERTDATA


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::CreateDataAdviseCache, static public
//
//      Synopsis:
//              Creates an instance of the CDataAdviseCache
//
//      Arguments:
//              [pp] -- pointer to a location to where to return the
//                      newly created CDataAdviseCache
//
//      Returns:
//              E_OUTOFMEMORY, S_OK
//
//      Notes:
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CreateDataAdviseCache)
FARINTERNAL CDataAdviseCache::CreateDataAdviseCache(LPDATAADVCACHE FAR* pp)
{
	VDATEHEAP();

	VDATEPTRIN(pp, LPDATAADVCACHE);

	// try to allocate the CDataAdviseCache
	if(NULL == (*pp = new DATAADVCACHE))
		return ReportResult(0, E_OUTOFMEMORY, 0, 0);

	// initialize the DataAdviseHolder member
	if(CreateDataAdviseHolder(&((*pp)->m_pDAH)) != NOERROR)
	{
		// free the DataAdviseCache
		delete *pp;
		*pp = NULL;

		return ReportResult(0, E_OUTOFMEMORY, 0, 0);
	}

	return(NOERROR);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::CDataAdviseCache, private
//
//      Synopsis:
//              constructor
//
//      Arguments:
//              none
//
//      Notes:
//              This is private because it does not create a fully
//              formed CDataAdviseCache.  m_pDAH must be allocated before
//              this can be used.  That is done by the static member
//              CreateDataAdviseCache, which first calls this
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_ctor)
CDataAdviseCache::CDataAdviseCache():
	m_mapClientToDelegate(MEMCTX_TASK)
{
	VDATEHEAP();

	//now allocated with system allocator
	//Assert(CoMemctxOf(this) == MEMCTX_TASK);

	// no data advise holder allocated yet
	m_pDAH = NULL;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::~CDataAdviseCache, public
//
//      Synopsis:
//              destructor
//
//      Arguments:
//              none
//
//      Requires:
//              successful call to CreateDataAdviseCache
//
//      Notes:
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_dtor)
CDataAdviseCache::~CDataAdviseCache()
{
	VDATEHEAP();

	// release the data advise holder
	if( m_pDAH )
	{
		m_pDAH->Release();
	}
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::Advise, public
//
//      Synopsis:
//              Records an advise sink for later use.  The sink will be
//              registered with the data object, if there is one, and
//              will be remembered for later registration with the data object,
//              in case it should go away, and return later.
//
//      Effects:
//
//      Arguments:
//              [pDataObject] -- the data object that the advise sink is
//                      interested in changes to; may be null if the
//                      data object isn't running
//              [pFetc] -- the format the advise sink would like to recieve
//                      new data in
//              [advf] -- advise control flags ADVF_*
//              [pAdvise] -- the advise sink
//              [pdwClient] -- a token identifying the connection
//
//      Returns:
//              E_OUTOFMEMORY, S_OK
//
//      Notes:
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_Advise)
HRESULT CDataAdviseCache::Advise(LPDATAOBJECT pDataObject,
		FORMATETC FAR* pFetc, DWORD advf, LPADVISESINK pAdvise,
		DWORD FAR* pdwClient)
		// first 4 parms are as in DataObject::Advise
{
	VDATEHEAP();

	DWORD dwDelegate = 0; // the delegate connection number
	HRESULT hr;

	// if there is a data object, ask to be advised of changes
	if(pDataObject != NULL)
		RetErr(pDataObject->DAdvise(pFetc, advf, pAdvise, &dwDelegate));

	// if there is no data object, (i.e. the object is not active,
	// dwDelegate is zero

	// Here we are using the data advise holder only to hold advise
	// connections. We are not going to use it to send OnDataChange to
	// sinks.
	
	// REVIEW, handling of ADVF_ONLYONCE seems broken...
	// it's clear that we can't cope with this flag properly;  we have
	// no way of knowing when the notification takes place, and therefore
	// we can't remove the entry from m_pDAH.  The notification may have
	// taken place above, and it may not have.  If the data object wasn't
	// around, then the advise request here is lost, and the sink will
	// never be notified.  Or, if the request isn't PRIMEFIRST, and the
	// data object is deactivated, then the data object loses the request,
	// and on subsequent activation, we won't readvise it on EnumAndAdvise.
	// So, what good are we for ONLYONCE sinks?  What does this break?
	if(advf & ADVF_ONLYONCE)
		return  NOERROR;

	// keep a local copy of the advise
	hr = m_pDAH->Advise(NULL, pFetc, advf, pAdvise, pdwClient);

	// if we failed to keep a local reference to the advise sink,
	// we won't be able to maintain this mapping, so remove the
	// advise on the data object, if there is one
	if (hr != NOERROR)
	{
	Exit1:
		if (pDataObject != NULL)
			pDataObject->DUnadvise(dwDelegate);

		return(hr);
	}

	// create a map entry from *pdwClient -> dwDelegate

	// if the map entry creation failed, undo all work
	if (m_mapClientToDelegate.SetAt(*pdwClient, dwDelegate) != TRUE)
	{
		// map failed to allocate memory, undo advise since we won't
		// be able to find this one again
		m_pDAH->Unadvise(*pdwClient);

		// map entry creation must have failed from lack of allocation
		hr = ReportResult(0, E_OUTOFMEMORY, 0, 0);

		// undo the advise on the data object
		goto Exit1;
	}

	return(NOERROR);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::Unadvise, public
//
//      Synopsis:
//              Remove an advise sink from the list of sinks the advise cache
//              maintains; the sink is also removed from the list of items
//              registered with the data object, if the data object is provided
//
//      Effects:
//
//      Arguments:
//              [pDataObject] -- the data object, if it is running, or NULL
//              [dwClient] -- the token that identifies this connection
//
//      Returns:
//              OLE_E_NOCONNECTION, for a bad dwClient
//              S_OK
//
//      Notes:
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_Unadvise)
HRESULT CDataAdviseCache::Unadvise(IDataObject FAR* pDataObject, DWORD dwClient)
{
	VDATEHEAP();

	DWORD dwDelegate = 0;

	// retrieve dwDelegate before removing from map
	if(pDataObject != NULL)
		RetErr(ClientToDelegate(dwClient, &dwDelegate));

	// do these first so error from remote unadvise is last(which might
	// be sync call during async dispatch

	RetErr(m_pDAH->Unadvise(dwClient));

	// If the above line succeeded, Remove Key must succeed.
	Verify(TRUE == m_mapClientToDelegate.RemoveKey(dwClient));

	// Delegate connection could be 0 if it did not accept the Advise
	if(pDataObject != NULL && dwDelegate != 0)
	{
		// Unadvise is asynchronous, don't worry about return value
		pDataObject->DUnadvise(dwDelegate);
	}
	
	return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::EnumAdvise, public
//
//      Synopsis:
//              returns an enumerator over the advisory connections
//
//      Arguments:
//              [ppenumAdvise] -- pointer to where to return the enumerator
//
//      Returns:
//              E_OUTOFMEMORY, S_OK
//
//      Notes:
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_EnumAdvise)
HRESULT CDataAdviseCache::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
	VDATEHEAP();

	return m_pDAH->EnumAdvise(ppenumAdvise);
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::ClientToDelegate, private
//
//      Synopsis:
//              returns the delegate connection id for a given client
//              connection id
//
//      Arguments:
//              [dwClient] -- the client connection identifier
//              [pdwDelegate] -- pointer to where to return the delegate
//                      connection identifier
//
//      Returns:
//              OLE_E_NOCONNECTION, for a bad dwClient
//              S_OK
//
//      Notes:
//
//      History:
//              11/02/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_ClientToDelegate)
HRESULT CDataAdviseCache::ClientToDelegate(DWORD dwClient,
		DWORD FAR* pdwDelegate)
{
	VDATEHEAP();

	VDATEPTRIN(pdwDelegate, DWORD);
	DWORD dwDelegate = *pdwDelegate = 0;

	if (FALSE == m_mapClientToDelegate.Lookup(dwClient, dwDelegate))
		return(ReportResult(0, OLE_E_NOCONNECTION, 0, 0));

	*pdwDelegate = dwDelegate;
	return NOERROR;
}


//+----------------------------------------------------------------------------
//
//      Member:
//              CDataAdviseCache::EnumAndAdvise, public
//
//      Synopsis:
//              Enumerate all the advise sinks registered in the data advise
//              cache.  For each one, either register it with the
//              given data object, or deregister it, depending on [fAdvise].
//              Does not change what sinks are known to the data advise cache.
//
//      Effects:
//
//      Arguments:
//              [pDataDelegate] -- a data object that the advise sinks
//                      are interested in
//              [fAdvise] -- if TRUE, register the advise sinks with
//                      pDataDelegate object (with IDataObject::DAdvise();) if
//                      FALSE, the deregister the advise sinks
//                      (with DUnadvise().)
//
//      Returns:
//              OLE_E_NOCONNECTION, if the mapping is corrupt  (REVIEW!)
//              S_OK
//
//      Notes:
//
//      History:
//              11/04/93 - ChrisWe - file cleanup and inspection
//-----------------------------------------------------------------------------

#pragma SEG(CDataAdviseCache_EnumAndAdvise)
HRESULT CDataAdviseCache::EnumAndAdvise(LPDATAOBJECT pDataDelegate,
		BOOL fAdvise)
{
	VDATEHEAP();

	if(pDataDelegate) {
            VDATEIFACE(pDataDelegate);
        }
        else {
            Win4Assert(!fAdvise);
        }
	LPENUMSTATDATA penumAdvise; // enumerator for the data advise holder
	DWORD dwDelegate; // delegate connection id for the current connection
	STATDATA statdata; // filled in by the penumAdvise enumerator
	HRESULT hresult = NOERROR; // current error status

	// get an enumerator from the data advise holder
	RetErr(m_pDAH->EnumAdvise(&penumAdvise));

	// repeat for each advise sink in the data advise holder...
	while(NOERROR == penumAdvise->Next(1, &statdata, NULL))
	{
		if(fAdvise)
		{
			// It is possible that the delegate's Advise will fail
			// even though we allowed the advise on the loaded
			// object to succeed(because the delegate is "pickier".)
			if(NOERROR==pDataDelegate->DAdvise(&statdata.formatetc,
					statdata.advf, statdata.pAdvSink,
					&dwDelegate))
			{
				// we know the key is present; this SetAt
				// should not fail
				Verify(m_mapClientToDelegate.SetAt(
						statdata.dwConnection,
						dwDelegate));
			}
		}
		else // unadvise
		{
			if((hresult=ClientToDelegate(statdata.dwConnection,
					&dwDelegate)) != NOERROR)
			{
				AssertSz(0, "Corrupt mapping");
				UtReleaseStatData(&statdata);
				goto errRtn;
			}
				
			if(dwDelegate != 0) {
                            // Unadvise only if valid object
                            if(pDataDelegate)
                                pDataDelegate->DUnadvise(dwDelegate);

                            // Always remove the key 
                            Verify(m_mapClientToDelegate.SetAt(statdata.dwConnection, 0));
			}
		}
		UtReleaseStatData(&statdata);
	}

  errRtn:

	// release the enumerator
	penumAdvise->Release();
	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDataAdviseCache::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CDataAdviseCache::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDAH;
    char *pszCMapDD;
    dbgstream dstrPrefix;
    dbgstream dstrDump(1000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    if (m_pDAH != NULL)
    {
        pszDAH = DumpCDAHolder((CDAHolder *)m_pDAH, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "CDAHolder: " << endl;
        dstrDump << pszDAH;
        CoTaskMemFree(pszDAH);
    }
    else
    {
        dstrDump << pszPrefix << "pIDataAdviseHolder   = " << m_pDAH    << endl;
    }

    pszCMapDD = DumpCMapDwordDword(&m_mapClientToDelegate, ulFlag, nIndentLevel + 1);
    dstrDump << pszPrefix << "Map of Clients to Delegate:"      << endl;
    dstrDump << pszCMapDD;
    CoTaskMemFree(pszCMapDD);

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCDataAdviseCache, public (_DEBUG only)
//
//  Synopsis:   calls the CDataAdviseCache::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pDAC]          - pointer to CDataAdviseCache
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCDataAdviseCache(CDataAdviseCache *pDAC, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pDAC == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pDAC->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\cache\enumtors.h ===
#ifndef _ENUMERATORS_
#define _ENUMERATORS_

#include <cachenod.h>
#include <array.hxx>

// Class CStatData 
#define SDFLAG_OUTOFMEMORY 1

class CStatData
{
public:
    // Public member functions 
    CStatData(FORMATETC* foretc, DWORD dwAdvf, IAdviseSink* pAdvSink, 
              DWORD dwConnID);
    ~CStatData();
    const CStatData& operator=(const CStatData& rStatData);

    // Public member variables
    unsigned long m_ulFlags;
    FORMATETC m_foretc;
    DWORD m_dwAdvf;
    IAdviseSink* m_pAdvSink;
    DWORD m_dwConnID;
};

// Class CEnumStatData
#define CENUMSDFLAG_OUTOFMEMORY 1

class CEnumStatData : public IEnumSTATDATA, public CPrivAlloc,
                      public CThreadCheck
{
public:
    // Public constructor
    static LPENUMSTATDATA CreateEnumStatData(CArray<CCacheNode>* pCacheArray);

    // Public IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // Public IEnumSTATDATA methods
    STDMETHOD(Next)(ULONG celt, STATDATA* rgelt, ULONG* pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(LPENUMSTATDATA* ppenum);

private:
    // Private constructor
    CEnumStatData(CArray<CCacheNode>* pCacheArray);

    // Private copy constructor
    CEnumStatData(CEnumStatData& EnumStatData);
    
    // Private Destructor
    ~CEnumStatData();

    // Private member variables
    unsigned long m_ulFlags;       // flags
    ULONG m_refs;                  // reference count
    ULONG m_index;                 // current index
    CArray<CStatData>* m_pSDArray; // internal array of statdata structures
};

// Class CFormatEtc
#define FEFLAG_OUTOFMEMORY 1

class CFormatEtc
{
public:
    // Public member functions 
    CFormatEtc(FORMATETC* foretc);
    ~CFormatEtc();
    const CFormatEtc& operator=(const CFormatEtc& rFormatEtc);

    // Public member variables
    unsigned long m_ulFlags;
    FORMATETC m_foretc;
};

// Class CEnumFormatEtc
#define CENUMFEFLAG_OUTOFMEMORY 1

class CEnumFormatEtc : public IEnumFORMATETC, public CPrivAlloc,
                       public CThreadCheck
{
public:
    // Public constructor
    static LPENUMFORMATETC CreateEnumFormatEtc(CArray<CCacheNode>* pCacheArray);

    // Public IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // Public IEnumFORMATETC methods
    STDMETHOD(Next)(ULONG celt, FORMATETC* rgelt, ULONG* pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(LPENUMFORMATETC* ppenum);

private:
    // Private constructor
    CEnumFormatEtc(CArray<CCacheNode>* pCacheArray);

    // Private copy constructor
    CEnumFormatEtc(CEnumFormatEtc& EnumFormatEtc);
    
    // Private Destructor
    ~CEnumFormatEtc();

    // Private member variables
    unsigned long m_ulFlags;        // flags
    ULONG m_refs;                   // reference count
    ULONG m_index;                  // current index
    CArray<CFormatEtc>* m_pFEArray; // internal array of FormatEtc structures
};

#endif // _ENUMERATORS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\cache\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   cache
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..;..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\cachenod.cpp \
              ..\dacache.cpp  \
              ..\olecache.cpp \
              ..\enumtors.cpp

UMTYPE=       windows

USE_IOSTREAM=1

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\ole232\clipbrd\clipapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       clipapi.cpp
//
//  Contents:   Clipboard related OLE API's
//
//  Classes:
//
//  Functions:
//              OleFlushClipboard
//              OleGetClipboard
//              OleIsCurrentClipboard
//              OleSetClipboard
//
//  History:    dd-mmm-yy Author    Comment
//              12-Aug-94 alexgo    added support for transfering
//                                  DVASPECT_ICON, etc.
//              08-Aug-94 BruceMa   Memory sift fix
//              10-Jun-94 alexgo    added support for OLE1 Containers
//              17-May-94 alexgo    created OleOpenClipboard and enhanced
//                                  code to mimize the times when the
//                                  clipboard is kept open.
//              25-Apr-94 alexgo    made thread-safe for the apartment model
//              16-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include <le2int.h>
#include <getif.hxx>
#include <clipbrd.h>
#include <olesem.hxx>
#include <ostm2stg.h>   // for wProgIDFromCLSID
#include "clipdata.h"

//
// types local to this file
//

typedef enum tagCLIPWNDFLAGS
{
    CLIPWND_REMOVEFROMCLIPBOARD     = 1,
    CLIPWND_IGNORECLIPBOARD         = 2,
    CLIPWND_DONTCALLAPP             = 4
} CLIPWNDFLAGS;

typedef enum tagGETCLSIDFLAGS
{
    USE_NORMAL_CLSID                = 1,
    USE_STANDARD_LINK               = 2,
} GETCLSIDFLAGS;


//
// functions local to this file.  They are not "static" so the symbols
// show up in ntsd debug builds.
//
extern "C" LRESULT ClipboardWndProc( HWND, UINT, WPARAM, LPARAM );
HRESULT GetDataFromDescriptor(IDataObject *pDataObj, LPCLSID pclsid,
            UINT cf, GETCLSIDFLAGS fFlags,
            LPOLESTR *ppszSrcOfCopy,
            DWORD *pdwStatus);
HRESULT GetDataFromStorage(IDataObject *pDataObj, UINT cf,
            STGMEDIUM *pmedium, IStorage **ppstg);
HRESULT GetDataFromStream(IDataObject *pDataObj, UINT cf,
            STGMEDIUM *pmedium, IStream **ppstm);
HRESULT GetNative(IDataObject *pDataObj, STGMEDIUM *pmedium);
HRESULT GetObjectLink(IDataObject *pDataObj, STGMEDIUM *pmedium);
HRESULT GetOwnerLink(IDataObject *pDataObj, STGMEDIUM *pmedium);
HRESULT HandleFromHandle(IDataObject *pDataObj, FORMATETC *pformatetc,
            STGMEDIUM *pmedium);
HRESULT MapCFToFormatetc( UINT cf, FORMATETC *pformatetc );
HRESULT RemoveClipboardDataObject( HWND hClipWnd, DWORD fFlags );
HRESULT RenderFormat( HWND hClipWnd, UINT cf, IDataObject *pDataObj );
HRESULT SetClipboardDataObject( HWND hClipWnd, IDataObject *pDataObj );
HRESULT SetClipboardFormats( HWND hClipWnd, IDataObject *pDataObj );
HWND VerifyCallerIsClipboardOwner( void );

HGLOBAL PersistDataObjectToHGlobal(IDataObject *lpDataObj);
HRESULT LoadPersistedDataObjectFromHGlobal(HGLOBAL hglobal, 
            IDataObject **ppDataObj);
void SetClipDataObjectInTLS(IDataObject **ppDataObj, DWORD dwClipSeqNum,
            BOOL fIsClipWrapper);
void GetClipDataObjectFromTLS(IDataObject **ppDataObj);
HRESULT CreateClipDataObjectFromPersistedData(IDataObject **ppDataObj);
HRESULT CreateWrapperClipDataObjectFromFormatsArray(IDataObject **ppDataObj);

//
//static variables
//

// vcClipboardInit is used to keep track of the number of times Clipboard
// Initialize is called (right now, only from OleInitialize), so that we
// only create a private clipboard window class once per dll (even though
// the many threads may need their own instance of the window class in the
// apartment model).

static ULONG vcClipboardInit;

// vszClipboardWndClass is the name of the window class used by OLE to
// create private clipboard windows for copy/paste and other clipboard
// data transfers.

static const OLECHAR vszClipboardWndClass[] = OLESTR("CLIPBRDWNDCLASS");
#define ClpWNDCLASS  WNDCLASS
#define ClpRegisterClass RegisterClass
#define ClpUnregisterClass UnregisterClass
#define ClpCreateWindowEx CreateWindowEx

// Mutex used to synchronize clipboard initialization / cleanup
extern COleStaticMutexSem g_mxsSingleThreadOle;

extern ATOM g_aDropTargetMarshalHwnd; // Atom for Delayed DragDrop Marshaling.



// WindowLong Offset for storing private data.
// so don't have to go to the clipboard to fetch it.
#define WL_ClipPrivateData 0 


//
// functions (in alphabetical order)
//


//+-------------------------------------------------------------------------
//
//  Function:   ClipboardInitialize (private)
//
//  Synopsis:   Creates the private clipboard window class (if necessary)
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:   hmodOLE2 must be initialized
//
//  Returns:    TRUE upon success, false otherwise
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Register the clipboard class only once per dll instance
//              (or more specifically, every time vcClipboardInit == 0,
//              which may happen multiple times in a WOW box).
//
//  History:    dd-mmm-yy Author    Comment
//              23-Oct-94 alexgo    fixed up Chicago WOW hacks (see comments)
//              25-Apr-94 alexgo    updated to the apartment model
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL ClipboardInitialize( void )
{
    ClpWNDCLASS        wc;
    BOOL            fRet = TRUE;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN ClipboardInitialize ( )\n", NULL));

    // serialize access to this function
    // we'll unlock the mutex automatically in "lck"'s destructor
    // (called at function exit)

    COleStaticLock lck(g_mxsSingleThreadOle);

    // One time initializtaion (when loaded for the first time)

    if (vcClipboardInit == 0)
    {
        // Register Clipboard window class
        wc.style                = 0;
        wc.lpfnWndProc          = ClipboardWndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = sizeof(void *);

        AssertSz(g_hmodOLE2, "Dll instance variable not set");

        wc.hInstance            = g_hmodOLE2; //global vairable set in
                          //ole2.cpp
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = vszClipboardWndClass;

        // register this window class, returning if we fail
        if (!ClpRegisterClass(&wc))
        {
            LEWARN(FALSE, "ClipboardInitialize RegisterClass failed!");

            // it is possible that our dll got unloaded without us
            // having called unregister, so we call it here and try
            // again.
            ClpUnregisterClass( vszClipboardWndClass, g_hmodOLE2 );
            if (!ClpRegisterClass(&wc))
            {
                LEWARN(FALSE, "ClipboardInitialize RegisterClass failed again!");
                LEDebugOut((DEB_WARN,
                "WARNING: RegisterClass failed\n"));
                fRet = FALSE;
                goto errRtn;
            }
	}

	vcClipboardInit++;
    }

errRtn:
    LEDebugOut((DEB_ITRACE, "%p OUT ClipboardIntialize ( %lu )\n",
        NULL, fRet));

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:	ClipboardUnitialize (internal)
//
//  Synopsis:	Uninitializes the clipboard for the current thread.
//
//  Effects:
//
//  Arguments:  void
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Oct-94 alexgo    fixed up Chicago WOW hacks (see comments)
//              25-Apr-94 alexgo    made thread-safe
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void ClipboardUninitialize(void)
{
    HRESULT hrTls;

    VDATEHEAP();

    //
    // This cleanup is done during OleUninitialize, but not
    // if somebody does FreeLibrary(OLE32.DLL). That would cause
    // us to leak the class register and any clipboard window.  We have
    // gotten around the class re-register problem above in the
    // ClipboardInitialize function, but we still leak a window.
    //
    // But since it is illegal to unload OLE32 without uninitializing
    // first, whoever does that can fully expect all kinds of leaks.
    //

    LEDebugOut((DEB_ITRACE, "%p _IN ClipboardUninitialize ( )\n", NULL));

    COleTls tls(hrTls);

    if (NOERROR == hrTls)
    {
    	if(tls->pDataObjClip)
    	{
    	    if (tls->fIsClipWrapper)
    	    {
                ((CClipDataObject *)tls->pDataObjClip)->InternalRelease(); 
    	    }
    	    else
    	    {
    	        (tls->pDataObjClip)->Release(); 
    	    }
    	    tls->pDataObjClip = NULL;
    	}

    	if(tls->hwndClip)
    	{
    	    // destroy the window and NULL out the hwnd in the thread
    	    // storage
    	    Verify(SSDestroyWindow(tls->hwndClip));
    	    tls->hwndClip = NULL;
    	}

    }
		
}

//+-------------------------------------------------------------------------
//
//  Function:	ClipboardProcessUnitialize (internal)
//
//  Synopsis:   Uninitializes the clipboard.  If this the last such time,
//              then the private clipboard window class is unregistered.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:   hmodOLE2 must be initialized before calling this function
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Oct-94 alexgo    fixed up Chicago WOW hacks (see comments)
//              25-Apr-94 alexgo    made thread-safe
//              16-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void ClipboardProcessUninitialize(void)
{
    // serialize access for the apartment model

    COleStaticLock lck(g_mxsSingleThreadOle);

    if(vcClipboardInit == 1)
    {
	vcClipboardInit--;

	BOOL fRet = ClpUnregisterClass(vszClipboardWndClass,
              g_hmodOLE2);

        LEWARN(!fRet, "UnRegisterClass failed!");
    }

    LEDebugOut((DEB_ITRACE, "%p OUT ClipboardUninitialize ( )\n", NULL));
}


//+-------------------------------------------------------------------------
//
//  Function:   ClipboardWndProc
//
//  Synopsis:   Window message procedure for the private clipboard window
//
//  Effects:
//
//  Arguments:  [hWnd]          -- handle to private clipboard window
//              [msg]           -- the Window message
//              [wParam]        -- parameter 1
//              [lParam]        -- parameter 2
//
//  Requires:
//
//  Returns:    LRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  processes messages sent to the private clipboard window:
//              WM_DESTROYCLIPBOARD: somebody else is taking ownership
//                      of the clipboard, so release the data object
//                      (if any)
//              WM_RENDERFORMAT: a request has been made for data of the
//                      specified format--actually put it on the clipboard
//              WM_RENDERALLFORMATS: the app is going away, so empty the
//                      clipboard!  The app is supposed to call
//                      OleFlushClipboard before exiting, if it hasn't, then
//                      we can only assume that the app is terminating
//                      "abnormally".  We currently do nothing for this call
//
//  History:    dd-mmm-yy Author    Comment
//              23-Oct-94 alexgo    added support for eating WM_CANCELMODE
//                                  messages
//              20-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C" LRESULT ClipboardWndProc( HWND hWnd, UINT msg, WPARAM wParam,
        LPARAM lParam )
{
    LRESULT         lresult = 0;
    IDataObject *   pDataObj = NULL;
    UINT            cf;
    HRESULT         hresult;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN ClipboardWndProc ( %lx , %u , %lu ,"
        " %ld )\n", NULL, hWnd, msg, wParam, lParam));

    AssertSz((GetCurrentThreadId()
                == GetWindowThreadProcessId(hWnd, NULL)),
                "Clip window not on current thread");

    switch( msg )
    {
    // note that the clipboard should *NOT* be opened for these messages
    case WM_OLE_CLIPBRD_MARSHALDROPTARGET:
        {
        HWND hwndDropTarget = (HWND) lParam;

             // Request has come through to marshal the DropTarget
             // Associated with the hwndDropTarget.
               
             // Assign the Endpoint Property, If Success, remove the property.
            if(NOERROR == AssignEndpointProperty(hwndDropTarget))
            {
                Win4Assert(NULL != g_aDropTargetMarshalHwnd);
                RemoveProp(hwndDropTarget,(LPCWSTR) g_aDropTargetMarshalHwnd);
            }

        }
        
        break;

    case WM_RENDERALLFORMATS:
        // this message is sent to us if this window (the private
        // clipboard window) is about to be destroyed.

        // We don't currently do anything for this message.
        // REVIEW: in the future, we may want to render all the
        // remaining formats.  However, the app is *supposed* to
        // call OleFlushClipboard to accomplish this task.

        Assert(lresult == 0);
        break;

    case WM_DESTROYCLIPBOARD:
        // we get this message when somebody else takes ownership
        // of the clipboard.  Since our app may have an AddRef'ed
        // data object already there, we need to remove it.

        // there is no need to open the clipboard (since we specify
        // the IGNORECLIPBOARD flag)
	
        RemoveClipboardDataObject(hWnd, CLIPWND_IGNORECLIPBOARD);

        Assert(lresult == 0);

        break;

    case WM_RENDERFORMAT:

        cf = (UINT)wParam;

        pDataObj = (IDataObject *)GetProp( hWnd,
                    CLIPBOARD_DATA_OBJECT_PROP);

        if( !pDataObj )
        {
            LEDebugOut((DEB_ERROR, "ERROR!: No data object "
                "on the private window\n"));
            break;
        }

        // now render the data onto the clipboard
        hresult = RenderFormat( hWnd, cf, pDataObj);

#if DBG == 1
        if( hresult != NOERROR )
        {
            char szBuf[256];
            char *pszBuf;

            // we have to do predefined formats by hand
            if( cf > 0xC000 )
            {
                SSGetClipboardFormatNameA(cf, szBuf, 256);
                pszBuf = szBuf;
            }
            else
            {
                switch( cf )
                {
                case CF_METAFILEPICT:
                    pszBuf = "CF_METAFILEPICT";
                    break;
                case CF_BITMAP:
                    pszBuf = "CF_BITMAP";
                    break;
                case CF_DIB:
                    pszBuf = "CF_DIB";
                    break;
                case CF_PALETTE:
                    pszBuf = "CF_PALETTE";
                    break;
                case CF_TEXT:
                    pszBuf = "CF_TEXT";
                    break;
                case CF_UNICODETEXT:
                    pszBuf = "CF_UNICODETEXT";
                    break;
                case CF_ENHMETAFILE:
                    pszBuf = "CF_ENHMETAFILE";
                    break;
                default:
                    pszBuf = "UNKNOWN Default Format";
                    break;
                }
            }
            LEDebugOut((DEB_WARN, "WARNING: Unable to render "
                "format '%s' (%x)\n", pszBuf, cf));
        }
#endif // DBG == 1

        Assert(lresult == 0);

        break;

    case WM_CANCELMODE:
        // we want to swallow the WM_CANCELMODE message.  This
        // allows us to start drag drop, alt-tab to another app
        // (which causes a WM_CANCELMODE message) and continue
        // dragging.

        Assert(lresult == 0);

        break;

    case WM_DESTROY:
        // apps are supposed to call OleSetClipboard(NULL) or
        // OleFlushClipboard() before terminating a thread.  However,
        // not all apps do what they're supposed to, so just
        // remove as much state as we can safely do

        // Potentially, we could use CLIPWND_REMOVEFROMCLIPBOARD
        // here.  However, getting in this situation should be
        // somewhat unusual, so we don't want to do any more work
        // than absolutely necessary.  Even though we'll leave a
        // hwnd on the clipboard in g_cfDataObject, that hwnd
        // will soon be invalid (because it's the one getting this
        // WM_DESTROY message).

#if DBG == 1
        // do some debug checking first though

        if( GetWindowLongPtr( hWnd, WL_ClipPrivateData) != 0 )
        {
            LEDebugOut((DEB_WARN, "WARNING: App did not cleanup the "
                "clipboard properly, OleSetClipboard(NULL) or "
                "OleFlushClipboard not called"));
        }

#endif // DBG == 1

        RemoveClipboardDataObject(hWnd, (CLIPWND_DONTCALLAPP |
            CLIPWND_IGNORECLIPBOARD));

        Assert(lresult == 0);

        break;
    default:
        lresult = SSDefWindowProc( hWnd, msg, wParam, lParam);
        break;
    }

    LEDebugOut((DEB_ITRACE, "%p OUT ClipboardWndProc ( %ld )\n", NULL,
        lresult));

    return lresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   ClipSetCaptureForDrag
//
//  Synopsis:   Sets mouse capture mode for a drag operation
//
//  Arguments:  [pdrgop] - pointer to object that handles drag operation
//
//  Returns:    S_OK            -- it worked
//              E_FAIL          -- unexpected failure occurred.
//
//  Algorithm:  Get the clipboard window for the thread. Record the drag
//              drag operation pointer on the window for use by capture
//              mode. then turn on capture mode.
//
//  History:    dd-mmm-yy Author    Comment
//              21-Apr-94 ricksa    created
//
//  Notes:      The purpose of this function is to hide where the drag
//              pointer is stored for the window.
//
//--------------------------------------------------------------------------
HRESULT ClipSetCaptureForDrag(CDragOperation *pdrgop)
{
    // Default to failure
    HRESULT hr = ResultFromScode(E_FAIL);

    // We will use the clipboard window to capture the mouse but we
    // must have a clipboard window so we make sure it is created
    // if it is not already there.
    HWND hWndClip = GetPrivateClipboardWindow(CLIP_CREATEIFNOTTHERE);

    if (hWndClip != NULL)
    {
        AssertSz((GetCurrentThreadId()
            == GetWindowThreadProcessId(hWndClip, NULL)),
                "Clip window not on current thread");

        // Capture the mouse
        SetCapture(hWndClip);

        // Teller the caller that we worked.
        hr = NOERROR;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ClipReleaseCaptureForDrag
//
//  Synopsis:   Clean up drag mouse capture
//
//  Algorithm:  Get the clipboard window for the thread. Turn the drag
//              operation pointer into null. Then release the capture.
//
//  History:    dd-mmm-yy Author    Comment
//              21-Apr-94 ricksa    created
//
//  Notes:      It is assumed that the clip board window and the thread
//              doing drag and drop are on the same thread. Therefore,
//              there should be no race between clean up here and
//              the use of the pointer in the clipboard window proc.
//
//--------------------------------------------------------------------------
void ClipReleaseCaptureForDrag(void)
{

    // Stop the mouse capture
    ReleaseCapture();
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDataFromDescriptor
//
//  Synopsis:   Retrieves object descriptor data from the specified
//              clipboard format and fetches the clsid, SrcOfCopy
//              string, and status flags
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pclsid]        -- where to put the clsid
//              [cf]            -- the clipboard format to retrieve
//              [fFlags]        -- clsid conversion flags
//              [ppszSrcOfCopy] -- where to put an ALLOCATED (public
//                                 allocator) copy of the SrcOfCopy
//                                 string.
//              [pdwStatus]     -- where to put the status bits
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  see synopsis
//
//  History:    dd-mmm-yy Author    Comment
//              18-Aug-94 alexgo    added support for fetching dwStatus
//              10-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT GetDataFromDescriptor(IDataObject *pDataObj, LPCLSID pclsid,
            UINT cf, GETCLSIDFLAGS fFlags,
            LPOLESTR *ppszSrcOfCopy,
            DWORD *pdwStatus)
{
    HRESULT         hresult;
    FORMATETC       formatetc;
    STGMEDIUM       medium;
    LPOBJECTDESCRIPTOR      pObjDesc;


    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN GetDataFromDescriptor ( %p , "
        "%p , %d , %lx , %p, %p )\n", NULL, pDataObj, pclsid, cf,
        fFlags, ppszSrcOfCopy, pdwStatus));

    // we don't bother with extensive attempts to fetch the
    // OLE2 data since we're only using it to construct OLE1.  If
    // the data is offered in a non-standard way, the the worse
    // that will happen is that you can't paste an *object* to
    // an OLE1 container.  16bit was even more strict in that
    // you *always* had to offer OLE2 formats on standard mediums.

    INIT_FORETC(formatetc);
    formatetc.cfFormat = (CLIPFORMAT) cf;
    formatetc.tymed = TYMED_HGLOBAL;
    _xmemset(&medium, 0, sizeof(STGMEDIUM));

    hresult = pDataObj->GetData(&formatetc, &medium);

    if( hresult != NOERROR )
    {
        goto logRtn;
    }
    Win4Assert(medium.tymed != TYMED_NULL);

    pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);

    if( !pObjDesc )
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    if( pclsid )
    {
        // if we want to use the standard link AND the object really
        // is a link object (potentially a custom link), then
        // just set the clsid to the be the standard link object
        if( (fFlags & USE_STANDARD_LINK) &&
            (pObjDesc->dwStatus & OLEMISC_ISLINKOBJECT) )
        {
            *pclsid = CLSID_StdOleLink;
        }
        else
        {
            *pclsid = pObjDesc->clsid;
        }
    }

    if( ppszSrcOfCopy )
    {
        if( pObjDesc->dwSrcOfCopy )
        {
            *ppszSrcOfCopy = UtDupString(
            (LPOLESTR)(((BYTE *)pObjDesc)+pObjDesc->dwSrcOfCopy));

        }
        else
        {
            *ppszSrcOfCopy = UtDupString(OLESTR(""));
        }

        if( !*ppszSrcOfCopy )
        {
            hresult = ResultFromScode(E_OUTOFMEMORY);
        }

    }

    if( pdwStatus )
    {
        *pdwStatus = pObjDesc->dwStatus;
    }

    GlobalUnlock(medium.hGlobal);

errRtn:

    ReleaseStgMedium(&medium);

logRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT GetDataFromDescriptor ( %lx ) "
        "[ %p ]\n", NULL, hresult,
        (ppszSrcOfCopy) ? *ppszSrcOfCopy : 0 ));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetDataFromStorage
//
//  Synopsis:   Calls GetData[Here] for TYMED_ISTORAGE and returns the
//              results on either an HGLOBAL or memory-based storage
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the source data object
//              [pformatetc]    -- formatetc to retrieve
//              [pmedium]       -- where to put the resulting HGlobal, may
//                                 be NULL
//              [ppstg]         -- where to save the real IStorage
//                                 (may be NULL)
//
//  Requires:   if pmedium is specified, then pmedium->tymed must be
//              TYMED_HGLOBAL
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  we create a storage on memory
//              first try to GetDataHere to that storage, if that fails, then
//              do a GetData and CopyTo the returned storage to our memory
//              storage.
//
//  History:    dd-mmm-yy Author    Comment
//              11-Apr-94 alexgo    author
//
//  Notes:      NB!!: The caller takes ownership of the data--if an hglobal
//              is requested, then it must be explicitly GlobalFree'd.
//              Similarly, the retu