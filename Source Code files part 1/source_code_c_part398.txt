)) {
        // do temp drives need different handling?

        UCHAR Drive = Request[4] - 'A';

        if (Drive >= MD) {
            setAL( 0x98 );  // Volume does not exist
            return;
        }

        if (pNwDosTable->DriveHandleTable[Drive] != 0) {

            NwPrint(("Nw32: Move directory handle %d\n", Drive));

            //
            //  We already have a directory handle assigned for this
            //  process. Ask the server to point the handle at the requested
            //  position.
            //

            SendNCP2(FSCTL_NWR_NCP_E2H, Request+2, RequestLength, Reply+2, 2);

            if (getAL() == 0) {
                //  Record the new handle.

                pNwDosTable->DriveIdTable[ Drive ] = SelectConnection()+1;

                if (Request[2] == 0x12) {
                    pNwDosTable->DriveFlagTable[ Drive ] =
                        PERMANENT_NETWORK_DRIVE;
                } else {
                    pNwDosTable->DriveFlagTable[ Drive ] =
                        TEMPORARY_NETWORK_DRIVE;
                }

                pNwDosTable->DriveHandleTable[Drive] = Reply[2];
                NwPrint(("Nw32: Move directory handle -> %x\n", Reply[2]));
            }

        } else {
            NETRESOURCE Nr;
            WCHAR DriveString[3];
            ULONG Handle;

            if (Request[2] == 0x12) {
                NwPrint(("Nw32: Allocate permanent directory handle %d\n", Drive));
            } else {
                NwPrint(("Nw32: Allocate temporary directory handle %d\n", Drive));
            }

            if (Drives[Drive] != NULL) {

                //  Tidy up the old name for this drive.

                LocalFree( Drives[Drive] );
                Drives[Drive] = NULL;
            }

            DriveString[0] = L'A' + Drive; // A through Z
            DriveString[1] = L':';
            DriveString[2] = L'\0';

            //
            // This is effectively a net use!
            //

            ZeroMemory( &Nr, sizeof(NETRESOURCE));

            Nr.lpRemoteName = BuildUNC(&Request[6], Request[5]);
            Nr.dwType = RESOURCETYPE_DISK;

            //  Save where this drive points.
            Drives[Drive] = Nr.lpRemoteName;

            if (DriveString[0] <= L'Z') {
                Nr.lpLocalName = DriveString;

                if (NO_ERROR != WNetAddConnection2W( &Nr, NULL, NULL, 0)) {

                    NwPrint(("Nw32: Allocate ->%d\n", GetLastError()));
                    setAL(0x98);    // Volume does not exist
                    return;
                }
            }


            if (Request[2] == 0x12) {
                pNwDosTable->DriveFlagTable[ Drive ] =
                    PERMANENT_NETWORK_DRIVE;
            } else {
                pNwDosTable->DriveFlagTable[ Drive ] =
                    TEMPORARY_NETWORK_DRIVE;
            }

            Handle = GetDirectoryHandle2( Drive );

            if (Handle == 0xffffffff) {

                if (DriveString[0] <= L'Z') {

                    WNetCancelConnection2W( DriveString, 0, TRUE);

                }

                ResetDrive( Drive );

                setAL(0x9c);    // Invalid path

            } else {

                //
                //  We have a drive and a connection. Complete the table
                //  mappings.
                //

                pNwDosTable->DriveIdTable[ Drive ] = SelectConnection()+1;

                Reply[2] = (UCHAR)(Handle & 0xff);
                Reply[3] = (UCHAR)(0xff); //should be effective rights
                setAL(0);    // Successful
            }
        }

    } else if ( Request[2] == 0x14 ) {

        UCHAR DirHandle = Request[3];
        UCHAR Drive;
        CONN_INDEX Connection = SelectConnection();

        NwPrint(("Nw32: Deallocate directory handle %d on Connection %d\n", DirHandle, Connection));

        for (Drive = 0; Drive < MD; Drive++) {


            NwPrint(("Nw32: Drive %c: is DirHandle %d, Connection %d\n",
                    'A' + Drive,
                    pNwDosTable->DriveHandleTable[Drive],
                    pNwDosTable->DriveIdTable[ Drive ]-1 ));

            if ((pNwDosTable->DriveHandleTable[Drive] == DirHandle) &&
                (pNwDosTable->DriveIdTable[ Drive ] == Connection+1)) {

                //
                // This is effectively a net use del!
                //

                NwPrint(("Nw32: Deallocate directory handle %c\n", 'A' + Drive));

                ResetDrive(Drive);

                setAL(0);

                return;
            }
        }

        setAL(0x9b); //  Bad directory handle
        return;

    } else {

        SendNCP(pNwDosTable->SavedAx);
    }

    FormattedDump( Reply, Reply[0] );
}

VOID
ResetDrive(
    UCHAR Drive
    )
/*++

Routine Description:

    Do a net use del

Arguments:

    Drive - Supplies the target drive.

Return Value:

    None.

--*/
{

    NwPrint(("Nw32: Reset Drive %c:\n", 'A' + Drive ));

    if ((pNwDosTable->DriveFlagTable[ Drive ] &
         ( PERMANENT_NETWORK_DRIVE | TEMPORARY_NETWORK_DRIVE )) == 0) {

        return;

    }

    if (Win32DirectoryHandleTable[Drive] != 0) {

        CloseHandle( Win32DirectoryHandleTable[Drive] );
        Win32DirectoryHandleTable[Drive] = 0;

    }

    if (Drive <= (L'Z' - L'A')) {

        DWORD WStatus;
        WCHAR DriveString[3];

        DriveString[0] = L'A' + Drive;
        DriveString[1] = L':';
        DriveString[2] = L'\0';

        WStatus = WNetCancelConnection2W( DriveString, 0, TRUE);

        if( WStatus != NO_ERROR ) {
            NwPrint(("Nw32: WNetCancelConnection2W failed  %d\n", WStatus ));
        }

    }

    //  Turn off flags that show this drive as redirected

    pNwDosTable->DriveFlagTable[ Drive ] &=
        ~( PERMANENT_NETWORK_DRIVE | TEMPORARY_NETWORK_DRIVE );

    pNwDosTable->DriveHandleTable[Drive] = 0;
}

VOID
AllocateDirectoryHandle2(
    VOID
    )
/*++

Routine Description:

    Allocate root drive

    ASSUMES called from Nw16Handler

Arguments:

    BL    supplies drive to map.
    DS:DX supplies the pathname

    AL returns the completion code.


Return Value:

    None.

--*/
{
    UCHAR Drive = getBL()-1;

    PUCHAR Name=GetVDMPointer (
                            (ULONG)((getDS() << 16)|getDX()),
                            256,    // longest valid path
                            CpuInProtectMode
                            );

    NETRESOURCE Nr;
    WCHAR DriveString[3];
    ULONG Handle;

    NwPrint(("Nw32: e905 map drive %c to %s\n", Drive + 'A', Name ));

    if (Drive >= MD) {
        setAL( 0x98 );  // Volume does not exist
        setCF(1);
        return;
    }

    if (pNwDosTable->DriveHandleTable[Drive] != 0) {

        NwPrint(("Nw32: Drive already redirected\n"));
        ResetDrive(Drive);

    }


    NwPrint(("Nw32: Allocate permanent directory handle\n"));

    if (Drives[Drive] != NULL) {

        //  Tidy up the old name for this drive.

        LocalFree( Drives[Drive] );
        Drives[Drive] = NULL;
    }

    //
    // This is effectively a net use!
    //

    ZeroMemory( &Nr, sizeof(NETRESOURCE));

    Nr.lpRemoteName = BuildUNC( Name, strlen(Name));
    //  Save where this drive points.
    Drives[Drive] = Nr.lpRemoteName;

    if (Drive <= (L'Z' - L'A')) {
        DriveString[0] = L'A' + Drive; // A through Z
        DriveString[1] = L':';
        DriveString[2] = L'\0';
        Nr.lpLocalName = DriveString;
        Nr.dwType = RESOURCETYPE_DISK;

        if (NO_ERROR != WNetAddConnection2W( &Nr, NULL, NULL, 0)) {

            NwPrint(("Nw32: Allocate0 ->%d\n", GetLastError()));

            if (GetLastError() == ERROR_ALREADY_ASSIGNED) {

                WNetCancelConnection2W( DriveString, 0, TRUE);

                if (NO_ERROR != WNetAddConnection2W( &Nr, NULL, NULL, 0)) {

                    NwPrint(("Nw32: Allocate1 ->%d\n", GetLastError()));
                    ResetDrive( Drive );
                    setAL(0x03);    // Volume does not exist
                    setCF(1);
                    return;
                }

            } else {

                    NwPrint(("Nw32: Allocate2 ->%d\n", GetLastError()));
                    ResetDrive( Drive );
                    setAL(0x03);    // Volume does not exist
                    setCF(1);
                    return;
            }
        }
    }

    //
    //  Set flags so that GetDirectory2 will open handle
    //
    pNwDosTable->DriveIdTable[ Drive ] = SelectConnection()+1;
    pNwDosTable->DriveFlagTable[ Drive ] = PERMANENT_NETWORK_DRIVE;

    Handle = GetDirectoryHandle2( Drive );

    if (Handle == 0xffffffff) {

        ResetDrive( Drive );
        setAL(0x03);    // Invalid path
        setCF(1);

    } else {

        setAL(0);    // Successful

    }

    NwPrint(("Nw32: Returning %x\n",getAL()));
}

PWCHAR
BuildUNC(
    IN PUCHAR aName,
    IN ULONG aLength
    )
/*++

Routine Description:

    This routine takes the ansi name, prepends the appropriate server name
    (if appropriate) and converts to Unicode.

Arguments:

    IN aName - Supplies the ansi name.
    IN aLength - Supplies the ansi name length in bytes.

Return Value:

    Unicode string

--*/
{
    UNICODE_STRING Name;
    UCHAR ServerName[sizeof(SERVERNAME)+1];

    CONN_INDEX Connection;
    ANSI_STRING TempAnsi;
    UNICODE_STRING TempUnicode;
    USHORT x;

    //  conversion rules for aName to Name are:

    //  foo:                "\\server\foo\"
    //  foo:bar\baz         "\\server\foo\bar\baz"
    //  foo:\bar\baz        "\\server\foo\bar\baz"


#ifdef NWDBG
    TempAnsi.Buffer = aName;
    TempAnsi.Length = (USHORT)aLength;
    TempAnsi.MaximumLength = (USHORT)aLength;
    NwPrint(("Nw32: BuildUNC %Z\n", &TempAnsi));
#endif

    Connection = SelectConnection();
    if ( Connection == 0xff ) {
        return NULL;
    }

    Name.MaximumLength = (USHORT)(aLength + sizeof(SERVERNAME) + 5) * sizeof(WCHAR);
    Name.Buffer = (PWSTR)LocalAlloc( LMEM_FIXED, (ULONG)Name.MaximumLength);

    if (Name.Buffer == NULL) {
        return NULL;
    }

    Name.Length = 4;
    Name.Buffer[0] = L'\\';
    Name.Buffer[1] = L'\\';

    //
    //  Be careful because ServerName might be 48 bytes long and therefore
    //  not null terminated.
    //

    RtlCopyMemory( ServerName, pNwDosTable->ServerNameTable[Connection], sizeof(SERVERNAME) );
    ServerName[sizeof(ServerName)-1] = '\0';

    RtlInitAnsiString( &TempAnsi, ServerName );
    RtlAnsiStringToUnicodeString( &TempUnicode, &TempAnsi, TRUE);
    RtlAppendUnicodeStringToString( &Name, &TempUnicode );
    RtlFreeUnicodeString( &TempUnicode );

    //  Now pack servername to volume seperator if necessary.

    if ((aLength != 0) &&
        (aName[0] != '\\')) {
        RtlAppendUnicodeToString( &Name, L"\\");
    }

    // aName might not be null terminated so be careful creating TempAnsi
    TempAnsi.Buffer = aName;
    TempAnsi.Length = (USHORT)aLength;
    TempAnsi.MaximumLength = (USHORT)aLength;

    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString( &TempUnicode, &TempAnsi, TRUE))) {
        LocalFree( Name.Buffer );
        return NULL;
    }

    RtlAppendUnicodeStringToString( &Name, &TempUnicode );

    //  If the name already has a volume seperator then don't add another.
    for (x=0; x < (Name.Length/sizeof(WCHAR)) ; x++ ) {

        if (Name.Buffer[x] == L':') {

            //  Strip the colon if it is immediately followed by a backslash

            if (((Name.Length/sizeof(WCHAR))-1 > x) &&
                (Name.Buffer[x+1] == L'\\')) {

                RtlMoveMemory( &Name.Buffer[x],
                               &Name.Buffer[x+1],
                               Name.Length - ((x + 1) * sizeof(WCHAR)));
                Name.Length -= sizeof(WCHAR);

            } else {

                //  Replace the colon with a backslash
                Name.Buffer[x] = L'\\';

            }
            goto skip;
        }
    }


skip:

    RtlFreeUnicodeString( &TempUnicode );

    //  Strip trailing backslash if present.

    if ((Name.Length >= sizeof(WCHAR) ) &&
        (Name.Buffer[(Name.Length/sizeof(WCHAR)) - 1 ] == L'\\')) {

        Name.Length -= sizeof(WCHAR);
    }

    //  Return pointer to a null terminated wide char string.

    Name.Buffer[Name.Length/sizeof(WCHAR)] = L'\0';
    NwPrint(("Nw32: BuildUNC %ws\n", Name.Buffer));

    return Name.Buffer;
}


VOID
GetServerDateAndTime(
    VOID
    )
/*++

Routine Description:

    Implement Funtion E7h

    ASSUMES called from Nw16Handler

Arguments:

    none.

Return Value:

    none.

--*/
{

    PUCHAR Reply = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getDX()),
                            7,
                            CpuInProtectMode
                            );

    SendNCP2( NWR_ANY_NCP(0x14), NULL, 0, Reply, 7 );

}

VOID
GetShellVersion(
    IN USHORT Command
    )
/*++

Routine Description:

    Get the environment variables. Needs to be configurable for
    Japanese machines.

Arguments:

    Command supplies the callers AX.

Return Value:

    none.

--*/
{

    setAX(0);       // MSDOS, PC
    setBX(0x031a);  // Shell version
    setCX(0);

    if ( (Command & 0x00ff) != 0) {

        LONG tmp;
        HKEY Key = NULL;
        HINSTANCE hInst;
        int retval;

        PUCHAR Reply = GetVDMPointer (
                                (ULONG)((getES() << 16)|getDI()),
                                40,
                                CpuInProtectMode
                                );

        if ( Reply == NULL ) {
            return;
        }

        hInst = GetModuleHandleA( "nwapi16.dll" );
        
        if (hInst == NULL) {
            return;
        }

        retval = LoadStringA( hInst, IsNEC_98 ? IDS_CLIENT_ID_STRING_NEC98 : IDS_CLIENT_ID_STRING, Reply, 40 );

        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Parameters
        //
        tmp = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       NW_WORKSTATION_REGKEY,
                       REG_OPTION_NON_VOLATILE,   // options
                       KEY_READ,                  // desired access
                       &Key
                       );

        if (tmp != ERROR_SUCCESS) {
            return;
        }

        tmp = 40;   //  Max size for the string.

        RegQueryValueExA(
            Key,
            "ShellVersion",
            NULL,
            NULL,
            Reply,
            &tmp);

        ASSERT( tmp <= 40 );

        RegCloseKey( Key );

    }
}

#include <packon.h>

typedef struct _TTSOUTPACKETTYPE {
    UCHAR SubFunction;
    USHORT cx;
    USHORT dx;
} TTSOUTPACKETTYPE;

typedef struct _TTSINPACKETTYPE {
    USHORT cx;
    USHORT dx;
} TTSINPACKETTYPE;

#include <packoff.h>

VOID
TTS(
    VOID
    )
/*++

Routine Description:

    Transaction Tracking System

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR bOutput;
    UCHAR bInput[2];

    TTSINPACKET TTsInPacket;
    TTSOUTPACKET TTsOutPacket;


    switch ( pNwDosTable->SavedAx & 0x00ff )
    {
        case 2:
            // NCP Tts Available
            bOutput = 0;
            SendNCP2( NWR_ANY_F2_NCP(0x22), &bOutput, sizeof(UCHAR), NULL, 0);

            if (getAL() == 0xFF) {
                setAL(01);
            }
            break;

        case 0:
            // NCP Tts Begin/Abort
            bOutput = 1;
            SendNCP2( NWR_ANY_F2_NCP(0x22), &bOutput, sizeof(UCHAR), NULL, 0);
            break;

        case 3:
            // NCP Tts Begin/Abort
            bOutput = 3;
            SendNCP2( NWR_ANY_F2_NCP(0x22), &bOutput, sizeof(UCHAR), NULL, 0);
            break;

        case 1:
            // NCP Tts End
            bOutput = 2;
            SendNCP2( NWR_ANY_F2_NCP(0x22),
                &bOutput, sizeof(UCHAR),
                (PUCHAR)&TTsInPacket, sizeof(TTsInPacket));

            setCX(TTsInPacket.cx);
            setDX(TTsInPacket.dx);
            break;

        case 4:
            // NCP Tts Status
            TTsOutPacket.SubFunction = 4;
            TTsOutPacket.cx = getCX();
            TTsOutPacket.dx = getDX();

            SendNCP2( NWR_ANY_F2_NCP(0x22),
                (PUCHAR)&TTsOutPacket, sizeof(TTsOutPacket),
                NULL, 0);

            break;

        case 5:
        case 7:
            // NCP Tts Get App/Station Thresholds
            bOutput = (pNwDosTable->SavedAx & 0x00ff);

            SendNCP2( NWR_ANY_F2_NCP(0x22),
                &bOutput, sizeof(UCHAR),
                bInput, sizeof(bInput));

            setCX( (USHORT)((bInput[0] << 8 ) || bInput[1]) );
            break;

        case 6:
        case 8:
            // NCP Tts Set App/Station Thresholds
            TTsOutPacket.SubFunction = (pNwDosTable->SavedAx & 0x00ff);
            TTsOutPacket.cx = getCX();
            SendNCP2( NWR_ANY_F2_NCP(0x22),
                (PUCHAR)&TTsOutPacket, sizeof(UCHAR) + sizeof(USHORT),
                NULL, 0);
            break;

        default:
            pNwDosTable->SavedAx = 0xc7FF;
            break;
    }
    return;
}

VOID
OpenCreateFile(
    VOID
    )
/*++

Routine Description:

    Look at the file being opened to determine if it is
    a compatibility mode open to a file on a NetWare drive.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WORD Command = pNwDosTable->SavedAx;

    PUCHAR Name;


    if ((Command & OF_SHARE_MASK ) != OF_SHARE_COMPAT) {
        return;
    }

    Name = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getDX()),
                            256,
                            CpuInProtectMode
                            );


    NwPrint(("Nw16Handler Compatibility Open of %s\n", Name ));

    //
    //  We already know its a Create or Open with sharing options
    //  set to compatibility mode or the tsr wouldn't have bopped to us.
    //


    if (IsItNetWare(Name)) {

        SetCompatibility();

    }
}

BOOL
IsItNetWare(
    PUCHAR Name
    )
/*++

Routine Description:

    Look at the filename being opened to determine if it is on a NetWare drive.

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR Drive;

    Drive = tolower(Name[0])-'a';

    NwPrint(("Nw16Handler IsItNetWare %s\n", Name ));

    if (Name[1] == ':') {

        if (pNwDosTable->DriveFlagTable[Drive] == LOCAL_DRIVE) {

            //  Definitely not a netware drive.
            return FALSE;
        }

    } else if ((IS_ASCII_PATH_SEPARATOR(Name[0])) &&
               (IS_ASCII_PATH_SEPARATOR(Name[0]))) {

            // Assume only UNC names that the tsr built are NetWare

        if ((getDS() == DosTableSegment ) &&
            (getDX() == (WORD)(DosTableOffset + FIELD_OFFSET(NWDOSTABLE, DeNovellBuffer[0] )))) {

            return TRUE;
        }

        return FALSE;

    } else {

        Drive = pNwDosTable->CurrentDrive;

    }

    //
    //  If this is a drive we don't know about, refresh our tables.
    //

    if (pNwDosTable->DriveFlagTable[Drive] == 0 ) {

        Nw16Register();

    }

    if (pNwDosTable->DriveFlagTable[Drive] &
                (TEMPORARY_NETWORK_DRIVE | PERMANENT_NETWORK_DRIVE )) {

            return TRUE;

    }

    return FALSE;

}

VOID
SetCompatibility(
    VOID
    )
/*++

Routine Description:

    Take the Create/Open file request in AX and modify appropriately

Arguments:

    none.

Return Value:

    none.

--*/
{
    WORD Command = getAX();

    if (( Command & OF_READ_WRITE_MASK) == OF_READ ) {

        setAX((WORD)(Command | OF_SHARE_DENY_WRITE));

    } else {

        setAX((WORD)(Command | OF_SHARE_EXCLUSIVE));

    }

}

VOID
OpenQueueFile(
    VOID
    )
/*++

Routine Description:

    Build the UNC filename \\server\queue using the contents of the shared
    datastructures and the CreateJobandFile NCP.

Arguments:

    none.

Return Value:

    none.

--*/
{

    CONN_INDEX Connection = SelectConnection();
    PUCHAR Request;
    PUCHAR Buffer = pNwDosTable->DeNovellBuffer;
    int index;

    if ( Connection == 0xff ) {
        //
        //  No need to return an errorcode. The NCP exchange
        //  will fail and give an appropriate call to the application.
        //

        return;
    }

    if ( ServerHandles[Connection] == NULL ) {

        NTSTATUS status;

        status = OpenConnection( Connection );

        if (!NT_SUCCESS(status)) {
            SetStatus(status);
            return;
        }
    }

    //
    //  CreateJobandQueue open in progress. The purpose of this
    //  open being processed is to translate the information in
    //  the CreateJob NCP into a pathname to be opened by the 16
    //  bit code.
    //


    //
    //  Users DS:SI points at a CreateJob NCB. Inside the request is
    //  the objectid of the queue. Ask the server for the queue name.
    //

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            8,
                            CpuInProtectMode);

    NwlibMakeNcp(
                ServerHandles[Connection],
                FSCTL_NWR_NCP_E3H,
                7,                      //  RequestSize
                61,                     //  ResponseSize
                "br|_r",
                0x36,                   //  Get Bindery Object Name
                Request+3, 4,
                6,                      //  Skip ObjectId and Type
                pNwDosTable->DeNovellBuffer2, 48 );


    pNwDosTable->DeNovellBuffer2[54] = '\0';

    Buffer[0] = '\\';
    Buffer[1] = '\\';
    Buffer += 2;            //  Point to after backslashes

    //  Copy the servername
    for (index = 0; index < sizeof(SERVERNAME); index++) {
        Buffer[index] = pNwDosTable->ServerNameTable[Connection][index];
        if (Buffer[index] == '\0') {
            break;
        }
    }

    Buffer[index] = '\\';

    RtlCopyMemory( &Buffer[index+1], &pNwDosTable->DeNovellBuffer2[0], 48 );

    NwPrint(("Nw32: CreateQueue Job and File %s\n", pNwDosTable->DeNovellBuffer));

    //
    //  Set up 16 bit registers to do the DOS OpenFile for \\server\queue
    //

    setDS((WORD)(CpuInProtectMode ? pNwDosTable->PmSelector : DosTableSegment));
    setDX( (WORD)(DosTableOffset + FIELD_OFFSET(NWDOSTABLE, DeNovellBuffer[0] )) );
    setAX(0x3d02);    //  Set to OpenFile

}

VOID
AttachHandle(
    VOID
    )
/*++

Routine Description:

    This routine implements Int 21 B4. Which is supposed to create a
    Dos Handle that corresponds to a specified 6 byte NetWare handle.

    This is used as a replacement for doing a DosOpen on "NETQ" and usin the
    handle returned from there.

Arguments:

    none.

Return Value:

    none.

--*/
{

    if ( pNwDosTable->CreatedJob ) {

        NwPrint(("Nw32: AttachHandle %x\n", pNwDosTable->JobHandle));
        setAX( pNwDosTable->JobHandle );
        pNwDosTable->CreatedJob = 0;        //  Only return it once.

    } else {

        NwPrint(("Nw32: AttachHandle failed, no job\n"));
        setAX(ERROR_FILE_NOT_FOUND);
        setCF(1);

    }
}

VOID
ProcessExit(
    VOID
    )
/*++

Routine Description:

    Cleanup all cached handles. Unmap all temporary drives.

    Cleanup the server name table so that if another dos app
    is started we reload all the useful information such as
    the servers connection number.

    Note: Dos always completes processing after we complete.

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR Connection;
    UCHAR Drive;
    USHORT Command = pNwDosTable->SavedAx;

    ResetLocks();

    for (Drive = 0; Drive < MD; Drive++) {

        NwPrint(("Nw32: Deallocate directory handle %c\n", 'A' + Drive));

        if (Win32DirectoryHandleTable[Drive] != 0) {

            CloseHandle( Win32DirectoryHandleTable[Drive] );
            Win32DirectoryHandleTable[Drive] = 0;
            pNwDosTable->DriveHandleTable[Drive] = 0;

        }
    }

    for (Connection = 0; Connection < MC ; Connection++ ) {
        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse == IN_USE) {

            CloseConnection(Connection);

            pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;

            ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );
        }
    }

    pNwDosTable->PreferredServer = 0;

    LockMode = 0;
    TablesValid = FALSE;
    DriveHandleTableValid = FALSE;

#if NWDBG
    if (DebugCtrl & ~3 ) {
        DebugControl( 2 );  //  Close logfile
    }
    GotDebugState = FALSE;
#endif

    //
    //  set AX register so that AH gets preserved
    //

    setAX( Command );
}

VOID
SystemLogout(
    VOID
    )
/*++

Routine Description:

    This api is called by the NetWare login.

    Remove all NetWare redirected drives and logout connections
    that don't have open handles on them. Don't detach the connections.

Arguments:

    none.

Return Value:

    none.

--*/
{

    UCHAR Connection;
    UCHAR Drive;
    USHORT Command = pNwDosTable->SavedAx;

    ResetLocks();

    for (Drive = 0; Drive < MD; Drive++) {
        ResetDrive(Drive);
    }

    for (Connection = 0; Connection < MC ; Connection++ ) {
        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse == IN_USE) {

            if ( ServerHandles[Connection] == NULL ) {
                OpenConnection( Connection );
            }

            if (ServerHandles[Connection] != NULL ) {

                NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(NCP_LOGOUT),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");

                CloseConnection(Connection);
            }

            //pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;

            //ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );
        }
    }

    pNwDosTable->PreferredServer = 0;
    pNwDosTable->PrimaryServer = 0;

    // No servers in the table so find the nearest/preferred.

    LoadPreferredServerName();

    //
    //  set AX register so that AH gets preserved
    //  and AL says success.
    //

    setAX( (USHORT)(Command & 0xff00) );
}

UCHAR
AttachmentControl(
    ULONG Command
    )
/*++

Routine Description:

    Implement Funtion F1h

Arguments:

    none.

Return Value:

    Return status.

--*/
{
    UCHAR Connection = getDL();

    if ((Connection < 1) ||
        (Connection > MC)) {
        return 0xf7;
    }

    Connection -= 1;

    switch (Command & 0x00ff) {

    case 0:     //  Attach

        NwPrint(("Nw16AttachmentControl: Attach connection %d\n", Connection));

        pNwDosTable->ConnectionIdTable[Connection].ci_InUse = IN_USE;

        if ( ServerHandles[Connection] == NULL ) {

            NTSTATUS status = OpenConnection( Connection );

            if (!NT_SUCCESS(status)) {
                pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;
                ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );
                return (UCHAR)RtlNtStatusToDosError(status);
            } else {
                InitConnection(Connection);
            }
        }

        return 0;
        break;

    case 1:     //  Detach

        NwPrint(("Nw16AttachmentControl: Detach connection %d\n", Connection));

        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse != IN_USE) {
            return 0xff;
        } else {

            pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;

            if (ServerHandles[Connection] != NULL ) {
                CloseConnection(Connection);
            }

            ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );

            if (pNwDosTable->PrimaryServer == (UCHAR)Connection + 1 ) {

                // Need to pick another
                UCHAR IndexConnection;

                pNwDosTable->PrimaryServer = 0;

                for (IndexConnection = 0; IndexConnection < MC ; IndexConnection++ ) {

                    if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {

                        pNwDosTable->PrimaryServer = IndexConnection + 1;

                    }
                }

            }

            if (pNwDosTable->PreferredServer == (UCHAR)Connection + 1 ) {
                pNwDosTable->PreferredServer = 0;
            }

            return 0;
        }

    case 2:     //  Logout

        NwPrint(("Nw16AttachmentControl: Logout connection %d\n", Connection));

        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse != IN_USE) {
            return 0xff;
        } else {

            UCHAR Drive;

            if ( ServerHandles[Connection] == NULL ) {
                OpenConnection( Connection );
            }

            for (Drive = 0; Drive < MD; Drive++ ) {
                if (pNwDosTable->DriveIdTable[ Drive ] == (Connection + 1)) {
                    ResetDrive(Drive);
                }
            }

            if (ServerHandles[Connection] != NULL ) {
                NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(NCP_LOGOUT),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
                CloseConnection(Connection);
            }

            return 0;
        }

    }
    return 0xff;
}

VOID
ServerFileCopy(
    VOID
    )
/*++

Routine Description:

    Build the NCP that tells the server to move a file on the server.

Arguments:

    none.

Return Value:

    none.

--*/
{

    DWORD BytesReturned;
    UCHAR SrcHandle[6];
    UCHAR DestHandle[6];
    NTSTATUS status;
    PUCHAR Buffer;

    Buffer = GetVDMPointer (
                        (ULONG)((getES() << 16)|getDI()),
                        16,
                        CpuInProtectMode
                        );

    if ( DeviceIoControl(
            GET_NT_SRCHANDLE(),
            IOCTL_NWR_RAW_HANDLE,
            NULL,
            0,
            (PUCHAR)&SrcHandle,
            sizeof(SrcHandle),
            &BytesReturned,
            NULL ) == FALSE ) {

        setAL(0xff);
        return;

    }

    if ( DeviceIoControl(
            GET_NT_HANDLE(),
            IOCTL_NWR_RAW_HANDLE,
            NULL,
            0,
            (PUCHAR)&DestHandle,
            sizeof(DestHandle),
            &BytesReturned,
            NULL ) == FALSE ) {

        setAL(0xff);
        return;

    }

    status = NwlibMakeNcp(
                GET_NT_SRCHANDLE(),
                NWR_ANY_F2_NCP(0x4A),
                25,  //  RequestSize
                4,   //  ResponseSize
                "brrddd|d",
                0,
                SrcHandle,  6,
                DestHandle, 6,
                *(DWORD UNALIGNED*)&Buffer[4],
                *(DWORD UNALIGNED*)&Buffer[8],
                *(DWORD UNALIGNED*)&Buffer[12],
                &BytesReturned
                );

    setDX((WORD)(BytesReturned >> 16));
    setCX((WORD)BytesReturned);

    if (!NT_SUCCESS(status)) {
        SetStatus(status);
        return;
    } else {
        setAL(0);
    }
}

VOID
SetStatus(
    NTSTATUS Status
    )
/*++

Routine Description:

    Convert an NTSTATUS into the appropriate register settings and updates
    to the dos tables.

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR DosStatus = (UCHAR)RtlNtStatusToDosError(Status);

    if ((!DosStatus) &&
        (Status != 0)) {

        //
        //  We have a connection bit set
        //

        if ( Status & (NCP_STATUS_BAD_CONNECTION << 8)) {
            DosStatus = 0xfc;
        } else {
            DosStatus = 0xff;
        }
    }

    if (DosStatus) {
        setCF(1);
    }

    setAL(DosStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\drv\dllentry.asm ===
PAGE,132
;***************************************************************************
;*
;*   DLLENTRY.ASM
;*
;*	VER.DLL Entry code
;*
;*	This module generates a code segment called INIT_TEXT.
;*	It initializes the local heap if one exists and then calls
;*	the C routine LibMain() which should have the form:
;*	BOOL FAR PASCAL LibMain(HANDLE hInstance,
;*				WORD   wDataSeg,
;*				WORD   cbHeap,
;*				LPSTR  lpszCmdLine);
;*        
;*	The result of the call to LibMain is returned to Windows.
;*	The C routine should return TRUE if it completes initialization
;*	successfully, FALSE if some error occurs.
;*
;**************************************************************************

	INCLUDE CMACROS.INC

externFP <LIBMAIN>               ;The C routine to be called

ifndef SEGNAME
    SEGNAME equ <_TEXT>         ; default seg name
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE


sBegin	CodeSeg          ; this defines what seg this goes in
assumes cs,CodeSeg

?PLM=0                           ;'C'naming
externA  <_acrtused>             ;Ensures that Win DLL startup code is linked

?PLM=1                           ;'PASCAL' naming
externFP <LOCALINIT>             ;Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ;Entry point into DLL

cBegin
        push    di               ;Handle of the module instance
        push    ds               ;Library data segment
        push    cx               ;Heap size
        push    es               ;Command line segment
        push    si               ;Command line offset

        ;** If we have some heap then initialize it
        jcxz    callc            ;Jump if no heap specified

        ;** Call the Windows function LocalInit() to set up the heap
        ;**	LocalInit((LPSTR)start, WORD cbHeap);
        
        xor     ax,ax
        cCall   LOCALINIT <ds, ax, cx>
        or      ax,ax            ;Did it do it ok ?
        jz      error            ;Quit if it failed

        ;** Invoke the C routine to do any special initialization

callc:
        call    LIBMAIN          ;Invoke the 'C' routine (result in AX)
        jmp short exit           ;LibMain is responsible for stack clean up

error:
	pop	si		 ;Clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:

cEnd

sEnd _thisseg

	END LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\drv\nwasmutl.asm ===
PAGE,132
;*****************************************************************;
;**               Microsoft Windows for Workgroups              **;
;**           Copyright (C) Microsoft Corp., 1991-1993          **;
;*****************************************************************;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                          ;;
;; COMPONENT:   Windows NetWare DLL.                                        ;;
;;                                                                          ;;
;; FILE:        NWASMUTL.ASM                                                ;;
;;                                                                          ;;
;; PURPOSE:     General routines used that cannot be done in C.             ;;
;;                                                                          ;;
;; REVISION HISTORY:                                                        ;;
;;  vlads       09/20/93 First cut                                          ;;
;;                                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE CMACROS.INC

?PLM = 1
?WIN=0

ifndef SEGNAME
    SEGNAME equ <_TEXT>         ; default seg name
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg                 ; this defines what seg this goes in
assumes cs,CodeSeg

;;
;; Swapping bytes in a  word
;;

cProc   WordSwap, <PUBLIC,FAR>
        parmW inWord

cBegin
        mov     ax, word ptr (inWord)
        xchg    al, ah
cEnd


;;
;; Swapping words in a long word
;;
cProc   LongSwap, <FAR,PUBLIC>, <dx>
        parmD inLong

cBegin
        mov     dx, word ptr (inLong + 2)
        xchg    dl, dh
        mov     ax, word ptr (inLong)
        xchg    al, ah
cEnd

;public NETWAREREQUEST
;
;NETWAREREQUEST proc far
;    int 21h
;       retf
;NETWAREREQUEST endp
        
sEnd _thisseg

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\dll\procs.h ===
/*++

Copyright (c) 1993/4  Microsoft Corporation

Module Name:

    procs.c

Abstract:

    Common header file for routines which support 16 bit
    applications.

Author:

    Colin Watson    (colinw)    21-Nov-1993

Environment:


Revision History:


--*/

#ifndef DBG
#define DBG 0
#endif

#if !DBG
#undef NWDBG
#endif

#define UNICODE

#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <string.h>     // strcmp
#include <stdio.h>
#include <stdarg.h>
#include <debugfmt.h>   // FORMAT_LPSTR

#include <nwapi.h>
#include <nwxchg.h>
#include <ntddnwfs.h>
#include <npapi.h>
#include <nwrnames.h>

#include <vddsvc.h>
#include <nwdos.h>
#include <ncp.h>

#define IDS_CLIENT_ID_STRING          1
#define IDS_CLIENT_ID_STRING_NEC98    2

//  Locks.c

VOID
Locks(
    USHORT Command
    );

VOID
InitLocks(
    VOID
    );

VOID
ResetLocks(
    VOID
    );


//  Ncp.c

extern PNWDOSTABLE pNwDosTable;
extern HANDLE ServerHandles[MC];

CONN_INDEX
SelectConnection(
    VOID
    );

CONN_INDEX
SelectConnectionInCWD(
    VOID
    );

NTSTATUS
OpenConnection(
    CONN_INDEX Connection
    );

ULONG
GetDirectoryHandle2(
    DWORD Drive
    );


#define GET_NT_HANDLE() (HANDLE)(pNwDosTable->NtHandleHi << 16 | pNwDosTable->NtHandleLow)
#define GET_NT_SRCHANDLE() (HANDLE)(pNwDosTable->NtHandleSrcHi << 16 | pNwDosTable->NtHandleSrcLow)


//
// MSW_PE: Machine Status Word Protect-mode enable bit
//

#ifndef MSW_PE
#define MSW_PE  0x0001
#endif

#undef getMSW
extern  WORD getMSW(VOID);

#define IS_PROTECT_MODE()   (UCHAR)((getMSW() & MSW_PE)? TRUE : FALSE)

#if NWDBG

#define NwPrint(String) NwPrintf String;

VOID
DebugControl(
    int Command
    );

VOID
NwPrintf(
    char *Format,
    ...
    );

VOID
VrDumpRealMode16BitRegisters(
    IN  BOOL    DebugStyle
    );

VOID
VrDumpNwData(
    VOID
    );

VOID
DisplayExtendedError(
    VOID
    );

VOID
FormattedDump(
    PCHAR far_p,
    LONG  len
    );

#else

#define NwPrint(_x_)
#define VrDumpRealMode16BitRegisters(_x_)
#define VrDumpNwData( )
#define DisplayExtendedError( )
#define FormattedDump(_x_,_y_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\drv\ints.asm ===
page ,132

if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ints.asm

Abstract:

    Contains handler for Windows protect-mode NetwareRequest function, exported
    by NETWARE.DRV. Code in this file access real mode memory via an LDT descriptor
    created especially for this purpose. This selector gives us access to all
    code and data contained in the Nw16 TSR

Author:

    Richard L Firth 22-Jan-1994

Environment:

    Windows protect mode only

Revision History:

    22-Jan-1994 rfirth
        Created

--*/

endif

include nwdos.inc                       ; NWDOSTABLE_ASM structure
include isvbop.inc                      ; DispatchCall

.286
.model medium,pascal

_DATA segment word public 'DATA'

OldInt21Handler dd      ?
RMSegment       dw      ?
RMBase          dw      ?               ; MUST be in this order - loaded
RMSelector      dw      ?               ; via lds dx,word ptr RMBase

.errnz (RMSelector - (RMBase + 2))

_DATA ends

;
; code segment ordering
;

INIT_TEXT segment byte public 'CODE'
INIT_TEXT ends

_TEXT segment byte public 'CODE'
_TEXT ends

;
; macros
;

LOAD_DS macro
        push    _DATA
        pop     ds
        assume  ds:_DATA
        endm

SET_DS macro
        push    ds
        LOAD_DS
        endm

RESTORE_DS macro
        pop     ds
        assume  ds:nothing
        endm

LOAD_RM_DS_BX macro
        LOAD_DS
        lds     bx,dword ptr RMBase
        assume  ds:nothing
        endm

RESTORE_DS_BX macro
        RESTORE_DS
        pop     bx
        endm

INIT_TEXT segment byte public 'CODE'

        assume  cs:INIT_TEXT

        public GetLowRedirInfo
GetLowRedirInfo proc far
        mov     ax,9f00h
        int     21h                     ; get the RM data segment in BX
        jc      @f
        SET_DS
        mov     RMSegment,bx
        mov     RMBase,dx
        mov     ax,2
        int     31h
        jc      @f                      ; can't create selector
        mov     RMSelector,ax

;
; now that we have the selector, we write the selector value into the low
; memory area. The 32-bit DLL will use this value when setting output DS or ES
; register values if the call originated in Protect Mode
;

        lds     bx,dword ptr RMBase
        mov     [bx]._PmSelector,ax

;
; we now hook int 21
;

        LOAD_DS
        push    es
        mov     ax,3521h
        int     21h
        mov     word ptr OldInt21Handler,bx
        mov     word ptr OldInt21Handler[2],es
        mov     cx,_TEXT
        mov     dx,offset _TEXT:NewInt21Handler
        mov     ax,205h
        mov     bl,21h
        int     31h
        pop     es
        RESTORE_DS
        xor     ax,ax                   ; success: return TRUE
        inc     ax
        ret
@@:     xor     ax,ax                   ; failure: return FALSE
        ret
GetLowRedirInfo endp

INIT_TEXT ends

_TEXT segment byte public 'CODE'

        assume  cs:_TEXT

        public NewInt21Handler
NewInt21Handler proc far
        sti
        cmp     ah,0e3h
        jb      @f
        call    far ptr NetwareRequest
        retf    2
@@:     sub     sp,4
        push    bp
        mov     bp,sp
        push    es
        push    bx
        SET_DS
        les     bx,OldInt21Handler
        mov     [bp+2],bx
        mov     [bp+4],es
        RESTORE_DS
        pop     bx
        pop     es
        pop     bp
        retf
NewInt21Handler endp

        public NetwareRequest
NetwareRequest proc far
        push    bx
        push    ds
        LOAD_RM_DS_BX
        cmp     ah,0f0h
        jne     for_dll

;
; these are the 0xF000, 0xF001, 0xF002, 0xF004, 0xF005 calls that we can handle
; here without having to BOP. All we need do is access the table in the shared
; real-mode/protect-mode (low) memory
;

.errnz (_PrimaryServer - (_PreferredServer + 1))

;
; point bx at PreferredServer in the low memory area. If the request is a
; PrimaryServer request (0xF004, 0xF005) then point bx at PrimaryServer
;

        lea     bx,[bx]._PreferredServer; bx = offset of PreferredServer
        cmp     al,3
        cmc
        adc     bx,0                    ; bx = &PrimaryServer if F004 or F005
        or      al,al                   ; f000 = set preferred server
        jz      set_server
        cmp     al,4                    ; f004 = set primary server
        jnz     try_01

;
; 0xF000 or 0xF004: set Preferred or Primary Server to value contained in DL.
; If DL > 8, set respective server index to 0
;

set_server:
        xor     al,al
        cmp     dl,8
        ja      @f
        mov     al,dl
@@:     mov     [bx],al
        jmp     short exit_f0

;
; 0xF001 or 0xF005: get Preferred or Primary Server
;

try_01: cmp     al,1                    ; f001 = get preferred server
        jz      get_server
        cmp     al,5
        jnz     try_02

get_server:
        mov     al,[bx]
        jmp     short exit_f0

try_02: cmp     al,2                    ; f002 = get default server
        jnz     for_dll                 ; try to handle on 32-bit side
        mov     al,[bx]                 ; al = PreferredServer
        or      al,al
        jnz     exit_f0
        mov     al,[bx+1]               ; al = PrimaryServer

exit_f0:RESTORE_DS_BX
        ret

;
; if we're here then the call must go through to the 32-bit DLL. Save any relevant
; info in the low memory area, load the handle and BOP (DispatchCall)
;

for_dll:mov     [bx]._SavedAx,ax        ; save AX value for DLL
        push    word ptr [bx]._hVdd     ; put VDD handle on top of stack

        cmp     ah,0BCh                 ; bc, bd, be need handle mapping
        jb      @f
        cmp     ah,0BEh
        ja      @f
        pop     ax                      ; ax = hVdd
        RESTORE_DS_BX                   ; ds, bx = user ds, bx
        call    MapNtHandle
        jmp     dispatchola

@@:     push    bp
        cmp     ah, 0E3h                ; Is it new or old Create Job request?
        je      lookupcode
        cmp     ax, 0F217h
        jne     check_f3

lookupcode:
        mov     bp,sp
        mov     ds,[bp+4]
        cmp     byte ptr [si+2],68h
        je      createjob
        cmp     byte ptr [si+2],79h
        je      createjob
        jmp     short outtahere

createjob:
        LOAD_RM_DS_BX
        mov     [bx]._SavedAx,9f02h
        push    ax                      ; Open \\Server\queue for NCP
        mov     ax,[bp+2]               ; ax = hVdd
        mov     ds,[bp+4]               ; ds = users ds
        push    ds
        push    dx                      ; users dx
        DispatchCall                    ; Set DeNovellBuffer to \\Server\queue
                                        ; and registers ready for DOS OpenFile
        int     21h                     ; Open \\server\queue
        LOAD_RM_DS_BX
        jc      openfailed
        mov     [bx]._JobHandle, al
        mov     [bx]._CreatedJob, 1     ; Flag JobHandle is valid
        push    bx
        mov     bx, ax                  ; JobHandle
        call    MapNtHandle             ; take bx and find the Nt handle
        pop     bx

openfailed:
        pop     dx
        pop     ds                      ; Proceed and send the NCP
        pop     ax

        push    ds
        push    bx
        LOAD_RM_DS_BX
        mov     [bx]._SavedAx, ax
        pop     bx
        pop     ds                      ; users DS
        jmp     short outtahere

check_f3:
        cmp     ah, 0F3h
        jne     outtahere
                                        ; FileServerCopy, change both
                                        ; handles in the structure es:di
        push    bx

        mov     bx,word ptr es:[di]     ; Map Source Handle
        call    MapNtHandle

        pop     bx
        mov     ax,[bx]._NtHandleHi
        mov     [bx]._NtHandleSrcHi,ax
        mov     ax,[bx]._NtHandleLow
        mov     [bx]._NtHandleSrcLow,ax

        mov     bx,word ptr es:[di+2]   ; Map Destination Handle
        call    MapNtHandle

outtahere:
        pop     bp
        pop     ax                      ; ax = hVdd
        RESTORE_DS_BX                   ; ds, bx = user ds, bx
dispatchola:
        DispatchCall                    ; BOP: DLL performs action
        ret                             ; return to the application

;
; if the request was not recognized by the DLL, it modifies IP so that control
; will resume at the next int 21. We just fill the intervening space with NOPs
; (space that makes up a retf <n> instruction in the RM TSR)
;

        nop
        nop
        int     21h
        ret
NetwareRequest endp

; ***   MapNtHandle
; *
; *     Given a handle in BX, map it to a 32-bit Nt handle in NtHandle[Hi|Low]
; *
; *     ENTRY   bx = handle to map
; *
; *     EXIT    Success - NtHandle set to 32-bit Nt handle from SFT
; *
; *     USES    ax, bx, flags
; *
; *     ASSUMES nothing
; *
; ***

MapNtHandle proc near
        push    ax
        mov     ax,9f01h                ; call MapNtHandle on (BX) in RM
        int     21h                     ; update NtHandleHi, NtHandleLow
        pop     ax
@@:     ret
MapNtHandle endp

_TEXT ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\drv\netware.h ===
/*****************************************************************/
/**               Microsoft Windows 4.0                         **/
/**           Copyright (C) Microsoft Corp., 1991-1993          **/
/*****************************************************************/


/*
 * History:
 *  08/08/93    vlads   Created
 *	10/16/93	gregj	Removed #pragma pack() because of #include nesting
 *
 */

#ifndef _INC_NETWARE
#define _INC_NETWARE

#include <windows.h>

// #include <npdefs.h>

// #include <base.h>

// #include <npassert.h>
// #include <buffer.h>

// #include <..\..\dev\ddk\inc16\error.h>
// #include <bseerr.h>
#include "nwerror.h"
// #include "..\nwnp\nwsysdos.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// #include <netcons.h>
// #include <netlib.h>

WINAPI NETWAREREQUEST (LPVOID);
WINAPI PNETWAREREQUEST(LPVOID);
WINAPI DOSREQUESTER(LPVOID);

//UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
//UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
//UINT WINAPI WNetCancelConnection(LPSTR, BOOL);


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#ifdef DEBUG
#define TRACE(s) OutputDebugString(s)
#else
#define TRACE(s)
#endif

extern HINSTANCE hInstance;

#endif  /* !_INC_NETWARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\drv\nwerror.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NWERROR.H -- Novell defined error return codes from Netware API
 *
 * History:
 *  03/16/93    vlads   Created
 *
 */

#ifndef _nwerror_h_
#define _nwerror_h_


#define NWSC_SUCCESS            0x00
#define NWSC_SERVEROUTOFMEMORY  0x96
#define NWSC_NOSUCHVOLUME       0x98   // Volume does not exist
#define NWSC_BADDIRECTORYHANDLE 0x9b
#define NWSC_NOSUCHPATH         0x9c
#define NWSC_NOJOBRIGHTS        0xd6
#define NWSC_EXPIREDPASSWORD    0xdf
#define NWSC_NOSUCHSEGMENT      0xec   // Segment does not exist
#define NWSC_INVALIDNAME        0xef
#define NWSC_NOWILDCARD         0xf0   // Wildcard not allowed
#define NWSC_NOPERMBIND         0xf1   // Invalid bindery security

#define NWSC_ALREADYATTACHED    0xf8   // Already attached to file server
#define NWSC_NOPERMREADPROP     0xf9   // No property read privelege
#define NWSC_NOFREESLOTS        0xf9   // No free connection slots at server
#define NWSC_NOMORESLOTS        0xfa   // No more server slots
#define NWSC_NOSUCHPROPERTY     0xfb   // Property does not exist
#define NWSC_UNKNOWN_REQUEST    0xfb    // Invalid NCP number
#define NWSC_NOSUCHOBJECT       0xfc   // End of Scan Bindery Object service
                                       // No such object
#define NWSC_UNKNOWNSERVER      0xfc   // Unknown file server
#define NWSC_SERVERBINDERYLOCKED    0xfe   // Server bindery locked
#define NWSC_BINDERYFAILURE     0xff   // Bindery failure
#define NWSC_ILLEGALSERVERADDRESS 0xff   // No response from server (illegal server address)
#define NWSC_NOSUCHCONNECTION   0xff   // Connection ID does not exist


typedef WORD   NW_STATUS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\drv\nwinit.c ===
/*****************************************************************/
/**               Microsoft Windows 4.0                         **/
/**           Copyright (C) Microsoft Corp., 1992-1993          **/
/*****************************************************************/

/* INIT.C -- General code for MS/Netware network driver emulator.
 *
 * History:
 *  09/22/93    vlads   Created
 *
 */

#include "netware.h"

#define Reference(x) ((void)(x))

extern BOOL far pascal GetLowRedirInfo(void);

int FAR PASCAL LibMain(
    HANDLE hInst,
    WORD wDataSeg,
    WORD wcbHeapSize,
    LPSTR lpstrCmdLine)
{

    //
    // get shared data segment address. Fail initialization if an error is
    // returned
    //

    if (!GetLowRedirInfo()) {
        return 0;
    }

    //
    // return success
    //

    return 1;
}

/*  WEP
 *  Windows Exit Procedure
 */

int FAR PASCAL _loadds WEP(int nParameter)
{
   Reference(nParameter);
   return 1;
}


WINAPI PNETWAREREQUEST(LPVOID x)
{
    return(1);
}

//
// removed because nwcalls makes use of this function; removing it causes
// NWCALLS to use real INT 21
//

//WINAPI DOSREQUESTER(LPVOID x)
//{
//    return(1);
//}

UINT WINAPI WNetAddConnection(LPSTR p1, LPSTR p2, LPSTR p3)
{
    return(1);
}

UINT WINAPI WNetGetConnection(LPSTR p1, LPSTR p2, UINT FAR *p3)
{
    return(1);
}

UINT WINAPI WNetCancelConnection(LPSTR p1, BOOL p2)
{
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\inc\nwdos.h ===
/*--

  Copyright (c) 1993  Microsoft Corporation

  Module Name:

    NWDOS.h

  Abstract:

    This is the include file that defines all constants and types for
    16 bit applications accessing the redirector.

  Author:

    Colin Watson   (ColinW)  08-Jul-1993

  Revision History:

--*/

#define NWDOS_INCLUDED

#define  MC     8   // maximum number of connections

#define  NC     8   // number of novell connections
#define  MP     3   // maximum number of printers
#define  MD    32   // maximum number of drives
#define  PZ    64   // print buffer size

#define SERVERNAME_LENGTH   48
#define USERNAME_LENGTH     16
#define PASSWORD_LENGTH     16
#define IPXADDRESS_LENGTH   12
#define NODEADDRESS_LENGTH  6

typedef  UCHAR  byte;
typedef  USHORT word;

typedef  byte   CONN_INDEX; // index into ConnectionIdTable, range 0..MC-1
typedef  byte   DRIVE;      // index into DriveXxxTable, range 0..MD-1

/* OpenFile() Flags */

#define OF_READ_WRITE_MASK  0x0003
/*
#define OF_READ 	        0x0000
#define OF_WRITE	        0x0001
#define OF_READWRITE	    0x0002
*/
#define OF_SHARE_MASK       0x0070
/*
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	        0x0100
#define OF_DELETE	        0x0200
#define OF_VERIFY	        0x0400   */ /* Used with OF_REOPEN */
/*
#define OF_SEARCH	        0x0400	 */ /* Used without OF_REOPEN */
/*
#define OF_CANCEL	        0x0800
#define OF_CREATE	        0x1000
#define OF_PROMPT	        0x2000
#define OF_EXIST	        0x4000
#define OF_REOPEN	        0x8000
*/

//
// Force misalignment of the following structures
//

/* XLATOFF */
#include <packon.h>
/* XLATON */

typedef  struct CID { /* */
    byte        ci_InUse;
    byte        ci_OrderNo;
    byte        ci_ServerAddress[IPXADDRESS_LENGTH];
    word        ci_TimeOut;
    byte        ci_LocalNode[NODEADDRESS_LENGTH];
    byte        ci_SequenceNo;
    byte        ci_ConnectionNo;
    byte        ci_ConnectionStatus;
    word        ci_MaxTimeOut;
    byte        ci_ConnectionLo;
    byte        ci_ConnectionHi;
    byte        ci_MajorVersion;
    byte        ci_1;
    byte        ci_MinorVersion;
} CONNECTIONID;
typedef CONNECTIONID UNALIGNED *PCONNECTIONID;

#if 0  /* Already declared in nw\inc\ntddnwfs.h */
typedef  char   SERVERNAME[SERVERNAME_LENGTH];
#endif

typedef  char   USERNAME[USERNAME_LENGTH];
typedef  char   PASSWORD[PASSWORD_LENGTH];
typedef  char   IPXADDRESS[IPXADDRESS_LENGTH];
typedef  char   NODEADDRESS[NODEADDRESS_LENGTH];

//
//  The following type collects all the structures used between the TSR
//  and the 32 bit dll into one packed structure.
//
// *** ANY CHANGES TO THIS STRUCTURE MUST ALSO BE MADE TO THE ASM NWDOSTABLE_ASM
// *** STRUCTURE (below)
//

/* XLATOFF */
typedef struct {
    CONNECTIONID    ConnectionIdTable[MC];
    SERVERNAME      ServerNameTable[MC];
    CONN_INDEX      DriveIdTable[MD];       // Corresponding ConnectionId
    UCHAR           DriveFlagTable[MD];
    UCHAR           DriveHandleTable[MD];
    UCHAR           PreferredServer;
    UCHAR           PrimaryServer;
    UCHAR           TaskModeByte;
    UCHAR           CurrentDrive;
    USHORT          SavedAx;
    USHORT          NtHandleHi;
    USHORT          NtHandleLow;
    USHORT          NtHandleSrcHi;
    USHORT          NtHandleSrcLow;
    USHORT          hVdd;
    USHORT          PmSelector;
    UCHAR           CreatedJob;
    UCHAR           JobHandle;
    UCHAR           DeNovellBuffer[256];
    UCHAR           DeNovellBuffer2[256];
} NWDOSTABLE;
typedef NWDOSTABLE *PNWDOSTABLE;
/* XLATON */

//
// Turn structure packing back off
//

/* XLATOFF */
#include <packoff.h>
/* XLATON */

//
//  CONNECTIONID Constants
//

#define FREE                        0
#define IN_USE                      0xff

//
//  Values for DriveFlags
//

#define NOT_MAPPED                  0
#define PERMANENT_NETWORK_DRIVE     1
#define TEMPORARY_NETWORK_DRIVE     2
#define LOCAL_DRIVE                 0x80


///// Client state tables:

extern  CONNECTIONID*   ConnectionIdTable;          //  MC entries
extern  SERVERNAME*     ServerNameTable;            //  MC entries

extern  byte*           DriveFlagTable;             //  MD entries
extern  byte*           DriveIdTable;               //  MD entries

//
// this next egregious grossness is extant because MASM cannot handle anything
// other than a basic type inside a structure declaration
//
// *** ANY CHANGES TO THIS STRUCTURE MUST ALSO BE MADE TO THE C NWDOSTABLE
// *** STRUCTURE (above)
//
// NB. The leading underscores are there because we already have globals with
// the same names
//

/* ASM

NWDOSTABLE_ASM struc

_ConnectionIdTable  db ((size CID) * MC) dup (?)
_ServerNameTable    db (MC * SERVERNAME_LENGTH) dup (?)
_DriveIdTable       db MD dup (?)
_DriveFlagTable     db MD dup (?)
_DriveHandleTable   db MD dup (?)
_PreferredServer    db ?
_PrimaryServer      db ?
_TaskModeByte       db ?
_CurrentDrive       db ?
_SavedAx            dw ?
_NtHandleHi         dw ?
_NtHandleLow        dw ?
_NtHandleSrcHi      dw ?
_NtHandleSrcLow     dw ?
_hVdd               dw ?
_PmSelector         dw ?
_CreatedJob         db ?
_JobHandle          db ?
_DeNovellBuffer     db 256 dup (?)
_DeNovellBuffer2    db 256 dup (?)

NWDOSTABLE_ASM ends

*/

/* XLATOFF */
//
// IS_ASCII_PATH_SEPARATOR - returns TRUE if ch is / or \. ch is a single
// byte (ASCII) character
//
#define IS_ASCII_PATH_SEPARATOR(ch)     (((ch) == '/') || ((ch) == '\\'))
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\asmmacro.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    asmmacro.inc
;
;Abstract:
;
;    Contains macros to extend masm functionality:
;
;       jmpc
;       jmpnc
;       jmpne
;       jmps
;       _mkjmp
;
;
;Author:
;
;    Richard L Firth (rfirth) 24-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;Revision History:
;
;    24-Sep-1991 rfirth
;        Created
;
;--



DEFINED_BIT=020h
;ISDEFINED equ %(.type <thing> and DEFINED_BIT)
LABEL_DEFINED equ <(.type &label and DEFINED_BIT)>

DEBUG_MACROS    = 0
;DEBUG_MACROS    = 1


;***    jmpa
;*
;*      jump to label if above. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpa    macro   label
        _mkjmp  ja,jna,&label
endm

;***    jmpc
;*
;*      jump to label if below. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpb    macro   label
        _mkjmp  jb,jnb,&label
endm

;***    jmpc
;*
;*      jump to label if carry flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpc    macro   label
        _mkjmp  jc,jnc,&label
endm



;***    jmpnc
;*
;*      jump to label if carry flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpnc   macro   label
        _mkjmp  jnc,jc,&label
endm



;***    jmpne
;*
;*      jump to label if zero flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpne   macro   label
        _mkjmp  jne,je,&label
endm



;***    jmpe
;*
;*      jump to label if zero flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpe    macro   label
        _mkjmp  je,jne,&label
endm



;***    jmps
;*
;*      jump to label. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmps    macro   label
        local   l,dist
dist=&label-$
if1
if (.type label and DEFINED_BIT)
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass1: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass1: &label defined and short
endif
        jmp     short &label
endif
else
if DEBUG_MACROS
        %out pass1: &label not defined
endif
        org     $+3
endif
else
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass2: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass2: &label defined and short
endif
        jmp     short &label
        org     $+1
endif
endif
l:
endm



;***    _mkjmp
;*
;*      Make a jmp<?> macro. Generate instruction sequence for jump with or
;*      without conditional test. Jump may be short (+127/-128 bytes) or near
;*      (+32767/-32768 bytes)
;*
;*      ENTRY   is      - short jump instruction
;*              in      - near jump instruction
;*              label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

_put macro s,v
if2
if DEBUG_MACROS
%out s = v
endif
endif
endm

_mkjmp  macro   is, in, label
        local   l

;;
;; if pass 1 and label is already known, generate correct instruction
;;

if1
if (.type &label and DEFINED_BIT)

;;
;; if label is too far away for short jump instruction, make jump <condition>
;; into jump <NOT condition> round jump to label followed by a near jump to
;; label
;;

if (((&label - $) gt 129) or ((&label - $) lt -126))
        &in     l       ;; short jump, NOT condition
        jmp     &label  ;; jump to where we want to go
else
        &is     &label  ;; short jump
endif

;;
;; if pass 1 and we don't know about the label yet, adjust the program
;; counter by the max. number of bytes taken up by this macro (5 - 2 for
;; short jump, 3 for near jump)
;;

else
        nop
        nop
        nop
        nop
        nop
endif

;;
;; pass 2 - do same stuff as for pass 1
;;

else
if (((&label - $) gt 129) or ((&label - $) lt -126))
 if ((&label-$) gt 129)
        _put    <label distance>, %(&label-$)
 else
        _put    <label distance>, %($-&label)
 endif
        &in     l
        jmp     &label
else

;;
;; label is within +127/-128 bytes of current instruction - generate short
;; jump instruction and put the program counter forward past the space
;; reserved during pass 1
;;

        _put    <label distance>, %(&label-$)
        &is     &label
        nop
        nop
        nop
endif
endif
l:
endm



oldjmps macro   label
if2
if (((&label - $) gt 127) or (($ - &label) lt -128))
        jmp     short l
        jmp     &label
else
        jmp     short &label
        org     $+3
endif
else
;;
;; if this is pass 1 just take up max amount of space so phases don't get
;; screwed
;;
        org     $+5
endif
l:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\makefile.inc ===
!IF 0

Copyright (c) 1991 & 1993  Microsoft Corporation

Module Name:

    makefile

Abstract:

    makefile for Vdm NetWare Redir program

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

!ENDIF

!include $(NTMAKEENV)\makefile.plt

#
# Because we've invoked nmake from within a makefile, macros defined
# in a previous makefile (ie, sources, sources.inc, makefile.def)
# are not defined at this point unless they're defined on the command
# line.  This makefile assumes the LANGUAGE and ALT_PROJECT_TARGET macros
# defined in $(LANGUAGE)\sources.inc are passed to this invokation of nmake
# on the command line.
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
TARGET_DIRECTORY=i386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
TARGET_DIRECTORY=alpha
!endif

PATH=$(PATH_TOOLS16);$(PATH)

#
# set the LANGUAGE info
#

!IFNDEF LANGUAGE
LANGUAGE=USA
!ENDIF

DEST=$(LANGUAGE)\$(_OBJ_DIR)\$(TARGET_DIRECTORY)

.SUFFIXES:
.SUFFIXES:  .asm .h

#
# nmake doesn't work properly if we try to stick the objects in obj, so put
# them in current dir for now. WHEN CHANGE OBJPATH TO BE OBJ, CHANGE clean TOO
#

ASM         = $(PATH_TOOLS16)\masm
LINK        = $(PATH_TOOLS16)\link16

#
# convert NTDEBUG into DEBUG flag. NTDEBUG can be not present or retail, either
# of which mean no debugging; or ntsd, cvp or sym, which means debugging support
# required
#

!IF "$(NTDEBUG)" == "ntsdnodbg"
DEBUGGING=0
!ELSE
DEBUGGING=1
!ENDIF

#
# assembler and linker debugging options
#

!IF $(DEBUGGING)
ASMDEBUG    =/DDEBUG=1 /Zi
LINKDEBUG   =/CO
!ELSE
ASMDEBUG    =/DDEBUG=0
LINKDEBUG   =
!ENDIF
ASMINC      =/I. /I..\..\inc /I..\inc\$(_OBJ_DIR)\$(TARGET_DIRECTORY) /I..\..\inc\$(LANGUAGE) /I$(SDK_INC16_PATH)
ASMFLAGS    =/Mx
LINKFLAGS   =/MAP /CP:1


#
# Inference rules - asm to obj, h to inc
#

.asm{$(DEST)\}.obj:
    @rem Setting the MASM env var keeps the masm command line below 128 chars
    set MASM=$(ASMINC) $(ASMDEBUG) $(USERDEFS)
    $(ASM) $<,$@;

.asm.lst:
    set MASM = $(ASMINC) $(ASMDEBUG) $(USERDEFS)
    $(ASM) /L $<;


#
# what it is we're building
#

TARGET      = $(DEST)\nw16.exe
MAPFILE     = $(TARGET:.exe=.map)
DEFFILE     = ;

OBJS        = $(DEST)\nw16.obj       \
              $(DEST)\resident.obj

LIBS        =

#
# how to build it
#

all:    makedir $(TARGET)


$(TARGET):  $(OBJS)
    $(LINK) @<<
$(OBJS)
$(TARGET) $(LINKFLAGS) $(LINKDEBUG)
$(MAPFILE)
$(LIBS)
$(DEFFILE)
<<


#
# where to put it
#
    if not exist $(DEST) md $(DEST)
    binplace -o $(ALT_PROJECT_TARGET) $(TARGET)
    binplace -o $(ALT_PROJECT_TARGET) $(MAPFILE)

#
# clean build - delete all objs
#

clean:  clean2

clean2:
    if exist $(DEST)\*.* del $(DEST)\*.*
    $(MAKE)

makedir:
    @-if not exist $(DEST) md $(DEST)


#
# file dependencies
#

$(DEST)\nw16.obj:          \
        nw16.asm                \
        debugmac.inc            \
        asmmacro.inc            \
        segorder.inc            \
        ..\inc\$(_OBJ_DIR)\$(TARGET_DIRECTORY)\nwdos.inc

$(DEST)\resident.obj:      \
        resident.asm            \
        segorder.inc            \
        debugmac.inc            \
        asmmacro.inc            \
        ..\inc\$(_OBJ_DIR)\$(TARGET_DIRECTORY)\nwdos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\nw16.asm ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nw16.asm

Abstract:

    This module contains the stub redir TSR code for NT VDM net support

Author:

    Richard L Firth (rfirth) 05-Sep-1991
    Colin Watson (colinw)    30-Jun-1993

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

    30-Jun-1993 colinw
        ported to NetWare

--*/
endif



;
; DOS include files
;

.xlist
.xcref
include ..\..\..\..\public\sdk\inc\isvbop.inc   ;  NTVDM BOP mechanism
include dossym.inc      ; includes MS-DOS version etc
include pdb.inc         ; PSP defines
include syscall.inc     ; AssignOper
include segorder.inc    ; load order of 'redir' segments
include debugmac.inc    ; debug display macros
include asmmacro.inc    ; jumps which may be short or near
include messages.inc
include nwdos.inc       ; NetWare structures and nwapi32 interface
.cref
.list

;
; Define externals in resident code and data
;

ResidentCodeStart

        extrn   Old21Handler:dword
        extrn   NwInt21:near
        extrn   hVDD:dword
        extrn   quick_jump_to_dos:byte
        extrn   for_dos_proper:byte
        extrn   chain_previous_int21:byte
        extrn   ConnectionIdTable:byte
        extrn   not_exclusive:byte

ResidentCodeEnd


InitStack       segment stack para 'stack'

        dw      256 dup (?)

InitStack       ends

InitDataStart


bad_ver_msg     db      NLS_MSG_001,c_CR,c_LF
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      NLS_MSG_004,c_CR,c_LF
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

cannot_load_msg db      NLS_MSG_005,c_CR, c_LF
CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg

InitDataEnd


InitCodeStart

        assume  cs:InitCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public DllName
DllName         db      "NWAPI16.DLL",0

        public InitFunc
InitFunc        db      "Nw16Register",0

        public  DispFunc
DispFunc        db      "Nw16Handler",0

        public  start
start   proc    near

;
; when we start up we could be on any old PC - even an original, so don't
; assume anything other than a model-T processor
;

        .8086

;
; Set the data segment while we're at it - all paths set it sooner
; or later. NOTE: es will point to the PSP until we change it!
;

        mov     dx,InitData
        mov     ds,dx
        assume  ds:InitData

;
; first off, get the DOS version. If we're not running on NT (VDM) then this
; TSR's not going to do much, so exit. Exit using various methods, depending
; on the DOS version (don't you hate compatibility?)
;

        mov     ah,30h
        int     21h
        jc      ancient_version         ; version not even supported

;
; version is 2.0 or higher. Check it out. al = major#, ah = minor#
;

        cmp     al,major_version
        jne     invalid_version

;
; what do you know? We're actually running on NT (unless some evil programmer
; has pinched int 21h/30h and broken it!). Enable minimum instruction set
; for NTVDM (286 on RISC).
;

        .286c

;
; perform an installation check by calling one of our entry points
; (GetFileServerNameTable). If this returns a table pointer in ES:DI then we
; know this TSR is already active, in which case we bail out now
;

        push    es
        push    di
        xor     di,di
        mov     es,di
        mov     ax,0ef03h
        int     21h
        mov     ax,es
        or      ax,di
        pop     di
        pop     es
        jnz     already_here

;
; OK, the NetWare redir is not already loaded - we're in business.
; Find entrypoints to nwapi16.dll Get and set the various interrupt
; vectors, Calculate the amount of space we want to keep,
; free up any unused space (like the environment segment), display a message
; in the DEBUG version, then terminate and stay resident. Remember: at this
; point we expect ES to point at the PSP
;

        call    PullInDll
        jc      already_here            ; failed to load

        call    InstallInterruptHandlers

        assume  es:nothing

        push    es
        pop     ds
        call    is_c_on_command_line
        jz      @f

        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode
        mov     not_exclusive, 1

        assume  ds:nothing
@@:

;
; free the environment segment
;

        mov     es,es:[PDB_environ]
        mov     ah,49h
        int     21h                     ; free environment segment

;if DEBUG
;ifdef VERBOSE
;        DbgPrintString <"NetWare Redir successfully loaded",13,10>
;endif
;endif

;
; finally terminate and stay resident
;

        mov     dx,ResidentEnd
        sub     dx,ResidentStart        ; number of paragraphs in resident code
        add     dx,10h                  ; additional for PSP (PDB)


;if DEBUG
;ifdef VERBOSE
;        DbgPrintString "Staying resident with "
;        DbgPrintHexWord dx
;        DbgPrintString " paragraphs. Load seg is ",NOBANNER
;        mov     ah,62h
;        int     21h
;        DbgPrintHexWord bx
;        DbgPrintString " current seg is ",NOBANNER
;        DbgPrintHexWord cs
;        DbgCrLf
;endif
;endif

        mov     ax,3100h
        int     21h                     ; terminate and stay resident

;
; here if the MS-DOS version check (Ah=30h) call is not supported
;

ancient_version:
        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

        mov     dx,offset bad_ver_msg
        mov     ah,9                    ; cp/m-style write to output
        int     21h

;
; safe exit: what we really want to do here is INT 20H, but when you do this,
; CS must be the segment of the PSP of this program. Knowing that CD 20 is
; embedded at the start of the PSP, the most foolproof way of doing this is
; to jump (using far return) to the start of the PSP
;

        push    es
        xor     ax,ax
        push    ax
        retf                            ; terminate

;
; we are running on a version of DOS >= 2.00, but its not NT, so we still can't
; help. Display the familiar message and exit, but using a less programmer-
; hostile mechanism
;

invalid_version:
        mov     dx,offset bad_ver_msg
        mov     cx,BAD_VER_MSG_LEN
        jmps    print_error_message_and_exit

;
; if we cannot initialize 32-bit support (because we can't find/load the DLL)
; then put back the hooked interrupt vectors as they were when this TSR started,
; display a message and fail to load the redir TSR
;

initialization_error:
        call    RestoreInterruptHandlers
        mov     dx,offset cannot_load_msg
        mov     cx,CANNOT_LOAD_MSG_LEN
        jmps    print_error_message_and_exit

;
; The DOS version's OK, but this TSR is already loaded
;

already_here:
        mov     dx,offset already_loaded_msg
        mov     cx,ALREADY_LOADED_MSG_LEN

print_error_message_and_exit:
        mov     bx,1                    ; bx = stdout handle
        mov     ah,40h                  ; write to handle
        int     21h                     ; write (cx) bytes @ (ds:dx) to stdout
        mov     ax,4c01h                ; terminate program
        int     21h                     ; au revoir, cruel environment

start   endp

;*******************************************************************************
;*
;*  InstallInterruptHandlers
;*
;*      Sets the interrupt handlers for all the ints we use - 21
;*
;*  ENTRY       es = PSP segment
;*              ds =
;*
;*  EXIT        Old21Handler contains the original interrupt 21 vector
;*
;*  RETURNS     nothing
;*
;*  ASSUMES
;*
;*******************************************************************************

InstallInterruptHandlers proc
        push    es                      ; PSP segment - destroyed by INT 21/35h
        push    ds

;
; note: if we use ResidentCode here, explicitly, instead of seg OldMultHandler,
; then we can leave out an extraneous load of ds for the ISR address
;

        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode

;
; Add ourselves to the int 21 chain
;

        mov     ax,3521h
        int     21h
        mov     word ptr Old21Handler,bx
        mov     word ptr Old21Handler+2,es
        mov     word ptr quick_jump_to_dos+1,bx
        mov     word ptr quick_jump_to_dos+3,es
        mov     word ptr for_dos_proper+1,bx
        mov     word ptr for_dos_proper+3,es
        mov     word ptr chain_previous_int21+1,bx
        mov     word ptr chain_previous_int21+3,es
        mov     dx,offset ResidentCode:NwInt21
        mov     ax,2521h
        int     21h

        pop     ds                      ; restore segment registers
        pop     es
        ret
InstallInterruptHandlers endp

;*******************************************************************************
;*
;*  RestoreInterruptHandlers
;*
;*      Resets the interrupt handlers for all the ints we use - 21
;*
;*  ENTRY       Old21Handler
;*              contain the interrupt vectors from before nw16.sys was loaded
;*
;*  EXIT        Original interrupt vectors are restored
;*
;*  RETURNS     nothing
;*
;*  ASSUMES
;*
;*******************************************************************************

RestoreInterruptHandlers proc
        push    ds

        assume  ds:nothing

        push    es
        mov     dx,ResidentCode
        mov     es,dx

        assume  es:ResidentCode

        lds     dx,Old21Handler
        mov     ax,2521h
        int     21h

        pop     es
        pop     ds
        ret
RestoreInterruptHandlers endp

;*******************************************************************************
;*
;*  PullInDll
;*
;*      Does a RegisterModule to load NWAPI32.DLL into our NTVDM.EXE
;*
;*  ENTRY       nothing
;*
;*  EXIT        nothing
;*
;*  RETURNS     cf if fails.
;*
;*  ASSUMES     Earth moves round Sun
;*
;******************************************************************************/

PullInDll proc near

        pusha                           ; dispatch code
        push    dx                      ; save callers dx,ds,es,ax
        push    ds
        push    es
        push    ax

        mov     dx,InitCode
        mov     ds,dx

        assume  ds:InitCode

        push    ds
        pop     es

        assume  es:InitCode

        mov     si,offset DllName       ; ds:si = nwapi32.dll
        mov     di,offset InitFunc      ; es:di = init routine
        mov     bx,offset DispFunc      ; ds:bx = dispatch routine
        mov     ax,ResidentCode
        mov     dx,offset ConnectionIdTable
                                        ; ax:dx = shared datastructure

        RegisterModule

        jc      @f

        mov     dx,ResidentCode
        mov     ds,dx
        assume  ds:ResidentCode
        mov     word ptr hVDD,ax

@@:     pop     ax                      ; callers ax
        pop     es                      ; callers es
        pop     ds                      ; callers ds
        pop     dx                      ; callers dx

        assume  ds:nothing
        assume  es:nothing

        popa                            ; dispatch code
        ret
PullInDll endp

;*******************************************************************************
;*
;*  is_c_on_command_line
;*
;*     -C or /C means we should open compatiblity mode createfiles as shared
;*      instead of exclusive
;*
;*  ENTRY       ds points to PDB
;*
;*  EXIT        nothing
;*
;*  RETURNS     zero if not found.
;*
;*  ASSUMES     ds points at PSP
;*
;******************************************************************************/

is_c_on_command_line proc near
        mov     si,80h
        lodsb
        cbw
        mov     cx,ax
next:   jcxz    quit
        dec     cx
        lodsb
check_next:
        cmp     al,'-'
        je      check_c
        cmp     al,'/'
        je      check_c
        cmp     al,' '
        je      next
        cmp     al,9
        je      next
find_ws:jcxz    quit
        dec     cx
        lodsb
        cmp     al,' '
        je      next
        cmp     al,9
        je      next
        jmp     short find_ws
check_c:jcxz    quit
        dec     cx
        lodsb
        or      al,20h
        cmp     al,'c'
        jne     find_ws
        or      cx,ax
quit:   or      cx,cx
        ret
is_c_on_command_line endp

InitCodeEnd
end     start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=nw16

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\segorder.inc ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    segorder.inc
;
;Abstract:
;
;    This module contains the segment order and segment macros
;
;Author:
;
;    Richard Firth (rfirth) 05-Sep-1991
;
;Environment:
;
;    Dos mode only
;
;Notes:
;
;    When initially loaded, the NT VDM redir has the following order:
;
;       +----------------------+
;       |                      |
;       |    Resident Code     |
;       |                      |
;       +----------------------+
;       |                      |
;       |    Resident Data     |
;       |                      |
;       +----------------------+ ----------------+
;       |                      |                 |
;       | Initialisation Code  | <- entry point  v
;       |                      |
;       +----------------------+
;       |                      |                 all the stuff between these
;       | Initialisation Data  |                 arrows is discarded if we stay
;       |                      |                 resident. Note that the redir
;       +----------------------+                 does not uninstall
;       |                      |
;       | Initialisation Stack |                 ^
;       |                      |                 |
;       +----------------------+ ----------------+
;
;Revision History:
;
;    05-Sep-1991 rfirth
;        Created
;
;--*/



ResidentStart   segment public para 'code'
ResidentStart   ends

ResidentCode    segment public word 'code'
ResidentCode    ends

ResidentData    segment public word 'data'
ResidentData    ends

ResidentEnd     segment public para 'data'
ResidentEnd     ends

ResidentGroup   group   ResidentStart, ResidentCode, ResidentData, ResidentEnd

InitCode        segment public para 'init'
InitCode        ends

InitData        segment public word 'init'
InitData        ends

InitStack       segment stack para 'stack'
InitStack       ends

;
; macros to avoid having to type in/possibly alter segment header guff
;

ResidentCodeStart macro
ResidentCode    segment public word 'code'
endm

ResidentCodeEnd macro
ResidentCode    ends
endm

ResidentDataStart macro
ResidentData    segment public word 'data'
endm

ResidentDataEnd macro
ResidentData    ends
endm

InitCodeStart   macro
InitCode        segment public para 'init'
endm

InitCodeEnd     macro
InitCode        ends
endm

InitDataStart   macro
InitData        segment public word 'init'
endm

InitDataEnd     macro
InitData        ends
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\debugmac.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    debugmac.inc
;
;Abstract:
;
;    Contains debugging macros:
;
;       DbgBreakPoint
;       DbgUnsupported
;       DbgDEBUG
;       DbgPrint
;       DbgPrintTty
;       DbgPrintString
;       DbgPrintHexDword
;       DbgPrintHexWord
;       DbgPrintHexByte
;       DbgPrintNearPointer
;       DbgPrintFarPointer
;
;Author:
;
;    Richard L Firth (rfirth) 13-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;[Notes:]
;
;    optional-notes
;
;Revision History:
;
;    13-Sep-1991 rfirth
;        Created
;
;--


;***    DbgBreakPoint
;*
;*      Same as NT routine of same name. No-op in non-DEBUG version
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgBreakPoint macro
if DEBUG
        int     3
endif
endm

;***    DbgUnsupported
;*
;*      Causes the 32-bit support code to display a message about an unsupported
;*      service code, and dumps the 16-bit registers. Used to discover when an
;*      unsupported int 2f/11 call or int 21/5f call is being made
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgUnsupported macro
if DEBUG
        SVC     -1
endif
endm

;***    DbgDEBUG
;*
;*      Prints the string "DEBUG: " to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    ax
;*
;*      ASSUMES 286+
;*
;***

DbgDEBUG macro
        mov     ax,(14 shl 8) + 'D'
        int     10h
        mov     al,'E'
        int     10h
        mov     al,'B'
        int     10h
        mov     al,'U'
        int     10h
        mov     al,'G'
        int     10h
        mov     al,':'
        int     10h
        mov     al,' '
        int     10h
endm



;***    DbgCrLf
;*
;*      Prints CR,LF to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgCrLf macro
        push    ax
        mov     ax,(14 shl 8) + 13
        int     10h
        mov     al,10
        int     10h
        pop     ax
endm



;***    DbgPrint
;*
;*      Prints an ASCIZ string to console using Bios Int 10h
;*
;*      ENTRY   string  - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrint macro string
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; save regs used by DbgPrintTty
        push    ax
        push    bx
        push    si
        push    ds
        mov     ax,seg string
        mov     ds,ax
        mov     si,offset string;; ds:si = address of string
        DbgPrintTty             ;; display it on console
        pop     ds
        pop     si
        pop     bx
        pop     ax
        popf
endif
endm



;***    DbgPrintTty
;*
;*      Prints an ASCIZ string in ds:si to console using Bios Int 10h
;*
;*      ENTRY   page    - if present defines which Bios video page to use
;*                        Defaults to 0
;*              ds:si   - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    al, bh, si, flags
;*
;*      ASSUMES 286+
;*
;***

DbgPrintTty macro page
        local   l1,l2

if DEBUG                        ;; no macro if not debug version
        mov     ah,14           ;; Bios Int write character as TTY function
ifb <page>
        sub     bh,bh
else
        mov     bh,page
endif
        cld                     ;; autoincrement lodsb
l1:     lodsb                   ;; al := next character; si := next character addr
        or      al,al           ;; eof string?
        jz      l2              ;; yes
        int     10h             ;; display it to console
        jmp     short l1        ;; go round again
l2:
endif
endm



;***    DbgPrintString
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions. The string "DEBUG: " will be
;*      displayed if the banner parm is not blank
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*              banner  - the "DEBUG: " banner will be printed if not blank
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintString macro string, banner
        local   s1
        local   l1

if DEBUG                        ;; no macro if not debug version
        jmp     short l1
s1      db      &string,0
l1:     pushf                   ;; don't destroy direction flag
        pusha                   ;; save gp regs
ifb <banner>
        DbgDEBUG                ;; Display "DEBUG: "
endif
        push    ds              ;; save user's data seg
        push    cs
        pop     ds              ;; ds == cs
        mov     si,offset cs:s1 ;; si := string offset
        DbgPrintTty             ;; display ds:si to console
        pop     ds              ;; restore user's data seg
        popa                    ;; restore gp regs
        popf                    ;; restore direction flag+
endif
endm



;***    DbgPrintHexDword
;*
;*      Prints a dword to console in hex notation using Bios Int 10h
;*
;*      ENTRY   dword   - dword to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexDword macro dword
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexDword not implemented yet",13,10>
endif
endm



;***    DbgPrintHexWord
;*
;*      Prints a word to console in hex notation using Bios Int 10h
;*
;*      ENTRY   word    - to print. Can be memory or register
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexWord macro word
        local   l1, l2
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; don't use any registers
        push    ax
        push    cx
        push    dx
ifdifi <word>,<ax>
        mov     ax,word
endif
        mov     cx,4
l1:     rol     ax,4
        mov     dx,ax
        and     al,0fh
        cmp     al,9
        jle     l2
        add     al,'a'-('9'+1)
l2:     add     al,'0'
        mov     ah,14
        int     10h
        mov     ax,dx
        loop    l1
        pop     dx
        pop     cx
        pop     ax
        popf
endif
endm



;***    DbgPrintHexByte
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*
;*      EXIT
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexByte macro byte
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexByte not implemented yet",13,10>
endif
endm



DbgPrintNearPointer macro nearptr
endm



DbgPrintFarPointer macro farptr
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\resident.asm ===
page    ,132
if 0

/*++

Copyright (c) 1993-4 Microsoft Corporation

Module Name:

    resident.asm

Abstract:

    This module contains the resident code part of the stub redir TSR for NT
    VDM NetWare support.

Author:

    Colin Watson (colinw)   08-Jul-1993

Environment:

    Dos mode only

Revision History:

    08-Jul-1993 colinw
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include ..\..\..\..\public\sdk\inc\isvbop.inc      ; NTVDM BOP mechanism
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include segorder.inc    ; segments
include mult.inc        ; MultNET
include sf.inc          ; SFT definitions/structure
include pdb.inc         ; program header/process data block structure

include debugmac.inc    ; DbgPrint macro
include asmmacro.inc    ; language extensions

include nwdos.inc       ; NetWare structures and nwapi32 interface

.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file


.286                    ; all code in this module 286 compatible

far_segment segment
far_label label far
far_segment ends

ResidentCodeStart

        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  Old21Handler
Old21Handler    dd      ?

;
; IMPORTANT: the following up to the comment <END NWDOSTABLE> must
; be kept in the same order as for the NWDOSTABLE structure in NWDOS.H/.INC.
; Align on 32 bits to make it convenient for nwapi32.dll
;
        align 4

        public  ConnectionIdTable
ConnectionIdTable       CID      MC dup (<>)

        public  ServerNameTable
ServerNameTable         db       MC * SERVERNAME_LENGTH dup (0)

        public  DriveIdTable
DriveIdTable            db       MD dup (0)

        public  DriveFlagTable
DriveFlagTable          db       MD dup (0)

        public  DriveHandleTable
DriveHandleTable        db      MD dup (0)

        public  PreferredServer
PreferredServer         db      0

        public  PrimaryServer
PrimaryServer           db      0

        public  TaskModeByte
TaskModeByte            db      0

CurrentDrive            db      0

        public  SavedAx;
SavedAx                 dw      0

        public  NtHandleHi;
NtHandleHi              dw      0
        public  NtHandleLow;
NtHandleLow             dw      0

        public  NtHandleSrcHi;          //      Used in FileServerCopy
NtHandleSrcHi           dw      0
        public  NtHandleSrcLow;
NtHandleSrcLow          dw      0

        public hVDD
hVDD                    dw      -1

        public PmSelector
PmSelector              dw      0

        public  CreatedJob
CreatedJob              db      0
        public  JobHandle
JobHandle               db      0

NOV_BUFFER_LENGTH       equ     256

        public  DenovellBuffer
DenovellBuffer          db      NOV_BUFFER_LENGTH  dup (?)

        public  DenovellBuffer2
DenovellBuffer2         db      NOV_BUFFER_LENGTH  dup (?)


.errnz (size DeNovellBuffer2 - size DenovellBuffer)

Comspec                 db      "COMSPEC="
COMSPEC_LENGTH          equ ($ - Comspec)

;
; this is the <END NWDOSTABLE> structure.
;

;
; data passed from nw16.asm
;
        public not_exclusive
not_exclusive           db      0

        page

        public  NwInt21
NwInt21 proc    far
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        sti                             ; make sure ints are still enabled

;
; check whether we filter this vector; if not, pass it through to previous INT 21
; handler (DOS or some other TSR)
;
; If this is a name based operation, and the caller is passing through a novell
; format name - SYS:FOO or SERVER\SYS:FOO - then munge the name to be a UNC name
;

        cmp     ah,0eh
        jne     @f
        jmp     select_default_drive
@@:     cmp     ah,39h                  ; create directory
        je      check_name
        ja      @f

;
; ah less than 39h (mkdir) is definitely for DOS
;

        public  quick_jump_to_dos
quick_jump_to_dos:
        jmp     far_label

;
; run any of the following name-based calls through the name check:
;
;       3ah     remove directory
;       3bh     change directory
;       3ch     create file
;       3dh     open file
;       41h     delete file
;       43h     get/set attributes
;       4bh     exec program
;       4eh     find first file
;       56h     rename
;

@@:     cmp     ah,3dh
        jbe     check_name
        cmp     ah,41h                  ; delete file
        je      check_name
        cmp     ah,43h                  ; get/set attributes
        je      check_name
        cmp     ah,4bh                  ; exec program
        je      check_name
        cmp     ah,4eh                  ; find first file
        je      check_name
        cmp     ah,56h                  ; rename
        je      rename
        jmp     dispatch_check


;
; Rename function. This has 2 path names: source in ds:dx and
; destination in es:di. Check the destination first then fall through
; and check the source.
;
rename:
        push    ds
        push    dx
        push    es
        push    di                      ; user registers saved for after Int21

        push    ds                      ; save ds:dx 'cause we will corrupt them
        push    dx

        mov     dx,es
        mov     ds,dx
        mov     dx,di                   ; ds:dx = destination buffer
        call    IsDosPath
        je      @f                      ; DOS path, no modification
        cld
        push    di
        call    DenovellizeName
        pop     di
        cmp     dx,offset DenovellBuffer
        je      swap_buffers

@@:
        pop     dx                      ; ds:dx points at source again
        pop     ds

        pop     di
        pop     es
        pop     dx
        pop     ds
        jmp     check_name

;
; Destination name was normalized and stored in DeNovellBuffer. put the data
; in Denovellbuffer2 in-case we need to put the Source name in Denovellbuffer
;

swap_buffers:
        push    cx
        push    si
        push    ds                      ; will become es during Dos call

        mov     si,dx
        mov     di,cs
        mov     es,di
        mov     di,offset DenovellBuffer2
        mov     cx,NOV_BUFFER_LENGTH / 2
.errnz (NOV_BUFFER_LENGTH and 1)

        rep     movsw

        mov     di,offset DenovellBuffer2
        pop     es                      ; es:di is now Denovellbuffer2
        pop     si
        pop     cx

        pop     dx                      ; make ds:dx source again
        pop     ds

                                        ; stack has users di,es,dx,ds pushed
                                        ; parameters are same as callers except for es:di
        jmp     check_src

check_name:                             ; ds:dx points at name to examine
        push    ds
        push    dx
        push    es
        push    di
                                        ; fall through

check_src:                              ; only jumped to in rename

        cld
        call    IsDosPath
        je      for_dos_properR         ; x: or UNC filename. No more processing

        cmp     ah,3dh
        jne     notNETQ                 ; special NETQ open only applies for create
        cmp     CreatedJob,0
        jz      notNETQ                 ; don't look at name if no job handle available

        push    ax
        push    si
        mov     si,dx
        cld
        lodsw
        cmp     ax,"EN"
        jne     @f
        lodsw
        cmp     ax,"QT"
        jne     @f
        lodsb
        or      al,al
        jnz     @f

        pop     si                      ; Opening NETQ. Return Dos handle from CreateJob and File
        pop     ax
        mov     CreatedJob,0            ; Only return handle once
        mov     al, JobHandle
        xor     ah, ah
        pop     di
        pop     es
        pop     dx
        pop     ds
        clc
        retf    2

@@:     pop     si
        pop     ax
        jmp     for_dos_properR

notNETQ:push    di
        call    DenovellizeName         ; munge the name if required
        pop     di                      ; restore caller DI

;
; Look for compatibility mode opens that need to change to exlusive mode
; opens so that they get properly cached. Criteria for opening exclusive
; is that the application did not specify any sharing modes and the drive
; being opened is on a netware drive.
;

        cmp     ah, 3ch
        je      @f
        cmp     ah, 3dh
        jne     not_compat
@@:     test    al,OF_SHARE_MASK
        jne     not_compat

        cmp     not_exclusive, 1        ; open shared mode anyway
        je      not_compat

        mov     SavedAx,ax
        mov     ax,hVdd
        DispatchCall                    ; 32 bit code decides if compat mode

not_compat:
        pushf
        call    Old21Handler            ; fake int 21 to get to DOS

        pop     di
        pop     es
        pop     dx
        pop     ds
        retf    2                       ; return to app (with flags from DOS)

for_dos_properR:                        ; restore regs and call dos
        pop     di
        pop     es
        pop     dx
        pop     ds
        cmp     ah, 3ch
        je      @f
        cmp     ah, 3dh
        jne     for_dos_proper
@@:     test    al,OF_SHARE_MASK
        jne     for_dos_proper
        cmp     not_exclusive, 1        ; open shared mode anyway
        je      for_dos_proper
        mov     SavedAx,ax
        mov     ax,hVdd
@@:     DispatchCall                    ; 32 bit code decides if compat mode
        public  for_dos_proper
for_dos_proper:
        jmp     far_label

dispatch_check:
        cmp     ah,04ch
        jne     check_9f
        jmp     process_exit

;
; 'special' entry point to return the data segment info to the protect-mode code
; so it can generate an LDT descriptor which refers to this memory.
;

check_9f:
        cmp     ah,9fh
        jne     check_nw_ep             ; is it a Netware call?
        or      al,al
        jnz     check_handle_mapper
        mov     bx,seg ConnectionIdTable; 9f00: return segment info
        mov     dx,offset ConnectionIdTable
        clc                             ; if we loaded then it can't fail
        retf    2

;
; if the call is 9f01 then we call MapNtHandle for the value in BX. This will
; update NtHandleHi and NtHandleLow, which we assume will be accessed from the
; code segment register
;

check_handle_mapper:
        cmp     al,1
        jne     check_nw_ep             ; still not one of ours?
        call    MapNtHandle             ; 9f01: call MapNtHandle
        retf    2

check_nw_ep:
        cmp     ah,0b4h
        jb      for_dos_proper
        cmp     ah,0f3h
        ja      for_dos_proper
        jne     @f
        jmp     file_server_copy
@@:     cmp     ah,0BAh
        jne     check_f0

        push    bx                      ; get environment. used by map.exe
        push    ax
        mov     ah,051h                 ; load current apps PDB into ax
        int     021h

@@:     mov     es, bx
        cmp     bx, es:PDB_Parent_PID
        je      @f
        mov     bx, es:PDB_Parent_PID
        jmp     @b
@@:
        mov     dx, es:PDB_environ      ; set DX to environment segment
        mov     es, dx                  ; set es:di to value of COMSPEC

        push    si
        push    ds
        mov     ds, dx
        xor     si, si

;       future code to save space
;       es <- env seg
;       di <- env off
;       ds <- cs
;       si <- offset Comspec
;       cx <- .size Comspec / 2
;       cld
;       repz cmpsw
;       jnz     no match

;       al <- 0
;       cx <- remaining size of env seg
;       rep scasb

        cld
next_var:
        lodsb
        cmp     al, "C"
        jne     @f
        lodsb
        cmp     al, "O"
        jne     @f
        lodsb
        cmp     al, "M"
        jne     @f
        lodsb
        cmp     al, "S"
        lodsb
        jne     @f
        cmp     al, "P"
        jne     @f
        lodsb
        cmp     al, "E"
        jne     @f
        lodsb
        cmp     al, "C"
        jne     @f
        lodsb
        cmp     al, "="
        je      got_comspec

@@:                                     ; Search for null terminating environment
        or      al,al
        je      next_var
        lodsb
        jmp     @b

got_comspec:
        pop     ds
        mov     di,si
        pop     si

        pop     ax
        pop     bx
        iret

check_f0:
        cmp     ah,0f0h
        jne     for_me

;
; if we're here then we're doing simple stuff that we don't need to bop fer
; currently stuff here is ah=f0, al = 00, 01, 04, 05
;
; caveat emptor dept #312: However, it came to pass that we needed to bop when
; the f00x calls were made without any preceding calls that would cause nwapi32
; to be loaded
;

dispatch_f0:

.errnz ((offset PrimaryServer - offset PreferredServer) - 1)

        or      al,al                   ; f000 = set preferred server
        jnz     try_01
        cmp     dl,8
        ja      zap_preferred
        mov     PreferredServer,dl
        iret

zap_preferred:
        mov     PreferredServer,al      ; al contains 0 remember
        iret

try_01: cmp     al,1                    ; f001 = get preferred server
        jnz     try_02
        mov     al,PreferredServer
        iret

try_02: cmp     al,2                    ; f002 = get default server
        jnz     try_04
        mov     al,PreferredServer
        or      al,al
        jnz     @f
        mov     al,PrimaryServer
@@:     iret

try_04: cmp     al,4                    ; f004 = set primary server
        jne     try_05
        cmp     dl,8
        ja      zap_primary
        mov     PrimaryServer,dl
        iret

zap_primary:
        mov     PrimaryServer,0
        iret

try_05: cmp     al,5                    ; f005 = get primary server
        jne     for_me
        mov     al,PrimaryServer
        iret

file_server_copy:
        call    FileServerCopy          ; f3 - Used by ncopy.exe
        ;jmp    for_me

;
; if the process exits and the dll is loaded then call the 32 bit code to
; close any cached handles.
;

process_exit:
       ;jmp     for_me

;
; if we're here then the dispatch code is for a NetWare client API. First we
; check if we have already loaded the 32-bit code. If not, then load it. If we
; get an error, we will fall through to DOS
;

for_me:
        cmp     ah,0BCh                 ; bc,bd,be need handle mapping
        jb      no_mapping
        cmp     ah,0BEh
        ja      no_mapping

;do_mapping_call:
        call    MapNtHandle             ; take bx and find the Nt handle

no_mapping:
        mov     SavedAx,ax

        cmp     ah,0e3h                 ; Look for CreateJob NCP
        jne     @f                      ; try f2 alternative

        mov     al,[si+2]                 ; si is NCP subfunction
        jmp     lookupcode

@@:     cmp     ax,0f217h
        jne     do_dispatch             ; Not CreateJob
        mov     al,[si+2]               ; si is NCP subfunction

lookupcode:
        cmp     al,68h
        je      createjob
        cmp     al,79h
        jne     do_dispatch


createjob:                              ; It is a CreateJob and File

                                        ; Always return the errorcode from the NCP exchange
                                        ; regardless of any earlier failures in the NT plumbing.
        mov     ax, SavedAx
        push    ax                      ; Open \\Server\queue for NCP
        push    ds
        push    dx
        mov     ax, 9f02h
        mov     SavedAx,ax

        mov     ax,hVdd
        DispatchCall                    ; Set DeNovellBuffer to \\Server\queue
                                        ; and registers ready for DOS OpenFile

        pushf
        call    Old21Handler            ; Open \\server\queue
        jc      @f
        mov     JobHandle, al
        mov     CreatedJob, 1           ; Flag JobHandle is valid
        push    bx
        xor     ah, ah
        mov     bx, ax                  ; JobHandle
        call    MapNtHandle             ; take bx and find the Nt handle
        pop     bx

@@:
        pop     dx
        pop     ds                      ; Proceed and send the NCP
        pop     ax
        mov     SavedAx, ax

do_dispatch:
        mov     ax,hVdd
        DispatchCall
        retf 2                          ; return to the application

        public  chain_previous_int21
chain_previous_int21:
        jmp     far_label


;
; Save new drive so we can conveniently handle compatibility mode opens.
; also need to return 32 as the number of available drives.
;

select_default_drive:
        pushf
        call    Old21Handler            ; fake int 21 to get to DOS

        mov     ah,19h                  ; get current drive
        pushf
        call    Old21Handler            ; fake int 21 to get to DOS
        mov     CurrentDrive,al         ; current drive

        mov     al,32                   ; # of drives supported by NetWare
        retf    2                       ; return to app (with flags from DOS)


NwInt21 endp

;*******************************************************************************
;*
;*  FileServerCopy
;*
;*      Implement preperation for calling
;*      \\...)
;*
;*  ENTRY       applications registers
;*
;*  EXIT        nothing
;*
;*  RETURNS     nothing
;*
;*  ASSUMES     no registers (except flags) can be destroyed
;*
;******************************************************************************/

FileServerCopy proc near

        push    ax
        push    bx

        mov     bx,word ptr es:[di]     ; Map Source Handle
        call    MapNtHandle

        mov     bx,NtHandleHi
        mov     NtHandleSrcHi,bx
        mov     bx,NtHandleLow
        mov     NtHandleSrcLow,bx

        mov     bx,word ptr es:[di+2]   ; Map Destination Handle
        call    MapNtHandle

@@:     pop     bx
        pop     ax

        ret
FileServerCopy endp

;*******************************************************************************
;*
;*  IsDosPath
;*
;*      Checks to see if a path name looks like a Microsoft path (<drive>:... or
;*      \\...)
;*
;*  ENTRY       ds:dx = path name
;*
;*  EXIT        nothing
;*
;*  RETURNS     ZF = 1: path is for MS-DOS
;*
;*  ASSUMES     no registers (except flags) can be destroyed
;*
;******************************************************************************/

IsDosPath proc near
        push    ax
        xchg    si,dx                   ; si = offset of filename; dx = ????
        mov     al,[si+1]               ; al = second character of filename
        cmp     al,':'
        je      @f                      ; looks like a DOS filename
        cmp     al,'\'                  ; (X\... or \\...)
        jne     tryFirstbyte
        cmp     al,'/'                  ; (X/... or //...)
        jne     @f                      ; second char is not "\" or "/"

tryFirstbyte:
        mov     al,[si]                 ; al = first character of filename
        cmp     al,'\'                  ; (\\... or \/...)
        je      @f
        cmp     al,'/'                  ; (\/... or //...)

@@:     xchg    si,dx                   ; dx = offset of filename; si = ????
        pop     ax
        ret
IsDosPath endp

;*******************************************************************************
;*
;*  DenovellizeName
;*
;*      Converts a name from Novell format (SERVER\SHARE:filename or
;*      SHARE:filename) to DOS UNC name. Server name is found by:
;*
;*              if PreferredServer != 0 then Index = PreferredServer
;*              else if PrimaryServer != 0 then Index = PrimaryServer
;*              else Index = 0
;*              servername = ServerNameTable[Index * sizeof(SERVER_NAME)]
;*
;*  ENTRY       ds:dx = name
;*
;*  EXIT        ds:dx = offset of DenovellBuffer
;*
;*  RETURNS     if success, DI points to last byte+1 in DenovellBuffer, else
;*              DI is garbage
;*
;*  ASSUMES     1. filename does not wrap in buffer segment
;*              2. DI register can be trashed
;*              3. DF = 0
;*
;******************************************************************************/

DenovellizeName proc near
        assume  ds:nothing
        assume  es:nothing

        push    ax
        push    bx
        push    cx
        push    bp
        push    si
        push    es
        mov     bp,ds

;
; get the length of the input filename
;

        mov     cx,ds
        mov     es,cx
        mov     di,dx                   ; es:di = filename
        xor     cx,cx
        dec     cx                      ; cx = ffff
        xor     al,al
        repnz   scasb
        not     cx
        dec     cx                      ; cx = strlen(filename)
        cmp     cx,length DenovellBuffer
        jb      @f
        jmp     dnn_ret                 ; filename too long: give it to DOS

;
; find the offset of ':' in the filename
;

@@:     mov     bx,cx                   ; remember length
        mov     di,dx                   ; es:di = filename
        mov     al,':'
        repnz   scasb                   ; di = strchr(filename, ':')+1
        jz      @f
go_home:jmp     dnn_ret                 ; no ':' - not novell format name?
@@:     cmp     byte ptr [di],0
        je      go_home                 ; device name? (eg "LPT1:") - to DOS
        mov     si,di                   ; si = offset of ':' in name, +1

;
; find the offset of the first '/' or '\'
;

        mov     cx,bx                   ; cx = length of filename
        mov     di,dx                   ; di = offset of filename
        mov     al,'\'
        repnz   scasb
        sub     bx,cx
        mov     cx,bx
        mov     bx,di
        mov     di,dx
        mov     al,'/'
        repnz   scasb
        jnz     @f
        mov     bx,di

;
; if ':' before '\' or '/' then name is SYS:FOO... else SERVER\SYS:FOO...
;

@@:     mov     di,cs
        mov     es,di
        mov     di,offset DenovellBuffer
        mov     ax,('\' shl 8) + '\'
        stosw
        cmp     bx,si
        jb      copy_share_name
        xor     bx,bx
        mov     cl,PreferredServer
        or      cl,cl
        jnz     got_index
        mov     cl,PrimaryServer
        jcxz    get_server_name

got_index:
        dec     cl
        jz      get_server_name
        mov     bx,cx

.errnz SERVERNAME_LENGTH - 48

        shl     cx,5
        shl     bx,4

get_server_name:
        add     bx,cx
        mov     cx,ds
        mov     si,es
        mov     ds,si
        lea     si,ServerNameTable[bx]
        cmp     byte ptr [si],0
        je      dnn_ret
        mov     ah,SERVERNAME_LENGTH

copy_server_name:
        lodsb
        or      al,al
        jz      done_server_name
        stosb
        dec     ah
        jnz     copy_server_name

done_server_name:
        mov     al,'\'
        stosb
        mov     ds,cx

copy_share_name:
        mov     si,dx

next_char:
        lodsb
        cmp     al,':'
        je      @f
        stosb
        jmp     short next_char
@@:     mov     al,'\'
        stosb

copy_rest:
        lodsb
        stosb
        or      al,al
        jnz     copy_rest
        cmp     byte ptr [si-2],':'
        jne     @f
        mov     byte ptr [si-2],0
@@:     mov     dx,offset DenovellBuffer
        mov     bp,es

dnn_ret:mov     ds,bp
        pop     es
        pop     si
        pop     bp
        pop     cx
        pop     bx
        pop     ax
        ret
DenovellizeName endp



;***    DosCallBack
;*
;*      Call back into DOS via the int 2f/ah=12 back door. If CALL_DOS defined,
;*      use a call, else s/w interrupt. Using a call means no other TSRs etc.
;*      which load AFTER the redir can hook it, but we DON'T HAVE TO MAKE A
;*      PRIVILEGE TRANSITION ON x86 which speeds things up. This should be safe,
;*      because no other s/w should really be hooking INT 2F/AH=12
;*
;*      ENTRY   FunctionNumber  - dispatch code goes in al
;*              DosAddr         - if present, variable containing address of
;*                                DOS int 2f entry point
;*              OldMultHandler  - this variable contains the address of DOSs
;*                                int 2f back door. Specific to redir code
;*
;*      EXIT    nothing
;*
;*      USES    ax, OldMultHandler
;*
;*      ASSUMES nothing
;*
;***

DosCallBack macro FunctionNumber, DosAddr
        mov     ax,(MultDOS shl 8) + FunctionNumber
ifdef CALL_DOS
        pushf
ifb <DosAddr>
if (((.type OldMultHandler) and 32) eq 0)    ;; OldMultHandler not defined
        extrn   OldMultHandler:dword
endif
        call    OldMultHandler
else
        call    DosAddr
endif
else
        int     2fh
endif
endm

;
; defines for DosCallBack FunctionNumbers
;

SF_FROM_SFN     =       22
PJFN_FROM_HANDLE=       32

; ***   MapNtHandle
; *
; *     Given a handle in BX, map it to a 32-bit Nt handle store result
; *             in NtHandle[Hi|Low]
; *
; *
; *     ENTRY   bx = handle to map
; *
; *     EXIT    Success - NtHandle set to 32-bit Nt handle from SFT
; *
; *     RETURNS Success - CF = 0
; *             Failure - CF = 1, ax = ERROR_INVALID_HANDLE
; *
; *     USES    ax, bx, flags
; *
; *     ASSUMES nothing
; *
; ***

MapNtHandle proc near
        pusha                           ; save regs used by Dos call back
        push    ds
        push    es

;
; call back to Dos to get the pointer to the JFN in our caller's JFT. Remember
; the handle (BX) is an index into the JFT. The byte at this offset in the JFT
; contains the index of the SFT structure we want in the system file table
;

        DosCallBack PJFN_FROM_HANDLE    ; pJfnFromHamdle
        jc      @f                      ; bad handle

;
; we retrieved a pointer to the required byte in the JFT. The byte at this
; pointer is the SFT index which describes our 'file' (file to (un)lock in
; this case). We use this as an argument to the next call back function -
; get Sft from System File Number.
;

        mov     bl,es:[di]
        xor     bh,bh
        DosCallBack SF_FROM_SFN         ; SfFromSfn
        jc      @f                      ; oops - bad handle

;
; Ok. We have a pointer to the SFT which describes this named pipe. Get the
; 32-bit Nt handle and store it in the shared datastructure.
;

        mov     bx,word ptr es:[di].sf_NtHandle[2]
        mov     NtHandleHi,bx
        mov     bx,word ptr es:[di].sf_NtHandle
        mov     NtHandleLow,bx

;
; restore all registers used by Dos call back.
; Carry flag is set appropriately
;

@@:     pop     es
        pop     ds
        popa
        jnc     @f

;
; finally, if there was an error then return a bad handle indication in ax
;

        mov     ax,ERROR_INVALID_HANDLE
@@:     ret
MapNtHandle endp

ResidentCodeEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\tsr\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\nwapi32.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWAPI32.C

Abstract:

      This module contains the NetWare(R) SDK support to routines
      into the NetWare redirector

Author:

      Chris Sandys    (a-chrisa)  09-Sep-1993

Revision History:

      Chuck Y. Chan (chuckc)   02/06/94  Moved to NWCS. Make it more NT like.
      Chuck Y. Chan (chuckc)   02/27/94  Clear out old code.
                                         Make logout work.
                                         Check for error in many places.
                                         Dont hard code strings.
                                         Remove non compatible parameters.
                                         Lotsa other cleanup.
      Tommy R. Evans (tommye)  04/21/00  Added two routines:
                                            NwNdsObjectHandleToConnHandle()
                                            NwNdsConnHandleFree()
                                            
--*/

#include "procs.h"
#include "nwapi32.h"
#include <nds32.h>
#include <stdio.h>
 
//
// Define structure for internal use. Our handle passed back from attach to
// file server will be pointer to this. We keep server string around for
// discnnecting from the server on logout. The structure is freed on detach.
// Callers should not use this structure but treat pointer as opaque handle.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

//
// define define categories of errors
//
typedef enum _NCP_CLASS {
    NcpClassConnect,
    NcpClassBindery,
    NcpClassDir
} NCP_CLASS ;

//
// define error mapping structure
//
typedef struct _NTSTATUS_TO_NCP {
    NTSTATUS NtStatus ;
    NWCCODE  NcpCode  ;
} NTSTATUS_TO_NCP, *LPNTSTATUS_TO_NCP ;
    
//
// Error mappings for directory errors
//
NTSTATUS_TO_NCP MapNcpDirErrors[] = 
{
    {STATUS_NO_SUCH_DEVICE,                VOLUME_DOES_NOT_EXIST},
    {STATUS_INVALID_HANDLE,                BAD_DIRECTORY_HANDLE},
    {STATUS_OBJECT_PATH_NOT_FOUND,         INVALID_PATH},
    {STATUS_UNSUCCESSFUL,                  INVALID_PATH},
    {STATUS_NO_MORE_ENTRIES,               NO_SUCH_OBJECT},
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    { 0,                                   0 }
} ;

//
// Error mappings for connect errors
//
NTSTATUS_TO_NCP MapNcpConnectErrors[] = 
{
    {STATUS_UNSUCCESSFUL,                  INVALID_CONNECTION},
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_NO_MORE_ENTRIES,               UNKNOWN_FILE_SERVER},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    { 0,                                   0 }
} ;

//
// Error mappings for bindery errors
//
NTSTATUS_TO_NCP MapNcpBinderyErrors[] = 
{
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_NO_MORE_ENTRIES,               UNKNOWN_FILE_SERVER},
    {STATUS_NO_MORE_ENTRIES,               NO_SUCH_OBJECT},
    {STATUS_INVALID_PARAMETER,             NO_SUCH_PROPERTY},
    {STATUS_UNSUCCESSFUL,                  INVALID_CONNECTION},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    {STATUS_NO_SUCH_DEVICE,                VOLUME_DOES_NOT_EXIST},
    {STATUS_INVALID_HANDLE,                BAD_DIRECTORY_HANDLE},
    {STATUS_OBJECT_PATH_NOT_FOUND,         INVALID_PATH},
    // {0xC0010001,                           INVALID_CONNECTION},
    // {0xC0010096,                           SERVER_OUT_OF_MEMORY},
    // {0xC0010098,                           VOLUME_DOES_NOT_EXIST},
    // {0xC001009B,                           BAD_DIRECTORY_HANDLE},
    // {0xC001009C,                           INVALID_PATH},
    // {0xC00100FB,                           NO_SUCH_PROPERTY},
    // {0xC00100FC,                           NO_SUCH_OBJECT},
    { 0,                                   0 }
} ;


//
// Forwards
//
DWORD 
CancelAllConnections(
      LPWSTR    pszServer
);


NWCCODE 
MapNtStatus( 
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
);

DWORD 
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) ;

DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
);

//
// Static functions used internally
//

LPSTR
NwDupStringA(
    const LPSTR       lpszA,
    WORD              length
)
{
    LPSTR lpRet;

    //
    // Allocate memory
    //
    lpRet = LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT , length );

    if(lpRet == NULL) return(NULL);

    //
    // Dupulicate string
    //
    memcpy( (LPVOID)lpRet, (LPVOID)lpszA, length );

    return(lpRet);
}


VOID
MapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
)
{
    LCID lcid;
//
// Netware Japanese version The following character is replaced with another one
// if the string is for File Name only when sendding from Client to Server.
//
// any char, even DBCS trailByte. 
//
//  SJIS+0xBF     -> 0x10
//  SJIS+0xAE     -> 0x11
//  SJIS+0xAA     -> 0x12
//
// DBCS TrailByte only.
//
//  SJIS+0x5C     -> 0x13
//

// Get system locale and language ID in Kernel mode in order to  
// distinguish the currently running system.

    NtQueryDefaultLocale( TRUE, &lcid );

    if (! (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
           PRIMARYLANGID(lcid) == LANG_KOREAN ||
           PRIMARYLANGID(lcid) == LANG_CHINESE) ) {

            return;
    }

    if(lpszA == NULL)
        return;


    while( length ) {

        if( IsDBCSLeadByte(*lpszA) && (length >= 2) ) {

                //  Adding length>=2 ensure the Lead Byte is followed by
                //  a trail byte , Fix bug #102729
                //
                // This is a DBCS character, check trailbyte is 0x5C or not.
                //

                lpszA++;
                length--;
                if( *lpszA == 0x5C ) {
                    *lpszA = (UCHAR)0x13;
                }

        }

        switch( (UCHAR) *lpszA ) {
            case 0xBF :
                *lpszA = (UCHAR)0x10;
                break;
            case 0xAE :
                *lpszA = (UCHAR)0x11;
                break;
            case 0xAA :
                *lpszA = (UCHAR)0x12;
                break;
        }

        //
        // next char
        //
        lpszA++;
        length--;
    }
}

VOID
UnmapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
)
{
    LCID lcid;

    //
    // Get system locale and language ID in Kernel mode in order to  
    // distinguish the currently running system.
    //

    NtQueryDefaultLocale( TRUE, &lcid );

    if (! (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
           PRIMARYLANGID(lcid) == LANG_KOREAN ||
           PRIMARYLANGID(lcid) == LANG_CHINESE) ) {

            return;
    }

    if (lpszA == NULL)
        return;

    while( length ) {
        if( IsDBCSLeadByte(*lpszA) && (length >= 2) ) {
                //  Adding length>=2 ensure the Lead Byte is followed by  
                //  a trail byte , Fix bug #102729
                //
                // This is a DBCS character, check trailbyte is 0x5C or not.
                //
                lpszA++;
                length--;
                if( *lpszA == 0x13 ) {
                    *lpszA = (UCHAR)0x5C;
                }
        }

        switch( (UCHAR) *lpszA ) {
            case 0x10 :
                *lpszA = (UCHAR)0xBF;
                break;
            case 0x11 :
                *lpszA = (UCHAR)0xAE;
                break;
            case 0x12 :
                *lpszA = (UCHAR)0xAA;
                break;
        }
        //
        // next char
        //
        lpszA++;
        length--;
    }
}

DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
    )
{
    if (!MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             lpszC,
                             -1,
                             lpszW,
                             nSize))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}


NWCCODE 
MapNtStatus( 
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
    )
{
    LPNTSTATUS_TO_NCP pErrorMap ;

    if (ntstatus == STATUS_SUCCESS)
        return SUCCESSFUL ;

    switch ( ncpclass ) {
        case NcpClassBindery: 
            pErrorMap = MapNcpBinderyErrors ; 
            break ;
        case NcpClassDir: 
            pErrorMap = MapNcpDirErrors ; 
            break ;
        case NcpClassConnect: 
            pErrorMap = MapNcpConnectErrors ; 
            break ;
        default:                      
            return 0xFFFF ;        
    }

    while (pErrorMap->NtStatus)
    {
        if (pErrorMap->NtStatus == ntstatus)
            return (pErrorMap->NcpCode) ;

        pErrorMap++ ;
    }

    return 0xFFFF ;
}

DWORD 
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) 
{
    DWORD Status ;

    if (NtStatus & 0xC0010000) {            // netware specific
 
        Status = ERROR_EXTENDED_ERROR ;

    } else if (NtStatus == NWRDR_PASSWORD_HAS_EXPIRED) {

        Status = 0 ;  // note this is not an error (the operation suceeded!)

    } else {

        Status = RtlNtStatusToDosError(NtStatus) ;

    }

    SetLastError(Status) ;

    return Status ;
}

//
//  FormatString - Supplies an ANSI string which describes how to
//     convert from the input arguments into NCP request fields, and
//     from the NCP response fields into the output arguments.
//
//       Field types, request/response:
//
//          'b'      byte              ( byte   /  byte* )
//          'w'      hi-lo word        ( word   /  word* )
//          'd'      hi-lo dword       ( dword  /  dword* )
//          '-'      zero/skip byte    ( void )
//          '='      zero/skip word    ( void )
//          ._.      zero/skip string  ( word )
//          'p'      pstring           ( char* )
//          'P'      DBCS pstring      ( char* )
//          'c'      cstring           ( char* )
//          'C'      cstring followed skip word ( char*, word ) 
//          'r'      raw bytes         ( byte*, word )
//          'R'      DBCS raw bytes    ( byte*, word )
//          'u'      p unicode string  ( UNICODE_STRING * )
//          'U'      p uppercase string( UNICODE_STRING * )
//          'W'      word n followed by an array of word[n] ( word, word* )
//
//
//
//
// Standard NCP Function Block
//
//
//    NWCCODE NWAPI DLLEXPORT
//    NW***(
//        NWCONN_HANDLE           hConn,
//        )
//    {
//        NWCCODE NcpCode;
//        NTSTATUS NtStatus;
//    
//        NtStatus = NwlibMakeNcp(
//                        hConn,                  // Connection Handle
//                        FSCTL_NWR_NCP_E3H,      // Bindery function
//                        ,                       // Max request packet size
//                        ,                       // Max response packet size
//                        "b|",                   // Format string
//                        // === REQUEST ================================
//                        0x,                     // b Function
//                        // === REPLY ==================================
//                        );
//    
//        return MapNtStatus( NtStatus, NcpClassXXX );
//    }
//    
//    

NWCCODE NWAPI DLLEXPORT
NWAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char      NWFAR   *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    )
{
    unsigned short     reply;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Directory function
                    265,                    // Max request packet size
                    2,                      // Max response packet size
                    "bbrbP|",               // Format string
                    // === REQUEST ================================
                    0x0d,                   // b Add trustee to directory
                    dirHandle,              // b 0xffffffff to start or last returned ID when enumerating  HI-LO
                    &dwTrusteeID,DW_SIZE,   // r Object ID to assigned to directory
                    rightsMask,             // b User rights for directory
                    pszPath,                // P Directory (if dirHandle = 0 then vol:directory)
                    // === REPLY ==================================
                    &reply                  // Not used
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );

}
NWCCODE NWAPI DLLEXPORT
NWAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // E2 Function function
                    261,                    // Max request packet size
                    4,                      // Max response packet size
                    "bbbP|bb",              // Format string
                    // === REQUEST ================================
                    0x12,                   // b Function Alloc Perm Dir
                    dirHandle,              // b 0 for new
                    0,                      // b Drive Letter
                    pszDirPath,             // P Volume Name (SYS: or SYS:\PUBLIC)
                    // === REPLY ==================================
                    pbNewDirHandle,         // b Dir Handle
                    pbRightsMask            // b Rights
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // E2 Function function
                    261,                    // Max request packet size
                    4,                      // Max response packet size
                    "bbbP|bb",              // Format string
                    // === REQUEST ================================
                    0x13,                   // b Function Alloc Temp Dir
                    dirHandle,              // b 0 for new
                    0,                      // b Drive Letter
                    pszDirPath,             // P Volume Name (SYS: or SYS:\PUBLIC)
                    // === REPLY ==================================
                    pbNewDirHandle,         // b Dir Handle
                    pbRightsMask            // b Rights
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    )
{
    WORD               wDummy;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    2,                      // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0xC8,                   // b Get Console Privilges
                    // === REPLY ==================================
                    &wDummy,W_SIZE          // r Dummy Response
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );     
}

NWCCODE NWAPI DLLEXPORT
NWDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    )
{
    WORD               wDummy;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // E2 Function function
                    4,                      // Max request packet size
                    2,                      // Max response packet size
                    "bb|w",                 // Format string
                    // === REQUEST ================================
                    0x14,                   // b Function Dealloc Dir Hand
                    dirHandle,              // b 0 for new
                    // === REPLY ==================================
                    &wDummy
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO    NWFAR   *lpVerInfo
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR      NWFAR   *pIntAddr
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    14,                     // Max response packet size
                    "bb|r",                 // Format string
                    // === REQUEST ================================
                    0x13,                   // b Get Internet Address
                    nConnNum,               // b Connection Number
                    // === REPLY ==================================
                    pIntAddr,12             // r File Version Structure
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}


NWCCODE NWAPI DLLEXPORT
NWGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char            NWFAR   *pszObjName,
    NWOBJ_TYPE      NWFAR   *pwObjType )
{
    NWOBJ_ID           dwRetID;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 


    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    7,                      // Max request packet size
                    56,                     // Max response packet size
                    "br|rrR",               // Format string
                    // === REQUEST ================================
                    0x36,                   // b Get Bindery Object Name
                    &dwObjectID,DW_SIZE,    // r Object ID    HI-LO
                    // === REPLY ==================================
                    &dwRetID,DW_SIZE,       // r Object ID HI-LO
                    pwObjType,W_SIZE,       // r Object Type
                    pszObjName,48           // R Object Name
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

// This function not supported  (E3 E9)
NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    )
{
    WORD        wTime;                 // w Elapsed Time
    BYTE        bVoln;                 // b Vol Num
    BYTE        bDriven;               // b Drive Num
    WORD        wStartBlock;           // w Starting Block
    WORD        wMaxUsedDir;           // w Actual Max Used Directory Entries
    BYTE        bVolHashed;            // b Volume is hashed
    BYTE        bVolCached;            // b Volume is Cached
    BYTE        bVolMounted;           // b Volume is mounted

    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    42,                     // Max response packet size
                    "bb|wbbwwwwwwwbbbbr",   // Format string
                    // === REQUEST ================================
                    0xe9,                   // b Get Volume Information
                    nVolNum,                // b Volume Number (0 to Max Vol)
                    // === REPLY ==================================
                    &wTime,                 // w Elapsed Time
                    &bVoln,                 // b Vol Num
                    &bDriven,               // b Drive Num
                    pwSectors,              // w Sectors per block
                    &wStartBlock,           // w Starting Block
                    pwTotalBlocks,          // w Total Blocks
                    pwAvailBlocks,          // w Available Blocks (free)
                    pwTotalDir,             // w Total Dir Slots
                    pwAvailDir,             // w Available Directory Slots
                    &wMaxUsedDir,           // w Actual Max Used Directory Entries
                    &bVolHashed,            // b Volume is hashed
                    &bVolCached,            // b Volume is Cached
                    pfVolRemovable,         // b Volume is removable
                    &bVolMounted,           // b Volume is mounted
                    pszVolName,16           // r Volume Name
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    4,                      // Max request packet size
                    30,                     // Max response packet size
                    "bb|wwwwwrb",           // Format string
                    // === REQUEST ================================
                    0x15,                   // b Get Volume Information
                    nDirHand,               // b Dir Handle
                    // === REPLY ==================================
                    pwSectors,              // w Sectors per block
                    pwTotalBlocks,          // w Total Blocks
                    pwAvailBlocks,          // w Available Blocks (free)
                    pwTotalDir,             // w Total Dir Slots
                    pwAvailDir,             // w Available Directory Slots
                    pszVolName,16,          // r Volume Name
                    pfVolRemovable          // b Volume is removable
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWGetVolumeName(
    NWCONN_HANDLE       hConn,
    NWVOL_NUM           bVolNum,
    char        NWFAR   *pszVolName
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Directory Services
                    4,                      // Max request packet size
                    19,                     // Max response packet size
                    "bb|p",                 // Format string
                    // === REQUEST ================================
                    0x06,                   // Get Volume Name
                    bVolNum,                // Volume Number
                    // === REPLY ==================================
                    pszVolName             // Return Volume name
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWIsObjectInSet(
        NWCONN_HANDLE           hConn,
        const char      NWFAR   *lpszObjectName,
        NWOBJ_TYPE              wObjType,
        const char      NWFAR   *lpszPropertyName,
        const char              NWFAR   *lpszMemberName,
        NWOBJ_TYPE                              wMemberType
        )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 
        WORD               Dummy;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,   // Connection Handle
                    FSCTL_NWR_NCP_E3H,    // Bindery function
                    122,                  // Max request packet size
                    2,                    // Max response packet size
                    "brPPrP|",            // Format string
                    // === REQUEST ================================
                    0x43,                 // b Read Property Value
                    &wObjType,W_SIZE,     // r OT_???  HI-LO
                    lpszObjectName,       // P Object Name
                    lpszPropertyName,     // P Prop Name
                    &wMemberType,W_SIZE,  // r Member Type
                    lpszMemberName,       // P Member Name
                    // === REPLY ==================================
                    &Dummy,W_SIZE
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );

} // NWIsObjectInSet

NWCCODE NWAPI DLLEXPORT
NWLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszUserName,
    NWOBJ_TYPE              wObType,
    const char      NWFAR   *pszPassword
    )
{
    NETRESOURCEW       NetResource;
    DWORD              dwRes, dwSize;
    NWCCODE            nwRes;
    LPWSTR             pszUserNameW = NULL, 
                       pszPasswordW = NULL;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // validate parameters
    //
    if (!hConn || !pszUserName || !pszPassword)
        return INVALID_CONNECTION ;

    //
    // allocate memory for unicode strings and convert ANSI input
    // to Unicode.
    //
    dwSize = strlen(pszUserName)+1 ;
    if (!(pszUserNameW = (LPWSTR)LocalAlloc(
                                       LPTR, 
                                       dwSize * sizeof(WCHAR))))
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }
    if (szToWide( pszUserNameW, pszUserName, dwSize ) != NO_ERROR)
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }

    dwSize = strlen(pszPassword)+1 ;
    if (!(pszPasswordW = (LPWSTR)LocalAlloc(
                                       LPTR, 
                                       dwSize * sizeof(WCHAR))))
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }
    
    if (szToWide( pszPasswordW, pszPassword, dwSize ) != NO_ERROR)
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = (LPWSTR) pServerInfo->ServerString.Buffer;
    NetResource.lpComment    = NULL;
    NetResource.lpProvider   = NULL ;

    //
    // make the connection 
    //
    dwRes=NPAddConnection ( &NetResource, 
                            pszPasswordW, 
                            pszUserNameW );

    if( NO_ERROR != dwRes ) {
        dwRes = GetLastError();
        switch( dwRes ) {
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                nwRes = SUCCESSFUL;
                break;
            case ERROR_ALREADY_ASSIGNED:
                nwRes = ALREADY_ATTACHED;
                break;
            case ERROR_ACCESS_DENIED:
            case ERROR_BAD_DEV_TYPE:
            case ERROR_BAD_DEVICE:
            case ERROR_BAD_NET_NAME:
            case ERROR_BAD_PROFILE:
            case ERROR_CANNOT_OPEN_PROFILE:
            case ERROR_DEVICE_ALREADY_REMEMBERED:
            case ERROR_EXTENDED_ERROR:
            case ERROR_INVALID_PASSWORD:
            case ERROR_NO_NET_OR_BAD_PATH:
            case ERROR_NO_NETWORK:
                nwRes = INVALID_CONNECTION;
                break;
            default:
                nwRes = INVALID_CONNECTION;
                break;
        }
    } else {
        nwRes = SUCCESSFUL;
    }

ExitPoint: 

    if (pszUserNameW)
        (void) LocalFree((HLOCAL) pszUserNameW) ;
    if (pszPasswordW)
        (void) LocalFree((HLOCAL) pszPasswordW) ;

    return( nwRes );
}

NWCCODE NWAPI DLLEXPORT
NWLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    DWORD              dwRes;
    NWCCODE            nwRes;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // cancel all explicit connections to that server
    //
    (void) CancelAllConnections ( pServerInfo->ServerString.Buffer );

    //
    // now cancel the any connection to \\servername.
    //
    dwRes=NPCancelConnection( pServerInfo->ServerString.Buffer, TRUE );

    if( NO_ERROR != dwRes ) {
        dwRes = GetLastError();
        switch( dwRes ) 
        {
            case ERROR_NOT_CONNECTED:
            case ERROR_INVALID_HANDLE:
                nwRes = SUCCESSFUL;
                break;

            case ERROR_BAD_PROFILE:
            case ERROR_CANNOT_OPEN_PROFILE:
            case ERROR_DEVICE_IN_USE:
            case ERROR_EXTENDED_ERROR:
                nwRes = INVALID_CONNECTION;
                break;
            default:
                nwRes = INVALID_CONNECTION;
                break;
        }
    } else {
        nwRes = SUCCESSFUL;
    }

    return( nwRes );
}

NWCCODE NWAPI DLLEXPORT
NWReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszPropName,
    unsigned char           ucSegment,
    char            NWFAR   *pValue,
    NWFLAGS         NWFAR   *pucMoreFlag,
    NWFLAGS         NWFAR   *pucPropFlag
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    70,                     // Max request packet size
                    132,                    // Max response packet size
                    "brPbP|rbb",            // Format string
                    // === REQUEST ================================
                    0x3D,                   // b Read Property Value
                    &wObjType,W_SIZE,       // r Object Type    HI-LO
                    pszObjName,             // P Object Name
                    ucSegment,              // b Segment Number
                    pszPropName,            // P Property Name
                    // === REPLY ==================================
                    pValue,128,             // r Property value
                    pucMoreFlag,            // b More Flag
                    pucPropFlag             // b Prop Flag
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWScanObject(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID        NWFAR   *pdwObjectID,
    char            NWFAR   *pszObjectName,
    NWOBJ_TYPE      NWFAR   *pwObjType,
    NWFLAGS         NWFAR   *pucHasProperties,
    NWFLAGS         NWFAR   *pucObjectFlags,
    NWFLAGS         NWFAR   *pucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    57,                     // Max request packet size
                    59,                     // Max response packet size
                    "brrP|rrRbbb",          // Format string
                    // === REQUEST ================================
                    0x37,                   // b Scan bindery object
                    pdwObjectID,DW_SIZE,    // r 0xffffffff to start or last returned ID when enumerating  HI-LO
                    &wObjSearchType,W_SIZE, // r Use OT_??? Defines HI-LO
                    pszSearchName,          // P Search Name. (use "*") for all
                    // === REPLY ==================================
                    pdwObjectID,DW_SIZE,    // r Returned ID    HI-LO
                    pwObjType,W_SIZE,       // r rObject Type    HI-LO
                    pszObjectName,48,       // R Found Name
                    pucObjectFlags,         // b Object Flag
                    pucObjSecurity,         // b Object Security
                    pucHasProperties        // b Has Properties
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWScanProperty(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszSearchName,
    NWOBJ_ID        NWFAR   *pdwSequence,
    char            NWFAR   *pszPropName,
    NWFLAGS         NWFAR   *pucPropFlags,
    NWFLAGS         NWFAR   *pucPropSecurity,
    NWFLAGS         NWFAR   *pucHasValue,
    NWFLAGS         NWFAR   *pucMore
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    26,                     // Max response packet size
                    "brPrP|Rbbrbb",         // Format string
                    // === REQUEST ================================
                    0x3C,                   // b Scan Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // P Object Name
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pszSearchName,          // P Property Name to Search for
                    // === REPLY ==================================
                    pszPropName,16,         // R Returned Property Name
                    pucPropFlags,           // b Property Flags
                    pucPropSecurity,        // b Property Security
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pucHasValue,            // b Property Has value
                    pucMore                 // b More Properties
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}




NWCCODE NWAPI DLLEXPORT
NWGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE            NWFAR   *year,
    BYTE            NWFAR   *month,
    BYTE            NWFAR   *day,
    BYTE            NWFAR   *hour,
    BYTE            NWFAR   *minute,
    BYTE            NWFAR   *second,
    BYTE            NWFAR   *dayofweek
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E0H,      // Server function
                    0,                      // Max request packet size
                    9,                      // Max response packet size
                    "|bbbbbbb",             // Format string
                    // === REQUEST ================================
                    // === REPLY ==================================
                    year,
                    month,
                    day,
                    hour,
                    minute,
                    second,
                    dayofweek
                    );


    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassConnect );
    
} // NWGetFileServerDateAndTime


//
// worker routines
//

#define NW_RDR_SERVER_PREFIX L"\\Device\\Nwrdr\\"


DWORD 
CancelAllConnections(
      LPWSTR    pszServer
)
/*++

Routine Description:

    This routine cancels all connections to a server

Arguments:

    pszServer - the server we are disconnecting from

Return Value:

    NO_ERROR or win32 error for failure.

--*/
{
    DWORD status = ERROR_NO_NETWORK;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE NetR = NULL;

    DWORD BytesNeeded = 4096;
    DWORD EntriesRead;
    DWORD i;

    //
    // Retrieve the list of connections
    //
    status = NPOpenEnum(
                   RESOURCE_CONNECTED,
                   0,
                   0,
                   NULL,
                   &EnumHandle
                   );

    if (status != NO_ERROR) {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get connection list.
    //
    if ((NetR = (LPNETRESOURCE) LocalAlloc(
                                    LPTR,
                                    (UINT) BytesNeeded
                                    )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        status = NPEnumResource(
                     EnumHandle,
                     &EntriesRead,
                     (LPVOID) NetR,
                     &BytesNeeded
                     );

        if (status == WN_SUCCESS) 
        {
            LPNETRESOURCE TmpPtr = NetR;

            for (i = 0; i < EntriesRead; i++, TmpPtr++) 
            {
                LPWSTR pszTmp ;

                //
                // If it contains the server we are logging off from, we want
                // to cancel it. First, lets extract the server name part.
                //

                pszTmp = TmpPtr->lpRemoteName ; 

                if (!pszTmp || !*pszTmp)
                    continue ;

                if ((*pszTmp == L'\\') && (*(pszTmp+1) == L'\\'))
                    pszTmp += 2 ; 

                if (pszTmp = wcschr(pszTmp, L'\\'))
                    *pszTmp = 0 ;

                if (_wcsicmp(TmpPtr->lpRemoteName, pszServer) == 0)
                {
                    //
                    // Aha, it matches. Restore the '\' and nuke it with force.
                    // Ignore errors here.
                    //
                    if (pszTmp)
                        *pszTmp = L'\\' ;

                    if (TmpPtr->lpLocalName && *(TmpPtr->lpLocalName))
                    {
                        //
                        // if local name present, its a redirection. 
                        //
                        (void) NPCancelConnection( TmpPtr->lpLocalName,TRUE );
                    }
                    else
                    {
                        //
                        // else cancel the deviceless use
                        //
                        (void) NPCancelConnection( TmpPtr->lpRemoteName,TRUE );
                    }
                }
            }

        }
        else if (status != WN_NO_MORE_ENTRIES) {

            status = GetLastError();

            if (status == WN_MORE_DATA) {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                if ((NetR = (LPNETRESOURCE) LocalAlloc(
                                         LPTR,
                                         (UINT) BytesNeeded
                                         )) == NULL) {

                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else
            {
                //
                // cant handle other errors. bag out.
                //
                goto CleanExit;
            }
        }

    } while (status != WN_NO_MORE_ENTRIES);

    if (status == WN_NO_MORE_ENTRIES) 
    {
        status = NO_ERROR;
    }

CleanExit:

    if (EnumHandle != (HANDLE) NULL) 
    {
        (void) NPCloseEnum(EnumHandle);
    }

    if (NetR != NULL) 
    {
        (void) LocalFree((HLOCAL) NetR);
    }

    return status;
}

NWCCODE NWAPI DLLEXPORT
NWCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    )
{
   NTSTATUS           NtStatus;
   PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

   NtStatus = NwlibMakeNcp(
                  pServerInfo->hConn,     // Connection Handle
                  FSCTL_NWR_NCP_E3H,      // Bindery function
                  174,                    // Max request packet size
                  6,                      // Max response packet size
                  "brPbP|r",              // Format string
                  // === REQUEST ================================
                  0x64,                   // b Create Queue
                  &wQueueType,W_SIZE,     // r Queue Type    HI-LO
                  pszQueueName,           // P Queue Name
                  dirHandle,              // b Directory Handle
                  pszPathName,            // P Path name
                  // === REPLY ==================================
                  pdwQueueId,DW_SIZE      // r Queue ID HI-LO
                  );

   (void) SetWin32ErrorFromNtStatus(NtStatus);
   return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS   NtStatus;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp (
                   pServerInfo->hConn,   // Connection Handle
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   70,                   // Max request packet size
                   2,                    // Max response packet size
                   "brPbP|",             // Format string
                   // === REQUEST ================================
                   0x3B,                 // b Change Property Security
                   &wObjType,W_SIZE,     // r OT_???  HI-LO
                   pszObjName,           // P Prop Name
                   ucObjSecurity,        // b New Property security
                   pszPropertyName       // P Property Name
                   // === REPLY ==================================
                   );

   (void) SetWin32ErrorFromNtStatus( NtStatus );
   return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWDestroyQueue(
    NWCONN_HANDLE hConn,
    NWOBJ_ID      dwQueueId
    )
{
    NTSTATUS   NtStatus;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                   pServerInfo->hConn,   // Connection Handle
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   7,                    // Max request packet size
                   2,                    // Max response packet size
                   "bd|",                // Format string
                   // === REQUEST ================================
                   0x65,                 // b Destroy Queue
                   dwQueueId             // d Queue ID
                   // === REPLY ==================================
                   );

   (void) SetWin32ErrorFromNtStatus( NtStatus );
   return MapNtStatus( NtStatus, NcpClassBindery );

}

//
// tommye MS 88021 / MCS 
//
//  Added the following two routines to allow the library user 
//  to obtain a NWCONN_HANDLE given a ObjectHandle, then free that 
//  handle.
//

NWCONN_HANDLE NWAPI DLLEXPORT
NwNdsObjectHandleToConnHandle(
    IN HANDLE ObjectHandle)
{
    PNWC_SERVER_INFO    pServerInfo;
    LPNDS_OBJECT_PRIV   pObject = (LPNDS_OBJECT_PRIV)ObjectHandle;

    /** Allocate the NWCONN_HANDLE to return **/

    pServerInfo = (PNWC_SERVER_INFO)LocalAlloc(LPTR, sizeof(NWC_SERVER_INFO));
    if (pServerInfo == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    /** Fill it in **/

    pServerInfo->hConn = pObject->NdsTree;

    /** 
        Fill in the server name, even though NWLoginToFileServer and 
        NWLogoutFromFileServer are the only calls that use it now.
    **/

    RtlInitUnicodeString(
                    &pServerInfo->ServerString, 
                    pObject->szContainerName);

    /** 
        Return the pointer to the block, which is our form of NWCONN_HANDLE.
        The caller is responsible for calling NwNdsConnHandlFree when done.
    **/

    return (NWCONN_HANDLE)pServerInfo;
}

VOID NWAPI DLLEXPORT
NwNdsConnHandleFree(
    IN NWCONN_HANDLE hConn)
{
    if (hConn) {
        PNWC_SERVER_INFO pServerInfo = (PNWC_SERVER_INFO)hConn;

        /** Free the connection handle **/

        LocalFree(pServerInfo);
    }

    /** All done **/

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwapi32\nwapi32.c ===
//
// dummy file to make build happy
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\nwcapi32.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWAPI32.C

Abstract:

      This module contains NetWare compatible APIs.  The NWC* functions
      are implemented as wrappers around NWP* or NW* functions.

Author:

      Chuck Y. Chan   (ChuckC)  06-Mar-1995

Revision History:

      ChuckC          Moved over from DSM to consolidate.
                                  
--*/

#include "procs.h"
 
//
// define define categories of errors
//
typedef enum _NCP_CLASS {
    NcpClassConnect,
    NcpClassBindery,
    NcpClassDir
} NCP_CLASS ;

extern NWCCODE 
MapNtStatus( 
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
);

extern DWORD 
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) ;


//
// Function bodies
//


NWCCODE 
NWCAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    )
{
    return (NWAddTrusteeToDirectory(
                            hConn,
                            dirHandle,
                            pszPath,
                            dwTrusteeID,
                            rightsMask)) ;
}

NWCCODE 
NWCAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    )
{
    return (NWAllocPermanentDirectoryHandle(
                            hConn,
                            dirHandle,
                            pszDirPath,
                            pbNewDirHandle,
                            pbRightsMask)) ;
}

NWCCODE 
NWCAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    )
{
    return (NWAllocTemporaryDirectoryHandle(
                            hConn,
                            dirHandle,
                            pszDirPath,
                            pbNewDirHandle,
                            pbRightsMask)) ;
}

NWCCODE 
NWCAttachToFileServer(
    const char              *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    return (NWAttachToFileServer(
                            pszServerName,
                            ScopeFlag,
                            phNewConn)) ;
}

NWCCODE 
NWCAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    return (NWAttachToFileServerW(
                            pszServerName,
                            ScopeFlag,
                            phNewConn)) ;
}

NWCCODE 
NWCCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    )
{
    return(NWCheckConsolePrivileges(hConn)); 
}

NWCCODE 
NWCDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    )
{
    return(NWDeallocateDirectoryHandle(
                            hConn,
                            dirHandle)) ;
}

NWCCODE 
NWCDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    return(NWDetachFromFileServer(hConn)) ;
}

NWCCODE 
NWCGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    )
{
    return(NWGetFileServerVersionInfo(
                            hConn,
                            lpVerInfo)) ;
}

NWCCODE 
NWCGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR              *pIntAddr
    )
{
    return (NWGetInternetAddress(
                            hConn,
                            nConnNum,
                            pIntAddr)) ;
}

NWCCODE 
NWCGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType )
{
    return(NWGetObjectName(
                            hConn,
                            dwObjectID,
                            pszObjName,
                            pwObjType )) ;
}


NWCCODE 
NWCGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    )
{
    return(NWGetVolumeInfoWithNumber(
                            hConn,
                            nVolNum,
                            pszVolName,
                            pwTotalBlocks,
                            pwSectors,
                            pwAvailBlocks,
                            pwTotalDir,
                            pwAvailDir,
                            pfVolRemovable)) ;
}

NWCCODE 
NWCGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    )
{
    return(NWGetVolumeInfoWithHandle(
                            hConn,
                            nDirHand,
                            pszVolName,
                            pwTotalBlocks,
                            pwSectors,
                            pwAvailBlocks,
                            pwTotalDir,
                            pwAvailDir,
                            pfVolRemovable)) ;
}

NWCCODE 
NWCGetVolumeName(
    NWCONN_HANDLE       hConn,
    NWVOL_NUM           bVolNum,
    char                *pszVolName
    )
{
    return(NWGetVolumeName(
                        hConn,
                        bVolNum,
                        pszVolName)) ;
}

NWCCODE 
NWCIsObjectInSet(
    NWCONN_HANDLE           hConn,
    const char              *lpszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *lpszPropertyName,
    const char           	*lpszMemberName,
    NWOBJ_TYPE              wMemberType
	)
{
    return(NWIsObjectInSet(
	                        hConn,
	                        lpszObjectName,
	                        wObjType,
	                        lpszPropertyName,
                            lpszMemberName,
                            wMemberType)) ;
}


NWCCODE 
NWCLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char              *pszUserName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPassword
    )
{
    return(NWLoginToFileServer(
                            hConn,
                            pszUserName,
                            wObjType,
                            pszPassword)) ;
}

NWCCODE 
NWCLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    return(NWLogoutFromFileServer( hConn )) ;
}

NWCCODE 
NWCReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    )
{
    return(NWReadPropertyValue(
                            hConn,
                            pszObjName,
                            wObjType,
                            pszPropName,
                            ucSegment,
                            pValue,
                            pucMoreFlag,
                            pucPropFlag)) ;
}

NWCCODE 
NWCScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    )
{
    return(NWScanObject(
                            hConn,
                            pszSearchName,
                            wObjSearchType,
                            pdwObjectID,
                            pszObjectName,
                            pwObjType,
                            pucHasProperties,
                            pucObjectFlags,
                            pucObjSecurity)) ;
}

NWCCODE 
NWCScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    )
{
    return( NWScanProperty(
                            hConn,
                            pszObjectName,
                            wObjType,
                            pszSearchName,
                            pdwSequence,
                            pszPropName,
                            pucPropFlags,
                            pucPropSecurity,
                            pucHasValue,
                            pucMore)) ;
}

NWCCODE 
NWCGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    )
{
    return( NWGetFileServerDateAndTime( 
                            hConn,
                            year,
                            month,
                            day,
                            hour,
                            minute,
                            second,
                            dayofweek ));
}


NWCCODE 
NWCAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    )
{
    NTSTATUS NtStatus;

    NtStatus = NWPAddTrustee(
                   hConn,
                   dirHandle,
                   pszPath,
                   dwTrusteeID,
                   rightsMask 
                   );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;

    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE 
NWCDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    )
{
    NTSTATUS NtStatus;

    NtStatus = NWPDeleteObject( hConn,
                                pszObjectName,
                                wObjType );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;

    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPCreateObject( hConn,
                                pszObjectName,
                                wObjType,
                                ucObjectFlags,
                                ucObjSecurity );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;

    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPCreateProperty( hConn,
                                  pszObjectName,
                                  wObjType,
                                  pszPropertyName,
                                  ucObjectFlags,
                                  ucObjSecurity );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPDeleteProperty( hConn,
                                  pszObjectName,
                                  wObjType,
                                  pszPropertyName );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPWritePropertyValue( hConn,
                                      pszObjectName,
                                      wObjType,
                                      pszPropertyName,
                                      segmentNumber,
                                      segmentData,
                                      moreSegments );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS           NtStatus ;
  
    NtStatus = NWPGetObjectID( hConn,
                               pszObjectName,
                               wObjType,
                               objectID );


    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType 
    )
{
    NTSTATUS NtStatus;

    NtStatus = NWPRenameBinderyObject( 
                   hConn,
                   pszObjectName,
                   pszNewObjectName,
                   wObjType
                   );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCAddObjectToSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
  
    NtStatus = NWPAddObjectToSet( hConn,
                                  pszObjectName,
                                  wObjType,
                                  pszPropertyName,
                                  pszMemberName,
                                  memberType );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCDeleteObjectFromSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
  
    NtStatus = NWPDeleteObjectFromSet( hConn,
                                       pszObjectName,
                                       wObjType,
                                       pszPropertyName,
                                       pszMemberName,
                                       memberType );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask 
    )
{
    NTSTATUS    NtStatus;

    NtStatus = NWPCreateDirectory(
                    hConn,
                    dirHandle,
                    pszPath,
                    accessMask 
                    );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}


NWCCODE
NWCScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *ti
    )
{
    NTSTATUS    NtStatus;

    NtStatus =  NWPScanForTrustees(
                            hConn,
                            dirHandle,
                            pszsearchDirPath,
                            pucsequenceNumber,
                            numberOfEntries,
                            ti
                            ) ;

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
} 


NWCCODE
NWCScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *ti
    )
{
    NTSTATUS    NtStatus;

    NtStatus =  NWPScanDirectoryForTrustees2(
                            hConn,
                            dirHandle,
                            pszsearchDirPath,
                            pucsequenceNumber,
                            pszdirName,
                            dirDateTime,
                            ownerID,
                            ti
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
} 


NWCCODE
NWCGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS    NtStatus;

    NtStatus =  NWPGetBinderyAccessLevel(
                            hConn,
                            accessLevel,
                            objectID
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCGetFileServerDescription(
    NWCONN_HANDLE           hConn,
    char                    *pszCompany,
    char                    *pszVersion,
    char                    *pszRevision
    )
{
    NTSTATUS   NtStatus ;

    NtStatus = NWPGetFileServerDescription(
                            hConn,
                            pszCompany,
                            pszVersion,
                            pszRevision
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCGetVolumeNumber(
    NWCONN_HANDLE           hConn,
    char                    *pszVolume,
    NWVOL_NUM               *VolumeNumber
    )
{
    NTSTATUS   NtStatus ;

    NtStatus = NWPGetVolumeNumber(
                            hConn,
                            pszVolume,
                            VolumeNumber
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCGetVolumeUsage(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               VolumeNumber,
    DWORD                   *TotalBlocks,
    DWORD                   *FreeBlocks,
    DWORD                   *PurgeableBlocks,
    DWORD                   *NotYetPurgeableBlocks,
    DWORD                   *TotalDirectoryEntries,
    DWORD                   *AvailableDirectoryEntries,
    BYTE                    *SectorsPerBlock
    )
{
    NTSTATUS   NtStatus ;

    NtStatus = NWPGetVolumeUsage( 
                            hConn,
                            VolumeNumber,
                            TotalBlocks,
                            FreeBlocks,
                            PurgeableBlocks,
                            NotYetPurgeableBlocks,
                            TotalDirectoryEntries,
                            AvailableDirectoryEntries,
                            SectorsPerBlock
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    )
{
    return (NWCreateQueue(
                     hConn,
                     dirHandle,
                     pszQueueName,
                     wQueueType,
                     pszPathName,
                     pdwQueueId
                     ));
}

NWCCODE
NWCChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    )
{
    return (NWChangePropertySecurity(
                            hConn,
                            pszObjName,
                            wObjType,
                            pszPropertyName,
                            ucObjSecurity
                            ));
}

NWCCODE
NWCDestroyQueue(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwQueueId
    )
{
    return (NWDestroyQueue(
                       hConn,
                       dwQueueId
                       ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\ndsapi32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsLib32.c

Abstract:

    This module implements the exposed user-mode link to
    Netware NDS support in the Netware redirector.  For
    more comments, see ndslib32.h.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include <procs.h>
//#include <nwapilyr.h>

NTSTATUS
NwNdsOpenGenericHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwRdrHandle
) {

    NTSTATUS ntstatus, OpenStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[128];
    UNICODE_STRING uOpenName;
    UINT i;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Prepare the open name.
    //

    uOpenName.MaximumLength = sizeof( NameStr );

    if (puNdsTree->Length > (MAX_NDS_TREE_NAME_LEN * sizeof(WCHAR)))
        return STATUS_INVALID_PARAMETER;

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    try {

        for ( i = 0 ; i < ( puNdsTree->Length / sizeof( WCHAR ) ) ; i++ ) {
            NameStr[i + PreambleLength] = puNdsTree->Buffer[i];
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;

    }

    uOpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) ));
    uOpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOpenName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    //
    // Make the compiler happy about variable initialization.
    //

    RtlZeroMemory( &IoStatusBlock, sizeof( IO_STATUS_BLOCK ) );

    ntstatus = NtOpenFile(
                   phNwRdrHandle,
                   DesiredAccess,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    OpenStatus = IoStatusBlock.Status;

    //
    // Verify that this is a tree handle, not a server handle.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET)RrpData;

    Rrp->Version = 0;

    RtlCopyMemory( &(Rrp->Parameters).VerifyTree,
                   puNdsTree,
                   sizeof( UNICODE_STRING ) );

    RtlCopyMemory( (BYTE *)(&(Rrp->Parameters).VerifyTree) + sizeof( UNICODE_STRING ),
                   puNdsTree->Buffer,
                   puNdsTree->Length );

    try {

        ntstatus = NtFsControlFile( *phNwRdrHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_VERIFY_TREE,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puNdsTree->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ntstatus = GetExceptionCode();
        goto CloseAndExit2;
    }

    if ( !NT_SUCCESS( ntstatus ))
    {
        *lpdwHandleType = HANDLE_TYPE_NCP_SERVER;
    }
    else
    {
        *lpdwHandleType = HANDLE_TYPE_NDS_TREE;
    }

    return OpenStatus;

CloseAndExit2:

    NtClose( *phNwRdrHandle );
    *phNwRdrHandle = NULL;

    return ntstatus;
}


NTSTATUS
NwNdsSetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    IN PUNICODE_STRING puContext
)
/*+++

    This sets the current context in the requested tree.

---*/
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RrpSize;
    BYTE *CurrentString;

    //
    // Set up the request.
    //

    RrpSize = sizeof( NWR_NDS_REQUEST_PACKET ) +
              puTree->Length +
              puContext->Length;

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        (Rrp->Parameters).SetContext.TreeNameLen = puTree->Length;
        (Rrp->Parameters).SetContext.ContextLen = puContext->Length;

        CurrentString = (BYTE *)(Rrp->Parameters).SetContext.TreeAndContextString;

        RtlCopyMemory( CurrentString, puTree->Buffer, puTree->Length );
        CurrentString += puTree->Length;
        RtlCopyMemory( CurrentString, puContext->Buffer, puContext->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    try {

        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_SETCONTEXT,
                                    (PVOID) Rrp,
                                    RrpSize,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
)
/*+++

    This gets the current context of the requested tree.

---*/
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RrpSize;

    //
    // Set up the request.
    //

    RrpSize = sizeof( NWR_NDS_REQUEST_PACKET ) + puTree->Length;

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        (Rrp->Parameters).GetContext.TreeNameLen = puTree->Length;

        RtlCopyMemory( (BYTE *)(Rrp->Parameters).GetContext.TreeNameString,
                       puTree->Buffer,
                       puTree->Length );

        (Rrp->Parameters).GetContext.Context.MaximumLength = puContext->MaximumLength;
        (Rrp->Parameters).GetContext.Context.Length = 0;
        (Rrp->Parameters).GetContext.Context.Buffer = puContext->Buffer;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    try {

        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GETCONTEXT,
                                    (PVOID) Rrp,
                                    RrpSize,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

    //
    // Copy out the length; the buffer has already been written.
    //

    puContext->Length = (Rrp->Parameters).GetContext.Context.Length;

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}

NTSTATUS
NwNdsIsNdsConnection (
    IN  HANDLE hNdsRdr,
    OUT BOOL *          pfIsNds,
    OUT PUNICODE_STRING puTree
)
/*+++

    This tests the current connection handle to see if it is one that is
    connected to a server in an NDS tree. If so, the name of the tree is
    put into puTree.

---*/
{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PCONN_DETAILS2 Rrp;
    DWORD RrpSize;

    *pfIsNds = FALSE;

    //
    // Set up the request.
    //

    RrpSize = sizeof( CONN_DETAILS2 );

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp )
        return STATUS_INSUFFICIENT_RESOURCES;

    try
    {
        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_GET_CONN_DETAILS2,
                                    NULL,
                                    0,
                                    (PVOID) Rrp,
                                    RrpSize );

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

    if ( ntstatus == STATUS_SUCCESS )
    {
        if ( Rrp->fNds )
        {
            puTree->Length = (USHORT) wcslen( Rrp->NdsTreeName );

            if ( puTree->MaximumLength >= puTree->Length )
                wcscpy( puTree->Buffer, Rrp->NdsTreeName );
            else
                puTree->Length = 0;

            *pfIsNds = TRUE;
        }
    }

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}

NTSTATUS
NwNdsList (
   IN HANDLE   hNdsTree,
   IN DWORD    dwObjectId,
   OUT DWORD   *dwIterHandle,
   OUT BYTE    *pbReplyBuf,
   IN DWORD    dwReplyBufLen
) {

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;

    PNDS_RESPONSE_SUBORDINATE_LIST Rsp;
    DWORD dwRspBufferLen;

    BYTE RrpData[256];
    BYTE RspData[1024];

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;

    Rrp->Parameters.ListSubordinates.ObjectId = dwObjectId;
    Rrp->Parameters.ListSubordinates.IterHandle = *dwIterHandle;

   if ( dwReplyBufLen != 0 &&
        pbReplyBuf != NULL ) {

       Rsp = ( PNDS_RESPONSE_SUBORDINATE_LIST ) pbReplyBuf;
       dwRspBufferLen = dwReplyBufLen;

   } else {

       Rsp = ( PNDS_RESPONSE_SUBORDINATE_LIST ) RspData;
       dwRspBufferLen = 1024;

   }

   try {

       Status = NtFsControlFile( hNdsTree,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_NWR_NDS_LIST_SUBS,
                                 (PVOID) Rrp,
                                 sizeof( NWR_NDS_REQUEST_PACKET ),
                                 (PVOID) Rsp,
                                 dwRspBufferLen );

   } except ( EXCEPTION_EXECUTE_HANDLER ) {

       return GetExceptionCode();
   }

   if ( Status == STATUS_SUCCESS )
   {
      *dwIterHandle = Rsp->IterationHandle;
   }

   return Status;

}

NTSTATUS
NwNdsReadObjectInfo(
    IN HANDLE  hNdsTree,
    IN DWORD   dwObjectId,
    OUT BYTE   *pbRawReply,
    IN DWORD   dwReplyBufLen
)
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;

    PNDS_RESPONSE_GET_OBJECT_INFO Rsp;
    DWORD dwRspBufferLen;

    BYTE RrpData[256];
    BYTE RspData[1024];

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;

    Rrp->Parameters.GetObjectInfo.ObjectId = dwObjectId;

    if ( dwReplyBufLen != 0 &&
         pbRawReply != NULL ) {

        Rsp = ( PNDS_RESPONSE_GET_OBJECT_INFO ) pbRawReply;
        dwRspBufferLen = dwReplyBufLen;

    } else {

        Rsp = ( PNDS_RESPONSE_GET_OBJECT_INFO ) RspData;
        dwRspBufferLen = 1024;

    }

    try {

        Status = NtFsControlFile( hNdsTree,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_NDS_READ_INFO,
                                  (PVOID) Rrp,
                                  sizeof( NWR_NDS_REQUEST_PACKET ),
                                  (PVOID) Rsp,
                                  dwRspBufferLen );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    return Status;

}



NTSTATUS
NwNdsReadAttribute (
   IN HANDLE          hNdsTree,
   IN DWORD           dwObjectId,
   IN DWORD           *dwIterHandle,
   IN PUNICODE_STRING puAttrName,
   OUT BYTE           *pbReplyBuf,
   IN DWORD           dwReplyBufLen
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    PNDS_RESPONSE_READ_ATTRIBUTE Rsp = ( PNDS_RESPONSE_READ_ATTRIBUTE )
                                       pbReplyBuf;

    DWORD dwAttributeNameLen;

    BYTE RrpData[1024];

    //
    // Check the incoming buffer.
    //
    if ( !dwReplyBufLen || !Rsp )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, 1024 );

    (Rrp->Parameters).ReadAttribute.ObjectId = dwObjectId;
    (Rrp->Parameters).ReadAttribute.IterHandle = *dwIterHandle;

    //
    // Nds strings are NULL terminated; watch the size.
    //

    dwAttributeNameLen = puAttrName->Length + sizeof( WCHAR );
    if (dwAttributeNameLen > (MAX_NDS_SCHEMA_NAME_CHARS * sizeof(WCHAR))) {
        return STATUS_INVALID_PARAMETER;
    }

    (Rrp->Parameters).ReadAttribute.AttributeNameLength = dwAttributeNameLen;

    try {

        //
        // But don't try to copy more than the user gave us.
        //

        memcpy( (Rrp->Parameters).ReadAttribute.AttributeName,
                puAttrName->Buffer,
                puAttrName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

   //
   // Send the request to the Redirector FSD.
   //

   try {

       ntstatus = NtFsControlFile( hNdsTree,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_NWR_NDS_READ_ATTR,
                                   (PVOID) Rrp,
                                   sizeof( NWR_NDS_REQUEST_PACKET ) + dwAttributeNameLen,
                                   (PVOID) Rsp,
                                   dwReplyBufLen );

   } except ( EXCEPTION_EXECUTE_HANDLER ) {

       return GetExceptionCode();
   }

   if ( ntstatus == STATUS_SUCCESS )
   {
      *dwIterHandle = Rsp->IterationHandle;
   }

   //
   // There's no buffer post processing on this one.
   //

   return ntstatus;

}

NTSTATUS
NwNdsOpenStream (
    IN HANDLE          hNdsTree,
    IN DWORD           dwObjectId,
    IN PUNICODE_STRING puStreamName,
    IN DWORD           dwOpenFlags,
    OUT DWORD          *pdwFileLength
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, 1024 );

    (Rrp->Parameters).OpenStream.StreamAccess = dwOpenFlags;
    (Rrp->Parameters).OpenStream.ObjectOid = dwObjectId;

    (Rrp->Parameters).OpenStream.StreamName.Length = puStreamName->Length;
    (Rrp->Parameters).OpenStream.StreamName.MaximumLength =
        sizeof( RrpData ) - FIELD_OFFSET(NWR_NDS_REQUEST_PACKET,Parameters.OpenStream.StreamNameString);
    (Rrp->Parameters).OpenStream.StreamName.Buffer =
        (Rrp->Parameters).OpenStream.StreamNameString;

    //
    // Make sure we're not trashing memory.
    //

    if ( (Rrp->Parameters).OpenStream.StreamName.Length >
         (Rrp->Parameters).OpenStream.StreamName.MaximumLength ) {

        return STATUS_INVALID_PARAMETER;
    }

    try {

        //
        // But don't try to copy more than the user gave us.
        //

        memcpy( (Rrp->Parameters).OpenStream.StreamNameString,
                puStreamName->Buffer,
                puStreamName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send the request to the Redirector FSD.
    //

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_OPEN_STREAM,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puStreamName->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    if ( pdwFileLength ) {
        *pdwFileLength = (Rrp->Parameters).OpenStream.FileLength;
    }

    return ntstatus;
}

NTSTATUS
NwNdsGetQueueInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puQueueName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PDWORD           pdwQueueId
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, sizeof( RrpData ) );

    if ( puQueueName ) {
        (Rrp->Parameters).GetQueueInfo.QueueName.Length = puQueueName->Length;
        (Rrp->Parameters).GetQueueInfo.QueueName.MaximumLength = puQueueName->MaximumLength;
        (Rrp->Parameters).GetQueueInfo.QueueName.Buffer = puQueueName->Buffer;
    }

    if ( puHostServer ) {
        (Rrp->Parameters).GetQueueInfo.HostServer.Length = 0;
        (Rrp->Parameters).GetQueueInfo.HostServer.MaximumLength = puHostServer->MaximumLength;
        (Rrp->Parameters).GetQueueInfo.HostServer.Buffer = puHostServer->Buffer;
    }

    //
    // Send the request to the Redirector FSD.
    //

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GET_QUEUE_INFO,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ),
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    if ( NT_SUCCESS( ntstatus ) ) {

        if ( pdwQueueId ) {
            *pdwQueueId = (Rrp->Parameters).GetQueueInfo.QueueId;
        }

        if (puHostServer) {
            puHostServer->Length = (Rrp->Parameters).GetQueueInfo.HostServer.Length;
        }

    }

    return ntstatus;
}

NTSTATUS
NwNdsGetVolumeInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puVolumeName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PUNICODE_STRING  puHostVolume
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RequestSize;
    BYTE RrpData[1024];
    BYTE ReplyData[1024];
    PBYTE NameStr;

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, sizeof( RrpData ) );

    if ( !puVolumeName ||
         puVolumeName->Length > MAX_NDS_NAME_SIZE ||
         !puHostServer ||
         !puHostVolume ) {

        return STATUS_INVALID_PARAMETER;
    }

    try {

        (Rrp->Parameters).GetVolumeInfo.VolumeNameLen = puVolumeName->Length;
        RtlCopyMemory( &((Rrp->Parameters).GetVolumeInfo.VolumeName[0]),
                       puVolumeName->Buffer,
                       puVolumeName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send the request to the Redirector FSD.
    //

    RequestSize = sizeof( NWR_NDS_REQUEST_PACKET ) +
                  (Rrp->Parameters).GetVolumeInfo.VolumeNameLen;

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GET_VOLUME_INFO,
                                    (PVOID) Rrp,
                                    RequestSize,
                                    ReplyData,
                                    sizeof( ReplyData ) );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    if ( NT_SUCCESS( ntstatus ) ) {

        try {

            if ( ( puHostServer->MaximumLength < (Rrp->Parameters).GetVolumeInfo.ServerNameLen ) ||
                 ( puHostVolume->MaximumLength < (Rrp->Parameters).GetVolumeInfo.TargetVolNameLen ) ) {

                return STATUS_BUFFER_TOO_SMALL;
            }

            puHostServer->Length = (USHORT)(Rrp->Parameters).GetVolumeInfo.ServerNameLen;
            puHostVolume->Length = (USHORT)(Rrp->Parameters).GetVolumeInfo.TargetVolNameLen;

            NameStr = &ReplyData[0];

            RtlCopyMemory( puHostServer->Buffer, NameStr, puHostServer->Length );
            NameStr += puHostServer->Length;
            RtlCopyMemory( puHostVolume->Buffer, NameStr, puHostVolume->Length );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            return STATUS_INVALID_PARAMETER;
        }

    }

    return ntstatus;

}

//
// User mode fragment exchange.
//

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
);


int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
)
/*

Routine Description:

    Formats a buffer according to supplied the format string.

    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'V'      sized NDS value   ( byte *, dword / byte **, dword *)
            'S'      p unicode string copy as NDS_STRING (UNICODE_STRING *)
            's'      cstring copy as NDS_STRING (char* / char *, word)
            'r'      raw bytes         ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )

Routine Arguments:

    char *buf - destination buffer.
    int buflen - length of the destination buffer.
    char *format - format string.
    args - args to the format string.

Implementation Notes:

   This comes verbatim from kernel mode.

*/
{
    ULONG ix;

    NTSTATUS status;
    const char *z = format;

    //
    // Convert the input arguments into request packet.
    //

    ix = 0;

    while ( *z )
    {
        switch ( *z )
        {
        case '=':
            if ((ix + 1) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = 0;
            // intentional fallthrough - '='= 2 bytes, '-'= 1 byte
        case '-':
            if ((ix + 1) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = 0;
            break;

        case '_':
        {
            WORD l = va_arg ( args, WORD );
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            while ( l-- )
                buf[ix++] = 0;
            break;
        }

        case 'b':
            if ((ix + 1) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = va_arg ( args, BYTE );
            break;

        case 'w':
        {
            WORD w = va_arg ( args, WORD );
            if ((ix + 2) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = (BYTE) (w >> 8);
            buf[ix++] = (BYTE) (w >> 0);
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( args, DWORD );
            if ((ix + 4) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = (BYTE) (d >> 24);
            buf[ix++] = (BYTE) (d >> 16);
            buf[ix++] = (BYTE) (d >>  8);
            buf[ix++] = (BYTE) (d >>  0);
            break;
        }

        case 'W':
        {
            WORD w = va_arg(args, WORD);
            if ((ix + 2) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            (* (WORD *)&buf[ix]) = w;
            ix += 2;
            break;
        }

        case 'D':
        {
            DWORD d = va_arg (args, DWORD);
            if ((ix + 4) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            (* (DWORD *)&buf[ix]) = d;
            ix += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( args, char* );
            WORD  l = (WORD)strlen( c );
            if ((ix + (ULONG)l + 1) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            RtlCopyMemory( &buf[ix], c, l+1 );
            ix += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( args, char* );
            WORD l = va_arg ( args, WORD );
            WORD len = strlen( c ) + 1;
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
                goto ErrorExit;
            }

            RtlCopyMemory( &buf[ix], c, len > l? l : len);
            ix += l;
            buf[ix-1] = 0;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( args, char* );
            BYTE  l = (BYTE)strlen( c );
            if ((ix + (ULONG)l + 1) > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = l;
            RtlCopyMemory( &buf[ix], c, l );
            ix += l;
            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( args, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            //
            //  We need to check for more then just "Length" because
            //  the MaximumLength we pass in has "+1" on it so even
            //  though we don't care about the ending NULL it is
            //  going to get put in there so we have to account for it
            //
            if ( (ix + Length + 1) > (ULONG)bufLen ) {
                goto ErrorExit;
            }

            buf[ix++] = (UCHAR)Length;
            OemString.Buffer = &buf[ix];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));
            ix += (USHORT)Length;
            break;
        }

        case 'S':
        {
            PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
            ULONG Length, rLength;

            Length = pUString->Length;
            rLength = ROUNDUP4(Length + sizeof( WCHAR ));

            if (ix + sizeof(rLength) + rLength > (ULONG)bufLen) {
                goto ErrorExit;
            }

            //
            // The VLM client uses the rounded up length and it seems to
            // make a difference!  Also, don't forget that NDS strings have
            // to be NULL terminated.
            //

            *((DWORD *)&buf[ix]) = rLength;
            ix += 4;
            RtlCopyMemory(&buf[ix], pUString->Buffer, Length);
            ix += Length;
            rLength -= Length;
            RtlFillMemory( &buf[ix], rLength, '\0' );
            ix += rLength;
            break;

        }

        case 's':
        {
           PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
           ULONG Length, rLength;

           Length = pUString->Length;
           rLength = Length + sizeof( WCHAR );

           if (ix + sizeof(rLength) + rLength > (ULONG)bufLen) {
               // DebugTrace( 0, Dbg, "FormatBuf: case 's' request buffer too small.\n", 0 );
               goto ErrorExit;
           }

           //
           // Don't use the padded size here, only the NDS null terminator.
           //

           *((DWORD *)&buf[ix]) = rLength;
           ix += 4;
           RtlCopyMemory(&buf[ix], pUString->Buffer, Length);
           ix += Length;
           rLength -= Length;
           RtlFillMemory( &buf[ix], rLength, '\0' );
           ix += rLength;
           break;


        }

        case 'V':
        {
            // too similar to 'S' - should be combined
            BYTE* b = va_arg ( args, BYTE* );
            DWORD  l = va_arg ( args, DWORD );
            if ( ix + l + sizeof(DWORD) > (ULONG)
               bufLen )
            {
                goto ErrorExit;
            }
            *((DWORD *)&buf[ix]) = l;
            ix += sizeof(DWORD);
            RtlCopyMemory( &buf[ix], b, l );
                        l = ROUNDUP4(l);
            ix += l;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( args, BYTE* );
            WORD  l = va_arg ( args, WORD );
            if ( b == NULL || l == 0 )
            {
                break;
            }
            if ( ix + l > (ULONG)bufLen )
            {
                goto ErrorExit;
            }
            RtlCopyMemory( &buf[ix], b, l );
            ix += l;
            break;
        }

        default:

        ;

        }

        if ( ix > (ULONG)bufLen )
        {
            goto ErrorExit;
        }


        z++;
    }

    return(ix);

ErrorExit:
    return 0;
}


int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
)
/*

Routine Description:

    This routine calculates the buffer size needed to hold a request.
    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'V'      sized NDS value   ( byte *, dword / byte **, dword *)
            'S'      p unicode string copy as NDS_STRING (UNICODE_STRING *)
            's'      cstring copy as NDS_STRING (char* / char *, word)
            'r'      raw bytes         ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )

Routine Arguments:

    char *format - format string.
    args - args to the format string.

Implementation Notes:

   This comes verbatim from kernel mode.

*/
{
    ULONG ix;

    const char *z = format;

    //
    // Convert the input arguments into request packet.
    //

    ix = 0;

    while ( *z )
    {
        switch ( *z )
        {
        case '=':
            ix++;
        case '-':
            ix++;
            break;

        case '_':
        {
            WORD l = va_arg ( args, WORD );
            ix += l;
            break;
        }

        case 'b':
        {
            char b = va_arg ( args, BYTE );
            ix++;
            break;
        }

        case 'w':
        {
            WORD w = va_arg ( args, WORD );
            ix += 2;
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( args, DWORD );
            ix += 4;
            break;
        }

        case 'W':
        {
            WORD w = va_arg(args, WORD);
            ix += 2;
            break;
        }

        case 'D':
        {
            DWORD d = va_arg (args, DWORD);
            ix += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( args, char* );
            WORD  l = (WORD)strlen( c );
            ix += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( args, char* );
            WORD l = va_arg ( args, WORD );
            WORD len = strlen( c ) + 1;
            ix += l;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( args, char* );
            BYTE  l = (BYTE)strlen( c );
            ix++;
            ix += l;
            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( args, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            ix++;
            ix += (USHORT)Length;
            break;
        }

        case 'S':
        {
            PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
            ULONG Length, rLength;

            Length = pUString->Length;

            //
            // The VLM client uses the rounded up length and it seems to
            // make a difference!  Also, don't forget that NDS strings have
            // to be NULL terminated.
            //

            rLength = ROUNDUP4(Length + sizeof( WCHAR ));
            ix += 4;
            ix += Length;
            rLength -= Length;
            ix += rLength;
            break;

        }

        case 's':
        {
           PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
           ULONG Length, rLength;

           Length = pUString->Length;

           //
           // Don't use the padded size here, only the NDS null terminator.
           //

           rLength = Length + sizeof( WCHAR );
           ix += 4;
           ix += Length;
           rLength -= Length;
           ix += rLength;
           break;


        }

        case 'V':
        {
            // too similar to 'S' - should be combined
            BYTE* b = va_arg ( args, BYTE* );
            DWORD  l = va_arg ( args, DWORD );
            ix += sizeof(DWORD);
            l = ROUNDUP4(l);
            ix += l;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( args, BYTE* );
            WORD  l = va_arg ( args, WORD );
            if ( b == NULL || l == 0 )
            {
                break;
            }
            ix += l;
            break;
        }

        default:

        ;

        }

        z++;
    }

    return(ix);
}


NTSTATUS
_cdecl
ParseResponse(
    PUCHAR  Response,
    ULONG ResponseLength,
    char*  FormatString,
    ...                       //  format specific parameters
    )
/*++

Routine Description:

    This routine parse an NCP response.

    Packet types:

            'G'      Generic packet            ( )

         Field types, request/response:

            'b'      byte              ( byte* )
            'w'      hi-lo word        ( word* )
            'x'      ordered word      ( word* )
            'd'      hi-lo dword       ( dword* )
            'e'      ordered dword     ( dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'r'      raw bytes         ( byte*, word )

            Added 3/29/95 by CoryWest:

            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            'S'      unicode string copy as NDS_STRING (UNICODE_STRING *)
            'T'      terminal unicode string copy as NDS_STRING (UNICODE_STRING *)

            't'      terminal unicode string with the nds null copied
                     as NDS_STRING (UNICODE_STRING *) (for GetUseName)

Return Value:

    STATUS - Success or failure, depending on the response.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PCHAR FormatByte;
    va_list Arguments;
    ULONG Length = 0;

    va_start( Arguments, FormatString );

    //
    // User mode parse response handles only generic packets.
    //

    if ( *FormatString != 'G' ) {
        return STATUS_INVALID_PARAMETER;
    }

    FormatByte = FormatString + 1;
    while ( *FormatByte ) {

        switch ( *FormatByte ) {

        case '-':
            Length += 1;
            break;

        case '=':
            Length += 2;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            Length += l;
            break;
        }

        case 'b':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            *b = Response[Length++];
            break;
        }

        case 'w':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[1] = Response[Length++];
            b[0] = Response[Length++];
            break;
        }

        case 'x':
        {
            WORD* w = va_arg ( Arguments, WORD* );
            *w = *(WORD UNALIGNED *)&Response[Length];
            Length += 2;
            break;
        }

        case 'd':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[3] = Response[Length++];
            b[2] = Response[Length++];
            b[1] = Response[Length++];
            b[0] = Response[Length++];
            break;
        }

        case 'e':
        {
            DWORD UNALIGNED * d = va_arg ( Arguments, DWORD* );
            *d = *(DWORD UNALIGNED *)&Response[Length];
            Length += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = (WORD)strlen( &Response[Length] );
            memcpy ( c, &Response[Length], l+1 );
            Length += l+1;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = Response[Length++];
            memcpy ( c, &Response[Length], l );
            c[l+1] = 0;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            RtlCopyMemory( b, &Response[Length], l );
            Length += l;
            break;
        }

        case 'W':
        {

            WORD *w = va_arg ( Arguments, WORD* );
            *w = (* (WORD *)&Response[Length]);
            Length += 2;
            break;

        }

        case 'D':
        {

            DWORD *d = va_arg ( Arguments, DWORD* );
            *d = (* (DWORD *)&Response[Length]);
            Length += 4;
            break;

        }

        case 'S':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

               strl = (USHORT)(* (DWORD *)&Response[Length]);

                //
                // Don't count the null terminator that is part of
                // Novell's counted unicode string.
                //

                pU->Length = strl - sizeof( WCHAR );
                Length += 4;
                if (pU->Length >= pU->MaximumLength) {
                    pU->Length = pU->MaximumLength;
                }
                RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );
                Length += ROUNDUP4(strl);

            } else {

                //
                // Skip over the string since we don't want it.
                //

                Length += ROUNDUP4((* (DWORD *)&Response[Length] ));
                Length += 4;
            }


            break;

        }

        case 's':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                strl = (USHORT)(* (DWORD *)&Response[Length]);
                pU->Length = strl;
                Length += 4;
                if (pU->Length >= pU->MaximumLength) {
                    pU->Length = pU->MaximumLength;
                }
                RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );
                Length += ROUNDUP4(strl);

            } else {

                //
                // Skip over the string since we don't want it.
                //

                Length += ROUNDUP4((* (DWORD *)&Response[Length] ));
                Length += 4;
            }


            break;

        }

        case 'T':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                strl = (USHORT)(* (DWORD *)&Response[Length] );
                strl -= sizeof( WCHAR );  // Don't count the NULL from NDS.

                if ( strl <= pU->MaximumLength ) {

                   pU->Length = strl;
                   Length += 4;
                   RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );

                   //
                   // No need to advance the pointers since this is
                   // specifically a termination case!
                   //

                } else {

                    pU->Length = 0;
                }

            }

            break;

        }

        case 't':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                strl = (USHORT)(* (DWORD *)&Response[Length] );

                if ( strl <= pU->MaximumLength ) {

                   pU->Length = strl;
                   Length += 4;
                   RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );

                   //
                   // No need to advance the pointers since this is
                   // specifically a termination case!
                   //

                } else {

                   pU->Length = 0;

                }

            }

            break;

        }

    }

    if ( Length > ResponseLength ) {
        return( STATUS_INVALID_PARAMETER );
    }

    FormatByte++;

    }

    va_end( Arguments );
    return( Status );

}

NTSTATUS
NwNdsChangePassword(
    IN HANDLE          hNwRdr,
    IN PUNICODE_STRING puTreeName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puCurrentPassword,
    IN PUNICODE_STRING puNewPassword
) {

    NTSTATUS Status;
    PNWR_NDS_REQUEST_PACKET pNdsRequest;
    DWORD dwRequestLength;
    PBYTE CurrentString;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Allocate the request.
    //

    dwRequestLength =  sizeof( NWR_NDS_REQUEST_PACKET ) +
                       puTreeName->Length +
                       puUserName->Length +
                       puCurrentPassword->Length +
                       puNewPassword->Length;

    pNdsRequest = LocalAlloc( LMEM_ZEROINIT, dwRequestLength );

    if ( !pNdsRequest) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the parameters into the request buffer.
    //

    try {

        (pNdsRequest->Parameters).ChangePass.NdsTreeNameLength =
            puTreeName->Length;
        (pNdsRequest->Parameters).ChangePass.UserNameLength =
            puUserName->Length;
        (pNdsRequest->Parameters).ChangePass.CurrentPasswordLength =
            puCurrentPassword->Length;
        (pNdsRequest->Parameters).ChangePass.NewPasswordLength =
            puNewPassword->Length;

        CurrentString = ( PBYTE ) &((pNdsRequest->Parameters).ChangePass.StringBuffer[0]);
        RtlCopyMemory( CurrentString, puTreeName->Buffer, puTreeName->Length );

        CurrentString += puTreeName->Length;
        RtlCopyMemory( CurrentString, puUserName->Buffer, puUserName->Length );

        CurrentString += puUserName->Length;
        RtlCopyMemory( CurrentString, puCurrentPassword->Buffer, puCurrentPassword->Length );

        CurrentString += puCurrentPassword->Length;
        RtlCopyMemory( CurrentString, puNewPassword->Buffer, puNewPassword->Length );

        Status = NtFsControlFile( hNwRdr,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_NDS_CHANGE_PASS,
                                  (PVOID) pNdsRequest,
                                  dwRequestLength,
                                  NULL,
                                  0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = STATUS_INVALID_PARAMETER;
    }

    LocalFree( pNdsRequest );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\nwpapi32.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWAPI32.C

Abstract:

      This module contains several useful functions. Mostly wrappers.

Author:

      Chuck Y. Chan   (ChuckC)  06-Mar-1995

Revision History:
                                  
--*/


#include "procs.h"
 
//
// Define structure for internal use. Our handle passed back from attach to
// file server will be pointer to this. We keep server string around for
// discnnecting from the server on logout. The structure is freed on detach.
// Callers should not use this structure but treat pointer as opaque handle.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;


//
// forward declare
//
#ifndef WIN95
extern NTSTATUS
NwAttachToServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    ) ;

extern NTSTATUS
NwDetachFromServer(
    IN HANDLE handleServer
    ) ;

#endif
extern DWORD 
CancelAllConnections(
    LPWSTR    pszServer
    ) ;

extern DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
);



NTSTATUS
NWPAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    NTSTATUS         NtStatus;
    LPWSTR           lpwszServerName;   // Pointer to buffer for WIDE servername
    int              nSize;
    PNWC_SERVER_INFO pServerInfo = NULL;

    UNREFERENCED_PARAMETER(ScopeFlag) ;

    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return STATUS_INVALID_PARAMETER;

    *phNewConn = NULL ; 

    //
    // Allocate a buffer to store the file server name 
    //
    nSize = wcslen(pszServerName)+3 ;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        NtStatus = STATUS_NO_MEMORY;
        goto ExitPoint ;
    }
    wcscpy( lpwszServerName, L"\\\\" );
    wcscat( lpwszServerName, pszServerName );

    //
    // Allocate a buffer for the server info (handle + name pointer). Also
    // init the unicode string.
    //
    if( !(pServerInfo = (PNWC_SERVER_INFO) LocalAlloc( 
                                              LPTR, 
                                              sizeof(NWC_SERVER_INFO))) ) 
    {
        NtStatus = STATUS_NO_MEMORY;
        goto ExitPoint ;
    }
    RtlInitUnicodeString(&pServerInfo->ServerString, lpwszServerName) ;

    //
    // Call createfile to get a handle for the redirector calls
    //
    NtStatus = NwAttachToServer( lpwszServerName, &pServerInfo->hConn );

ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if ( !NT_SUCCESS( NtStatus))
    {
        if (lpwszServerName)
            (void) LocalFree( (HLOCAL) lpwszServerName );
        if (pServerInfo)
            (void) LocalFree( (HLOCAL) pServerInfo );
    }
    else
        *phNewConn  = (HANDLE) pServerInfo ;

    return( NtStatus );
}


NTSTATUS
NWPDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    (void) NwDetachFromServer( pServerInfo->hConn );

    (void) LocalFree (pServerInfo->ServerString.Buffer) ;

    //
    // catch any body that still trirs to use this puppy...
    //
    pServerInfo->ServerString.Buffer = NULL ;   
    pServerInfo->hConn = NULL ;

    (void) LocalFree (pServerInfo) ;

    return STATUS_SUCCESS;
}


NTSTATUS
NWPGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );
    return NtStatus;
}

NTSTATUS
NWPGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType )
{
    NWOBJ_ID           dwRetID;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    7,                      // Max request packet size
                    56,                     // Max response packet size
                    "br|rrr",               // Format string
                    // === REQUEST ================================
                    0x36,                   // b Get Bindery Object Name
                    &dwObjectID,DW_SIZE,    // r Object ID    HI-LO
                    // === REPLY ==================================
                    &dwRetID,DW_SIZE,       // r Object ID HI-LO
                    pwObjType,W_SIZE,       // r Object Type
                    pszObjName,48           // r Object Name
                    );

    return NtStatus;
}

DWORD
NWPLoginToFileServerW(
    NWCONN_HANDLE  hConn,
    LPWSTR         pszUserNameW,
    NWOBJ_TYPE     wObjType,
    LPWSTR         pszPasswordW
    )
{
    NETRESOURCEW       NetResource;
    DWORD              dwRes;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // validate parameters
    //
    if (!hConn || !pszUserNameW || !pszPasswordW)
        return ERROR_INVALID_PARAMETER;

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = (LPWSTR) pServerInfo->ServerString.Buffer;
    NetResource.lpComment    = NULL;
    NetResource.lpProvider   = NULL ;

    //
    // make the connection 
    //
    dwRes=NPAddConnection ( &NetResource, 
                            pszPasswordW, 
                            pszUserNameW );

    if( NO_ERROR != dwRes ) 
        dwRes = GetLastError();

    return( dwRes );
}


DWORD
NWPLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    DWORD              dwRes;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // now cancel the any connection to \\servername.
    //
    dwRes = NPCancelConnection( pServerInfo->ServerString.Buffer, TRUE );

    if ( NO_ERROR != dwRes ) 
        dwRes = GetLastError();

    return dwRes;
}


NTSTATUS
NWPReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    70,                     // Max request packet size
                    132,                    // Max response packet size
                    "brpbp|rbb",            // Format string
                    // === REQUEST ================================
                    0x3D,                   // b Read Property Value
                    &wObjType,W_SIZE,       // r Object Type    HI-LO
                    pszObjName,             // p Object Name
                    ucSegment,              // b Segment Number
                    pszPropName,            // p Property Name
                    // === REPLY ==================================
                    pValue,128,             // r Property value
                    pucMoreFlag,            // b More Flag
                    pucPropFlag             // b Prop Flag
                    );

    return NtStatus;
}

NTSTATUS
NWPScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    57,                     // Max request packet size
                    59,                     // Max response packet size
                    "brrp|rrrbbb",          // Format string
                    // === REQUEST ================================
                    0x37,                   // b Scan bindery object
                    pdwObjectID,DW_SIZE,    // r 0xffffffff to start or last returned ID when enumerating  HI-LO
                    &wObjSearchType,W_SIZE, // r Use OT_??? Defines HI-LO
                    pszSearchName,          // p Search Name. (use "*") for all
                    // === REPLY ==================================
                    pdwObjectID,DW_SIZE,    // r Returned ID    HI-LO
                    pwObjType,W_SIZE,       // r rObject Type    HI-LO
                    pszObjectName,48,       // r Found Name
                    pucObjectFlags,         // b Object Flag
                    pucObjSecurity,         // b Object Security
                    pucHasProperties        // b Has Properties
                    );

    return NtStatus;
}

NTSTATUS
NWPScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    26,                     // Max response packet size
                    "brprp|rbbrbb",         // Format string
                    // === REQUEST ================================
                    0x3C,                   // b Scan Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pszSearchName,          // p Property Name to Search for
                    // === REPLY ==================================
                    pszPropName,16,         // r Returned Property Name
                    pucPropFlags,           // b Property Flags
                    pucPropSecurity,        // b Property Security
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pucHasValue,            // b Property Has value
                    pucMore                 // b More Properties
                    );

    return NtStatus;
}

NTSTATUS
NWPDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    54,                     // Max request packet size
                    2,                      // Max response packet size
                    "brp|",                 // Format string
                    // === REQUEST ================================
                    0x33,                   // b Scan Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName           // p Object Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    56,                     // Max request packet size
                    2,                      // Max response packet size
                    "bbbrp|",               // Format string
                    // === REQUEST ================================
                    0x32,                   // b Scan Prop function
                    ucObjectFlags,          // b Object flags
                    ucObjSecurity,          // b Object security
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName           // p Object Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    2,                      // Max response packet size
                    "brpbbp|",              // Format string
                    // === REQUEST ================================
                    0x39,                   // b Create Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    ucObjectFlags,          // b Object flags
                    ucObjSecurity,          // b Object security
                    pszPropertyName         // p Property Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}


NTSTATUS
NWPDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    2,                      // Max response packet size
                    "brpp|",                // Format string
                    // === REQUEST ================================
                    0x3A,                   // b Delete Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszPropertyName         // p Property Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}


NTSTATUS
NWPWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    201,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpbbpr|",             // Format string
                    // === REQUEST ================================
                    0x3E,                   // b Write Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    segmentNumber,          // b Segment Number
                    moreSegments,           // b Segment remaining
                    pszPropertyName,        // p Property Name
                    segmentData, 128        // r Property Value Data
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPChangeObjectPasswordEncrypted(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    BYTE                    *validationKey,
    BYTE                    *newKeyedPassword
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    strlen( pszObjectName) + 32, // Max request packet size
                    2,                      // Max response packet size
                    "brrpr|",               // Format string
                    // === REQUEST ================================
                    0x4B,                   // b Write Prop function
                    validationKey, 8,       // r Key
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    newKeyedPassword, 17    // r New Keyed Password
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    54,                     // Max request packet size
                    56,                     // Max response packet size
                    "brp|d",                // Format string
                    // === REQUEST ================================
                    0x35,                   // b Get Obj ID
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    // === REPLY ==================================
                    objectID                // d Object ID
                    );

    *objectID = dwSWAP( *objectID );

    return NtStatus;
}


NTSTATUS
NWPRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType 
    )
{
    NTSTATUS     NtStatus;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    105,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpp",                 // Format string
                    // === REQUEST ================================
                    0x34,                   // b Rename bindery object
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszNewObjectName        // p New Object Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS 
NWPAddObjectToSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    122,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpprp|",              // Format string
                    // === REQUEST ================================
                    0x41,                   // b Add obj to set
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszPropertyName,        // p Property Name
                    &memberType, W_SIZE,    // r Member type
                    pszMemberName           // p Member Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}


NTSTATUS 
NWPDeleteObjectFromSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    122,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpprp|",              // Format string
                    // === REQUEST ================================
                    0x42,                   // b Del object from set
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszPropertyName,        // p Property Name
                    &memberType, W_SIZE,    // r Member type
                    pszMemberName           // p Member Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS 
NWPGetChallengeKey(
    NWCONN_HANDLE           hConn,
    UCHAR                   *challengeKey
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    10,                     // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x17,                   // b Get Challenge
                    // === REPLY ==================================
                    challengeKey, 8
                    );

    return NtStatus;
}

NTSTATUS 
NWPCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask 
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    261,                    // Max request packet size
                    2,                      // Max response packet size
                    "bbbp|",                // Format string
                    // === REQUEST ================================
                    0xA,                    // b Create Directory
                    dirHandle,              // b Directory Handle
                    accessMask,             // b Access Mask
                    pszPath                 // p Property Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Directory function
                    266,                    // Max request packet size
                    2,                      // Max response packet size
                    "bbrrp|",               // Format string
                    // === REQUEST ================================
                    0x27,                   // b Add trustee to directory
                    dirHandle,              // b Directory handle
                    &dwTrusteeID,DW_SIZE,   // r Object ID to assigned to directory
                    &rightsMask,W_SIZE,     // r User rights for directory
                    pszPath                 // p Directory (if dirHandle = 0 then vol:directory)
                    );

    return NtStatus;

}


NTSTATUS
NWPScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *ti
    )
{
    ULONG i;
    DWORD oid[20];
    WORD or[20];
    NTSTATUS NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    261,                    // Max request packet size
                    121,                    // Max response packet size
                    "bbbp|brr",             // Format string
                    // === REQUEST ================================
                    0x26,                   // b Scan For Trustees
                    dirHandle,              // b Directory Handle
                    *pucsequenceNumber,     // b Sequence Number
                    pszsearchDirPath,       // p Search Dir Path
                    // === REPLY ==================================
                    numberOfEntries,
                    &oid[0],DW_SIZE*20,      // r trustee object ID
                    &or[0], W_SIZE*20        // b Trustee rights mask 
                    );


    for(i = 0; i < 20; i++) {
      ti[i].objectID = oid[i];
      ti[i].objectRights = or[i];
    }

    (*pucsequenceNumber)++;
    
    return NtStatus ;

} // NWScanForTrustees


NTSTATUS
NWPScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *ti
    )
{
    ULONG i;
    DWORD oid[5];
    BYTE or[5];
    NTSTATUS NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    memset(oid, 0, sizeof(oid));
    memset(or, 0, sizeof(or));

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    261,                    // Max request packet size
                    49,                     // Max response packet size
                    "bbbp|rrrrr",  // Format string
                    // === REQUEST ================================
                    0x0C,                   // b Scan Directory function
                    dirHandle,              // b Directory Handle
                    *pucsequenceNumber,     // b Sequence Number
                    pszsearchDirPath,       // p Search Dir Path
                    // === REPLY ==================================
                    pszdirName,16,          // r Returned Directory Name
                    dirDateTime,DW_SIZE,    // r Date and Time
                    ownerID,DW_SIZE,        // r Owner ID
                    &oid[0],DW_SIZE*5,      // r trustee object ID
                    &or[0], 5               // b Trustee rights mask 
                    );


    for(i = 0; i < 5; i++) {
      ti[i].objectID = oid[i];
      ti[i].objectRights = (WORD) or[i];
    }

    (*pucsequenceNumber)++;
    
    return NtStatus ;

} // NWScanDirectoryForTrustees2


NTSTATUS
NWPGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    7,                      // Max response packet size
                    "b|br",                 // Format string
                    // === REQUEST ================================
                    0x46,                   // b Get Bindery Access Level
                    // === REPLY ==================================
                    accessLevel,
                    objectID,DW_SIZE
                    );


    
    return NtStatus ;

} // NWGetBinderyAccessLevel

NTSTATUS
NWPGetFileServerDescription(
    NWCONN_HANDLE         hConn,
    char                  *pszCompany,
    char                  *pszVersion,
    char                  *pszRevision
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    514,                    // Max response packet size
                    "b|ccc",                // Format string
                    // === REQUEST ================================
                    0xC9,                   // b Get File Server Information
                    // === REPLY ==================================
                    pszCompany,             // c Company
                    pszVersion,             // c Version
                    pszRevision             // c Description
                    );

    return NtStatus;
}

NTSTATUS
NWPGetVolumeNumber(
    NWCONN_HANDLE         hConn,
    char                  *pszVolume,
    NWVOL_NUM             *VolumeNumber
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    20,                     // Max request packet size
                    3,                      // Max response packet size
                    "bp|b",                  // Format string
                    // === REQUEST ================================
                    0x05,                   // b Get Volume Number
                    pszVolume,              // p volume name
                    // === REPLY ==================================
                    VolumeNumber            // b Description
                    );

    return NtStatus;
}

NTSTATUS
NWPGetVolumeUsage(
    NWCONN_HANDLE         hConn,
    NWVOL_NUM             VolumeNumber,
    DWORD                 *TotalBlocks,
    DWORD                 *FreeBlocks,
    DWORD                 *PurgeableBlocks,
    DWORD                 *NotYetPurgeableBlocks,
    DWORD                 *TotalDirectoryEntries,
    DWORD                 *AvailableDirectoryEntries,
    BYTE                  *SectorsPerBlock
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    4,                      // Max request packet size
                    46,                     // Max response packet size
                    "bb|dddddd==b",                 // Format string
                    // === REQUEST ================================
                    0x2C,                   // b Get Volume Number
                    VolumeNumber,           // p volume number
                    // === REPLY ==================================
                    TotalBlocks,
                    FreeBlocks,
                    PurgeableBlocks,
                    NotYetPurgeableBlocks,
                    TotalDirectoryEntries,
                    AvailableDirectoryEntries,
                    SectorsPerBlock
                    );

    *TotalBlocks = dwSWAP( *TotalBlocks );
    *FreeBlocks  = dwSWAP( *FreeBlocks );
    *PurgeableBlocks = dwSWAP( *PurgeableBlocks );
    *NotYetPurgeableBlocks = dwSWAP( *NotYetPurgeableBlocks );
    *TotalDirectoryEntries = dwSWAP( *TotalDirectoryEntries );
    *AvailableDirectoryEntries = dwSWAP( *AvailableDirectoryEntries );

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\packstr.c ===
/*++

Copyright (c) 1992, 1993  Microsoft Corporation

Module Name:

    packstr.c

Abstract:

    Contains functions for packing strings into buffers that also contain
    structures.

Author:

    From LAN Manager netlib.
    Rita Wong     (ritaw)     2-Mar-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <procs.h>


BOOL
NwlibCopyStringToBuffer(
    IN LPCWSTR SourceString OPTIONAL,
    IN DWORD   CharacterCount,
    IN LPCWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    SourceString - Supplies a pointer to the source string to copy into the
        output buffer.  If SourceString is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of SourceString, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD CharsNeeded = (CharacterCount + 1);


    //
    // Determine if source string will fit, allowing for a zero terminator.
    // If not, just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && SourceString != NULL) {

            (VOID) wcsncpy(*EndOfVariableData, SourceString, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = L'\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\nds32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32.c

Abstract:

    This module implements functions to Read, Add, Modify, and Remove
    NDS Objects and Attributes using the Microsoft Netware redirector.

Author:

    Glenn Curtis    [GlennC]    04-Jan-1996 - New NDS function implementations
    Glenn Curtis    [GlennC]    24-Apr-1996 - Added schema APIs
    Glenn Curtis    [GlennC]    20-Jun-1996 - Added search API
    Felix Wong      [t-felixw]  24-Sep-1995 - Added Win95 Support
    Glenn Curtis    [GlennC]    20-Nov-1996 - Improved search API
    Glenn Curtis    [GlennC]    02-Jan-1997 - Added rename object API
    Tommy Evans     [tommye]    21-Apr-2000 - Moved the NDS_OBJECT typedef out and
                                                renamed to NDS_OBJECT_PRIV.

--*/

#include <procs.h>
#include <nds32.h>
#include <align.h>
#include <nwapi32.h>
#include <nwpkstr.h>

#ifdef WIN95
#include <msnwapi.h>
#include <utils95.h>
#include <ndsapi95.h>
#endif

/* Definitions */

#define NDS_SIGNATURE                            0x6E656C67 /* glen */
#define ONE_KB                                   1024
#define TWO_KB                                   (ONE_KB*2)
#define FOUR_KB                                  (ONE_KB*4)
#define EIGHT_KB                                 (ONE_KB*8)
#define SIXTEEN_KB                               (ONE_KB*16)
#define THIRY_TWO_KB                             (ONE_KB*32)
#define SIXTY_FOUR_KB                            (ONE_KB*64)
#define ONE_TWENTY_EIGHT_KB                      (ONE_KB*128)
#define NDS_MAX_BUFFER                           (ONE_KB*63)

#define NDS_SEARCH_ENTRY                         0
#define NDS_SEARCH_SUBORDINATES                  1
#define NDS_SEARCH_SUBTREE                       2

#define NDS_DEREF_ALIASES                        0x00000000
#define NDS_DONT_DEREF_ALIASES                   0x00010000

/* NetWare NDS NCP function identifiers */

#define NETWARE_NDS_FUNCTION_RESOLVE_NAME         0x00000001
#define NETWARE_NDS_FUNCTION_READ_OBJECT          0x00000003
#define NETWARE_NDS_FUNCTION_LIST                 0x00000005
#define NETWARE_NDS_FUNCTION_SEARCH               0x00000006
#define NETWARE_NDS_FUNCTION_ADD_OBJECT           0x00000007
#define NETWARE_NDS_FUNCTION_REMOVE_OBJECT        0x00000008
#define NETWARE_NDS_FUNCTION_MODIFY_OBJECT        0x00000009
#define NETWARE_NDS_FUNCTION_MODIFY_RDN           0x0000000A
#define NETWARE_NDS_FUNCTION_DEFINE_ATTR          0x0000000B
#define NETWARE_NDS_FUNCTION_READ_ATTR_DEF        0x0000000C
#define NETWARE_NDS_FUNCTION_REMOVE_ATTR_DEF      0x0000000D
#define NETWARE_NDS_FUNCTION_DEFINE_CLASS         0x0000000E
#define NETWARE_NDS_FUNCTION_READ_CLASS_DEF       0x0000000F
#define NETWARE_NDS_FUNCTION_MODIFY_CLASS         0x00000010
#define NETWARE_NDS_FUNCTION_REMOVE_CLASS_DEF     0x00000011
#define NETWARE_NDS_FUNCTION_LIST_CONT_CLASSES    0x00000012
#define NETWARE_NDS_FUNCTION_GET_EFFECTIVE_RIGHTS 0x00000013
#define NETWARE_NDS_FUNCTION_BEGIN_MOVE_OBJECT    0x0000002A
#define NETWARE_NDS_FUNCTION_FINISH_MOVE_OBJECT   0x0000002B
#define NETWARE_NDS_FUNCTION_GET_SERVER_ADDRESS   0x00000035


/* Data structure definitions */

typedef struct
{
    DWORD  dwBufferId;
    DWORD  dwOperation;

    //
    // About the request buffer
    //
    DWORD  dwRequestBufferSize;
    DWORD  dwRequestAvailableBytes;
    DWORD  dwNumberOfRequestEntries;
    DWORD  dwLengthOfRequestData;

    //
    // The request buffer
    //
    LPBYTE lpRequestBuffer;

    //
    // About the reply buffer
    //
    DWORD  dwReplyBufferSize;
    DWORD  dwReplyAvailableBytes;
    DWORD  dwNumberOfReplyEntries;
    DWORD  dwLengthOfReplyData;

    //
    // More about the reply buffer
    //
    DWORD  dwReplyInformationType;

    //
    // The reply buffer
    //
    LPBYTE lpReplyBuffer;

    //
    // About the index buffer
    //
    DWORD  dwIndexBufferSize;
    DWORD  dwIndexAvailableBytes;
    DWORD  dwNumberOfIndexEntries;
    DWORD  dwLengthOfIndexData;

    //
    // More about the index buffer
    //
    DWORD  dwCurrentIndexEntry;

    //
    // The index buffer
    //
    LPBYTE lpIndexBuffer;

    //
    // About the syntax buffer
    //
    DWORD  dwSyntaxBufferSize;
    DWORD  dwSyntaxAvailableBytes;
    DWORD  dwNumberOfSyntaxEntries;
    DWORD  dwLengthOfSyntaxData;

    //
    // The syntax buffer
    //
    LPBYTE lpSyntaxBuffer;

    //
    // A place to keep the search from object path ...
    //
    WCHAR szPath[NDS_MAX_NAME_CHARS + 4];

} NDS_BUFFER, * LPNDS_BUFFER;


/* Local Function Definitions */

VOID
PrepareAddEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes );

VOID
PrepareModifyEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    DWORD          dwAttrModificationOperation,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes );

VOID
PrepareReadEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    LPDWORD        lpdwLengthInBytes );

DWORD
CalculateValueDataSize(
    DWORD           dwSyntaxId,
    LPBYTE          lpAttributeValues,
    DWORD           dwValueCount );

VOID
AppendValueToEntry(
    LPBYTE  lpBuffer,
    DWORD   dwSyntaxId,
    LPBYTE  lpAttributeValues,
    DWORD   dwValueCount,
    LPDWORD lpdwLengthInBytes );

DWORD
MapNetwareErrorCode(
    DWORD dwNetwareError );

DWORD
IndexReadAttrDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexReadClassDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexReadObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexReadNameReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexSearchObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
SizeOfASN1Structure(
    LPBYTE * lppRawBuffer,
    DWORD    dwSyntaxId );

DWORD
ParseASN1ValueBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwSyntaxId,
    DWORD  dwNumberOfValues,
    LPBYTE SyntaxStructure );

DWORD
ParseStringListBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwNumberOfStrings,
    LPBYTE SyntaxStructure );

DWORD
ReadAttrDef_AllAttrs(
    IN  HANDLE hTree,
    IN  DWORD  dwInformationType,
    OUT HANDLE lphOperationData );

DWORD
ReadAttrDef_SomeAttrs(
    IN     HANDLE hTree,
    IN     DWORD  dwInformationType,
    IN OUT HANDLE lphOperationData );

DWORD
ReadClassDef_AllClasses(
    IN  HANDLE hTree,
    IN  DWORD  dwInformationType,
    OUT HANDLE lphOperationData );

DWORD
ReadClassDef_SomeClasses(
    IN     HANDLE hTree,
    IN     DWORD  dwInformationType,
    IN OUT HANDLE lphOperationData );

DWORD
ReadObject_AllAttrs(
    IN  HANDLE   hObject,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData );

DWORD
ReadObject_SomeAttrs(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData );

DWORD
Search_AllAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    OUT    HANDLE *     lphOperationData );

DWORD
Search_SomeAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData );

DWORD
GetFirstNdsSubTreeEntry(
    OUT LPNDS_OBJECT_PRIV lpNdsObject,
    IN  DWORD BufferSize );

DWORD
GetNextNdsSubTreeEntry(
    OUT LPNDS_OBJECT_PRIV lpNdsObject );

VOID
GetSubTreeData(
    IN  DWORD    NdsRawDataPtr,
    OUT LPDWORD  lpdwEntryId,
    OUT LPDWORD  lpdwSubordinateCount,
    OUT LPDWORD  lpdwModificationTime,
    OUT LPDWORD  lpdwClassNameLen,
    OUT LPWSTR * szClassName,
    OUT LPDWORD  lpdwObjectNameLen,
    OUT LPWSTR * szObjectName );

LPBYTE
GetSearchResultData( IN  LPBYTE   lpResultBufferPtr,
                     OUT LPDWORD  lpdwFlags,
                     OUT LPDWORD  lpdwSubordinateCount,
                     OUT LPDWORD  lpdwModificationTime,
                     OUT LPDWORD  lpdwClassNameLen,
                     OUT LPWSTR * szClassName,
                     OUT LPDWORD  lpdwObjectNameLen,
                     OUT LPWSTR * szObjectName,
                     OUT LPDWORD  lpdwEntryInfo1,
                     OUT LPDWORD  lpdwEntryInfo2 );

DWORD
WriteObjectToBuffer(
    IN OUT LPBYTE *        FixedPortion,
    IN OUT LPWSTR *        EndOfVariableData,
    IN     LPWSTR          ObjectFullName,
    IN     LPWSTR          ObjectName,
    IN     LPWSTR          ClassName,
    IN     DWORD           EntryId,
    IN     DWORD           ModificationTime,
    IN     DWORD           SubordinateCount,
    IN     DWORD           NumberOfAttributes,
    IN     LPNDS_ATTR_INFO lpAttributeInfos );

DWORD
VerifyBufferSize(
    IN  LPBYTE  lpRawBuffer,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwSyntaxID,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength );

DWORD
VerifyBufferSizeForStringList(
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength );

DWORD
WriteQueryTreeToBuffer(
    IN  LPQUERY_TREE lpQueryTree,
    IN  LPNDS_BUFFER lpNdsBuffer );

DWORD
WriteQueryNodeToBuffer(
    IN  LPQUERY_NODE lpQueryNode,
    IN  LPNDS_BUFFER lpNdsBuffer );

DWORD
NwNdsGetServerDN(
    IN  HANDLE  hTree,
    OUT LPWSTR  szServerDN );

DWORD
AllocateOrIncreaseSyntaxBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer ,
    IN  DWORD        dwLengthNeeded );

DWORD
AllocateOrIncreaseRequestBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer );


//
// Flags used for the function ParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2


WORD
ParseNdsUncPath( IN OUT LPWSTR * Result,
                 IN     LPWSTR   ObjectPathName,
                 IN     DWORD    flag );


/* Function Implementations */

DWORD
NwNdsAddObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  HANDLE hOperationData )
/*
   NwNdsAddObject()

   This function is used to add a leaf object to an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object in
                        the directory tree to add a new leaf to. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name that the new leaf
                        object will be known by.

       HANDLE           hOperationData - A buffer containing a list of
                        attributes and values to create the new object. This
                        buffer is manipulated by the following functions:
                            NwNdsCreateBuffer (NDS_OBJECT_ADD),
                            NwNdsPutInBuffer, and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    NTSTATUS       ntstatus;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_BUFFER   lpNdsBuffer = (LPNDS_BUFFER) hOperationData;
    LPNDS_OBJECT_PRIV   lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    UNICODE_STRING ObjectName;

    if ( lpNdsBuffer == NULL ||
         lpNdsParentObject == NULL ||
         szObjectName == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_OBJECT_ADD ||
         lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ObjectName, szObjectName );

    ntstatus =
        FragExWithWait(
                     lpNdsParentObject->NdsTree,
                     NETWARE_NDS_FUNCTION_ADD_OBJECT,
                     NdsReply,
                     NDS_BUFFER_SIZE,
                     &dwReplyLength,
                     "DDDSDr",
                     0,                   // Version
                     0,                   // Flags
                     lpNdsParentObject->ObjectId,
                     &ObjectName,
                     lpNdsBuffer->dwNumberOfRequestEntries,
                     lpNdsBuffer->lpRequestBuffer, // Object attributes to be added
                     (WORD)lpNdsBuffer->dwLengthOfRequestData // Length of data
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddObject: The add name response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsAddAttributeToClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  LPWSTR   szAttributeName )
/*
   NwNdsAddAttributeToClass()

   This function is used to modify the schema definition of a class by adding
   an optional attribute to a particular class. Modification of existing NDS
   class defintions is limited to only adding additional optional attributes.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class definition to be
                        modified.

       LPWSTR           szAttributeName - The name of the attribute to be added
                        as an optional attribute to the class defintion in the
                        schema.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING ClassName;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         szClassName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ClassName, szClassName );
    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_MODIFY_CLASS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DSDS",
                        0,          // Version
                        &ClassName,
                        1,          // Number of attributes
                        &AttributeName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddAttributeToClass: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddAttributeToClass: The modify class definition response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsChangeUserPassword(
    IN  HANDLE hUserObject,
    IN  LPWSTR szOldPassword,
    IN  LPWSTR szNewPassword )
/*
   NwNdsChangeUserPassword()

   This function is used to change the password for a given user object
   in a NDS directory tree.

   Arguments:

       HANDLE           hUserObject - A handle to a specific user object in
                        the directory tree to change the password on. Handle
                        is obtained by calling NwNdsOpenObject.

       LPWSTR           szOldPassword - The current password set on the user
                        object hUserObject.

                          - OR -

                        If NwNdsChangeUserPassword is called from a client with
                        administrative priveleges to the specified user object
                        identified by hUserObject, then the szOldPassword
                        value can be blank (L""). This way resetting the user
                        password to szNewPassword.

       LPWSTR           szNewPassword - The new password to be set on the user
                        object hUserObject.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
    UNICODE_STRING TreeNameStr;
    UNICODE_STRING UserNameStr;
    UNICODE_STRING OldPasswordStr;
    UNICODE_STRING NewPasswordStr;
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hUserObject;
    DWORD          tempStrLen = 0;
    LPWSTR         tempStr = NULL;

    tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                  lpNdsObject->szContainerName,
                                  PARSE_NDS_GET_TREE_NAME );

    TreeNameStr.Buffer = tempStr;
    TreeNameStr.Length = (WORD) tempStrLen;
    TreeNameStr.MaximumLength = (WORD) tempStrLen;

    tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                  lpNdsObject->szContainerName,
                                  PARSE_NDS_GET_PATH_NAME );

#ifndef WIN95
    UserNameStr.Buffer = tempStr;
    UserNameStr.Length = (WORD) tempStrLen;
    UserNameStr.MaximumLength = (WORD) tempStrLen;

    RtlInitUnicodeString( &OldPasswordStr, szOldPassword );
    RtlInitUnicodeString( &NewPasswordStr, szNewPassword );

    ntstatus = NwNdsChangePassword( lpNdsObject->NdsTree,
                                    &TreeNameStr,
                                    &UserNameStr,
                                    &OldPasswordStr,
                                    &NewPasswordStr );
#else
    {
        LPSTR pszUser = NULL;
        LPSTR pszOldPasswd = NULL;
        LPSTR pszNewPasswd = NULL;
        NW_STATUS nwstatus;
        if (!(pszUser = AllocateAnsiString(tempStr))) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }
        if (!(pszOldPasswd = AllocateAnsiString(szOldPassword))) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }
        if (!(pszNewPasswd= AllocateAnsiString(szNewPassword))) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        nwstatus = NDSChangePassword( pszUser,
                                      pszOldPasswd,
                                      pszNewPasswd );
        ntstatus = MapNwToNtStatus(nwstatus);
    Exit:
        if (pszUser)
            FreeAnsiString(pszUser);
        if (pszOldPasswd)
            FreeAnsiString(pszOldPasswd);
        if (pszNewPasswd)
            FreeAnsiString(pszNewPasswd);
    }
#endif

    if ( ntstatus != STATUS_SUCCESS )
    {
        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
    }

    return status;
}


DWORD
NwNdsCloseObject(
    IN  HANDLE hObject )
/*
   NwNdsCloseObject()

   This function is used to close the handle used to manipulate an object
   in an NDS directory tree. The handle must be one Opened by NwNdsOpenObject.

   Arguments:

       HANDLE           lphObject - The handle of the object to be closed.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;

    if ( lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsObject )
    {
        if ( lpNdsObject->NdsTree )
            CloseHandle( lpNdsObject->NdsTree );

        if ( lpNdsObject->NdsRawDataBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
            lpNdsObject->NdsRawDataBuffer = 0;
            lpNdsObject->NdsRawDataSize = 0;
            lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsObject->NdsRawDataCount = 0;
        }

        (void) LocalFree( (HLOCAL) lpNdsObject );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
NwNdsCreateBuffer(
    IN  DWORD    dwOperation,
    OUT HANDLE * lphOperationData )
/*
   NwNdsCreateBuffer()

   This function is used to create a buffer used to describe object
   transactions to a specific object in an NDS directory tree. This routine
   allocates memory and is automatically resized as needed during calls
   to NwNdsPutInBuffer. This buffer must be freed with NwNdsFreeBuffer.

   Arguments:

       DWORD            dwOperation - Indicates how buffer is to be utilized.
                        Use defined values NDS_OBJECT_ADD, NDS_OBJECT_MODIFY,
                        NDS_OBJECT_READ, NDS_SCHEMA_DEFINE_CLASS,
                        NDS_SCHEMA_READ_ATTR_DEF, NDS_SCHEMA_READ_CLASS_DEF,
                        NDS_OBJECT_LIST_SUBORDINATES, NDS_SEARCH.

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwSizeOfBuffer = TWO_KB; // Initial size, grow as needed.

    switch( dwOperation )
    {
        case NDS_OBJECT_ADD:
        case NDS_OBJECT_MODIFY:
        case NDS_OBJECT_READ:
        case NDS_SCHEMA_DEFINE_CLASS:
        case NDS_SCHEMA_READ_ATTR_DEF:
        case NDS_SCHEMA_READ_CLASS_DEF:
        case NDS_OBJECT_LIST_SUBORDINATES:
        case NDS_SEARCH:
             break;

        default:
#if DBG
             KdPrint(( "NDS32: NwNdsCreateBuffer parameter dwOperation unknown 0x%.8X\n", dwOperation ));
             ASSERT( FALSE );
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    //
    // Allocate memory for the buffer.
    //
    lpNdsBuffer =
              (LPNDS_BUFFER) LocalAlloc( LPTR, sizeof(NDS_BUFFER) );

    if ( lpNdsBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsCreateBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Initialize the contents of the header structure.
    //
    lpNdsBuffer->dwBufferId = NDS_SIGNATURE;
    lpNdsBuffer->dwOperation = dwOperation;

    if ( dwOperation == NDS_OBJECT_LIST_SUBORDINATES )
    {
        lpNdsBuffer->dwIndexBufferSize = dwSizeOfBuffer;
        lpNdsBuffer->dwIndexAvailableBytes = dwSizeOfBuffer;
    }
    else
    {
        lpNdsBuffer->dwRequestBufferSize = dwSizeOfBuffer;
        lpNdsBuffer->dwRequestAvailableBytes = dwSizeOfBuffer;
    }

    //
    // NOTE: The following are set to zero by LPTR
    //
    // lpNdsBuffer->dwNumberOfRequestEntries = 0;
    // lpNdsBuffer->dwLengthOfRequestData = 0;

    // lpNdsBuffer->dwReplyBufferSize = 0;
    // lpNdsBuffer->dwReplyAvailableBytes = 0;
    // lpNdsBuffer->dwNumberOfReplyEntries = 0;
    // lpNdsBuffer->dwLengthOfReplyData = 0;

    // lpNdsBuffer->dwReplyInformationType = 0;

    // lpNdsBuffer->lpReplyBuffer = NULL;

    // lpNdsBuffer->dwNumberOfIndexEntries = 0;
    // lpNdsBuffer->dwLengthOfIndexData = 0;
    // lpNdsBuffer->dwCurrentIndexEntry = 0;

    // lpNdsBuffer->dwSyntaxBufferSize = 0;
    // lpNdsBuffer->dwSyntaxAvailableBytes = 0;
    // lpNdsBuffer->dwNumberOfSyntaxEntries = 0;
    // lpNdsBuffer->dwLengthOfSyntaxData = 0;

    // lpNdsBuffer->lpSyntaxBuffer = NULL;

    //
    // Now allocate the data buffer.
    //
    if ( dwOperation == NDS_OBJECT_LIST_SUBORDINATES )
    {
        lpNdsBuffer->lpIndexBuffer =
                            (LPBYTE) LocalAlloc( LPTR, dwSizeOfBuffer );

        if ( lpNdsBuffer->lpIndexBuffer == NULL )
        {
#if DBG
            KdPrint(( "NDS32: NwNdsCreateBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            (void) LocalFree((HLOCAL) lpNdsBuffer);
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }
    }
    else
    {
        lpNdsBuffer->lpRequestBuffer =
                            (LPBYTE) LocalAlloc( LPTR, dwSizeOfBuffer );

        if ( lpNdsBuffer->lpRequestBuffer == NULL )
        {
#if DBG
            KdPrint(( "NDS32: NwNdsCreateBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            (void) LocalFree((HLOCAL) lpNdsBuffer);
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    *lphOperationData = (HANDLE) lpNdsBuffer;

    return NO_ERROR;
}


DWORD
NwNdsCreateQueryNode(
    IN  DWORD          dwOperation,
    IN  LPVOID         lpLValue,
    IN  DWORD          dwSyntaxId,
    IN  LPVOID         lpRValue,
    OUT LPQUERY_NODE * lppQueryNode
)
/*
   NwNdsCreateQueryNode()

   This function is used to generate a tree node that is part of a query
   to be used with the function NwNdsSearch.

   Arguments:

       DWORD            dwOperation - Indicates the type of node to create
                        for a search query. Use one of the defined values
                        below:

                          NDS_QUERY_OR
                          NDS_QUERY_AND :
                            These operations must have both lpLValue and
                            lpRValue pointing to a QUERY_NODE structure.
                            In this case the dwSyntaxId value is ignored.

                          NDS_QUERY_NOT :
                            This operation must have lpLValue pointing to a
                            QUERY_NODE structure and lpRValue set to NULL.
                            In this case the dwSyntaxId value is ignored.

                          NDS_QUERY_EQUAL
                          NDS_QUERY_GE
                          NDS_QUERY_LE
                          NDS_QUERY_APPROX :
                            These operations must have lpLValue pointing to
                            a LPWSTR containing the name of an NDS attribute,
                            and lpRValue pointing to an ASN1 structure defined
                            in NdsSntx.h. dwSyntaxId must be set to the syntax
                            identifier of the ASN1 structure pointed to by
                            lpRValue.

                          NDS_QUERY_PRESENT :
                            This operation must have lpLValue pointing to a
                            LPWSTR containing the name of an NDS attribute,
                            and lpRValue set to NULL. In this case the
                            dwSyntaxId value is ignored.

       LPVOID           lpLValue - A pointer to either a QUERY_NODE structure
                        or a LPWSTR depending on the value for dwOperation.

       DWORD            dwSyntaxId - The syntax identifier of the ASN1
                        structure pointed to by lpRValue for the dwOperations
                        NDS_QUERY_EQUAL, NDS_QUERY_GE, NDS_QUERY_LE, or
                        NDS_QUERY_APPROX. For other dwOperation values, this
                        is ignored.

       LPVOID           lpRValue - A pointer to either a QUERY_NODE structure,
                        an ASN1 structure, or NULL, depending on the value for
                        dwOperation.

       LPQUERY_NODE *   lppQueryNode - Address of a LPQUERY_NODE to receive
                        a pointer to created node.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPWSTR szAttributeName;
    DWORD  dwAttributeNameLen;
    LPWSTR szRValueString;
    DWORD  dwRValueStringLen;

    switch( dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpLValue == NULL || lpRValue == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            *lppQueryNode = (LPQUERY_NODE) LocalAlloc( LPTR,
                                                       sizeof(QUERY_NODE) );

            if ( *lppQueryNode == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }

            (*lppQueryNode)->dwOperation = dwOperation;
            (*lppQueryNode)->dwSyntaxId = NDS_NO_MORE_ITERATIONS;
            (*lppQueryNode)->lpLVal = lpLValue;
            (*lppQueryNode)->lpRVal = lpRValue;

            break;

        case NDS_QUERY_NOT :

            if ( lpLValue == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            *lppQueryNode = (LPQUERY_NODE) LocalAlloc( LPTR,
                                                       sizeof(QUERY_NODE) );

            if ( *lppQueryNode == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }

            (*lppQueryNode)->dwOperation = dwOperation;
            (*lppQueryNode)->dwSyntaxId = NDS_NO_MORE_ITERATIONS;
            (*lppQueryNode)->lpLVal = lpLValue;
            (*lppQueryNode)->lpRVal = NULL;

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :

            switch( dwSyntaxId )
            {
                case NDS_SYNTAX_ID_1 :
                case NDS_SYNTAX_ID_2 :
                case NDS_SYNTAX_ID_3 :
                case NDS_SYNTAX_ID_4 :
                case NDS_SYNTAX_ID_5 :
                case NDS_SYNTAX_ID_10 :
                case NDS_SYNTAX_ID_20 :
                    //
                    // This syntax is in the form of a LPWSTR.
                    //
                    szAttributeName = (LPWSTR) lpLValue;
                    dwAttributeNameLen = ROUND_UP_COUNT(
                                            ( wcslen( szAttributeName ) + 1 ) *
                                            sizeof(WCHAR),
                                            ALIGN_DWORD );
                    szRValueString = ((LPASN1_TYPE_1) lpRValue)->DNString;
                    dwRValueStringLen = ROUND_UP_COUNT(
                                           ( wcslen( szRValueString ) + 1 ) *
                                           sizeof(WCHAR),
                                           ALIGN_DWORD );

                    *lppQueryNode = (LPQUERY_NODE)
                     LocalAlloc( LPTR,
                                 sizeof(QUERY_NODE) +
                                 dwAttributeNameLen +
                                 dwRValueStringLen );

                    if ( *lppQueryNode == NULL )
                    {
#if DBG
                        KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        return (DWORD) UNSUCCESSFUL;
                    }

                    (*lppQueryNode)->dwOperation = dwOperation;
                    (*lppQueryNode)->dwSyntaxId = dwSyntaxId;
                    (*lppQueryNode)->lpLVal = *lppQueryNode;
                    (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal, szAttributeName );
                    (*lppQueryNode)->lpRVal = (*lppQueryNode)->lpLVal;
                    (LPBYTE) (*lppQueryNode)->lpRVal += dwAttributeNameLen;
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpRVal, szRValueString );

                    break;

                case NDS_SYNTAX_ID_7 :
                case NDS_SYNTAX_ID_8 :
                case NDS_SYNTAX_ID_22 :
                case NDS_SYNTAX_ID_24 :
                case NDS_SYNTAX_ID_27 :
                    //
                    // This syntax is in the form of a DWORD.
                    //

                    szAttributeName = (LPWSTR) lpLValue;
                    dwAttributeNameLen = ROUND_UP_COUNT(
                                            ( wcslen( szAttributeName ) + 1 ) *
                                            sizeof(WCHAR),
                                            ALIGN_DWORD );

                    *lppQueryNode = (LPQUERY_NODE)
                                              LocalAlloc( LPTR,
                                                          sizeof(QUERY_NODE) +
                                                          dwAttributeNameLen +
                                                          sizeof(ASN1_TYPE_8) );

                    if ( *lppQueryNode == NULL )
                    {
#if DBG
                        KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        return (DWORD) UNSUCCESSFUL;
                    }

                    (*lppQueryNode)->dwOperation = dwOperation;
                    (*lppQueryNode)->dwSyntaxId = dwSyntaxId;
                    (*lppQueryNode)->lpLVal = *lppQueryNode;
                    (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal,
                            szAttributeName );
                    (*lppQueryNode)->lpRVal = (LPQUERY_NODE)((LPBYTE)((*lppQueryNode)->lpLVal) +
                                              dwAttributeNameLen);
                    ((LPASN1_TYPE_8)(*lppQueryNode)->lpRVal)->Integer =
                                      ((LPASN1_TYPE_8)lpRValue)->Integer;

                    break;

                case NDS_SYNTAX_ID_9 :
                    //
                    // This syntax is in the form of an Octet String.
                    //
                    szAttributeName = (LPWSTR) lpLValue;
                    dwAttributeNameLen = ROUND_UP_COUNT(
                                            ( wcslen( szAttributeName ) + 1 ) *
                                            sizeof(WCHAR),
                                            ALIGN_DWORD );

                    *lppQueryNode = (LPQUERY_NODE)
                     LocalAlloc( LPTR,
                                 sizeof(QUERY_NODE) +
                                 dwAttributeNameLen +
                                 sizeof( DWORD ) +
                                 ((LPASN1_TYPE_9) lpRValue)->Length + 1 );

                    if ( *lppQueryNode == NULL )
                    {
#if DBG
                        KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        return (DWORD) UNSUCCESSFUL;
                    }

                    (*lppQueryNode)->dwOperation = dwOperation;
                    (*lppQueryNode)->dwSyntaxId = dwSyntaxId;
                    (*lppQueryNode)->lpLVal = *lppQueryNode;
                    (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal, szAttributeName );
                    (*lppQueryNode)->lpRVal = (*lppQueryNode)->lpLVal;
                    (LPBYTE) (*lppQueryNode)->lpRVal += dwAttributeNameLen;
                    *((LPDWORD) (*lppQueryNode)->lpRVal) =
                                            ((LPASN1_TYPE_9) lpRValue)->Length;
                    (LPBYTE) (*lppQueryNode)->lpRVal += sizeof( DWORD );
                    memcpy( (*lppQueryNode)->lpRVal,
                            ((LPASN1_TYPE_9) lpRValue)->OctetString,
                            ((LPASN1_TYPE_9) lpRValue)->Length );
                    (LPBYTE) (*lppQueryNode)->lpRVal -= sizeof( DWORD );

                    break;

                default :
                    SetLastError( ERROR_NOT_SUPPORTED );
                    return (DWORD) UNSUCCESSFUL;
            }

            break;

        case NDS_QUERY_PRESENT :

            if ( lpLValue == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            szAttributeName = (LPWSTR) lpLValue;
            dwAttributeNameLen = ( wcslen( szAttributeName ) + 1 ) *
                                 sizeof(WCHAR);

            *lppQueryNode = (LPQUERY_NODE) LocalAlloc( LPTR,
                                                       sizeof(QUERY_NODE) +
                                                       dwAttributeNameLen );

            if ( *lppQueryNode == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }

            (*lppQueryNode)->dwOperation = dwOperation;
            (*lppQueryNode)->dwSyntaxId = NDS_NO_MORE_ITERATIONS;
            (*lppQueryNode)->lpLVal = (*lppQueryNode);
            (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
            wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal, szAttributeName );
            (*lppQueryNode)->lpRVal = NULL;

            break;

        default :
#if DBG
            KdPrint(( "NDS32: NwNdsCreateQueryNode was passed an unidentified operation - 0x%.8X.\n", dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
NwNdsDefineAttribute(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName,
    IN  DWORD    dwFlags,
    IN  DWORD    dwSyntaxID,
    IN  DWORD    dwLowerLimit,
    IN  DWORD    dwUpperLimit,
    IN  ASN1_ID  asn1ID )
/*
   NwNdsDefineAttribute()

   This function is used to create an attribute definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name that the new attribute will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new attribute
                        definition. Definitions for flag values are found at
                        the top of the file Nds32.h.

       DWORD            dwSyntaxID - The ID of the syntax structure to be use
                        for the new attribute. Syntax IDs and their associated
                        structures are defined in the file NdsSntx.h. According
                        to the NetWare NDS schema spec, there is and always will
                        be, only 28 (0..27) different syntaxes.

       DWORD            dwLowerLimit - The lower limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       DWORD            dwUpperLimit - The upper limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       ASN1_ID          asn1ID - The ASN.1 ID for the attribute. If no
                        attribute identifier has been registered, a
                        zero-length octet string is specified.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_DEFINE_ATTR,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDSDDDD",
                        0,          // Version
                        dwFlags,
                        &AttributeName,
                        dwSyntaxID,
                        dwLowerLimit,
                        dwUpperLimit,
                        0           // ASN1 Id
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineAttribute: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineAttribute: The define attribute response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsDefineClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  DWORD    dwFlags,
    IN  ASN1_ID  asn1ID,
    IN  HANDLE   hSuperClasses,
    IN  HANDLE   hContainmentClasses,
    IN  HANDLE   hNamingAttributes,
    IN  HANDLE   hMandatoryAttributes,
    IN  HANDLE   hOptionalAttributes )
/*
   NwNdsDefineClass()

   This function is used to create a class definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name that the new class will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new class
                        definition. Definitions for flag values are found at
                        the top of the file Nds32.h.

       ASN1_ID          asn1ID - The ASN.1 ID for the class. If no
                        class identifier has been registered, a
                        zero-length octet string is specified.

       HANDLE(S)        hSuperClasses,
                        hContainmentClasses,
                        hNamingAttributes,
                        hMandatoryAttributes,
                        hOptionalAttributes -

                        Handle to buffers that contain class definition
                        information to create new class in schema.
                        These handles are manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_DEFINE_CLASS),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                - OR -

                        Handles can be NULL to indicate that no list
                        is associated with the specific class defintion
                        item.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING ClassName;
    LPNDS_BUFFER   lpSuperClasses = (LPNDS_BUFFER) hSuperClasses;
    LPNDS_BUFFER   lpContainmentClasses = (LPNDS_BUFFER) hContainmentClasses;
    LPNDS_BUFFER   lpNamingAttributes = (LPNDS_BUFFER) hNamingAttributes;
    LPNDS_BUFFER   lpMandatoryAttributes = (LPNDS_BUFFER) hMandatoryAttributes;
    LPNDS_BUFFER   lpOptionalAttributes = (LPNDS_BUFFER) hOptionalAttributes;

    DWORD          NumberOfSuperClasses = 0;
    DWORD          NumberOfContainmentClasses = 0;
    DWORD          NumberOfNamingAttributes = 0;
    DWORD          NumberOfMandatoryAttributes = 0;
    DWORD          NumberOfOptionalAttributes = 0;

    WORD           SuperClassesBufferLength = 0;
    WORD           ContainmentClassesBufferLength = 0;
    WORD           NamingAttributesBufferLength = 0;
    WORD           MandatoryAttributesBufferLength = 0;
    WORD           OptionalAttributesBufferLength = 0;

    LPBYTE         SuperClassesBuffer = NULL;
    LPBYTE         ContainmentClassesBuffer = NULL;
    LPBYTE         NamingAttributesBuffer = NULL;
    LPBYTE         MandatoryAttributesBuffer = NULL;
    LPBYTE         OptionalAttributesBuffer = NULL;

    if ( szClassName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpSuperClasses )
    {
        if ( lpSuperClasses->dwBufferId != NDS_SIGNATURE ||
             lpSuperClasses->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfSuperClasses = lpSuperClasses->dwNumberOfRequestEntries,
        SuperClassesBuffer = lpSuperClasses->lpRequestBuffer,
        SuperClassesBufferLength = (WORD)lpSuperClasses->dwLengthOfRequestData;
    }

    if ( lpContainmentClasses )
    {
        if ( lpContainmentClasses->dwBufferId != NDS_SIGNATURE ||
             lpContainmentClasses->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfContainmentClasses =
                lpContainmentClasses->dwNumberOfRequestEntries,
        ContainmentClassesBuffer =
                lpContainmentClasses->lpRequestBuffer,
        ContainmentClassesBufferLength =
                (WORD)lpContainmentClasses->dwLengthOfRequestData;
    }

    if ( lpNamingAttributes )
    {
        if ( lpNamingAttributes->dwBufferId != NDS_SIGNATURE ||
             lpNamingAttributes->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfNamingAttributes =
                lpNamingAttributes->dwNumberOfRequestEntries,
        NamingAttributesBuffer =
                lpNamingAttributes->lpRequestBuffer,
        NamingAttributesBufferLength =
                (WORD)lpNamingAttributes->dwLengthOfRequestData;
    }

    if ( lpMandatoryAttributes )
    {
        if ( lpMandatoryAttributes->dwBufferId != NDS_SIGNATURE ||
             lpMandatoryAttributes->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfMandatoryAttributes =
                lpMandatoryAttributes->dwNumberOfRequestEntries,
        MandatoryAttributesBuffer =
                lpMandatoryAttributes->lpRequestBuffer,
        MandatoryAttributesBufferLength =
                (WORD)lpMandatoryAttributes->dwLengthOfRequestData;
    }

    if ( lpOptionalAttributes )
    {
        if ( lpOptionalAttributes->dwBufferId != NDS_SIGNATURE ||
             lpOptionalAttributes->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfOptionalAttributes =
                lpOptionalAttributes->dwNumberOfRequestEntries,
        OptionalAttributesBuffer =
                lpOptionalAttributes->lpRequestBuffer,
        OptionalAttributesBufferLength =
                (WORD)lpOptionalAttributes->dwLengthOfRequestData;
    }

    RtlInitUnicodeString( &ClassName, szClassName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_DEFINE_CLASS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDSDDrDrDrDrDr",
                        0,          // Version
                        dwFlags,
                        &ClassName,
                        0,          // ASN1 Id
                        NumberOfSuperClasses,
                        SuperClassesBuffer,
                        SuperClassesBufferLength,
                        NumberOfContainmentClasses,
                        ContainmentClassesBuffer,
                        ContainmentClassesBufferLength,
                        NumberOfNamingAttributes,
                        NamingAttributesBuffer,
                        NamingAttributesBufferLength,
                        NumberOfMandatoryAttributes,
                        MandatoryAttributesBuffer,
                        MandatoryAttributesBufferLength,
                        NumberOfOptionalAttributes,
                        OptionalAttributesBuffer,
                        OptionalAttributesBufferLength
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineClass: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineClass: The define class response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsDeleteAttrDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName )
/*
   NwNdsDeleteAttrDef()

   This function is used to remove an attribute definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name of the attribute
                        defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_REMOVE_ATTR_DEF,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DS",
                        0,          // Version
                        &AttributeName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteAttrDef: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteAttrDef: The delete attribute response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsDeleteClassDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName )
/*
   NwNdsDeleteClassDef()

   This function is used to remove a class definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING ClassName;

    if ( szClassName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ClassName, szClassName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_REMOVE_CLASS_DEF,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DS",
                        0,          // Version
                        &ClassName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteClassDef: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteClassDef: The delete class response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


VOID
NwNdsDeleteQueryNode(
    IN  LPQUERY_NODE lpQueryNode
)
/*
   NwNdsDeleteQueryNode()

   This function is used to free a tree node that was part of a query
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_NODE     lpQueryNode - A pointer to a particular node of
                        a query tree that defines a search. The tree is
                        created manually by the user through the function
                        NwNdsCreateQueryNode.

    Returns:

       Nothing
*/
{
    (void) LocalFree( (HLOCAL) lpQueryNode );

    lpQueryNode = NULL;
}


DWORD
NwNdsDeleteQueryTree(
    IN  LPQUERY_TREE lpQueryTree
)
/*
   NwNdsDeleteQueryTree()

   This function is used to free a tree that describes a query that was
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a query
                        tree that defines a search.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD status;

    switch( lpQueryTree->dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpQueryTree->lpLVal == NULL || lpQueryTree->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsDeleteQueryTree was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = NwNdsDeleteQueryTree( lpQueryTree->lpLVal );

            if ( status != NO_ERROR )
            {
                return status;
            }

            lpQueryTree->lpLVal = NULL;

            status = NwNdsDeleteQueryTree( lpQueryTree->lpRVal );

            if ( status != NO_ERROR )
            {
                return status;
            }

            lpQueryTree->lpRVal = NULL;

            NwNdsDeleteQueryNode( lpQueryTree );

            break;

        case NDS_QUERY_NOT :

            if ( lpQueryTree->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = NwNdsDeleteQueryTree( lpQueryTree->lpLVal );

            if ( status != NO_ERROR )
            {
                return status;
            }

            lpQueryTree->lpLVal = NULL;

            NwNdsDeleteQueryNode( lpQueryTree );

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :
        case NDS_QUERY_PRESENT :

            NwNdsDeleteQueryNode( lpQueryTree );

            break;

        default :
#if DBG
            KdPrint(( "NDS32: NwNdsDeleteQueryTree was passed an unidentified operation - 0x%.8X.\n", lpQueryTree->dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
NwNdsFreeBuffer(
    IN  HANDLE hOperationData
                     )
/*
   NwNdsFreeBuffer()

   This function is used to free the buffer used to describe object
   operations to a specific object in an NDS directory tree. The buffer must
   be one created by NwNdsCreateBuffer, or returned by calling NwNdsReadObject,
   NwNdsReadAttrDef, or NwNdsReadClassDef.

   Arguments:

       HANDLE           hOperationData - Handle to buffer that is to be freed.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD        status = NO_ERROR;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    if ( lpNdsBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsFreeBuffer was passed a NULL buffer pointer.\n" ));
#endif

        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsBuffer->dwBufferId != NDS_SIGNATURE )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsFreeBuffer was passed an unidentified buffer.\n" ));
        ASSERT( FALSE );
#endif

        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If this buffer contains a pointer to an index buffer. Need to free
    // the index buffer.
    //
    if ( lpNdsBuffer->lpIndexBuffer )
    {
        if ( lpNdsBuffer->dwOperation == NDS_SEARCH &&
             lpNdsBuffer->dwNumberOfIndexEntries )
        {
            LPNDS_OBJECT_INFO lpObjectInfo = (LPNDS_OBJECT_INFO)
                                                    lpNdsBuffer->lpIndexBuffer;
            DWORD iter;

            for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
            {
                (void) LocalFree( (HLOCAL) lpObjectInfo[iter].lpAttribute );
                lpObjectInfo[iter].lpAttribute = NULL;
                lpObjectInfo[iter].dwNumberOfAttributes = 0;
            }
        }

        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpIndexBuffer );
        lpNdsBuffer->lpIndexBuffer = NULL;
    }

    //
    // If this buffer contains a pointer to a reply buffer. Need to free
    // the reply buffer.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
    }

    //
    // If this buffer contains a pointer to a request buffer. Need to free
    // the request buffer.
    //
    if ( lpNdsBuffer->lpRequestBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpRequestBuffer );
        lpNdsBuffer->lpRequestBuffer = NULL;
    }

    //
    // If this buffer contains a pointer to a syntax buffer. Need to free
    // the syntax buffer.
    //
    if ( lpNdsBuffer->lpSyntaxBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpSyntaxBuffer );
        lpNdsBuffer->lpSyntaxBuffer = NULL;
    }

    //
    // Now free the handle buffer.
    //
    (void) LocalFree((HLOCAL) lpNdsBuffer);

    return NO_ERROR;
}


DWORD
NwNdsGetAttrDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries )
/*
   NwNdsGetAttrDefListFromBuffer()

   This function is used to retrieve an array of attribute definition entries
   for a schema that was read with a prior call to NwNdsReadAttrDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadAttrDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadAttrDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of attribute schema structures. Each
                        structure contains the details of each attribute
                        definition read from a given schema by calling
                        NwNdsReadAttrDef. The lppEntries value should be
                        cast to either a LPNDS_ATTR_DEF or LPNDS_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER    lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    //
    // Check to see if the data handle is one for reading attribute definitions.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_ATTR_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if NwNdsReadAttrDef has been called yet.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsReadAttrDef returned any attributes.
    //
    if ( lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_NAMES )
        {
            status = IndexReadNameReplyBuffer( lpNdsBuffer );
        }
        else
        {
            status = IndexReadAttrDefReplyBuffer( lpNdsBuffer );
        }

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lpdwInformationType = lpNdsBuffer->dwReplyInformationType;
    *lppEntries = (LPVOID) lpNdsBuffer->lpIndexBuffer;

    return NO_ERROR;
}


DWORD
NwNdsGetAttrListFromBuffer(
    IN  HANDLE            hOperationData,
    OUT LPDWORD           lpdwNumberOfEntries,
    OUT LPNDS_ATTR_INFO * lppEntries )
/*
   NwNdsGetAttrListFromBuffer()

   This function is used to retrieve an array of attribute entries for an
   object that was read with a prior call to NwNdsReadObject.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadObject.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPNDS_ATTR_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_ATTR_INFO structures. Each
                        structure contains the details of each attribute read
                        from a given object by calling NwNdsReadObject.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER    lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    //
    // Check to see if the data handle is one for reading attributes.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_OBJECT_READ )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if NwNdsReadObject has been called yet.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsReadObject returned any attributes.
    //
    if ( lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_NAMES )
        {
            status = IndexReadNameReplyBuffer( lpNdsBuffer );
        }
        else
        {
            status = IndexReadObjectReplyBuffer( lpNdsBuffer );
        }

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    ASSERT( lpNdsBuffer->lpIndexBuffer != NULL );

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lppEntries = (LPNDS_ATTR_INFO) lpNdsBuffer->lpIndexBuffer;

    return NO_ERROR;
}


DWORD
NwNdsGetClassDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries )
/*
   NwNdsGetClassDefListFromBuffer()

   This function is used to retrieve an array of class definition entries
   for a schema that was read with a prior call to NwNdsReadClassDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadClassDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadClassDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of schema class structures. Each
                        structure contains the details of each class
                        definition read from a given schema by calling
                        NwNdsReadClassDef. The lppEntries value should be
                        cast to either a LPNDS_CLASS_DEF or LPNDS_DEF_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER    lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    //
    // Check to see if the data handle is one for reading class definitions.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_CLASS_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if NwNdsReadClassDef has been called yet.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsReadClassDef returned any classes.
    //
    if ( lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_NAMES )
        {
            status = IndexReadNameReplyBuffer( lpNdsBuffer );
        }
        else
        {
            status = IndexReadClassDefReplyBuffer( lpNdsBuffer );
        }

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    ASSERT( lpNdsBuffer->lpIndexBuffer != NULL );

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lpdwInformationType = lpNdsBuffer->dwReplyInformationType;
    *lppEntries = (LPVOID) lpNdsBuffer->lpIndexBuffer;

    return NO_ERROR;
}


DWORD
NwNdsGetEffectiveRights(
    IN  HANDLE  hObject,
    IN  LPWSTR  szSubjectName,
    IN  LPWSTR  szAttributeName,
    OUT LPDWORD lpdwRights )
/*
   NwNdsGetEffectiveRights()

   This function is used to determine the effective rights of a particular
   subject on a particular object in the NDS tree. The user needs to have
   appropriate priveleges to make the determination.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to determine effective rights on. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szSubjectName - The distinguished name of user whose
                        rights we're interested in determining.

       LPWSTR           szAttributeName - Regular attribute name (i.e.
                        L"Surname" , L"CN" ) for reading a particular
                        attribute right, or L"[All Attribute Rights]" and
                        L"[Entry Rights]" can be used to determine the default
                        attribute rights and object rights respectively.

       LPDWORD          lpdwRights - A pointer to a DWORD to receive the
                        results. If the call is successful, lpdwRights will
                        contain a mask representing the subject's rights:

                           Attribute rights -  NDS_RIGHT_COMPARE_ATTR,
                              NDS_RIGHT_READ_ATTR, NDS_RIGHT_WRITE_ATTR,
                              NDS_RIGHT_ADD_SELF_ATTR, and
                              NDS_RIGHT_SUPERVISE_ATTR.

                           Object rights - NDS_RIGHT_BROWSE_OBJECT,
                              NDS_RIGHT_CREATE_OBJECT, NDS_RIGHT_DELETE_OBJECT,
                              NDS_RIGHT_RENAME_OBJECT, and
                              NDS_RIGHT_SUPERVISE_OBJECT.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    UNICODE_STRING SubjectName;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         szSubjectName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &SubjectName, szSubjectName );
    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_GET_EFFECTIVE_RIGHTS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDSS",
                        0,          // Version
                        lpNdsObject->ObjectId,
                        &SubjectName,
                        &AttributeName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetEffectiveRights: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetEffectiveRights: The status code response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "G_D",
                              1 * sizeof(DWORD),
                              lpdwRights );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetEffectiveRights: The effective rights response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsGetObjectListFromBuffer(
    IN  HANDLE              hOperationData,
    OUT LPDWORD             lpdwNumberOfEntries,
    OUT LPDWORD             lpdwAttrInformationType OPTIONAL,
    OUT LPNDS_OBJECT_INFO * lppEntries )
/*
   NwNdsGetObjectListFromBuffer()

   This function is used to retrieve an array of object entries for
   objects that were read with a prior call to either
   NwNdsListSubObjects or NwNdsSearch.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsListSubObjects, or a
                        buffer containing the search results from a call
                        to NwNdsSearch.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwAttrInformationType - The address of a DWORD to
                        receive a value that indicates the type of attribute
                        information returned by the call to NwNdsSearch.
                        This attribute information type determines which
                        buffer structure (LPNDS_ATTR_INFO or LPNDS_NAME_ONLY)
                        should be used for the lpAttribute field found in
                        each NDS_OBJECT_INFO structure below.

                        - or -

                        NULL to indicate that the callee is not interested,
                        especially when the object list is that from a call
                        to NwNdsListSubObjects.

       LPNDS_OBJECT_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_OBJECT_INFO structures. Each
                        structure contains the details of each object returned
                        from a call to NwNdsListSubObjects or NwNdsSearch.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    *lpdwNumberOfEntries = 0;
    *lppEntries = NULL;

    //
    // Check to see if the data handle is one for listing subordinates or
    // for searching.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         ( lpNdsBuffer->dwOperation != NDS_OBJECT_LIST_SUBORDINATES &&
           lpNdsBuffer->dwOperation != NDS_SEARCH ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsListSubObjects returned any objects.
    //
    if ( lpNdsBuffer->dwOperation == NDS_OBJECT_LIST_SUBORDINATES &&
         lpNdsBuffer->dwNumberOfIndexEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsSearch returned any objects.
    //
    if ( lpNdsBuffer->dwOperation == NDS_SEARCH &&
         lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->dwOperation == NDS_SEARCH &&
         lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        status = IndexSearchObjectReplyBuffer( lpNdsBuffer );

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    ASSERT( lpNdsBuffer->lpIndexBuffer != NULL );

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lppEntries = (LPNDS_OBJECT_INFO) lpNdsBuffer->lpIndexBuffer;

    if ( lpdwAttrInformationType )
    {
        *lpdwAttrInformationType = lpNdsBuffer->dwReplyInformationType;
    }

    return NO_ERROR;
}


DWORD
NwNdsGetSyntaxID(
    IN  HANDLE  hTree,
    IN  LPWSTR  szlpAttributeName,
    OUT LPDWORD lpdwSyntaxID )
/*
   NwNdsGetObjListFromBuffer()

   This function is used to retrieve the Syntax ID of a given attribute name.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szlpAttributeName - The attribute name whose Syntax ID
                        is requested.

       LPDWORD          lpdwSyntaxID - The address of a DWORD to receive the
                        SyntaxID.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING AttributeName;
    DWORD          dwNumEntries;
    DWORD          dwStringLen;
    LPBYTE         lpByte;
    DWORD          LengthInBytes;
    LPBYTE         lpTempEntry = NULL;

    if ( lpNdsObject == NULL ||
         szlpAttributeName == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szlpAttributeName );

    // allocate enough extra space for the padding PrepareReadEntry will do
    lpTempEntry = LocalAlloc( LPTR, AttributeName.Length + (2*sizeof(DWORD)) );

    if ( ! lpTempEntry )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }
    PrepareReadEntry( lpTempEntry,
                      AttributeName,
                      &LengthInBytes );


    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_READ_ATTR_DEF,
                               NdsReply,
                               NDS_BUFFER_SIZE,
                               &dwReplyLength,
                               "DDDDDr",
                               0,             // Version
                               NDS_NO_MORE_ITERATIONS, // Initial iteration
                               NDS_INFO_NAMES_DEFS,
                               (DWORD) FALSE, // All attributes indicator
                               1,             // Number of attributes
                               lpTempEntry,
                               LengthInBytes);

    (void) LocalFree((HLOCAL) lpTempEntry );
    
    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: The get syntax id response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: NetWare error 0x%.8X reading %ws.\n", nwstatus, szlpAttributeName ));
#endif
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "G_D",
                              3 * sizeof(DWORD),
                              &dwNumEntries );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: The attribute read response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ASSERT( dwNumEntries == 1 );

    //
    // Set lpByte to the point in the reply buffer that has the attribute
    // name length.
    //
    lpByte = NdsReply + ( 4 * sizeof(DWORD) );

    //
    // Get the attribute name length and move lpByte to beginning of
    // attribute name
    //
    dwStringLen = * (LPDWORD) lpByte;
    lpByte += sizeof(DWORD);

    //
    // Move lpByte past the attribute name so that it points to the
    // attribute flags value
    //
    lpByte += ROUND_UP_COUNT( dwStringLen,
                              ALIGN_DWORD);

    //
    // Move lpByte past the attribute flags value so that it now points to
    // the attribute syntax id value
    //
    lpByte += sizeof(DWORD);
    *lpdwSyntaxID = * (LPDWORD) lpByte;
    return NO_ERROR;
}


DWORD
NwNdsListSubObjects(
    IN  HANDLE   hParentObject,
    IN  DWORD    dwEntriesRequested,
    OUT LPDWORD  lpdwEntriesReturned,
    IN  LPNDS_FILTER_LIST lpFilters OPTIONAL,
    OUT HANDLE * lphOperationData )
/*
   NwNdsListSubObjects()

   This function is used to enumerate the subordinate objects for a particular
   parent object. A filter can be passed in to restrict enumeration to a
   a specific class type or list of class types.

   Arguments:

       HANDLE           hParentObject - A handle to the object in the directory
                        tree whose subordinate objects (if any) will be
                        enumerated.

       DWORD            dwEntriesRequested - The number of subordinate objects
                        to list. A subsequent call to NwNdsListSubObjects will
                        continue enumeration following the last item returned.

       LPDWORD          lpdwEntriesReturned - A pointer to a DWORD that will
                        contain the actual number of subobjects enumerated in
                        the call.

       LPNDS_FILTER_LIST lpFilters - The caller can specify the object class
                         names for the kinds of objects that they would like
                         to enumerate. For example if just User and Group
                         object classes should be enumerated, then a filter
                         for class names NDS_CLASS_USER and NDS_CLASS_GROUP
                         should be pass in.

                                - or -

                         NULL to indicate that all objects should be returned
                         (no filter).

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer that contains the list of
                        subordinate objects read from the object
                        hParentObject. This handle is manipulated by the
                        following functions:
                           NwNdsGetObjListFromBuffer and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD        status = NO_ERROR;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    LPNDS_OBJECT_PRIV lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    LPBYTE FixedPortion = NULL;
    LPWSTR EndOfVariableData = NULL;
    BOOL  FitInBuffer = TRUE;

    //
    // Test the parameters.
    //
    if ( lpNdsParentObject == NULL ||
         lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsParentObject->ResumeId == NDS_NO_MORE_ITERATIONS )
    {
        if ( lpNdsParentObject->NdsRawDataBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsParentObject->NdsRawDataBuffer );
            lpNdsParentObject->NdsRawDataBuffer = 0;
            lpNdsParentObject->NdsRawDataSize = 0;
            lpNdsParentObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsParentObject->NdsRawDataCount = 0;
        }

        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    //
    // Allocate a results buffer
    //
    status = NwNdsCreateBuffer( NDS_OBJECT_LIST_SUBORDINATES,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        return status;
    }

    FixedPortion = lpNdsBuffer->lpIndexBuffer;
    EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                          ROUND_DOWN_COUNT(
                                  lpNdsBuffer->dwIndexAvailableBytes,
                                  ALIGN_DWORD ) );

    *lpdwEntriesReturned = 0;
    *lphOperationData = NULL;

    while ( FitInBuffer &&
            dwEntriesRequested > *lpdwEntriesReturned &&
            status == NO_ERROR )
    {
        if ( lpNdsParentObject->ResumeId == 0 )
        {
            //
            // Get the first subtree entry.
            //
            status = GetFirstNdsSubTreeEntry( lpNdsParentObject,
                                              lpNdsBuffer->dwRequestAvailableBytes );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // GetFirstNdsSubTreeEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && lpNdsParentObject->ResumeId != 0)
        {
            WORD   tempStrLen;
            LPWSTR newPathStr = NULL;
            LPWSTR tempStr = NULL;
            LPWSTR ClassName;
            LPWSTR ObjectName;
            DWORD  ClassNameLen;
            DWORD  ObjectNameLen;
            DWORD  EntryId;
            DWORD  SubordinateCount;
            DWORD  ModificationTime;
            BOOL   fWriteThisObject = FALSE;

            //
            // Get current subtree data from lpNdsParentObject
            //
            GetSubTreeData( lpNdsParentObject->ResumeId,
                            &EntryId,
                            &SubordinateCount,
                            &ModificationTime,
                            &ClassNameLen,
                            &ClassName,
                            &ObjectNameLen,
                            &ObjectName );

            if ( lpFilters )
            {
                DWORD iter;

                for ( iter = 0; iter < lpFilters->dwNumberOfFilters; iter++ )
                {
                    if (!wcscmp(lpFilters->Filters[iter].szObjectClass, ClassName))
                        fWriteThisObject = TRUE;
                }
            }
            else
            {
                fWriteThisObject = TRUE;
            }

            if ( fWriteThisObject )
            {
                //
                // Need to build a string with the new NDS UNC path
                // for subtree object
                //
                newPathStr = (PVOID) LocalAlloc( LPTR,
                                   ( wcslen(ObjectName) +
                                   wcslen(lpNdsParentObject->szContainerName) +
                                   3 ) * sizeof(WCHAR) );

                if ( newPathStr == NULL )
                {
                    (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
#if DBG
                    KdPrint(("NDS32: NwNdsListSubObjects LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                            lpNdsParentObject->szContainerName,
                                            PARSE_NDS_GET_TREE_NAME );

                tempStrLen /= sizeof(WCHAR);

                if ( tempStrLen > 0 )
                {
                    wcscpy( newPathStr, L"\\\\" );
                    wcsncat( newPathStr, tempStr, tempStrLen );
                    wcscat( newPathStr, L"\\" );
                    wcscat( newPathStr, ObjectName );
                    _wcsupr( newPathStr );
                }

                tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                            lpNdsParentObject->szContainerName,
                                            PARSE_NDS_GET_PATH_NAME );

                tempStrLen /= sizeof(WCHAR);

                if ( tempStrLen > 0 )
                {
                    wcscat( newPathStr, L"." );
                    wcsncat( newPathStr, tempStr, tempStrLen );
                }

                //
                // Pack subtree name into output buffer.
                //
                status = WriteObjectToBuffer( &FixedPortion,
                                              &EndOfVariableData,
                                              newPathStr,
                                              ObjectName,
                                              ClassName,
                                              EntryId,
                                              ModificationTime,
                                              SubordinateCount,
                                              0,      // No attribute
                                              NULL ); // infos here

                if ( status == NO_ERROR )
                {
                    //
                    // Note that we've returned the current entry.
                    //
                    (*lpdwEntriesReturned)++;
                    (lpNdsBuffer->dwNumberOfIndexEntries)++;
                }

                if ( newPathStr )
                    (void) LocalFree( (HLOCAL) newPathStr );
            }

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*lpdwEntriesReturned)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Get next directory entry.
                //
                status = GetNextNdsSubTreeEntry( lpNdsParentObject );
            }
        } // end of if data to process

        if (status == WN_NO_MORE_ENTRIES)
        {
            lpNdsParentObject->ResumeId = NDS_NO_MORE_ITERATIONS;
        }
    } //end of while loop

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( *lpdwEntriesReturned && status == WN_NO_MORE_ENTRIES )
    {
        status = NO_ERROR;
    }

    if ( *lpdwEntriesReturned )
    {
        *lphOperationData = lpNdsBuffer;
    }

    if ( *lpdwEntriesReturned == 0 )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    if ( lpNdsParentObject->NdsRawDataBuffer &&
         lpNdsParentObject->ResumeId == NDS_NO_MORE_ITERATIONS )
    {
        (void) LocalFree( (HLOCAL) lpNdsParentObject->NdsRawDataBuffer );
        lpNdsParentObject->NdsRawDataBuffer = 0;
        lpNdsParentObject->NdsRawDataSize = 0;
        lpNdsParentObject->NdsRawDataId = INITIAL_ITERATION;
        lpNdsParentObject->NdsRawDataCount = 0;
    }

    return status;
}


DWORD
NwNdsModifyObject(
    IN  HANDLE hObject,
    IN  HANDLE hOperationData )
/*
   NwNdsModifyObject()

   This function is used to modify a leaf object in an NDS directory tree.
   Modifying a leaf object means: changing, adding, removing, and clearing of
   specified attributes for a given object.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       HANDLE           hOperationData - A handle to data containing a
                        list of attribute changes to be applied to the object.
                        This buffer is manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_MODIFY),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       ERROR_INVALID_PARAMETER
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD        nwstatus;
    NTSTATUS     ntstatus = STATUS_SUCCESS;
    DWORD        dwReplyLength;
    BYTE         NdsReply[NDS_BUFFER_SIZE];
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) hOperationData;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;

    if ( lpNdsBuffer == NULL ||
         lpNdsObject == NULL ||
         lpNdsBuffer->dwOperation != NDS_OBJECT_MODIFY ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus =
        FragExWithWait(
                     lpNdsObject->NdsTree,
                     NETWARE_NDS_FUNCTION_MODIFY_OBJECT,
                     NdsReply,
                     NDS_BUFFER_SIZE,
                     &dwReplyLength,
                     "DDDDr",
                     0,                   // Version
                     0,                   // Flags
                     lpNdsObject->ObjectId, // The id of the object
                     lpNdsBuffer->dwNumberOfRequestEntries,
                     lpNdsBuffer->lpRequestBuffer, // Object attribute changes
                     (WORD)lpNdsBuffer->dwLengthOfRequestData // Length of data
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsModifyObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsModifyObject: The modify object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsMoveObject(
    IN  HANDLE hObject,
    IN  LPWSTR szDestObjectParentDN )
/*
   NwNdsMoveObject()

   This function is used to move a leaf object in an NDS directory tree
   from one container to another.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be moved. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szDestObjectParentDN - The DN of the object's new
                        parent.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    LPNDS_OBJECT_PRIV   lpNdsDestParentObject = NULL;
    WCHAR          szServerDN[NDS_MAX_NAME_CHARS];
    UNICODE_STRING ObjectName;
    UNICODE_STRING ServerDN;
    DWORD          dwDestParentObjectId;

    if ( szDestObjectParentDN == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlZeroMemory( &szServerDN[0], sizeof( szServerDN ) );

    status = NwNdsGetServerDN( lpNdsObject, szServerDN );

    if ( status )
    {
        return status;
    }

    status = NwNdsOpenObject( szDestObjectParentDN,
                              NULL,
                              NULL,
                              (HANDLE *) &lpNdsDestParentObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        return status;
    }

    dwDestParentObjectId = lpNdsDestParentObject->ObjectId;

    (void) NwNdsCloseObject( (HANDLE) lpNdsDestParentObject );

    RtlInitUnicodeString( &ObjectName, lpNdsObject->szRelativeName );
    RtlInitUnicodeString( &ServerDN, szServerDN );

    ntstatus =
        FragExWithWait( lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_BEGIN_MOVE_OBJECT,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDDSS",
                        0,          // Version
                        0x00000000, // Some value
                        dwDestParentObjectId,
                        &ObjectName,
                        &ServerDN
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The status code response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    ntstatus =
        FragExWithWait( lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_FINISH_MOVE_OBJECT,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDDDSS",
                        0,          // Version
                        0x00000001, // Some value
                        lpNdsObject->ObjectId,
                        dwDestParentObjectId,
                        &ObjectName,
                        &ServerDN
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The status code response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    return nwstatus;
}


DWORD
NwNdsOpenObject(
    IN  LPWSTR   szObjectDN,
    IN  LPWSTR   UserName OPTIONAL,
    IN  LPWSTR   Password OPTIONAL,
    OUT HANDLE * lphObject,
    OUT LPWSTR   szObjectName OPTIONAL,
    OUT LPWSTR   szObjectFullName OPTIONAL,
    OUT LPWSTR   szObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime OPTIONAL,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL )
/*
   NwNdsOpenObject()

   Arguments:

       LPWSTR           szObjectDN - The distinguished name of the object
                        that we want resolved into an object handle.

       LPWSTR           UserName - The name of the user account to create
                        connection to object with.
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       LPWSTR           Password - The password of the user account to create
                        connection to object with. If password is blank, callee
                        should pass "".
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       HANDLE *         lphObject - The address of a NDS_OBJECT_HANDLE
                        to receive the handle of the object specified by
                        szObjectDN.

       Optional arguments: ( Callee can pass NULL in for these parameters to
                             indicate ignore )

       LPWSTR           szObjectName - A LPWSTR buffer to receive
                        the object's NDS name, or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE

       LPWSTR           szObjectFullName - A LPWSTR buffer to receive
                        the object's full NDS name (DN), or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE

       LPWSTR           szObjectClassName - A LPWSTR buffer to receive
                        the class name of the object opened, or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE.

       LPDWORD          lpdwModificationTime -  The address of a DWORD to
                        receive the last date/time the object was modified.

       LPDWORD          lpdwSubordinateCount -  The address of a DWORD to
                        receive the number of subordinate objects that may
                        be found under szObjectDN, if it is a container object.
                        Or, NULL in not interested.

                        If szObjectDN is not a container, then the value is set
                        to zero. Although a value of zero does not imply
                        that object is not a container, it could just be empty.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    WCHAR          szServerName[NW_MAX_SERVER_LEN];
    UNICODE_STRING ServerName;
    UNICODE_STRING ObjectName;
    LPNDS_OBJECT_PRIV   lpNdsObject = NULL;
#ifdef WIN95
    LPWSTR         pszObjectName = NULL;
    LPWSTR         szWin95ClassName = NULL;
#endif
    if ( szObjectDN == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsObject = (LPNDS_OBJECT_PRIV) LocalAlloc( LPTR,
                                             sizeof(NDS_OBJECT_PRIV) );

    if (lpNdsObject == NULL) {
#if DBG
        KdPrint(("NDS32: NwNdsOpenObject LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof(szServerName);
    ServerName.Buffer = szServerName;

    ObjectName.Buffer = NULL;

    ObjectName.MaximumLength = (wcslen( szObjectDN ) + 1) * sizeof(WCHAR);

    ObjectName.Length = ParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                         szObjectDN,
                                         PARSE_NDS_GET_TREE_NAME );

    if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
    {
        SetLastError( ERROR_PATH_NOT_FOUND );
        goto ErrorExit;
    }

    if ( ObjectName.Length > NDS_MAX_NAME_SIZE ) {
        SetLastError( ERROR_PATH_NOT_FOUND );
        goto ErrorExit;
    }

    //
    // Open a NDS tree connection handle to \\treename
    //
    if ( UserName && Password )
    {
        UNICODE_STRING usUserName;
        UNICODE_STRING usPassword;
        DWORD          dwHandleType;

        RtlInitUnicodeString( &usUserName, UserName );
        RtlInitUnicodeString( &usPassword, Password );

        ntstatus = NwOpenHandleWithSupplementalCredentials(
                                               &ObjectName,
                                               &usUserName,
                                               &usPassword,
                                               &dwHandleType,
                                               &lpNdsObject->NdsTree );

        if ( ntstatus == STATUS_SUCCESS &&
             dwHandleType != HANDLE_TYPE_NDS_TREE )
        {
            SetLastError( ERROR_PATH_NOT_FOUND );
            goto ErrorExit;
        }
    }
    else if ( !UserName && !Password )
    {
        ntstatus = NwNdsOpenTreeHandle( &ObjectName, &lpNdsObject->NdsTree );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto ErrorExit;
    }

    if ( ntstatus != STATUS_SUCCESS )
    {
        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    ObjectName.Length /= sizeof(WCHAR);

    wcscpy( lpNdsObject->szContainerName, L"\\\\" );
    wcsncat( lpNdsObject->szContainerName, ObjectName.Buffer, ObjectName.Length );
    wcscat( lpNdsObject->szContainerName, L"\\" );
    _wcsupr( lpNdsObject->szContainerName );

    //
    // Get the path to the container to open.
    //
    ObjectName.Length = ParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                         szObjectDN,
                                         PARSE_NDS_GET_PATH_NAME );

    if ( ObjectName.Length == 0 )
    {
        UNICODE_STRING Root;

        RtlInitUnicodeString(&Root, L"[Root]");

        //
        // Resolve the path to get a NDS object id of [Root].
        //
#ifndef WIN95
        ntstatus = NwNdsResolveName( lpNdsObject->NdsTree,
                                     &Root,
                                     &lpNdsObject->ObjectId,
                                     &ServerName,
                                     NULL,
                                     0 );
#else
        ntstatus = NwNdsResolveNameWin95( lpNdsObject->NdsTree,
                                     &Root,
                                     &lpNdsObject->ObjectId,
                                     &lpNdsObject->NdsTree,
                                     NULL,
                                     0 );
#endif
        if ( ntstatus != STATUS_SUCCESS )
        {
            status = RtlNtStatusToDosError( ntstatus );

            if ( status == ERROR_NOT_CONNECTED )
                SetLastError( ERROR_PATH_NOT_FOUND );
            else
                SetLastError( status );
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Resolve the path to get a NDS object id.
        //
#ifndef WIN95
        ntstatus = NwNdsResolveName( lpNdsObject->NdsTree,
                                     &ObjectName,
                                     &lpNdsObject->ObjectId,
                                     &ServerName,
                                     NULL,
                                     0 );
#else

        ntstatus = NwNdsResolveNameWin95( lpNdsObject->NdsTree,
                                     &ObjectName,
                                     &lpNdsObject->ObjectId,
                                     &lpNdsObject->NdsTree,
                                     NULL,
                                     0 );
#endif

        if ( ntstatus != STATUS_SUCCESS )
        {
            status = RtlNtStatusToDosError( ntstatus );

            if ( status == ERROR_NOT_CONNECTED )
                SetLastError( ERROR_PATH_NOT_FOUND );
            else
                SetLastError( status );
            goto ErrorExit;
        }
    }

#ifndef WIN95
    if ( ServerName.Length )
    {
        DWORD    dwHandleType;

        //
        // NwNdsResolveName succeeded, but we were referred to
        // another server, though lpNdsObject->ObjectId is still valid.
        //
        if ( lpNdsObject->NdsTree )
            CloseHandle( lpNdsObject->NdsTree );

        lpNdsObject->NdsTree = 0;

        //
        // Open a NDS generic connection handle to \\ServerName
        //
        ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                           &dwHandleType,
                                           &lpNdsObject->NdsTree );

        if ( ntstatus != STATUS_SUCCESS )
        {
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            goto ErrorExit;
        }
    }
    {
        PBYTE RawResponse = NULL;
        PNDS_RESPONSE_GET_OBJECT_INFO psGetInfo;
        PBYTE pbRawGetInfo;
        LPWSTR szClassName;
        DWORD dwStrLen;

        RawResponse = LocalAlloc( LPTR, TWO_KB );

        if ( ! RawResponse )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        ntstatus = NwNdsReadObjectInfo( lpNdsObject->NdsTree,
                                        lpNdsObject->ObjectId,
                                        RawResponse,
                                        TWO_KB );

        if ( ntstatus != STATUS_SUCCESS )
        {
            LocalFree( RawResponse );
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            goto ErrorExit;
        }

        psGetInfo = ( PNDS_RESPONSE_GET_OBJECT_INFO ) RawResponse;

        if ( lpdwModificationTime != NULL )
        {
            *lpdwModificationTime = psGetInfo->ModificationTime;
        }

        if ( lpdwSubordinateCount != NULL )
        {
            *lpdwSubordinateCount = psGetInfo->SubordinateCount;
        }

        //
        // Dig out the two unicode strings for class name and object name.
        //

        pbRawGetInfo = RawResponse;

        pbRawGetInfo += sizeof (NDS_RESPONSE_GET_OBJECT_INFO);

        dwStrLen = * (LPDWORD) pbRawGetInfo;
        pbRawGetInfo += sizeof(DWORD);
        szClassName = (LPWSTR) pbRawGetInfo;

        if ( szObjectClassName != NULL )
        {
            wcsncpy( szObjectClassName, szClassName, NDS_MAX_NAME_CHARS );
        }

        pbRawGetInfo += ROUNDUP4( dwStrLen );
        dwStrLen = * ( DWORD * ) pbRawGetInfo;
        pbRawGetInfo += sizeof(DWORD);

        //
        // Clean up the object's relative name ...
        //
        if ( wcscmp( szClassName, NDS_CLASS_TOP ) )
        {
            LPWSTR szTempStr = (LPWSTR) pbRawGetInfo;

            while ( *szTempStr != L'=' )
            {
                szTempStr++;
            }

            szTempStr++;

            wcsncpy( lpNdsObject->szRelativeName, szTempStr, NDS_MAX_NAME_CHARS );
            lpNdsObject->szRelativeName[NDS_MAX_NAME_CHARS - 1] = (WCHAR)'\0';

            szTempStr = lpNdsObject->szRelativeName;

            while ( *szTempStr && *szTempStr != L'.' )
            {
                szTempStr++;
            }

            *szTempStr = L'\0';
        }
        else
        {
            wcsncpy( lpNdsObject->szRelativeName, (LPWSTR) pbRawGetInfo, NDS_MAX_NAME_CHARS );
            lpNdsObject->szRelativeName[NDS_MAX_NAME_CHARS - 1] = (WCHAR)'\0';
        }

        if ( szObjectName != NULL )
        {
            wcscpy( szObjectName, lpNdsObject->szRelativeName );
        }

        if ( szObjectFullName != NULL )
        {
            if ( wcscmp( szClassName, NDS_CLASS_TOP ) )
            {
                wcsncpy( szObjectFullName, lpNdsObject->szContainerName, NDS_MAX_NAME_CHARS );
                szObjectFullName[NDS_MAX_NAME_CHARS - 1] = (WCHAR)'\0'; 
                wcsncat( szObjectFullName, (LPWSTR) pbRawGetInfo, 
                    NDS_MAX_NAME_CHARS - wcslen( szObjectFullName ) );
                szObjectFullName[NDS_MAX_NAME_CHARS - 1] = (WCHAR)'\0';
            }
            else
            {
                wcsncpy( szObjectFullName,
                         lpNdsObject->szContainerName,
                         NDS_MAX_NAME_CHARS );
                szObjectFullName[NDS_MAX_NAME_CHARS - 1] = (WCHAR)'\0'; 

                // Remove trailing slash
                if ( szObjectFullName[wcslen( szObjectFullName ) - 1] == '\\' )
                    szObjectFullName[wcslen( szObjectFullName ) - 1] = L'\0';
            }
        }

        //
        // If the object is at a level below the root of the tree, append
        // it's full DN to handle Name.
        //
        if ( wcscmp( szClassName, NDS_CLASS_TOP ) )
        {
            if ( ( wcslen(lpNdsObject->szContainerName) + 
                wcslen((LPWSTR) pbRawGetInfo) ) < 
                ( sizeof(lpNdsObject->szContainerName) / sizeof(WCHAR)) )
            {
                wcscat(lpNdsObject->szContainerName, (LPWSTR) pbRawGetInfo);
            }
            else
            {
                LocalFree( RawResponse );
                SetLastError( ERROR_PATH_NOT_FOUND );
                goto ErrorExit;
            }
        }

        if ( RawResponse )
            LocalFree( RawResponse );
    }

    lpNdsObject->Signature = NDS_SIGNATURE;

    //
    // Initialize ListSubObject/Search structure values.
    //
    // lpNdsObject->ResumeId = 0;         // Start of enumeration
    //
    // lpNdsObject->NdsRawDataBuffer = 0;
    // lpNdsObject->NdsRawDataSize = 0;
    // lpNdsObject->NdsRawDataId = 0;     // These are initialized by
    // lpNdsObject->NdsRawDataCount = 0;  // LPTR

    //
    // Return the newly created object handle.
    //
    *lphObject = (HANDLE) lpNdsObject;

    return NO_ERROR;

#else
    {
        DS_OBJ_INFO dsobj;
        DWORD dwStrLen;
        NW_STATUS nwstatus;

        memset(&dsobj, 0, sizeof(DS_OBJ_INFO));

        nwstatus = NDSGetObjectInfoWithId(lpNdsObject->NdsTree,
                                  lpNdsObject->ObjectId,
                                  &dsobj );

        ntstatus = MapNwToNtStatus(nwstatus);
        if ( ntstatus != STATUS_SUCCESS )
        {
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            goto ErrorExit;
        }

        if ( lpdwSubordinateCount != NULL )
        {
            *lpdwSubordinateCount = dsobj.subordinateCount;
        }

        if (!(szWin95ClassName = AllocateUnicodeString(dsobj.className))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        if ( szObjectClassName != NULL )
        {
            wcscpy( szObjectClassName, szWin95ClassName);
        }

        if (!(pszObjectName = AllocateUnicodeString(dsobj.objectName))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        //
        // Clean up the object's relative name ...
        //
        if ( wcscmp( szWin95ClassName, NDS_CLASS_TOP ) )
        {
            LPWSTR szTempStr = pszObjectName;

            while ( *szTempStr != L'=' )
            {
                szTempStr++;
            }

            szTempStr++;

            wcscpy( lpNdsObject->szRelativeName, szTempStr );

            szTempStr = lpNdsObject->szRelativeName;

            while ( *szTempStr && *szTempStr != L'.' )
            {
                szTempStr++;
            }

            *szTempStr = L'\0';
        }
        else
        {
            wcscpy( lpNdsObject->szRelativeName, pszObjectName );
        }

        if ( szObjectName != NULL )
        {
            wcscpy( szObjectName, lpNdsObject->szRelativeName );
        }

        if ( szObjectFullName != NULL )
        {
            if ( wcscmp( szWin95ClassName, NDS_CLASS_TOP ) )
            {
                wcscpy( szObjectFullName, lpNdsObject->szContainerName );
                wcscat( szObjectFullName, pszObjectName );
            }
            else
            {
                wcscpy( szObjectFullName,
                        lpNdsObject->szContainerName );

                szObjectFullName[wcslen( szObjectFullName ) - 1] = L'\0';
            }
        }

        //
        // If the object is at a level below the root of the tree, append
        // it full DN to handle Name.
        //
        if ( wcscmp( szWin95ClassName, NDS_CLASS_TOP ) )
        {
            wcscat(lpNdsObject->szContainerName, pszObjectName);
        }
        if(szWin95ClassName){
            FreeUnicodeString(szWin95ClassName);
        }
        if(pszObjectName){
            FreeUnicodeString(pszObjectName);
        }
    }

    lpNdsObject->Signature = NDS_SIGNATURE;
    *lphObject = (HANDLE) lpNdsObject;

    return NO_ERROR;
#endif


ErrorExit:

    if ( lpNdsObject )
    {
#ifndef WIN95
        // There is no ref count in Win95, the connection will time out itself
        if ( lpNdsObject->NdsTree )
            CloseHandle( lpNdsObject->NdsTree );
#endif
        (void) LocalFree( (HLOCAL) lpNdsObject );
    }

#ifdef WIN95
    if(szWin95ClassName)
    {
        FreeUnicodeString(szWin95ClassName);
    }

    if(pszObjectName)
    {
        FreeUnicodeString(pszObjectName);
    }
#endif

    *lphObject = NULL;
    return (DWORD) UNSUCCESSFUL;
}


DWORD
NwNdsPutInBuffer(
    IN     LPWSTR szAttributeName,
    IN     DWORD  dwSyntaxID,
    IN     LPVOID lpAttributeValues,
    IN     DWORD  dwValueCount,
    IN     DWORD  dwAttrModificationOperation,
    IN OUT HANDLE hOperationData )
/*
   NwNdsPutInBuffer()

   This function is used to add an entry to the buffer used to describe
   an object attribute or change to an object attribute. The buffer must
   be created using NwNdsCreateBuffer. If the buffer was created using the
   operations, NDS_OBJECT_ADD, NDS_SCHEMA_DEFINE_CLASS,
   NDS_SCHEMA_READ_ATTR_DEF, or NDS_SCHEMA_READ_CLASS_DEF, then
   dwAttrModificationOperation is ignored. If the buffer was created using
   either the operation NDS_OBJECT_READ or NDS_SEARCH, then
   dwAttrModificationOperation, puAttributeType, and lpAttributeValue are
   all ingnored.

   Arguments:

       LPWSTR           szAttributeName - A NULL terminated WCHAR string
                        that contains name of the attribute value to be
                        added to the buffer. It can be a user supplied
                        string, or one of the  many defined string macros
                        in ndsnames.h.

       DWORD            dwSyntaxID - The ID of the syntax structure used to
                        represent the attribute value. Syntax IDs and their
                        associated structures are defined in the file
                        NdsSntx.h. According to the NetWare NDS schema spec,
                        there is and always will be, only 28 (0..27)
                        different syntaxes.

       LPVOID           lpAttributeValues - A pointer to the beginning of a
                        buffer containing the value(s) for a particular
                        object attribute with data syntax dwSyntaxID.

       DWORD            dwValueCount - The number of value entries found in
                        buffer pointed to by lpAttributeValues.

       DWORD            dwAttrModificationOperation - If the buffer was created
                        using the operation NDS_MODIFY_OBJECT, then this is
                        used to desribe which type of modification operation
                        to apply for a given attribute. These attribute
                        modification operations are defined near the beginning
                        of this file.

       HANDLE           hOperationData - A handle to data created by
                        calling NwNdsCreateBuffer. The buffer stores the
                        attributes used to define transactions for
                        NwNdsAddObject, NwNdsModifyObject, NwNdsReadObject,
                        NwNdsReadAttrDef, NwNdsReadClassDef, or NwNdsSearch.

    Returns:

       NO_ERROR
       ERROR_NOT_ENOUGH_MEMORY
       ERROR_INVALID_PARAMETER
*/
{
    LPNDS_BUFFER   lpNdsBuffer = (LPNDS_BUFFER) hOperationData;
    DWORD          LengthInBytes;
    LPBYTE         lpTempEntry = NULL;
    UNICODE_STRING AttributeName;
    DWORD          bufferSize = TWO_KB;

    if ( lpNdsBuffer == NULL ||
         szAttributeName == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szAttributeName );

    //
    // Check to see if the buffer was already used by a read operation.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return NDS_ERR_NO_ACCESS;
    }

    if ( lpNdsBuffer->dwOperation == NDS_OBJECT_MODIFY )
    {
        switch( dwAttrModificationOperation )
        {
            case NDS_ATTR_ADD:
            case NDS_ATTR_REMOVE:
            case NDS_ATTR_ADD_VALUE:
            case NDS_ATTR_REMOVE_VALUE:
            case NDS_ATTR_ADDITIONAL_VALUE:
            case NDS_ATTR_OVERWRITE_VALUE:
            case NDS_ATTR_CLEAR:
            case NDS_ATTR_CLEAR_VALUE:
                break;

            default:
#if DBG
                KdPrint(( "NDS32: NwNdsPutInBuffer was passed an unidentified modification operation.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
        }
    }

    if ( lpNdsBuffer->dwOperation == NDS_OBJECT_ADD ||
         lpNdsBuffer->dwOperation == NDS_OBJECT_MODIFY )
    {
        bufferSize += CalculateValueDataSize ( dwSyntaxID,
                                               lpAttributeValues,
                                               dwValueCount );
    }

    lpTempEntry = LocalAlloc( LPTR, bufferSize );

    if ( ! lpTempEntry )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    switch ( lpNdsBuffer->dwOperation )
    {
        case NDS_OBJECT_ADD:
            PrepareAddEntry( lpTempEntry,
                             AttributeName,
                             dwSyntaxID,
                             lpAttributeValues,
                             dwValueCount,
                             &LengthInBytes );
            break;

        case NDS_OBJECT_MODIFY:
            PrepareModifyEntry( lpTempEntry,
                                AttributeName,
                                dwSyntaxID,
                                dwAttrModificationOperation,
                                lpAttributeValues,
                                dwValueCount,
                                &LengthInBytes );
            break;

        case NDS_OBJECT_READ:
        case NDS_SCHEMA_DEFINE_CLASS:
        case NDS_SCHEMA_READ_ATTR_DEF:
        case NDS_SCHEMA_READ_CLASS_DEF:
        case NDS_SEARCH:
            //
            // Check to see if this buffer has already been used. If so,
            // return with error.
            //
            if ( lpNdsBuffer->lpReplyBuffer )
            {
                if ( lpTempEntry )
                    LocalFree( lpTempEntry );

                SetLastError( ERROR_INVALID_PARAMETER );
                return (DWORD) UNSUCCESSFUL;
            }

            PrepareReadEntry( lpTempEntry,
                              AttributeName,
                              &LengthInBytes );
            break;

        default:
#if DBG
            KdPrint(( "NDS32: NwNdsPutInBuffer has unknown buffer operation!\n" ));
#endif

            if ( lpTempEntry )
                LocalFree( lpTempEntry );

            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsBuffer->dwRequestAvailableBytes >= LengthInBytes )
    {
        //
        // Copy temporary buffer entry into buffer and update buffer header.
        //

        RtlCopyMemory( (LPBYTE)&lpNdsBuffer->lpRequestBuffer[lpNdsBuffer->dwLengthOfRequestData],
                       lpTempEntry,
                       LengthInBytes );

        lpNdsBuffer->dwRequestAvailableBytes -= LengthInBytes;
        lpNdsBuffer->dwNumberOfRequestEntries += 1;
        lpNdsBuffer->dwLengthOfRequestData += LengthInBytes;
    }
    else
    {
        LPBYTE lpNewBuffer = NULL;

        //
        // Need to reallocate buffer to a bigger size.
        //
        lpNewBuffer = (LPBYTE) LocalAlloc(
                                  LPTR,
                                  lpNdsBuffer->dwRequestBufferSize +
                                  LengthInBytes +
                                  TWO_KB );

        if ( lpNewBuffer == NULL )
        {
#if DBG
            KdPrint(( "NDS32: NwNdsPutInBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            if ( lpTempEntry )
                LocalFree( lpTempEntry );

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }

        RtlCopyMemory( lpNewBuffer,
                       lpNdsBuffer->lpRequestBuffer,
                       lpNdsBuffer->dwLengthOfRequestData );

        LocalFree( (HLOCAL) lpNdsBuffer->lpRequestBuffer );
        lpNdsBuffer->lpRequestBuffer = lpNewBuffer;
        lpNdsBuffer->dwRequestBufferSize += LengthInBytes + TWO_KB;
        lpNdsBuffer->dwRequestAvailableBytes += LengthInBytes + TWO_KB;

        //
        // Copy temporary buffer entry into the resized buffer and
        // update buffer header.
        //

        RtlCopyMemory( (LPBYTE)&lpNdsBuffer->lpRequestBuffer[lpNdsBuffer->dwLengthOfRequestData],
                       lpTempEntry,
                       LengthInBytes );

        lpNdsBuffer->dwRequestAvailableBytes -= LengthInBytes;
        lpNdsBuffer->dwNumberOfRequestEntries += 1;
        lpNdsBuffer->dwLengthOfRequestData += LengthInBytes;
    }

    if ( lpTempEntry )
        LocalFree( lpTempEntry );

    return NO_ERROR;
}


DWORD
NwNdsReadAttrDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_NAMES_DEFS
    IN OUT HANDLE * lphOperationData OPTIONAL )
/*
   NwNdsReadAttrDef()

   This function is used to read attribute definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined attribute name(s) in the schema or
                        read both the attribute name(s) and definition(s)
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attribute names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_ATTR_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all attributes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                            NwNdsGetAttrDefListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                            NwNdsGetAttrDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    if ( hTree == NULL ||
         ((LPNDS_OBJECT_PRIV) hTree)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL ) // If TRUE, we need to read all attr defs
        return ReadAttrDef_AllAttrs( hTree,
                                     dwInformationType,
                                     lphOperationData );
    else // Else, we read the attr definitions specified in lphOperationData
        return ReadAttrDef_SomeAttrs( hTree,
                                      dwInformationType,
                                      lphOperationData );
}


DWORD
NwNdsReadClassDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES,
                                       // NDS_INFO_NAMES_DEFS,
                                       // NDS_CLASS_INFO_EXPANDED_DEFS,
                                       // or NDS_CLASS_INFO
    IN OUT HANDLE * lphOperationData OPTIONAL )
/*
   NwNdsReadClassDef()

   This function is used to read class definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined class name(s) in the schema or
                        read both the class name(s) and definition(s)
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of class names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_CLASS_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all classes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Class read results can be retrieved from the
                        buffer with the functions:
                            NwNdsGetClassDefListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                            NwNdsGetClassDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    if ( hTree == NULL ||
         ((LPNDS_OBJECT_PRIV) hTree)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL ) // If TRUE, we need to read all class defs
        return ReadClassDef_AllClasses( hTree,
                                        dwInformationType,
                                        lphOperationData );
    else // Else, we read the class definitions specified in lphOperationData
        return ReadClassDef_SomeClasses( hTree,
                                         dwInformationType,
                                         lphOperationData );
}


DWORD
NwNdsReadObject(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_ATTR_NAMES_VALUES
    IN OUT HANDLE * lphOperationData OPTIONAL )
/*
   NwNdsReadObject()

   This function is used to read attributes about an object of an NDS
   directory tree.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the attribute name(s) on the object or
                        read both the attribute name(s) and value(s)
                        from the object.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        object hObject. This handle is manipulated by the
                        following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_READ),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from object
                        hObject.

                        If these calls are successful, this pointer will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                           NwNdsGetAttrListFromBuffer

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                           NwNdsGetAttrListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    if ( hObject == NULL ||
         ((LPNDS_OBJECT_PRIV) hObject)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL ) // If TRUE, we need to read all attributes
        return ReadObject_AllAttrs( hObject,
                                    dwInformationType,
                                    lphOperationData );
    else // Else, we read the attributes specified in lphOperationData
        return ReadObject_SomeAttrs( hObject,
                                     dwInformationType,
                                     lphOperationData );
}


DWORD
NwNdsRemoveObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName )
/*
   NwNdsRemoveObject()

   This function is used to remove a leaf object from an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to remove leaf object from.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the leaf object
                        to be removed.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD    nwstatus;
    DWORD    status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    DWORD    dwReplyLength;
    BYTE     NdsReply[TWO_KB]; // A 2K buffer is plenty for a response
    LPNDS_OBJECT_PRIV lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    LPNDS_OBJECT_PRIV lpNdsObject = NULL;
    LPWSTR   szFullObjectDN = NULL;
    LPWSTR   szTempStr = NULL;
    DWORD    length;
    UNICODE_STRING ObjectName;

    if (  szObjectName == NULL ||
          lpNdsParentObject == NULL ||
          lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ObjectName, szObjectName );

    //
    // Create a buffer to hold the full object distinguished name.
    // \\tree\<--Object Name-->.<existing container path, if any>
    //
    szFullObjectDN = (LPWSTR) LocalAlloc(
                               LPTR,
                               ( wcslen( lpNdsParentObject->szContainerName ) *
                                 sizeof(WCHAR) ) +     // Container name
                                 ObjectName.Length +     // Object name
                                 ( 2 * sizeof(WCHAR) ) ); // Extras

    //
    // Check that the memory allocation was successful.
    //
    if ( szFullObjectDN == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRemoveObject LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_TREE_NAME );

    length /= sizeof(WCHAR);

    wcscpy( szFullObjectDN, L"\\\\" );              // <\\>
    wcsncat( szFullObjectDN, szTempStr, length );   // <\\tree>
    wcscat( szFullObjectDN, L"\\" );                // <\\tree\>
    wcsncat( szFullObjectDN, ObjectName.Buffer,
             ObjectName.Length );                   // <\\tree\obj>

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_PATH_NAME );

    if ( length > 0 )
    {
        length /= sizeof(WCHAR);
        wcscat( szFullObjectDN, L"." );              // <\\tree\obj.>
        wcsncat( szFullObjectDN, szTempStr, length );// <\\tree\obj.org_unt.org>
    }

    status = NwNdsOpenObject( szFullObjectDN,
                              NULL,
                              NULL,
                              (HANDLE *) &lpNdsObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status != NO_ERROR )
    {
        // NwNdsOpenObject will have already set the last error . . .
        goto ErrorExit;
    }

    (void) LocalFree( szFullObjectDN );
    szFullObjectDN = NULL;

    ntstatus =
        FragExWithWait(
                        lpNdsParentObject->NdsTree,
                        NETWARE_NDS_FUNCTION_REMOVE_OBJECT,
                        NdsReply,           // Response buffer.
                        sizeof(NdsReply), // Size of response buffer.
                        &dwReplyLength,     // Length of response returned.
                        "DD",           // Going to send 2 DWORDs, they are ...
                        0,                         // Version
                        lpNdsObject->ObjectId // The id of the object
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRemoveObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    lpNdsObject = NULL;

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRemoveObject: The remove object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;


ErrorExit :

    if ( szFullObjectDN )
    {
        (void) LocalFree( szFullObjectDN );
    }

    if ( lpNdsObject )
    {
        (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    }

    return (DWORD) UNSUCCESSFUL;
}


DWORD
NwNdsRenameObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  LPWSTR szNewObjectName,
    IN  BOOL   fDeleteOldName )
/*
   NwNdsRenameObject()

   This function is used to rename an object in a NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to rename leaf object in.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the object to be
                        renamed.

       LPWSTR           szNewObjectName - The new directory name of the object.

       BOOL             fDeleteOldName - If true, the old name is discarded;
                        Otherwise, the old name is retained as an additional
                        attribute.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD    nwstatus;
    DWORD    status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    DWORD    dwReplyLength;
    BYTE     NdsReply[TWO_KB]; // A 2K buffer is plenty for a response
    LPNDS_OBJECT_PRIV lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    LPNDS_OBJECT_PRIV lpNdsObject = NULL;
    LPWSTR   szFullObjectDN = NULL;
    LPWSTR   szTempStr = NULL;
    DWORD    length;
    UNICODE_STRING ObjectName;
    UNICODE_STRING NewObjectName;

    if (  szObjectName == NULL ||
          szNewObjectName == NULL ||
          lpNdsParentObject == NULL ||
          lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ObjectName, szObjectName );
    RtlInitUnicodeString( &NewObjectName, szNewObjectName );

    //
    // Create a buffer to hold the full object distinguished name.
    // \\tree\<--Object Name-->.<existing container path, if any>
    //
    szFullObjectDN = (LPWSTR) LocalAlloc(
                               LPTR,
                               ( wcslen( lpNdsParentObject->szContainerName ) *
                                 sizeof(WCHAR) ) +     // Container name
                                 ObjectName.Length +     // Object name
                                 ( 2 * sizeof(WCHAR) ) ); // Extras

    //
    // Check that the memory allocation was successful.
    //
    if ( szFullObjectDN == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRenameObject LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_TREE_NAME );

    length /= sizeof(WCHAR);

    wcscpy( szFullObjectDN, L"\\\\" );              // <\\>
    wcsncat( szFullObjectDN, szTempStr, length );   // <\\tree>
    wcscat( szFullObjectDN, L"\\" );                // <\\tree\>
    wcsncat( szFullObjectDN, ObjectName.Buffer,
             ObjectName.Length );                   // <\\tree\obj>

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_PATH_NAME );

    if ( length > 0 )
    {
        length /= sizeof(WCHAR);
        wcscat( szFullObjectDN, L"." );              // <\\tree\obj.>
        wcsncat( szFullObjectDN, szTempStr, length );// <\\tree\obj.org_unt.org>
    }

    status = NwNdsOpenObject( szFullObjectDN,
                              NULL,
                              NULL,
                              (HANDLE *) &lpNdsObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status != NO_ERROR )
    {
        // NwNdsOpenObject will have already set the last error . . .
        goto ErrorExit;
    }

    (void) LocalFree( szFullObjectDN );
    szFullObjectDN = NULL;

    ntstatus =
        FragExWithWait(
                        lpNdsParentObject->NdsTree,
                        NETWARE_NDS_FUNCTION_MODIFY_RDN,
                        NdsReply,           // Response buffer.
                        sizeof(NdsReply),   // Size of response buffer.
                        &dwReplyLength,     // Length of response returned.
                        "DDDS",
                        0x00000000,         // Version
                        lpNdsObject->ObjectId,
                        fDeleteOldName ? 0x00021701 : 0x00021700,
                        &NewObjectName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRenameObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    lpNdsObject = NULL;

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRenameObject: The rename object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;


ErrorExit :

    if ( szFullObjectDN )
    {
        (void) LocalFree( szFullObjectDN );
    }

    if ( lpNdsObject )
    {
        (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    }

    return (DWORD) UNSUCCESSFUL;
}


DWORD
NwNdsSearch(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType, // NDS_INFO_NAMES
                                           // or NDS_INFO_ATTR_NAMES_VALUES
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData )
/*
   NwNdsSearch()

   This function is used to query an NDS directory tree to find objects of
   a certain object type that match a specified search filter.

   Arguments:

       HANDLE           hStartFromObject - A HANDLE to an object in the
                        directory tree to start search from. Handle is
                        obtained by calling NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the attribute name(s) on the search result
                        objects or read both the attribute name(s) and value(s)
                        from the search result objects.

       DWORD            dwScope -
                        NDS_SCOPE_ONE_LEVEL - Search subordinates from given
                                              object, one level only
                        NDS_SCOPE_SUB_TREE - Search from given object on down
                        NDS_SCOPE_BASE_LEVEL - Applies search to an object

       BOOL             fDerefAliases - If TRUE the search will dereference
                        aliased objects to the real objects and continue
                        to search in the aliased objects subtree. If FALSE
                        the search will not dereference aliases.

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a
                        search tree which defines a query. This tree
                        is manipulated by the following functions:
                           NwNdsCreateQueryNode, NwNdsDeleteQueryNode,
                           and NwNdsDeleteQueryTree.

       LPDWORD          lpdwIterHandle - A pointer to a DWORD that has the
                        iteration handle value. On input, the handle value
                        is set to NDS_INITIAL_SEARCH or to a value previously
                        returned from a prior call to NwNdsSearch. On ouput,
                        the handle value is set to NDS_NO_MORE_ITERATIONS if
                        search is complete, or to some other value otherwise.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        objects that meet the search query. This handle is
                        manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_SEARCH),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from the
                        search objects found.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Object information with attribute information
                        can be retrieved from the buffer with the function:
                           NwNdsGetObjectListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                          NwNdsGetObjectListFromBuffer,
                          and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD dwNdsScope = NDS_SEARCH_SUBTREE;

    switch ( dwScope )
    {
        case NDS_SCOPE_ONE_LEVEL :
            dwNdsScope = NDS_SEARCH_SUBORDINATES;
            break;

        case NDS_SCOPE_SUB_TREE :
            dwNdsScope = NDS_SEARCH_SUBTREE;
            break;

        case NDS_SCOPE_BASE_LEVEL :
            dwNdsScope = NDS_SEARCH_ENTRY;
            break;
    }

    if ( hStartFromObject == NULL ||
         lpQueryTree == NULL ||
         lpdwIterHandle == NULL ||
         ((LPNDS_OBJECT_PRIV) hStartFromObject)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL )
    {
        //
        // The callee is asking for all attributes to be returned from search.
        //
        return Search_AllAttrs( hStartFromObject,
                                dwInformationType,
                                dwNdsScope,
                                fDerefAliases,
                                lpQueryTree,
                                lpdwIterHandle,
                                lphOperationData );
    }
    else if ( ((LPNDS_BUFFER) *lphOperationData)->lpRequestBuffer == NULL )
    {
        //
        // The callee has a handle from a prior call to NwNdsSearch, and is
        // still asking for all attributes to be returned from search.
        //
        return Search_AllAttrs( hStartFromObject,
                                dwInformationType,
                                dwNdsScope,
                                fDerefAliases,
                                lpQueryTree,
                                lpdwIterHandle,
                                lphOperationData );
    }
    else
    {
        //
        // The callee has a handle that they created with calls to
        // NwNdsCreateBuffer and NwNdsPutInBuffer to specify attributes
        // to be returned from search or NwNdsSearch was called once before
        // and we are resuming the search.
        //
        return Search_SomeAttrs( hStartFromObject,
                                 dwInformationType,
                                 dwNdsScope,
                                 fDerefAliases,
                                 lpQueryTree,
                                 lpdwIterHandle,
                                 lphOperationData );
    }
}


/* Local Function Implementations */

VOID
PrepareAddEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpTempEntry;
    DWORD  dwStringLen = AttributeName.Length + sizeof(WCHAR);
    DWORD  dwPadLen = ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD ) -
                      dwStringLen;

    *lpdwLengthInBytes = 0;

    //
    // tommye - MS bug 71653 - added try/except wrapper
    //

    try {

        //
        // Write attribute name length to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwStringLen;
        *lpdwLengthInBytes += sizeof(DWORD);
        lpTemp += sizeof(DWORD);

        //
        // Write attribute name to temp entry buffer.
        //
        RtlCopyMemory( lpTemp, AttributeName.Buffer, AttributeName.Length );
        *lpdwLengthInBytes += AttributeName.Length;
        lpTemp += AttributeName.Length;

        //
        // Add the null character.
        //
        * (LPWSTR) lpTemp = L'\0';
        *lpdwLengthInBytes += sizeof(WCHAR);
        lpTemp += sizeof(WCHAR);

        //
        // Write padding (if needed) to temp entry buffer.
        //
        if ( dwPadLen )
        {
            RtlZeroMemory( lpTemp, dwPadLen );
            lpTemp += dwPadLen;
            *lpdwLengthInBytes += dwPadLen;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return;
    }

    //
    // Now add the value(s) to temp entry.
    //
    AppendValueToEntry( lpTemp,
                        dwSyntaxID,
                        lpAttributeValues,
                        dwValueCount,
                        lpdwLengthInBytes );
}


VOID
PrepareModifyEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    DWORD          dwAttrModificationOperation,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpTempEntry;
    DWORD  dwStringLen = AttributeName.Length + sizeof(WCHAR);
    DWORD  dwPadLen = ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD ) -
                      dwStringLen;

    *lpdwLengthInBytes = 0;

    //
    // tommye - MS bug 71654 - added try/except wrapper
    //

    try {

        //
        // Write attribute modification operation to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwAttrModificationOperation;
        lpTemp += sizeof(DWORD);
        *lpdwLengthInBytes += sizeof(DWORD);

        //
        // Write attribute name length to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwStringLen;
        *lpdwLengthInBytes += sizeof(DWORD);
        lpTemp += sizeof(DWORD);

        //
        // Write attribute name to temp entry buffer.
        //
        RtlCopyMemory( lpTemp, AttributeName.Buffer, AttributeName.Length );
        *lpdwLengthInBytes += AttributeName.Length;
        lpTemp += AttributeName.Length;

        //
        // Add the null character.
        //
        * (LPWSTR) lpTemp = L'\0';
        *lpdwLengthInBytes += sizeof(WCHAR);
        lpTemp += sizeof(WCHAR);

        //
        // Write padding (if needed) to temp entry buffer.
        //
        if ( dwPadLen )
        {
            RtlZeroMemory( lpTemp, dwPadLen );
            lpTemp += dwPadLen;
            *lpdwLengthInBytes += dwPadLen;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return;
    }

    //
    // Now add the value(s) to temp entry (if needed).
    //
    switch( dwAttrModificationOperation )
    {
        case NDS_ATTR_ADD_VALUE:
        case NDS_ATTR_ADDITIONAL_VALUE:
        case NDS_ATTR_OVERWRITE_VALUE:
        case NDS_ATTR_REMOVE_VALUE:
        case NDS_ATTR_CLEAR_VALUE:
        case NDS_ATTR_ADD:
            AppendValueToEntry( lpTemp,
                                dwSyntaxID,
                                lpAttributeValues,
                                dwValueCount,
                                lpdwLengthInBytes );
            break;

        case NDS_ATTR_REMOVE:
        case NDS_ATTR_CLEAR:
            // Don't need to do anything for these modification operations.
            break;

        default :
#if DBG
            KdPrint(( "NDS32: PrepareModifyEntry warning, unknown modification operation 0x%.8X\n", dwAttrModificationOperation ));
            ASSERT( FALSE );
#endif
            ; // Nothing, skip it.
    }
}


VOID
PrepareReadEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    LPDWORD        lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpTempEntry;
    DWORD  dwStringLen = AttributeName.Length + sizeof(WCHAR);
    DWORD  dwPadLen = ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD ) -
                      dwStringLen;

    *lpdwLengthInBytes = 0;

    //
    // tommye - MS bug 71655 - added try/except wrapper
    //

    try {
        //
        // Write attribute name length to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwStringLen;
        *lpdwLengthInBytes += sizeof(DWORD);
        lpTemp += sizeof(DWORD);

        //
        // Write attribute name to temp entry buffer.
        //
        RtlCopyMemory( lpTemp, AttributeName.Buffer, AttributeName.Length );
        *lpdwLengthInBytes += AttributeName.Length;
        lpTemp += AttributeName.Length;

        //
        // Add the null character.
        //
        * (LPWSTR) lpTemp = L'\0';
        *lpdwLengthInBytes += sizeof(WCHAR);
        lpTemp += sizeof(WCHAR);

        //
        // Write padding (if needed) to temp entry buffer.
        //
        if ( dwPadLen )
        {
            RtlZeroMemory( lpTemp, dwPadLen );
            lpTemp += dwPadLen;
            *lpdwLengthInBytes += dwPadLen;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return;
    }
}


DWORD
CalculateValueDataSize(
    DWORD           dwSyntaxId,
    LPBYTE          lpAttributeValues,
    DWORD           dwValueCount )
{
    LPBYTE lpAttrStart, lpAttrTemp = lpAttributeValues;
    LPBYTE lpField1, lpField2;
    DWORD  numFields;
    DWORD  length = 0;
    DWORD  stringLen, stringLen2;
    DWORD  iter, i;
    DWORD  dwLengthInBytes = 0;

    dwLengthInBytes += sizeof(DWORD);

    for ( iter = 0; iter < dwValueCount; iter++ )
    {
        switch ( dwSyntaxId )
        {
            case NDS_SYNTAX_ID_0 :
                break;

            case NDS_SYNTAX_ID_1 :
            case NDS_SYNTAX_ID_2 :
            case NDS_SYNTAX_ID_3 :
            case NDS_SYNTAX_ID_4 :
            case NDS_SYNTAX_ID_5 :
            case NDS_SYNTAX_ID_10 :
            case NDS_SYNTAX_ID_20 :

                stringLen = wcslen(((LPASN1_TYPE_1) lpAttrTemp)->DNString);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_1);
                break;

            case NDS_SYNTAX_ID_6 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrStart = lpAttrTemp;
                while(  ((LPASN1_TYPE_6) lpAttrTemp)->Next )
                {
                    stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);
                    dwLengthInBytes += sizeof(DWORD);
                    dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_6) lpAttrTemp)->Next);
                }
                stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD);
                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_6);
                break;

            case NDS_SYNTAX_ID_7 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_7);
                break;

            case NDS_SYNTAX_ID_8 :
            case NDS_SYNTAX_ID_22 :
            case NDS_SYNTAX_ID_24 :
            case NDS_SYNTAX_ID_27 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_8);
                break;

            case NDS_SYNTAX_ID_9 :

                stringLen = ((LPASN1_TYPE_9) lpAttrTemp)->Length;
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen)*sizeof(BYTE),
                                                     ALIGN_DWORD );
                lpAttrTemp += sizeof(ASN1_TYPE_9);
                break;

            case NDS_SYNTAX_ID_11 :

                stringLen = wcslen(((LPASN1_TYPE_11) lpAttrTemp)->TelephoneNumber);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD );
                dwLengthInBytes += 2*sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_11);
                break;

            case NDS_SYNTAX_ID_12 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ((LPASN1_TYPE_12)
                    lpAttrTemp)->AddressLength * sizeof(WCHAR);
                lpAttrTemp += sizeof(ASN1_TYPE_12);
                break;

            case NDS_SYNTAX_ID_13 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrStart = lpAttrTemp;
                while ( ((LPASN1_TYPE_13) lpAttrTemp)->Next )
                {
                    stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;
                    dwLengthInBytes += sizeof(DWORD);
                    dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(BYTE),
                                                         ALIGN_DWORD);
                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_13) lpAttrTemp)->Next);
                }
                stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(BYTE),
                                                     ALIGN_DWORD);
                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_13);
                break;

            case NDS_SYNTAX_ID_14 :

                stringLen = wcslen(((LPASN1_TYPE_14) lpAttrTemp)->Address);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_14);
                break;

            case NDS_SYNTAX_ID_15 :

                stringLen = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->VolumeName);
                stringLen2 = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->Path);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_15);
                break;

            case NDS_SYNTAX_ID_16 :

                stringLen = wcslen(((LPASN1_TYPE_16) lpAttrTemp)->ServerName);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_16);

                break;

            case NDS_SYNTAX_ID_17 :

                stringLen = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->ProtectedAttrName);
                stringLen2 = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->SubjectName);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_17);
                break;

            case NDS_SYNTAX_ID_18 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                for ( i = 0; i < 6; i++ )
                {
                    stringLen = wcslen(((LPASN1_TYPE_18) lpAttrTemp)->PostalAddress[i]);
                    dwLengthInBytes += sizeof(DWORD);
                    dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                }
                lpAttrTemp += sizeof(ASN1_TYPE_18);
                break;

            case NDS_SYNTAX_ID_19 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_19);
                break;

            case NDS_SYNTAX_ID_21 :

                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_21);
                break;

            case NDS_SYNTAX_ID_23 :
                break;

            case NDS_SYNTAX_ID_25 :

                stringLen = wcslen(((LPASN1_TYPE_25) lpAttrTemp)->ObjectName);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_25);
                break;

            case NDS_SYNTAX_ID_26 :
                break;

            default :
#if DBG
                KdPrint(( "NDS32: CalculateValueDataSize() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif
                break;  // empty statement not allowed
        }
    }

    return dwLengthInBytes;
}


VOID
AppendValueToEntry(
    LPBYTE          lpBuffer,
    DWORD           dwSyntaxId,
    LPBYTE          lpAttributeValues,
    DWORD           dwValueCount,
    LPDWORD         lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpBuffer;
    LPBYTE lpAttrStart, lpAttrTemp = lpAttributeValues;
    LPBYTE lpField1, lpField2;
    DWORD  numFields;
    DWORD  length = 0;
    DWORD  stringLen, stringLen2;
    DWORD  iter, i;

    *(LPDWORD)lpTemp = dwValueCount;
    lpTemp += sizeof(DWORD);
    *lpdwLengthInBytes += sizeof(DWORD);

    for ( iter = 0; iter < dwValueCount; iter++ )
    {
        switch ( dwSyntaxId )
        {
            case NDS_SYNTAX_ID_0 :
                break;

            case NDS_SYNTAX_ID_1 :
            case NDS_SYNTAX_ID_2 :
            case NDS_SYNTAX_ID_3 :
            case NDS_SYNTAX_ID_4 :
            case NDS_SYNTAX_ID_5 :
            case NDS_SYNTAX_ID_10 :
            case NDS_SYNTAX_ID_20 :

                stringLen = wcslen(((LPASN1_TYPE_1) lpAttrTemp)->DNString);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_1) lpAttrTemp)->DNString,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_1);
                break;

            case NDS_SYNTAX_ID_6 :

                lpField1 = lpTemp; // Save field to store the number of
                                   // bytes following
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 = 0;

                lpField2 = lpTemp; // Save field to store the number of
                                       // elements
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                numFields = 0;

                lpAttrStart = lpAttrTemp;

                while(  ((LPASN1_TYPE_6) lpAttrTemp)->Next )
                {
                    stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    *lpdwLengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpField1 += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   ((LPASN1_TYPE_6) lpAttrTemp)->String,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                             ALIGN_DWORD);
                    *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                    *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                           ALIGN_DWORD);

                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_6) lpAttrTemp)->Next);

                    numFields++;
                }

                stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_6) lpAttrTemp)->String,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD);
                *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_6);

                numFields++;

                *(LPDWORD)lpField2 = numFields;

                break;

            case NDS_SYNTAX_ID_7 :

                *(LPDWORD)lpTemp = 1; // Needs to have value 1, representing one byte even though it is
                                      // padded out to four bytes.
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = 0; // This clears all bits of the DWORD
                *(LPBYTE)lpTemp = (BYTE) (((LPASN1_TYPE_7)
                                                lpAttrTemp)->Boolean);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_7);

                break;

            case NDS_SYNTAX_ID_8 :
            case NDS_SYNTAX_ID_22 :
            case NDS_SYNTAX_ID_24 :
            case NDS_SYNTAX_ID_27 :

                *(LPDWORD)lpTemp = 4; // Needs to have value 4, representing four bytes - already DWORD aligned.
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_8) lpAttrTemp)->Integer;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_8);

                break;

            case NDS_SYNTAX_ID_9 :

                stringLen = ((LPASN1_TYPE_9) lpAttrTemp)->Length;

                *(LPDWORD)lpTemp = (stringLen)  * sizeof(BYTE);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_9) lpAttrTemp)->OctetString,
                               stringLen*sizeof(BYTE) );
                lpTemp += ROUND_UP_COUNT((stringLen)*sizeof(BYTE),
                                         ALIGN_DWORD );
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen)*sizeof(BYTE),
                                                     ALIGN_DWORD );

                lpAttrTemp += sizeof(ASN1_TYPE_9);

                break;

            case NDS_SYNTAX_ID_11 :

                stringLen = wcslen(((LPASN1_TYPE_11) lpAttrTemp)->TelephoneNumber);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                    ALIGN_DWORD) +
                                     ( 2*sizeof(DWORD) );
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_11) lpAttrTemp)->TelephoneNumber,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD );

                lpTemp += 2*sizeof(DWORD);
                *lpdwLengthInBytes += 2*sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_11);

                break;

            case NDS_SYNTAX_ID_12 :

                *(LPDWORD)lpTemp =
                     (2*sizeof(DWORD)) +
                     (((LPASN1_TYPE_12) lpAttrTemp)->AddressLength*sizeof(WCHAR));
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_12) lpAttrTemp)->AddressType;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                //
                // Write address length value to buffer
                //
                *(LPDWORD)lpTemp = ((LPASN1_TYPE_12) lpAttrTemp)->AddressLength;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                //
                // Write the address to the buffer
                //
                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_12) lpAttrTemp)->Address,
                               ((LPASN1_TYPE_12) lpAttrTemp)->AddressLength
                               * sizeof(WCHAR) );
                lpTemp += ((LPASN1_TYPE_12) lpAttrTemp)->AddressLength *
                          sizeof(WCHAR);
                *lpdwLengthInBytes += ((LPASN1_TYPE_12)
                    lpAttrTemp)->AddressLength * sizeof(WCHAR);

                lpAttrTemp += sizeof(ASN1_TYPE_12);

                break;

            case NDS_SYNTAX_ID_13 :

                lpField1 = lpTemp; // Save field to store the number of
                                   // bytes following
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 = 0;

                lpField2 = lpTemp; // Save field to store the number of
                                       // elements
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                numFields = 0;

                lpAttrStart = lpAttrTemp;

                while ( ((LPASN1_TYPE_13) lpAttrTemp)->Next )
                {
                    stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;

                    *(LPDWORD)lpTemp = stringLen;
                    lpTemp += sizeof(DWORD);
                    *lpdwLengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpField1 += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   ((LPASN1_TYPE_13) lpAttrTemp)->Data,
                                   stringLen*sizeof(BYTE) );
                    lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(BYTE),
                                             ALIGN_DWORD);
                    *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(BYTE),
                                                         ALIGN_DWORD);
                    *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(BYTE),
                                                         ALIGN_DWORD);

                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_13) lpAttrTemp)->Next);

                    numFields++;
                }

                stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;

                *(LPDWORD)lpTemp = stringLen;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_13) lpAttrTemp)->Data,
                               stringLen*sizeof(BYTE) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(BYTE),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(BYTE),
                                                     ALIGN_DWORD);
                *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(BYTE),
                                                     ALIGN_DWORD);

                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_13);

                numFields++;

                *(LPDWORD)lpField2 = numFields;

                break;

            case NDS_SYNTAX_ID_14 :

                stringLen = wcslen(((LPASN1_TYPE_14) lpAttrTemp)->Address);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_14) lpAttrTemp)->Type;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1)*sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_14) lpAttrTemp)->Address,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_14);

                break;

            case NDS_SYNTAX_ID_15 :

                stringLen = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->VolumeName);
                stringLen2 = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->Path);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_15) lpAttrTemp)->Type;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen+1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_15) lpAttrTemp)->VolumeName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = (stringLen2+1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_15) lpAttrTemp)->Path,
                               stringLen2*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_15);

                break;

            case NDS_SYNTAX_ID_16 :

                stringLen = wcslen(((LPASN1_TYPE_16) lpAttrTemp)->ServerName);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                                  (4*sizeof(DWORD));
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_16) lpAttrTemp)->ServerName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_16) lpAttrTemp)->ReplicaType;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_16) lpAttrTemp)->ReplicaNumber;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_16) lpAttrTemp)->Count;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_16);

                break;

            case NDS_SYNTAX_ID_17 :

                stringLen = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->ProtectedAttrName);
                stringLen2 = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->SubjectName);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                    ALIGN_DWORD) +
                                     ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                    ALIGN_DWORD) +
                                     sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_17)lpAttrTemp)->ProtectedAttrName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = (stringLen2 + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_17) lpAttrTemp)->SubjectName,
                               stringLen2*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_17) lpAttrTemp)->Privileges;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_17);

                break;

            case NDS_SYNTAX_ID_18 :

                lpField1 = lpTemp; // Save field to store the number of
                                   // bytes following
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 = 0;

                *(LPDWORD)lpTemp = 6; // The number of postal address fields
                                      // is always six.
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                for ( i = 0; i < 6; i++ )
                {
                    stringLen = wcslen(((LPASN1_TYPE_18) lpAttrTemp)->PostalAddress[i]);

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    *lpdwLengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpField1 += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   ((LPASN1_TYPE_18) lpAttrTemp)->PostalAddress[i],
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                             ALIGN_DWORD);
                    *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                    *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                }

                lpAttrTemp += sizeof(ASN1_TYPE_18);

                break;

            case NDS_SYNTAX_ID_19 :

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_19) lpAttrTemp)->WholeSeconds;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_19) lpAttrTemp)->EventID;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_19);

                break;

            case NDS_SYNTAX_ID_21 :

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_21) lpAttrTemp)->Length;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_21);

                break;

            case NDS_SYNTAX_ID_23 :
                break;

            case NDS_SYNTAX_ID_25 :

                stringLen = wcslen(((LPASN1_TYPE_25) lpAttrTemp)->ObjectName);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   2*sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_25) lpAttrTemp)->ObjectName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_25) lpAttrTemp)->Level;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_25) lpAttrTemp)->Interval;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_25);

                break;

            case NDS_SYNTAX_ID_26 :
                break;

            default :
#if DBG
                KdPrint(( "NDS32: AppendValueToEntry() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif
                break;  // empty statement not allowed
        }
    }
}


DWORD
MapNetwareErrorCode(
    DWORD dwNetwareError )
{
    DWORD status = NO_ERROR;

    switch( dwNetwareError )
    {
        case NDS_ERR_SUCCESS :
            status = NO_ERROR;
            break;

        case NDS_ERR_NO_SUCH_ENTRY :
        case NDS_ERR_NO_SUCH_VALUE :
        case NDS_ERR_NO_SUCH_ATTRIBUTE :
        case NDS_ERR_NO_SUCH_CLASS :
        case NDS_ERR_NO_SUCH_PARTITION :
            status = ERROR_EXTENDED_ERROR;
            break;

        case NDS_ERR_ENTRY_ALREADY_EXISTS :
            status = ERROR_ALREADY_EXISTS;
            break;

        case NDS_ERR_NOT_EFFECTIVE_CLASS :
        case NDS_ERR_ILLEGAL_ATTRIBUTE :
        case NDS_ERR_MISSING_MANDATORY :
        case NDS_ERR_ILLEGAL_DS_NAME :
        case NDS_ERR_ILLEGAL_CONTAINMENT :
        case NDS_ERR_CANT_HAVE_MULTIPLE_VALUES :
        case NDS_ERR_SYNTAX_VIOLATION :
        case NDS_ERR_DUPLICATE_VALUE :
        case NDS_ERR_ATTRIBUTE_ALREADY_EXISTS :
        case NDS_ERR_MAXIMUM_ENTRIES_EXIST :
        case NDS_ERR_DATABASE_FORMAT :
        case NDS_ERR_INCONSISTANT_DATABASE :
        case NDS_ERR_INVALID_COMPARISON :
        case NDS_ERR_COMPARISON_FAILED :
        case NDS_ERR_TRANSACTIONS_DISABLED :
        case NDS_ERR_INVALID_TRANSPORT :
        case NDS_ERR_SYNTAX_INVALID_IN_NAME :
        case NDS_ERR_REPLICA_ALREADY_EXISTS :
        case NDS_ERR_TRANSPORT_FAILURE :
        case NDS_ERR_ALL_REFERRALS_FAILED :
        case NDS_ERR_CANT_REMOVE_NAMING_VALUE :
        case NDS_ERR_OBJECT_CLASS_VIOLATION :
        case NDS_ERR_ENTRY_IS_NOT_LEAF :
        case NDS_ERR_DIFFERENT_TREE :
        case NDS_ERR_ILLEGAL_REPLICA_TYPE :
        case NDS_ERR_SYSTEM_FAILURE :
        case NDS_ERR_INVALID_ENTRY_FOR_ROOT :
        case NDS_ERR_NO_REFERRALS :
        case NDS_ERR_REMOTE_FAILURE :
        case NDS_ERR_INVALID_REQUEST :
        case NDS_ERR_INVALID_ITERATION :
        case NDS_ERR_SCHEMA_IS_NONREMOVABLE :
        case NDS_ERR_SCHEMA_IS_IN_USE :
        case NDS_ERR_CLASS_ALREADY_EXISTS :
        case NDS_ERR_BAD_NAMING_ATTRIBUTES :
        case NDS_ERR_NOT_ROOT_PARTITION :
        case NDS_ERR_INSUFFICIENT_STACK :
        case NDS_ERR_INSUFFICIENT_BUFFER :
        case NDS_ERR_AMBIGUOUS_CONTAINMENT :
        case NDS_ERR_AMBIGUOUS_NAMING :
        case NDS_ERR_DUPLICATE_MANDATORY :
        case NDS_ERR_DUPLICATE_OPTIONAL :
        case NDS_ERR_MULTIPLE_REPLICAS :
        case NDS_ERR_CRUCIAL_REPLICA :
        case NDS_ERR_SCHEMA_SYNC_IN_PROGRESS :
        case NDS_ERR_SKULK_IN_PROGRESS :
        case NDS_ERR_TIME_NOT_SYNCRONIZED :
        case NDS_ERR_RECORD_IN_USE :
        case NDS_ERR_DS_VOLUME_NOT_MOUNTED :
        case NDS_ERR_DS_VOLUME_IO_FAILURE :
        case NDS_ERR_DS_LOCKED :
        case NDS_ERR_OLD_EPOCH :
        case NDS_ERR_NEW_EPOCH :
        case NDS_ERR_PARTITION_ROOT :
        case NDS_ERR_ENTRY_NOT_CONTAINER :
        case NDS_ERR_FAILED_AUTHENTICATION :
        case NDS_ERR_NO_SUCH_PARENT :
            status = ERROR_EXTENDED_ERROR;
            break;

        case NDS_ERR_NO_ACCESS :
            status = ERROR_ACCESS_DENIED;
            break;

        case NDS_ERR_REPLICA_NOT_ON :
        case NDS_ERR_DUPLICATE_ACL :
        case NDS_ERR_PARTITION_ALREADY_EXISTS :
        case NDS_ERR_NOT_SUBREF :
        case NDS_ERR_ALIAS_OF_AN_ALIAS :
        case NDS_ERR_AUDITING_FAILED :
        case NDS_ERR_INVALID_API_VERSION :
        case NDS_ERR_SECURE_NCP_VIOLATION :
        case NDS_ERR_FATAL :
            status = ERROR_EXTENDED_ERROR;
            break;

        default :
#if DBG
            KdPrint(( "NDS32: MapNetwareErrorCode failed, Netware error = 0x%.8X\n", dwNetwareError ));
            ASSERT( FALSE );
#endif

            status = ERROR_EXTENDED_ERROR;
    }

    return status;
}


DWORD
IndexReadAttrDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_ATTR_DEF lpReplyIndex = NULL;
    DWORD          iter;
    LPBYTE         lpByte = NULL;
    DWORD          dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_ATTR_DEF);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_ATTR_DEF)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadAttrDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the first attribute definition
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD);  // Move past Completion Code
    // lpByte += sizeof(DWORD);  // Move past Iteration Handle
    // lpByte += sizeof(DWORD);  // Move past Information Type
    // lpByte += sizeof(DWORD);  // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the reply buffer index and fill it up with
    // data by referencing the Reply buffer or Syntax buffer.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Attribute Name Length

        lpReplyIndex[iter].szAttributeName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpReplyIndex[iter].dwFlags = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Flags

        lpReplyIndex[iter].dwSyntaxID = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Syntax ID

        lpReplyIndex[iter].dwLowerLimit = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Lower Limit

        lpReplyIndex[iter].dwUpperLimit = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Upper Limit

        lpReplyIndex[iter].asn1ID.length = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past ASN.1 ID length

        RtlCopyMemory( lpReplyIndex[iter].asn1ID.data,
                       lpByte,
                       sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN );
        lpByte += sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN;

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_ATTR_DEF );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_ATTR_DEF );
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadAttrDefReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexReadClassDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_CLASS_DEF lpReplyIndex = NULL;
    DWORD           iter;
    LPBYTE          lpByte = NULL;
    DWORD           LengthOfValueStructs;
    DWORD           dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_CLASS_DEF);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_CLASS_DEF)
        LocalAlloc( LPTR,
                    lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the SyntaxId of the first attribute
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD); // Move past Completion Code
    // lpByte += sizeof(DWORD); // Move past Iteration Handle
    // lpByte += sizeof(DWORD); // Move past Information Type
    // lpByte += sizeof(DWORD); // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the index buffer and fill it up with
    // data by referencing the reply buffer. Note references to
    // the syntax buffer are stored as offsets while un-marshalling.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Class Name Length

        lpReplyIndex[iter].szClassName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpReplyIndex[iter].dwFlags = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Flags

        lpReplyIndex[iter].asn1ID.length = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past ASN.1 ID length

        RtlCopyMemory( lpReplyIndex[iter].asn1ID.data,
                       lpByte,
                       sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN );
        lpByte += sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN;

        lpReplyIndex[iter].dwNumberOfSuperClasses = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfSuperClasses > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfSuperClasses,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfSuperClasses,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpSuperClasses =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpSuperClasses = NULL;
        }

        lpReplyIndex[iter].dwNumberOfContainmentClasses = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfContainmentClasses > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfContainmentClasses,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) !=
                    NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfContainmentClasses,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpContainmentClasses =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpContainmentClasses = NULL;
        }

        lpReplyIndex[iter].dwNumberOfNamingAttributes = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfNamingAttributes > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfNamingAttributes,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfNamingAttributes,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpNamingAttributes =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpNamingAttributes = NULL;
        }

        lpReplyIndex[iter].dwNumberOfMandatoryAttributes = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfMandatoryAttributes > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfMandatoryAttributes,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfMandatoryAttributes,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpMandatoryAttributes =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpMandatoryAttributes = NULL;
        }

        lpReplyIndex[iter].dwNumberOfOptionalAttributes = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfOptionalAttributes > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfOptionalAttributes,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfOptionalAttributes,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpOptionalAttributes =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpOptionalAttributes = NULL;
        }

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_CLASS_DEF );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_CLASS_DEF );
    }

    //
    // Now convert all syntax buffer references to pointers.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
    {
        if ( lpReplyIndex[iter].dwNumberOfSuperClasses > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpSuperClasses +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfContainmentClasses > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpContainmentClasses +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfNamingAttributes > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpNamingAttributes +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfMandatoryAttributes > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpMandatoryAttributes +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfOptionalAttributes > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpOptionalAttributes +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadClassDefReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexReadObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_ATTR_INFO lpReplyIndex = NULL;
    DWORD           iter;
    LPBYTE          lpByte = NULL;
    DWORD           LengthOfValueStructs;
    DWORD           dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_ATTR_INFO);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_ATTR_INFO)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the SyntaxId of the first attribute
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD); // Move past Completion Code
    // lpByte += sizeof(DWORD); // Move past Iteration Handle
    // lpByte += sizeof(DWORD); // Move past Information Type
    // lpByte += sizeof(DWORD); // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the index buffer and fill it up with
    // data by referencing the reply buffer. Note references to
    // the syntax buffer are stored as offsets while un-marshalling.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        lpReplyIndex[iter].dwSyntaxId = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Syntax Id

        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Attribute Name Length

        lpReplyIndex[iter].szAttributeName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpReplyIndex[iter].dwNumberOfValues = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Count Of Values

        //
        // See if the syntax buffer is large enough to hold the number of
        // SyntaxID structures that will be used to store the value(s)
        // for the current attribute. If the buffer isn't large enough
        // it is reallocated to a bigger size (if possible).
        //
        if ( VerifyBufferSize( lpByte,
                               lpNdsBuffer->dwSyntaxAvailableBytes,
                               lpReplyIndex[iter].dwSyntaxId,
                               lpReplyIndex[iter].dwNumberOfValues,
                               &LengthOfValueStructs ) != NO_ERROR )
        {
            if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) != NO_ERROR )
            {
#if DBG
                KdPrint(( "NDS32: IndexReadObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }
        }

        //
        // Parse the raw data buffer by mapping the network structures to
        // the NDS Syntax structures we define in NdsSntx.h. Then move the
        // pointer used to walk the raw data buffer past the ASN.1 Values.
        //
        lpByte += ParseASN1ValueBlob( lpByte,
                                      lpReplyIndex[iter].dwSyntaxId,
                                      lpReplyIndex[iter].dwNumberOfValues,
                                      (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

        lpReplyIndex[iter].lpValue =
                (LPBYTE) lpNdsBuffer->dwLengthOfSyntaxData;
        lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
        lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_ATTR_INFO );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_ATTR_INFO );
    }

    //
    // Now convert all syntax buffer references to pointers.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
    {
        (LPBYTE) lpReplyIndex[iter].lpValue +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadObjectReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexReadNameReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_NAME_ONLY lpReplyIndex = NULL;
    DWORD           iter;
    LPBYTE          lpByte = NULL;
    DWORD           dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_NAME_ONLY);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_NAME_ONLY)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadNameReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the first name
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD);  // Move past Completion Code
    // lpByte += sizeof(DWORD);  // Move past Iteration Handle
    // lpByte += sizeof(DWORD);  // Move past Information Type
    // lpByte += sizeof(DWORD);  // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the reply buffer index and fill it up with
    // data by referencing the Reply buffer or Syntax buffer.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Attribute Name Length

        lpReplyIndex[iter].szName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_NAME_ONLY );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_NAME_ONLY );
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadNameReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexSearchObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_OBJECT_INFO lpReplyIndex = NULL;
    DWORD             iter;
    DWORD             iter2;
    LPBYTE            lpByte = NULL;
    DWORD             LengthOfValueStructs;
    DWORD             dwStringLen;
    LPBYTE            FixedPortion;
    LPWSTR            EndOfVariableData;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     ( sizeof(NDS_OBJECT_INFO) +
                                       ( MAX_NDS_NAME_CHARS * 4 *
                                         sizeof( WCHAR ) ) );
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_OBJECT_INFO)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    FixedPortion = lpNdsBuffer->lpIndexBuffer;
    EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                          ROUND_DOWN_COUNT(
                                  lpNdsBuffer->dwIndexAvailableBytes,
                                  ALIGN_DWORD ) );

    //
    // Move lpByte so that it points to the first object
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD);  // Move past Completion Code
    // lpByte += sizeof(DWORD);  // Move past Iteration Handle
    // lpByte += sizeof(DWORD);  // Move past Information Type
    // lpByte += sizeof(DWORD);  // Move past Amount Of Attributes
    // lpByte += sizeof(DWORD);  // Move past Length Of Search
    // lpByte += sizeof(DWORD);  // Move past Amount Of Entries
    lpByte += 6 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the reply buffer index and fill it up with
    // data by referencing the Reply buffer or Syntax buffer.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        WORD            tempStrLen;
        LPWSTR          newPathStr = NULL;
        LPWSTR          tempStr = NULL;
        LPWSTR          ClassName;
        LPWSTR          DistinguishedObjectName;
        LPWSTR          ObjectName;
        DWORD           ClassNameLen;
        DWORD           DistinguishedObjectNameLen;
        DWORD           Flags;
        DWORD           SubordinateCount;
        DWORD           ModificationTime;
        DWORD           NumberOfAttributes = 0;
        LPNDS_ATTR_INFO lpAttributeInfos = NULL;
        DWORD           EntryInfo1;

        //
        // Get current subtree data from lpNdsParentObject
        //
        lpByte = GetSearchResultData( lpByte,
                                      &Flags,
                                      &SubordinateCount,
                                      &ModificationTime,
                                      &ClassNameLen,
                                      &ClassName,
                                      &DistinguishedObjectNameLen,
                                      &DistinguishedObjectName,
                                      &EntryInfo1,
                                      &NumberOfAttributes );

        //
        // Need to build a string with the new NDS UNC path
        // for search object
        //
        newPathStr = (PVOID) LocalAlloc( LPTR,
                                         ( wcslen( DistinguishedObjectName ) +
                                           wcslen( lpNdsBuffer->szPath ) +
                                           3 ) * sizeof( WCHAR ) );

        if ( newPathStr == NULL )
        {
#if DBG
            KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }

        //
        // Need to build a string for the relative object name.
        //
        ObjectName = (PVOID) LocalAlloc( LPTR,
                                         ( wcslen( DistinguishedObjectName ) +
                                           1 ) * sizeof( WCHAR ) );

        if ( ObjectName == NULL )
        {
#if DBG
            KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }

        tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                      lpNdsBuffer->szPath,
                                      PARSE_NDS_GET_TREE_NAME );

        tempStrLen /= sizeof(WCHAR);

        if ( tempStrLen > 0 )
        {
            wcscpy( newPathStr, L"\\\\" );
            wcsncat( newPathStr, tempStr, tempStrLen );
            wcscat( newPathStr, L"\\" );
            wcscat( newPathStr, DistinguishedObjectName );
            _wcsupr( newPathStr );
        }
        else
        {
            wcscpy( newPathStr, L"" );
        }

        tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                      newPathStr,
                                      PARSE_NDS_GET_OBJECT_NAME );

        tempStrLen /= sizeof(WCHAR);

        if ( tempStrLen > 0 )
        {
            wcsncpy( ObjectName, tempStr, tempStrLen );
        }
        else
        {
            wcscpy( ObjectName, L"" );
        }

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_ATTR_NAMES_VALUES )
        {
          lpAttributeInfos = (LPNDS_ATTR_INFO) LocalAlloc(
                                                    LPTR,
                                                    NumberOfAttributes *
                                                    sizeof( NDS_ATTR_INFO )
                                                         );

          if ( lpAttributeInfos == NULL )
          {
#if DBG
              KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

              SetLastError( ERROR_NOT_ENOUGH_MEMORY );
              return (DWORD) UNSUCCESSFUL;
          }

          for ( iter2 = 0; iter2 < NumberOfAttributes; iter2++ )
          {
            lpAttributeInfos[iter2].dwSyntaxId = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Syntax Id

            dwStringLen = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Attribute Name Length

            lpAttributeInfos[iter2].szAttributeName = (LPWSTR) lpByte;
            lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

            lpAttributeInfos[iter2].dwNumberOfValues = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Count Of Values

            //
            // See if the syntax buffer is large enough to hold the number of
            // SyntaxID structures that will be used to store the value(s)
            // for the current attribute. If the buffer isn't large enough
            // it is reallocated to a bigger size (if possible).
            //
            if ( VerifyBufferSize( lpByte,
                                   lpNdsBuffer->dwSyntaxAvailableBytes,
                                   lpAttributeInfos[iter2].dwSyntaxId,
                                   lpAttributeInfos[iter2].dwNumberOfValues,
                                   &LengthOfValueStructs ) != NO_ERROR )
            {
                if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer, LengthOfValueStructs ) != NO_ERROR )
                {
#if DBG
                    KdPrint(( "NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    return (DWORD) UNSUCCESSFUL;
                }
            }

            //
            // Parse the raw data buffer by mapping the network structures to
            // the NDS Syntax structures we define in NdsSntx.h. Then move the
            // pointer used to walk the raw data buffer past the ASN.1 Values.
            //
            lpByte += ParseASN1ValueBlob( lpByte,
                                          lpAttributeInfos[iter2].dwSyntaxId,
                                          lpAttributeInfos[iter2].dwNumberOfValues,
                                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

            lpAttributeInfos[iter2].lpValue =
                      (LPBYTE) lpNdsBuffer->dwLengthOfSyntaxData;
            lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
            lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
          }
        }
        else
        {
          lpAttributeInfos = (LPNDS_ATTR_INFO) LocalAlloc(
                                                    LPTR,
                                                    NumberOfAttributes *
                                                    sizeof( NDS_NAME_ONLY )
                                                         );

          if ( lpAttributeInfos == NULL )
          {
#if DBG
              KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

              SetLastError( ERROR_NOT_ENOUGH_MEMORY );
              return (DWORD) UNSUCCESSFUL;
          }

          for ( iter2 = 0; iter2 < NumberOfAttributes; iter2++ )
          {
            dwStringLen = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Attribute Name Length

            ((LPNDS_NAME_ONLY) lpAttributeInfos)[iter2].szName =
                                                             (LPWSTR) lpByte;
            lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );
          }
        }

        (void) WriteObjectToBuffer( &FixedPortion,
                                    &EndOfVariableData,
                                    newPathStr,
                                    ObjectName,
                                    ClassName,
                                    0, // Don't have this data to write out!
                                    ModificationTime,
                                    SubordinateCount,
                                    NumberOfAttributes,
                                    lpAttributeInfos );

        if ( newPathStr )
        {
            (void) LocalFree( (HLOCAL) newPathStr );
            newPathStr = NULL;
        }

        if ( ObjectName )
        {
            (void) LocalFree( (HLOCAL) ObjectName );
            ObjectName = NULL;
        }

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_CLASS_DEF );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_CLASS_DEF );
    }


    //
    // If the syntax buffer was used for the index, we need to convert
    // offset values to pointers
    //
    if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_ATTR_NAMES_VALUES )
    {
        for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
        {
            LPNDS_ATTR_INFO lpNdsAttr = (LPNDS_ATTR_INFO)
                                             lpReplyIndex[iter].lpAttribute;

            for ( iter2 = 0;
                  iter2 < lpReplyIndex[iter].dwNumberOfAttributes;
                  iter2++ )
            {
                lpNdsAttr[iter2].lpValue += (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
            }
        }
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData > lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexSearchObjectReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData >\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
SizeOfASN1Structure(
    LPBYTE * lppRawBuffer,
    DWORD    dwSyntaxId )
{
    DWORD  dwSize = 0;
    DWORD  numFields = 0;
    DWORD  StringLen = 0;
    DWORD  dwBlobLength = 0;
    LPBYTE lpBlobBeginning = NULL;
    LPBYTE lpRawBuffer = *lppRawBuffer;

    switch ( dwSyntaxId )
    {
        case NDS_SYNTAX_ID_1 :
            dwSize = sizeof(ASN1_TYPE_1);
            break;
        case NDS_SYNTAX_ID_2 :
            dwSize = sizeof(ASN1_TYPE_2);
            break;
        case NDS_SYNTAX_ID_3 :
            dwSize = sizeof(ASN1_TYPE_3);
            break;
        case NDS_SYNTAX_ID_4 :
            dwSize = sizeof(ASN1_TYPE_4);
            break;
        case NDS_SYNTAX_ID_5 :
            dwSize = sizeof(ASN1_TYPE_5);
            break;
        case NDS_SYNTAX_ID_6 :
            numFields = *(LPDWORD)(lpRawBuffer + sizeof(DWORD));
            dwSize = sizeof(ASN1_TYPE_6)*numFields;
            break;
        case NDS_SYNTAX_ID_7 :
            dwSize = sizeof(ASN1_TYPE_7);
            break;
        case NDS_SYNTAX_ID_8 :
            dwSize = sizeof(ASN1_TYPE_8);
            break;
        case NDS_SYNTAX_ID_9 :
            dwSize = sizeof(ASN1_TYPE_9);
            break;
        case NDS_SYNTAX_ID_10 :
            dwSize = sizeof(ASN1_TYPE_10);
            break;
        case NDS_SYNTAX_ID_11 :
            dwSize = sizeof(ASN1_TYPE_11);
            break;
        case NDS_SYNTAX_ID_12 :
            dwSize = sizeof(ASN1_TYPE_12);
            break;
        case NDS_SYNTAX_ID_13 :
            dwSize = sizeof(ASN1_TYPE_13);
            break;
        case NDS_SYNTAX_ID_14 :
            dwSize = sizeof(ASN1_TYPE_14);
            break;
        case NDS_SYNTAX_ID_15 :
            dwSize = sizeof(ASN1_TYPE_15);
            break;
        case NDS_SYNTAX_ID_16 :
            lpBlobBeginning = lpRawBuffer;
            dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
            dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
            lpRawBuffer += sizeof(DWORD);

            StringLen = *(LPDWORD)lpRawBuffer;
            lpRawBuffer += sizeof(DWORD);

            //
            // Skip past ServerName
            //
            lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

            //
            // Skip past ReplicaType
            //
            lpRawBuffer += sizeof(DWORD);

            //
            // Skip past ReplicaNumber
            //
            lpRawBuffer += sizeof(DWORD);

            //
            // Store address count and move past it
            //
            numFields = *(LPDWORD)lpRawBuffer;
            lpRawBuffer += sizeof(DWORD);

            dwSize = sizeof(ASN1_TYPE_16) - sizeof(ASN1_TYPE_12) +
                     ( numFields * sizeof(ASN1_TYPE_12) );

            *lppRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);
            break;
        case NDS_SYNTAX_ID_17 :
            dwSize = sizeof(ASN1_TYPE_17);
            break;
        case NDS_SYNTAX_ID_18 :
            dwSize = sizeof(ASN1_TYPE_18);
            break;
        case NDS_SYNTAX_ID_19 :
            dwSize = sizeof(ASN1_TYPE_19);
            break;
        case NDS_SYNTAX_ID_20 :
            dwSize = sizeof(ASN1_TYPE_20);
            break;
        case NDS_SYNTAX_ID_21 :
            dwSize = sizeof(ASN1_TYPE_21);
            break;
        case NDS_SYNTAX_ID_22 :
            dwSize = sizeof(ASN1_TYPE_22);
            break;
        case NDS_SYNTAX_ID_23 :
            dwSize = sizeof(ASN1_TYPE_23);
            break;
        case NDS_SYNTAX_ID_24 :
            dwSize = sizeof(ASN1_TYPE_24);
            break;
        case NDS_SYNTAX_ID_25 :
            dwSize = sizeof(ASN1_TYPE_25);
            break;
        case NDS_SYNTAX_ID_26 :
            dwSize = sizeof(ASN1_TYPE_26);
            break;
        case NDS_SYNTAX_ID_27 :
            dwSize = sizeof(ASN1_TYPE_27);
            break;

        default :
            KdPrint(( "NDS32: SizeOfASN1Structure() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
            ASSERT( FALSE );
    }

    return dwSize;
}

DWORD
ParseASN1ValueBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwSyntaxId,
    DWORD  dwNumberOfValues,
    LPBYTE SyntaxStructure )
{
    DWORD   iter;
    DWORD   i;
    DWORD   length = 0;
    LPBYTE  lpRawBuffer = RawDataBuffer;
    LPBYTE  lpSyntaxBuffer = SyntaxStructure;
    DWORD   StringLen;
    DWORD   numFields;
    DWORD   dwBlobLength;
    LPBYTE  lpBlobBeginning;

    for ( iter = 0; iter < dwNumberOfValues; iter++ )
    {
        switch ( dwSyntaxId )
        {
            case NDS_SYNTAX_ID_0 :

                break;

            case NDS_SYNTAX_ID_1 :
            case NDS_SYNTAX_ID_2 :
            case NDS_SYNTAX_ID_3 :
            case NDS_SYNTAX_ID_4 :
            case NDS_SYNTAX_ID_5 :
            case NDS_SYNTAX_ID_10 :
            case NDS_SYNTAX_ID_20 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_1) lpSyntaxBuffer)->DNString =
                               StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_1);

                length += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                break;

            case NDS_SYNTAX_ID_6 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                numFields = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                for ( iter = 0; iter < numFields; iter++ )
                {
                    StringLen = *(LPDWORD)lpRawBuffer;
                    lpRawBuffer += sizeof(DWORD);
                    ((LPASN1_TYPE_6) lpSyntaxBuffer)->String =
                                   StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                    lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                    if ( (iter+1) < numFields )
                    {
                        ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next =
                                                   (LPASN1_TYPE_6)
                                                   (lpSyntaxBuffer +
                                                    sizeof(ASN1_TYPE_6) );
                    }
                    else
                    {
                        ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next = NULL;
                    }

                    lpSyntaxBuffer += sizeof(ASN1_TYPE_6);
                }

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_7 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ASSERT( StringLen == 1 ); // Booleans are sent as a single
                                          // element DWORD array on the net.
                                          // Although booleans are only the
                                          // first single byte value.

                ((LPASN1_TYPE_7) lpSyntaxBuffer)->Boolean = *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_7);

                length += StringLen*sizeof(DWORD);
                lpRawBuffer += StringLen*sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_8 :
            case NDS_SYNTAX_ID_22 :
            case NDS_SYNTAX_ID_24 :
            case NDS_SYNTAX_ID_27 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ASSERT( StringLen == 4 ); // These DWORD values are all sent
                                          // as a 4 element BYTE array on
                                          // the net.

                ((LPASN1_TYPE_8) lpSyntaxBuffer)->Integer =
                                                    *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_8);

                length += StringLen*sizeof(BYTE);
                lpRawBuffer += StringLen*sizeof(BYTE);

                break;

            case NDS_SYNTAX_ID_9 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_9) lpSyntaxBuffer)->Length = StringLen;
                ((LPASN1_TYPE_9) lpSyntaxBuffer)->OctetString =
                               StringLen == 0 ? NULL : lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_9);

                length += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                break;

            case NDS_SYNTAX_ID_11 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_11) lpSyntaxBuffer)->TelephoneNumber =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_11) lpSyntaxBuffer)->NumberOfBits =
                                                    *(LPDWORD)lpRawBuffer;

                if ( ((LPASN1_TYPE_11) lpSyntaxBuffer)->NumberOfBits )
                {
                    lpRawBuffer += sizeof(DWORD);
                    ((LPASN1_TYPE_11) lpSyntaxBuffer)->Parameters = lpRawBuffer;
                }
                else
                {
                    ((LPASN1_TYPE_11) lpSyntaxBuffer)->Parameters = NULL;
                }

                lpSyntaxBuffer += sizeof(ASN1_TYPE_11);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_12 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_12) lpSyntaxBuffer)->AddressType =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                ((LPASN1_TYPE_12) lpSyntaxBuffer)->AddressLength = StringLen;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_12) lpSyntaxBuffer)->Address =
                                StringLen == 0 ? NULL : lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_12);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_13 :
#if DBG
                KdPrint(( "NDS32: ParseASN1ValueBlob() - Don't know how to parse SyntaxId 0x%.8X. Get a sniff and give it to GlennC.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif
                break;

            case NDS_SYNTAX_ID_14 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_14) lpSyntaxBuffer)->Type =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_14) lpSyntaxBuffer)->Address =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_14);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_15 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_15) lpSyntaxBuffer)->Type =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_15) lpSyntaxBuffer)->VolumeName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_15) lpSyntaxBuffer)->Path =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_15);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_16 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->ServerName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaType =
                                                       *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaNumber =
                                                       *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->Count =
                                                       *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                for ( i=0; i < ((LPASN1_TYPE_16) lpSyntaxBuffer)->Count; i++ )
                {
                    ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaAddressHint[i].AddressType = *(LPDWORD)lpRawBuffer;
                    lpRawBuffer += sizeof(DWORD);

                    StringLen = *(LPDWORD)lpRawBuffer;
                    ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaAddressHint[i].AddressLength = StringLen;
                    lpRawBuffer += sizeof(DWORD);

                    ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaAddressHint[i].Address = StringLen == 0 ? NULL : lpRawBuffer;
                    lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                }

                lpSyntaxBuffer += sizeof(ASN1_TYPE_16) -
                                  sizeof(ASN1_TYPE_12) +
                                  ( ((LPASN1_TYPE_16) lpSyntaxBuffer)->Count*
                                    sizeof(ASN1_TYPE_12) );

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_17 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_17) lpSyntaxBuffer)->ProtectedAttrName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_17) lpSyntaxBuffer)->SubjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_17) lpSyntaxBuffer)->Privileges =
                                                       *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_17);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_18 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                numFields = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                for ( i = 0; i < numFields; i++ )
                {
                    StringLen = *(LPDWORD)lpRawBuffer;
                    lpRawBuffer += sizeof(DWORD);
                    ((LPASN1_TYPE_18) lpSyntaxBuffer)->PostalAddress[i] =
                                   StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                    lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                }

                lpSyntaxBuffer += sizeof(ASN1_TYPE_18);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_19 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_19) lpSyntaxBuffer)->WholeSeconds =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_19) lpSyntaxBuffer)->EventID =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                lpSyntaxBuffer += sizeof(ASN1_TYPE_19);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_21 :

                ((LPASN1_TYPE_21) lpSyntaxBuffer)->Length =
                               *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_21);

                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_23 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_23) lpSyntaxBuffer)->RemoteID =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_23) lpSyntaxBuffer)->ObjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                lpSyntaxBuffer += sizeof(ASN1_TYPE_23);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_25 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_25) lpSyntaxBuffer)->Level =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_25) lpSyntaxBuffer)->Interval =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_25) lpSyntaxBuffer)->ObjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                lpSyntaxBuffer += sizeof(ASN1_TYPE_25);
                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_26 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_26) lpSyntaxBuffer)->ObjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_26) lpSyntaxBuffer)->Amount =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                lpSyntaxBuffer += sizeof(ASN1_TYPE_26);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            default :
#if DBG
                KdPrint(( "NDS32: ParseASN1ValueBlob() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif

                return 0;
        }
    }

    return length;
}


DWORD
ParseStringListBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwNumberOfStrings,
    LPBYTE SyntaxStructure )
{
    DWORD   iter;
    DWORD   length = 0;
    LPBYTE  lpRawBuffer = RawDataBuffer;
    LPBYTE  lpSyntaxBuffer = SyntaxStructure;
    DWORD   StringLen;

    for ( iter = 0; iter < dwNumberOfStrings; iter++ )
    {
        StringLen = *(LPDWORD)lpRawBuffer;
        lpRawBuffer += sizeof(DWORD);
        length += sizeof(DWORD);
        ((LPASN1_TYPE_6) lpSyntaxBuffer)->String =
                                 StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
        lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
        length += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

        if ( (iter+1) < dwNumberOfStrings )
        {
            ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next = (LPASN1_TYPE_6)
                                                      (lpSyntaxBuffer +
                                                      sizeof(ASN1_TYPE_6) );
        }
        else
        {
            ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next = NULL;
        }

        lpSyntaxBuffer += sizeof(ASN1_TYPE_6);
    }

    return length;
}


WORD
ParseNdsUncPath(
    IN OUT LPWSTR * lpszResult,
    IN     LPWSTR   szObjectPathName,
    IN     DWORD    flag )
{
    unsigned short length = 2;
    unsigned short totalLength = (USHORT) wcslen( szObjectPathName );

    if ( totalLength < 2 )
        return 0;

    //
    // Get length to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path.
    //
    // Example:  \\<tree name>\<path to object>[\|.]<object>
    //                        ^
    //                        |
    //
    while ( length < totalLength && szObjectPathName[length] != L'\\' )
    {
        length++;
    }

    if ( flag == PARSE_NDS_GET_TREE_NAME )
    {
        *lpszResult = (LPWSTR) ( szObjectPathName + 2 );

        return ( length - 2 ) * sizeof(WCHAR); // Take off 2 for the two \\'s
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME && length == totalLength )
    {
        *lpszResult = szObjectPathName;

        return 0;
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME )
    {
        *lpszResult = szObjectPathName + length + 1;

        return ( totalLength - length - 1 ) * sizeof(WCHAR);
    }

    if ( flag == PARSE_NDS_GET_OBJECT_NAME )
    {
        unsigned short ObjectNameLength = 0;

        *lpszResult = szObjectPathName + length + 1;

        length++;

        while ( length < totalLength && szObjectPathName[length] != L'.' )
        {
            length++;
            ObjectNameLength++;
        }

        return ObjectNameLength * sizeof(WCHAR);
    }

    *lpszResult = szObjectPathName + totalLength - 1;
    length = 1;

    while ( *lpszResult[0] != L'\\' )
    {
        (*lpszResult)--;
        length++;
    }

    (*lpszResult)++;
    length--;

    return length * sizeof(WCHAR);
}


DWORD
ReadAttrDef_AllAttrs(
    IN  HANDLE   hTree,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;
    DWORD        dwInfoType = dwInformationType;

    *lphOperationData = NULL;

    status = NwNdsCreateBuffer( NDS_SCHEMA_READ_ATTR_DEF,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer = NULL;
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 8K bytes.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_ATTR_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDD",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) TRUE,  // All attributes indicator
                                   0 );           // Number of attribute names


        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadAttrDef_AllAttrs - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadAttrDef_AllAttrs - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }

#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (ROUND_UP_COUNT( dwReplyLength, ALIGN_DWORD ) - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lphOperationData = lpNdsBuffer;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    return status;
}


DWORD
ReadAttrDef_SomeAttrs(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwInfoType = dwInformationType;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;

    if ( lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_ATTR_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if this buffer has already been used for a read reply.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 8K bytes.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_ATTR_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDr",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) FALSE, // All attributes indicator
                                   lpNdsBuffer->dwNumberOfRequestEntries,
                                   lpNdsBuffer->lpRequestBuffer,
                                   (WORD)lpNdsBuffer->dwLengthOfRequestData );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (ROUND_UP_COUNT( dwReplyLength, ALIGN_DWORD ) - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyBufferSize = 0;
    }

    return status;
}


DWORD
ReadClassDef_AllClasses(
    IN  HANDLE   hTree,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;
    DWORD        dwInfoType = dwInformationType;

    *lphOperationData = NULL;

    status = NwNdsCreateBuffer( NDS_SCHEMA_READ_CLASS_DEF,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer = NULL;
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 16K bytes.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadClassDef_AllClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_CLASS_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDD",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) TRUE,  // All attributes indicator
                                   0 );           // Number of attribute names


        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses: The read response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadClassDef_AllClasses - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadClassDef_AllClasses - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }

#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += ROUND_UP_COUNT( dwReplyLength, ALIGN_DWORD ) - dwCopyOffset;
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lphOperationData = lpNdsBuffer;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    return status;
}


DWORD
ReadClassDef_SomeClasses(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwInfoType = dwInformationType;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;

    if ( lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_CLASS_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if this buffer has already been used for a read reply.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 16K bytes.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadClassDef_SomeClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_CLASS_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDr",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) FALSE, // All attributes indicator
                                   lpNdsBuffer->dwNumberOfRequestEntries,
                                   lpNdsBuffer->lpRequestBuffer,
                                   (WORD)lpNdsBuffer->dwLengthOfRequestData );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadClassDef_SomeClasses - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadClassDef_SomeClasses - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }

#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (ROUND_UP_COUNT( dwReplyLength, ALIGN_DWORD ) - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyBufferSize = 0;
    }

    return status;
}


DWORD
ReadObject_AllAttrs(
    IN  HANDLE   hObject,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;
    DWORD        dwInfoType = dwInformationType;

    if ( lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    status = NwNdsCreateBuffer( NDS_OBJECT_READ,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer = NULL;
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // We're asking for all attribute values, so let's start with max buffer to avoid iterations.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadObject_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_OBJECT,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDD",
                                   0,            // Version
                                   dwIterHandle, // Initial iteration
                                   lpNdsObject->ObjectId, // Id of the object
                                   dwInformationType,
                                   (DWORD) TRUE, // All attributes indicator
                                   0 );          // Number of attribute names

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (ROUND_UP_COUNT( dwReplyLength, ALIGN_DWORD ) - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lphOperationData = lpNdsBuffer;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    return status;
}


DWORD
ReadObject_SomeAttrs(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwInfoType = dwInformationType;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;

    if ( lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsBuffer->dwOperation != NDS_OBJECT_READ )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if this buffer has already been used for a read reply.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // We may be asking for all values, so let's start with max buffer to avoid iterations.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadObject_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_OBJECT,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDDr",
                                   0,               // Version
                                   dwIterHandle, // Initial iteration
                                   lpNdsObject->ObjectId, // Id of the object
                                   dwInformationType,
                                   (DWORD) FALSE,   // All attributes indicator
                                   lpNdsBuffer->dwNumberOfRequestEntries,
                                   lpNdsBuffer->lpRequestBuffer, // Object info
                                   (WORD)lpNdsBuffer->dwLengthOfRequestData );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (ROUND_UP_COUNT( dwReplyLength, ALIGN_DWORD ) - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyBufferSize = 0;
    }

    return status;
}


DWORD
Search_AllAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    LPNDS_BUFFER lpNdsQueryTreeBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hStartFromObject;
    DWORD        dwIterHandle;
    DWORD        dwNumEntries;
    DWORD        dwAmountOfNodesSearched;
    DWORD        dwLengthOfSearch;
    DWORD        iter;

    //
    // Search NCP parameters
    //
    DWORD        dwFlags = fDerefAliases ?
                           NDS_DEREF_ALIASES :
                           NDS_DONT_DEREF_ALIASES;
    DWORD        dwNumNodes = 0;
    DWORD        dwNumAttributes = 0;
    DWORD        dwInfoType = dwInformationType;

    LPBYTE       FixedPortion;
    LPWSTR       EndOfVariableData;
    BOOL         FitInBuffer = TRUE;

    if ( *lphOperationData == NULL )
    {
        //
        // This is the first time that NwNdsSearch has been called,
        // need to create a hOperationData buffer . . .
        //
        status = NwNdsCreateBuffer( NDS_SEARCH,
                                    (HANDLE *) &lpNdsBuffer );

        if ( status )
        {
            goto ErrorExit;
        }

        //
        // Not specifying any particular attributes in the search request.
        //
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpRequestBuffer );
        lpNdsBuffer->lpRequestBuffer = NULL;
        lpNdsBuffer->dwRequestBufferSize = 0;
        lpNdsBuffer->dwRequestAvailableBytes = 0;
        lpNdsBuffer->dwNumberOfRequestEntries = 0;
        lpNdsBuffer->dwLengthOfRequestData = 0;

        //
        // Reasonable guess is that the response buffer needs to be 16K bytes.
        //
        lpNdsBuffer->dwReplyBufferSize = NDS_MAX_BUFFER;
    }
    else if ( ((LPNDS_BUFFER) *lphOperationData)->dwBufferId == NDS_SIGNATURE &&
              ((LPNDS_BUFFER) *lphOperationData)->dwOperation == NDS_SEARCH &&
              ((LPNDS_BUFFER) *lphOperationData)->lpReplyBuffer )
    {
        //
        // This seems to be a sub-sequent call to NwNdsSearch with a resume
        // handle, need to clean up the hOperationData buffer from the last
        // time this was called.
        //
        lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;

        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyAvailableBytes = 0;
        lpNdsBuffer->dwNumberOfReplyEntries = 0;
        lpNdsBuffer->dwLengthOfReplyData = 0;

        if ( lpNdsBuffer->lpIndexBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsBuffer->lpIndexBuffer );
            lpNdsBuffer->lpIndexBuffer = NULL;
            lpNdsBuffer->dwIndexAvailableBytes = 0;
            lpNdsBuffer->dwNumberOfIndexEntries = 0;
            lpNdsBuffer->dwLengthOfIndexData = 0;
        }

        //
        // Since the last call to NwNdsSearch needed a bigger buffer for all
        // of the response data, let's continue this time with a bigger reply
        // buffer. We grow the buffer up to a point, 128K bytes.
        //
        if ( lpNdsBuffer->dwReplyBufferSize < SIXTY_FOUR_KB )
        {
            lpNdsBuffer->dwReplyBufferSize *= 2;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    status = NwNdsCreateBuffer( NDS_SEARCH,
                                (HANDLE *) &lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    //
    // Prepare request buffer stream with search query.
    //
    status = WriteQueryTreeToBuffer( lpQueryTree, lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer =
        (PVOID) LocalAlloc( LPTR, lpNdsBuffer->dwReplyBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: Search_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

/*
    //
    // This is the format of a version 3 search request ...
    //
    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDDr",
                               0x00000003, // Version
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               0x0000281D, // Flags??
                               0x741E0000, // ??
                               (DWORD) TRUE, // All attributes?
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );
*/

    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDr",
                               0x00000002, // Version
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               (DWORD) TRUE, // All attributes?
                               dwNumAttributes,
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        status = nwstatus;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( (BYTE *) lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "G_DDDDD",
                              sizeof(DWORD),
                              &dwIterHandle,
                              &dwAmountOfNodesSearched,
                              &dwInfoType,
                              &dwLengthOfSearch,
                              &dwNumEntries );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    //
    // Finished the search call, free up lpNDsQueryTreeBuffer
    //
    (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
    lpNdsQueryTreeBuffer = NULL;

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lpdwIterHandle = dwIterHandle;
    *lphOperationData = (HANDLE) lpNdsBuffer;

    //
    // Keep the search from object path . . .
    //
    wcscpy( lpNdsBuffer->szPath, lpNdsObject->szContainerName );

    return NO_ERROR;

ErrorExit :

    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    if ( lpNdsQueryTreeBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
        lpNdsQueryTreeBuffer = NULL;
    }

    return status;
}


DWORD
Search_SomeAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    LPNDS_BUFFER lpNdsQueryTreeBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hStartFromObject;
    DWORD        dwIterHandle;
    DWORD        dwNumEntries;
    DWORD        dwAmountOfNodesSearched;
    DWORD        dwLengthOfSearch;
    DWORD        iter;

    //
    // Search NCP parameters
    //
    DWORD        dwFlags = fDerefAliases ?
                           NDS_DEREF_ALIASES :
                           NDS_DONT_DEREF_ALIASES;
    DWORD        dwNumNodes = 0;
    DWORD        dwInfoType = dwInformationType;

    LPBYTE       FixedPortion;
    LPWSTR       EndOfVariableData;
    BOOL         FitInBuffer = TRUE;

    //
    // A quick check of the buffer passed to us.
    //
    if ( lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_SEARCH )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Prepare request buffer stream with search query.
    //
    status = NwNdsCreateBuffer( NDS_SEARCH,
                                (HANDLE *) &lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    status = WriteQueryTreeToBuffer( lpQueryTree, lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    if ( lpNdsBuffer->lpReplyBuffer == NULL ||
         lpNdsBuffer->dwReplyBufferSize == 0 )
    {
        //
        // Reasonable guess is that the initial response buffer needs to
        // be 16K bytes.
        //
        lpNdsBuffer->dwReplyBufferSize = NDS_MAX_BUFFER;
    }

    if ( lpNdsBuffer->lpReplyBuffer )
    {
        //
        // This seems to be a sub-sequent call to NwNdsSearch,
        // need to clean up the hOperationData buffer from the last
        // time this was called.
        //
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyAvailableBytes = 0;
        lpNdsBuffer->dwNumberOfReplyEntries = 0;
        lpNdsBuffer->dwLengthOfReplyData = 0;

        if ( lpNdsBuffer->lpIndexBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsBuffer->lpIndexBuffer );
            lpNdsBuffer->lpIndexBuffer = NULL;
            lpNdsBuffer->dwIndexAvailableBytes = 0;
            lpNdsBuffer->dwNumberOfIndexEntries = 0;
            lpNdsBuffer->dwLengthOfIndexData = 0;
        }

        //
        // Since the last call to NwNdsSearch needed a bigger buffer for all
        // of the response data, let's continue this time with a bigger reply
        // buffer. We grow the buffer up to a point, 64K bytes.
        //
        if ( lpNdsBuffer->dwReplyBufferSize < SIXTY_FOUR_KB )
        {
            lpNdsBuffer->dwReplyBufferSize *= 2;
        }
    }

    lpNdsBuffer->lpReplyBuffer =
        (PVOID) LocalAlloc( LPTR, lpNdsBuffer->dwReplyBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: Search_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

/*
    //
    // This is the format of a version 3 search request ...
    //
    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDDrr",
                               0x00000003,
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               0x0000281D, // (DWORD) FALSE,// All attributes?
                               0x741E0000, // dwNumAttributes,
                               lpNdsBuffer->dwNumberOfRequestEntries,
                               lpNdsBuffer->lpRequestBuffer,
                               lpNdsBuffer->dwLengthOfRequestData,
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );
*/

    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDrr",
                               0x00000002,
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               (DWORD) FALSE,         // All attributes?
                               lpNdsBuffer->dwNumberOfRequestEntries,
                               lpNdsBuffer->lpRequestBuffer,
                               lpNdsBuffer->dwLengthOfRequestData,
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        status = nwstatus;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( (BYTE *) lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "G_DDDDD",
                              sizeof(DWORD),
                              &dwIterHandle,
                              &dwAmountOfNodesSearched,
                              &dwInfoType,
                              &dwLengthOfSearch,
                              &dwNumEntries );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    //
    // Finished the search call, free up lpNDsQueryTreeBuffer
    //
    (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
    lpNdsQueryTreeBuffer = NULL;

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lpdwIterHandle = dwIterHandle;
    *lphOperationData = (HANDLE) lpNdsBuffer;

    //
    // Keep the search from object path . . .
    //
    wcscpy( lpNdsBuffer->szPath, lpNdsObject->szContainerName );

    return NO_ERROR;

ErrorExit :

    if ( lpNdsQueryTreeBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
        lpNdsQueryTreeBuffer = NULL;
    }

    return status;
}


VOID
GetSubTreeData( IN  DWORD    NdsRawDataPtr,
                OUT LPDWORD  lpdwEntryId,
                OUT LPDWORD  lpdwSubordinateCount,
                OUT LPDWORD  lpdwModificationTime,
                OUT LPDWORD  lpdwClassNameLen,
                OUT LPWSTR * lpszClassName,
                OUT LPDWORD  lpdwObjectNameLen,
                OUT LPWSTR * lpszObjectName )
{
    PNDS_RESPONSE_SUBORDINATE_ENTRY pSubEntry =
                             (PNDS_RESPONSE_SUBORDINATE_ENTRY) NdsRawDataPtr;
    PBYTE pbRaw;

    //
    // The structure of a NDS_RESPONSE_SUBORDINATE_ENTRY consists of 4 DWORDs
    // followed by two standard NDS format UNICODE strings. Below we jump pbRaw
    // into the buffer, past the 4 DWORDs.
    //
    *lpdwEntryId = pSubEntry->EntryId;
    *lpdwSubordinateCount = pSubEntry->SubordinateCount;
    *lpdwModificationTime = pSubEntry->ModificationTime;

    pbRaw = (BYTE *) pSubEntry;
    pbRaw += sizeof(NDS_RESPONSE_SUBORDINATE_ENTRY);

    //
    // Now we get the length of the first string (Base Class).
    //
    *lpdwClassNameLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the first string (Base Class).
    //
    pbRaw += sizeof(DWORD);

    *lpszClassName = (LPWSTR) pbRaw;

    //
    // Move pbRaw into the buffer, past the first UNICODE string (WORD aligned)
    //
    pbRaw += ROUNDUP4( *lpdwClassNameLen );

    //
    // Now we get the length of the second string (Entry Name).
    //
    *lpdwObjectNameLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the second string (Entry Name).
    //
    pbRaw += sizeof(DWORD);

    *lpszObjectName = (LPWSTR) pbRaw;
}


LPBYTE
GetSearchResultData( IN  LPBYTE   lpResultBufferPtr,
                     OUT LPDWORD  lpdwFlags,
                     OUT LPDWORD  lpdwSubordinateCount,
                     OUT LPDWORD  lpdwModificationTime,
                     OUT LPDWORD  lpdwClassNameLen,
                     OUT LPWSTR * lpszClassName,
                     OUT LPDWORD  lpdwObjectNameLen,
                     OUT LPWSTR * lpszObjectName,
                     OUT LPDWORD  lpdwEntryInfo1,
                     OUT LPDWORD  lpdwEntryInfo2 )
{
    LPBYTE lpRaw = lpResultBufferPtr;

    *lpdwFlags = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    *lpdwSubordinateCount = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    *lpdwModificationTime = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    //
    // Now we get the length of the first string (Base Class).
    //
    *lpdwClassNameLen = * (DWORD *) lpRaw;

    //
    // Now we point lpRaw to the first WCHAR of the first string (Base Class).
    //
    lpRaw += sizeof(DWORD);

    *lpszClassName = (LPWSTR) lpRaw;

    //
    // Move lpRaw into the buffer, past the first UNICODE string
    // (DWORD aligned)
    //
    lpRaw += ROUNDUP4( *lpdwClassNameLen );

    //
    // Now we get the length of the second string (Entry Name).
    //
    *lpdwObjectNameLen = * (DWORD *) lpRaw;

    //
    // Now we point lpRaw to the first WCHAR of the second string (Entry Name).
    //
    lpRaw += sizeof(DWORD);

    *lpszObjectName = (LPWSTR) lpRaw;

    //
    // Move lpRaw into the buffer, past the second UNICODE string
    // (DWORD aligned)
    //
    lpRaw += ROUNDUP4( *lpdwObjectNameLen );

    //
    // Now skip over the last two DWORDs, I don't know what they represent?
    //
    *lpdwEntryInfo1 = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    *lpdwEntryInfo2 = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    return lpRaw;
}


DWORD
WriteObjectToBuffer(
    IN OUT LPBYTE *        FixedPortion,
    IN OUT LPWSTR *        EndOfVariableData,
    IN     LPWSTR          szObjectFullName,
    IN     LPWSTR          szObjectName,
    IN     LPWSTR          szClassName,
    IN     DWORD           EntryId,
    IN     DWORD           ModificationTime,
    IN     DWORD           SubordinateCount,
    IN     DWORD           NumberOfAttributes,
    IN     LPNDS_ATTR_INFO lpAttributeInfos )
{
    BOOL              FitInBuffer = TRUE;
    LPNDS_OBJECT_INFO lpNdsObjectInfo = (LPNDS_OBJECT_INFO) *FixedPortion;
    DWORD             EntrySize = sizeof( NDS_OBJECT_INFO ) +
                                  ( wcslen( szObjectFullName ) +
                                    wcslen( szObjectName ) +
                                    wcslen( szClassName ) +
                                    3 ) * sizeof( WCHAR );

    EntrySize = ROUND_UP_COUNT( EntrySize, ALIGN_DWORD );

    //
    // See if buffer is large enough to fit the entry.
    //
    if (((DWORD_PTR) *FixedPortion + EntrySize) >
         (DWORD_PTR) *EndOfVariableData) {

        return WN_MORE_DATA;
    }

    lpNdsObjectInfo->dwEntryId = EntryId;
    lpNdsObjectInfo->dwModificationTime = ModificationTime;
    lpNdsObjectInfo->dwSubordinateCount = SubordinateCount;
    lpNdsObjectInfo->dwNumberOfAttributes = NumberOfAttributes;
    lpNdsObjectInfo->lpAttribute = lpAttributeInfos;

    //
    // Update fixed entry pointer to next entry.
    //
    (DWORD_PTR) (*FixedPortion) += sizeof(NDS_OBJECT_INFO);

    FitInBuffer = NwlibCopyStringToBuffer(
                      szObjectFullName,
                      wcslen(szObjectFullName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &lpNdsObjectInfo->szObjectFullName );

    ASSERT(FitInBuffer);

    FitInBuffer = NwlibCopyStringToBuffer(
                      szObjectName,
                      wcslen(szObjectName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &lpNdsObjectInfo->szObjectName );

    ASSERT(FitInBuffer);

    FitInBuffer = NwlibCopyStringToBuffer(
                      szClassName,
                      wcslen(szClassName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &lpNdsObjectInfo->szObjectClass );

    ASSERT(FitInBuffer);

    if (! FitInBuffer)
        return WN_MORE_DATA;

    return NO_ERROR;
}


DWORD
VerifyBufferSize(
    IN  LPBYTE  lpRawBuffer,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwSyntaxID,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength )
{
    DWORD  iter;
    LPBYTE lpTemp = lpRawBuffer;

    *lpdwLength = 0;

    for ( iter = 0; iter < dwNumberOfValues; iter++ )
    {
        *lpdwLength += SizeOfASN1Structure( &lpTemp, dwSyntaxID );
    }

    if ( *lpdwLength > dwBufferSize )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}


DWORD
VerifyBufferSizeForStringList(
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength )
{
    *lpdwLength = sizeof(ASN1_TYPE_6) * dwNumberOfValues;

    if ( *lpdwLength > dwBufferSize )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}


DWORD
WriteQueryTreeToBuffer(
    IN  LPQUERY_TREE lpQueryTree,
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    DWORD status;

    switch( lpQueryTree->dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpQueryTree->lpLVal == NULL || lpQueryTree->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryTreeToBuffer was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = WriteQueryNodeToBuffer( (LPQUERY_NODE) lpQueryTree,
                                             lpNdsBuffer );

            if ( status )
                return status;

            status = WriteQueryTreeToBuffer( (LPQUERY_TREE) lpQueryTree->lpLVal,
                                             lpNdsBuffer );

            if ( status )
                return status;

            status = WriteQueryTreeToBuffer( (LPQUERY_TREE) lpQueryTree->lpRVal,
                                             lpNdsBuffer );

            if ( status )
                return status;

            break;

        case NDS_QUERY_NOT :

            if ( lpQueryTree->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryTreeToBuffer was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = WriteQueryNodeToBuffer( (LPQUERY_NODE) lpQueryTree,
                                             lpNdsBuffer );

            if ( status )
                return status;

            status = WriteQueryTreeToBuffer( (LPQUERY_TREE) lpQueryTree->lpLVal,
                                             lpNdsBuffer );

            if ( status )
                return status;

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :
        case NDS_QUERY_PRESENT :

            status = WriteQueryNodeToBuffer( (LPQUERY_NODE) lpQueryTree,
                                             lpNdsBuffer );

            if ( status )
                return status;

            break;

        default :
#if DBG
            KdPrint(( "NDS32: WriteQueryTreeToBuffer was passed an unidentified operation - 0x%.8X.\n", lpQueryTree->dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
WriteQueryNodeToBuffer(
    IN  LPQUERY_NODE lpQueryNode,
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    DWORD  LengthInBytes = 0;
    DWORD  stringLen;
    LPBYTE lpTemp;

    if ( lpNdsBuffer->dwRequestAvailableBytes < ONE_KB )
    {
        //
        // Buffer to store query is getting small, need to increase
        // request buffer size.
        //
        if ( AllocateOrIncreaseRequestBuffer( lpNdsBuffer ) != NO_ERROR )
        {
#if DBG
            KdPrint(( "NDS32: WriteQueryNodeToBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    lpTemp = (LPBYTE)&lpNdsBuffer->lpRequestBuffer[lpNdsBuffer->dwLengthOfRequestData];

    switch( lpQueryNode->dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpQueryNode->lpLVal == NULL || lpQueryNode->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            *(LPDWORD)lpTemp = 2; // The number of items being ANDed or ORed.
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            break;

        case NDS_QUERY_NOT :

            if ( lpQueryNode->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :

            if ( lpQueryNode->lpLVal == NULL || lpQueryNode->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = 0; // Zero represents ITEM in NDS
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            switch( lpQueryNode->dwSyntaxId )
            {
                case NDS_SYNTAX_ID_1 :
                case NDS_SYNTAX_ID_2 :
                case NDS_SYNTAX_ID_3 :
                case NDS_SYNTAX_ID_4 :
                case NDS_SYNTAX_ID_5 :
                case NDS_SYNTAX_ID_10 :
                case NDS_SYNTAX_ID_20 :
                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpRVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpRVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    break;

                case NDS_SYNTAX_ID_7 :

                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    *(LPDWORD)lpTemp = 1; // Needs to have value 1,
                                          // representing one byte
                                          // even though it is padded
                                          // out to four bytes.
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpTemp = 0; // This clears all bits of the DWORD
                    *(LPBYTE)lpTemp = (BYTE) (((LPASN1_TYPE_7)
                                                lpQueryNode->lpRVal)->Boolean);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    break;

                case NDS_SYNTAX_ID_8 :
                case NDS_SYNTAX_ID_22 :
                case NDS_SYNTAX_ID_24 :
                case NDS_SYNTAX_ID_27 :
                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    *(LPDWORD)lpTemp = sizeof( DWORD );
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpTemp = *( (LPDWORD) lpQueryNode->lpRVal );
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    break;

                case NDS_SYNTAX_ID_9 :
                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    stringLen = ((LPASN1_TYPE_9) lpQueryNode->lpRVal)->Length;

                    *(LPDWORD)lpTemp = stringLen;
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   &((LPASN1_TYPE_9) lpQueryNode->lpRVal)->OctetString,
                                   stringLen );
                    lpTemp += ROUND_UP_COUNT( stringLen, ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( stringLen, ALIGN_DWORD );

                    break;

                default :
                    SetLastError( ERROR_NOT_SUPPORTED );
                    return (DWORD) UNSUCCESSFUL;
            }

            break;

        case NDS_QUERY_PRESENT :

            if ( lpQueryNode->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = 0; // Zero represents ITEM in NDS
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            //
            // Write out the attribute name stored in LVal
            //
            stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

            *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            RtlCopyMemory( lpTemp,
                           lpQueryNode->lpLVal,
                           stringLen*sizeof(WCHAR) );
            lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                      ALIGN_DWORD);
            LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                             sizeof(WCHAR),
                                             ALIGN_DWORD );

            break;

        default :
#if DBG
            KdPrint(( "NDS32: WriteQueryNodeToBuffer was passed an unidentified operation - 0x%.8X.\n", lpQueryNode->dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwRequestAvailableBytes -= LengthInBytes;
    lpNdsBuffer->dwLengthOfRequestData += LengthInBytes;

    return NO_ERROR;
}


DWORD
NwNdsGetServerDN(
    IN  HANDLE hTree,
    OUT LPWSTR szServerDN )
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;

    if ( lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus =
        FragExWithWait( lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_GET_SERVER_ADDRESS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        NULL );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetServerInfo: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetServerInfo: The get server information response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }
    else
    {
        LPBYTE lpByte = NdsReply;
        DWORD  dwStrLen = 0;
        DWORD  dwNumPartitions = 0;

        //
        // Skip past status return code ...
        //
        lpByte += sizeof( DWORD );

        //
        // Skip past the length value of the Server DN string ...
        //
        lpByte += sizeof( DWORD );

        wcsncpy( szServerDN, (LPWSTR) lpByte, NDS_MAX_NAME_CHARS );
        szServerDN[NDS_MAX_NAME_CHARS - 1] = (WCHAR)0;

        return NO_ERROR;
    }
}


DWORD
AllocateOrIncreaseSyntaxBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer,
    IN  DWORD        dwLengthNeeded )
{
    DWORD LengthAdded;

    if ( lpNdsBuffer->lpSyntaxBuffer )
    {
        LPBYTE lpTempBuffer = NULL;

        //
        //  Figure how much we need.  We figure how many four kb 
        //  chunks and then multiply that by four kb to get the number
        //  or bytes needed.
        //

        DWORD LengthNeeded = dwLengthNeeded - lpNdsBuffer->dwSyntaxAvailableBytes;
        if (LengthNeeded <= 0) {
            LengthAdded = FOUR_KB;
        }
        else {
            LengthAdded = ((LengthNeeded + (FOUR_KB) - 1) / FOUR_KB) * FOUR_KB;
        }

        //
        // Need to reallocate buffer to a bigger size.
        //
        lpTempBuffer = (LPBYTE) LocalReAlloc(
                                   (HLOCAL) lpNdsBuffer->lpSyntaxBuffer,
                                   lpNdsBuffer->dwSyntaxBufferSize + LengthAdded,
                                   LPTR );

        if ( lpTempBuffer )
        {
            lpNdsBuffer->lpSyntaxBuffer = lpTempBuffer;
        }
        else
        {
            lpTempBuffer = (LPBYTE) LocalAlloc( LPTR,
                                       lpNdsBuffer->dwSyntaxBufferSize +
                                       LengthAdded );

            if ( lpTempBuffer )
            {
                RtlCopyMemory( lpTempBuffer,
                               lpNdsBuffer->lpSyntaxBuffer,
                               lpNdsBuffer->dwSyntaxBufferSize );

                LocalFree( lpNdsBuffer->lpSyntaxBuffer );

                lpNdsBuffer->lpSyntaxBuffer = lpTempBuffer;
            }
            else
            {
                LocalFree( lpNdsBuffer->lpSyntaxBuffer );

                lpNdsBuffer->lpSyntaxBuffer = NULL;
            }
        }
    }
    else
    {
        //
        //  Figure how much we need.  We figure how many four kb 
        //  chunks and then multiply that by four kb to get the number
        //  or bytes needed.
        //

        if (dwLengthNeeded <= 0) {
            LengthAdded = FOUR_KB;
        }
        else {
            LengthAdded = ((dwLengthNeeded + (FOUR_KB) - 1) / FOUR_KB) * FOUR_KB;
        }

        //
        // Need to allocate a 4K byte buffer.
        //
        lpNdsBuffer->lpSyntaxBuffer = (LPBYTE) LocalAlloc( LPTR,
                                                           LengthAdded );
        lpNdsBuffer->dwSyntaxBufferSize = 0;
        lpNdsBuffer->dwSyntaxAvailableBytes = 0;
    }

    if ( lpNdsBuffer->lpSyntaxBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: AllocateOrIncreaseSyntaxBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwSyntaxBufferSize += LengthAdded;
    lpNdsBuffer->dwSyntaxAvailableBytes += LengthAdded;

    return NO_ERROR;
}


DWORD
AllocateOrIncreaseRequestBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    if ( lpNdsBuffer->lpRequestBuffer )
    {
        LPBYTE lpTempBuffer = NULL;

        //
        // Need to reallocate buffer to a bigger size.
        //
        lpTempBuffer = (LPBYTE) LocalReAlloc(
                                   (HLOCAL) lpNdsBuffer->lpRequestBuffer,
                                   lpNdsBuffer->dwRequestBufferSize + TWO_KB,
                                   LPTR );

        if ( lpTempBuffer )
        {
            lpNdsBuffer->lpRequestBuffer = lpTempBuffer;
        }
        else
        {
            lpTempBuffer = (LPBYTE) LocalAlloc( LPTR,
                                       lpNdsBuffer->dwRequestBufferSize +
                                       TWO_KB );

            if ( lpTempBuffer )
            {
                RtlCopyMemory( lpTempBuffer,
                               lpNdsBuffer->lpRequestBuffer,
                               lpNdsBuffer->dwRequestBufferSize );

                LocalFree( lpNdsBuffer->lpRequestBuffer );

                lpNdsBuffer->lpRequestBuffer = lpTempBuffer;
            }
            else
            {
                LocalFree( lpNdsBuffer->lpRequestBuffer );

                lpNdsBuffer->lpRequestBuffer = NULL;
            }
        }
    }
    else
    {
        //
        // Need to allocate a 2K byte buffer.
        //
        lpNdsBuffer->lpRequestBuffer = (LPBYTE) LocalAlloc( LPTR,
                                                           TWO_KB );
        lpNdsBuffer->dwRequestBufferSize = 0;
        lpNdsBuffer->dwRequestAvailableBytes = 0;
    }

    if ( lpNdsBuffer->lpRequestBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: AllocateOrIncreaseRequestBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwRequestBufferSize += TWO_KB;
    lpNdsBuffer->dwRequestAvailableBytes += TWO_KB;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\canon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    canon.c

Abstract:

    Contains canonicalization routines for NetWare names.

Author:

    Rita Wong     (ritaw)    19-Feb-1993

Environment:


Revision History:


--*/


#include <procs.h>


DWORD
NwLibValidateLocalName(
    IN LPWSTR LocalName
    )
/*++

Routine Description:

    This routine checks to see if the supplied name is a valid
    DOS device name.

Arguments:

    LocalName - Supplies a local device name.  It can be any of
        the following:

            X:
            LPTn or LPTn:
            COMn or COMn:
            PRN or PRN:
            AUX or AUX:


Return Value:

    NO_ERROR - LocalName is valid.

    WN_BAD_NETNAME - LocalName is invalid.

--*/
{
    DWORD LocalNameLength;


    //
    // Cannot be a NULL or empty string
    //
    if (LocalName == NULL || *LocalName == 0) {
        return WN_BAD_NETNAME;
    }

    LocalNameLength = wcslen(LocalName);

    if (LocalNameLength == 1) {
        return WN_BAD_NETNAME;
    }

    if (LocalName[LocalNameLength - 1] == L':') {
        if (! IS_VALID_TOKEN(LocalName, LocalNameLength - 1)) {
            return WN_BAD_NETNAME;
        }
    }
    else {
        if (! IS_VALID_TOKEN(LocalName, LocalNameLength)) {
            return WN_BAD_NETNAME;
        }
    }

    if (LocalNameLength == 2) {
        //
        // Must be in the form of X:
        //
        if (! iswalpha(*LocalName)) {
            return WN_BAD_NETNAME;
        }

        if (LocalName[1] != L':') {
            return WN_BAD_NETNAME;
        }

        return NO_ERROR;
    }

    if (RtlIsDosDeviceName_U(LocalName) == 0) {
        return WN_BAD_NETNAME;
    }

    //
    // Valid DOS device name but invalid redirection name
    //
    if (_wcsnicmp(LocalName, L"NUL", 3) == 0) {
        return WN_BAD_NETNAME;

    }
    return NO_ERROR;
}


DWORD
NwLibCanonLocalName(
    IN LPWSTR LocalName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine canonicalizes the local name by uppercasing the string
    and converting the following:

          x:  -> X:
          LPTn: -> LPTn
          COMn: -> COMn
          PRN or PRN:  -> LPT1
          AUX or AUX:  -> COM1

Arguments:

    LocalName - Supplies a local device name.

    OutputBuffer - Receives a pointer to the canonicalized LocalName.

    OutputBufferLength - Receives the length of the canonicalized name
        in number of characters, if specified.

Return Value:

    NO_ERROR - Successfully canonicalized the local name.

    WN_BAD_NETNAME - LocalName is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    DWORD status;
    DWORD LocalNameLength;


    status = NwLibValidateLocalName(LocalName);

    if (status != NO_ERROR) {
        return status;
    }

    LocalNameLength = wcslen(LocalName);

    //
    // Allocate output buffer.  Should be the size of the LocalName
    // plus 1 for the special case of PRN -> LPT1 or AUX -> COM1.
    //
    *OutputBuffer = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                (LocalNameLength + 2) * sizeof(WCHAR)
                                );

    if (*OutputBuffer == NULL) {
        KdPrint(("NWLIB: NwLibCanonLocalName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, LocalName);

    if (LocalNameLength > 2) {

        if (_wcsnicmp(*OutputBuffer, L"PRN", 3) == 0) {

            //
            // Convert PRN or PRN: to LPT1
            //
            wcscpy(*OutputBuffer, L"LPT1");
            LocalNameLength = 4;

        }
        else if (_wcsnicmp(*OutputBuffer, L"AUX", 3) == 0) {

            //
            // Convert AUX or AUX: to COM1
            //
            wcscpy(*OutputBuffer, L"COM1");
            LocalNameLength = 4;
        }

        //
        // Remove trailing colon, if there is one, and decrement the length
        // of DOS device name.
        //
        if ((*OutputBuffer)[LocalNameLength - 1] == L':') {
            (*OutputBuffer)[--LocalNameLength] = 0;
        }
    }

    //
    // LocalName is always in uppercase.
    //
    _wcsupr(*OutputBuffer);

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = LocalNameLength;
    }

    return NO_ERROR;
}


DWORD
NwLibCanonRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine validates and canonicalizes the supplied
    NetWare UNC name.  It can be of any length in the form of:

        \\Server\Volume\Directory\Subdirectory

Arguments:

    LocalName - Supplies the local device name.  If it is NULL, then
        \\Server is an acceptable format for the UNC name.

    RemoteName - Supplies the UNC name.

    OutputBuffer - Receives a pointer to the canonicalized RemoteName.

    OutputBufferLength - Receives the length of the canonicalized name
        in number of characters, if specified.

Return Value:

    NO_ERROR - RemoteName is valid.

    WN_BAD_NETNAME - RemoteName is invalid.

--*/
{
    DWORD RemoteNameLength;
    DWORD i;
    DWORD TokenLength;
    LPWSTR TokenPtr;
    BOOL  fFirstToken = TRUE;


    //
    // Cannot be a NULL or empty string
    //
    if (RemoteName == NULL || *RemoteName == 0) {
        return WN_BAD_NETNAME;
    }

    RemoteNameLength = wcslen(RemoteName);

    //
    // Must be at least \\x\y if local device name is specified.
    // Otherwise it must be at least \\x.
    //
    if ((RemoteNameLength < 5 && ARGUMENT_PRESENT(LocalName)) ||
        (RemoteNameLength < 3)) {
        return WN_BAD_NETNAME;
    }

    //
    // First two characters must be "\\"
    //
    if (*RemoteName != L'\\' || RemoteName[1] != L'\\') {
        return WN_BAD_NETNAME;
    }

    if (! ARGUMENT_PRESENT(LocalName) &&
        (IS_VALID_TOKEN(&RemoteName[2], RemoteNameLength - 2))) {

        //
        // Return success for \\Server case.
        //

        *OutputBuffer = (PVOID) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    (RemoteNameLength + 1) * sizeof(WCHAR)
                                    );

        if (*OutputBuffer == NULL) {
            KdPrint(("NWLIB: NwLibCanonRemoteName LocalAlloc failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*OutputBuffer, RemoteName);

        return NO_ERROR;
    }

    //
    // Must have at least one more backslash after the third character
    //
    if (wcschr(&RemoteName[3], L'\\') == NULL) {
        return WN_BAD_NETNAME;
    }

    //
    // Last character cannot a backward slash
    //
    if (RemoteName[RemoteNameLength - 1] == L'\\') {
        return WN_BAD_NETNAME;
    }

    //
    // Allocate output buffer.  Should be the size of the RemoteName
    // and space for an extra character to simplify parsing code below.
    //
    *OutputBuffer = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                (RemoteNameLength + 2) * sizeof(WCHAR)
                                );


    if (*OutputBuffer == NULL) {
        KdPrint(("NWLIB: NwLibCanonRemoteName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, RemoteName);

    //
    // Convert all backslashes to NULL terminator, skipping first 2 chars.
    //
    for (i = 2; i < RemoteNameLength; i++) {
        if ((*OutputBuffer)[i] == L'\\') {

            (*OutputBuffer)[i] = 0;

            //
            // Two consecutive forward or backslashes is bad.
            //
            if ((i + 1 < RemoteNameLength) &&
                ((*OutputBuffer)[i + 1] == L'\\')) {

                (void) LocalFree((HLOCAL) *OutputBuffer);
                *OutputBuffer = NULL;
                return WN_BAD_NETNAME;
            }
        }
    }

    //
    // Validate each token of the RemoteName, separated by NULL terminator.
    //
    TokenPtr = *OutputBuffer + 2;  // Skip first 2 chars

    while (*TokenPtr != 0) {

        TokenLength = wcslen(TokenPtr);

        if (  ( fFirstToken && !IS_VALID_SERVER_TOKEN(TokenPtr, TokenLength))
           || ( !fFirstToken && !IS_VALID_TOKEN(TokenPtr, TokenLength))
           )
        {
            (void) LocalFree((HLOCAL) *OutputBuffer);
            *OutputBuffer = NULL;
            return WN_BAD_NETNAME;
        }

        fFirstToken = FALSE;
        TokenPtr += TokenLength + 1;
    }

    //
    // Convert NULL separators to backslashes
    //
    for (i = 0; i < RemoteNameLength; i++) {
        if ((*OutputBuffer)[i] == 0) {
            (*OutputBuffer)[i] = L'\\';
        }
    }

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = RemoteNameLength;
    }

    return NO_ERROR;
}


DWORD
NwLibCanonUserName(
    IN LPWSTR UserName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine canonicalizes the user name by checking to see
    if the name contains any illegal characters.


Arguments:

    UserName - Supplies a username.

    OutputBuffer - Receives a pointer to the canonicalized UserName.

    OutputBufferLength - Receives the length of the canonicalized name
        in number of characters, if specified.

Return Value:

    NO_ERROR - Successfully canonicalized the username.

    WN_BAD_NETNAME - UserName is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    DWORD UserNameLength;


    //
    // Cannot be a NULL or empty string
    //
    if (UserName == NULL) {
        return WN_BAD_NETNAME;
    }

    UserNameLength = wcslen(UserName);

    if (! IS_VALID_TOKEN(UserName, UserNameLength)) {
        return WN_BAD_NETNAME;
    }

    //
    // Allocate output buffer.  Should be the size of the UserName
    // plus 1 for the special case of PRN -> LPT1 or AUX -> COM1.
    //
    *OutputBuffer = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                (UserNameLength + 1) * sizeof(WCHAR)
                                );

    if (*OutputBuffer == NULL) {
        KdPrint(("NWLIB: NwLibCanonUserName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, UserName);

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = UserNameLength;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\procs.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    procs.c

Abstract:

    Common header file for routines which support 16 bit
    applications.

Author:

    Colin Watson    (colinw)    21-Nov-1993

Environment:


Revision History:


--*/

#define UNICODE


#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ctype.h>

#include <validc.h>
#include <nwstatus.h>
#include <nwcanon.h>
#include <ntddnwfs.h>
#include <npapi.h>

#include <nwxchg.h>
#include <nwapi.h>
#include <nwapi32.h>
#include <nwpapi32.h>
#include <ndsapi32.h>
#include <nds.h>

#include <debugfmt.h>   // FORMAT_LPSTR
#include <mpr.h>

#include <lmcons.h>
#include <ntsam.h>
#include <nwpkstr.h>

#ifdef WIN95
#include "defines.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\tpath.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tpath.c

Abstract:

    Test for canonicalization helpers.

Author:

    Rita Wong (ritaw) 22-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>

#include <nwcanon.h>

#ifndef UNICODE
#define UNICODE
#endif

DWORD
TestCanonLocalName(
    IN LPWSTR LocalName,
    IN DWORD ExpectedError
    );

DWORD
TestCanonRemoteName(
    IN LPWSTR RemoteName,
    IN DWORD ExpectedError
    );

// BYTE WorkBuffer[1024];

void __cdecl
main(
    void
    )
{


    TestCanonLocalName(
        L"x:",
        NO_ERROR
        );

    TestCanonLocalName(
        L"B:",
        NO_ERROR
        );

    TestCanonLocalName(
        L"prn",
        NO_ERROR
        );

    TestCanonLocalName(
        L"lpt1:",
        NO_ERROR
        );

    TestCanonLocalName(
        L"*:",
        ERROR_INVALID_NAME
        );

    TestCanonLocalName(
        L"B",
        ERROR_INVALID_NAME
        );

    TestCanonLocalName(
        L"abc",
        ERROR_INVALID_NAME
        );

    TestCanonLocalName(
        L"\\:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Ser:ver",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\*",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume",
        NO_ERROR
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume\\Dir1\\Directory2\\ALongDirectory3",
        NO_ERROR
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume\\",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"Server\\Volume\\",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volu:me",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume\\\\Dir",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server/Volume\\Dir",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server",
        ERROR_INVALID_NAME
        );

}


DWORD
TestCanonLocalName(
    IN LPWSTR LocalName,
    IN DWORD ExpectedError
    )
{
    DWORD status;
    DWORD OutputBufferLength;
    LPWSTR OutputBuffer;


    printf("\nCanon local name %ws\n", LocalName);

    status = NwLibCanonLocalName(
                 LocalName,
                 &OutputBuffer,
                 &OutputBufferLength
                 );

    if (status == NO_ERROR) {

        printf("   got %ws, length %lu\n", OutputBuffer, OutputBufferLength);

        (void) LocalFree((HLOCAL) OutputBuffer);
    }

    if (status == ExpectedError) {
        printf("   SUCCESS: Got %lu as expected\n", ExpectedError);

    }
    else {
        printf("   FAILED: Got %lu, expected %lu\n", status, ExpectedError);
    }
}


DWORD
TestCanonRemoteName(
    IN LPWSTR RemoteName,
    IN DWORD ExpectedError
    )
{
    DWORD status;
    DWORD OutputBufferLength;
    LPWSTR OutputBuffer;


    printf("\nCanon remote name %ws\n", RemoteName);

    status = NwLibCanonRemoteName(
                 RemoteName,
                 &OutputBuffer,
                 &OutputBufferLength
                 );

    if (status == NO_ERROR) {

        printf("   got %ws, length %lu\n", OutputBuffer, OutputBufferLength);

        (void) LocalFree((HLOCAL) OutputBuffer);
    }

    if (status == ExpectedError) {
        printf("   SUCCESS: Got %lu as expected\n", ExpectedError);

    }
    else {
        printf("   FAILED: Got %lu, expected %lu\n", status, ExpectedError);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\winnt\nds32nt.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32NT.c

Abstract:

    This module implements functions to Read, Add, Modify, and Remove
    NDS Objects and Attributes using the Microsoft Netware redirector.
    All functions in this file are NT specific.
    
Author:

    Glenn Curtis    [GlennC]    04-Jan-1996
    Glenn Curtis    [GlennC]    24-Apr-1996 - Added schema APIs
    Glenn Curtis    [GlennC]    20-Jun-1996 - Added search API
    Felix Wong      [t-felixw]  24-Sep-1996 - Added Win95 Support
--*/

#include <procs.h>

typedef struct
{
    DWORD      Signature;
    HANDLE     NdsTree;
    DWORD      ObjectId;
    DWORD_PTR  ResumeId;
    DWORD_PTR  NdsRawDataBuffer;
    DWORD      NdsRawDataSize;
    DWORD      NdsRawDataId;
    DWORD      NdsRawDataCount;
    WCHAR      Name[1];

} NDS_OBJECT, * LPNDS_OBJECT;

DWORD
GetFirstNdsSubTreeEntry(
    OUT LPNDS_OBJECT lpNdsObject,
    IN  DWORD BufferSize )
{
    NTSTATUS ntstatus;

    lpNdsObject->NdsRawDataSize = BufferSize;

    //
    // Determine size of NDS raw data buffer to use. Set to at least 8KB.
    //
    if ( lpNdsObject->NdsRawDataSize < 8192 )
        lpNdsObject->NdsRawDataSize = 8192;

    //
    // Create NDS raw data buffer.
    //
    lpNdsObject->NdsRawDataBuffer = (DWORD_PTR) LocalAlloc( LMEM_ZEROINIT,
                                                     lpNdsObject->NdsRawDataSize );

    if ( lpNdsObject->NdsRawDataBuffer == 0 )
    {
        KdPrint(("NWWORKSTATION: NwGetFirstNdsSubTreeEntry LocalAlloc Failed %lu\n", GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Set up to get initial NDS subordinate list.
    //
    lpNdsObject->NdsRawDataId = INITIAL_ITERATION;

    ntstatus = NwNdsList( lpNdsObject->NdsTree,
                        lpNdsObject->ObjectId,
                        &lpNdsObject->NdsRawDataId,
                        (LPBYTE) lpNdsObject->NdsRawDataBuffer,
                        lpNdsObject->NdsRawDataSize );

    //
    // If error, clean up the Object and return.
    //
    if ( ntstatus != STATUS_SUCCESS ||
         ((PNDS_RESPONSE_SUBORDINATE_LIST)
             lpNdsObject->NdsRawDataBuffer)->SubordinateEntries == 0 )
    {
        if ( lpNdsObject->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
        lpNdsObject->NdsRawDataBuffer = 0;
        lpNdsObject->NdsRawDataSize = 0;
        lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
        lpNdsObject->NdsRawDataCount = 0;
        lpNdsObject->ResumeId = 0;

        return WN_NO_MORE_ENTRIES;
    }

    lpNdsObject->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                       lpNdsObject->NdsRawDataBuffer)->SubordinateEntries - 1;

    lpNdsObject->ResumeId = lpNdsObject->NdsRawDataBuffer +
                              sizeof(NDS_RESPONSE_SUBORDINATE_LIST);

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
GetNextNdsSubTreeEntry(
    OUT LPNDS_OBJECT lpNdsObject )
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    PBYTE pbRaw;
    DWORD dwStrLen;

    if ( lpNdsObject->NdsRawDataCount == 0 &&
         lpNdsObject->NdsRawDataId == INITIAL_ITERATION )
        return WN_NO_MORE_ENTRIES;

    if ( lpNdsObject->NdsRawDataCount == 0 &&
         lpNdsObject->NdsRawDataId != INITIAL_ITERATION )
    {
        ntstatus = NwNdsList( lpNdsObject->NdsTree,
                            lpNdsObject->ObjectId,
                            &lpNdsObject->NdsRawDataId,
                            (LPBYTE) lpNdsObject->NdsRawDataBuffer,
                            lpNdsObject->NdsRawDataSize );

        //
        // If error, clean up the Object and return.
        //
        if (ntstatus != STATUS_SUCCESS)
        {
            if ( lpNdsObject->NdsRawDataBuffer )
                (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
            lpNdsObject->NdsRawDataBuffer = 0;
            lpNdsObject->NdsRawDataSize = 0;
            lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsObject->NdsRawDataCount = 0;

            return WN_NO_MORE_ENTRIES;
        }

        lpNdsObject->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                           lpNdsObject->NdsRawDataBuffer)->SubordinateEntries - 1;

        lpNdsObject->ResumeId = lpNdsObject->NdsRawDataBuffer +
                                  sizeof(NDS_RESPONSE_SUBORDINATE_LIST);

        return RtlNtStatusToDosError(ntstatus);
    }

    lpNdsObject->NdsRawDataCount--;

    //
    // Move pointer past the fixed header portion of a
    // NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw = (BYTE *) lpNdsObject->ResumeId;
    pbRaw += sizeof(NDS_RESPONSE_SUBORDINATE_ENTRY);

    //
    // Move pointer past the length value of the Class Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof(DWORD);

    //
    // Move pointer past the Class Name string of a
    // NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Move pointer past the length value of the Object Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof(DWORD);

    lpNdsObject->ResumeId = (DWORD_PTR) ( pbRaw + ROUNDUP4( dwStrLen ) );

    return RtlNtStatusToDosError(ntstatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\winnt\ndsapint.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsApiNT.c

Abstract:

    This module implements the NT specific exposed user-mode link to
    Netware NDS support in the Netware redirector.  For
    more comments, see ndslib32.h.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include <procs.h>

NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
) {

    NTSTATUS ntstatus, OpenStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[128];
    UNICODE_STRING uOpenName;
    UINT i;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Prepare the open name.
    //

    uOpenName.MaximumLength = sizeof( NameStr );

    if ( puNdsTree->Length > (MAX_NDS_TREE_NAME_LEN * sizeof(WCHAR)))
        return STATUS_INVALID_PARAMETER;

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    try {

        for ( i = 0 ; i < ( puNdsTree->Length / sizeof( WCHAR ) ) ; i++ ) {
            NameStr[i + PreambleLength] = puNdsTree->Buffer[i];
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;

    }

    uOpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) ));
    uOpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOpenName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    ntstatus = NtOpenFile(
                   phNwRdrHandle,
                   DesiredAccess,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    OpenStatus = IoStatusBlock.Status;

    //
    // Verify that this is a tree handle, not a server handle.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET)RrpData;

    Rrp->Version = 0;

    RtlCopyMemory( &(Rrp->Parameters).VerifyTree,
                   puNdsTree,
                   sizeof( UNICODE_STRING ) );

    RtlCopyMemory( (BYTE *)(&(Rrp->Parameters).VerifyTree.NameString),
                   puNdsTree->Buffer,
                   puNdsTree->Length );
    (Rrp->Parameters).VerifyTree.TreeName.Buffer = (Rrp->Parameters).VerifyTree.NameString;

    try {

        ntstatus = NtFsControlFile( *phNwRdrHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_VERIFY_TREE,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puNdsTree->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ntstatus = GetExceptionCode();
        goto CloseAndExit;
    }

    if ( !NT_SUCCESS( ntstatus )) {
        goto CloseAndExit;
    }

    //
    // Otherwise, all is well!
    //

    return OpenStatus;

CloseAndExit:

    NtClose( *phNwRdrHandle );
    *phNwRdrHandle = NULL;

    return ntstatus;
}

NTSTATUS
NwOpenHandleWithSupplementalCredentials(
    IN PUNICODE_STRING puResourceName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwHandle
) {

    NTSTATUS ntstatus, OpenStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = FILE_GENERIC_READ | FILE_GENERIC_WRITE;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[128];
    UNICODE_STRING uOpenName;
    UINT i;

    PFILE_FULL_EA_INFORMATION pEaEntry;
    PBYTE EaBuffer;
    ULONG EaLength, EaNameLength, EaTotalLength;
    ULONG UserNameLen, PasswordLen, TypeLen, CredLen;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Prepare the open name.
    //

    uOpenName.MaximumLength = sizeof( NameStr );

    if ( puResourceName->Length > uOpenName.MaximumLength - ( PreambleLength * sizeof(WCHAR) ) )
        return STATUS_INVALID_PARAMETER;

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    try {

        for ( i = 0 ; i < ( puResourceName->Length / sizeof( WCHAR ) ) ; i++ ) {
            NameStr[i + PreambleLength] = puResourceName->Buffer[i];
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;

    }

    uOpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) ));
    uOpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOpenName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    //
    // Allocate the EA buffer - be a little generous.
    //

    UserNameLen = strlen( EA_NAME_USERNAME );
    PasswordLen = strlen( EA_NAME_PASSWORD );
    TypeLen = strlen( EA_NAME_TYPE );
    CredLen = strlen( EA_NAME_CREDENTIAL_EX );

    EaLength = 4 * sizeof( FILE_FULL_EA_INFORMATION );
    EaLength += 4 * sizeof( ULONG );
    EaLength += ROUNDUP4( UserNameLen );
    EaLength += ROUNDUP4( PasswordLen );
    EaLength += ROUNDUP4( TypeLen );
    EaLength += ROUNDUP4( CredLen  );
    EaLength += ROUNDUP4( puUserName->Length );
    EaLength += ROUNDUP4( puPassword->Length );

    EaBuffer = LocalAlloc( LMEM_ZEROINIT, EaLength );

    if ( !EaBuffer ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pack in the first EA: UserName.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION) EaBuffer;

    EaNameLength = UserNameLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = puUserName->Length;

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_USERNAME,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    RtlCopyMemory( &(pEaEntry->EaName[EaNameLength]),
                   puUserName->Buffer,
                   puUserName->Length );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               puUserName->Length;

    EaLength = ROUNDUP4( EaLength );

    EaTotalLength = EaLength;

    pEaEntry->NextEntryOffset = EaLength;

    //
    // Pack in the second EA: Password.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION)
               ( ( (PBYTE)pEaEntry ) + pEaEntry->NextEntryOffset );

    EaNameLength = PasswordLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = puPassword->Length;

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_PASSWORD,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    RtlCopyMemory( &(pEaEntry->EaName[EaNameLength]),
                   puPassword->Buffer,
                   puPassword->Length );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               puPassword->Length;

    EaLength = ROUNDUP4( EaLength );

    EaTotalLength += EaLength;

    pEaEntry->NextEntryOffset = EaLength;

    //
    // Pack in the third EA: Type.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION)
               ( ( (PBYTE)pEaEntry ) + pEaEntry->NextEntryOffset );

    EaNameLength = TypeLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = sizeof( ULONG );

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_TYPE,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               sizeof( ULONG );

    EaLength = ROUNDUP4( EaLength );

    EaTotalLength += EaLength;

    pEaEntry->NextEntryOffset = EaLength;

    //
    // Pack in the fourth EA: the CredentialEx flag.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION)
               ( ( (PBYTE)pEaEntry ) + pEaEntry->NextEntryOffset );

    EaNameLength = CredLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = sizeof( ULONG );

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_CREDENTIAL_EX,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               sizeof( ULONG );

    EaLength = ROUNDUP4( EaLength );
    EaTotalLength += EaLength;

    pEaEntry->NextEntryOffset = 0;

    //
    // Do the open.
    //

    ntstatus = NtCreateFile( phNwHandle,              // File handle (OUT)
                             DesiredAccess,           // Access mask
                             &ObjectAttributes,       // Object attributes
                             &IoStatusBlock,          // Io status
                             NULL,                    // Optional Allocation size
                             FILE_ATTRIBUTE_NORMAL,   // File attributes
                             FILE_SHARE_VALID_FLAGS,  // File share access
                             FILE_OPEN,               // Create disposition
                             0,                       // Create options
                             (PVOID) EaBuffer,        // Our EA buffer
                             EaTotalLength );         // Ea buffer length

    LocalFree( EaBuffer );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    OpenStatus = IoStatusBlock.Status;

    //
    // Check the handle type.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET)RrpData;

    Rrp->Version = 0;

    RtlCopyMemory( &(Rrp->Parameters).VerifyTree,
                   puResourceName,
                   sizeof( UNICODE_STRING ) );

    RtlCopyMemory( (BYTE *)(&(Rrp->Parameters).VerifyTree) + sizeof( UNICODE_STRING ),
                   puResourceName->Buffer,
                   puResourceName->Length );

    try {

        ntstatus = NtFsControlFile( *phNwHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_VERIFY_TREE,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puResourceName->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ntstatus = GetExceptionCode();
        goto CloseAndExit2;
    }

    if ( !NT_SUCCESS( ntstatus ))
    {
        *lpdwHandleType = HANDLE_TYPE_NCP_SERVER;
    }
    else
    {
        *lpdwHandleType = HANDLE_TYPE_NDS_TREE;
    }

    return OpenStatus;

CloseAndExit2:

    NtClose( *phNwHandle );
    *phNwHandle = NULL;

    return ntstatus;
}

NTSTATUS
NwNdsResolveName (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *dwObjectId,
    OUT PUNICODE_STRING puReferredServer,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    PNDS_RESPONSE_RESOLVE_NAME Rsp;
    DWORD dwRspBufferLen, dwNameLen, dwPadding;

    BYTE RrpData[1024];
    BYTE RspData[256];

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;

    RtlZeroMemory( Rrp, 1024 );

    //
    // NW NDS strings are null terminated, so we make sure we
    // report the correct length...
    //

    dwNameLen = puObjectName->Length + sizeof( WCHAR );
    if (dwNameLen > MAX_NDS_NAME_SIZE)
    {
        return STATUS_INVALID_PARAMETER;
    }

    Rrp->Version = 0;
    Rrp->Parameters.ResolveName.ObjectNameLength = ROUNDUP4( dwNameLen );
    Rrp->Parameters.ResolveName.ResolverFlags = RSLV_DEREF_ALIASES |
                                                RSLV_WALK_TREE |
                                                RSLV_WRITABLE;

    try {

        //
        // But don't try to copy more than the user gave us.
        //

        memcpy( Rrp->Parameters.ResolveName.ObjectName,
                puObjectName->Buffer,
                puObjectName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send the request to the Redirector FSD.
    //

    if ( dwResponseBufferLen != 0 &&
         pbRawResponse != NULL ) {

        Rsp = ( PNDS_RESPONSE_RESOLVE_NAME ) pbRawResponse;
        dwRspBufferLen = dwResponseBufferLen;

    } else {

        Rsp = ( PNDS_RESPONSE_RESOLVE_NAME ) RspData;
        dwRspBufferLen = 256;

    }

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_RESOLVE_NAME,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + Rrp->Parameters.ResolveName.ObjectNameLength,
                                    (PVOID) Rsp,
                                    dwRspBufferLen );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    //
    // Dig out the object id and referred server.
    //

    if ( NT_SUCCESS( ntstatus ) ) {

        try {

            *dwObjectId = Rsp->EntryId;

            if ( Rsp->ServerNameLength > puReferredServer->MaximumLength ) {

                ntstatus = STATUS_BUFFER_TOO_SMALL;

            } else {

                RtlCopyMemory( puReferredServer->Buffer,
                               Rsp->ReferredServer,
                               Rsp->ServerNameLength );

                puReferredServer->Length = (USHORT)Rsp->ServerNameLength;

            }

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            return ntstatus;

        }

    }

    return ntstatus;

}

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
);


NTSTATUS
_cdecl
FragExWithWait(
    IN HANDLE  hNdsServer,
    IN DWORD   NdsVerb,
    IN BYTE    *pReplyBuffer,
    IN DWORD   pReplyBufferLen,
    IN OUT DWORD *pdwReplyLen,
    IN BYTE    *NdsRequestStr,
    ...
)
/*

Routine Description:

    Exchanges an NDS request in fragments and collects the fragments
    of the response and writes them to the reply buffer.

Routine Arguments:

    hNdsServer      - A handle to the server you want to talk to.
    NdsVerb         - The verb for that indicates the request.

    pReplyBuffer    - The reply buffer.
    pReplyBufferLen - The length of the reply buffer.

    NdsReqestStr    - The format string for the arguments to this NDS request.
    Arguments       - The arguments that satisfy the NDS format string.

Return Value:

    NTSTATUS - Status of the exchange, but not the result code in the packet.

*/
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET RawRequest = NULL;

    BYTE  *NdsRequestBuf;
    DWORD NdsRequestLen;
    int   bufferSize = 0;

    va_list Arguments;

    //
    // Allocate a request buffer.
    //

    //
    // Calculate needed buffer size . . .
    //
    if ( NdsRequestStr != NULL ) {

        va_start( Arguments, NdsRequestStr );
        bufferSize = CalculateBuf( NdsRequestStr, Arguments );
        va_end( Arguments );

        if ( bufferSize == 0 )
        {
            Status = STATUS_INVALID_PARAMETER;
            goto ExitWithCleanup;
        }

    }

    bufferSize += sizeof( NWR_NDS_REQUEST_PACKET ) + 50;

    RawRequest = LocalAlloc( LMEM_ZEROINIT, bufferSize );

    if ( !RawRequest ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the request in our local buffer.  The first DWORD
    // is the verb and the rest is the formatted request.
    //

    RawRequest->Parameters.RawRequest.NdsVerb = NdsVerb;
    NdsRequestBuf = &RawRequest->Parameters.RawRequest.Request[0];

    if ( NdsRequestStr != NULL ) {

        va_start( Arguments, NdsRequestStr );

        NdsRequestLen = FormatBuf( NdsRequestBuf,
                                   bufferSize - sizeof( NWR_NDS_REQUEST_PACKET ),
                                   NdsRequestStr,
                                   Arguments );

        if ( !NdsRequestLen ) {

           Status = STATUS_INVALID_PARAMETER;
           goto ExitWithCleanup;

        }

        va_end( Arguments );

    } else {

        NdsRequestLen = 0;
    }

    RawRequest->Parameters.RawRequest.RequestLength = NdsRequestLen;

    //
    // Pass this buffer to kernel mode via FSCTL.
    //

    try {

        Status = NtFsControlFile( hNdsServer,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_NDS_RAW_FRAGEX,
                                  (PVOID) RawRequest,
                                  NdsRequestLen + sizeof( NWR_NDS_REQUEST_PACKET ),
                                  (PVOID) pReplyBuffer,
                                  pReplyBufferLen );

        if ( NT_SUCCESS( Status ) ) {
            *pdwReplyLen = RawRequest->Parameters.RawRequest.ReplyLength;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

ExitWithCleanup:

    if ( RawRequest ) {
        LocalFree( RawRequest );
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\attach.c ===
/*************************************************************************
*
*  ATTACH.C
*
*  NT Attach routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\ATTACH.C  $
*  
*     Rev 1.2   10 Apr 1996 14:21:30   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:52:08   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:23:32   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:26   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:36:30   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:10   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nwapi32.h>
#include <ntddnwfs.h>
#include <nwapi.h>
#include <npapi.h>

#include "inc/common.h"
#include "ntnw.h"

/********************************************************************

        GetDefaultConnectionID

Routine Description:

        Return the default connection ID ( the "preferred server" )

Arguments:

        phNewConn - pointer to connection number

Return Value:
        0 = success
        else NetWare error number

 *******************************************************************/
unsigned int
GetDefaultConnectionID(
    unsigned int   *phNewConn
    )
{
    VERSION_INFO VerInfo;
    unsigned int Result;

    if ( fNDS ) 
    {
        Result = NTAttachToFileServer( NDSTREE, phNewConn );
    }
    else 
    {
        //
        //  "*" is the name for the preferred server
        //
        Result = NTAttachToFileServer( "*", phNewConn );
        if ( Result )
            return Result;

        Result = NWGetFileServerVersionInfo( (NWCONN_HANDLE)*phNewConn,
                                         &VerInfo );
        if ( Result )
            return Result;

        NWDetachFromFileServer( (NWCONN_HANDLE)*phNewConn );

        Result = NTAttachToFileServer( VerInfo.szName, phNewConn );
    }
    return Result;

}

/********************************************************************

        NTAttachToFileServer

Routine Description:

        Given a server name, return a connection handle.
        We need our own because NWAPI32 does it's own mapping
        of errors.

Arguments:

        pszServerName - Ascii server name
        phNewConn     - pointer to connection handle

Return Value:
        0 = success
        else NetWare error number

 *******************************************************************/
unsigned int
NTAttachToFileServer(
    unsigned char  *pszServerName,
    unsigned int   *phNewConn
    )
{
    return ( NWAttachToFileServer( pszServerName, 0,
                                   (NWCONN_HANDLE *)phNewConn ) );
}


/********************************************************************

        NTIsConnected

Routine Description:

        Given a server name, is there already a connection to it?

Arguments:

        pszServerName - ascii server name

Return Value:
        TRUE  - a connection to the server exists
        FALSE - a connection to the server does not exist

 *******************************************************************/
unsigned int
NTIsConnected( unsigned char * pszServerName )
{
    LPBYTE       Buffer ; 
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    DWORD        Count ;
    LPWSTR       pszServerNameW;
    INT          nSize;
    DWORD        BufferSize = 4096;

    nSize = (strlen( pszServerName ) + 1 + 2) * sizeof( WCHAR );
    
    //
    // allocate memory and open the enumeration
    //
    if (!(pszServerNameW = LocalAlloc( LPTR, nSize ))) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    wcscpy( pszServerNameW, L"\\\\" );
    szToWide( pszServerNameW + 2, pszServerName, nSize );
 
    //
    // allocate memory and open the enumeration
    //
    if (!(Buffer = LocalAlloc( LPTR, BufferSize ))) {
        (void) LocalFree((HLOCAL) pszServerNameW) ;
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    memset( Buffer, 0, BufferSize );

    dwErr = NPOpenEnum(RESOURCE_CONNECTED, 0, 0, NULL, &EnumHandle) ;
    if (dwErr != WN_SUCCESS) {
        (void) LocalFree((HLOCAL) pszServerNameW) ;
        (void) LocalFree((HLOCAL) Buffer) ;
        return FALSE;
    }

    do {

        Count = 0xFFFFFFFF ;
        BufferSize = 4096;
        dwErr = NwEnumConnections(EnumHandle, &Count, Buffer, &BufferSize, TRUE) ;

        if ((dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
            && ( Count != 0xFFFFFFFF) )
        {
            LPNETRESOURCE lpNetResource ;
            DWORD i ;
            DWORD ServerLen;

            ServerLen = wcslen( pszServerNameW );
            lpNetResource = (LPNETRESOURCE) Buffer ;
            //
            // search for our server
            //
            for ( i = 0; i < Count; lpNetResource++, i++ )
            {
              if ( lpNetResource->lpProvider )
                  if ( _wcsicmp( lpNetResource->lpProvider, NW_PROVIDER ) ) {
                      continue;
                  }
               if ( lpNetResource->lpRemoteName ) {
                   if ( wcslen(lpNetResource->lpRemoteName) > ServerLen ) {
                       if ( lpNetResource->lpRemoteName[ServerLen] == L'\\' ) 
                           lpNetResource->lpRemoteName[ServerLen] = L'\0';
                   }
                   if ( !_wcsicmp(lpNetResource->lpRemoteName, pszServerNameW )) {
                       (void) WNetCloseEnum(EnumHandle) ; 
                       (void) LocalFree((HLOCAL) pszServerNameW) ;
                       (void) LocalFree((HLOCAL) Buffer) ;
                       return TRUE;
                   }
               }
            }

        }

    } while (dwErr == WN_SUCCESS) ;

    (void ) WNetCloseEnum(EnumHandle) ;
    (void) LocalFree((HLOCAL) pszServerNameW) ;
    (void) LocalFree((HLOCAL) Buffer) ;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\winnt\nwattach.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWATTACH.C

Abstract:

      This module contains the NetWare(R) SDK support to routines
      into the NetWare redirector

Author:

      Chris Sandys    (a-chrisa)  09-Sep-1993

Revision History:

      Chuck Y. Chan (chuckc)   02/06/94  Moved to NWCS. Make it more NT like.
      Chuck Y. Chan (chuckc)   02/27/94  Clear out old code. 
                                         Make logout work.
                                         Check for error in many places.
                                         Dont hard code strings.
                                         Remove non compatible parameters.
                                         Lotsa other cleanup.
      Felix Wong (t-felixw)    09/16/96  Moved functions for Win95 port.
                                  
--*/


#include "procs.h"
#include "nwapi32.h"
#include <stdio.h>

//
// Define structure for internal use. Our handle passed back from attach to
// file server will be pointer to this. We keep server string around for
// discnnecting from the server on logout. The structure is freed on detach.
// Callers should not use this structure but treat pointer as opaque handle.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

//
// define define categories of errors
//
typedef enum _NCP_CLASS {
    NcpClassConnect,
    NcpClassBindery,
    NcpClassDir
} NCP_CLASS ;

//
// define error mapping structure
//
typedef struct _NTSTATUS_TO_NCP {
    NTSTATUS NtStatus ;
    NWCCODE  NcpCode  ;
} NTSTATUS_TO_NCP, *LPNTSTATUS_TO_NCP ;
    
NWCCODE
MapNtStatus(
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
);

DWORD
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) ;
DWORD
szToWide(
    LPWSTR lpszW,
    LPCSTR lpszC,
    INT nSize
);
//
// Forwards
//
NTSTATUS 
NwAttachToServer(
    LPWSTR      ServerName,
    LPHANDLE    phandleServer
    );

NTSTATUS 
NwDetachFromServer(
      HANDLE    handleServer
);

NWCCODE NWAPI DLLEXPORT
NWAttachToFileServer(
    const char      NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    )
{
    DWORD            dwRes;
    NWCCODE          nwRes;
    LPWSTR           lpwszServerName;   // Pointer to buffer for WIDE servername
    int              nSize;
    PNWC_SERVER_INFO pServerInfo ;


    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return INVALID_CONNECTION ;

    *phNewConn = NULL ; 

    //
    // Allocate a buffer for wide server name 
    //
    nSize = strlen(pszServerName)+1 ;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    if (szToWide( lpwszServerName, pszServerName, nSize ) != NO_ERROR)
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }

    //
    // Call createfile to get a handle for the redirector calls
    //
    nwRes = NWAttachToFileServerW( lpwszServerName, 
                                   ScopeFlag,
                                   phNewConn );


ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if (lpwszServerName)
        (void) LocalFree( (HLOCAL) lpwszServerName );

    //
    // Return with NWCCODE
    //
    return( nwRes );
}


NWCCODE NWAPI DLLEXPORT
NWAttachToFileServerW(
    const WCHAR     NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    )
{
    DWORD            NtStatus;
    NWCCODE          nwRes;
    LPWSTR           lpwszServerName;   // Pointer to buffer for WIDE servername
    int              nSize;
    PNWC_SERVER_INFO pServerInfo = NULL;

    UNREFERENCED_PARAMETER(ScopeFlag) ;

    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return INVALID_CONNECTION ;

    *phNewConn = NULL ; 

    //
    // Allocate a buffer to store the file server name 
    //
    nSize = wcslen(pszServerName)+3 ;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    wcscpy( lpwszServerName, L"\\\\" );
    wcscat( lpwszServerName, pszServerName );

    //
    // Allocate a buffer for the server info (handle + name pointer). Also
    // init the unicode string.
    //
    if( !(pServerInfo = (PNWC_SERVER_INFO) LocalAlloc( 
                                              LPTR, 
                                              sizeof(NWC_SERVER_INFO))) ) 
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    RtlInitUnicodeString(&pServerInfo->ServerString, lpwszServerName) ;

    //
    // Call createfile to get a handle for the redirector calls
    //
    NtStatus = NwAttachToServer( lpwszServerName, &pServerInfo->hConn );

    if(NT_SUCCESS(NtStatus))
    {
        nwRes = SUCCESSFUL;
    } 
    else 
    {
        (void) SetWin32ErrorFromNtStatus( NtStatus );
        nwRes = MapNtStatus( NtStatus, NcpClassConnect );
    }

ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if (nwRes != SUCCESSFUL)
    {
        if (lpwszServerName)
            (void) LocalFree( (HLOCAL) lpwszServerName );
        if (pServerInfo)
            (void) LocalFree( (HLOCAL) pServerInfo );
    }
    else
        *phNewConn  = (HANDLE) pServerInfo ;

    //
    // Return with NWCCODE
    //
    return( nwRes );
}


NWCCODE NWAPI DLLEXPORT
NWDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    (void) NwDetachFromServer( pServerInfo->hConn );

    (void) LocalFree (pServerInfo->ServerString.Buffer) ;

    //
    // catch any body that still trirs to use this puppy...
    //
    pServerInfo->ServerString.Buffer = NULL ;   
    pServerInfo->hConn = NULL ;

    (void) LocalFree (pServerInfo) ;

    return SUCCESSFUL;
}



//
// worker routines
//

#define NW_RDR_SERVER_PREFIX L"\\Device\\Nwrdr\\"

NTSTATUS
NwAttachToServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    )
/*++

Routine Description:

    This routine opens a handle to the given server.

Arguments:

    ServerName    - The server name to attach to.
    phandleServer - Receives an opened handle to the preferred or
                    nearest server.

Return Value:

    0 or reason for failure.

--*/
{
    NTSTATUS            ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    LPWSTR FullName;
    UNICODE_STRING UServerName;

    FullName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                    (UINT) ( wcslen( NW_RDR_SERVER_PREFIX) +
                                             wcslen( ServerName ) - 1) *
                                             sizeof(WCHAR)
                                  );

    if ( FullName == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    wcscpy( FullName, NW_RDR_SERVER_PREFIX );
    wcscat( FullName, ServerName + 2 );    // Skip past the prefix "\\"

    RtlInitUnicodeString( &UServerName, FullName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a handle to the preferred server.
    //
    ntstatus = NtOpenFile(
                   phandleServer,
                   SYNCHRONIZE | FILE_LIST_DIRECTORY,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        *phandleServer = NULL;
    }

    LocalFree( FullName );
    return (ntstatus);
}


NTSTATUS
NwDetachFromServer(
    IN HANDLE handleServer
    )
/*++

Routine Description:

    This routine closes a handle to the given server.

Arguments:

    handleServer - Supplies a open handle to be closed.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS ntstatus = NtClose( handleServer );
    return (ntstatus);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\regacl.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regacl.c

Abstract:

    This module contains the code for adding access permission ACL in a registry
    key.

Author:

    Terrence Kwan (terryk)   25-Sept-1993

Revision History:

--*/

#include <procs.h>

DWORD
NwLibSetEverybodyPermission(
    IN HKEY hKey,
    IN DWORD dwPermission
    )
/*++

Routine Description:

    Set the registry key to everybody "Set Value" (or whatever
    the caller want.)

Arguments:

    hKey - The handle of the registry key to set security on

    dwPermission - The permission to add to "everybody"

Return Value:

    The win32 error.

--*/
{
    LONG err;                           // error code
    PSECURITY_DESCRIPTOR psd = NULL;    // related SD
    PACL pDacl = NULL;                  // Absolute DACL
    PACL pSacl = NULL;                  // Absolute SACL
    PSID pOSid = NULL;                  // Absolute Owner SID
    PSID pPSid = NULL;                  // Absolute Primary SID

    do {  // Not a loop, just for breaking out of error
        //
        // Initialize all the variables...
        //
                                                        // world sid authority
        SID_IDENTIFIER_AUTHORITY SidAuth= SECURITY_WORLD_SID_AUTHORITY;
        DWORD cbSize=0;                                 // Security key size
        PACL pAcl;                                      // original ACL
        BOOL fDaclPresent;
        BOOL fDaclDefault;
        PSID pSid;                                      // original SID
        SECURITY_DESCRIPTOR absSD;                      // Absolute SD
        DWORD AbsSize = sizeof(SECURITY_DESCRIPTOR);    // Absolute SD size
        DWORD DaclSize;                                 // Absolute DACL size
        DWORD SaclSize;                                 // Absolute SACL size
        DWORD OSidSize;                                 // Absolute OSID size
        DWORD PSidSize;                                 // Absolute PSID size


        // Get the original DACL list

        RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, NULL, &cbSize);

        psd = (PSECURITY_DESCRIPTOR *)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pDacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pSacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pOSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pPSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        DaclSize = cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);
        SaclSize = cbSize;
        OSidSize = cbSize;
        PSidSize = cbSize;

        if (( NULL == psd) ||
            ( NULL == pDacl) ||
            ( NULL == pSacl) ||
            ( NULL == pOSid) ||
            ( NULL == pPSid))
        {
            err = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if ( (err = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd, &cbSize )) != ERROR_SUCCESS )
        {
            break;
        }
        if ( !GetSecurityDescriptorDacl( psd, &fDaclPresent, &pAcl, &fDaclDefault ))
        {
            err = GetLastError();
            break;
        }

        // Increase the size for an extra ACE

        pAcl->AclSize += sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);

        // Get World SID

        if ( (err = RtlAllocateAndInitializeSid( &SidAuth, 1,
              SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSid)) != ERROR_SUCCESS)
        {
            break;
        }

        // Add Permission ACE

        if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, dwPermission ,pSid))
        {
            err = GetLastError();
            break;
        }

        // Convert from relate format to absolute format

        if ( !MakeAbsoluteSD( psd, &absSD, &AbsSize, pDacl, &DaclSize, pSacl, &SaclSize,
                        pOSid, &OSidSize, pPSid, &PSidSize ))
        {
            err = GetLastError();
            break;
        }

        // Set SD

        if ( !SetSecurityDescriptorDacl( &absSD, TRUE, pAcl, FALSE ))
        {
            err = GetLastError();
            break;
        }
        if ( (err = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd ))
              != ERROR_SUCCESS )
        {
            break;
        }

    } while (FALSE);

    // Clean up the memory

    LocalFree( psd );
    LocalFree( pDacl );
    LocalFree( pSacl );
    LocalFree( pOSid );
    LocalFree( pPSid );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwlib\winnt\exchange.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    exchange.c

Abstract:

    Contains routine which packages the request buffer, makes
    the NCP request, and unpackages the response buffer.

Author:

    Hans Hurvig     (hanshu)       Aug-1992  Created
    Colin Watson    (colinw)    19-Dec-1992
    Rita Wong       (ritaw)     11-Mar-1993  FSCtl version

Environment:


Revision History:


--*/


#include <procs.h>

NTSTATUS
GetFileServerVersionInfo(
    HANDLE                DeviceHandle,
    VERSION_INFO NWFAR   *lpVerInfo
    )
{
    NTSTATUS NtStatus ;

    NtStatus = NwlibMakeNcp(
                    DeviceHandle,           // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );

    return NtStatus;
}


NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    )
/*++

Routine Description:

    This function converts the input arguments into an NCP request buffer
    based on the format specified in FormatString (e.g. takes a word
    and writes it in hi-lo format in the request buffer as required by
    an NCP).

    It then makes the NCP call via the NtFsControlFile API.

    The FormatString also specifies how to convert the fields in the
    response buffer from the completed NCP call into the output
    arguments.

    The FormatString takes the form of "xxxx|yyyy" where each 'x'
    indicates an input argument to convert from, and each 'y' indicates
    an output argument to convert into.  The '|' character separates
    the input format from the output format specifications.

Arguments:

    DeviceHandle - Supplies a handle to the network file system driver
        which will be making the network request.  This function
        assumes that the handle was opened for synchronouse I/O access.

    FsControlCode - Supplies the control code which determines the
        NCP.

    RequestBufferSize - Supplies the size of the request buffer in
        bytes to be allocated by this routine.

    ResponseBufferSize - Supplies the size of the response buffer in
        bytes to be allocated by this routine.

    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'P'      DBCS pstring      ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'r'      raw bytes         ( byte*, word )
            'R'      DBCS raw bytes    ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )
            'W'      word n followed by an array of word[n] ( word, word* )

Return Value:

    Return code from the NCP call.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    va_list Arguments;
    PCHAR z;
    WORD t = 1;
    ULONG data_size;

    LPBYTE RequestBuffer = NULL;
    LPBYTE ResponseBuffer;

    IO_STATUS_BLOCK IoStatusBlock;
    DWORD ReturnedDataSize;

    BOOL SpecialCaseChangePass = FALSE;
    BOOL DontFreeBuffer = FALSE;
    BOOL GetVersionInfo = TRUE;
    BOOL DoMapSpecialJapaneseCharThing = TRUE;
    VERSION_INFO VerInfo;

    //
    // Allocate memory for request and response buffers.
    //
    RequestBuffer = LocalAlloc(
                        LMEM_ZEROINIT,
                        RequestBufferSize + ResponseBufferSize + 0x20
                        );

    if (RequestBuffer == NULL) {
        KdPrint(("NWLIB: NwlibMakeNcp LocalAlloc failed %lu\n", GetLastError()));
        return STATUS_NO_MEMORY;
    }

    ResponseBuffer = (LPBYTE) ((ULONG_PTR) RequestBuffer + RequestBufferSize);


    va_start( Arguments, FormatString );

    //
    // Convert the input arguments into request packet.
    //
    z = FormatString;

    data_size = 0;

    while ( *z && *z != '|')
    {
        switch ( *z )
        {
        case '=':
            RequestBuffer[data_size++] = 0;
        case '-':
            RequestBuffer[data_size++] = 0;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case '_' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            while ( l-- )
                RequestBuffer[data_size++] = 0;
            break;
        }

        case 'b':
            RequestBuffer[data_size] = va_arg ( Arguments, BYTE );

            //
            // We know the first va_arg is the subfunction. If the function
            // is FSCTL_NWR_NCP_E3H and the subfunctions are those related
            // the Challenge/SetPass then we need do this special case
            // workaround.
            //
            if ( (z == FormatString) &&
                 (FsControlCode == FSCTL_NWR_NCP_E3H) &&
                 ( (RequestBuffer[data_size] == 0x17) ||
                   (RequestBuffer[data_size] == 0x4B) ) ) {

                SpecialCaseChangePass = TRUE ;
            }
            ++data_size ;
            break;

        case 'w':
        {
            WORD w = va_arg ( Arguments, WORD );
            RequestBuffer[data_size++] = (BYTE) (w >> 8);
            RequestBuffer[data_size++] = (BYTE) (w >> 0);
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( Arguments, DWORD );
            RequestBuffer[data_size++] = (BYTE) (d >> 24);
            RequestBuffer[data_size++] = (BYTE) (d >> 16);
            RequestBuffer[data_size++] = (BYTE) (d >>  8);
            RequestBuffer[data_size++] = (BYTE) (d >>  0);
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = (WORD)strlen( c );
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'c' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            RtlCopyMemory( &RequestBuffer[data_size], c, l+1 );
            data_size += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( Arguments, char* );
            WORD l = va_arg ( Arguments, WORD );
            WORD len = strlen( c ) + 1;
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'C' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RtlCopyMemory( &RequestBuffer[data_size], c, len > l? l : len);
            data_size += l;
            RequestBuffer[data_size-1] = 0;
            break;
        }

        case 'P':
        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = (BYTE)strlen( c );
            char* p;

            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'p' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            RequestBuffer[data_size++] = l;
            RtlCopyMemory( (p=(char*)&RequestBuffer[data_size]), c, l );
            data_size += l;

            //
            // Map Japanese special chars
            //
            if (*z == 'P')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                     MapSpecialJapaneseChars(p, (WORD)l);
                }
            }

            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( data_size + Length > RequestBufferSize ) {
                KdPrint(("NWLIB: NwlibMakeNcp case 'u' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RequestBuffer[data_size++] = (UCHAR)Length;
            OemString.Buffer = &RequestBuffer[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));
            data_size += (USHORT)Length;
            break;
        }

        case 'U':
        {
            //
            //  UPPERCASE the string, copy it from unicode to the packet
            //

            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            UNICODE_STRING UUppercaseString;
            OEM_STRING OemString;
            ULONG Length;

            status = RtlUpcaseUnicodeString(&UUppercaseString, pUString, TRUE);
            if ( status )
            {
                goto CleanExit;
            }

            pUString = &UUppercaseString;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( data_size + Length > RequestBufferSize ) {
                KdPrint(("NWLIB: NwlibMakeNcp case 'U' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RequestBuffer[data_size++] = (UCHAR)Length;
            OemString.Buffer = &RequestBuffer[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));

            RtlFreeUnicodeString( &UUppercaseString );

            data_size += (USHORT)Length;
            break;
        }

        case 'R':
        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            char* c;

            if ( data_size + l > RequestBufferSize )
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'r' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RtlCopyMemory( (c=(char*)&RequestBuffer[data_size]), b, l );
            data_size += l;

            //
            // Map Japanese special chars
            //
            if (*z == 'R')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                     MapSpecialJapaneseChars(c, (WORD)l);
                }
            }

            break;
        }

        default:
            KdPrint(("NWLIB: NwlibMakeNcp invalid request field, %x\n", *z));
            ASSERT(FALSE);
        }

        if ( data_size > RequestBufferSize )
        {
            KdPrint(("NWLIB: NwlibMakeNcp too much request data\n"));
            status = STATUS_BUFFER_TOO_SMALL;
            goto CleanExit;
        }


        z++;
    }


    //
    // Make the NCP request
    //
    status = NtFsControlFile(
                 DeviceHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FsControlCode,
                 (PVOID) RequestBuffer,
                 RequestBufferSize,
                 (PVOID) ResponseBuffer,
                 ResponseBufferSize
                 );

    if ( (status == STATUS_PENDING) && SpecialCaseChangePass ) {

        //
        // TRACKING - remove this when bug 99008 is fixed in NwRdr.
        // The NwRdr fix is nontrivial.
        //
        // This call is supposed to be synchronous. For some reason, if
        // supplemental credentials are used, it is NOT. Since the redir
        // is already shipped, we workaround it. We do so as follows:
        //
        //    a) give the redir a chance to fill in the buffer (not a real fix)
        //    b) dont free the buffer. its better to leak in this case (not
        //       common) than to trash the heap.
        //    c) set result to success so we will continue.
        //
        Sleep(200) ;
        DontFreeBuffer = TRUE ;
        status = STATUS_SUCCESS ;
    }

    if (status == STATUS_SUCCESS) {
        status = IoStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {

#if 0
        if (! NT_SUCCESS(status)) {
            KdPrint(("NWLIB: NwlibMakeNcp: NtFsControlFile returns x%08lx\n", status));
        }
#endif

        goto CleanExit;
    }


    ReturnedDataSize = (DWORD) IoStatusBlock.Information; // Number of bytes returned
                                                          //    in ResponseBuffer


    //
    // Convert the response packet into output arguments.
    //

    data_size = 0;

    if (*z && *z == '|') {
        z++;
    }

    while ( *z )
    {
        switch ( *z )
        {
        case '-':
            data_size += 1;
            break;

        case '=':
            data_size += 2;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            data_size += l;
            break;
        }

        case 'b':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            *b = ResponseBuffer[data_size++];
            break;
        }

        case 'w':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];
            break;
        }

        case 'd':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[3] = ResponseBuffer[data_size++];
            b[2] = ResponseBuffer[data_size++];
            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = (WORD)strlen( &ResponseBuffer[data_size] );
            if ( data_size+l+1 < ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], l+1 );
            }
            data_size += l+1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( Arguments, char* );
            WORD l = va_arg ( Arguments, WORD );
            WORD len = strlen( &ResponseBuffer[data_size] ) + 1;

            if ( data_size + l < ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], len > l ? l :len);
            }
            c[l-1] = 0;
            data_size += l;
            break;

        }

        case 'P':
        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = ResponseBuffer[data_size++];
            if ( data_size+l <= ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], l );
                c[l] = 0;
            }
            data_size += l;

            //
            // Unmap Japanese special chars
            //
            if (*z == 'P')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                    UnmapSpecialJapaneseChars(c, l);
                }
            }

            break;
        }

        case 'R':
        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            RtlCopyMemory( b, &ResponseBuffer[data_size], l );
            data_size += l;

            //
            // Unmap Japanese special chars
            //
            if (*z == 'R')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                    UnmapSpecialJapaneseChars(b, l);
                }
            }
            break;
        }

        case 'W':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            BYTE* w = va_arg ( Arguments, BYTE* );
            WORD  i;

            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];

            for ( i = 0; i < ((WORD) *b); i++, w += sizeof(WORD) )
            {
                w[1] = ResponseBuffer[data_size++];
                w[0] = ResponseBuffer[data_size++];
            }
            break;
        }

        default:
            KdPrint(("NWLIB: NwlibMakeNcp invalid response field, %x\n", *z));
            ASSERT(FALSE);
        }

        if ( data_size > ReturnedDataSize )
        {
            KdPrint(("NWLIB: NwlibMakeNcp not enough response data\n"));
            status = STATUS_UNSUCCESSFUL;
            goto CleanExit;
        }

        z++;
    }

    status = STATUS_SUCCESS;

CleanExit:
    if ((RequestBuffer != NULL) && !DontFreeBuffer) {
        (void) LocalFree((HLOCAL) RequestBuffer);
    }

    va_end( Arguments );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\break.c ===
/*************************************************************************
*
*  BREAK.C
*
*  Control-C and Control-Break routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\BREAK.C  $
*  
*     Rev 1.2   10 Apr 1996 14:21:38   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:52:16   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:23:38   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:28   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:14   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"
#include "ntnw.h"


/*
 *  Handler for console events
 */
BOOL WINAPI
Handler( DWORD CtrlType )
{
    if ( CtrlType & ( CTRL_C_EVENT | CTRL_BREAK_EVENT ) )
        return TRUE;  /* don't execute default handler */
    else
        return FALSE;
}

/*
 * NTBreakOn
 *
 * Routine Description:
 *
 *       Allow Ctrl+C and Ctrl+Break during logon script
 *
 * Arguments:
 *    none
 *
 * Return Value:
 *    none
 */
void NTBreakOn( void )
{
    (void) SetConsoleCtrlHandler( &Handler, FALSE );
}

/*
 * NTBreakOff
 *
 * Routine Description:
 *
 *       Prevent Ctrl+C and Ctrl+Break during logon script
 *
 * Arguments:
 *    none
 *
 * Return Value:
 *    none
 */
void NTBreakOff( void )
{
    (void) SetConsoleCtrlHandler( &Handler, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\date.c ===
/*************************************************************************
*
*  DATE.C
*
*  NT date routine
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DATE.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:00   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:52:56   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:04   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:40   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:22   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"


/*
 *******************************************************************

        NTGetTheDate

Routine Description:

        Return the current date

Arguments:

        yearCurrent  pointer to current year
                     1980-2099
        monthCurrent pointer to current month
                     1-12
        dayCurrent   pointer to current day
                     1-31

Return Value:

        

 *******************************************************************
 */
void NTGetTheDate( unsigned int * yearCurrent,
                   unsigned char * monthCurrent,
                   unsigned char * dayCurrent ) 
{
    time_t timedat;
    struct tm * p_tm;

    (void) time( &timedat );
    p_tm = localtime( &timedat );

    *yearCurrent =  p_tm->tm_year + 1900;
    *monthCurrent = p_tm->tm_mon + 1;
    *dayCurrent =   (UCHAR) p_tm->tm_mday;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\capture.c ===
/*
 * Module Name:
 *        capture.c
 *  Copyright (c) 1995 Microsoft Corporation
 * 
 * Abstract:
 * 
 *      SYNTAX (Command line)
 *                 - Usage:  Capture [/Options]
 * 
 * Author : Congpa You (Congpay)
 * 
 * Revision history :
 *       - 05/24/94      congpay     Created
 */

#include "common.h"

extern char *RemoveSpaces (char * buffer);

typedef struct _CAPTURE_PARAMS {
    UCHAR nLPT;
    char serverName[MAX_NAME_LEN];
    char queueName[MAX_QUEUE_NAME_LEN];
    char bannerUserName[MAX_BANNER_USER_NAME];
    char filePath[_MAX_PATH];
    unsigned int NDSCapture;
    NETWARE_CAPTURE_FLAGS_RW captureFlagsRW;
}CAPTURE_PARAMS, *PCAPTURE_PARAMS;

/* Local Functions*/
void UpcaseArg(int argc, char ** argv);
int  IsShowOption (int argc, char ** argv);
int  IsServerSpecified (int argc, char ** argv);
int  IsNoOption (char * option);
int  IsQuestionMark (int argc, char ** argv);
int  IsValidOption (char *input, char *option, char *shortoption);
void ShowCapture(void);

void GetJobNameFromArg (int argc, char ** argv, char *jobName);

int  InitCaptureParams (unsigned int conn,
                        char *jobName,
                        PCAPTURE_PARAMS pCaptureParams);

int  ReadArguments (int argc,
                    char ** argv,
                    char *jobName,
                    PCAPTURE_PARAMS pCaptureParams);

int  CStartCapture(unsigned int conn,
                   PCAPTURE_PARAMS pCaptureParams);

int GetPrinterDefaultQueue( PCAPTURE_PARAMS, PBYTE );

void
Capture (char ** argv, unsigned int argc)
{
    char jobName[MAX_JOB_NAME_LEN]="";
    CAPTURE_PARAMS captureParams;
    unsigned int conn;

    UpcaseArg(argc, argv);

    memset( (PBYTE)&captureParams, 0, sizeof(captureParams) );

    captureParams.nLPT = 0;
    captureParams.serverName[0] = 0;
    captureParams.queueName[0] = 0;
    captureParams.bannerUserName[0] = 0;
    captureParams.filePath[0] = 0;

    if ( fNDS )
    {
       captureParams.NDSCapture = TRUE;
    }
    else 
    {
       captureParams.NDSCapture = FALSE;
    }

    if ( IsServerSpecified( argc, argv ) ) 
       captureParams.NDSCapture = FALSE;

    // If the option is show, show the current capture settings.
    if (IsShowOption (argc, argv))
    {
        ShowCapture();
        return;
    }

    // If the option is ?, show the usage.
    if (IsQuestionMark(argc, argv))
    {
        DisplayMessage(IDR_CAPTURE_USAGE);
        return;
    }

    // If /Job=jobname is in the parameter, get the jobname.
    GetJobNameFromArg (argc, argv, jobName);

    if (!CGetDefaultConnectionID (&conn) ||
        !InitCaptureParams (conn, jobName, &captureParams) ||
        !ReadArguments (argc,
                        argv,
                        jobName,
                        &captureParams))
        return;

    // Terminate old capture.
    EndCapture ((unsigned char) captureParams.nLPT);

    (void) CStartCapture(conn, &captureParams);
    return;
}

void UpcaseArg(int argc, char ** argv)
{
    int i;
    for (i = 0; i < argc ; i++)
        _strupr (argv[i]);
}

/*
    Return TRUE if input is /Show option.
    FALSE otherwise.
 */
int  IsShowOption (int argc,char ** argv)
{
    int bIsShowOption = FALSE;
    char * p;

    if (argc == 2)
    {
        p = argv[1];
        while ((*p == '/') || (*p == '\\') || (*p == '-'))
            p++;

        if (!strncmp (p, __SHOW__, max (2, strlen(p))))
            bIsShowOption = TRUE;
    }

    return(bIsShowOption);
}

/*
    Return TRUE if input is /? option.
    FALSE otherwise.
 */
int  IsQuestionMark (int argc, char ** argv)
{
    int bIsQuestionMark = FALSE;
    char * p;

    if (argc == 2)
    {
        p = argv[1];
        while ((*p == '/') || (*p == '\\') || (*p == '-'))
            p++;

        if (*p == '?')
            bIsQuestionMark = TRUE;
    }

    return(bIsQuestionMark);
}

int  IsNoOption (char * option)
{
    int bIsNoOption = FALSE;
    char * p;

    p = option;
    while ((*p == '/') || (*p == '\\') || (*p == '-'))
        p++;

    if (!strncmp (p, __OPT_NO__, max (1, strlen(p))))
        bIsNoOption = TRUE;

    return(bIsNoOption);
}

/*
    Return TRUE if the input match option or shortoption.
    FALSE otherwise.
 */
int  IsValidOption (char *input, char *option, char *shortoption)
{
    int bValideInput = FALSE;

    while ((*input == '/') || (*input == '\\') || (*input == '-'))
        input++;

    if (!strcmp (input, shortoption))
    {
        bValideInput = TRUE;
    }
    else if (!strcmp (input, option))
    {
        bValideInput = TRUE;
    }

    return(bValideInput);
}

void GetJobNameFromArg (int argc, char ** argv, char *jobName)
{
    int i;
    char *pEqual;

    for (i = 0; i < argc; i++)
    {
        if (pEqual = strchr (argv[i], '='))
        {
            *pEqual = 0;

            if (IsValidOption (argv[i], __JOB__, __SHORT_FOR_JOB__) &&
                *(pEqual+1) != 0 &&
                strlen (pEqual+1) < MAX_JOB_NAME_LEN)
                strcpy (jobName, pEqual+1);

            *pEqual = '=';
        }
    }

    return;
}

int IsServerSpecified (int argc, char ** argv)
{
    int i;

    for (i = 0; i < argc; i++)
    {
        if (IsValidOption (argv[i], __SERVER__, __SHORT_FOR_SERVER__))
            return TRUE;
    }

    return FALSE;

}

/*
    Initialize the capture flags with job config or default value.
 */
int  InitCaptureParams (unsigned int conn,
                        char *jobName,
                        PCAPTURE_PARAMS pCaptureParams)
{
    PS_JOB_RECORD            psJobRecord;
    unsigned int iRet = 0;

    // Get job configuration.
    if (jobName[0] == 0)
    {
        // Get Default Job Name.
        if ( Is40Server( conn ) )
        {
            iRet = PS40JobGetDefault(  pCaptureParams->NDSCapture,
                                       0,
                                       NULL,
                                       jobName,
                                       &psJobRecord );
        }
        else 
        {
            iRet = PSJobGetDefault( conn,
                                    0,
                                    NULL,
                                    jobName,
                                    &psJobRecord );
        }

        if ( iRet )
        {
            if (iRet == PS_ERR_OPENING_DB || iRet == PS_ERR_GETTING_DEFAULT)
            {
                pCaptureParams->nLPT = 1;
                pCaptureParams->bannerUserName[0]=0;
                pCaptureParams->serverName[0]=0;
                pCaptureParams->queueName[0]=0;
                pCaptureParams->filePath[0]=0;

                pCaptureParams->captureFlagsRW.JobControlFlags = 0;
                pCaptureParams->captureFlagsRW.TabSize = 8;
                pCaptureParams->captureFlagsRW.NumCopies = 1;
                pCaptureParams->captureFlagsRW.PrintFlags = DEFAULT_PRINT_FLAGS;
                pCaptureParams->captureFlagsRW.FormName[0] = 0;
                pCaptureParams->captureFlagsRW.FormType = 0;
                pCaptureParams->captureFlagsRW.FlushCaptureTimeout = 0;
                pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 0;

                strcpy (pCaptureParams->captureFlagsRW.BannerText, DEFAULT_BANNER_TEXT);
                return(TRUE);
            }
            else
            {
                DisplayError (iRet, "PSJobGetDefault");
                return(FALSE);
            }
        }
    }
    else
    {
        if ( Is40Server( conn ) )
        {
            iRet = PS40JobRead(  pCaptureParams->NDSCapture,
                                 NULL,
                                 jobName,
                                 &psJobRecord);
        }
        else
        {
            iRet = PSJobRead(conn,
                             NULL,
                             jobName,
                             &psJobRecord);
        }
        if ( iRet )
        {
            if ( ( iRet == PS_ERR_READING_RECORD) ||
                 ( iRet == PS_ERR_OPENING_DB) )
                DisplayMessage(IDR_JOB_NOT_FOUND, jobName);
            else
                DisplayError (iRet, "PSJobRead");
            return(FALSE);
        }
    }

    pCaptureParams->captureFlagsRW.JobControlFlags = 0;
    pCaptureParams->captureFlagsRW.TabSize = psJobRecord.TabSize;
    pCaptureParams->captureFlagsRW.NumCopies = psJobRecord.Copies;

    pCaptureParams->captureFlagsRW.PrintFlags =
        ((psJobRecord.PrintJobFlag & PS_JOB_EXPAND_TABS)? 0 : CAPTURE_FLAG_EXPAND_TABS)
       +((psJobRecord.PrintJobFlag & PS_JOB_NO_FORMFEED)? CAPTURE_FLAG_NO_FORMFEED : 0)
       +((psJobRecord.PrintJobFlag & PS_JOB_NOTIFY)? CAPTURE_FLAG_NOTIFY : 0)
       +((psJobRecord.PrintJobFlag & PS_JOB_PRINT_BANNER)? CAPTURE_FLAG_PRINT_BANNER : 0);

    pCaptureParams->captureFlagsRW.FormType = 0;
    pCaptureParams->captureFlagsRW.FlushCaptureTimeout = psJobRecord.TimeOutCount;
    pCaptureParams->captureFlagsRW.FlushCaptureOnClose = !(psJobRecord.PrintJobFlag & PS_JOB_AUTO_END);

    strcpy (pCaptureParams->captureFlagsRW.FormName, psJobRecord.FormName);
    strcpy (pCaptureParams->captureFlagsRW.BannerText, (psJobRecord.BannerName[0] == 0)? DEFAULT_BANNER_TEXT : psJobRecord.BannerName);

    pCaptureParams->nLPT = psJobRecord.LocalPrinter;
    strcpy (pCaptureParams->bannerUserName, psJobRecord.Name);
    if ( psJobRecord.PrintJobFlag & PS_JOB_ENV_DS ) {
        strcpy (pCaptureParams->serverName, "");
        if ( psJobRecord.PrintJobFlag & PS_JOB_DS_PRINTER ) 
            GetPrinterDefaultQueue( pCaptureParams, psJobRecord.u.DSObjectName );
        else
            strcpy (pCaptureParams->queueName, psJobRecord.u.DSObjectName );
    }
    else {
        strcpy (pCaptureParams->serverName, psJobRecord.u.NonDS.FileServer);
        strcpy (pCaptureParams->queueName, psJobRecord.u.NonDS.PrintQueue);
    }
    pCaptureParams->filePath[0]=0;

    return(TRUE);
}

int ReadArguments (int argc,
                   char ** argv,
                   char *jobName,
                   PCAPTURE_PARAMS pCaptureParams)
{
    int i, fValidOption = TRUE, fValidParam = TRUE;
    char *pEqual = NULL;

    for (i = 1; i < argc; i++)
    {
        if (IsNoOption(argv[i]))
        {
            if (i != argc - 1)
            {
                i++;

                if (IsValidOption (argv[i], __NOTIFY__, __SHORT_FOR_NOTIFY__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF-CAPTURE_FLAG_NOTIFY);
                }
                else if (IsValidOption (argv[i], __AUTOENDCAP__, __SHORT_FOR_AUTOENDCAP__))
                {
                    pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 1;
                }
                else if (IsValidOption (argv[i], __TABS__, __SHORT_FOR_TABS__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_EXPAND_TABS);
                }
                else if (IsValidOption (argv[i], __BANNER__, __SHORT_FOR_BANNER__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_PRINT_BANNER);
                }
                else if (IsValidOption (argv[i], __FORMFEED__, __SHORT_FOR_FORMFEED__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_NO_FORMFEED;
                }
                else
                {
                    i--;
                    fValidOption = FALSE;
                    break;
                }
            }
            else
            {
                fValidOption = FALSE;
                break;
            }
        }
        else if (IsValidOption (argv[i], __NOTIFY__, __SHORT_FOR_NOTIFY__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_NOTIFY;
        }
        else if (IsValidOption (argv[i], __NONOTIFY__, __SHORT_FOR_NONOTIFY__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_NOTIFY);
        }
        else if (IsValidOption (argv[i], __AUTOENDCAP__, __SHORT_FOR_AUTOENDCAP__))
        {
            pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 0;
        }
        else if (IsValidOption (argv[i], __NOAUTOENDCAP__, __SHORT_FOR_NOAUTOENDCAP__))
        {
            pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 1;
        }
        else if (IsValidOption (argv[i], __NOTABS__, __SHORT_FOR_NOTABS__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_EXPAND_TABS);
        }
        else if (IsValidOption (argv[i], __NOBANNER__, __SHORT_FOR_NOBANNER__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_PRINT_BANNER);
        }
        else if (IsValidOption (argv[i], __FORMFEED__, __SHORT_FOR_FORMFEED__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_NO_FORMFEED);
        }
        else if (IsValidOption (argv[i], __NOFORMFEED__, __SHORT_FOR_NOFORMFEED__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_NO_FORMFEED;
        }
        else if (IsValidOption (argv[i], __KEEP__, __SHORT_FOR_KEEP__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_KEEP;
        }
        else
        {
            // All other valid options should have '=' sign in it.
            // Except for LX LPX LPTX
            //
            pEqual = strchr (argv[i], '=');

            // Optionally a ':' works too
            if (pEqual == NULL ) {
                pEqual = strchr (argv[i], ':');
            }

            if (pEqual != NULL)
                *pEqual = 0;

            if (IsValidOption (argv[i], __TIMEOUT__, __SHORT_FOR_TIMEOUT__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_TIME_OUT_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.FlushCaptureTimeout = (USHORT) atoi (pEqual+1);

                if (pCaptureParams->captureFlagsRW.FlushCaptureTimeout > 1000)
                {
                    DisplayMessage(IDR_TIMEOUT_OUTOF_RANGE);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __LOCAL__, __SHORT_FOR_LOCAL__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_LPT_NUMBER_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->nLPT = (unsigned char) atoi (pEqual+1);

                if (pCaptureParams->nLPT < 1 || pCaptureParams->nLPT > 3)
                {
                    DisplayMessage(IDR_INVALID_LPT_NUMBER);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __LOCAL_3__, __LOCAL_2__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_LPT_NUMBER_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->nLPT = (unsigned char) atoi (pEqual+1);

                if (pCaptureParams->nLPT < 1 || pCaptureParams->nLPT > 3)
                {
                    DisplayMessage(IDR_INVALID_LPT_NUMBER);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __JOB__, __SHORT_FOR_JOB__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_JOB_NAME_LEN - 1)
                {
                    fValidOption = FALSE;
                    break;
                }
                strcpy (jobName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __SERVER__, __SHORT_FOR_SERVER__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_NAME_LEN - 1)
                {
                    fValidOption = FALSE;
                    break;
                }
                pCaptureParams->NDSCapture = FALSE;
                strcpy (pCaptureParams->serverName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __QUEUE__, __SHORT_FOR_QUEUE__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_QUEUE_NAME_LEN - 1) //compatible.
                {
                    fValidOption = FALSE;
                    break;
                }
                strcpy (pCaptureParams->queueName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __PRINTER__, __SHORT_FOR_PRINTER__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    !pCaptureParams->NDSCapture ||
                    strlen (pEqual+1) > MAX_QUEUE_NAME_LEN - 1) //compatible.
                {
                    fValidOption = FALSE;
                    break;
                }
                GetPrinterDefaultQueue( pCaptureParams, pEqual+1 );
            }
            else if (IsValidOption (argv[i], __CREATE__, __SHORT_FOR_CREATE__))
            {
                if (pEqual != NULL)  //compatible.
                {
                    if (strlen (pEqual+1) > _MAX_PATH - 1)
                    {
                        DisplayMessage(IDR_INVALID_PATH_NAME, pEqual+1);
                        fValidParam = FALSE;
                        break;
                    }
                    strcpy (pCaptureParams->filePath, pEqual+1);
                }
            }
            else if (IsValidOption (argv[i], __FORM__, __SHORT_FOR_FORM__))
            {
                int j = 1;
                int bAllNumbers = TRUE;

                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_FORM_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                if (strlen (pEqual+1) > 3) // Only allow 3 digits number.
                {
                    DisplayMessage(IDR_INVALID_FORM_NAME, pEqual+1);
                    fValidParam = FALSE;
                    break;
                }

                while (*(pEqual+j) != 0)
                {
                    if (!isdigit (*(pEqual+j)))
                    {
                        bAllNumbers = FALSE;
                        break;
                    }
                    j++;
                }

                if (bAllNumbers)
                {
                    pCaptureParams->captureFlagsRW.FormType = (USHORT) atoi (pEqual+1);

                    if (pCaptureParams->captureFlagsRW.FormType > 255)
                    {
                        DisplayMessage(IDR_INVALID_FORM_TYPE);
                        fValidParam = FALSE;
                        break;
                    }
                }
                else
                {
                    DisplayMessage(IDR_INVALID_FORM_NAME, pEqual+1);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __COPIES__, __SHORT_FOR_COPIES__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_COPIES_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.NumCopies = (USHORT) atoi (pEqual+1);

                if (pCaptureParams->captureFlagsRW.NumCopies < 1 ||
                    pCaptureParams->captureFlagsRW.NumCopies > 255)
                {
                    DisplayMessage(IDR_COPIES_OUTOF_RANGE);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __TABS__, __SHORT_FOR_TABS__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_TAB_SIZE_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.TabSize = (BYTE) atoi (pEqual+1);

                if (pCaptureParams->captureFlagsRW.TabSize < 1 ||
                    pCaptureParams->captureFlagsRW.TabSize > 18)
                {
                    DisplayMessage(IDR_TABSIZE_OUTOF_RANGE);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_EXPAND_TABS;
            }
            else if (IsValidOption (argv[i], __NAME__, __SHORT_FOR_NAME__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_BANNER_USER_NAME - 1)
                {
                    fValidOption = FALSE;
                    break;
                }
                strcpy (pCaptureParams->bannerUserName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __BANNER__, __SHORT_FOR_BANNER__))
            {
                if (pEqual != NULL)
                {
                    if (strlen (pEqual+1) > MAX_BANNER_USER_NAME - 1)
                    {
                        DisplayMessage(IDR_INVALID_BANNER, pEqual+1);
                        fValidParam = FALSE;
                        break;
                    }
                    strcpy (pCaptureParams->captureFlagsRW.BannerText, pEqual+1);
                    pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_PRINT_BANNER;
                }
            }
            //
            // Kludge for LX LPX LPTX parameters
            // Note that L:X L=X, etc are also valid
            //
            else if ( ( pEqual == NULL ) && ( *(argv[i]) == 'L' ) ) {
                pEqual = argv[i];
                pEqual++;
                if ( *pEqual == 'P' ) {
                    pEqual++;
                    if ( *pEqual == 'T' ) {
                        pEqual++;
                    }
                }
                pCaptureParams->nLPT = (unsigned char) atoi (pEqual);

                if (pCaptureParams->nLPT < 1 || pCaptureParams->nLPT > 3)
                {
                    DisplayMessage(IDR_INVALID_LPT_NUMBER);
                    fValidParam = FALSE;
                    break;
                }

            }
            else
            {
                fValidOption = FALSE;
                break;
            }
        }
    }

    if (fValidOption && fValidParam)
    {
        sprintf (pCaptureParams->captureFlagsRW.JobDescription, __JOB_DESCRIPTION__, pCaptureParams->nLPT);
        return(TRUE);
    }
    else
    {
        if (!fValidOption)
        {
            if (pEqual)
                *pEqual = '=';
            DisplayMessage(IDR_UNKNOW_FLAG, argv[i]);
        }
        DisplayMessage(IDR_CAPTURE_USAGE);
        return(FALSE);
    }
}

/*
    Show the capture setting.
 */
void ShowCapture(void)
{
    unsigned int iRet = 0;
    int     i;
    char * queueName;

    for (i = 1; i <= 3; i++ )
    {
        NETWARE_CAPTURE_FLAGS_RW captureFlagsRW;
        NETWARE_CAPTURE_FLAGS_RO captureFlagsRO;

        if (iRet = GetCaptureFlags ((unsigned char)i,
                                    &captureFlagsRW,
                                    &captureFlagsRO))
        {
            DisplayError (iRet, "GetCaptureFlags");
        }
        else
        {
            char *serverName;
            WCHAR timeOut[256];
            WCHAR tabs[256];

            if (captureFlagsRO.LPTCaptureFlag == 0)
            {
                DisplayMessage(IDR_NOT_ACTIVE, i);
            }
            else
            {
                serverName = captureFlagsRO.ServerName;

                if ( !CaptureStringsLoaded ) {
                    (void) LoadString( NULL, IDR_DISABLED, __DISABLED__, 256 );
                    (void) LoadString( NULL, IDR_ENABLED, __ENABLED__, 256 );
                    (void) LoadString( NULL, IDR_YES, __YES__, 256 );
                    (void) LoadString( NULL, IDR_NO, __NO__, 256 );
                    (void) LoadString( NULL, IDR_SECONDS, __SECONDS__, 256 );
                    (void) LoadString( NULL, IDR_CONVERT_TO_SPACE, __CONVERT_TO_SPACE__, 256 );
                    (void) LoadString( NULL, IDR_NO_CONVERSION, __NO_CONVERSION__, 256 );
                    (void) LoadString( NULL, IDR_NOTIFY_USER, __NOTIFY_USER__, 256 );
                    (void) LoadString( NULL, IDR_NOT_NOTIFY_USER, __NOT_NOTIFY_USER__, 256 );
                    (void) LoadString( NULL, IDR_NONE, __NONE__, 256 );
                }

                if (captureFlagsRW.FlushCaptureTimeout)
                    wsprintf (timeOut, __SECONDS__, captureFlagsRW.FlushCaptureTimeout);
                else
                    (void) LoadString( NULL, IDR_DISABLED, timeOut, 256 );

                if (captureFlagsRW.PrintFlags & CAPTURE_FLAG_EXPAND_TABS)
                    wsprintf(tabs, __CONVERT_TO_SPACE__, captureFlagsRW.TabSize);
                else
                    (void) LoadString( NULL, IDR_NO_CONVERSION, tabs, 256 );


                queueName = captureFlagsRO.QueueName;

                if ( fNDS )
                {
                    if ( captureFlagsRW.PrintFlags & CAPTURE_FLAG_PRINT_BANNER )
                    {
                        DisplayMessage(IDR_LPT_STATUS_NDS, i, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,    //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               captureFlagsRW.BannerText, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__, //Form Feed
                               captureFlagsRW.NumCopies,    //Copies
                               tabs,                        //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                    else
                        {
                        DisplayMessage(IDR_LPT_STATUS_NO_BANNER_NDS, i, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,     //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               __NONE__, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__,  //Form Feed
                               captureFlagsRW.NumCopies,     //Copies
                               tabs,                         //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                }
                else
                {
                    if ( captureFlagsRW.PrintFlags & CAPTURE_FLAG_PRINT_BANNER )
                    {
                        DisplayMessage(IDR_LPT_STATUS, i, serverName, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,    //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               captureFlagsRW.BannerText, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__, //Form Feed
                               captureFlagsRW.NumCopies,    //Copies
                               tabs,                        //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                    else
                        {
                        DisplayMessage(IDR_LPT_STATUS_NO_BANNER, i, serverName, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,     //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               __NONE__, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__,  //Form Feed
                               captureFlagsRW.NumCopies,     //Copies
                               tabs,                         //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                }
            }
        }
    }
}

int  CStartCapture(unsigned int conn,
                   PCAPTURE_PARAMS pCaptureParams)
{
    unsigned int iRet = 0;
    unsigned char FullPath[255 + NCP_VOLUME_LENGTH];
    unsigned char DirPath[255];
    unsigned char VolumeName[NCP_VOLUME_LENGTH];
    WORD          status;

    // Get connection handle.
    if ( !pCaptureParams->NDSCapture )
    {
        if ( pCaptureParams->serverName[0] == 0 )
        {
            if (iRet = GetFileServerName (conn, pCaptureParams->serverName))
            {
                DisplayError (iRet, "GetFileServerName");
                return (1);
            }
        }
        else
        {
            if (iRet = GetConnectionHandle (pCaptureParams->serverName, &conn))
            {
                if ( iRet = NTLoginToFileServer( pCaptureParams->serverName, "GUEST", "" ) ) {
                    switch ( iRet ) {
                    case ERROR_INVALID_PASSWORD:
                    case ERROR_NO_SUCH_USER:
                    case ERROR_CONNECTION_COUNT_LIMIT:
                    case ERROR_LOGIN_TIME_RESTRICTION:
                    case ERROR_LOGIN_WKSTA_RESTRICTION:
                    case ERROR_ACCOUNT_DISABLED:
                    case ERROR_PASSWORD_EXPIRED:
                    case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
                        DisplayMessage( IDR_CAPTURE_FAILED, pCaptureParams->queueName );
                        DisplayMessage( IDR_ACCESS_DENIED );
                        break;
                    default:
                        DisplayMessage(IDR_SERVER_NOT_FOUND, pCaptureParams->serverName);
                    }
                    return (1);
                }
                else {
                    if (iRet = GetConnectionHandle (pCaptureParams->serverName, &conn)) {
                        DisplayMessage(IDR_SERVER_NOT_FOUND, pCaptureParams->serverName);
                        return (1);
                    }
                }
            }
        }
    }

    if (pCaptureParams->filePath[0] != 0)
    {
        DisplayMessage(IDR_FILE_CAPTURE_UNSUPPORTED);
        return (1);
    }
    else
    {
        if (pCaptureParams->queueName[0] == 0)
        {
            if ( pCaptureParams->NDSCapture ) 
            {
                DisplayMessage(IDR_NO_QUEUE);
                return (1);
            }
            else
            {
                // Try to get the default queue ID and name.
                if (iRet = GetDefaultPrinterQueue (conn, pCaptureParams->serverName, pCaptureParams->queueName))
                {
                    DisplayMessage(IDR_NO_PRINTERS, pCaptureParams->serverName);
                    return (1);
                }
            }
        }
        // Start queue capture.
        if ( pCaptureParams->NDSCapture )
        {
            char szCanonName[MAX_QUEUE_NAME_LEN];

            // Get the full name of the printer queue
            // The redirectory wants root based names for
            // everything.

            iRet = NDSCanonicalizeName( pCaptureParams->queueName,
                                        szCanonName,
                                        NDS_NAME_CHARS,
                                        TRUE );
            
            if ( iRet && ( pCaptureParams->queueName[0] != '.' ) )
            {
                // If that didn't work, see if it's a root
                // based name without the leading period.

                strcpy( szCanonName, "." );
                strcat( szCanonName, pCaptureParams->queueName );

                iRet = NDSCanonicalizeName( szCanonName,
                                            szCanonName,
                                            MAX_QUEUE_NAME_LEN,
                                            TRUE );
            }

            if ( iRet )
                iRet = ERROR_BAD_NETPATH;
            else
                iRet = StartQueueCapture ( conn,
                                           pCaptureParams->nLPT,
                                           NDSTREE,
                                           szCanonName );
        }
        else 
        {
            iRet = StartQueueCapture (conn,
                                      pCaptureParams->nLPT,
                                      pCaptureParams->serverName,
                                      pCaptureParams->queueName);
        }

        if ( iRet )
        {
            switch ( iRet ) {
            case ERROR_ACCESS_DENIED:
            case ERROR_INVALID_PASSWORD:
                DisplayMessage (IDR_CAPTURE_FAILED, pCaptureParams->queueName);
                DisplayMessage (IDR_ACCESS_DENIED);
                break;
            case ERROR_EXTENDED_ERROR:
                NTPrintExtendedError();
                break;
            case ERROR_BAD_NET_NAME:
            case ERROR_BAD_NETPATH:
                if ( pCaptureParams->NDSCapture )
                    DisplayMessage (IDR_NDSQUEUE_NOT_EXIST,
                                    pCaptureParams->queueName,
                                    pCaptureParams->serverName );
                else
                    DisplayMessage (IDR_QUEUE_NOT_EXIST,
                                    pCaptureParams->queueName,
                                    pCaptureParams->serverName );
                break;
            default:
                DisplayError (iRet, "StartQueueCapture");
                break;
            }
            return (1);
        }
    }

    if (pCaptureParams->captureFlagsRW.FlushCaptureOnClose == 1)
        DisplayMessage(IDR_NO_AUTOENDCAP);

    if ( pCaptureParams->NDSCapture )
        DisplayMessage(IDR_NDSSUCCESS_QUEUE, pCaptureParams->nLPT,
                       pCaptureParams->queueName);
    else
        DisplayMessage(IDR_SUCCESS_QUEUE, pCaptureParams->nLPT,
                       pCaptureParams->queueName, pCaptureParams->serverName);

    return(0);
}

/*
 * Given an NDS printer name, fill in the default queue name
 *
 */
int
GetPrinterDefaultQueue( PCAPTURE_PARAMS pCaptureParams,
                        PBYTE PrinterName )
{
    BYTE Fixup[ MAX_QUEUE_NAME_LEN];
    PBYTE ptr;
    unsigned int iRet;

    iRet = NDSGetProperty ( PrinterName, "Default Queue",
                            pCaptureParams->queueName,
                            MAX_QUEUE_NAME_LEN,
                            NULL );
    if ( iRet )
    {
        /*
         * Strip off the . in front and add context at end
         */
        ptr = RemoveSpaces (PrinterName);
        if ( *ptr == '.' )
        {
            ptr++;
            strncpy( Fixup, ptr, MAX_QUEUE_NAME_LEN );
        } 
        else
        {
            strncpy( Fixup, ptr, MAX_QUEUE_NAME_LEN );
            if ( Fixup[strlen(Fixup)-1] != '.' )
            {
                strcat( Fixup, "." );
            }
            (void) NDSGetContext( Fixup + strlen(Fixup),
                                  MAX_QUEUE_NAME_LEN - strlen(Fixup) );
        }
        iRet = NDSGetProperty ( Fixup, "Default Queue",
                                pCaptureParams->queueName,
                                MAX_QUEUE_NAME_LEN,
                                NULL );
        if ( !iRet )
            ConvertUnicodeToAscii( pCaptureParams->queueName ); 
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\common.c ===
/*************************************************************************
*
*  COMMON.C
*
*  Miscellaneous routines for scripts, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\COMMON.C  $
*  
*     Rev 1.3   10 Apr 1996 14:21:52   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.3   12 Mar 1996 19:52:40   terryt
*  Relative NDS names and merge
*  
*     Rev 1.2   24 Jan 1996 17:14:54   terryt
*  Common read string routine
*  
*     Rev 1.1   22 Dec 1995 14:23:56   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:36   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:22:18   terryt
*  Capture support
*  
*     Rev 1.1   26 Jul 1995 14:17:06   terryt
*  Clean up comments
*  
*     Rev 1.0   15 May 1995 19:10:18   terryt
*  Initial revision.
*  
*************************************************************************/
#include "common.h"

/*
    Used by DisplayMapping() only.
    Return search number if the drive is a search drive.
    Return 0 if the drive is not a search drive.
 */
int  IsSearchDrive(int driveNum)
{
    int   searchNum = 1;
    char  *path;

    path = NWGetPath();
    if (path == NULL) {
        return 0;
    }

    while (*path != 0)
    {
        if ((*path - 'A' + 1 == driveNum) &&
            (*(path+1) == ':'))
        {
            return searchNum;
        }

        if (path = strchr (path, ';'))
        {
            path++;
            searchNum++;
        }
        else
            return(0);
    }

    return(0);
}


/*
    Get path enviroment variable. This returns the pointer to the
    path in the parent enviroment segment.
 */
char  * NWGetPath(void)
{
    // 
    // On NT we can't change or get the parent's environment this way
    //
    return( getenv("PATH") );    
}

/*
    Return TRUE if the memory block is large enough for adding new
    search path. FALSE otherwise.
 */
int MemorySegmentLargeEnough (int nInsertByte)
{
    return TRUE;
}

/*
    Display drive maps info.
 */
void DisplayMapping(void)
{
    unsigned int    iRet = 0;
    int        i;
    WORD       status;
    char       rootPath[MAX_PATH_LEN], relativePath[MAX_PATH_LEN];
    char      *envPath, *tokenPath;
    char  *path;
    DWORD LocalDrives;
    DWORD NonSearchDrives;
    char sLocalDrives[26*2+5];
    char * sptr;

    // Don't delete this line. This is for fixing bug 1176.
    DisplayMessage(IDR_NEWLINE);

    LocalDrives = 0;
    NonSearchDrives = 0;

    // Collect local drives and search drives
    for (i = 1; i <= 26; i++) {
        status = NTNetWareDriveStatus( (unsigned short)(i-1) );
        if ((status & NETWARE_LOCAL_DRIVE) && !(status & NETWARE_NETWORK_DRIVE))
            LocalDrives |= ( 1 << (i-1) );
        else if ((status & NETWARE_NETWORK_DRIVE) && (!IsSearchDrive(i)) )
        {
            if (status & NETWARE_NETWARE_DRIVE)
                NonSearchDrives |= ( 1 << (i-1) );
            else
            {
                //For NetWare compatibility
                LocalDrives |= ( 1 << (i-1) );
            }
        }
    }

    // Print out local drives
    if ( LocalDrives ) {
        sptr = &sLocalDrives[0];
        for (i = 1; i <= 26; i++)
        {
            if ( LocalDrives & ( 1 << (i - 1) ) ) { 
                *sptr++ = 'A' + i - 1;
                *sptr++ = ',';
            }
        }
        sptr--;
        *sptr = '\0';
        DisplayMessage(IDR_ALL_LOCAL_DRIVES, sLocalDrives);
    }

    // Print out non search drives.
    for (i = 1; i <= 26; i++)
    {
        if ( NonSearchDrives & ( 1 << (i - 1) ) ) { 

            if (iRet = GetDriveStatus ((unsigned short)i,
                                       NETWARE_FORMAT_SERVER_VOLUME,
                                       &status,
                                       NULL,
                                       rootPath,
                                       relativePath,
                                       NULL))
            {
                DisplayError (iRet, "GetDriveStatus");
            }
            else
            {
                DisplayMessage(IDR_NETWARE_DRIVE, 'A'+i-1, rootPath, relativePath);
            }
        }
    }

    // Print out dashed line as seperator between non search drives
    // and search drives.
    DisplayMessage(IDR_DASHED_LINE);

    // Get the PATH environment variable.
    path = NWGetPath();
    if (path == NULL) {
        return;
    }

    if ((envPath = malloc (strlen (path) + 1)) == NULL)
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }

    strcpy (envPath, path);

    tokenPath = strtok (envPath, PATH_SEPERATOR);

    // Print out search drvies.
    for (i = 1; tokenPath != NULL; i++)
    {
        if (tokenPath[1] == ':')
        {
            if (iRet = GetDriveStatus ((unsigned short)(toupper(tokenPath[0])-'A'+1),
                                       NETWARE_FORMAT_SERVER_VOLUME,
                                       &status,
                                       NULL,
                                       rootPath,
                                       relativePath,
                                       NULL))
            {
                DisplayError (iRet, "GetDriveStatus");
            }
            else
            {
                if (status & NETWARE_NETWARE_DRIVE)
                    DisplayMessage(IDR_NETWARE_SEARCH, i, tokenPath, rootPath, relativePath);
                else
                    DisplayMessage(IDR_LOCAL_SEARCH, i, tokenPath);
            }
        }
        else
        {
            // Path is specified without drive letter.
            DisplayMessage(IDR_LOCAL_SEARCH, i, tokenPath);
        }

        tokenPath = strtok (NULL, PATH_SEPERATOR);
    }

    free (envPath);
}

/*****************************************************************************
 *                                                                           *
 *   GetString                                                               *
 *                                                                           *
 *                                                                           *
 *   entry:  pointer to buffer                                               *
 *           length of buffer                                                *
 *                                                                           *
 *   exit:   length of string                                                *
 *                                                                           *
 *****************************************************************************/

int
GetString( char * pBuffer, int ByteCount )
{
   char * pString = pBuffer;
   char ch;

   if ( ByteCount > 0 )
       ByteCount--;

   for( ;; ) {

       switch ( ch = (char) _getch() ) {

       case '\r' :
           *pString++ = '\0';
           putchar( '\n' );
           return( strlen( pBuffer ) );

       case '\b' :
           if ( pString != pBuffer ) {
               ByteCount++;
               pString--;
               printf( "\b \b" );
           }
           break;

       default :
           if ( ByteCount > 0 && ch >= 0x20 && ch < 0x80 ) {
               *pString++ = ch;
               ByteCount--;
               putchar( ch );
           }
           break;
       }

    }
    fflush(stdin);
}

/*
    Read user or server name from the keyboard input.
    Return TRUE if user typed in a username
           FALSE otherwise.
 */
int ReadName (char * Name)
{
    memset( Name, 0, MAX_NAME_LEN );

    if ( 0 == GetString( Name, MAX_NAME_LEN ) )
        return FALSE;

    _strupr(Name);
    return TRUE;
}



/*
    Try to log the user in.
    Return error code. 0 is success.
 */
int  Login( char *UserName,
            char *ServerName,
            char *Password,
            int   bReadPassword)
{
    unsigned int  iRet = 0;

    // Try log the user in with no password first.
    iRet = NTLoginToFileServer( ServerName,
                                UserName,
                                Password);

    if (iRet == ERROR_INVALID_PASSWORD && bReadPassword)
    {
        // wrong password. ask for passowrd. and try login with
        // the input password.
        DisplayMessage(IDR_PASSWORD, UserName, ServerName);

        ReadPassword (Password);

        iRet = NTLoginToFileServer( ServerName,
                                    UserName,
                                    Password);
    }

    switch(iRet)
    {
    case NO_ERROR: // ok
        DisplayMessage(IDR_ATTACHED, ServerName);
        break;

    case ERROR_INVALID_PASSWORD: // wrong password.
    case ERROR_NO_SUCH_USER: // no such user.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_ACCESS_DENIED);
        break;

    case ERROR_CONNECTION_COUNT_LIMIT:  // concurrent connection restriction.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_LOGIN_DENIED_NO_CONNECTION);
        break;

    case ERROR_LOGIN_TIME_RESTRICTION:  // time restriction.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_UNAUTHORIZED_LOGIN_TIME);
        break;

    case ERROR_LOGIN_WKSTA_RESTRICTION: // station restriction.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_UNAUTHORIZED_LOGIN_STATION);
        break;

    case ERROR_ACCOUNT_DISABLED:
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_ACCOUNT_DISABLED);
        break;

    case ERROR_PASSWORD_EXPIRED: // password expired and no grace login left.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_PASSWORD_EXPRIED_NO_GRACE);
        break;

    case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
        // Server rejected access
        DisplayMessage(IDR_CONNECTION_REFUSED);
        break;

    case ERROR_EXTENDED_ERROR:
        NTPrintExtendedError();
        break;

    //
    // tommye - MS bug 8194 (MCS 240)
    // If we are already attached to this server under other credentials
    // we get back an ERROR_SESSION_CREDENTIAL_CONFLICT.  This is okay,
    // we'll just print out that we're already attached.  We have to 
    // pass the error on up, though, so we don't add this server to the
    // attach list again.
    //
    case ERROR_SESSION_CREDENTIAL_CONFLICT:
        DisplayMessage(IDR_ALREADY_ATTACHED, ServerName);
        break;

    default :
        DisplayError(iRet,"NtLoginToFileServer");
        break;
    }

    return(iRet);
}

int CAttachToFileServer(char *ServerName, unsigned int *pConn, int * pbAlreadyAttached)
{
    unsigned int  iRet = 0;

    if (pbAlreadyAttached != NULL)
        *pbAlreadyAttached = FALSE;

    // Validate the server name.
    iRet = AttachToFileServer(ServerName,pConn);

    switch (iRet)
    {
        case 0: // OK
            break;

        case 0x8800 : // Already atached.
            if (pbAlreadyAttached != NULL)
                *pbAlreadyAttached = TRUE;

            iRet = GetConnectionHandle (ServerName, pConn);
            break;

        default:
            DisplayMessage(IDR_NO_RESPONSE, ServerName);
            break;
    }

    return(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\dbcs.c ===
/*************************************************************************
*
*  DBCS.C
*
*  DBCS routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DBCS.C  $
*  
*     Rev 1.1   22 Dec 1995 14:24:10   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:44   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:26   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:24   terryt
*  Initial revision.
*  
*************************************************************************/
/*
** dbcs.c - DBCS functions for DOS apps.
**
** Written by RokaH and DavidDi.
*/


/* Headers
**********/

// IsDBCSLeadByte taken out of NT because there is one built in.
// I left the Next and Prev in because I don't know whether this 
// algorithm is "safer" than the built in code.

#include "common.h"

/*
** unsigned char *NWAnsiNext(unsigned char *puch);
**
** Moves to the next character in a string.
**
** Arguments:  puch - pointer to current location in string
**
** Returns:    char * - Pointer to next character in string.
**
** Globals:    none
**
** N.b., if puch points to a null character, NWAnsiNext() will return puch.
*/
unsigned char *NWAnsiNext(unsigned char *puch)
{
   if (*puch == '\0')
      return(puch);
   else if (IsDBCSLeadByte(*puch))
      puch++;

   puch++;

   return(puch);
}


/*
** unsigned char *NWAnsiPrev(unsigned char *psz, unsigned char *puch);
**
** Moves back one character in a string.
**
** Arguments:  psz  - pointer to start of string
**             puch - pointer to current location in string
**
** Returns:    char * - Pointer to previous character in string.
**
** Globals:    none
**
** N.b., if puch <= psz, NWAnsiPrev() will return psz.
**
** This function is implemented in a very slow fashion because we do not wish
** to trust that the given string is necessarily DBCS "safe," i.e., contains
** only single-byte characters and valid DBCS characters.  So we start from
** the beginning of the string and work our way forward.
*/
unsigned char *NWAnsiPrev(unsigned char *psz, unsigned char *puch)
{
   unsigned char *puchPrevious;

   do
   {
      puchPrevious = psz;
      psz = NWAnsiNext(psz);
   } while (*psz != '\0' && psz < puch);

   return(puchPrevious);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\display.c ===
/*************************************************************************
*
*  DISPLAY.C
*
*  NetWare script routines for displaying information, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DISPLAY.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:06   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:53:04   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:18   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:48   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:32   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:26   terryt
*  Initial revision.
*  
*************************************************************************/
/*
    File name: display.c
    Do not add any other functions to this file.
    Otherwise many exes size will increase.
 */


#include "common.h"

/*
    Display error report.
 */
void DisplayError(int error ,char *functionName)
{
    DisplayMessage(IDR_ERROR, error ,functionName);
}

void xstrupr(char *buffer)
{
    for (; *buffer; buffer++)
    {
        if (IsDBCSLeadByte(*buffer))
            buffer++;
        else if (*buffer == 0xff80)
            *buffer = (char)0xff87;
        else if (*buffer == 0xff81)
            *buffer = (char)0xff9a;
        else if (*buffer == 0xff82)
            *buffer = (char)0xff90;
        else if (*buffer == 0xff84)
            *buffer = (char)0xff8e;
        else if (*buffer == 0xff88)
            *buffer = (char)0xff9f;
        else if (*buffer == 0xff91)
            *buffer = (char)0xff92;
        else if (*buffer == 0xff94)
            *buffer = (char)0xff99;
        else if (*buffer == 0xffa4)
            *buffer = (char)0xffa5;
    }

    _strupr (buffer);
}

/*
    Read password from the keyboard input.
 */
void ReadPassword(char * Password)
{
    int  i = 0;
    char c;

    do
    {   c=(char)_getch();

        if (c == '\b')
        {
            if (i > 0)
                i--;
        }
        else
        {
            Password[i]=c;
            i++;
        }
    }while((c!='\r') && i< MAX_PASSWORD_LEN );
    Password[i-1]='\0';
    xstrupr(Password);
    DisplayMessage(IDR_NEWLINE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\drvstat.c ===
/*************************************************************************
*
*  DRVSTAT.C
*
*  Drive status routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DRVSTAT.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:20   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:53:36   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:32   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:54   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:44   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:32   terryt
*  Initial revision.
*  
*************************************************************************/

/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\drvstat.c

Abstract:

    Directory APIs.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

--*/
#include "common.h"


/*++
*******************************************************************

        GetDriveStatus

Routine Description:

        Get the drive status.

Arguments:

        DriveNumber = The drive to number to use. (1=A,2=B,C=3,...)
        PathFormat = Format for the return path.
                        NW_FORMAT_NETWARE - volume:path
                        NW_FORMAT_SERVER_VOLUME - server\volume:path
                        NW_FORMAT_DRIVE - G:\path
                        NW_FORMAT_UNC - \\server\volume\path
        pStatus = A pointer to return the status of the drive.
        pConnectionHandle = A pointer to return the connection handle
                                for the drive.
        pRootPath = The pointer to return the base root path. OPTIONAL
        pRelativePath = The pointer to return the relative to root path.
        pFullPath = The pointer to return the full path.

Return Value:

        0x0000      SUCCESSFUL
        0x00FF      INVALID_DRIVE

*******************************************************************
--*/
unsigned int
GetDriveStatus(
    unsigned short  DriveNumber,
    unsigned short  PathFormat,
    unsigned short *pStatus,
    unsigned int   *pConnectionHandle,
    unsigned char  *pRootPath,
    unsigned char  *pRelativePath,
    unsigned char  *pFullPath
    )
{
    unsigned char     *p;
    unsigned int       Result;
    unsigned short     Status;
    unsigned char      Path[NCP_MAX_PATH_LENGTH + 1];
    unsigned char      WorkPath[NCP_MAX_PATH_LENGTH + 1];
    unsigned char      ServerName[NCP_SERVER_NAME_LENGTH + 1];

    /** Make sure the drive number is valid **/

    if (DriveNumber < 1 || DriveNumber > 32) {
        return 0x000F;      /* INVALID_DRIVE */
    }

    Status = 0;

    DriveNumber--;


    if (pConnectionHandle) {
        /* 
         *  This should never occur.
         */
        DisplayError (0xff, "GetDriveStatus");
        return 0xff;
    }

    /** Get the directory path from the server **/
    Result = NTGetNWDrivePath( DriveNumber, ServerName, Path );
    if ( Result ) {
        *Path = 0;
        *ServerName = 0;
    }

    /** Convert the / in the path to \ **/
    for (p = Path; *p != 0 ; p++)
    {
        if (*p == '/')
            *p = '\\';
    }

    /** Get the status of the drive if we need to **/
    Status = NTNetWareDriveStatus( DriveNumber );

    /** Get the status of the drive if we need to **/

    if (pStatus) {
        *pStatus = Status;
    }

    /** Get the full path if we need to **/

    if (pFullPath) {

        if (Status & NETWARE_LOCAL_FREE_DRIVE) {
            *pFullPath = 0;
        }
        else {
            strcpy(WorkPath, Path);

            /** Build the NetWare path format (volume:path) **/

            if (PathFormat == NETWARE_FORMAT_NETWARE) {
                strcpy(pFullPath, WorkPath);
            }

            /** Build the server volume path (server\volume:path) **/

            else if (PathFormat == NETWARE_FORMAT_SERVER_VOLUME) {
                sprintf(pFullPath, "%s\\%s", ServerName, WorkPath);
            }

            /** Build the drive path (G:\path) **/

            else if (PathFormat == NETWARE_FORMAT_DRIVE) {

                p = WorkPath;
                while (*p != ':' && *p) {
                    p++;
                }

                if (*p == ':') {
                    p++;
                }

                sprintf(pFullPath, "%c:\\%s", DriveNumber + 'A', p);
            }

            /** Build the UNC path (\\server\volume\path) **/

            else if (PathFormat == NETWARE_FORMAT_UNC) {

                p = WorkPath;
                while (*p != ':' && *p) {
                    p++;
                }

                if (*p == ':') {
                    *p = '\\';
                }

                sprintf(pFullPath, "\\\\%s\\%s", ServerName, WorkPath);
            }
        }
    }

    strcpy(WorkPath, Path);
    /*
     * Path does not have the relative path (current directory) in it.
     */

    /** Get the root path if we need to **/

    if (pRootPath) {

        if (Status & NETWARE_LOCAL_FREE_DRIVE) {
            *pRootPath = 0;
        }
        else {

            /** Build the NetWare root path format (volume:) **/

            if (PathFormat == NETWARE_FORMAT_NETWARE) {
                sprintf(pRootPath, strchr(WorkPath, ':')? "%s" : "%s:", WorkPath);
            }

            /** Build the server volume root path (server\volume:) **/

            else if (PathFormat == NETWARE_FORMAT_SERVER_VOLUME) {
                if ( fNDS && !_strcmpi( ServerName, NDSTREE) )
                    sprintf(pRootPath, strchr (WorkPath, ':')? "%s" : "%s:", WorkPath);
                else
                    sprintf(pRootPath, strchr (WorkPath, ':')? "%s\\%s" : "%s\\%s:", ServerName, WorkPath);
            }

            /** Build the drive root path (G:\) **/

            else if (PathFormat == NETWARE_FORMAT_DRIVE) {
                sprintf(pRootPath, "%c:\\", DriveNumber + 'A');
            }

            /** Build the UNC root path (\\server\volume) **/

            else if (PathFormat == NETWARE_FORMAT_UNC) {
                sprintf(pRootPath, "\\\\%s\\%s", ServerName, WorkPath);
            }
        }
    }

    /** Get the relative path if we need to **/

    if (pRelativePath) {

        if (Status & NETWARE_LOCAL_FREE_DRIVE) {
            *pRelativePath = 0;
        }
        else {
            int i;
            NTGetCurrentDirectory( (unsigned char)DriveNumber, pRelativePath );
            /* 
             * Skip the drive letter
             */
            if ( pRelativePath[0] ) {
                for ( i = 0; ;i++ ) {
                    pRelativePath[i] = pRelativePath[i+3];
                    if ( !pRelativePath[i] )
                        break;
                }
            }
        }
    }

    return 0x0000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\drive.c ===
/*************************************************************************
*
*  DRIVE.C
*
*  NT drive routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DRIVE.C  $
*
*     Rev 1.2   10 Apr 1996 14:22:12   terryt
*  Hotfix for 21181hq
*
*     Rev 1.2   12 Mar 1996 19:53:22   terryt
*  Relative NDS names and merge
*
*     Rev 1.1   22 Dec 1995 14:24:24   terryt
*  Add Microsoft headers
*
*     Rev 1.0   15 Nov 1995 18:06:52   terryt
*  Initial revision.
*
*     Rev 1.2   25 Aug 1995 16:22:38   terryt
*  Capture support
*
*     Rev 1.1   23 May 1995 19:36:46   terryt
*  Spruce up source
*
*     Rev 1.0   15 May 1995 19:10:30   terryt
*  Initial revision.
*
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nwapi32.h>
#include <nwapi.h>
#include <npapi.h>
#include <regapi.h>

#include "nwscript.h"
#include "ntnw.h"
#include "inc/nwlibs.h"

#include <mpr.h>

extern unsigned char NW_PROVIDERA[];

// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() (BOOLEAN)(!(USER_SHARED_DATA->SuiteMask & (1 << SingleUserTS)))
/********************************************************************

        GetFirstDrive

Routine Description:

        Return the first non-local drive

Arguments:

        pFirstDrive = pointer to drive
                 1-26

Return Value:
        0 = success
        F = failure

 ********************************************************************/
unsigned int
GetFirstDrive( unsigned short *pFirstDrive )
{
    int i;
    char DriveName[10];
    unsigned int drivetype;
    HKEY hKey;
    char InitDrive[3] = "";
    DWORD dwTemp;


    if (IsTerminalServer()) {
        // Check if there is a override specified in the registry for the
        // initial NetWare drive (to prevent collisions with client drive mappings)
        if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          REG_CONTROL_TSERVER,
                          0,
                          KEY_READ,
                          &hKey) == ERROR_SUCCESS) {

            dwTemp = sizeof(InitDrive);
            if (RegQueryValueExA(hKey,
                                 REG_CITRIX_INITIALNETWAREDRIVE_A,
                                 NULL,
                                 NULL,
                                 InitDrive,
                                 &dwTemp) != ERROR_SUCCESS) {
            }
            RegCloseKey(hKey);
        }

        // Original code defaulted to C:
        if (!isalpha(InitDrive[0])) {
            InitDrive[0] = 'C';
        }

        strcpy( DriveName, "A:\\" );
        dwTemp = toupper(InitDrive[0]) - 'A';
    }
    else {
       strcpy( DriveName, "A:\\" );
       dwTemp=2;
    }

    for ( i = dwTemp; i < 26; i++ ) {
        DriveName[0] = 'A' + i;
        drivetype = GetDriveTypeA( DriveName );
        if ( ( ( drivetype == DRIVE_REMOTE ) &&
               ( NTIsNetWareDrive( i )     )  ) ||
             ( drivetype == DRIVE_NO_ROOT_DIR ) ) {
            *pFirstDrive = i + 1;
            return 0x0000;
        }
    }

    return 0x000F;
}

/********************************************************************

        IsDriveRemote

Routine Description:

        Is the given drive remote?

Arguments:

        DriveNumber 1-26
        pRemote  0x1000 = remote,  0x0000 = local

Return Value:
        0  = success
        F =  invalid drive

 ********************************************************************/
unsigned int
IsDriveRemote(
    unsigned char  DriveNumber,
    unsigned int  *pRemote
    )
{
    char DriveName[10];
    unsigned int drivetype;

    strcpy( DriveName, "A:\\" );
    DriveName[0] = 'A' + DriveNumber;

    drivetype = GetDriveTypeA( DriveName );

    if ( drivetype == DRIVE_REMOTE ) {
        *pRemote = 0x1000;
        return 0;
    }
    else if ( drivetype == DRIVE_NO_ROOT_DIR ) {
        return 0xF;
    }
    else {
        *pRemote = 0;
        return 0;
    }
}


/********************************************************************

        NTNetWareDriveStatus

Routine Description:

        Return the type of drive

Arguments:

        DriveNumber - Number of drive 0-25

Return Value:

        Combination of:
           NETWARE_NETWORK_DRIVE
           NETWARE_NETWARE_DRIVE
           NETWARE_LOCAL_FREE_DRIVE
           NETWARE_LOCAL_DRIVE



 *******************************************************************/
unsigned short
NTNetWareDriveStatus( unsigned short DriveNumber )
{
    char DriveName[10];
    unsigned int drivetype;
    unsigned int Status = 0;

    strcpy( DriveName, "A:\\" );
    DriveName[0] = 'A' + DriveNumber;
    drivetype = GetDriveTypeA( DriveName );

    if ( drivetype == DRIVE_REMOTE ) {
        Status |= NETWARE_NETWORK_DRIVE;
        if ( NTIsNetWareDrive( (unsigned int)DriveNumber ) )
            Status |=  NETWARE_NETWARE_DRIVE;
    }
    else if ( drivetype == DRIVE_NO_ROOT_DIR ) {
        Status = NETWARE_LOCAL_FREE_DRIVE;
    }
    else {
        Status = NETWARE_LOCAL_DRIVE;
    }
    return (USHORT)Status;
}


/********************************************************************

        NTGetNWDrivePath

Routine Description:

        Return the server name and path of the specified drive

Arguments:
        DriveNumber - Number of drive 0-25
        ServerName  - Name of file server
        Path        - Volume:\Path

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int NTGetNWDrivePath(
          unsigned short DriveNumber,
          unsigned char * ServerName,
          unsigned char * Path )
{
    static char localname[] = "A:";
    unsigned int Result;
    char * p;
    char * volume;
    char remotename[1024];
    int length = 1024;

    if ( ServerName != NULL )
        *ServerName = 0;

    if ( Path != NULL )
        *Path = 0;

    localname[0] = 'A' + DriveNumber;

    Result = WNetGetConnectionA ( localname, remotename, &length );

    if ( Result != NO_ERROR ) {
        Result = GetLastError();
        if ( Result == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
        return Result;
    }

    p = strchr (remotename + 2, '\\');
    if ( !p )
        return 0xffffffff;

    *p++ = '\0';
    volume = p;

    if ( ServerName != NULL ) {
        strcpy( ServerName, remotename + 2 );
        _strupr( ServerName );
    }

    if ( Path != NULL ) {
        p = strchr (volume, '\\');
        if ( !p ) {
            strcpy( Path, volume );
            strcat( Path, ":" );
        }
        else {
            *p = ':';
            strcpy( Path, volume );
        }
        _strupr( Path );
    }

    return NO_ERROR;
}


/********************************************************************

        NTIsNetWareDrive

Routine Description:

        Returns TRUE if the drive is a netware mapped drive

Arguments:

        DriveNumber - Number of drive 0-25

Return Value:
        TRUE  - drive is NetWare
        FALSE - drive is not NetWare

 *******************************************************************/
unsigned int
NTIsNetWareDrive( unsigned int DriveNumber )
{
    LPBYTE       Buffer ;
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    char         DriveName[10];
    DWORD        BufferSize = 4096;
    LPWNET_CONNECTIONINFOA pConnectionInfo;

    strcpy( DriveName, "A:" );

    DriveName[0] = 'A' + DriveNumber;

    //
    // allocate memory and open the enumeration
    //
    if (!(Buffer = LocalAlloc( LPTR, BufferSize ))) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    dwErr = WNetGetConnection2A( DriveName, Buffer, &BufferSize );
    if (dwErr != WN_SUCCESS) {
        dwErr = GetLastError();
        if ( dwErr == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
        (void) LocalFree((HLOCAL) Buffer) ;
        return FALSE;
    }

    pConnectionInfo = (LPWNET_CONNECTIONINFOA) Buffer;

    if ( !_strcmpi ( pConnectionInfo->lpProvider, NW_PROVIDERA ) ) {
        (void) LocalFree((HLOCAL) Buffer) ;
        return TRUE;
    }
    else {
        (void) LocalFree((HLOCAL) Buffer) ;
        return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\helpers.c ===
/******************************************************************************
*
*  HELPERS.C
*
*  Various helper functions.
*
*  Copyright (c) 1995 Microsoft Corporation
*
*   $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\HELPERS.C  $
*  
*     Rev 1.1   22 Dec 1995 14:24:48   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:02   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:56   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:38   terryt
*  Initial revision.
*  
*  
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

#include "nwscript.h"


/*******************************************************************************
 *
 *  DisplayMessage
 *      Display a message with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
DisplayMessage( unsigned int nID, ... )
{
    WCHAR sz1[512];
    WCHAR sz2[1536];  
    int cch ;
    HANDLE  hOut;

    va_list args;
    va_start( args, nID );

    if ( LoadString( NULL, nID, sz1, 512 ) ) {

        vswprintf(sz2, sz1, args ) ;
        
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        cch = wcslen(sz2) ;
        WriteConsole(hOut, sz2, cch, &cch, NULL);

    }

    va_end(args);

}  /* DisplayMessage() */


/*******************************************************************************
 *
 *  DisplayOemString
 *      Display an OEM string
 *
 *  ENTRY:
 *      string: string to display
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
DisplayOemString( char *string )
{
    // this will print % in strings correctly.
    printf( "%s", string );

} /* DisplayAnsiString() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\env.c ===
/*************************************************************************
*
*  ENV.C
* 
*  Environment export routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\ENV.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:28   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:53:48   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:40   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:58   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:22:50   terryt
*  Capture support
*  
*     Rev 1.1   23 May 1995 19:36:54   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:34   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"

#define MAX_PATH_LEN 2048
#define PATH "Path"
#define LIBPATH "LibPath"
#define OS2LIBPATH "Os2LibPath"

unsigned char * Path_Value = NULL;
unsigned char * LibPath_Value = NULL;
unsigned char * Os2LibPath_Value = NULL;


/********************************************************************

        GetOldPaths

Routine Description:

        Save the orginal paths for 
           Path
           LibPath
           Os2LibPath

Arguments:
        none

Return Value:
        none

 *******************************************************************/
void
GetOldPaths( void )
{
    if (!(Path_Value = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN )))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    GetEnvironmentVariableA( PATH, Path_Value, MAX_PATH_LEN );
    if (!(LibPath_Value = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    GetEnvironmentVariableA( LIBPATH, LibPath_Value, MAX_PATH_LEN );
    if (!(Os2LibPath_Value = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    GetEnvironmentVariableA( OS2LIBPATH, Os2LibPath_Value, MAX_PATH_LEN );
}


/********************************************************************

        AdjustPath

Routine Description:

        Given an old path and a new path, merge the two togther.
        Basically, the Adjusted path is the old path with the
        new values at the end, minus any duplicates.

Arguments:

        Value         - New path
        OldPath_Value - Old path
        AdjustedValue - New value (allocated)

Return Value:
        none

 *******************************************************************/
void
AdjustPath( unsigned char * Value,
            unsigned char * OldPath_Value,
            unsigned char ** AdjustedValue )
{
    unsigned char * tokenPath;
    unsigned char * clipStart;
    unsigned char * clipEnd;
    unsigned char * tokenSearch;
    unsigned char * tokenNext;

    if (!(*AdjustedValue = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    strncpy( *AdjustedValue, Value, MAX_PATH_LEN );

    if (!(tokenSearch = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
       DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
       (void) LocalFree((HLOCAL) *AdjustedValue) ;
       return;
    }
    strncpy( tokenSearch, OldPath_Value, MAX_PATH_LEN );

    tokenNext = tokenSearch;

    if ( !tokenNext || !tokenNext[0] ) 
        tokenPath = NULL;
    else {
        tokenPath = tokenNext;
        tokenNext = strchr( tokenPath, ';' );
        if ( tokenNext )  {
            *tokenNext++ = 0;
        }
    }

    while ( tokenPath != NULL )
    {
        if ( clipStart = strstr( *AdjustedValue, tokenPath ) ) {
            if ( clipEnd = strchr( clipStart, ';' ) ) {
                memmove( clipStart, clipEnd + 1, strlen( clipEnd + 1 ) + 1 );
            }
            else {
                clipStart[0] = 0;
            }
        }

        if ( !tokenNext || !tokenNext[0] ) 
            tokenPath = NULL;
        else {
            tokenPath = tokenNext;
            tokenNext = strchr( tokenPath, ';' );
            if ( tokenNext )  {
                *tokenNext++ = 0;
            }
        }
    }
    (void) LocalFree((HLOCAL) tokenSearch) ;

}

/********************************************************************

        ExportEnv

Routine Description:

        Export environment value to the registry

Arguments:

        EnvString - Environment string

Return Value:
        none

 *******************************************************************/
void
ExportEnv( unsigned char * EnvString )
{
    HKEY ScriptEnvironmentKey;
    NTSTATUS Status;
    unsigned char * Value;
    unsigned char * ValueName;
    unsigned char * AdjustedValue = NULL;

    ValueName = EnvString;
    Value = strchr( EnvString, '=' );

    if ( Value == NULL ) {
        wprintf(L"Bad Environment string\n");

        return;
    }
    Value++;

    if (!(ValueName = (unsigned char *)LocalAlloc( LPTR, Value-EnvString + 1)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    strncpy( ValueName, EnvString, (UINT) (Value-EnvString - 1) );

    if ( !_strcmpi( ValueName, PATH ) ) {
       AdjustPath( Value, Path_Value, &AdjustedValue );
       Value = AdjustedValue;
    }
    else if ( !_strcmpi( ValueName, LIBPATH ) ) {
       AdjustPath( Value, LibPath_Value, &AdjustedValue );
       Value = AdjustedValue;
    }
    else if ( !_strcmpi( ValueName, OS2LIBPATH ) ) {
       AdjustPath( Value, Os2LibPath_Value, &AdjustedValue );
       Value = AdjustedValue;
    }

    if (Value == NULL) {
        return;
    }

    Status = RegCreateKeyExW( HKEY_CURRENT_USER,
                                 SCRIPT_ENVIRONMENT_VALUENAME,
                                 0,
                                 WIN31_CLASS,
                                 REG_OPTION_VOLATILE,
                                 KEY_WRITE,
                                 NULL,                      // security attr
                                 &ScriptEnvironmentKey,
                                 NULL
                              );
    
    if ( NT_SUCCESS(Status)) {

        Status = RegSetValueExA( ScriptEnvironmentKey,
                                      ValueName,
                                 0,
                                 REG_SZ,
                                 (LPVOID) Value,
                                 strlen( Value ) + 1
                               );
    }
    else {
        wprintf(L"Cannot create registry key\n");
    }

    (void) LocalFree((HLOCAL) ValueName) ;

    if ( AdjustedValue )
        (void) LocalFree((HLOCAL) AdjustedValue) ;

    RegCloseKey( ScriptEnvironmentKey );
}

/********************************************************************

        ExportCurrentDirectory

Routine Description:

        Return the first non-local drive

Arguments:

        DriveNum - Number of drive 1-26

Return Value:
        none

 *******************************************************************/
void
ExportCurrentDirectory( int DriveNum )
{
    char DriveName[10];
    HKEY ScriptEnvironmentKey;
    NTSTATUS Status;
    char CurrentPath[MAX_PATH_LEN];

    strcpy( DriveName, "=A:" );

    DriveName[1] += (DriveNum - 1);

    if ( NTGetCurrentDirectory( (unsigned char)(DriveNum - 1), CurrentPath ) )
        return;

    Status = RegCreateKeyExW( HKEY_CURRENT_USER,
                                 SCRIPT_ENVIRONMENT_VALUENAME,
                                 0,
                                 WIN31_CLASS,
                                 REG_OPTION_VOLATILE,
                                 KEY_WRITE,
                                 NULL,                      // security attr
                                 &ScriptEnvironmentKey,
                                 NULL
                              );
    
    if ( NT_SUCCESS(Status)) {

        Status = RegSetValueExA( ScriptEnvironmentKey,
                                      DriveName,
                                 0,
                                 REG_SZ,
                                 (LPVOID) CurrentPath,
                                 strlen( CurrentPath ) + 1
                               );
    }
    else {
        wprintf(L"Cannot open registry key\n");
    }

    RegCloseKey( ScriptEnvironmentKey );

}


/********************************************************************

        ExportCurrentDrive

Routine Description:

        Export current drive to registry
        NOT IMPLEMENTED

Arguments:

        DriveNum - drive number

Return Value:
        none

 *******************************************************************/
void
ExportCurrentDrive( int DriveNum )
{
   /* 
    * Don't know if we want to do this or how.
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\ncp.c ===
/*************************************************************************
*
*  NCP.C
*
*  All routines doing direct NCPs or filecontrol operations
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NCP.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:50   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:54:06   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:56   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:10   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nwapi32.h>
#include <ntddnwfs.h>

#include "nwscript.h"
#include "ntnw.h"
#include "inc/nwlibs.h"


/********************************************************************

        NTGetUserID

Routine Description:

        Given a connection handle, return the user ID

Arguments:

        ConnectionHandle - Connection Handle
        UserID           - returned User ID

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
NTGetUserID(
    unsigned int       ConnectionHandle,
    unsigned long      *pUserID
    )
{
    NTSTATUS NtStatus ;
    unsigned int ObjectType;
    unsigned char LoginTime[7];
    unsigned char UserName[48];
    VERSION_INFO VerInfo;
    unsigned int Version;
    unsigned int ConnectionNum;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 

    NtStatus = GetConnectionNumber( ConnectionHandle, &ConnectionNum );

    if (!NT_SUCCESS(NtStatus)) 
       return NtStatus;

    NtStatus = NWGetFileServerVersionInfo( (NWCONN_HANDLE)ConnectionHandle,
                                            &VerInfo );

    if (!NT_SUCCESS(NtStatus)) 
       return NtStatus;

    Version = VerInfo.Version * 1000 + VerInfo.SubVersion * 10;

    if ( ( Version >= 3110 ) || ( Version < 2000 ) ) {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    8,                      // Max request packet size
                    63,                     // Max response packet size
                    "br|rrrr",              // Format string
                    // === REQUEST ================================
                    0x1c,                   // b Get Connection Information
                    &ConnectionNum, 4,      // r Connection Number
                    // === REPLY ==================================
                    pUserID, 4,             // r Object ID
                    &ObjectType, 2,         // r Object Type
                    UserName, 48,           // r UserName
                    LoginTime, 7            // r Login Time
                    );
    }
    else {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    63,                     // Max response packet size
                    "bb|rrrr",              // Format string
                    // === REQUEST ================================
                    0x16,                   // b Get Connection Information
                    ConnectionNum,          // b Connection Number
                    // === REPLY ==================================
                    pUserID, 4,             // r Object ID
                    &ObjectType, 2,         // r Object Type
                    UserName, 48,           // r UserName
                    LoginTime, 7            // r Login Time
                    );
    }

    return NtStatus;
}

/********************************************************************

        GetConnectionNumber

Routine Description:

        Given a ConnectionHandle, return the NetWare Connection number

Arguments:

        ConnectionHandle  - Connection Handle
        pConnectionNumber - pointer to returned connection number

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
GetConnectionNumber(
    unsigned int       ConnectionHandle,
    unsigned int *     pConnectionNumber )
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    NWR_GET_CONNECTION_DETAILS Details;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 

    Status = NtFsControlFile(
                 pServerInfo->hConn,     // Connection Handle
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_NWR_GET_CONN_DETAILS,
                 NULL,
                 0,
                 (PVOID) &Details,
                 sizeof(Details));

    if (Status == STATUS_SUCCESS) {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS(Status)) {
        *pConnectionNumber = 256 * Details.ConnectionNumberHi +
                             Details.ConnectionNumberLo;
    }

    return Status;
}

/********************************************************************

        GetInternetAddress

Routine Description:

        Return the address of the current system

Arguments:

        ConnectionHandle - Connection Handle
        ConnectionNum    - Connection Number
        pAddress         - returned address

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
GetInternetAddress(
    unsigned int       ConnectionHandle,
    unsigned int       ConnectionNum,
    unsigned char      *pAddress
    )
{
    NTSTATUS NtStatus ;
    VERSION_INFO VerInfo;
    unsigned int Version;
    unsigned char Address[12];
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 

    NtStatus = NWGetFileServerVersionInfo( (NWCONN_HANDLE)ConnectionHandle,
                                            &VerInfo );

    if (!NT_SUCCESS(NtStatus)) 
       return NtStatus;

    Version = VerInfo.Version * 1000 + VerInfo.SubVersion * 10;

    if ( ( Version >= 3110 ) || ( Version < 2000 ) ) {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    7,                      // Max request packet size
                    14,                     // Max response packet size
                    "br|r",                 // Format string
                    // === REQUEST ================================
                    0x1a,                   // b Get Connection Information
                    &ConnectionNum, 4,      // r Connection Number
                    // === REPLY ==================================
                    Address, 12             // r Login Time
                    );
    }
    else {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    14,                     // Max response packet size
                    "bb|r",                 // Format string
                    // === REQUEST ================================
                    0x13,                   // b Get Connection Information
                    (unsigned char)ConnectionNum, // b Connection Number
                    // === REPLY ==================================
                    Address, 12             // r Login Time
                    );
    }
    memcpy( pAddress, Address, 10 );

    return NtStatus;
}


/********************************************************************

        GetBinderyObjectID

Routine Description:

        Get the object ID of a named object in the bindery

Arguments:

        ConnectionHandle - Server connection handle
        pObjectName      - Name of object
        ObjectType       - Object type
        pObjectId        - returned object ID


Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
GetBinderyObjectID( 
    unsigned int       ConnectionHandle,
    char              *pObjectName,
    unsigned short     ObjectType,
    unsigned long     *pObjectId )
{
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 
    unsigned int reply;

    reply = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Directory function
                    54,                     // Max request packet size
                    56,                     // Max response packet size
                    "brp|r",                // Format string
                    // === REQUEST ================================
                    0x35,                   // b Get object ID
                    &ObjectType, W_SIZE,    // r Object type HI-LO
                    pObjectName,            // p UserName
                    // === REPLY ==================================
                    pObjectId, 4            // 4 bytes of raw data
                    );
    return reply;
}

/********************************************************************

        GetDefaultPrinterQueue

Routine Description:

    Get the default printer queue.

Arguments:
    ConnectionHandle - IN
       Handle to server
    pServerName - IN
       File server name
    pQueueName - OUT
       Default printer queue name
        

Return Value:

 *******************************************************************/
unsigned int
GetDefaultPrinterQueue (
    unsigned int  ConnectionHandle,
    unsigned char *pServerName,
    unsigned char *pQueueName
    )
{
    unsigned long      ObjectID;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 
    NWOBJ_TYPE         ObjectType;
    NWCCODE            Nwcode;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    NWR_ANY_F2_NCP(0x11),   // F2 Function function
                    4,                      // Max request packet size
                    4,                      // Max response packet size
                    "wbb|d",                // Format string
                    // === REQUEST ================================
                    0x2,                    // w Length
                    0xA,                    // b Subfunction
                    0,                      // b printer number
                    // === REPLY ==================================
                    &ObjectID               // d Object ID of Queue
                    );

    if ( !NT_SUCCESS( NtStatus ) )
        return ( NtStatus & 0xFF );

    Nwcode = NWGetObjectName( (NWCONN_HANDLE) ConnectionHandle,
                              ObjectID,
                              pQueueName,
                              &ObjectType ); 

    return Nwcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\maplist.c ===
/*************************************************************************
*
*  QATTACH.C
*
*  Do any neccessary attach user queries
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\MAPLIST.C  $
*  
*     Rev 1.1   10 Apr 1996 14:22:42   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.1   12 Mar 1996 19:53:58   terryt
*  Relative NDS names and merge
*  
*     Rev 1.0   22 Jan 1996 16:49:24   terryt
*  Initial revision.
*  
*************************************************************************/
#include "common.h"

//
//  4X login script behavior for map commands to servers not in the
//  logged in NDS tree that have not been ATTACH'ed is different from
//  the 3X behavior.
//
//  The 4X behavior is to always ask for a user name and password for
//  these servers, doing the attach at that point.  The user gets
//  two trys.
//
//  Since NT doesn't have an list of attached servers, and will try
//  to connect to a volume with the default user name and password,
//  a wrapper must be put around the MAP commands.  This code
//  must determine that a bindery connection will be made and that
//  this server has not previously been MAP'ed or ATTACH'ed.
//  The user will be always prompted for user name and password.
//  The server will then be logged into with those credentials.
//
//  One problem with the below is that it's not easy to tell that
//  a connection "will be" made with the bindery, this is done in
//  the redirector.  So to simplify things the assumption is that
//  only 3X servers use bindery connections.  This means that 
//  4X servers using bindery emulation on a different NDS tree will
//  not always be asked for the user name and password.
//
//  Already processed servers are kept in a list and marked as 4X or 3X
//  for possible future use.
//
//  The behavior for a 3X login depends on the LOGIN.EXE version.
//  The old behavior is that you must always ATTACH before mapping.
//  However, if you login to a 3X server with a 4X version LOGIN.EXE
//  it will try to authenticate using your user name (and password)
//  on the first attempt and ask for a password if that fails.  The
//  second attempt will ask for your user name.  Since this 4X behavior
//  is more forgiving (more scripts "work") that is the one being
//  emulated.
//

typedef struct _SERVERLIST
{
   char * ServerName;
   unsigned int ServerType;
   struct _SERVERLIST *pNextServer;
} SERVERLIST, *PSERVERLIST;

PSERVERLIST pMainList = NULL;

BOOL IsServerInAttachList( char *, unsigned int );
void AddServerToAttachList( char *, unsigned int );
int DoAttachProcessing( char * );

/*
 * Scan the list for the server
 */
BOOL
IsServerInAttachList( char * Server, unsigned int ServerType )
{
   PSERVERLIST pServerList = pMainList;

   while ( pServerList != NULL )
   {
       if ( !_strcmpi( Server, pServerList->ServerName ) &&
            ( ServerType & pServerList->ServerType ) )
           return TRUE;
        pServerList = pServerList->pNextServer;
   }
   
   return FALSE;
}

/*
 * Add the server to the list of attached servers
 *
 * This is used during MAP's and ATTACH's
 */
void
AddServerToAttachList( char * Server, unsigned int ServerType )
{
    PSERVERLIST pServerList;

    pServerList = (PSERVERLIST) malloc( sizeof( SERVERLIST ) );

    if ( pServerList == NULL )
    {
        DisplayMessage( IDR_NOT_ENOUGH_MEMORY );
        return;
    }

    pServerList->ServerName = _strdup( Server );
    pServerList->ServerType = ServerType;
    pServerList->pNextServer = pMainList;
    pMainList = pServerList;
}

/*
 *  Do any Attach processing
 *  Return error code. 0 is success.
 *  880F is the special "attached failed" error
 */

int
DoAttachProcessing( char * PossibleServer )
{
    unsigned int  iRet = 0;
    unsigned int  conn;
    char userName[MAX_NAME_LEN] = "";
    char password[MAX_PASSWORD_LEN] = "";
    BOOL AlreadyConnected = FALSE;

    //
    // Must have a server to process
    //
    if ( !*PossibleServer )
       return iRet;

    // See if this server has been processed before
    // No since in doing a 4X server twice, and you only ask
    // for the user name and password once.

    if ( IsServerInAttachList( PossibleServer,
             LIST_4X_SERVER | LIST_3X_SERVER ) )
        return iRet;

    // See if there is already a connection to the server

    if ( NTIsConnected( PossibleServer ) )
       AlreadyConnected = TRUE;
    else
       AlreadyConnected = FALSE;

    // Try and attach to the server

    iRet = NTAttachToFileServer( PossibleServer, &conn );

    // If attach failed, return

    if ( iRet ) 
       return iRet;

    // If this is a 4X server then add it to the list of attached
    // servers.  We don't want to do this again.  4X servers must 
    // use the NDS attachment anyway (or at least I don't see a 
    // way of telling that it's going to be a bindery emulation
    // connection ahead of time).

    if ( fNDS && Is40Server( conn ) )
    {
        AddServerToAttachList( PossibleServer, LIST_4X_SERVER );
        DetachFromFileServer ( conn );
        return iRet;
    }

    // Close that first connection

    DetachFromFileServer ( conn );

    // If we are already connected, don't mess with things
    // The credentials can't be changed anyway

    if ( AlreadyConnected )
    {
        AddServerToAttachList( PossibleServer, LIST_3X_SERVER );
        return iRet;
    }

    // Ask for user name on an NDS login
    //
    // Use the current login name for a 3X login on the first attempt

    if ( fNDS )
    {
        DisplayMessage(IDR_ENTER_LOGIN_NAME, PossibleServer);
        if (!ReadName(userName))
            return 0x880F;
    }
    else
    {
        strncpy( userName, LOGIN_NAME, sizeof( userName ) );
    }

    // Try to log the user in, asking for a password 

    iRet = Login( userName,
                  PossibleServer,
                  password,
                  TRUE );

    // Clear out the password
    // We don't need it again

    memset( password, 0, sizeof( password ) );

    // If failed, give the user one more chance

    if ( iRet )
    {
        // Ask for user name

        DisplayMessage(IDR_ENTER_LOGIN_NAME, PossibleServer);
        if (!ReadName(userName))
            return 0x880F;

        // Try to log the user in 

        iRet = Login( userName,
                      PossibleServer,
                      password,
                      TRUE );

        // Clear out the password

        memset( password, 0, sizeof( password ) );

    }
    
    // Add servername to list of attached servers, marked as 3X

    if ( !iRet )
    {
        AddServerToAttachList( PossibleServer, LIST_3X_SERVER );
    }
    else
    {  
        iRet = 0x880F;   // Special I am not attached error
    }

    return iRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\nds.c ===
/*************************************************************************
*
*  NDS.C
*
*  NT NetWare NDS routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*************************************************************************/
#include <common.h>

DWORD GUserObjectID;
HANDLE GhRdrForUser;
HANDLE GhRdr;


WCHAR * NDSTREE_w = NULL;
UNICODE_STRING NDSTREE_u;

/********************************************************************

        ExpandRelativeName

Routine Description:

        If the name is a relative NDS name append the proper context
        to the end.   A relative name has periods on the end.  Each
        period represents one level up the NDS tree.

Arguments:

Return Value:

 *******************************************************************/
void
ExpandRelativeName( LPSTR RelativeName, LPSTR AbsoluteName, unsigned int Len,
                    LPSTR Context )
{

   PBYTE ptr;
   unsigned int   i;
   unsigned int   count = 0;

   strncpy( AbsoluteName, RelativeName, Len );

   if ( ( AbsoluteName[0] == '.' ) &&
        ( AbsoluteName[ strlen( AbsoluteName ) - 1 ] != '.' ) )
       return;

   if ( ( strlen( AbsoluteName ) + strlen( Context ) ) > Len )
   {
       DisplayMessage( IDR_NOT_ENOUGH_MEMORY );
       return;
   }

   if ( AbsoluteName[0] == '\0' )
   {
       return;
   }

   ptr = &AbsoluteName[ strlen( AbsoluteName ) - 1 ];

   // Count the number of periods and back up over them.

   if ( *ptr != '.' )
   {
       //
       // No periods at the end
       // Assume this is a relative name and append the context
       //
       strcat( AbsoluteName, "." );
       strcat( AbsoluteName + strlen( AbsoluteName ), Context );
       return;
   }

   while ( *ptr == '.' )
   {
       ptr--;
       count++;
   }

   ptr++;
   *ptr = '\0';

   // ptr now points to where the copy of the rest of the context should start
   // skip the first "count" entries in the context

   ptr = Context;

   for ( i = 0; i < count; i++ )
   {
      ptr = strchr( ptr, '.' );
      if ( ptr == NULL )
      {
          return;
      }
      ptr++;
   }
   ptr--;

   // Now append

   strcat( AbsoluteName, ptr );

}



/********************************************************************

        NDSGetNameContext

Routine Description:

        Get the current context

Arguments:
        none

Return Value:
        none

 *******************************************************************/
NTSTATUS
NDSGetNameContext( LPSTR Context, BOOLEAN flag )
{
    //
    // For NdsResolveName.
    //

    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    HANDLE hReferredServer;
    DWORD dwHandleType;

    NTSTATUS Status;

    OEM_STRING oemStr;
    UNICODE_STRING defaultcontext;
    DWORD ThisObjectID;
    BYTE  Buffer[2048];
    WCHAR NdsStr[1024];
    PBYTE ptr;

    defaultcontext.Length = 0;
    defaultcontext.MaximumLength = sizeof( NdsStr );
    defaultcontext.Buffer = NdsStr;

    Status = NwNdsGetTreeContext( GhRdr, &NDSTREE_u, &defaultcontext );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &defaultcontext,
                                &ThisObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            DisplayMessage(IDR_NDS_USERNAME_FAILED);
            return Status;
        }

        if( GhRdr != GhRdrForUser ) {
            CloseHandle( GhRdr );
        }
        GhRdr = hReferredServer;
    }

    Status = NwNdsReadObjectInfo( GhRdr, ThisObjectID, Buffer, 2048 );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ptr = Buffer + sizeof( NDS_RESPONSE_GET_OBJECT_INFO );
    ptr += ROUNDUP4(*(DWORD *)ptr);
    ptr += sizeof(DWORD);
    ptr += sizeof(DWORD);

    defaultcontext.Length = wcslen( (WCHAR *)ptr ) * 2;
    defaultcontext.MaximumLength = defaultcontext.Length;
    defaultcontext.Buffer = (WCHAR *)ptr;

    oemStr.Length = 0;
    oemStr.MaximumLength = NDS_NAME_CHARS;
    oemStr.Buffer = Context;

    RtlUnicodeStringToOemString( &oemStr, &defaultcontext, FALSE );

    return 0;
}

/********************************************************************

        NDSTypeless

Routine Description:

        Change name to typelese

Arguments:
        none

Return Value:
        none

 *******************************************************************/
unsigned int
NDSTypeless( LPSTR OrigName , LPSTR TypelessName )
{
    int i,j;
    PBYTE p;

    i = 0;
    j = 0;

    if ( !_strnicmp( "CN=", OrigName, 3 ) ||
         !_strnicmp( "OU=", OrigName, 3 ) )
    {
       i += 3;
    }
    else if ( !_strnicmp( "C=", OrigName, 2 ) ||
              !_strnicmp( "O=", OrigName, 2 ) )
    {
       i += 2;
    }

    for ( ; (( i < NDS_NAME_CHARS ) && ( OrigName[i] ) ); i++ )
    {
       if ( !_strnicmp( ".CN=", &OrigName[i], 4 ) ||
            !_strnicmp( ".OU=", &OrigName[i], 4 ) )
       {
          TypelessName[j++]= '.';
          i += 3;
          continue;
       }
       if ( !_strnicmp( ".C=", &OrigName[i], 3 ) ||
            !_strnicmp( ".O=", &OrigName[i], 3 ) )
       {
          TypelessName[j++]= '.';
          i += 2;
          continue;
       }
       /*
        * Strip out multiple blanks
        */
       if ( !_strnicmp( "  ", &OrigName[i], 2 ) )
       {
          continue;
       }
       TypelessName[j++] = OrigName[i];
    }

    TypelessName[j] = '\0';

    return 0;
}

/********************************************************************

        NDSAbbreviateName

Routine Description:

        Abbreviate name

Arguments:
        none

Return Value:
        none

 *******************************************************************/
unsigned int
NDSAbbreviateName( DWORD Flags, LPSTR OrigName , LPSTR AbbrevName )
{
    BYTE Buffer[NDS_NAME_CHARS];
    BYTE CurrentContext[NDS_NAME_CHARS];
    PBYTE p;
    PBYTE c;
    NTSTATUS Status;

    if ( OrigName[0] == '.' )
        NDSTypeless( OrigName + 1, Buffer );
    else
        NDSTypeless( OrigName, Buffer );

    /*
     * We want a relative name
     */
    if ( Flags & FLAGS_LOCAL_CONTEXT )
    {
        p = &Buffer[strlen(Buffer)-strlen(REQUESTER_CONTEXT)];
        if ( !_strcmpi( REQUESTER_CONTEXT, p ) )
        {
            // The name is below us

            if ( ( *(p-1) == '.' ) && ( p > Buffer ) )
               p--;
            *p = '\0';
            strcpy( AbbrevName, Buffer );
        }
        else
        {
            //
            // Going from back to front for each section of context
            // in common with AbbrevName
            //    truncate both
            // Going from back to front for each section of context
            // left over
            //    concatonate a period to AbbrevName
            //
            // Example
            //
            // Name: w.x.y.z  Context: a.b.z  =>  w.x.y..
            //

            strcpy( CurrentContext, REQUESTER_CONTEXT );
            strcpy( AbbrevName, Buffer );

            if ( CurrentContext[0] && AbbrevName[0] )
            {
                c = &CurrentContext[ strlen( CurrentContext ) ] - 1;
                p = &AbbrevName[ strlen( AbbrevName ) ] - 1;

                //
                // Strip off the matching names from end to front
                //
                for ( ;; )
                {
                    if ( ( c == CurrentContext ) && ( *p == '.' ) )
                    {
                        *c = '\0';
                        *p = '\0';
                        break;
                    }

                    if ( *c != *p )
                        break;

                    if ( ( *c == '.' ) && ( *p == '.' ) )
                    {
                        *c = '\0';
                        *p = '\0';
                    }

                    if ( ( c == CurrentContext ) || ( p == AbbrevName ) )
                    {
                        break;
                    }

                    c--; p--;
                }

                //
                // Count the remaining sections of the context and
                // add that number of periods to the end of the buffer.
                // That is how far we need to back up before getting
                // to a matching branch of the tree.
                //

                if ( CurrentContext[0] ) {
                    strcat( AbbrevName, "." );
                    for ( c = CurrentContext; *c; c++ ) {
                        if ( *c == '.' )
                            strcat( AbbrevName, "." );
                    }
                }
            }

        }
    }
    else
        strcpy( AbbrevName, Buffer );

    return 0;
}


/********************************************************************

        NDSInitUserProperty

Routine Description:

        none

Arguments:
        none

Return Value:
        0 = no error

 *******************************************************************/
unsigned int
NDSInitUserProperty( )
{
    NTSTATUS Status;
    UNICODE_STRING ObjectName;
    PWCHAR lpT;
    UNICODE_STRING defaultcontext;

    //
    // For NdsResolveName.
    //

    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    HANDLE hReferredServer;
    DWORD dwHandleType;

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &NDSTREE_u, &GhRdr );

    if ( !NT_SUCCESS( Status ) ) {
        DisplayMessage(IDR_TREE_OPEN_FAILED);
        return 1;
    }

    //
    // Resolve the name that we have to an object id.
    //

    RtlInitUnicodeString( &ObjectName, TYPED_USER_NAME_w );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &ObjectName,
                                &GUserObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       DisplayMessage(IDR_NDS_USERNAME_FAILED);
       return 1;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            DisplayMessage(IDR_NDS_USERNAME_FAILED);
            return 1;
        }

        CloseHandle( GhRdr );
        GhRdr = hReferredServer;

    }

    //
    //  Save off this handle for the user so that we can use it to
    //  get information about the user.
    //

    GhRdrForUser = GhRdr;

    //
    // Set the current context to what we think it should be
    // (At the user's location.)
    //

    lpT = wcschr( TYPED_USER_NAME_w, L'.' );
    while (lpT) // handle usernames with embedded/escaped dots
    {
        if (*(lpT-1) == L'\\')
        {
            lpT = wcschr (lpT+1, L'.');
        }
        else
            break;
    }
    if ( lpT )
    {
        RtlInitUnicodeString( &defaultcontext, lpT+1 );
    }
    else
    {
        RtlInitUnicodeString( &defaultcontext, L"" );
    }

    Status = NwNdsSetTreeContext( GhRdr, &NDSTREE_u, &defaultcontext );

    if ( !NT_SUCCESS( Status ) ) {
       DisplayMessage(IDR_NDS_CONTEXT_INVALID);
       return 1;
    }

    return 0;


}

/********************************************************************

        NDSCanonicalizeName

Routine Description:

        return a canonicalized version of a name

Arguments:
        Name - original name
        CanonName - Canonicalized name
        Len - length of CanonName
        fCurrentContext - TRUE => use current contex, FALSE use
                          requester context

Return Value:
        status error

 *******************************************************************/
unsigned int
NDSCanonicalizeName( PBYTE Name, PBYTE CanonName, int Len, int fCurrentContext )
{
    NTSTATUS Status;
    int ccode = -1;
    DWORD ThisObjectID;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    BYTE Buffer[2048];
    BYTE FullName[NDS_NAME_CHARS];
    PBYTE ptr;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;
    unsigned char CurrentContext[NDS_NAME_CHARS];

    //
    // Cope with relative names
    //
    if ( fCurrentContext )
    {
        Status = NDSGetNameContext( CurrentContext, TRUE );
        if ( !NT_SUCCESS( Status ) )
            return Status;
        ExpandRelativeName( Name, FullName, NDS_NAME_CHARS, CurrentContext );
    }
    else
        ExpandRelativeName( Name, FullName, NDS_NAME_CHARS, REQUESTER_CONTEXT );

    //
    // Fill it in in case we have an error
    //
    strncpy( CanonName, FullName, Len);

    //
    // Resolve the name that we have to an object id.
    //
    // Unfortuneately, the name resolver doesn't understand periods at the
    // front or end (absolute or relative names)
    //

    if ( FullName[0] == '.' )
    {
        oemStr.Length = (USHORT)strlen( FullName + 1 );
        oemStr.MaximumLength = oemStr.Length;
        oemStr.Buffer = FullName + 1;
    }
    else
    {
        oemStr.Length = (USHORT)strlen( FullName );
        oemStr.MaximumLength = oemStr.Length;
        oemStr.Buffer = FullName;
    }

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(Buffer);
    ObjectName.Buffer = (WCHAR *)Buffer;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &ObjectName,
                                &ThisObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return Status;
        }

        if( GhRdr != GhRdrForUser ) {
            CloseHandle( GhRdr );
        }
        GhRdr = hReferredServer;
    }

    Status = NwNdsReadObjectInfo( GhRdr, ThisObjectID, Buffer, 2048 );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ptr = Buffer + sizeof( NDS_RESPONSE_GET_OBJECT_INFO );
    ptr += ROUNDUP4(*(DWORD *)ptr);
    ptr += sizeof(DWORD);
    ptr += sizeof(DWORD);

    RtlInitUnicodeString( &ObjectName, (PWCHAR)ptr );

    oemStr.Length = 0;
    oemStr.MaximumLength = (USHORT) Len;
    oemStr.Buffer = CanonName;

    RtlUnicodeStringToOemString( &oemStr, &ObjectName, FALSE );

    return 0;
}

/********************************************************************

        NDSGetUserProperty

Routine Description:

        Return the NDS property for the object

Arguments:
        Property - property name
        Data     - data buffer
        Size     - size of data buffer

Return Value:
        0 no error

 *******************************************************************/
unsigned int
NDSGetUserProperty( PBYTE Property,
                    PBYTE Data,
                    unsigned int Size,
                    SYNTAX * pSyntaxID,
                    unsigned int * pActualSize )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int ccode = -1;

    OEM_STRING oemStr;
    UNICODE_STRING PropertyName;
    WCHAR NdsStr[1024];
    DWORD iterhandle = INITIAL_ITERATION;

    PBYTE szBuffer;
    DWORD dwBufferSize = 2048;
    PNDS_RESPONSE_READ_ATTRIBUTE pReadAttribute;
    PNDS_ATTRIBUTE pAttribute;
    PBYTE pAttribValue;
    BOOL  fContinue = TRUE;

    //
    // Read the User property
    //

    szBuffer = (PBYTE)malloc(dwBufferSize);

    if ( !szBuffer ) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        Status = STATUS_NO_MEMORY;
        return Status;
    }
    memset( szBuffer, 0, dwBufferSize );

    oemStr.Length = (USHORT) strlen( Property );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Property;

    PropertyName.Length = 0;
    PropertyName.MaximumLength = sizeof(NdsStr);
    PropertyName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &PropertyName, &oemStr, FALSE );

    while ( fContinue )
    {
        Status = NwNdsReadAttribute ( GhRdrForUser,
                                      GUserObjectID,
                                      &iterhandle,
                                      &PropertyName,
                                      szBuffer,
                                      dwBufferSize );

        if ( NT_SUCCESS(Status) && iterhandle != INITIAL_ITERATION )
        {
            dwBufferSize *= 2;

            free( szBuffer );

            szBuffer = (PBYTE)malloc(dwBufferSize);

            if ( !szBuffer ) {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            memset( szBuffer, 0, dwBufferSize );
            iterhandle = INITIAL_ITERATION;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if ( !NT_SUCCESS(Status) )
    {
        if ( szBuffer )
            free( szBuffer );
        return Status;
    }

    if ( NT_SUCCESS(Status) )
    {
        int i;
        pReadAttribute = (PNDS_RESPONSE_READ_ATTRIBUTE)szBuffer;
        pAttribute = (PNDS_ATTRIBUTE)(szBuffer
                      + sizeof(NDS_RESPONSE_READ_ATTRIBUTE));
        if ( pSyntaxID )
        {
            *pSyntaxID = pAttribute->SyntaxID;
        }

        pAttribValue = (PBYTE)(pAttribute->AttribName) +
                       ROUNDUP4(pAttribute->AttribNameLength) +
                       sizeof(DWORD);

        if ( pActualSize )
        {
            *pActualSize = *(DWORD *)pAttribValue;
        }

        memcpy( Data, pAttribValue + sizeof(DWORD),
                min(*(DWORD *)pAttribValue, Size) );

    }

    return Status;
}


/********************************************************************

        NDSGetVar

Routine Description:

        Return value of user property

        Get the syntax type of the property
        Retrieve the data
        Do any data conversion

Arguments:
        Name - of NDS property IN
        Value - value buffer OUT
        Size - size of value buffer IN

Return Value:
        none

 *******************************************************************/
void
NDSGetVar ( PBYTE Name, PBYTE Value, unsigned int Size)
{
   unsigned int err;
   SYNTAX Syntax;
   BYTE Buffer[ATTRBUFSIZE];
   DWORD ActualSize;

   Value[0] = 0;

   err = NDSGetUserProperty( Name, Buffer, ATTRBUFSIZE, &Syntax, &ActualSize );

   if ( err )
   {
       return;
   }

   switch ( Syntax )
   {
   case NDSI_BOOLEAN:
       if ( *(PBYTE)Buffer )
       {
           strcpy( Value, "Y" );
       }
       else
       {
           strcpy( Value, "N" );
       }
       break;
   case NDSI_DIST_NAME:
   case NDSI_CE_STRING:
   case NDSI_CI_STRING:
   case NDSI_OCTET_STRING:
   case NDSI_PR_STRING:
   case NDSI_NU_STRING:
   case NDSI_TEL_NUMBER:
   case NDSI_CLASS_NAME:
       ConvertUnicodeToAscii( Buffer );
       if ( Syntax == NDSI_DIST_NAME )
           NDSAbbreviateName(FLAGS_LOCAL_CONTEXT, Buffer, Buffer);
       strncpy( Value, Buffer, Size );
       break;
   case NDSI_CI_LIST:
       ConvertUnicodeToAscii( Buffer+8 );
       strncpy( Value, Buffer+8, Size );
       break;
       break;
   case NDSI_INTEGER:
   case NDSI_COUNTER:
   case NDSI_TIME:
   case NDSI_INTERVAL:
   case NDSI_TIMESTAMP:
       sprintf( Value, "%d", *(int *)Buffer );
       break;
   case NDSI_PO_ADDRESS:
       {
           // 6 null terminated lines
           int line,len;
           PBYTE ptr = Buffer + 4;

           // Stop if not 6 lines
           if ( *(int *)Buffer != 6 )
               break;

           for (line = 0; line <= 5; line++) {
               len = ROUNDUP4(*(int *)ptr);
               ptr += 4;
               if ( !len )
                   break;
               ConvertUnicodeToAscii( ptr );
               strcat( Value, ptr );
               strcat( Value, "\n" );
               ptr += len;
           }
       }
       break;
   case NDSI_FAX_NUMBER:
       if ( *(int *)Buffer == 0 )
           return;
       ConvertUnicodeToAscii( Buffer+4 );
       strncpy( Value, Buffer+4, Size );
       break;
   case NDSI_EMAIL_ADDRESS:
       if ( *(int *)(Buffer+4) == 0 )
           return;
       ConvertUnicodeToAscii( Buffer+8 );
       strncpy( Value, Buffer+8, Size );
       break;
   case NDSI_PATH:
       {
           int len;

           len = *(int *)(Buffer+4);
           if ( len == 0 )
               break;
           len = ROUNDUP4( len );
           ConvertUnicodeToAscii( Buffer+8 );
           strcpy( Value, Buffer+8 );
           NDSAbbreviateName(FLAGS_LOCAL_CONTEXT, Value, Value);
           strcat( Value, ":" );
           if ( *(int *)(Buffer + 8 + len) == 0 )
               break;
           ConvertUnicodeToAscii( Buffer+8+len+4 );
           strcat( Value, Buffer+8+len+4 );
           break;
       }
   case NDSI_NET_ADDRESS:
   case NDSI_OCTET_LIST:
   case NDSI_OBJECT_ACL:
   case NDSI_STREAM:
   case NDSI_UNKNOWN:
   case NDSI_REPLICA_POINTER:
   case NDSI_BACK_LINK:
   case NDSI_TYPED_NAME:
   case NDSI_HOLD:
   case NDSI_TAX_COUNT:
   default:
       Value[0] = '\0';
       Value[1] = '\0';
       break;
   }

}

/********************************************************************

        NDSChangeContext

Routine Description:

        Change the current context

Arguments:
        Context - context string IN

Return Value:
        error number

 *******************************************************************/
unsigned int
NDSChangeContext( PBYTE Context )
{
    NTSTATUS Status;

    OEM_STRING oemStr;
    UNICODE_STRING defaultcontext;
    WCHAR NdsStr[1024];

    oemStr.Length = (USHORT)strlen( Context );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Context;

    defaultcontext.Length = 0;
    defaultcontext.MaximumLength = sizeof(NdsStr);
    defaultcontext.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &defaultcontext, &oemStr, FALSE );

    Status = NwNdsSetTreeContext( GhRdr, &NDSTREE_u, &defaultcontext );

    return Status;
}

/********************************************************************

        NDSGetContext

Routine Description:

        Retrieve the current context

Arguments:
        Buffer - data buffer for context string OUT
        len    - length of data buffer IN

Return Value:
        error number

 *******************************************************************/
unsigned int
NDSGetContext( PBYTE Buffer,
               unsigned int len )
{
    NTSTATUS Status;

    Status = NDSGetNameContext( Buffer, TRUE );
    if ( !NT_SUCCESS( Status ) )
        return Status;
    NDSAbbreviateName(FLAGS_NO_CONTEXT, Buffer, Buffer);
    return 0;
}

/********************************************************************

        NDSfopenStream

Routine Description:

        Open a file handle to an NDS stream property

Arguments:
        Object - name of object IN
        Property - name of property IN
        pStream - pointer to file handle OUT
        pFileSize - pointer to file size OUT

Return Value:
        error

 *******************************************************************/
unsigned int
NDSfopenStream ( PBYTE Object,
                 PBYTE Property,
                 PHANDLE pStream,
                 unsigned int * pFileSize )
{
    //
    // Status variables.
    //

    NTSTATUS Status;
    int ccode = -1;

    //
    // For NwNdsOpenTreeHandle.
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    WCHAR NdsStr[1024];

    //
    // For NwNdsResolveName.
    //

    DWORD dwOid;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &NDSTREE_u, &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        DisplayMessage(IDR_TREE_OPEN_FAILED);
        return ccode;
    }

    //
    // Resolve the name that we have to an object id.
    //

    if ( !Object )
    {
        return 1;
    }

    oemStr.Length = (USHORT)strlen( Object );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Object;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return 0xffffffff;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // must jump to that server before continuing.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return 0xffffffff;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    //
    // Open the file stream.
    //

    oemStr.Length = (USHORT)strlen( Property );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Property;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    //
    // Try to open a file stream for read access.
    //

    Status = NwNdsOpenStream( hRdr,
                              dwOid,
                              &ObjectName,
                              1,                // Read access.
                              pFileSize );

    if ( !NT_SUCCESS( Status ) ) {
        return 0xffffffff;
    }

    *pStream = hRdr;

    return 0;
}

/*
 * IsMemberOfNDSGroup
 * ------------------
 *
 * Returns true if currently logged in user object is member of group with given name
 *
 */
unsigned int
IsMemberOfNDSGroup(
        PBYTE        nwGroup
        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT        nwRet;
    BYTE        szCanonTargetGroupName[NDS_NAME_CHARS+1];
    UINT        syntaxid;
    UINT        actualsize;
    PBYTE       szBuffer;
    LPSTR       pProp;
    UINT        i;
    DWORD iterhandle = INITIAL_ITERATION;
    DWORD dwBufferSize = ATTRBUFSIZE;
    UINT        fFoundGroup = FALSE;
    PNDS_RESPONSE_READ_ATTRIBUTE pReadAttribute;
    PNDS_ATTRIBUTE pAttribute;
    PBYTE pAttribValue;
    UNICODE_STRING PropertyName;
    UINT    numvalues = 0;
    BOOL    fContinue = TRUE;

    szBuffer = (PBYTE)malloc(dwBufferSize);

    if ( !szBuffer ) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    memset( szBuffer, 0, dwBufferSize );

    // Canonicalize name according to current context

    strcpy( szCanonTargetGroupName, nwGroup );

    nwRet = NDSCanonicalizeName( szCanonTargetGroupName,
                                 szCanonTargetGroupName,
                                 NDS_NAME_CHARS,
                                 TRUE );
    if (nwRet) {

        if ( nwGroup[0] != '.' ) {

            // Try an absolute name

            strcpy( szCanonTargetGroupName, "." );
            strcat( szCanonTargetGroupName, nwGroup );

            nwRet = NDSCanonicalizeName( szCanonTargetGroupName,
                                         szCanonTargetGroupName,
                                         NDS_NAME_CHARS,
                                         TRUE );
        }

        if ( nwRet )
            goto CleanRet;
    }

    // Should check class name of object

    RtlInitUnicodeString( &PropertyName, L"Group Membership" );

    while ( fContinue )
    {
        Status = NwNdsReadAttribute ( GhRdrForUser,
                                      GUserObjectID,
                                      &iterhandle,
                                      &PropertyName,
                                      szBuffer,
                                      dwBufferSize );

        if ( NT_SUCCESS(Status) && iterhandle != INITIAL_ITERATION )
        {
            dwBufferSize *= 2;

            free( szBuffer );

            szBuffer = (PBYTE)malloc(dwBufferSize);

            if ( !szBuffer ) {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            memset( szBuffer, 0, dwBufferSize );
            iterhandle = INITIAL_ITERATION;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if ( !NT_SUCCESS(Status) )
    {
        goto CleanRet;
    }

    pReadAttribute = (PNDS_RESPONSE_READ_ATTRIBUTE)szBuffer;

    pAttribute = (PNDS_ATTRIBUTE)(szBuffer
                  + sizeof(NDS_RESPONSE_READ_ATTRIBUTE));
    pAttribute->SyntaxID;

    pAttribValue = (PBYTE)(pAttribute->AttribName) +
                   ROUNDUP4(pAttribute->AttribNameLength) +
                   sizeof(DWORD);

    numvalues = *(PUINT)((PBYTE)(pAttribute->AttribName) +
                         ROUNDUP4(pAttribute->AttribNameLength));

    if ( *(DWORD *)pAttribValue == 0 )
    {
        goto CleanRet;
    }

    for ( i = 0; i < numvalues; i++ ) {
        ConvertUnicodeToAscii( pAttribValue+sizeof(DWORD) );
        if (!_stricmp(pAttribValue+sizeof(DWORD),szCanonTargetGroupName)) {
            fFoundGroup = TRUE;
            break;
        }
        pAttribValue += ROUNDUP4(*(PUINT)pAttribValue) + sizeof(DWORD);
    }



CleanRet:
    if (szBuffer ) {
        free (szBuffer);
    }
    return fFoundGroup;
}

/********************************************************************

        NDSGetProperty

Routine Description:

        Return the NDS property for the object

Arguments:
        Object   - name of object IN
        Property - property name  IN
        Data     - data buffer    OUT
        Size     - size of data buffer IN
        pActualSize - real data size OUT

Return Value:
        error

 *******************************************************************/
unsigned int
NDSGetProperty ( PBYTE Object,
                 PBYTE Property,
                 PBYTE Data,
                 unsigned int Size,
                 unsigned int * pActualSize )
{
    //
    // Status variables.
    //

    NTSTATUS Status = STATUS_SUCCESS;
    int ccode = -1;

    //
    // For NwNdsOpenTreeHandle.
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    WCHAR NdsStr[1024];

    //
    // For NwNdsResolveName.
    //

    DWORD dwOid;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;

    //
    // For NwNdsReadAttribute
    //
    PBYTE szBuffer;
    DWORD dwBufferSize = 2048;
    DWORD iterhandle = INITIAL_ITERATION;
    PNDS_RESPONSE_READ_ATTRIBUTE pReadAttribute;
    PNDS_ATTRIBUTE pAttribute;
    PBYTE pAttribValue;
    BOOL fContinue = TRUE;

    //
    // Allocate a buffer for the NDS request.
    //

    szBuffer = (PBYTE)malloc(dwBufferSize);

    if ( !szBuffer ) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        Status = STATUS_NO_MEMORY;
        return Status;
    }
    memset( szBuffer, 0, dwBufferSize );

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &NDSTREE_u, &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        DisplayMessage(IDR_TREE_OPEN_FAILED);
        return ccode;
    }

    //
    // Resolve the name that we have to an object id.
    //

    if ( !Object )
    {
        return 1;
    }

    oemStr.Length = (USHORT)strlen( Object );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Object;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return 0xffffffff;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // must jump to that server before continuing.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return 0xffffffff;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    //
    // Get the attribute
    //

    oemStr.Length = (USHORT)strlen( Property );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Property;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );



    while ( fContinue )
    {
        Status = NwNdsReadAttribute ( hRdr,
                                      dwOid,
                                      &iterhandle,
                                      &ObjectName,
                                      szBuffer,
                                      dwBufferSize );

        if ( NT_SUCCESS(Status) && iterhandle != INITIAL_ITERATION )
        {
            dwBufferSize *= 2;

            free( szBuffer );

            szBuffer = (PBYTE)malloc(dwBufferSize);

            if ( !szBuffer ) {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            memset( szBuffer, 0, dwBufferSize );
            iterhandle = INITIAL_ITERATION;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if ( !NT_SUCCESS(Status) )
    {
        NtClose( hRdr );
        free( szBuffer );

        return Status;
    }

    if ( NT_SUCCESS(Status) )
    {
        int i;
        pReadAttribute = (PNDS_RESPONSE_READ_ATTRIBUTE)szBuffer;
        pAttribute = (PNDS_ATTRIBUTE)(szBuffer
                      + sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

        pAttribValue = (PBYTE)(pAttribute->AttribName) +
                       ROUNDUP4(pAttribute->AttribNameLength) +
                       sizeof(DWORD);

        if ( pActualSize )
        {
            *pActualSize = *(DWORD *)pAttribValue;
        }

        memcpy( Data, pAttribValue + sizeof(DWORD),
                min(*(DWORD *)pAttribValue, Size) );

    }

    NtClose( hRdr );

    return Status;
}


/********************************************************************

        NDSCleanup

Routine Description:

        Does any NDS cleanup

Arguments:
        none

Return Value:
        none

 *******************************************************************/
void
NDSCleanup ( void )
{
    NtClose( GhRdr );
    if( GhRdr != GhRdrForUser ) {
        NtClose( GhRdrForUser );
    }
}

/********************************************************************

        NDSGetClassName

Routine Description:

        return a class name for an object

Arguments:
        szObjectName
        ClassName

Return Value:
        none

 *******************************************************************/
unsigned int
NDSGetClassName( LPSTR szObjectName, LPSTR ClassName )
{
    NTSTATUS Status;
    int ccode = -1;
    DWORD ThisObjectID;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    BYTE Buffer[2048];
    BYTE FullName[NDS_NAME_CHARS];
    PBYTE ptr;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;
    DWORD Length;

    //
    // Resolve the name that we have to an object id.
    //

    oemStr.Length = (USHORT)strlen( szObjectName );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = szObjectName;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(Buffer);
    ObjectName.Buffer = (WCHAR *)Buffer;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &ObjectName,
                                &ThisObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return Status;
        }

        if( GhRdr != GhRdrForUser ) {
            CloseHandle( GhRdr );
        }
        GhRdr = hReferredServer;
    }

    Status = NwNdsReadObjectInfo( GhRdr, ThisObjectID, Buffer, 2048 );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ptr = Buffer + sizeof( NDS_RESPONSE_GET_OBJECT_INFO ) + sizeof( DWORD );

    RtlInitUnicodeString( &ObjectName, (PWCHAR)ptr );

    oemStr.Length = 0;
    oemStr.MaximumLength = NDS_NAME_CHARS;
    oemStr.Buffer = ClassName;

    RtlUnicodeStringToOemString( &oemStr, &ObjectName, FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\nt.c ===
/*************************************************************************
*
*  NT.C
*
*  NT NetWare routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NT.C  $
*  
*     Rev 1.4   22 Dec 1995 14:25:12   terryt
*  Add Microsoft headers
*  
*     Rev 1.3   28 Nov 1995 17:13:28   terryt
*  Cleanup resource file
*  
*     Rev 1.2   22 Nov 1995 15:43:44   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 16:10:00   terryt
*  Close open NDS handles
*  
*     Rev 1.0   15 Nov 1995 18:07:18   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:23:02   terryt
*  Capture support
*  
*     Rev 1.1   23 May 1995 19:37:02   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:40   terryt
*  Initial revision.
*  
*************************************************************************/
#include <common.h>

#include <nwapi.h>
#include <npapi.h>

#include "ntnw.h"
/*
 * Name of NetWare provider
 */
TCHAR NW_PROVIDER[60];
unsigned char NW_PROVIDERA[60];

/********************************************************************

        NTPrintExtendedError

Routine Description:

        Print any extended errors from WNet routines

Arguments:
        None

Return Value:
        None

 *******************************************************************/
void
NTPrintExtendedError( void )
{
    DWORD ExError;
    wchar_t provider[32];
    wchar_t description[1024];

    if ( !WNetGetLastErrorW( &ExError, description, 1024, provider, 32 ) )
        wprintf(L"%s\n", description);
}


/********************************************************************

        NTInitProvider

Routine Description:

        Retrieve provider name and save old paths

Arguments:
        None

Return Value:
        None

 *******************************************************************/
void
NTInitProvider( void )
{
    HKEY hKey;
    DWORD dwType, dwSize;
    LONG Status;
    BOOL ret = FALSE;

    dwSize = sizeof(NW_PROVIDER);
    if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_PROVIDER, 0, KEY_READ, &hKey)) == ERROR_SUCCESS) {
        (void) RegQueryValueEx(hKey, REGISTRY_PROVIDERNAME, NULL, &dwType, (LPBYTE) NW_PROVIDER, &dwSize);
        WideTosz( NW_PROVIDERA, NW_PROVIDER, sizeof(NW_PROVIDERA) );
        RegCloseKey(hKey);
    }

    GetOldPaths();
}

/********************************************************************

        DeleteDriveBase

Routine Description:

        Disconnect drive from network

Arguments:

        DriveNumber - number of drive 1-26

Return Value:
        0 - success
        else NetWare error

 *******************************************************************/
unsigned int
DeleteDriveBase( unsigned short DriveNumber)
{
    static char drivename[] = "A:";
    unsigned int dwRes;

    drivename[0] = 'A' + DriveNumber - 1;

    dwRes = WNetCancelConnection2A( drivename, 0, TRUE );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

    if ( dwRes == ERROR_EXTENDED_ERROR )
        NTPrintExtendedError();

    return dwRes;
}

/********************************************************************

        DetachFromFileServer

Routine Description:

        Break connection from a file server

Arguments:

        ConnectionId - Connection handle

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
DetachFromFileServer( unsigned int ConnectionId )
{
    return ( NWDetachFromFileServer( (NWCONN_HANDLE)ConnectionId ) );
}


/********************************************************************

        NTLoginToFileServer

Routine Description:

        Login to a file server given a user name and password.

        If a NULL password is passed in, the default password should
        be tried if no password failed.

Arguments:

        pszServerName - Server name
        pszUserName   - User name
        pszPassword   - Password

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
NTLoginToFileServer(
    char          *pszServerName,
    char          *pszUserName,
    char          *pszPassword
    )
{
    NETRESOURCEA       NetResource;
    DWORD              dwRes;

    //
    // validate parameters
    //
    if (!pszServerName || !pszUserName || !pszPassword) {
        DisplayMessage(IDR_ERROR_DURING, "NTLoginToFileServer");
        return 0xffffffff ;
    }

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = pszServerName;
    NetResource.lpComment    = NULL;
    // NetResource.lpProvider   = NW_PROVIDERA ;
    // Allow OS to select provider in case localized name doesn't map to OEM code page
    NetResource.lpProvider   = NULL;


    //
    // make the connection 
    //
    dwRes=WNetAddConnection2A ( &NetResource, 
                                pszPassword, 
                                pszUserName,
                                0 );
    if ( dwRes != NO_ERROR )
       dwRes = GetLastError();

    //
    // Try default password if no password was specified
    //
    // The error numbers aren't (or weren't) reliable (ERROR_INVALID_PASSWORD)
    //
    if ( ( dwRes != NO_ERROR ) && ( pszPassword[0] == '\0' ) ) {
        dwRes=WNetAddConnection2A ( &NetResource, 
                                    NULL, 
                                    pszUserName,
                                        0 );
        if ( dwRes != NO_ERROR )
           dwRes = GetLastError();
    }

    return( dwRes );
}

/********************************************************************

        GetFileServerName

Routine Description:

        Return the server name associated with the connection ID

Arguments:

        ConnectionId - Connection ID to a server
        pServerName  - Returned server name

Return Value:
        0 - success
        else NT error

 *******************************************************************/
unsigned int
GetFileServerName(
    unsigned int      ConnectionId,
    char *            pServerName
    )
{
    unsigned int Result;
    VERSION_INFO VerInfo;

    *pServerName = '\0';

    Result = NWGetFileServerVersionInfo( (NWCONN_HANDLE) ConnectionId,
                                         &VerInfo );
    if ( !Result )
    {
        strcpy( pServerName, VerInfo.szName );
    }

    return Result;
}

/********************************************************************

        SetDriveBase

Routine Description:

        Connect a drive to a NetWare volume

Arguments:

        DriveNumber      - number of drive 1-26
        ServerName       - server name
        DirHandle        - not used
        pDirPath         - Volume:\Path

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
SetDriveBase(
    unsigned short   DriveNumber,
    unsigned char   *ServerName,
    unsigned int     DirHandle,
    unsigned char   *pDirPath
    )
{
    unsigned int Result = 0;
    static char driveName[] = "A:" ;

    /*
     * DirHandle is never used
     */

    driveName[0]= 'A' + DriveNumber - 1;

    if ( ( ServerName[0] == '\0' ) && fNDS ) {

        /*
         * Assume its an NDS volume name, if that fails, then
         * try a default file server volume.
         */
        Result = NTSetDriveBase( driveName, NDSTREE, pDirPath );

        if ( !Result )
            return Result;

        Result = NTSetDriveBase( driveName, PREFERRED_SERVER, pDirPath );

        return Result;
    }

    Result = NTSetDriveBase( driveName, ServerName, pDirPath );

    return Result;
}


/********************************************************************

        NTSetDriveBase

Routine Description:

        Connect a local name to a NetWare volume and path

Arguments:

        pszLocalName   -  local name to connect
        pszServerName  -  name of file server
        pszDirPath     -  Volume:\Path

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
NTSetDriveBase( unsigned char * pszLocalName,
                unsigned char * pszServerName,
                unsigned char * pszDirPath )
{
    NETRESOURCEA       NetResource;
    DWORD              dwRes, dwSize;
    unsigned char * pszRemoteName = NULL; 
    char * p;

    //
    // validate parameters
    //
    if (!pszLocalName || !pszServerName || !pszDirPath) {
        DisplayMessage(IDR_ERROR_DURING, "NTSetDriveBase");
        return 0xffffffff ;
    }

    //
    // allocate memory for string
    //
    dwSize = strlen(pszDirPath) + strlen(pszServerName) + 5 ;
    if (!(pszRemoteName = (unsigned char *)LocalAlloc(
                                       LPTR, 
                                       dwSize)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        dwRes = 0xffffffff;
        goto ExitPoint ; 
    }

    //
    // The requester understands 
    // server\volume:dir
    // but not
    // server\volume:\dir
    //
    // So just convert it to UNC
    //

    strcpy( pszRemoteName, "\\\\" );
    strcat( pszRemoteName, pszServerName );
    strcat( pszRemoteName, "\\" );
    strcat( pszRemoteName, pszDirPath );

    p = strchr( pszRemoteName, ':' );
    if ( !p ) {
        DisplayMessage(IDR_NO_VOLUME);
        dwRes = 0xffffffff;
        goto ExitPoint ; 
    }
    *p++ = '\\';

    if ( *p == '\\' ) {
       /* Don't want a double backslash */
       *p = '\0';
       p = strchr( pszDirPath, ':' );
       p++;
       p++;
       strcat( pszRemoteName, p );
    }

    //
    // strip off trailing backslash
    //
    if (pszRemoteName[strlen(pszRemoteName)-1] == '\\')
        pszRemoteName[strlen(pszRemoteName)-1] = '\0';

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_DISK;
    NetResource.lpLocalName  = pszLocalName;
    NetResource.lpRemoteName = pszRemoteName;
    NetResource.lpComment    = NULL;
    // NetResource.lpProvider   = NW_PROVIDERA ;
    // Allow OS to select provider in case localized name doesn't map to OEM code page
    NetResource.lpProvider   = NULL;

    //
    // make the connection 
    //
    dwRes=WNetAddConnection2A ( &NetResource, NULL, NULL, 0 );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

ExitPoint: 

    if (pszRemoteName)
        (void) LocalFree((HLOCAL) pszRemoteName) ;

    return( dwRes );
}


/********************************************************************

        Is40Server

Routine Description:

        Returns TRUE if 4X server

Arguments:

        ConnectionHandle - Connection Handle

Return Value:
        TRUE = 4X server
        FALSE = pre-4X server

 *******************************************************************/
unsigned int
Is40Server(
    unsigned int       ConnectionHandle
    )
{
    NTSTATUS NtStatus ;
    VERSION_INFO VerInfo;
    unsigned int Version;

    NtStatus = NWGetFileServerVersionInfo( (NWCONN_HANDLE)ConnectionHandle,
                                            &VerInfo );

    if (!NT_SUCCESS(NtStatus)) 
       FALSE;

    Version = VerInfo.Version * 1000 + VerInfo.SubVersion * 10;

    if ( Version >= 4000 ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

/********************************************************************

        CleanupExit

Routine Description:

        Does any cleanup and exits

Arguments:

        ExitCode - exit code for exit()

Return Value:
        does not return

 *******************************************************************/
void 
CleanupExit ( int ExitCode )
{
    if ( fNDS )
       NDSCleanup();

    exit( ExitCode );
}

/********************************************************************

        NTGetNWUserName

Routine Description:

        Get NetWare user name

Arguments:

        TreeBuffer  IN - wide string for server or tree
	UserName    OUT - user name 
	Length      IN - length of user name

Return Value:
        error message

 *******************************************************************/
int
NTGetNWUserName( PWCHAR TreeBuffer, PWCHAR UserName, int Length ) 
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[64];
    UNICODE_STRING OpenName;
    UINT i;

    UNICODE_STRING NdsTree;

    //
    // Copy over the preamble.
    //

    OpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    RtlInitUnicodeString( &NdsTree, TreeBuffer );

    //
    // Copy the server or tree name.
    //

    for ( i = 0 ; i < ( NdsTree.Length / sizeof( WCHAR ) ) ; i++ ) {
        NameStr[i + PreambleLength] = NdsTree.Buffer[i];
    }

    OpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
		       ( PreambleLength * sizeof( WCHAR ) ));
    OpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
				NULL,
				NULL,
				&IoStatusBlock,
				FSCTL_NWR_GET_USERNAME,
				(PVOID) TreeBuffer,
				NdsTree.Length,
				(PVOID) UserName,
				Length );

   UserName[(USHORT)IoStatusBlock.Information/2] = 0;

   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\lsparse.c ===
/*
 * LSPARSE.C - NetWare Login Script processing routines for our Win32
 *             NetWare 3.x LOGIN clone.
 *
 * Based on code contained in NWPARSE.C, written by Xiao Ying Ding.
 *
 * Modified and re-written for Win32 by J. SOUZA, February 1994.
 *
 * Modified for NT by Terry Treder
 *
 * Copyright (C)1994 Microsoft Corporation.
 *
 */

#include <common.h>

/********************************************************************

        ConverNDSPathToNetWarePathA

Routine Description:

        Convert a NDS path to a Netware format path

Arguments:
        ndspath  - origninal NDS path
        objclass - type of NDS object, NULL if unknown
        nwpath   - Netware format path

Return Value:
        error

 *******************************************************************/
unsigned int
ConverNDSPathToNetWarePathA(char *ndspath, char *objclass, char *nwpath)
{
    CHAR    szDN[MAX_PATH];
    CHAR    szObjName[MAX_PATH];
    CHAR    cSave;
    CHAR    className[MAX_PATH];

    LPSTR   lpDelim = NULL;
    LPSTR   lpFilePath = "";
    LPSTR   lpszValue;
    LPSTR   path;
    LPSTR   volume;

    DWORD   dwRet;
    DWORD   length;
    UINT    NWStatus;
    char    bufAttribute[2048];

    // optimize for path beginning with drive letter
    // This assumes NDS volume and dir map names are at least 2 chars

    if (ndspath[1] == ':')
        return 1;    
    // strip ':' from path before this call
    if ( ( lpDelim = strchr(ndspath,':') ) != NULL
        || ((lpDelim = strchr(ndspath,'\\')) != NULL)) {
        cSave = *lpDelim;
        *lpDelim = '\0';
        lpFilePath = lpDelim+1;
    }

    if ( objclass == NULL ) {

        NWStatus = NDSCanonicalizeName( ndspath, szObjName, MAX_PATH, TRUE );

        if ( NWStatus != 0 ) {
#ifdef DEBUG
            printf("can't canonicalize [%s] (0x%x)\n",
                    ndspath, NWStatus );
#endif

            if (lpDelim) {
                *lpDelim = cSave;    
            }

            return 1;
        }


        NWStatus = NDSGetClassName( szObjName, className );

        if ( NWStatus != 0 ||
                    strcmp ( className, DSCL_SERVER    ) &&
                    strcmp ( className, DSCL_NCP_SERVER ) &&
                    strcmp ( className, DSCL_VOLUME ) &&
                    strcmp ( className, DSCL_QUEUE ) &&
                    strcmp ( className, DSCL_DIRECTORY_MAP )) {

#ifdef DEBUG
            printf("no path DSOBJ: %d (%s) (%s)\n",
                   NWStatus, szObjName, className );
#endif

            if (lpDelim) {
                *lpDelim = cSave;    
            }

            return 1;
        }

        objclass = className;
    }
    else
        strcpy ( szObjName, ndspath );

    if (lpDelim) {
        *lpDelim = cSave;    
    }

#ifdef DEBUG
    printf("ConvertNDSPath BEFORE [%s]\n", szObjName);
#endif

    //
    // Is f this is the server class object , we only need
    // to extract it's common name and put into netware format
    //
    if ((strcmp(objclass,DSCL_SERVER) == 0 ) ||
        (strcmp(objclass,DSCL_NCP_SERVER) == 0 )) {

        // Abbreaviate first to remove type qualifiers
        *szDN = '\0';
        if (0 != NDSAbbreviateName(FLAGS_LOCAL_CONTEXT,(LPSTR)szObjName,szDN)) {
            return 1;
        }

        lpDelim = strchr(szDN,'.');
        if (lpDelim) {
            *lpDelim = '\0';
        }

        strcpy(nwpath,szDN);

#ifdef DEBUG
        printf("Returning Netware path:%s\n",nwpath);
#endif

        return 0;

    } /* endif server class */

    //
    // If this is share class object ( volume or queue), we need
    // to find it's host server name and host resource name
    //
     if ((strcmp(objclass,DSCL_VOLUME) == 0 ) ||
        (strcmp(objclass,DSCL_QUEUE) == 0 )
        ) {

        //
        // Read host server name first. It comes back as distinguished
        // directory name, so we will need to extract server name from it
        //

        NWStatus = NDSGetProperty ( szObjName,
                                    DSAT_HOST_SERVER,
                                    bufAttribute,
                                    sizeof(bufAttribute),
                                    NULL );

        if (NWStatus != 0) {
#ifdef DEBUG
            printf("Get host server  failed. err=0x%x\n",NWStatus);
#endif
            return 1;
        }

        lpszValue = bufAttribute;
        ConvertUnicodeToAscii( lpszValue ); 

        //
        // Now copy server distinguished name into temporary buffer
        // and call ourselves to convert it to Netware
        //
        strcpy(szDN,lpszValue);

        dwRet  = ConverNDSPathToNetWarePathA(szDN, DSCL_SERVER, nwpath);
        if (dwRet) {
#ifdef DEBUG
            printf("Resolving server DN failed\n");
#endif
            //Break();
            return 1;
        }

        //
        // Get volume name itself
        //
        NWStatus = NDSGetProperty ( szObjName,
                                    DSAT_HOST_RESOURCE_NAME,
                                    bufAttribute,
                                    sizeof(bufAttribute),
                                    NULL );

        if (NWStatus != 0) {
#ifdef DEBUG
            printf("Get host resource name  failed. err=0x%x\n",NWStatus);
#endif
            return 1;
        }

        lpszValue = bufAttribute;
        ConvertUnicodeToAscii( lpszValue ); 

        //
        // Now we already have server name in the user buffer,
        // append share name to it
        strcat(nwpath,"/");
        strcat(nwpath,lpszValue);
        strcat(nwpath,":");
        strcat(nwpath, lpFilePath );

#ifdef DEBUG
        printf("Returning Netware path:%s\n",nwpath);
#endif

        return 0;

    }    /* endif Volume class */

    //
    // For directory maps we need to find host volume NDS name and
    // append relative directory path
    //
    if (strcmp(objclass,DSCL_DIRECTORY_MAP) == 0 ) {

        //
        // First get NDS name for host volume object
        //

        NWStatus = NDSGetProperty ( szObjName,
                                    DSAT_PATH,
                                    bufAttribute,
                                    sizeof(bufAttribute),
                                    NULL );

        if (NWStatus != 0) {
#ifdef DEBUG
            printf("Get path %s failed. err=0x%x\n", szObjName, NWStatus);
#endif
            return 1;
        }

        volume = bufAttribute;
        volume += sizeof(DWORD);
        volume += sizeof(DWORD);
        ConvertUnicodeToAscii( volume ); 

        // Path is next

        path = bufAttribute;
        path += sizeof(DWORD);
        length = ROUNDUP4(*(DWORD *)path);
        path += sizeof(DWORD);
        path += length;

        //
        // Check for 0 length paths
        //
        if ( *(DWORD *)path == 0 ) {
            path = "";
        }
        else {
            path += sizeof(DWORD);
            ConvertUnicodeToAscii( path ); 
        }

#ifdef DEBUG
        printf("path is %s\n",path);
#endif

        //
        // Now copy volume distinguished name into temporary buffer
        // and call ourselves to convert it to NetWare
        //
        strcpy(szDN,volume);

        dwRet  = ConverNDSPathToNetWarePathA(szDN, DSCL_VOLUME, nwpath);
        if (dwRet) {
#ifdef DEBUG
            printf("Resolving volume DN failed\n");
#endif
            //Break();
            return 1;
        }

        //
        // Now we already have NetWare server\volume name in the user buffer,
        // append directory path to it
        //strcat(nwpath,"\\");
        // we want only one '\'
        if (path[0] == '\\' || path[0] == '/') path++;
        strcat(nwpath,path);
        // append non-NDS part of path, if any
        if (*lpFilePath) {
            strcat(nwpath,"/");
            strcat(nwpath, lpFilePath );
        }

#ifdef DEBUG
        printf("Returning NetWare path:%s\n",nwpath);
#endif

        return 0;

    } /* endif DirectoryMap class */

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\ntcap.c ===
/*************************************************************************
*
*  NTCAP.C
*
*  NT NetWare routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NTCAP.C  $
*  
*     Rev 1.2   10 Apr 1996 14:23:04   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:54:36   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:25:20   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:20   terryt
*  Initial revision.
*  
*     Rev 1.0   25 Aug 1995 15:41:14   terryt
*  Initial revision.
*  
*  
*************************************************************************/

#include "common.h"
#include <ntddnwfs.h>
#include <nwapi.h>
#include <npapi.h>
#include "ntnw.h"

extern unsigned char NW_PROVIDERA[];

/********************************************************************

        EndCapture

Routine Description:

        Remove the local printer redirection

Arguments:
        LPTDevice - IN
            1, 2, or 3 - the local printer #

Return Value:
        Error 

 *******************************************************************/
unsigned int
EndCapture(
    unsigned char LPTDevice
    )
{
    char LPTname[] = "LPT1";
    unsigned int dwRes;

    LPTname[3] = '1' + LPTDevice - 1;

    /*
     * Should we check for non-NetWare printers?
     */

    dwRes = WNetCancelConnection2A( LPTname, 0, TRUE );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

    if ( dwRes == ERROR_EXTENDED_ERROR )
        NTPrintExtendedError();

    return dwRes;
}


/********************************************************************

        GetCaptureFlags

Routine Description:

    Return info about the printer capture status.  Note that the only
    options set on NT are on a per-user basis and can be changed with
    the control panel.

Arguments:
    LPTDevice - IN
        LPT device 1, 2 or 3
    pCaptureFlagsRW - OUT
        Capture options
    pCaptureFlagsRO - OUT
        Capture options

Return Value:

 *******************************************************************/
unsigned int
GetCaptureFlags(
    unsigned char        LPTDevice,
    PNETWARE_CAPTURE_FLAGS_RW pCaptureFlagsRW,
    PNETWARE_CAPTURE_FLAGS_RO pCaptureFlagsRO
    )
{
    LPBYTE       Buffer ; 
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    DWORD        Count ;
    char         LPTName[10];
    DWORD        BufferSize = 4096;
    char        *remotename;
    char        *p;
    DWORD        dwPrintOptions ;
    LPTSTR       pszPreferred ;

    strcpy( LPTName, "LPT1" );

    LPTName[3] = '1' + LPTDevice - 1;

    pCaptureFlagsRO->LPTCaptureFlag = 0;

    //
    // allocate memory and open the enumeration
    //
    if (!(Buffer = LocalAlloc( LPTR, BufferSize ))) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return 0xFFFF;
    }

    dwErr = WNetOpenEnum(RESOURCE_CONNECTED, 0, 0, NULL, &EnumHandle) ;
    if (dwErr != WN_SUCCESS) {
        dwErr = GetLastError();
        if ( dwErr == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
        (void) LocalFree((HLOCAL) Buffer) ;
        return 0xFFFF;
    }

    do {

        Count = 0xFFFFFFFF ;
        BufferSize = 4096;
        dwErr = WNetEnumResourceA(EnumHandle, &Count, Buffer, &BufferSize) ;

        if ((dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
            && ( Count != 0xFFFFFFFF) )
        {
            LPNETRESOURCEA lpNetResource ;
            DWORD i ;

            lpNetResource = (LPNETRESOURCEA) Buffer ;

            //
            // search for our printer
            //
            for ( i = 0; i < Count; lpNetResource++, i++ )
            {
                if ( lpNetResource->lpLocalName )
                {
                    if ( !_strcmpi(lpNetResource->lpLocalName, LPTName ))
                    {
                        if ( lpNetResource->lpProvider )
                        {
                            if ( _strcmpi( lpNetResource->lpProvider,
                                            NW_PROVIDERA ) )
                            {

                                pCaptureFlagsRO->LPTCaptureFlag = 0;
                            }
                              else
                            {
                                remotename = lpNetResource->lpRemoteName;
                                p = strchr (remotename + 2, '\\');
                                if ( !p ) 
                                    return 0xffffffff;
                                *p++ = '\0';
                                _strupr( remotename+2 );
                                _strupr( p );
                                strcpy( pCaptureFlagsRO->ServerName, remotename+2 );
                                strcpy( pCaptureFlagsRO->QueueName, p );
                                pCaptureFlagsRO->LPTCaptureFlag = 1;

                                pCaptureFlagsRW->JobControlFlags = 0;
                                pCaptureFlagsRW->TabSize = 8;
                                pCaptureFlagsRW->NumCopies = 1;
                                //
                                // query NW wksta for print options
                                //   & preferred server
                                //
                                if ( NwQueryInfo(&dwPrintOptions,
                                     &pszPreferred)) {
                                    pCaptureFlagsRW->PrintFlags =
                                        CAPTURE_FLAG_NOTIFY |
                                        CAPTURE_FLAG_PRINT_BANNER ;
                                }
                                else {
                                    pCaptureFlagsRW->PrintFlags = 0;
                                    if ( dwPrintOptions & NW_PRINT_PRINT_NOTIFY )
                                        pCaptureFlagsRW->PrintFlags |= 
                                            CAPTURE_FLAG_NOTIFY;
                                    if ( dwPrintOptions & NW_PRINT_SUPPRESS_FORMFEED)
                                        pCaptureFlagsRW->PrintFlags |= 
                                            CAPTURE_FLAG_NO_FORMFEED;
                                    if ( dwPrintOptions & NW_PRINT_PRINT_BANNER )
                                        pCaptureFlagsRW->PrintFlags |= 
                                            CAPTURE_FLAG_PRINT_BANNER;
                                }
                                pCaptureFlagsRW->FormName[0] = 0;
                                pCaptureFlagsRW->FormType = 0;
                                pCaptureFlagsRW->BannerText[0] = 0;
                                pCaptureFlagsRW->FlushCaptureTimeout = 0;
                                pCaptureFlagsRW->FlushCaptureOnClose = 1;
                             }
                        }
                         else
                        {
                            pCaptureFlagsRO->LPTCaptureFlag = 0;
                        }
 
                        (void) WNetCloseEnum(EnumHandle) ; 
                        (void) LocalFree((HLOCAL) Buffer) ;
                          return 0;
                    }
                }
            }
        }

    } while (dwErr == WN_SUCCESS) ;

    if ( ( dwErr != WN_SUCCESS ) && ( dwErr != WN_NO_MORE_ENTRIES ) )
    {
        dwErr = GetLastError();
        if ( dwErr == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
    }

    (void ) WNetCloseEnum(EnumHandle) ;
    (void) LocalFree((HLOCAL) Buffer) ;

    return 0;
}

/********************************************************************

        StartQueueCapture

Routine Description:

    Attach local name to the queue.


Arguments:
    ConnectionHandle - IN
       Handle to file server
    LPTDevice - IN
       LPT 1, 2 or 3
    pServerName - IN
       Server name
    pQueueName - IN
       Printer queue name

Return Value:

 *******************************************************************/
unsigned int
StartQueueCapture(
    unsigned int    ConnectionHandle,
    unsigned char   LPTDevice,
    unsigned char  *pServerName,
    unsigned char  *pQueueName
    )
{
    NETRESOURCEA       NetResource;
    DWORD              dwRes, dwSize;
    unsigned char * pszRemoteName = NULL; 
    unsigned char pszLocalName[10];
    char * p;

    //
    // validate parameters
    //
    if (!pServerName || !pQueueName || !LPTDevice) {
        DisplayMessage(IDR_ERROR_DURING, "StartQueueCapture");
        return 0xffffffff ;
    }

    //
    // allocate memory for string
    //
    dwSize = strlen(pServerName) + strlen(pQueueName) + 5 ;
    if (!(pszRemoteName = (unsigned char *)LocalAlloc(
                                       LPTR, 
                                       dwSize)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        dwRes = 0xffffffff;
        goto ExitPoint ; 
    }

    sprintf(pszRemoteName, "\\\\%s\\%s", pServerName, pQueueName);
    sprintf(pszLocalName, "LPT%d", LPTDevice );

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_PRINT;
    NetResource.lpLocalName  = pszLocalName;
    NetResource.lpRemoteName = pszRemoteName;
    NetResource.lpComment    = NULL;
    // NetResource.lpProvider   = NW_PROVIDERA ;
    // Allow OS to select provider in case localized name doesn't map to OEM code page
    NetResource.lpProvider   = NULL; 

    //
    // make the connection 
    //
    dwRes=WNetAddConnection2A ( &NetResource, NULL, NULL, 0 );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

ExitPoint: 

    if (pszRemoteName)
        (void) LocalFree((HLOCAL) pszRemoteName) ;

    return( dwRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\nwapi2.c ===
/*************************************************************************
*
*  NWAPI2.C
*
*  NetWare routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWAPI2.C  $
*  
*     Rev 1.1   22 Dec 1995 14:25:54   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:34   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:50   terryt
*  Initial revision.
*  
*************************************************************************/

#include <direct.h>
#include "common.h"

/*
    Set the current drive to the login directory
    of the default server.
 */
void SetLoginDirectory( PBYTE serverName )
{
    unsigned int        iRet = 0;
    WORD           firstDrive;

    if(iRet = GetFirstDrive (&firstDrive))
    {
        DisplayError(iRet,"GetFirstDrive");
        return;
    }

    // Nothing we can do if SetDriveBase failed.
    // Don't report the error.

    if ( !( SetDriveBase (firstDrive, serverName, 0, "SYS:LOGIN") ) )
    {
        _chdrive (firstDrive);
        ExportCurrentDrive( firstDrive );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\parspath.c ===
/*************************************************************************
*
*  PARSPATH.C
*
*  NetWare parsing routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\PARSPATH.C  $
*  
*     Rev 1.3   22 Jan 1996 16:48:38   terryt
*  Add automatic attach query during map
*  
*     Rev 1.2   22 Dec 1995 14:26:16   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   22 Dec 1995 11:08:50   terryt
*  Fixes
*  
*     Rev 1.0   15 Nov 1995 18:07:48   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:23:34   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:11:00   terryt
*  Initial revision.
*  
*************************************************************************/

/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\parspath.c

Abstract:

    Directory APIs.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

--*/
#include "common.h"
#include <ctype.h>
#include <direct.h>
#include "inc\nwlibs.h"


/*++
*******************************************************************

        ParsePath

Routine Description:

        Parse the path string.

Arguments:

        pPath = The pointer to the path to parse.
        pServerName = The pointer to return the server name.
        pVolumeName = The pointer to return the volume name.
        pDirPath = The pointer to return the directory path.

Return Value:

        0x0000      SUCCESSFUL
        0x000F      INVALID_DRIVE
        0x8800      Unknown error

*******************************************************************
--*/
unsigned int
ParsePath(
    unsigned char   *pPath,
    unsigned char   *pServerName,           //OPTIONAL
    unsigned char   *pVolumeName,           //OPTIONAL
    unsigned char   *pDirPath               //OPTIONAL
    )
{
    unsigned char     *p, *p2;
    unsigned int       Result;
    unsigned int       Remote;
    unsigned int       NcpError = 0;
    unsigned char      DriveNumber = (unsigned char)-1;
    unsigned char      CurrentPath[64];
    unsigned char      RootPath[NCP_MAX_PATH_LENGTH];
    unsigned char      ServerName[NCP_MAX_PATH_LENGTH];
    unsigned char     *pRootDir;
    unsigned char      NetWarePath[NCP_MAX_PATH_LENGTH];
    unsigned char      VolumeName[NCP_VOLUME_LENGTH];
    unsigned int       LocalDriveForce = FALSE;

    RootPath[0] = 0;
    VolumeName[0] = 0;
    ServerName[0] = 0;

    if ( pServerName )
       *pServerName = '\0';

    /** See if there is a volume on the path **/

    p = pPath;
    while (*p != ':' && *p) {
        p++;
    }

    if (*p == ':') {
        *p = 0;

        /**
            Check to see if this is a drive letter.  The volume must
            be 2 characters or more.
        **/

        if ((p - pPath) == 1) {

            /** Make sure it is a valid alpha char **/

            if (!isalpha((int) *pPath)) {
                return 0x000F;
            }

            *pPath = (unsigned char) toupper((int) *pPath);

            /** Make it a drive number **/

            DriveNumber = (unsigned char) (*pPath - 'A');
            GetDriveStatus ((unsigned short)(DriveNumber+1),
                            NETWARE_FORMAT_SERVER_VOLUME,
                            NULL,
                            NULL,
                            RootPath,
                            NULL,
                            NULL);
            pRootDir = strchr (RootPath, ':');
            if (pRootDir)
            {
                /*
                 * Setup the pServerName here
                 */

                 pRootDir[0] = '\0';
                 p2 = RootPath;
                 while (*p2)
                 {
                    if (*p2 == '\\' || *p2 == '/')
                    {
                        *p2++ = 0;
                        strcpy(ServerName, RootPath);
                        if (pServerName) {
                            strcpy(pServerName, RootPath);
                        }
                        break;
                    }
                    p2++;
                }
                strcpy (RootPath, pRootDir+1);
            }
            else
                RootPath[0] = 0;
        }
        else {

            DriveNumber = 0;
            LocalDriveForce = TRUE;

            /**
                If there is a server name, save the server name
                and set the error code to 0x880F but still parse
                the path.  This just means that there is no connection
                for this server.  Even if we do have one.
            **/

            p2 = pPath;
            while (*p2) {
                if (*p2 == '\\' || *p2 == '/') {
                    *p2++ = 0;

                    strcpy(ServerName, pPath);
                    if (pServerName) {
                        strcpy(pServerName, pPath);
                    }
                    pPath = p2;

                    NcpError = 0x880F;
                    break;
                }
                p2++;
            }

            if (NcpError == 0x880F) {
                /**
                    Do any attach processing.
                 **/

                NcpError = DoAttachProcessing( ServerName );

            }

            strcpy(VolumeName, pPath);
        }

        /** Get the directory **/

        p++;
        pPath = p;
    }

    /**
        If we did not get the drive letter of volume name
        from above, then get the current drive we are on.
    **/

    if (DriveNumber == (unsigned char) -1) {
        DriveNumber = (UCHAR) _getdrive();
    }

    /*
     * Use the PREFERRED_SERVER for 3X logins if no server name
     * was specified.  
     */
    if (pServerName && !fNDS && !pServerName[0] ) {
        strcpy( pServerName, PREFERRED_SERVER );
    }

    if (pVolumeName) {

        /**
            Check if the drive is remote, if so, then go get the path
            from the server.
        **/
        if ( LocalDriveForce ) {
            Result = 0;
            Remote = 0;
        }
        else {
            Result = IsDriveRemote(DriveNumber, &Remote);

        }

        if (NcpError != 0x880F && !VolumeName[0] && (Result || !Remote)) {
            pVolumeName[0] = (unsigned char) (DriveNumber + 'A');
            pVolumeName[1] = 0;
        }
        else {
            if (VolumeName[0]) {
                strcpy(pVolumeName, VolumeName);
            }
            else {
                Result = NTGetNWDrivePath( DriveNumber, NULL, NetWarePath );
                if (Result) {
                    return Result;
                }

                p = NetWarePath;
                while (*p != ':' && *p) {
                    p++;
                }

                if (*p == ':') {
                    *p = 0;
                }
                strcpy(pVolumeName, NetWarePath);
            }
        }
    }

    if (pDirPath) {

        memset(CurrentPath, 0, sizeof(CurrentPath));

        if (VolumeName[0]) {
            strcpy(pDirPath, pPath);
        }
        else {
            Result = NTGetCurrentDirectory(DriveNumber, CurrentPath);
            if (Result) {
                CurrentPath[0] = 0;
            }
            else  {
                /* 
                 * Skip the drive letter
                 */
                if ( CurrentPath[0] ) {
                    int i;
                    for ( i = 0; ;i++ ) {
                        CurrentPath[i] = CurrentPath[i+3];
                        if ( !CurrentPath[i] )
                            break;
                    }
                }
            }

            if (CurrentPath[0] == 0) {
                if ( (*pPath == '\\') || ( *pPath == '/' ) ) {
                    sprintf(pDirPath, "%s%s", RootPath, pPath);
                }
                else if ( !(*pPath) ) {
                    sprintf(pDirPath, "%s", RootPath);
                }
                else {
                    sprintf(pDirPath, "%s\\%s", RootPath, pPath);
                }
            }
            else {
                if (*pPath) {
                    if ( (*pPath == '\\') || ( *pPath == '/' ) ) {
                        strcpy (pDirPath, RootPath);
                        if (pPath[1]) {
                            strcat(pDirPath, pPath);
                        }
                    }
                    else {
                        sprintf(pDirPath, "%s\\%s\\%s", RootPath, CurrentPath, pPath);
                    }
                }
                else {
                    sprintf(pDirPath, "%s\\%s", RootPath, CurrentPath);
                }
            }
        }

        /** Convert the / in the path to \ **/
        for (p = pDirPath; ( p && ( *p != 0 ) ) ; p++)
        {
            if (*p == '/')
                *p = '\\';
        }
    }

    return NcpError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\nwapi1.c ===
/*************************************************************************
*
*  NWAPI1.C
*
*  NetWare routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWAPI1.C  $
*  
*     Rev 1.1   22 Dec 1995 14:25:48   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:32   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:48   terryt
*  Initial revision.
*  
*************************************************************************/
#include "common.h"

/*
    Get default connection handle.
    return TRUE if succeeded, FALSE otherwise.
 */
int CGetDefaultConnectionID ( unsigned int * pConn )
{
    unsigned int iRet = GetDefaultConnectionID(pConn);

    switch (iRet)
    {
    case 0:
        break;

    case 0x880f:
        DisplayMessage(IDR_NO_KNOWN_FILE_SERVER);
        break;
    default:
        DisplayMessage(IDR_NO_DEFAULT_CONNECTION);
        break;
    }

    return(iRet == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\nwapi3.c ===
/*************************************************************************
*
*  NWAPI3.C
*
*  NetWare routines ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWAPI3.C  $
*  
*     Rev 1.4   18 Apr 1996 16:52:14   terryt
*  Various enhancements
*  
*     Rev 1.3   10 Apr 1996 14:23:20   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.5   13 Mar 1996 18:49:28   terryt
*  Support directory maps
*  
*     Rev 1.4   12 Mar 1996 19:55:10   terryt
*  Relative NDS names and merge
*  
*     Rev 1.2   22 Dec 1995 14:26:02   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   22 Nov 1995 15:41:56   terryt
*  Fix MAP ROOT of search drives
*  
*     Rev 1.0   15 Nov 1995 18:07:38   terryt
*  Initial revision.
*  
*     Rev 1.3   25 Aug 1995 16:23:22   terryt
*  Capture support
*  
*     Rev 1.2   26 Jul 1995 16:02:08   terryt
*  Allow deletion of current drive
*  
*     Rev 1.1   23 Jun 1995 09:49:22   terryt
*  Add error message for mapping over MS network drive
*  
*     Rev 1.0   15 May 1995 19:10:54   terryt
*  Initial revision.
*  
*************************************************************************/

/*
Module Name:
        nwapi3.c

Abstract:
        can :
                - view current mapping
                - create/change a drive mapping
                - create/change a search drive mapping
                - map a drive to a fake root
                - map the next available drive

    SYNTAX (Command line)
        View current mapping.
                MAP [drive:]
        Create or change network drive mappings
                MAP path
                MAP drive:=[drive:|path]
                MAP [DEL[ete] | REM[ove]] drive:
        Create or change search dirve mappings
                MAP [INS[ert]] drive:=[drive:|path]
        Map a drive to a fake root directory
                MAP ROOT drive:=[drive:|path]
        Map the next available dirve
                MAP N[ext] [drive:|path]



Author : Thierry TABARD (thierryt)

Revision history :
        - 03/10/94      thierryt    started
        - 05/13/94      congpay     rewrote.
*/

#include <ctype.h>
#include <direct.h>
#include "common.h"

/* Local functions*/
int  IsDrive( char * input);
int  GetSearchNumber( char * input);
int  IsNetwareDrive (int driveNum);
int  IsLocalDrive (int driveNum);
int  IsNonNetwareNetworkDrive (int driveNum);
int  GetDriveFromSearchNumber (int searchNumber);

void DisplayDriveMapping(WORD drive);
void DisplaySearchDriveMapping(int searchNumber);

int  ParseMapPath(char * mapPath, char * volName, char * dirPath, char * serverName, int fMapErrorsOn, char *lpCommand);
int  MapDrive (int driveNum, int searchNum, char * mapPath, int bRoot, int bInsert, int fMapErrorsOn, char *lpCommand);
int  MapNonSearchDrive (int driveNum, char *mapPath, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand);
int  MapSearchDrive (int searchNum, int driveNum, char *mapPath, int bInsert, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand);
int  MapNextAvailableDrive (char *mapPath, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand);

void RemoveDriveFromPath(int searchNumber, int fMapErrorsOn);
int  RemoveDrive (WORD drive, int fMapDisplayOn, int fMapErrorsOn);
void RemoveSearchDrive (int searchNumber, int fMapDisplayOn, int fMapErrorsOn);
int  InsertSearchDrive(int searchNum, int driveNum, int bInsert, char * insertPath);

#define CM_MAP         0
#define CM_DEL         1
#define CM_NEXT        2
#define CM_HELP        3
#define MAX_INPUT_PATH_LEN 128

int fMapDisplayOn = TRUE;
int fMapErrorsOn = TRUE;
int SafeDisk = 2; 

int GetFlag (char *buffer, int *pfInsert, int *pfRoot, char **ppPath)
{
    int nFlag, nLen;
    char *lpSpace, *lpTemp;

    if (((*buffer == '/') || (*buffer == '-') || (*buffer == '\\')) &&
             (*(buffer+1) == '?'))
        return CM_HELP;

    lpSpace = strchr (buffer, ' ');

    nFlag = CM_MAP;   // A bug!

    if (lpSpace == NULL)
    {
        *ppPath = buffer;
        return CM_MAP;
    }

    nLen = (int)(lpSpace - buffer);
    lpSpace++;

    if (!strncmp(buffer, __DEL__, max (3, nLen)) ||
        !strncmp(buffer, __REM__, max (3, nLen)))
        nFlag = CM_DEL;
    else if (!strncmp(buffer, __NEXT__, nLen))
        nFlag = CM_NEXT;
    else if (!strncmp(buffer, __INS__, max (3, nLen)))
    {
        *pfInsert = TRUE;
        if (lpTemp = strchr (lpSpace, ' '))
        {
            nLen = (int)(lpTemp - lpSpace);
            if (!strncmp(lpSpace, __ROOT__, nLen))
            {
                *pfRoot = TRUE;
                lpSpace = lpTemp+1;
            }
        }
    }
    else if (!strncmp(buffer, __ROOT__, nLen))
    {
        *pfRoot = TRUE;
        if (lpTemp = strchr (lpSpace, ' '))
        {
            nLen = (int)(lpTemp - lpSpace);
            if (!strncmp(lpSpace, __INS__, max (3, nLen)))
            {
                *pfInsert = TRUE;
                lpSpace = lpTemp+1;
            }
        }
    }
    else
        lpSpace = buffer;

    *ppPath = lpSpace;

    return(nFlag);
}

int Map (char * buffer)
{
    WORD  status, driveNum;
    char *lpCommand, *inputPath, *lpEqual;
    int   fRoot, fInsert, fSpace, fCommandHandled;
    int   nFlag, searchNumber, iRet;

    // Fix for NWCS.
    // NWGetDriveStatus() always returns 1800 on first call for non-Network
    // drives on NWCS. So we call with c: first to pass the first call.
    GetDriveStatus (3,
                    NETWARE_FORMAT_SERVER_VOLUME,
                    &status,
                    NULL,
                    NULL,
                    NULL,
                    NULL);

    lpCommand =  strtok (buffer, ";");

    if (lpCommand == NULL)
    {
        DisplayMapping();
        return(0);
    }

    do
    {
        fRoot = FALSE;
        fInsert = FALSE;
        fSpace = FALSE;
        fCommandHandled = TRUE;

        // Make sure first and last char of the command are not spaces.
        if (*lpCommand == ' ')
            lpCommand++;

        if (*(lpCommand+strlen (lpCommand)-1) == ' ')
            *(lpCommand+strlen (lpCommand)-1) = 0;

        if (!strcmp (lpCommand, "DISPLAY ON"))
        {
            fMapDisplayOn = TRUE;
            continue;
        }
        else if (!strcmp (lpCommand, "DISPLAY OFF"))
        {
            fMapDisplayOn = FALSE;
            continue;
        }
        else if (!strcmp (lpCommand, "ERROR ON") || !strcmp (lpCommand, "ERRORS ON"))
        {
            fMapErrorsOn = TRUE;
            continue;
        }
        else if (!strcmp (lpCommand, "ERROR OFF") || !strcmp (lpCommand, "ERRORS OFF"))
        {
            fMapErrorsOn = FALSE;
            continue;
        }

        nFlag = GetFlag (lpCommand, &fInsert, &fRoot, &inputPath);

        /*
         *  The 4X login program is much more forgiving about spaces
         *  in the map command.  
         */
        {
            char *lpTemp;
            char *lpCur;
            int  inquote = FALSE;

            lpTemp = inputPath;
            lpCur = inputPath;

            /*
             * Compress blanks unless the string is quoted
             */
            while ( *lpTemp )
            {
                if ( *lpTemp == '\"' )
                {
                    if ( inquote )
                        inquote = FALSE;
                    else
                        inquote = TRUE;
                }
                else if ( !inquote &&
                         (( *lpTemp == ' ' ) ||
                          ( *lpTemp == '\t' )  ) )
                {
                }
                else
                {
                   *lpCur++ = *lpTemp;
                   
                   if (IsDBCSLeadByte(*lpTemp)) {
                       *lpCur++ = *(lpTemp+1);
                    }

                }
                lpTemp = NWAnsiNext(lpTemp);
            }
            *lpCur = '\0';
        }


        if (nFlag == CM_HELP && fMapErrorsOn)
            DisplayMessage(IDR_MAP_USAGE);
        else if (nFlag == CM_NEXT)
        {
            if (strchr (inputPath, '=') ||
                strchr (inputPath, ' ') ||
                strchr (inputPath, '\t'))
                fCommandHandled = FALSE;
            else
                iRet = MapNextAvailableDrive (inputPath, fMapDisplayOn, fMapErrorsOn, lpCommand);
        }
        else if (nFlag == CM_DEL)
        {
            if (driveNum = (WORD) IsDrive (inputPath))
                iRet = RemoveDrive (driveNum, fMapDisplayOn, fMapErrorsOn);
            else if (searchNumber = GetSearchNumber(inputPath))
                RemoveSearchDrive (searchNumber, fMapDisplayOn, fMapErrorsOn);
            else
                fCommandHandled = FALSE;
        }
        else //nFlag = CM_MAP
        {
            if (driveNum = (WORD) IsDrive (inputPath))
            {
                if (fInsert)
                    fCommandHandled = FALSE;
                else if (fRoot)
                    iRet = MapNonSearchDrive (0, inputPath, TRUE, fMapDisplayOn, fMapErrorsOn, lpCommand);
                else
                    DisplayDriveMapping(driveNum);
            }
            else if (searchNumber = GetSearchNumber (inputPath))
            {
                if (fInsert || fRoot)
                    fCommandHandled = FALSE;
                else
                    DisplaySearchDriveMapping(searchNumber);
            }
            else if ((lpEqual = strchr (inputPath, '=')) == NULL)
            {
                if (fInsert || strchr (inputPath, ' '))
                    fCommandHandled = FALSE;
                else
                {
                    /*
                     * We must cope with MAP K:DIR which means change the
                     * directory on K:
                     */
                    driveNum = 0;
                    if (isalpha(inputPath[0]) && (inputPath[1] == ':'))
                    {
                        driveNum = toupper(inputPath[0]) - 'A' + 1;
                        if ( !IsNetwareDrive(driveNum) )
                        {
                            driveNum = 0;
                        }
                    }
                    iRet = MapNonSearchDrive (driveNum, inputPath, fRoot, fMapDisplayOn, fMapErrorsOn, lpCommand);
                }
            }
            else
            {
                if ( ( !fNDS && strchr (lpEqual+2, ' ') )
                     || lpEqual == inputPath) {
                    fCommandHandled = FALSE;
                }
                else
                {
                    if (*AnsiPrev(inputPath, lpEqual) == ' ')
                    {
                        fSpace = TRUE;
                        *(lpEqual-1) = 0;
                    }
                    else
                        *lpEqual = 0;

                    if (*(lpEqual+1) == ' ')
                        lpEqual++;

                    driveNum = (WORD) IsDrive (inputPath);
                    searchNumber = GetSearchNumber (inputPath);
                    *(inputPath+strlen(inputPath)) = fSpace? ' ' : '=';

                    /*
                     * This is to handle the cases:
                     *
                     * map x:=s3:=sys:public
                     * map s3:=x:=sys:public
                     *
                     * Unfortuneatly the underlying parsing routines
                     * want everything null terminated, so we need
                     * to do the following shuffle.
                     *
                     */
                    if ( driveNum || searchNumber )
                    {
                        if ((strchr (lpEqual+1, '=')) != NULL)
                        {
                            char * lpEqual2;
                            char *tmpPath = _strdup( lpEqual+1 );

                            lpEqual2 = strchr (tmpPath, '=');

                            if (*AnsiPrev(tmpPath, lpEqual2) == ' ')
                            {
                                fSpace = TRUE;
                                *(lpEqual2-1) = 0;
                            }
                            else
                                *lpEqual2 = 0;

                            if (*(lpEqual2+1) == ' ')
                                lpEqual2++;

                            if ( searchNumber ) 
                            {
                                driveNum = (WORD) IsDrive (tmpPath);
                            }
                            else 
                            {
                                searchNumber = GetSearchNumber (tmpPath);
                            }

                            if ( driveNum && searchNumber ) 
                            {
                                lpEqual += (lpEqual2 - tmpPath) + 1;
                            }

                            free (tmpPath);

                        }
                    }

                    if (searchNumber)
                    {
                        iRet = MapSearchDrive (searchNumber, driveNum, lpEqual+1, fInsert, fRoot, fMapDisplayOn, fMapErrorsOn, lpCommand);
                    }
                    else if (driveNum)
                    {
                        if (fInsert)
                            fCommandHandled = FALSE;
                        else
                            iRet = MapNonSearchDrive (driveNum, lpEqual+1, fRoot, fMapDisplayOn, fMapErrorsOn, lpCommand);
                    }
                    else
                        fCommandHandled = FALSE;
                }
            }
        }

        if (!fCommandHandled && fMapErrorsOn)
        {
            DisplayMessage(IDR_MAP_INVALID_PATH, lpCommand);
        }
    }while ((lpCommand = strtok (NULL, ";")) != NULL);

    return(iRet & 0xFF);
}

/*  Return drive number if input is a drive specified as a letter followed
    by ':' for example if input is "A:", return 1
    or netware drive could be specified as *1: for example.
    Otherwise, return 0.
 */
int IsDrive( char * input)
{
    unsigned short driveNum = 0, n = 0;

    if (isalpha(input[0]) && (input[1] == ':') && (input[2] == 0))
        driveNum = toupper(input[0]) - 'A' + 1;
    else if (input[0] == '*' && isdigit (input[1]) && input[1] != '0')
    {
        if (isdigit (input[2]) && input[3] == ':' && input[4] == 0)
            n = (input[1]-'0')*10+(input[2]-'0');
        else if (input[2] == ':' && input[3] == 0)
            n = input[1]-'0';

        if (n)
        {
            GetFirstDrive (&driveNum);
            driveNum += (n-1);
            if (driveNum < 1 || driveNum > 26)
                driveNum = 0;
        }
    }

    return driveNum;
}

/*
    If the input is "Sn:", return n, where n > 0 && n <= 16.
    Otherwise return 0.
 */
int  GetSearchNumber( char * input)
{
    int searchNumber = 0;
    char *lpTemp;

    if (input[0] != 'S')
        return(0);

    lpTemp = input+1;
    while (*lpTemp && isalpha(*lpTemp))
        lpTemp++;

    if (strncmp (input, "SEARCH", (UINT)(lpTemp-input)))
        return(0);

    if ((lpTemp[0] > '0') &&
        (lpTemp[0] <= '9'))
    {
        if ((lpTemp[1] == ':') &&
            (lpTemp[2] == 0))
        {
            searchNumber = lpTemp[0] - '0';
        }
        else if ((lpTemp[0] == '1') &&
                 (lpTemp[1] >= '0') &&
                 (lpTemp[1] <= '6') &&
                 (lpTemp[2] == ':') &&
                 (lpTemp[3] == 0))
        {
            searchNumber = 10 + lpTemp[1] - '0';
        }
    }

    return(searchNumber);
}

/*
    Return TRUE if the drive is a NetWare drive.
    FALSE otherwise.
 */
int  IsNetwareDrive (int driveNum)
{
    unsigned int    iRet=0;
    WORD       status;

    if (iRet = GetDriveStatus ((unsigned short)driveNum,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL))
    {
        return FALSE;
    }

    return (status & NETWARE_NETWARE_DRIVE);
}

/*
    Return TRUE if the drive is a local drive.
    FALSE otherwise.
 */
int  IsLocalDrive (int driveNum)
{
    unsigned int    iRet=0;
    WORD       status;

    if (iRet = GetDriveStatus ((unsigned short)driveNum,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL))
    {
        return FALSE;
    }

    return ((status & NETWARE_LOCAL_DRIVE) && !(status & NETWARE_NETWORK_DRIVE));
}

/*
    Return TRUE if the drive is a network drive that is not netware
    FALSE otherwise.
 */
int  IsNonNetwareNetworkDrive (int driveNum)
{
    unsigned int    iRet=0;
    WORD       status;

    if (iRet = GetDriveStatus ((unsigned short)driveNum,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL))
    {
        return FALSE;
    }

    return ((status & NETWARE_NETWORK_DRIVE) && !(status & NETWARE_NETWARE_DRIVE));
}

/*
    Return the drive number of search drive n.
    Return 0 if search drive n does not exist.
 */
int  GetDriveFromSearchNumber (int searchNumber)
{
    char *path;
    int   i;

    path = getenv("PATH");
    if (path == NULL) {
        return 0;
    }

    for (i = 1; i < searchNumber; i++)
    {
        path =strchr (path, ';');

        if (path == NULL || *(path+1) == 0)
            return(0);

        path++;
    }

    return(toupper(*path) - 'A' + 1);
}

/*
    Display a specific drive's mapping.
 */
void DisplayDriveMapping(WORD drive)
{
    unsigned int    iRet = 0;
    WORD       status = 0;
    char       rootPath[MAX_PATH_LEN], relativePath[MAX_PATH_LEN];

    iRet = GetDriveStatus (drive,
                           NETWARE_FORMAT_SERVER_VOLUME,
                           &status,
                           NULL,
                           rootPath,
                           relativePath,
                           NULL);
    if (iRet)
    {
        DisplayError (iRet, "GetDriveStatus");
        return;
    }

    if (status & NETWARE_NETWARE_DRIVE)
        DisplayMessage(IDR_NETWARE_DRIVE, 'A'+drive-1, rootPath, relativePath);
    else if ((status & NETWARE_NETWORK_DRIVE) || (status & NETWARE_LOCAL_DRIVE))
        DisplayMessage(IDR_LOCAL_DRIVE, 'A'+drive-1);
    else
        DisplayMessage(IDR_UNDEFINED, 'A'+drive-1);
}

/*
    Display a specific search drive's mapping.
 */
void DisplaySearchDriveMapping(int searchNumber)
{
    unsigned int    iRet = 0;
    char  *p,  *searchPath;
    int        i;
    WORD       status;
    char       path[MAX_PATH_LEN], rootPath[MAX_PATH_LEN], relativePath[MAX_PATH_LEN];

    searchPath = NWGetPath();
    if (searchPath == NULL) {
        return;
    }

    for (i = 0; i < searchNumber-1; i++)
    {
        searchPath = strchr (searchPath, ';');
        if (searchPath != NULL)
            searchPath++;
        else
            return;
    }

    p = strchr (searchPath, ';');
    if (p != NULL)
    {
        i= (int)(p-searchPath);
        strncpy (path, searchPath, i);
        path[i] = 0;
    }
    else
        strcpy (path, searchPath);

    if (isalpha(*path) && *(path+1) == ':')
    {
        iRet = GetDriveStatus ((unsigned short)(toupper(*path)-'A'+1),
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               rootPath,
                               relativePath,
                               NULL);

        if (iRet)
        {
            DisplayError (iRet, "GetDriveStatus");
            return;
        }
        else
        {
            if (status & NETWARE_NETWARE_DRIVE)
                DisplayMessage(IDR_NETWARE_SEARCH, searchNumber, path, rootPath, relativePath);
            else
                DisplayMessage(IDR_LOCAL_SEARCH, searchNumber, path);
        }
    }
    else
        DisplayMessage(IDR_LOCAL_SEARCH, searchNumber, path);
}

/*
    Return TRUE if the mapPath is parsed, FALSE otherwise.
 */
int  ParseMapPath(char * mapPath, char * volName, char * dirPath, char * serverName, int fMapErrorsOn, char * lpCommand)
{
    unsigned int  iRet=0;
    char         *pColon, inputPath[MAX_PATH_LEN];
    int           drive, nDriveNum;

    // fix g:=:sys:\public case.
    if (*mapPath == ':')
        mapPath++;

    if (strlen (mapPath) > MAX_INPUT_PATH_LEN)
    {
        if (fMapErrorsOn)
            DisplayMessage(IDR_INVALID_PATH, mapPath);
        return FALSE;
    }

    // Get the drive or volume part if there is one.
    if (pColon = strchr (mapPath, ':'))
    {
        char *directory = pColon+1;
        int  searchNumber;

        // Assing drive: part to input.
        strncpy (inputPath, mapPath, (UINT)(directory-mapPath));
        inputPath[directory-mapPath] = 0;

        if (nDriveNum = IsDrive (inputPath))
        {
            if (*inputPath == '*')
            {
                *inputPath = 'A' + nDriveNum - 1;
                *(inputPath+1) = ':';
                *(inputPath+2) = 0;
            }
            else if (!IsNetwareDrive(nDriveNum))
            {
                if (fMapErrorsOn)
                    DisplayMessage(IDR_NOT_NETWORK_DRIVE);
                return(FALSE);
            }
        }
        else if (searchNumber = GetSearchNumber(inputPath))
        {
            int drive = GetDriveFromSearchNumber (searchNumber);

            if (!drive)
            {
                if (fMapErrorsOn)
                    DisplayMessage(IDR_SEARCH_DRIVE_NOT_EXIST, searchNumber);
                return FALSE;
            }

            if (!IsNetwareDrive(drive))
            {
                if (fMapErrorsOn)
                    DisplayMessage(IDR_NOT_NETWORK_DRIVE);
                return(FALSE);
            }

            inputPath[0] = 'A' + drive - 1;
            inputPath[1] = ':';
            inputPath[2] = 0;
        }

        strcat (inputPath, directory);
    }
    else
    {
        if ( fNDS )
        {
            CHAR fullname[MAX_PATH];
            if ( !NDSCanonicalizeName( mapPath, fullname, MAX_PATH, TRUE ) )
                if ( !ConverNDSPathToNetWarePathA( fullname, DSCL_DIRECTORY_MAP,
                     inputPath ) )
                    goto ParseThePath;
        }

        // If drive is not specified, the current drive is used.
        drive = _getdrive();
        if (!IsNetwareDrive(drive))
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_NOT_NETWORK_DRIVE);
            return(FALSE);
        }

        inputPath[0] = 'A'+drive-1;
        inputPath[1] = ':';
        inputPath[2] = 0;

        strcat (inputPath, mapPath);
    }

ParseThePath:

    iRet = ParsePath (inputPath,
                      serverName,
                      volName,
                      dirPath);
    if (iRet)
    {
        if (iRet == 0x880F)
        {
            DisplayMessage(IDR_MAP_NOT_ATTACHED_SERVER, lpCommand);
            return(FALSE);
        }
        else 
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_INVALID_PATH, inputPath);
            return(FALSE);
        }
    }

    return(TRUE);
}

/*
    Map drive to mapPath
 */
int  MapDrive (int drive, int searchNum, char * mapPath, int bRoot, int bInsert, int fMapErrorsOn, char *lpCommand)
{
    unsigned int  iRet=0;
    char          volName[MAX_VOLUME_LEN+1]; //+1 for append ':'.
    char          dirPath[MAX_DIR_PATH_LEN];
    int           currentDrive;
    int           OvermapDrive = -1;
    char          serverName[MAX_NAME_LEN];

    if (!ParseMapPath(mapPath, volName, dirPath, serverName, fMapErrorsOn, lpCommand))
        return(3);

    if (IsNetwareDrive(drive))
    {
        if ( drive == _getdrive() ) {
            OvermapDrive = drive;
            _chdrive (SafeDisk);
        }
        if (iRet = DeleteDriveBase ((unsigned short)drive))
        {
            if (fMapErrorsOn) { 
                /* Cannot delete the drive you are on */
                if (iRet == ERROR_DEVICE_IN_USE)
                    DisplayMessage(IDR_CAN_NOT_CHANGE_DRIVE);
                else
                    DisplayError (iRet, "DeleteDriveBase");
            }
            return iRet;
        }
    }
    else if ( IsNonNetwareNetworkDrive(drive) ) {
        if (fMapErrorsOn)
            DisplayMessage(IDR_NON_NETWARE_NETWORK_DRIVE, lpCommand);
        return 3;
    }

    if (bRoot)
    {
        // +2 is for strcat with ":".
        char *fullPath = malloc( MAX_VOLUME_LEN + strlen (dirPath) + 2);
        if (fullPath == NULL)
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
            return 8;
        }

        strcpy (fullPath, volName);
        strcat (fullPath, ":");
        strcat (fullPath, dirPath);

        iRet = SetDriveBase ((unsigned short)drive,
                             serverName,
                             0,
                             fullPath);

        // Relative names need to be expanded for the redirector

        if ( iRet && fNDS && ( volName[strlen(volName) - 1] == '.' ) )
        {
            char canonName[MAX_VOLUME_LEN+1];
            if ( !NDSCanonicalizeName( volName, canonName, MAX_VOLUME_LEN, TRUE ) ) 
            {
                strcpy (fullPath, canonName);
                strcat (fullPath, ":");
                strcat (fullPath, dirPath);

                iRet = SetDriveBase ((unsigned short)drive,
                                     serverName,
                                     0,
                                     fullPath);
            }
        }

        if (iRet == 0)
        {
            if (searchNum)
                searchNum = InsertSearchDrive(searchNum, drive, bInsert, NULL);

            currentDrive = _getdrive();
            _chdrive (drive);
            _chdir( "\\" );
            _chdrive (currentDrive);
               ExportCurrentDirectory( drive );

            if (fMapDisplayOn)
            {
                if (searchNum)
                    DisplaySearchDriveMapping (searchNum);
                else
                    DisplayDriveMapping((unsigned short)drive);
            }
        }
        else
        {
            if (fMapErrorsOn)
            {
                switch ( iRet )
                {
                case ERROR_DEVICE_IN_USE:
                    DisplayMessage(IDR_CAN_NOT_CHANGE_DRIVE);
                    break;
                case ERROR_BAD_NETPATH:
                case ERROR_BAD_NET_NAME:
                    DisplayMessage(IDR_VOLUME_NOT_EXIST, volName);
                    iRet = 3;
                    break;
                case ERROR_EXTENDED_ERROR:
                    NTPrintExtendedError();
                    iRet = 3;
                    break;
                default:
                    DisplayMessage(IDR_MAP_ERROR, iRet);
                    DisplayMessage(IDR_MAP_FAILED, lpCommand);
                    iRet = 3;
                    break;
                }
            }
        }

        free (fullPath);
    }
    else
    {
        // NETX requires to end the volName with ':'.
        strcat (volName, ":");

        iRet = SetDriveBase ((unsigned short)drive,
                             serverName,
                             0,
                             volName);

        // Relative names need to be expanded for the redirector

        if ( iRet && fNDS && ( volName[strlen(volName) - 2] == '.' ) )
        {
            char canonName[MAX_VOLUME_LEN+1];

            volName[strlen(volName)-1] = '\0';
            if ( !NDSCanonicalizeName( volName, canonName, MAX_VOLUME_LEN, TRUE ) ) 
            {
                strcat (canonName, ":");

                iRet = SetDriveBase ((unsigned short)drive,
                                     serverName,
                                     0,
                                     canonName);
            }
        }

        if (iRet)
        {
            if (fMapErrorsOn)
            {
                switch ( iRet )
                {
                case ERROR_DEVICE_IN_USE:
                    DisplayMessage(IDR_CAN_NOT_CHANGE_DRIVE);
                    break;
                case ERROR_EXTENDED_ERROR:
                    NTPrintExtendedError();
                    iRet = 3;
                    break;
                case ERROR_BAD_NETPATH:
                case ERROR_BAD_NET_NAME:
                default:
                    DisplayMessage(IDR_MAP_INVALID_PATH, lpCommand);
                    iRet = 3;
                    break;
                }
            }
        }
        else
        {
            // Succeed.

            if (searchNum)
                searchNum = InsertSearchDrive(searchNum, drive, bInsert, NULL);

            currentDrive = _getdrive();
            _chdrive (drive);
            if (!iRet && *dirPath)
            {
                iRet = _chdir( "\\" );
                if ( !iRet ) 
                    iRet = _chdir (dirPath);
                if ( iRet ) {
                    if (fMapErrorsOn)
                    {
                        DisplayMessage(IDR_MAP_INVALID_PATH, lpCommand);
                    }

                    iRet = 3;
                }

            }
            else
            {
                _chdir( "\\" );
            }
            _chdrive (currentDrive);
               ExportCurrentDirectory( drive );

            if (iRet == 0 && fMapDisplayOn)
            {
                if (searchNum)
                    DisplaySearchDriveMapping (searchNum);
                else
                    DisplayDriveMapping((unsigned short)drive);
            }

        }
    }

    if ( OvermapDrive != -1 )
        _chdrive (OvermapDrive);

    return(iRet);
}

/*
    Map drive secified by driveNum to mapPath.
    If bRoot is TRUE, use mapPath as the drive base.
 */
int MapNonSearchDrive (int driveNum, char *mapPath, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand)
{
    int driveLetter, iRet = 0;

    if ((driveNum == 0) && (!strchr(mapPath, ':') && !bRoot))
    {
        // map current drive to different directory.
        if (_chdir(mapPath) && fMapErrorsOn)
        {
            DisplayMessage(IDR_DIRECTORY_NOT_FOUND, mapPath);
            iRet = 3;
        }
        else {
            ExportCurrentDirectory( _getdrive() );
            if (fMapDisplayOn)
                DisplayDriveMapping((unsigned short)driveNum);
        }
        return(iRet);
    }
    else if ( (driveNum) && (isalpha(mapPath[0]) && (mapPath[1] == ':')))
    {
        int mapdriveNum = toupper(mapPath[0]) - 'A' + 1;

        if ( driveNum == mapdriveNum )
        {
            // map drive to different directory.
            // map k:=k:\dir

            WORD currentDrive; 
            currentDrive = (USHORT) _getdrive();
            _chdrive (driveNum);
            if (_chdir(mapPath) && fMapErrorsOn)
            {
                DisplayMessage(IDR_DIRECTORY_NOT_FOUND, mapPath);
                iRet = 3;
            }
            else
            {
                ExportCurrentDirectory( _getdrive() );
                if (fMapDisplayOn)
                    DisplayDriveMapping((unsigned short)driveNum);
            }
            _chdrive (currentDrive);
            return(iRet);
        }
    }

    if (driveNum == 0)
        driveNum = _getdrive();
    
    driveLetter = 'A' + driveNum -1;

    return MapDrive (driveNum, 0, mapPath, bRoot, 0, fMapErrorsOn, lpCommand);
}

/*
    Map the last free drive to mapPath and put it in the search path.
    If bInsert is TRUE, don't replace search drive n, otherwise,
    replace.
    If bRoot is TRUE, use mapPath as the drive base.
 */
int MapSearchDrive (int searchNum, int driveNum, char *mapPath, int bInsert, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand)
{
    unsigned int    iRet=0;
    int        i;
    WORD       status;
    char *     lpEqual;

    /*
     * Handle syntax map s2:=w:=volume:
     * Handle syntax map w:=s2:=volume:
     */
    if ( driveNum ) 
    {
        return MapDrive (driveNum, searchNum, mapPath, bRoot, bInsert, fMapErrorsOn, lpCommand);
    }

    // Check if mapPath is local path.
    if (mapPath[1] == ':' &&
        IsLocalDrive (toupper(mapPath[0])-'A'+1))
    {
        i = 0;  // a bug?
        searchNum = InsertSearchDrive(searchNum, i, bInsert, mapPath);
        if ((searchNum != 0) && fMapDisplayOn)
            DisplayMessage(IDR_LOCAL_SEARCH, searchNum, mapPath);
        return 0;
    }

    // Try to find the last available drive.
    for (i = 26; i >= 1; i--)
    {
        iRet = GetDriveStatus ((unsigned short)i,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        if (iRet)
            continue;

        if (!(status & NETWARE_LOCAL_DRIVE) &&
            !(status & NETWARE_NETWORK_DRIVE))
        {
            // Found. Map it to the path.
            return MapDrive (i, searchNum, mapPath, bRoot, bInsert, fMapErrorsOn, lpCommand);
        }
    }

    if (fMapErrorsOn)
        DisplayMessage (IDR_NO_DRIVE_AVAIL);
    return(0);
}

/*
    Map the next available drive to the mapPath.
 */
int MapNextAvailableDrive (char *mapPath, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand)
{
    unsigned int iRet = 0;
    int        i;
    WORD       status;

    // Find a free drive that is not mapped.
    // Then map it to the mapPath.
    for (i = 1; i <= 26; i++)
    {
        iRet = GetDriveStatus ((unsigned short)i,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        if (iRet)
        {
            if (fMapErrorsOn)
                DisplayError (iRet, "GetDriveStatus");
            return iRet;
        }

        if (!(status & NETWARE_LOCAL_DRIVE) &&
            !(status & NETWARE_NETWORK_DRIVE))
        {
            iRet = MapNonSearchDrive (i, mapPath, FALSE, fMapDisplayOn, fMapErrorsOn, lpCommand);
            return iRet;
        }
    }

    if (fMapErrorsOn)
        DisplayMessage(IDR_NO_DRIVE_AVAIL);

    return(0);
}

/*
    Remove a drive mapping.
 */
int RemoveDrive (WORD drive, int fMapDisplayOn, int fMapErrorsOn)
{
    unsigned int    iRet=0;
    int        searchNum;

    if (IsNetwareDrive (drive))
    {
        if (searchNum = IsSearchDrive(drive))
        {
            RemoveSearchDrive (searchNum, fMapDisplayOn, fMapErrorsOn);
        }
        else
        {
            /*
                 * Can't delete current drive on NT
             */
            if ( drive == _getdrive() ) {
                _chdrive (SafeDisk);
            }
            if (iRet = DeleteDriveBase (drive))
            {
                if (fMapErrorsOn)
                    DisplayError (iRet, "DeleteDriveBase");
            }
            else
            {
                if (fMapDisplayOn)
                    DisplayMessage(IDR_DEL_DRIVE, 'A'+drive-1);
            }
        }
    }
    else
    {
        if (fMapErrorsOn)
            DisplayMessage(IDR_WRONG_DRIVE, 'A'+drive-1);

        return(50); //error level.
    }

    return(0);
}

/*
    Remove a search drive.
 */
void RemoveSearchDrive (int searchNumber, int fMapDisplayOn, int fMapErrorsOn)
{
    WORD       drive;

    // Get the drive number.
    drive = (WORD) GetDriveFromSearchNumber (searchNumber);

    if (!drive)
    {
        if (fMapErrorsOn)
            DisplayMessage(IDR_SEARCH_DRIVE_NOT_EXIST, searchNumber);
        return;
    }

    // If the drive is a netware drive, remove the drive mapping.
    if (IsNetwareDrive (drive))
    {
        unsigned int    iRet=0;
        /*
         * Can't delete current drive on NT
         */
        if ( drive == _getdrive() ) {
            _chdrive (SafeDisk);
        }
        if (iRet = DeleteDriveBase (drive))
        {
            if (fMapErrorsOn)
                DisplayError (iRet, "DeleteDriveBase");
            return;
        }
    }

    RemoveDriveFromPath (searchNumber, fMapErrorsOn);

    if (fMapDisplayOn)
        DisplayMessage(IDR_DEL_SEARCH_DRIVE, 'A'+drive-1);

    // If the drive is not a local drive, remove all reference
    // to the drive in the path.
    if (!IsLocalDrive (drive))
    {
        while (searchNumber = IsSearchDrive (drive))
        {
            RemoveDriveFromPath (searchNumber, fMapErrorsOn);
        }
    }
}

/*
    Remove a search drive from the path.
 */
void RemoveDriveFromPath(int searchNumber, int fMapErrorsOn)
{
    char  *pOldPath,  *pNewPath,  *restEnvSeg,  *pPath, *Path;
    int        i, n;

    // Move pOldPath to where we want to put the new path string.
    pOldPath = NWGetPath();
    if (pOldPath == NULL) {
        return;
    }

    pPath = malloc( strlen(pOldPath) + 5 + 1 + 1 );
    if (pPath == NULL) {
        return;
    }
    strcpy(pPath, "PATH=");
    strcat(pPath, pOldPath);
    pOldPath = pPath + 5;

    for (i = 1; i < searchNumber; i++)
    {
        pOldPath=strchr (pOldPath, ';');

        if (pOldPath == NULL)
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_SEARCH_DRIVE_NOT_EXIST, searchNumber);
            free( pPath );
            return;
        }

        pOldPath++;
    }

    // Move pNewPath to the beginning of the path string that
    // needs to be moved.
    if (pNewPath = strchr (pOldPath, ';'))
        pNewPath++ ;
    else
        pNewPath = pOldPath + strlen (pOldPath);

    // Calculate the number of characters needs to be moved.
    n = strlen (pNewPath) + 1;
    restEnvSeg = pNewPath + n;

    n++;

    // Move the path string to overwrite the search drive.
    memmove (pOldPath, pNewPath, n);

    Path = malloc (strlen (pPath)+1);
    if (Path) {
        strcpy (Path, pPath);
        _putenv (Path);
    }
    ExportEnv( pPath );
    free( pPath );
}


/*
    If bInsert is TRUE, insert dirve specified by driveNum as search
    drive specified by searchNum. Otherwise replace search drive
    specified by searchNum with drive specified by driveNum.
 */
int InsertSearchDrive(int searchNum, int driveNum, int bInsert, char * insertPath)
{
    char  *pOldPath,  *pNewPath,  *restEnvSeg,  *pPath, *Path;
    int        i, n = 0, bSemiColon, nInsertChar;

    nInsertChar = (insertPath == NULL)? 3 : strlen (insertPath);

    // Check if memory block is large enough.
    if (!MemorySegmentLargeEnough (nInsertChar+1))
        return 0;

    // Move pNewPath to where we put the new drive.
    pNewPath = NWGetPath();

    //-- Multi user code merge. Citrix bug fixes ----
    // 8/14/96 cjc  Fix trap cause path is NULL.
    pPath = NULL;    //compiler error
    if (!pNewPath) {
       pPath = malloc(  5 + 1 + nInsertChar + 1 + 1 );
    }
    else {
       pPath = malloc( strlen(pNewPath) + 5 + 1 + nInsertChar + 1 + 1 );
    }
    if (pPath == NULL) {
        return 0;
    }
    strcpy(pPath, "PATH=");

    if (pNewPath) {
       strcat(pPath, pNewPath);
    }

    pNewPath = pPath + 5;

    for (i = 1; i < searchNum; i++)
    {
        if (strchr (pNewPath, ';'))
        {
            pNewPath = strchr (pNewPath, ';');
        }
        else
        {
            pNewPath += strlen (pNewPath);
            bInsert = TRUE;
            i++;
            break;
        }

        pNewPath++;
    }

    // Move pOldPath to the begining of the path string that needs
    // to be moved.
    if (bInsert)
        pOldPath = pNewPath;
    else
    {
        if ((pOldPath = strchr (pNewPath, ';')) == NULL)
            pOldPath = pNewPath + strlen (pNewPath);
        else
            pOldPath++;
    }

    // Figure out the number of characters that need to be moved.
    n = strlen (pOldPath) + 1;
    restEnvSeg = pOldPath + strlen (pOldPath) + 1;

    n++;

    // If we insert a new drive to the end of the path which ends with
    // a ';', or if we replace the last search drive, no ';' is needed.
    bSemiColon = bInsert ? (*(pNewPath-1) != ';' || *pOldPath != 0)
                         : (*pOldPath != 0);

    // Move the old path so that we will have space for the new search drive.
    memmove (pNewPath + (bSemiColon? nInsertChar+1:nInsertChar), pOldPath, n);

    if ((*pNewPath == 0)&& bSemiColon)
    {
        // Insert as the last one to the path.
        // Put ';' at the begining.
        *pNewPath = ';';
        if (insertPath == NULL)
        {
            *(pNewPath+1) = 'A' + driveNum - 1;
            *(pNewPath+2) = ':';
            *(pNewPath+3) = '.';
        }
        else
            memcpy (pNewPath+1, insertPath, nInsertChar);
    }
    else
    {
        if (insertPath == NULL)
        {
            *pNewPath = 'A' + driveNum - 1;
            *(pNewPath+1) = ':';
            *(pNewPath+2) = '.';
        }
        else
            memcpy (pNewPath, insertPath, nInsertChar);
        if (bSemiColon)
            *(pNewPath+nInsertChar) = ';';
    }

    Path = malloc (strlen (pPath)+1);
    if (Path) {
        strcpy (Path, pPath);
        _putenv (Path);
    }
    ExportEnv( pPath );
    free( pPath );

    return (i);
}

/*
 *  Used by SetEnv().
 *  Return the number of bytes of environment variable pointed by lpRest
 */
int GetRestEnvLen (char  *lpRest)
{
    int  nTotal = 1;
    nTotal += strlen (lpRest);

    return(nTotal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\nwscript.c ===
/*************************************************************************
*
*  NWSCRIPT.C
*
*  This module is the NetWare Logon Script utility.
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWSCRIPT.C  $
*  
*     Rev 1.3   22 Jan 1996 16:48:32   terryt
*  Add automatic attach query during map
*  
*     Rev 1.2   22 Dec 1995 14:26:08   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   20 Nov 1995 16:10:38   terryt
*  Close open NDS handles
*  
*     Rev 1.0   15 Nov 1995 18:07:42   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:37:18   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:58   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <locale.h>
#include <stdlib.h>
#include <time.h>
#include <direct.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <nwapi.h>

#include "nwscript.h"

int NTNetWareLoginScripts( int argc, char ** argv );

unsigned int fNDS = FALSE;

/*************************************************************************
*
*  main
*     Main function and entry point
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( int argc,
      char **argv )
{
    //
    // Call wksta to reset the sync login script flag if it did set it.
    // This flag is set and reset everytime so that if nw login scripts
    // are not used, user does not need wait.
    // Ignore any errors.
    //

    // Sets the locale to the default, which is the system-default 
    // ANSI  or DBCS code page obtained from the operating system.


    setlocale( LC_ALL, "" );

    (void) NwSetLogonScript(RESET_SYNC_LOGONSCRIPT) ;

    (void)NTNetWareLoginScripts( argc, argv );

    CleanupExit( 0 );

    return 0;

} /* main() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\ntnw.c ===
/*************************************************************************
*
*  NTNW.C
*
*  Dos NetWare to NT NetWare translation 
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NTNW.C  $
*  
*     Rev 1.1   22 Dec 1995 14:25:28   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:24   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:23:08   terryt
*  Capture support
*  
*     Rev 1.1   23 May 1995 19:37:10   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:44   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include "common.h"

extern int CONNECTION_ID;

/********************************************************************

        NTGetCurrentDirectory

Routine Description:

        Return the current directory.

Arguments:

        DriveNumber = The drive to get the directory from.
                        (0 = A, 1 = B, 2 = C, etc)
        pPath = A pointer to a 64 byte buffer to return the
                    current directory.

Return Value:

        0       Success
        else    Error

 ********************************************************************/

unsigned int
NTGetCurrentDirectory(
    unsigned char DriveNumber,
    unsigned char *pPath
    )
{
    char * CurPath;
    int currentDrive = _getdrive() ;

    //
    // Change to the drive and get its current working directory.
    // Default to root if fail to get cwd. DriveNumber is from 0.
    //

    _chdrive (DriveNumber+1);

    CurPath = _getcwd(NULL,MAX_PATH) ;

    if ( CurPath != NULL ) {
        
        strcpy( pPath, CurPath );
        free(CurPath) ;
    }
    else {

        strcpy( pPath, "A:\\" );
        pPath[0] += DriveNumber;
    }

    _chdrive (currentDrive);

    return 0;
}

/********************************************************************

        AttachToFileServer

Routine Description:

        Attach to a named file server

Arguments:

        pServerName      - Name of server
        pNewConnectionId - returned connection handle 

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
AttachToFileServer(
    unsigned char     *pServerName,
    unsigned int      *pNewConnectionId
    )
{
    unsigned int Result;

    if ( NTIsConnected( pServerName ) ) {
        return 0x8800;  // Already atached.
    }

    Result = NTAttachToFileServer( pServerName, pNewConnectionId );

    return Result;
}

/********************************************************************

        GetConnectionHandle

Routine Description:

        Given a server name, return the connection handle.
        The server should already be attached
        Note that this is not called for 4X servers.  It's used
        for attaches and bindery connections.

Arguments:

        pServerName       - Name of server
        pConnectionHandle - pointer to returned connection handle 

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
GetConnectionHandle(
    unsigned char *pServerName,
    unsigned int  *pConnectionHandle
    )
{
    unsigned int Result;

    if ( !NTIsConnected( pServerName ) ) {
        return 0xFFFF;  // not already connected
    }

    Result = NTAttachToFileServer( pServerName, pConnectionHandle );

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\ps40db.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    psndsdb.c

Abstract:

    Read the Print Configuration Attributes 

  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\PS40DB.C  $
*  
*     Rev 1.4   10 Apr 1996 14:23:28   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.4   12 Mar 1996 19:55:22   terryt
*  Relative NDS names and merge
*  
*     Rev 1.3   04 Jan 1996 18:57:36   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.2   22 Dec 1995 14:26:22   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   20 Nov 1995 15:09:46   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:07:52   terryt
*  Initial revision.

--*/
#include "common.h"

extern DWORD SwapLong(DWORD number);
extern char *TYPED_USER_NAME;

unsigned int
PS40GetJobName(
    unsigned int    NDSCaptureFlag,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    );

#include <pshpack1.h>
#define NWPS_JOB_NAME_SIZE          32    /* 31 bytes and a '\0' */ 
#define NWPS_FORM_NAME_SIZE         12    /* 12 bytes and a '\0' */ 
#define NWPS_BANNER_NAME_SIZE       12    /* 12 bytes and a '\0' */ 
#define NWPS_BANNER_FILE_SIZE       12    /* 12 bytes and a '\0' */ 
#define NWPS_DEVI_NAME_SIZE         32    /* 32 bytes and a '\0' */ 
#define NWPS_MODE_NAME_SIZE         32    /* 32 bytes and a '\0' */ 
#define NWPS_BIND_NAME_SIZE         48
#define NWPS_MAX_NAME_SIZE          514
/*
//   NWPS_Job_Old_Db_Hdr is the first record in the 4.0 PrnConDB database.
//   It contains the following information about the database:
//     The version number,
//     the number of NWPS_Job_Rec records in PrnConDB,
//     the name of the default print job configuration and
//     the name of the job record owner.
*/
typedef struct {
  char  text[ 76 ];             /* Printcon database. Version 4.0     */
  char  DefaultJobName[ 32 ];   /* Name of default Job                */
  char  Owner[ 256 ];           /* owner of the job record            */
  WORD  NumberOfRecords;        /* # of NWPS_Job_Rec's in PrnConDB    */
  WORD  NumberOfBlocks;         /* # of 50-(NWPS_Job_Name_Rec) blocks */
  BYTE  MajorVersion;           /* 4                                  */
  BYTE  MinorVersion;           /* 0                                  */
} PRINTCON_40_HEADER;

#define PRINTCON_40_HEADER_SIZE    sizeof(PRINTCON_40_HEADER)

/*
//   NWPS_Job_41_Db_Hdr is the first record in the 4.1 PrnConDB database.
//   It contains the following information about the database:
//     The version number,
//     the number of NWPS_Job_Rec records in PrnConDB,
//     the name of the default print job configuration and
//     the name of the job record owner IN UNICODE.
*/
typedef struct {
  char  text[ 76 ];              /* Printcon database. Version 4.1     */
  char  DefaultJobName[ 32 ];    /* Name of default Job                */
  char  unused[ 256 ];           /* no longer used.                    */
  WORD  NumberOfRecords;         /* # of NWPS_Job_Rec's in PrnConDB    */
  WORD  NumberOfBlocks;          /* # of 50-(NWPS_Job_Name_Rec) blocks */
  BYTE  MajorVersion;            /* 4                                  */
  BYTE  MinorVersion;            /* 1 unicode defaultPJOwner etc.      */
  WORD  Owner[ 256 ];            /* owner of the default job record    */
} PRINTCON_41_HEADER;

#define PRINTCON_41_HEADER_SIZE    sizeof(PRINTCON_41_HEADER)

/*
//   NWPS_Job_Name_Rec is the type of record found in the
//   second section of the PrnConDB database.  Each one of
//   these records contains the name of each NWPS_Job_Rec
//   and a pointer to their location in the third section of
//   the database.  There is space set aside in this second
//   section for fifty NWPS_Job_Name_Rec records; if this
//   limit is exceeded then another fifty-record block following
//   the first one is allocated after the third section of the
//   database is moved down to make room for the expansion.
*/
typedef struct {
  char  JobName[ NWPS_JOB_NAME_SIZE ]; /* 1 - 31 chars long + 0        */
  long  JobRecordOffset; /* Offset of the record
                         // (from the beginning 
                         // of the 3rd section for 4.0
                         // databases and from the start
                         // of the file for pre-4.0)                
                         */
} JOB_NAME_AREA;

#define JOB_NAME_AREA_SIZE       sizeof(JOB_NAME_AREA)

typedef struct {
  union {
      struct {
          DWORD DataType : 1;    /* 0=Byte stream 1 = Text */
          DWORD FormFeed : 1;    /* 0 = FF; 1 = suppress FF */
          DWORD NotifyWhenDone : 1; /* 0 = no, 1 = yes */
          DWORD BannerFlag : 1;    /* 0 = no, 1 = yes */
          DWORD AutoEndCap : 1;    /* 0 = no, 1 = yes */
          DWORD TimeOutFlag: 1;    /* 0 = no, 1 = yes */
          DWORD SystemType : 3;  /* 0 = bindery 1 = NDS  */
          DWORD Destination: 3;  /* 0 = queue 1 = printer */
          DWORD unknown : 20;
      }; 
      DWORD   PrintJobFlags;
  }; 
  
  WORD  NumberOfCopies; /* 1 - 65,000                             */
  WORD  TimeoutCount;   /* 1 - 1,000                              */
  BYTE  TabSize;        /* 1 - 18                                 */
  BYTE  LocalPrinter;   /* 0=Lpt1, 1=Lpt2, 2=Lpt3 etc.            */
  char  FormName[ NWPS_FORM_NAME_SIZE + 2 ];     /* 1-12 chars    */
  char  Name[ NWPS_BANNER_NAME_SIZE + 2 ];       /* 1-12 chars    */
  char  BannerName[ NWPS_BANNER_FILE_SIZE + 2 ]; /* 1-12 chars    */
  char  Device[ NWPS_DEVI_NAME_SIZE + 2 ];       /* 1-32 chars    */
  char  Mode[ NWPS_MODE_NAME_SIZE + 2 ];         /* 1-32 chars    */
  union {
      struct {
        /* pad structures on even boundries */
        char    Server[ NWPS_BIND_NAME_SIZE + 2 ];      /* 2-48 chars */
        char    QueueName[ NWPS_BIND_NAME_SIZE + 2 ];   /* 1-48 chars */
        char    PrintServer[ NWPS_BIND_NAME_SIZE + 2 ]; /* 1-48 chars */
      } NonDS;
      char    DSObjectName[ NWPS_MAX_NAME_SIZE ];   
  } u;
  BYTE  reserved[390];  /* Adds up to 1024 total (was 1026)       */
} JOB_RECORD_AREA;

#define JOB_RECORD_AREA_SIZE    sizeof(JOB_RECORD_AREA)


#include <poppack.h>



/*++
*******************************************************************

        PS40JobGetDefault

Routine Description:

        Get the default print job configuration from 40.

Arguments:
        NDSCaptureFlag
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PS40JobGetDefault(
    unsigned int    NDSCaptureFlag,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PS40GetJobName(
                    NDSCaptureFlag,
                    SearchFlag,
                    pOwner,
                    pJobName,
                    pJobRecord,
                    TRUE);
}


/*++
*******************************************************************

        PS40JobRead

Routine Description:

        Get the print job configuration from 40.

Arguments:

        NDSCaptureFlag =
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PS40JobRead(
    unsigned int    NDSCaptureFlag, 
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PS40GetJobName(
                NDSCaptureFlag,
                0,
                pOwner,
                pJobName,
                pJobRecord,
                FALSE);
}


/*++
*******************************************************************

        PS40GetJobName

Routine Description:

        Common routine to get the print job configuration from 40.

Arguments:
        NDSCaptureFlag =
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.
        GetDefault = TRUE = get the default job name, FALSE = Don't get
                      the default job name.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PS40GetJobName(
    unsigned int    NDSCaptureFlag, 
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    )
{
    unsigned char   *pSearchJobName;
    unsigned long   ObjectId;
    HANDLE          stream = NULL;
    unsigned int    Count;
    unsigned int    Bytes;
    unsigned int    RetCode = 0;
    unsigned int    ConnectionNumber;
    JOB_NAME_AREA   JobNameArea;
    JOB_RECORD_AREA JobRecord;
    PRINTCON_40_HEADER PrintConHeader;
    unsigned int    Version40 = FALSE;
    unsigned int ConnectionHandle;
    unsigned char   MailDirPath[NCP_MAX_PATH_LENGTH];
    unsigned char   TempJobName[33];
    PBYTE           JobContext = NULL;
    unsigned        FileSize;

    // TRACKING Printer names can be used instead of queues
    // Must lookup  "default print queue" if NT doesn't 

    if ( NDSCaptureFlag ) {

        if ( !GetDefault ) {
            JobContext = strchr( pJobName, ':' );
            if ( JobContext ) {
                *JobContext = '\0';
                strncpy( TempJobName, pJobName, 32 );
                TempJobName[32] = 0;
                *JobContext++ = ':';
                pJobName = TempJobName;
            }
        }

        if ( JobContext ) {
            if (NDSfopenStream ( JobContext, "Print Job Configuration", &stream, 
                 &FileSize )) {
                RetCode = PS_ERR_OPENING_DB;
                goto CommonExit;
            }
        }
        else {
            if (NDSfopenStream ( TYPED_USER_NAME, "Print Job Configuration",
                    &stream, &FileSize)) {
                PBYTE p;

                for ( p = TYPED_USER_NAME; p ; p = strchr ( p, '.' ) )
                {
                    p++;
                             
                    if ( *p == 'O' && *(p+1) == 'U' && *(p+2) == '=' )
                        break;

                    if ( *p == 'O' && *(p+1) == '=' )
                        break;
                }
                if (NDSfopenStream ( p, "Print Job Configuration", &stream,
                     &FileSize)) {
                    RetCode = PS_ERR_OPENING_DB;
                    goto CommonExit;
                }
            }
        }
    }
    else {

        if (!CGetDefaultConnectionID (&ConnectionHandle)) {
            RetCode = PS_ERR_OPENING_DB;
            goto CommonExit;
        }

        RetCode = GetConnectionNumber(ConnectionHandle, &ConnectionNumber);
        if (RetCode) {
            goto CommonExit;
        }

        RetCode = GetBinderyObjectID (ConnectionHandle, LOGIN_NAME,
                  OT_USER, &ObjectId);
        if (RetCode) {
            goto CommonExit;
        }

        /** Build the path to open the file **/

        sprintf(MailDirPath, "SYS:MAIL/%lX/PRINTJOB.DAT", SwapLong(ObjectId));
        stream = CreateFileA( NTNWtoUNCFormat( MailDirPath ),
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );
        if (stream == INVALID_HANDLE_VALUE) {

            sprintf(MailDirPath, "SYS:PUBLIC/PRINTJOB.DAT");

            stream = CreateFileA( NTNWtoUNCFormat(MailDirPath),
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

            if (stream == INVALID_HANDLE_VALUE) {
                RetCode = PS_ERR_OPENING_DB;
                goto CommonExit;
            }
        }
    }

    if ( !ReadFile( stream, (PBYTE) &PrintConHeader, PRINTCON_40_HEADER_SIZE, &Bytes, NULL ) ) {
        RetCode = PS_ERR_INTERNAL_ERROR;
        goto CommonExit;
    }

    if (Bytes < PRINTCON_40_HEADER_SIZE) {
        if ( !( NDSCaptureFlag && Bytes) ) {
            RetCode = PS_ERR_INTERNAL_ERROR;
            goto CommonExit;
        }
    }

    /** Check the version number **/

    if ( PrintConHeader.MajorVersion != 4 ) {
        RetCode = PS_ERR_BAD_VERSION;
        goto CommonExit;
    }

    if ( PrintConHeader.MinorVersion == 0 ) {
        Version40 = TRUE;
    }

    /** Get the name we are looking for **/

    if (GetDefault) {
        if (PrintConHeader.DefaultJobName[0] == 0) {
            RetCode = PS_ERR_GETTING_DEFAULT;
            goto CommonExit;
        }
        pSearchJobName = PrintConHeader.DefaultJobName;
    }
    else {
        pSearchJobName = pJobName;
    }

    if ( !Version40 ) {
        SetFilePointer( stream, PRINTCON_41_HEADER_SIZE, NULL, FILE_BEGIN );
    }

    Count = 0;

    /** Go through all of the job entry to look for the name **/

    while (Count < PrintConHeader.NumberOfRecords) {
        if ( !ReadFile( stream, (PBYTE) &JobNameArea, JOB_NAME_AREA_SIZE, &Bytes, NULL) ) {
            RetCode = PS_ERR_INTERNAL_ERROR;
            goto CommonExit;
        }

        if (Bytes < JOB_NAME_AREA_SIZE) {
            if ( !( NDSCaptureFlag && Bytes) ) {
                RetCode = PS_ERR_INTERNAL_ERROR;
                goto CommonExit;
            }
        }
        Count++;


        /** Skip the entry with a null job name **/

        if (JobNameArea.JobName[0] == 0) {
            continue;
        }
    
        /** Is this the job name we are looking for? **/

        if (!_strcmpi(pSearchJobName, JobNameArea.JobName)) {
            break;
        }
    }

    /** See if we found the job name **/

    if (Count > PrintConHeader.NumberOfRecords) {
        if (GetDefault) {
            RetCode = PS_ERR_GETTING_DEFAULT;
        }
        else {
            RetCode = PS_ERR_READING_RECORD;
        }
        goto CommonExit;
    }

    /*
     * The Job offset starts at the beginning of the third section.
     * The third section starts after the Header and after the
     * 50 record blocks.
     */
    if ( Version40 ) {
        SetFilePointer( stream,
            PRINTCON_40_HEADER_SIZE +
            ( PrintConHeader.NumberOfBlocks * 50) * JOB_NAME_AREA_SIZE +
            JobNameArea.JobRecordOffset,
            NULL,
            FILE_BEGIN );
    }
    else {
        SetFilePointer( stream,
            PRINTCON_41_HEADER_SIZE +
            ( PrintConHeader.NumberOfBlocks * 50) * JOB_NAME_AREA_SIZE +
            JobNameArea.JobRecordOffset,
            NULL,
            FILE_BEGIN );
    }

    memset((PBYTE)&JobRecord, 0, sizeof(JobRecord));

    if ( !ReadFile( stream, (PBYTE) &JobRecord, JOB_RECORD_AREA_SIZE, &Bytes, NULL) ) {
        RetCode = PS_ERR_READING_RECORD;
        goto CommonExit;
    }

    if (Bytes < JOB_RECORD_AREA_SIZE) {
        if ( !( NDSCaptureFlag && Bytes) ) {
            RetCode = PS_ERR_READING_RECORD;
            goto CommonExit;
        }
    }

    memset(pJobRecord, 0, PS_JOB_RECORD_SIZE);

    if (JobRecord.NotifyWhenDone) {
        pJobRecord->PrintJobFlag |= PS_JOB_NOTIFY;
    }
    if (JobRecord.BannerFlag) {
        pJobRecord->PrintJobFlag |= PS_JOB_PRINT_BANNER;
    }
    if (JobRecord.DataType) {
        pJobRecord->PrintJobFlag |= PS_JOB_EXPAND_TABS;
    }
    if (JobRecord.FormFeed) {
        pJobRecord->PrintJobFlag |= PS_JOB_NO_FORMFEED;
    }
    if (JobRecord.AutoEndCap) {
        pJobRecord->PrintJobFlag |= PS_JOB_AUTO_END;
    }
    if (JobRecord.TimeoutCount) {
        pJobRecord->PrintJobFlag |= PS_JOB_TIMEOUT;
    }
    if (JobRecord.Destination) {
        pJobRecord->PrintJobFlag |= PS_JOB_DS_PRINTER;
    }
    if ( JobRecord.SystemType ) {
        pJobRecord->PrintJobFlag |= PS_JOB_ENV_DS;
    }

    pJobRecord->Copies                    = JobRecord.NumberOfCopies;
    pJobRecord->TabSize                   = JobRecord.TabSize;
    pJobRecord->TimeOutCount              = JobRecord.TimeoutCount;
    pJobRecord->LocalPrinter              = JobRecord.LocalPrinter;

    strcpy(pJobRecord->Mode,                JobRecord.Mode);
    strcpy(pJobRecord->Device,              JobRecord.Device);
    strcpy(pJobRecord->FormName,            JobRecord.FormName);
    strcpy(pJobRecord->BannerName,          JobRecord.BannerName);

    if ( JobRecord.SystemType ) {
        ConvertUnicodeToAscii( JobRecord.u.DSObjectName ); 
        strcpy(pJobRecord->u.DSObjectName,  JobRecord.u.DSObjectName);
    }
    else {
        strcpy(pJobRecord->u.NonDS.PrintQueue,  JobRecord.u.NonDS.QueueName);
        strcpy(pJobRecord->u.NonDS.FileServer,  JobRecord.u.NonDS.Server);
    }

    if (GetDefault && pJobName) {
        strcpy(pJobName, JobNameArea.JobName);
    }

    if (pOwner) {
        *pOwner = 0;
    }

CommonExit:
    if (stream != NULL) {
        
	// 07/19/96 cjc (Citrix code merge) 
	//              fclose causes a trap cause it expects *stream but 
	//              really should be using CloseHandle anyway.
        CloseHandle( stream );
//        if ( NDSCaptureFlag ) 
//            CloseHandle( stream );
//        else
//            fclose( stream );
    }

    return RetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\ntscript.c ===
/*************************************************************************
*
*  NTSCRIPT.C
*
*  Process all login scripts
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NTSCRIPT.C  $
*  
*     Rev 1.8   10 Apr 1996 14:23:12   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.9   12 Mar 1996 19:54:58   terryt
*  Relative NDS names and merge
*  
*     Rev 1.8   07 Mar 1996 18:36:56   terryt
*  Misc fixes
*  
*     Rev 1.7   22 Jan 1996 16:48:26   terryt
*  Add automatic attach query during map
*  
*     Rev 1.6   08 Jan 1996 13:57:58   terryt
*  Correct NDS Preferred Server
*  
*     Rev 1.5   05 Jan 1996 17:18:26   terryt
*  Ensure context is the correct login default
*  
*     Rev 1.4   04 Jan 1996 18:56:48   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.3   22 Dec 1995 11:08:16   terryt
*  Fixes
*  
*     Rev 1.2   22 Nov 1995 15:43:52   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 15:09:38   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:07:28   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:23:14   terryt
*  Capture support
*  
*     Rev 1.1   26 Jul 1995 16:02:00   terryt
*  Allow deletion of current drive
*  
*     Rev 1.0   15 May 1995 19:10:46   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <direct.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include "common.h"

#include "inc/ntnw.h"

#include <nwapi.h>

void ProcessLoginScripts(unsigned int conn, char * UserName, int argc, char **argv, char *lpScript);

extern int SafeDisk;

extern unsigned int ConvertNDSPathToNetWarePath(char *, char *, char *);

/*************************************************************************
*
*  NTNetWareLoginScripts
*     Main logon script processor
*
*  ENTRY:
*
*  EXIT
*
*************************************************************************/

int
NTNetWareLoginScripts( int argc, char ** argv )
{
    unsigned int  defConn;
    char          UserName[MAX_NAME_LEN]="";
    WCHAR         UserName_w[MAX_NAME_LEN * sizeof(WCHAR)]=L"";
    char          MessageServer[NDS_NAME_CHARS]="";
    char         *lpScript = NULL;
    DWORD         PrintOptions;
    LPTSTR        pszPreferredSrv;
    LPTSTR        ptreeW;
    LPTSTR        pcontextW;
    NTSTATUS      ntstatus;
    char *        lpC1;
    char *        lpC2;
    unsigned int  NewConn;
    unsigned int  Result;

    if ( NwQueryInfo( &PrintOptions, &pszPreferredSrv ) || !pszPreferredSrv )
    {
        DisplayMessage(IDR_QUERY_INFO_FAILED);
        return( FALSE );
    }

    //
    // nwscript /S filename
    //
    // can be used to pass a local script file for testing
    //
    if ( ( argc >= 3 ) && !_strcmpi(argv[1], "/S") )
    {
        lpScript = argv[2];
        argc -= 2;
        argv += 2;
    }

    //
    // NDS preferred server format is:
    // *<tree name>\<context>
    
    fNDS = ( *pszPreferredSrv == L'*' );

    if ( fNDS )
    {

        // Get the NDS tree name

        ptreeW = pszPreferredSrv + 1;

        pcontextW = wcschr( pszPreferredSrv, L'\\' );

        if ( pcontextW )
        {
           *pcontextW++ = L'\0';
        }

        NDSTREE = malloc ( CONTEXT_MAX );
        if (NDSTREE == NULL) {
            goto ExitWithError;
        }

        NDSTREE_w = malloc ( CONTEXT_MAX * sizeof(WCHAR) );
        if (NDSTREE_w == NULL) {
            goto ExitWithError;
        }

        if ( ptreeW )
        {
            wcscpy( NDSTREE_w, ptreeW );
            RtlInitUnicodeString( &NDSTREE_u, NDSTREE_w );
            WideTosz( NDSTREE, ptreeW, CONTEXT_MAX );
            _strupr( NDSTREE );
        }
        else
        {
            strcpy( NDSTREE, "" ); 
            wcscpy( NDSTREE_w, L"" ); 
        }

        // Get the fully typed user name

        TYPED_USER_NAME_w = malloc ( sizeof(WCHAR) * NDS_NAME_CHARS );
        if (TYPED_USER_NAME_w == NULL) {
            goto ExitWithError;
        }
        TYPED_USER_NAME = malloc ( NDS_NAME_CHARS );
        if (TYPED_USER_NAME == NULL) {
            goto ExitWithError;
        }

        ntstatus = NTGetNWUserName( NDSTREE_w, TYPED_USER_NAME_w,
                                    sizeof(WCHAR) * NDS_NAME_CHARS  );
        if ( !NT_SUCCESS( ntstatus ) ) {
            DisplayMessage(IDR_QUERY_INFO_FAILED);
            return ( FALSE );
        }

        WideTosz( TYPED_USER_NAME, TYPED_USER_NAME_w, NDS_NAME_CHARS );

        // Get the user name stripped of context and type

        lpC1 = strchr( TYPED_USER_NAME, '=' );
        if ( lpC1 )
            lpC1++;
        else 
            lpC1 = TYPED_USER_NAME;

        lpC2 = strchr( TYPED_USER_NAME, '.' );

        while ( lpC2 ) // Handle usernames with embedded/escaped dots ("\.")
        {
            if (*(lpC2-1) == '\\')
                lpC2 = strchr(lpC2+1, '.');
            else
                break;
        }

        if ( lpC2 )
            strncpy( UserName, lpC1, (UINT)(lpC2 - lpC1) );
        else
            strcpy( UserName, lpC1 );

        // Get the default context
        // This should be where the user is

        REQUESTER_CONTEXT = malloc( CONTEXT_MAX );
        if (REQUESTER_CONTEXT == NULL) {
            goto ExitWithError;
        }

        if ( lpC2 ) 
        {
            strcpy( REQUESTER_CONTEXT, lpC2+1 ); 
        }
        else 
        {
            strcpy( REQUESTER_CONTEXT, "" ); 
        }
        NDSTypeless( REQUESTER_CONTEXT, REQUESTER_CONTEXT );

        //
        //  This finishes the NDS initialization
        //
        if ( NDSInitUserProperty () )
            return ( FALSE );

    }
    else
    {
        ntstatus = NTGetNWUserName( pszPreferredSrv, UserName_w,
                                    MAX_NAME_LEN * sizeof(WCHAR) );
        if ( !NT_SUCCESS( ntstatus ) ) {
            DisplayMessage(IDR_QUERY_INFO_FAILED);
            return ( FALSE );
        }
        WideTosz( UserName, UserName_w, MAX_NAME_LEN );
        _strupr( UserName );
    }

    //
    // If we map over a drive, the SafeDisk is used.
    //
    SafeDisk = _getdrive();

    NTInitProvider();

    //
    // Get the default connection handle.
    //
    // This is used to get the preferred server!

    if ( !CGetDefaultConnectionID (&defConn) )
        return( FALSE );

    PREFERRED_SERVER = malloc( NDS_NAME_CHARS );
    if (PREFERRED_SERVER == NULL) {
        goto ExitWithError;
    }

    GetFileServerName(defConn, PREFERRED_SERVER);

    //
    // By default we are "attached" to the default server
    //
    if ( fNDS )
        AddServerToAttachList( PREFERRED_SERVER, LIST_4X_SERVER );
    else
        AddServerToAttachList( PREFERRED_SERVER, LIST_3X_SERVER );

    //
    // Print out status
    //
    if ( fNDS ) 
    {
        DisplayMessage( IDR_CURRENT_CONTEXT, REQUESTER_CONTEXT );
        DisplayMessage( IDR_CURRENT_TREE, NDSTREE_w );
    }

    DisplayMessage( IDR_CURRENT_SERVER, PREFERRED_SERVER );

    //
    // We may want to change the Preferred Server based on the DS.
    // "MESSAGE_SERVER" should be the Preferred Server (if possible).
    //
    if ( fNDS )
    {
        NDSGetVar ( "MESSAGE_SERVER", MessageServer, NDS_NAME_CHARS );
        if ( strlen( MessageServer ) ) 
        {
            NDSAbbreviateName(FLAGS_NO_CONTEXT, MessageServer, MessageServer);
            lpC1 = strchr( MessageServer, '.' );
            if ( lpC1 )
                *lpC1 = '\0';
            if ( strcmp( MessageServer, PREFERRED_SERVER) )
            {
                DisplayMessage( IDR_AUTHENTICATING_SERVER, MessageServer );
                Result = NTAttachToFileServer( MessageServer, &NewConn );
                if ( Result )
                {
                    DisplayMessage( IDR_SERVER_NOT_FOUND, MessageServer );
                }
                else
                {
                    NWDetachFromFileServer( (NWCONN_HANDLE)NewConn );
                    strncpy( PREFERRED_SERVER, MessageServer, NDS_NAME_CHARS);
                    DisplayMessage( IDR_CURRENT_SERVER, PREFERRED_SERVER );

                    // By default we are "attached" to the preferred server

                    AddServerToAttachList( PREFERRED_SERVER, LIST_4X_SERVER );
                }
            }
        }
    }

    //
    // Just like login we ignore any errors from setting the login
    // directory.
    //
    SetLoginDirectory (PREFERRED_SERVER);

    // Process login scripts.

    ProcessLoginScripts(defConn, UserName, argc, argv, lpScript);

    return( TRUE );

ExitWithError:
    if (NDSTREE) {
        free(NDSTREE);
        NDSTREE = NULL;
    }
    if (NDSTREE_w) {
        free(NDSTREE_w);
        NDSTREE_w = NULL;
    }
    if (TYPED_USER_NAME) {
        free(TYPED_USER_NAME);
        TYPED_USER_NAME = NULL;
    }
    if (TYPED_USER_NAME_w) {
        free(TYPED_USER_NAME_w);
        TYPED_USER_NAME_w = NULL;
    }
    if (REQUESTER_CONTEXT) {
        free(REQUESTER_CONTEXT);
        REQUESTER_CONTEXT = NULL;
    }
    if (PREFERRED_SERVER) {
        free(PREFERRED_SERVER);
        PREFERRED_SERVER = NULL;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\time.c ===
/*
 * TIME.C - Various time subroutines needed by NetWare Login Script
 *
 *  Copyright (c) 1995 Microsoft Corporation
 */

#include "common.h"

// Needed to convert netware net date to DOS date
#define _70_to_80_bias        0x012CEA600L
#define SECS_IN_DAY (60L*60L*24L)
#define SEC2S_IN_DAY (30L*60L*24L)
#define FOURYEARS        (3*365+366)

WORD MonTotal[] = { 0,                       // dummy entry for month 0
        0,                                   // days before Jan 1
        31,                                  // days before Feb 1
        31+28,                               // days before Mar 1
        31+28+31,                            // days before Apr 1
        31+28+31+30,                         // days before May 1
        31+28+31+30+31,                      // days before Jun 1
        31+28+31+30+31+30,                   // days before Jul 1
        31+28+31+30+31+30+31,                // days before Aug 1
        31+28+31+30+31+30+31+31,             // days before Sep 1
        31+28+31+30+31+30+31+31+30,          // days before Oct 1
        31+28+31+30+31+30+31+31+30+31,       // days before Nov 1
        31+28+31+30+31+30+31+31+30+31+30,    // days before Dec 1
        31+28+31+30+31+30+31+31+30+31+30+31  // days before end of year
};

#define YR_MASK         0xFE00
#define LEAPYR_MASK     0x0600
#define YR_BITS         7
#define MON_MASK        0x01E0
#define MON_BITS        4
#define DAY_MASK        0x001F
#define DAY_BITS        5

#define HOUR_MASK       0xF800
#define HOUR_BITS       5
#define MIN_MASK        0x07E0
#define MIN_BITS        6
#define SEC2_MASK       0x001F
#define SEC2_BITS       5

static void NetToDosDate( DWORD time, WORD * dosdate, WORD * dostime )
{
        DWORD secs, days;
        WORD r;

    time = (time - _70_to_80_bias) / 2;     // # of 2 second periods since 1980
        secs = time % SEC2S_IN_DAY;         // 2 second period into day
        days = time / SEC2S_IN_DAY;         // days since Jan 1 1980

        r = (WORD) ( secs % 30 );           // # of 2 second steps
        secs /= 30;
        r |= (secs % 60) << SEC2_BITS;              // # of minutes
        r |= (secs / 60) << (SEC2_BITS+MIN_BITS);     // # of hours
        *dostime = r;

        r = (WORD) ( days / FOURYEARS );// (r) = four year period past 1980
        days %= FOURYEARS;              // (days) = days into four year period
        r *= 4;                         // (r) = years since 1980 (within 3)

        if (days == 31+28) {
                //* Special case for FEB 29th
                r = (r<<(MON_BITS+DAY_BITS)) + (2<<DAY_BITS) + 29;
        } else {
                if (days > 31+28)
                        --days;         // compensate for leap year
                while (days >= 365) {
                        ++r;
                        days -= 365;
                }

                for (secs = 1; days >= MonTotal[secs+1] ; ++secs)
                        ;
                days -= MonTotal[secs];
                r <<= MON_BITS;
                r += (WORD)secs;
                r <<= DAY_BITS;
                r += (WORD)days+1;
        }
        *dosdate = r;
}


void        nwShowLastLoginTime(VOID)
{
        LONG lTime = 0L;
        SYSTEMTIME st;
        FILETIME ft;
        TIME_ZONE_INFORMATION tz;
        WCHAR szTimeBuf[TIMEDATE_SIZE];
        WCHAR szDateBuf[TIMEDATE_SIZE];
        int ret;
        WORD dostime, dosdate;
        DWORD tzStat;

        if ( ret = NDSGetUserProperty ("Last Login Time", (PBYTE)&lTime,
                             4, NULL, NULL) )
        {
                #ifdef DEBUG
                OutputDebugString("NWLSPROC: error getting LOGIN TIME\n\r");
                #endif
                return;
        }

        // From NetWare we get seconds from 1970, need to go through
        // several conversions to get system time for NLS

        // First deduct bias from UTC time to correct for local time
        tzStat = GetTimeZoneInformation(&tz);
        if ( tzStat != (DWORD)-1 ) {
                if (tzStat == TIME_ZONE_ID_STANDARD)
                        tz.Bias += tz.StandardBias;
                else if (tzStat == TIME_ZONE_ID_DAYLIGHT)
                        tz.Bias += tz.DaylightBias;
                lTime -= tz.Bias*60;
        }
#ifdef DEBUG
        else {
                OutputDebugString("NWLSPROC: GetTimeZoneInformation failed\n\r");
        }
#endif // DEBUG

        NetToDosDate( lTime, &dosdate, &dostime );
        DosDateTimeToFileTime ( dosdate, dostime, &ft );
        FileTimeToSystemTime ( &ft, &st );

#ifdef notdef
        // I don't understand this comment, this code doesn't seem to be
        // needed for NT. - terry
        //
        // This code will work on NT, but not on Win95.
        // Convert the resulting system (UTC) time to local time
        if ( GetTimeZoneInformation(&tz) != (DWORD)-1 ) {
                SYSTEMTIME utcTime = st;
                SystemTimeToTzSpecificLocalTime ( &tz, &utcTime, &st );
        }
#ifdef DEBUG
        else {
                OutputDebugString("NWLSPROC: GetTimeZoneInformation failed\n\r");
        }
#endif // DEBUG
#endif

        wcscpy(szTimeBuf, L"");
        ret = GetTimeFormat (        GetSystemDefaultLCID(),
                                                TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER,
                                                &st,
                                                NULL,
                                                szTimeBuf,
                                                TIMEDATE_SIZE );
#ifdef DEBUG
        if ( !ret ) {
                char buf[80];
                wsprintf(buf,"NWLSPROC: GetTimeFormatA failure: %d sec:%ld\n\r",
                        GetLastError(), lTime );
                OutputDebugString(buf);
        }
#endif
        ret = GetDateFormat(LOCALE_USER_DEFAULT,
                                                DATE_LONGDATE,
                                                &st,
                                                NULL,
                                                szDateBuf,
                                                TIMEDATE_SIZE );
#ifdef DEBUG
        if ( !ret ) {
                char buf[80];
                wsprintf(buf,"NWLSPROC: GetDateFormatA failure: %d sec:%ld\n\r",
                        GetLastError(), lTime );
                OutputDebugString(buf);
        }
#endif

        DisplayMessage( IDR_LASTLOGIN, szDateBuf, szTimeBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\strings.c ===
/*************************************************************************
*
*  STRINGS.C
*
*  Various strings
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\STRINGS.C  $
*  
*     Rev 1.1   22 Dec 1995 14:26:50   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:08:06   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:23:56   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:11:06   terryt
*  Initial revision.
*  
*************************************************************************/

#include "common.h"

/*
 * These haven't been put into resource files, because they aren't user
 * messages.  Most are control information or variables.  To do this
 * right, all output and string processing would have to be changed to
 * unicode.  This can't be done until NetWare and International are
 * understood.
 */


char *__GREETING__[3]       = {"morning", "afternoon", "evening"};
char *__AMPM__[2]           = {"am", "pm"};
char *__Day__[7]            = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
char *__Month__[12]         = {"January", "Feburary", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
char __DEL__[]              ="DELETE";
char __REM__[]              ="REMOVE";
char __INS__[]              ="INSERT";
char __ROOT__[]             ="ROOT";
char __NEXT__[]             ="NEXT";

/*
 * Capture strings
 */
unsigned int CaptureStringsLoaded = FALSE;
WCHAR __DISABLED__[256];
WCHAR __ENABLED__[256];
WCHAR __YES__[256];
WCHAR __NO__[256];
WCHAR __SECONDS__[256];
WCHAR __CONVERT_TO_SPACE__[256];
WCHAR __NO_CONVERSION__[256];
WCHAR __NOTIFY_USER__[256];
WCHAR __NOT_NOTIFY_USER__[256];
WCHAR __NONE__[256];

char __JOB_DESCRIPTION__[]   ="LPT%d Catch";

char __OPT_NO__[]            ="No";

char __SHOW__[]              ="SHOW";

char __NOTIFY__[]            ="NOTIFY";
char __SHORT_FOR_NOTIFY__[]  ="NOTI";

char __NONOTIFY__[]          ="NONOTIFY";
char __SHORT_FOR_NONOTIFY__[]="NNOTI";

char __AUTOENDCAP__[]            ="AUTOENDCAP";
char __SHORT_FOR_AUTOENDCAP__[]  ="AU";

char __NOAUTOENDCAP__[]            ="NOAUTOENDCAP";
char __SHORT_FOR_NOAUTOENDCAP__[]  ="NA";

char __NOTABS__[]            ="NOTABS";
char __SHORT_FOR_NOTABS__[]  ="NT";

char __NOBANNER__[]            ="NOBANNER";
char __SHORT_FOR_NOBANNER__[]  ="NB";

char __FORMFEED__[]            ="FORMFEED";
char __SHORT_FOR_FORMFEED__[]  ="FF";

char __NOFORMFEED__[]            ="NOFORMFEED";
char __SHORT_FOR_NOFORMFEED__[]  ="NFF";

char __KEEP__[]            ="KEEP";
char __SHORT_FOR_KEEP__[]  ="K";

char __TIMEOUT__[]            ="TIMEOUT";
char __SHORT_FOR_TIMEOUT__[]  ="TI";

char __LOCAL__[]            ="LOCAL";
char __SHORT_FOR_LOCAL__[]  ="L";

char __LOCAL_3__[]          ="LPT";
char __LOCAL_2__[]          ="LP";

char __JOB__[]              ="JOB";
char __SHORT_FOR_JOB__[]    ="J";

char __SERVER__[]            ="SERVER";
char __SHORT_FOR_SERVER__[]  ="S";

char __QUEUE__[]            ="QUEUE";
char __SHORT_FOR_QUEUE__[]  ="Q";

char __PRINTER__[]            ="PRINTER";
char __SHORT_FOR_PRINTER__[]  ="P";

char __CREATE__[]            ="CREATE";
char __SHORT_FOR_CREATE__[]  ="CR";

char __FORM__[]            ="FORM";
char __SHORT_FOR_FORM__[]  ="F";

char __COPIES__[]            ="COPIES";
char __SHORT_FOR_COPIES__[]  ="C";

char __TABS__[]            ="TABS";
char __SHORT_FOR_TABS__[]  ="T";

char __NAME__[]            ="NAME";
char __SHORT_FOR_NAME__[]  ="NAM";

char __BANNER__[]            ="BANNER";
char __SHORT_FOR_BANNER__[]  ="B";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\script.c ===
/*************************************************************************
*
*  SCRIPT.C
*
*  Script routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*************************************************************************/

#include "common.h"
#include <direct.h>
#include <time.h>
#include <ctype.h>
#include <process.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <io.h>
#include <time.h>

extern VOID nwShowLastLoginTime( VOID );

#define MAXLEN     256
#define MAX_NUM_IF 10

#define NUMCOMMAND 45

#define CM_IF     20
#define CM_ELSE   21
#define CM_ENDIF  22
#define CM_END    23

//
// 3X and 4X variables
//

#define IDS_DAY_OF_WEEK                    0
#define IDS_DAY                            1
#define IDS_MONTH_NAME                     2
#define IDS_MONTH                          3
#define IDS_NDAY_OF_WEEK                   4
#define IDS_SHORT_YEAR                     5
#define IDS_YEAR                           6
#define IDS_AM_PM                          7
#define IDS_GREETING_TIME                  8
#define IDS_HOUR24                         9
#define IDS_HOUR                          10
#define IDS_MINUTE                        11
#define IDS_SECOND                        12
#define IDS_FULL_NAME                     13
#define IDS_LOGIN_NAME                    14
#define IDS_USER_ID                       15
#define IDS_PASSWORD_EXPIRES              16
#define IDS_NETWORK_ADDRESS               17
#define IDS_FILE_SERVER                   18
#define IDS_ACCESS_SERVER                 19
#define IDS_ERROR_LEVEL                   20
#define IDS_ERRORLEVEL                    21
#define IDS_MACHINE                       22
#define IDS_OS_VERSION                    23
#define IDS_OS                            24
#define IDS_SMACHINE                      25
#define IDS_SHELL_TYPE                    26
#define IDS_STATION                       27
#define IDS_P_STATION                     28
#define IDS_SHELL_VERSION                 29
#define NUMVAR_3X                         IDS_SHELL_VERSION + 1 

#define IDS_LAST_NAME                     30
#define IDS_LOGIN_CONTEXT                 31
#define IDS_NETWARE_REQUESTER             32
#define IDS_REQUESTER_CONTEXT             33
#define IDS_ACCOUNT_BALANCE               34
#define IDS_CN                            35
#define IDS_REQUESTER_VERSION             36
#define IDS_SURNAME                       37
#define IDS_DOS_REQUESTER                 38
#define IDS_REQUESTER                     39
#define IDS_ADMINISTRATIVE_ASSISTANT      40
#define IDS_ALLOW_UNLIMITED_CREDIT        41
#define IDS_DESCRIPTION                   42
#define IDS_EMAIL_ADDRESS                 43
#define IDS_EMPLOYEE_ID                   44
#define IDS_FACSIMILE_TELEPHONE_NUMBER    45
#define IDS_GROUP_MEMBERSHIP              46
#define IDS_HIGHER_PRIVILEGES             47
#define IDS_HOME_DIRECTORY                48
#define IDS_INITIALS                      49
#define IDS_LANGUAGE                      50
#define IDS_LOCKED_BY_INTRUDER            51
#define IDS_LOGIN_DISABLED                52
#define IDS_LOGIN_GRACE_LIMIT             53
#define IDS_LOGIN_GRACE_REMAINING         54
#define IDS_LOGIN_INTRUDER_ATTEMPTS       55
#define IDS_LOGIN_MAXIMUM_SIMULTANEOUS    56
#define IDS_MAILSTOP                      57
#define IDS_MESSAGE_SERVER                58
#define IDS_MINIMUM_ACCOUNT_BALANCE       59
#define IDS_NETWORK                       60
#define IDS_OBJECT_CLASS                  61
#define IDS_OU                            62
#define IDS_PASSWORD_ALLOW_CHANGE         63
#define IDS_PASSWORD_MINIMUM_LENGTH       64
#define IDS_PASSWORD_REQUIRED             65
#define IDS_PASSWORD_UNIQUE_REQUIRED      66
#define IDS_PASSWORDS_USED                67
#define IDS_PHYSICAL_DELIVERY_OFFICE_NAME 68
#define IDS_POSTAL_ADDRESS                69
#define IDS_POSTAL_CODE                   70
#define IDS_POSTAL_OFFICE_BOX             71
#define IDS_PRIVATE_KEY                   72
#define IDS_PROFILE                       73
#define IDS_REVISION                      74
#define IDS_SECURITY_EQUALS               75
#define IDS_SECURITY_FLAGS                76
#define IDS_SEE_ALSO                      77
#define IDS_SERVER_HOLDS                  78
#define IDS_SUPERVISOR                    79
#define IDS_TELEPHONE_NUMBER              80
#define IDS_TITLE                         81
#define IDS_CERTIFICATE_VALIDITY_INTERVAL 82
#define IDS_EQUIVALENT_TO_ME              83
#define IDS_GENERATIONAL_QUALIFIER        84
#define IDS_GIVEN_NAME                    85
#define IDS_MAILBOX_ID                    86
#define IDS_MAILBOX_LOCATION              87
#define IDS_PROFILE_MEMBERSHIP            88
#define IDS_SA                            89
#define IDS_S                             90
#define IDS_L                             91
#define IDS_ACCESS                        92
#define NUMVAR                            IDS_ACCESS + 1

/*
 *  String constants.
 */

/*
 *  Text for default Login Script.  Don't change.
 */
BYTE   DefaultLoginScript[] =
    "WRITE \"Good %GREETING_TIME, %LOGIN_NAME.\\n\"\n"
    "MAP DISPLAY OFF\n"
    "MAP ERRORS OFF\n"
    "Rem: Set 1st drive to most appropriate directory.\n"
    "MAP *1:=%FILE_SERVER/SYS:;*1:=%FILE_SERVER/SYS:%LOGIN_NAME\n"
    "If LOGIN_NAME=\"SUPERVISOR\" || LOGIN_NAME=\"ADMIN\" || LOGIN_NAME=\"SUPERVIS\" THEN MAP *1:=%FILE_SERVER/SYS:SYSTEM\n"
    "Rem: Set search drives (S2 machine-OS dependent).\n"
    "MAP INS S1:=%FILE_SERVER/SYS:PUBLIC\n"
    "MAP INS S2:=%FILE_SERVER/SYS:\n"
    "Rem: Now display all the current drive settings.\n"
    "MAP DISPLAY ON\n"
    "MAP\n"
    "\0";

char *__SPACES__=" \t";

/*
 *  Do not change the order of this array.
 */
char * COMPARE_OPERATORS[] =
{
    "!=",
    "<>",
    "NOT EQUAL TO",
    "DOES NOT EQUAL",
    "NOT EQUAL",
    "IS NOT EQUAL",
    "#",
    "IS NOT",                      // 7
    ">=",                          // 8
    "IS GREATER THAN OR EQUAL TO",
    "IS GREATER THAN OR EQUAL",
    "GREATER THAN OR EQUAL TO",
    "GREATER THAN OR EQUAL",
    ">",                           // 13
    "IS GREATER THAN",
    "GREATER THAN",
    "<=",                          // 16
    "IS LESS THAN OR EQUAL TO",
    "IS LESS THAN OR EQUAL",
    "LESS THAN OR EQUAL TO",
    "LESS THAN OR EQUAL",
    "<",                           // 21
    "IS LESS THAN",
    "LESS THAN",
    "==",                          // 24
    "=",
    "EQUALS",
    "EQUAL",
    "IS",
    "\0"
};

int IsNotEqual (int nIndex)
{
    return(nIndex < 8);
}

int IsGreaterOrEqual (int nIndex)
{
    return(nIndex >= 8 && nIndex < 13);
}

int IsGreater (int nIndex)
{
    return(nIndex >= 13 && nIndex < 16);
}

int IsLessOrEqual (int nIndex)
{
    return(nIndex >= 16 && nIndex < 21);
}

int IsLess (int nIndex)
{
    return(nIndex >= 21 && nIndex < 24);
}

/*
 *  Type defs.
 */
typedef int (*PFCommandHandler) (char *lpParam);

typedef struct tagCOMMANDTABLE
{
    char *commandStr0;
    char *commandStr1;
    char *commandStr2;
    PFCommandHandler commandhandler;
}COMMANDTABLE;

typedef struct tagLABEL_LIST
{
    char *pLabel;
    char *pNextLine;
    struct tagLABEL_LIST *pNext;
}LABEL_LIST, *PLABEL_LIST;

/*
 *  Functions that are in command dispatch table.
 */
int AttachHandler    (char *lpParam);
int BreakHandler     (char *lpParam);
int ComspecHandler   (char *lpParam);
int DisplayHandler   (char *lpParam);
int DosBreakHandler  (char *lpParam);
int SetHandler       (char *lpParam);
int LocalSetHandler  (char *lpParam);
int DosVerifyHandler (char *lpParam);
int DriveHandler     (char *lpParam);
int FireHandler      (char *lpParam);
int ExitHandler      (char *lpParam);
int IfHandler        (char *lpParam);
int ElseHandler      (char *lpParam);
int EndHandler       (char *lpParam);
int IncludeHandler   (char *lpParam);
int MapHandler       (char *lpParam);
int PauseHandler     (char *lpParam);
int WriteHandler     (char *lpParam);
int NullHandler      (char *lpParam);
int GotoHandler      (char *lpParam);
int ShiftHandler     (char *lpParam);
int MachineHandler   (char *lpParam);
int CompatibleHandler(char *lpParam);
int ClearHandler     (char *lpParam);
int LastLoginTimeHandler(char *lpParam);
int ContextHandler   (char *lpParam);
int ScriptServerHandler(char *lpParam);
int NoDefaultHandler (char *lpParam);

/*
 *  Command dispatch table. Do not change.
 *
 *  If you do, you must change CM_IF, CM_ELSE, CM_END and CM_ENDIF
 */
COMMANDTABLE nwCommand[NUMCOMMAND] =
{
    "LOCAL",            "DOS",     "SET",    LocalSetHandler,
    "TEMP",             "DOS",     "SET",    LocalSetHandler,
    "TEMPORARY",        "DOS",     "SET",    LocalSetHandler,
    "LOCAL",            "SET",     NULL,     LocalSetHandler,
    "TEMP",             "SET",     NULL,     LocalSetHandler,
    "TEMPORARY",        "SET",     NULL,     LocalSetHandler,
    "DOS",              "SET",     NULL,     SetHandler,
    "DOS",              "VERIFY",  NULL,     DosVerifyHandler,
    "DOS",              "BREAK",   NULL,     DosBreakHandler,
    "FIRE",             "PHASERS", NULL,     FireHandler,
    "ATTACH",           NULL,      NULL,     AttachHandler,
    "BREAK",            NULL,      NULL,     BreakHandler,
    "COMSPEC",          NULL,      NULL,     NullHandler,
    "DISPLAY",          NULL,      NULL,     DisplayHandler,
    "SET_TIME",         NULL,      NULL,     NullHandler,     
    "SET",              NULL,      NULL,     SetHandler,
    "DRIVE",            NULL,      NULL,     DriveHandler,
    "FDISPLAY",         NULL,      NULL,     DisplayHandler,
    "FIRE",             NULL,      NULL,     FireHandler,
    "EXIT",             NULL,      NULL,     ExitHandler,
    "IF",               NULL,      NULL,     IfHandler,       // CM_IF
    "ELSE",             NULL,      NULL,     ElseHandler,     // CM_ELSE 
    "ENDIF",            NULL,      NULL,     EndHandler,      // CM_ENDIF
    "END",              NULL,      NULL,     EndHandler,      // CM_END
    "INCLUDE",          NULL,      NULL,     IncludeHandler,
    "MACHINE",          NULL,      NULL,     MachineHandler,
    "MAP",              NULL,      NULL,     MapHandler,
    "PAUSE",            NULL,      NULL,     PauseHandler,
    "COMPATIBLE",       NULL,      NULL,     CompatibleHandler,
    "PCCOMPATIBLE",     NULL,      NULL,     CompatibleHandler,
    "REMARK",           NULL,      NULL,     NullHandler,
    "REM",              NULL,      NULL,     NullHandler,
    "SHIFT",            NULL,      NULL,     ShiftHandler,
    "WAIT",             NULL,      NULL,     PauseHandler,
    "WRITE",            NULL,      NULL,     WriteHandler,   
    "GOTO",             NULL,      NULL,     GotoHandler,   
    "CLS",              NULL,      NULL,     ClearHandler, 
    "CLEAR",            NULL,      NULL,     ClearHandler,
    "SWAP",             NULL,      NULL,     NullHandler,     
    "LASTLOGIN",        NULL,      NULL,     LastLoginTimeHandler, // 39
    "CONTEXT",          NULL,      NULL,     ContextHandler,       // 40
    "SCRIPT_SERVER",    NULL,      NULL,     ScriptServerHandler,  // 41
    "NO_DEFAULT",       NULL,      NULL,     NoDefaultHandler,     // 42
    "CX",               NULL,      NULL,     ContextHandler,       // 43
    "PATH",             NULL,      NULL,     MapHandler,           // 44
};

typedef struct tagVARTABLE
{
    char *VarName;
}VARTABLE;

VARTABLE varTable[NUMVAR] =
{
    "DAY_OF_WEEK",
    "DAY",       
    "MONTH_NAME",
    "MONTH",    
    "NDAY_OF_WEEK",
    "SHORT_YEAR", 
    "YEAR",      
    "AM_PM",    
    "GREETING_TIME",
    "HOUR24",      
    "HOUR",       
    "MINUTE",    
    "SECOND",   
    "FULL_NAME", 
    "LOGIN_NAME",
    "USER_ID",  
    "PASSWORD_EXPIRES",
    "NETWORK_ADDRESS",
    "FILE_SERVER",   
    "ACCESS_SERVER",
    "ERROR_LEVEL", 
    "ERRORLEVEL", 
    "MACHINE",   
    "OS_VERSION", 
    "OS",        
    "SMACHINE", 
    "SHELL_TYPE",
    "STATION",  
    "P_STATION", 
    "SHELL_VERSION",
    "LAST_NAME", 
    "LOGIN_CONTEXT",
    "NETWARE_REQUESTER",
    "REQUESTER_CONTEXT",
    "ACCOUNT_BALANCE",  
    "CN",               
    "REQUESTER_VERSION",
    "SURNAME",          
    "DOS_REQUESTER",
    "REQUESTER",
    "ADMINISTRATIVE_ASSISTANT",
    "ALLOW_UNLIMITED_CREDIT",
    "DESCRIPTION",
    "EMAIL_ADDRESS",
    "EMPLOYEE_ID",
    "FACSIMILE_TELEPHONE_NUMBER",
    "GROUP_MEMBERSHIP",
    "HIGHER_PRIVILEGES",
    "HOME_DIRECTORY",
    "INITIALS",
    "LANGUAGE",
    "LOCKED_BY_INTRUDER",
    "LOGIN_DISABLED",
    "LOGIN_GRACE_LIMIT",
    "LOGIN_GRACE_REMAINING",
    "LOGIN_INTRUDER_ATTEMPTS",
    "LOGIN_MAXIMUM_SIMULTANEOUS",
    "MAILSTOP",
    "MESSAGE_SERVER",
    "MINIMUM_ACCOUNT_BALANCE",
    "NETWORK",
    "OBJECT_CLASS",
    "OU",
    "PASSWORD_ALLOW_CHANGE",
    "PASSWORD_MINIMUM_LENGTH",
    "PASSWORD_REQUIRED",
    "PASSWORD_UNIQUE_REQUIRED",
    "PASSWORDS_USED",
    "PHYSICAL_DELIVERY_OFFICE_NAME",
    "POSTAL_ADDRESS",
    "POSTAL_CODE",
    "POSTAL_OFFICE_BOX",
    "PRIVATE_KEY",
    "PROFILE",
    "REVISION",
    "SECURITY_EQUALS",
    "SECURITY_FLAGS",
    "SEE_ALSO",
    "SERVER_HOLDS",
    "SUPERVISOR",
    "TELEPHONE_NUMBER",
    "TITLE",
    "CERTIFICATE_VALIDITY_INTERVAL",
    "EQUIVALENT_TO_ME",
    "GENERATIONAL_QUALIFIER",
    "GIVEN_NAME",
    "MAILBOX_ID",
    "MAILBOX_LOCATION",
    "PROFILE_MEMBERSHIP",
    "SA",
    "S",
    "L",
    "ACCESS",
};

/*
 *  Local functions.
 */
void  SmartCap(char *ptr);
int   NWGetFileSize (char * lpFileName);
void  LoadFile (char *lpFileName, char *lpFileBuffer, int nFileSize);
int   ProcessLoginScriptFile (char *lpLoginScriptFile);
void  ProcessLoginScript (char *lpLoginScript);
int   ProcessLoginScriptProperty (unsigned char *);

int   CreateLabelList (PLABEL_LIST *ppLabelList, char *lpLoginScript);
void  FreeLabelList (LABEL_LIST *pLabelList);

void  ExternalCmdHandler(char *lpCommand);
void  BadCommandHandler (char *lpCommand);

void  CommandDispatch (char *lpCommand);
int   GetTableIndex(char *lpCommand, char ** prestbuffer);

DWORD SwapLong(DWORD number);
int   EndOfLine (char *buffer);
char *RemoveSpaces (char * buffer);
int   IsOn (char *lpParam);
int   IsOff (char *lpParam);
int   VarTranslate(char *vartext);
int   QuotedStringTranslate (char *buffer);
void  NotQuotedStringTranslate(char *buffer, BOOL remove_dbs);
void  SetLocalEnv(char *buffer);
int   SetEnv (char *lpEnvLine);
char *ConvertPercent (char *buffer);
void  GetShellVersion(char *buffer, int index);

/*
 *  Global Defines
 */
#define IsWhiteSpace(x) ((x==' ')||(x=='\t')||(x=='\n')||(x=='\r')||(x==0))

/*
 *  Global variables.
 */

//
//  The following globals are used for goto processing... this allows us
//  to manipulate the line we're processing outside ProcessLoginScript.
//

LABEL_LIST *pGlobalLabelList;
char *lpGlobalLine;
char *lpGlobalLineSeparator;
int   fGlobalHaveNulledLineSeparator;
int   fGlobalExitFlag;
int   fGlobalIfTooDeep;

int  fBreakOn = TRUE;

int  nCondIndex;
int  aCondVal[MAX_NUM_IF];

int  ARGC;
char **ARGV;
int  nGlobalShiftDelta = 0;
int  fGlobalCompatible = FALSE;
int  fNoDefaultLoginScript = FALSE;

char *LOGIN_NAME;
char *LAST_NAME;
char *LOGIN_CONTEXT;
char *REQUESTER_CONTEXT;
char *COMMON_NAME;
char *TYPED_USER_NAME;
PWCHAR TYPED_USER_NAME_w;
PBYTE NDSTREE;
PBYTE PREFERRED_SERVER;

HANDLE hconout = INVALID_HANDLE_VALUE;

unsigned int CONNECTION_ID;
unsigned int CONNECTION_NUMBER;
unsigned int SCRIPT_ERROR = 0;

#define REQUESTER_VERSION "V1.20"

extern DWORD GUserObjectID;

int IsEmptyFile (char *lpFile)
{
    while (*lpFile != 0)
    {
        if (*lpFile != ' ' &&
            *lpFile != '\t'&&
            *lpFile != '\n'&&
            *lpFile != '\r')
        {
            return(FALSE);
        }
        lpFile++;
    }

    return(TRUE);
}

/*
 *  Login was successful.  Process both Login Scripts: the System Login
 *  Script and the User Login Script.  If there is an EXIT command in the
 *  System Login Script, then we do not process the User Login Script.
 *  If there is no User Login Script, we process a default Login Script,
 *  which is hard-coded internally.  See the Login Script appendix in
 *  the NetWare Installation guide for more info.
 */
void ProcessLoginScripts (unsigned int conn, char *UserName, int argc, char ** argv, char *lpScript)
{
    unsigned int  iRet = 0;
    unsigned long userID ;
    char     pchUserLoginScriptFile[24];

    // Initalize LOGIN_NAME, CONNECTION_ID and CONNECTION_NUMBER.
    ARGC = argc;
    ARGV = argv;
    LOGIN_NAME = UserName;
    CONNECTION_ID = conn;

    // Initialize some 4X variables
    if ( fNDS )
    {
        COMMON_NAME = UserName;

        LOGIN_CONTEXT = malloc ( CONTEXT_MAX );
        if (LOGIN_CONTEXT) {
            strcpy( LOGIN_CONTEXT, REQUESTER_CONTEXT );
        }

        LAST_NAME = malloc( MAXLEN );
        if (LAST_NAME ) {
            NDSGetVar ( "SURNAME", LAST_NAME, MAXLEN );
        }
    }
    else {
        LAST_NAME = UserName;
        COMMON_NAME = UserName;
        LOGIN_CONTEXT = "";
        REQUESTER_CONTEXT = "";
    }

    if (iRet = GetConnectionNumber (conn, &CONNECTION_NUMBER))
    {
        DisplayError (iRet, "GetConnectionNumber");
        return;
    }

    if (lpScript)
    {
        if (!ProcessLoginScriptFile(lpScript))
            DisplayMessage(IDR_NO_SCRIPT_FILE, lpScript);
    }
    else
    {
        if ( fNDS )
        {
            unsigned char Object[128];
            unsigned char ProfileObject[256];
            PBYTE p;
            int err;

            // Browse back from user's node to first occurrence
            // or organizational unit or organization and look for
            // system script there. If the nearest OU or O doesn't have
            // a system script, don't run one.

            for ( p = TYPED_USER_NAME; p ; p = strchr ( p, '.' ) )
            {

                p++;
                             
                if ( *p == 'O' && *(p+1) == 'U' && *(p+2) == '=' )
                    break;

                if ( *p == 'O' && *(p+1) == '=' )
                    break;
            }

            if ( p != NULL )
            {
                ProcessLoginScriptProperty( p );
            }

            // profile login script.

            if ( !NDSGetUserProperty ( "Profile", ProfileObject, 256, NULL, NULL) )
            {
                ConvertUnicodeToAscii( ProfileObject );
                ProcessLoginScriptProperty( ProfileObject );
            }

            // user login script

            if ( (!ProcessLoginScriptProperty( TYPED_USER_NAME )) &&
                 (!fNoDefaultLoginScript) ) 
            {
                ProcessLoginScript (DefaultLoginScript);
            }
        }
        else
        {
            static char SysLoginScriptFile[] = "SYS:PUBLIC/NET$LOG.DAT" ;

            // Process system login script file.
            ProcessLoginScriptFile (SysLoginScriptFile);

            // Check if user login script exists.
            if (iRet = GetBinderyObjectID (conn, UserName, OT_USER,
                       &userID))
                return;

            sprintf(pchUserLoginScriptFile, "SYS:MAIL/%lx/LOGIN", SwapLong(userID));

            if ( (!ProcessLoginScriptFile (pchUserLoginScriptFile)) &&
                 (!fNoDefaultLoginScript) )
            {
                ProcessLoginScript (DefaultLoginScript);
            }
        }
    }
}

int ProcessLoginScriptFile (char *lpLoginScriptFile)
{
    int   nFileSize = 0, bEmpty;
    char *lpLoginScript;

    nFileSize = NWGetFileSize (lpLoginScriptFile);

    if (nFileSize <= 2)
        return(FALSE);

    // system login script exists.
    lpLoginScript = malloc (nFileSize);
    if (lpLoginScript == NULL)
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    LoadFile (lpLoginScriptFile, lpLoginScript, nFileSize);

    bEmpty = IsEmptyFile(lpLoginScript);

    if (!bEmpty)
        ProcessLoginScript (lpLoginScript);

    free (lpLoginScript);

    return(!bEmpty);
}


/*
 * Retrieve and process the Login Script property 
 */
int ProcessLoginScriptProperty ( unsigned char * Object )
{
    unsigned int nFileSize = 0;
    unsigned int Actual = 0;
    unsigned int bEmpty;
    char *lpLoginScript;
    HANDLE Stream;
    int  err;
    unsigned int  i,j;

    if ( NDSfopenStream ( Object, "Login Script", &Stream, &nFileSize ) )
        return(FALSE);

    if ( nFileSize <= 2) 
        return(FALSE);

    // login script exists.
    lpLoginScript = malloc (nFileSize+2);
    if (lpLoginScript == NULL)
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    memset(lpLoginScript, 0, nFileSize+2);

    if ( !ReadFile ( Stream, lpLoginScript, nFileSize, &Actual, NULL ) )
    { 
       bEmpty = TRUE;
    }
    else if ( IsEmptyFile(lpLoginScript) ) 
       bEmpty = TRUE;
    else
       bEmpty = FALSE;

    if (!bEmpty) {
        for ( i = 0, j = 0; i < nFileSize; i++, j++ )
        {
            if (( lpLoginScript[i] == '\r' ) &&
                ( lpLoginScript[i+1] == '\n' ) )
                i++;

            lpLoginScript[j] = lpLoginScript[i];
        }

        while ( j < nFileSize )
        {
            lpLoginScript[j++] = 0;
        }
    }

    CloseHandle( Stream );

    if (!bEmpty)
        ProcessLoginScript (lpLoginScript);

    free (lpLoginScript);

    return(!bEmpty);
}

/*
 *  Return the size of the file.
 */
int NWGetFileSize (char * lpFileName)
{
    int nFileSize = 0;
    FILE * stream;

    do
    {
        if ((stream = fopen (NTNWtoUNCFormat(lpFileName), "r")) == NULL)
            break;

        while (feof (stream) == 0)
        {
            fgetc (stream);
            nFileSize++;
        }

        if (fclose (stream))
            nFileSize = 0;
    }while (FALSE);


    return(nFileSize);
}

/*
 *  Read the file into memory pointed by lpFileBuffer.
 */
void LoadFile (char *lpFileName, char *lpFileBuffer, int nFileSize)
{
    FILE * stream;

    if ((stream = fopen (NTNWtoUNCFormat(lpFileName), "r")) != NULL)
    {
        (void)fread (lpFileBuffer, sizeof (char), nFileSize, stream);
        fclose (stream);
    }

    *(lpFileBuffer+nFileSize-1) = 0;

}

/*
 *  Process Login Script that is in memory pointed by lpLoginScript
 *  line by line.
 */
void ProcessLoginScript (char *lpLoginScript)
{
    nCondIndex = -1;
    fGlobalExitFlag = FALSE;
    fGlobalIfTooDeep = FALSE;

    lpGlobalLine = lpLoginScript;   // we start at the top of the login script

    if (!CreateLabelList (&pGlobalLabelList, lpLoginScript))
    {
        if (pGlobalLabelList != NULL) {

            FreeLabelList (pGlobalLabelList);
            pGlobalLabelList = NULL;
        }
        return;
    }

    while (*lpGlobalLine != 0) {

        //
        //  search for the end of the current line and replace with a null
        //

        if (lpGlobalLineSeparator = strchr(lpGlobalLine, '\n')) {

            //
            //  we may reset this manually in the goto handler, remember so that
            //  we don't trample anything needlessly.
            //

            *lpGlobalLineSeparator = 0;
            fGlobalHaveNulledLineSeparator = TRUE;

        } else {

            fGlobalHaveNulledLineSeparator = FALSE;
        }

        //
        // Now lpGlobalLine points to one line only.
        //

        CommandDispatch (lpGlobalLine);

        if (fGlobalExitFlag)
        {
            if (fGlobalIfTooDeep)
                DisplayMessage(IDR_ORIGINAL_LINE_WAS, lpGlobalLine);
            break;
        }

        if (lpGlobalLineSeparator) {

            if ( fGlobalHaveNulledLineSeparator ) {

                *lpGlobalLineSeparator = '\n';    // recover the changes made.
                fGlobalHaveNulledLineSeparator = FALSE;
            }

            lpGlobalLine = lpGlobalLineSeparator + 1;   // next line please

        } else {

            break;
        }
    }

    if (pGlobalLabelList != NULL) {
        FreeLabelList (pGlobalLabelList);
        pGlobalLabelList = NULL;
    }
}

/*
 *  Scan the login script, put labels in a link list and comment out
 *  those label lines.
 */
int CreateLabelList (PLABEL_LIST *ppLabelList, char *lpLoginScript)
{
    char *lpLine = lpLoginScript, *lpEnd, *lpLabel, *lpTemp;
    int   nLen;
    PLABEL_LIST *ppNext = ppLabelList;

    while (*lpLine != 0)
    {
        if (lpEnd = strchr (lpLine, '\n'))
            *lpEnd = 0;

        // Now lpLine points to one line only.
        lpLabel = RemoveSpaces (lpLine);
        if (isalnum (*lpLabel) || (*lpLabel == '%'))
        {
            lpTemp = lpLabel;
            nLen = 0;
            while (*lpTemp != 0 && *lpTemp != ' ' && *lpTemp != '\t' && *lpTemp != ':')
            {
                if (IsDBCSLeadByte(*lpTemp))
                {
                    lpTemp++;
                    nLen++;
                }

                lpTemp++;
                nLen++;
            }

            lpTemp = RemoveSpaces (lpTemp);
            if (*lpTemp == ':' && EndOfLine (lpTemp+1))
            {
                // The Line is label line.
                if ((*ppNext = malloc (sizeof (LABEL_LIST))) == NULL ||
                    ((*ppNext)->pLabel = malloc (nLen+1)) == NULL)
                {
                    DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

                SmartCap(lpLabel);
                strncpy ((*ppNext)->pLabel, lpLabel, nLen);
                *((*ppNext)->pLabel+nLen) = 0;
                (*ppNext)->pNextLine = lpEnd? lpEnd+1 : lpEnd;
                (*ppNext)->pNext = NULL;
                ppNext = &((*ppNext)->pNext);

                // Comment out the label line.
                *(lpLine) = ';';
            }
        }

        if (lpEnd)
        {
            *lpEnd = '\n';    // recover the changes made.
            lpLine = lpEnd+1;
        }
        else
            break;
    }

    return(TRUE);
}

/*
 *  Free up the memory allocated for the link list.
 */
void FreeLabelList (LABEL_LIST *pLabelList)
{
    LABEL_LIST *pNext = pLabelList;

    while (pLabelList)
    {
        pNext = pLabelList->pNext;
        free (pLabelList->pLabel);
        free (pLabelList);
        pLabelList = pNext;
    }
}

/*
 *  Dispatch to command hander according to the command.
 */
void CommandDispatch (char *lpCommand)
{
    char buffer[MAXLEN];
    char *restBuffer;
    int  index, fCommandHandled = FALSE;
    int  nTemp = -1;

    // Get rid of leading spaces.
    lpCommand = RemoveSpaces(lpCommand);

    // Don't do anything if it's a comment line or empty line.
    if (*lpCommand == ';' || *lpCommand == '*' || *lpCommand == '\0' ||
        *lpCommand == '\r'|| *lpCommand == '\n')
        return;

    do  // FALSE loop.
    {
        // Make sure the command line is not too long to process.
        if (strlen (lpCommand) > MAXLEN -1) {
            break;
        }

        // Make a copy of the command line to buffer.
        strcpy (buffer, lpCommand);

        // external command line.
        if (*buffer == '#')
        {
            ExternalCmdHandler (buffer);
            return;
        }

        // Get the command index in the command table.
        if ((index = GetTableIndex(buffer, &restBuffer)) == -1)
            break;

        // Dispatch to the corresponding command handler.
        if (nCondIndex > -1 &&
            !aCondVal[nCondIndex] &&
            index != CM_IF   &&
            index != CM_ELSE &&
            index != CM_END  &&
            index != CM_ENDIF)
            fCommandHandled = TRUE;
        else
            fCommandHandled = (*nwCommand[index].commandhandler)(restBuffer);

    } while (FALSE);

    if (!fCommandHandled) {
        BadCommandHandler (lpCommand);
    }
}

/*
 * Used by GetTableIndex().
 * This function should capitalize the entire command string except
 * those in quotes. It should also skip DBCS characters.
 */
void SmartCap(char *ptr)
{
    int inquotes = (*ptr == '\"');
    char *pNext;

    while (*ptr)
    {
        if (!inquotes && !IsDBCSLeadByte(*ptr))
        {
            *ptr = (char) toupper((int)*ptr);
        }

        pNext = NWAnsiNext(ptr);

        if (*pNext == '\"' && *ptr != '\\')
            inquotes = !inquotes;

        ptr = pNext;
    }
}

/*
 * Return the index of the command in the command dispatch table.
 * Return -1 if the command is not found in the command dispatch table.
 */
int GetTableIndex(char *buffer, char **prestBuffer)
{
    int i, nStrLen;

    // Upcase every thing except those in quotes.
    SmartCap (buffer);

    for (i=0; i<NUMCOMMAND; i++)
    {
        if (*(WORD *)nwCommand[i].commandStr0 != *(WORD *)buffer)
            continue;

        nStrLen = strlen (nwCommand[i].commandStr0);

        if (strncmp(nwCommand[i].commandStr0, buffer, nStrLen))
            continue;

        *prestBuffer = buffer + nStrLen;
        *prestBuffer = RemoveSpaces (*prestBuffer);

        if (nwCommand[i].commandStr1)
        {
            nStrLen = strlen (nwCommand[i].commandStr1);

            if (strncmp(nwCommand[i].commandStr1, *prestBuffer, nStrLen))
                continue;

            *prestBuffer += nStrLen;
            *prestBuffer = RemoveSpaces (*prestBuffer);

            if (nwCommand[i].commandStr2)
            {
                nStrLen = strlen (nwCommand[i].commandStr2);

                if (strncmp(nwCommand[i].commandStr2, *prestBuffer, nStrLen))
                    continue;

                *prestBuffer += nStrLen;
                *prestBuffer = RemoveSpaces (*prestBuffer);
            }
        }

        return (i);
    }

    return(-1);
}

/*
 *   Goto label...  We modify the globals controlling what line we're on.
 */
int  GotoHandler  (char *lpParam)
{
    int fLabelFound = FALSE;
    char *lpLabel, *lpEnd, chEnd;
    LABEL_LIST *pLabelList = pGlobalLabelList;

    lpLabel = lpParam;
    lpLabel = RemoveSpaces (lpLabel);

    //
    //  find the end of the label, we'll slam in a null for the search and
    //  restore the char after we're done searching.
    //

    lpEnd = lpLabel;
    while (*lpEnd != 0 &&
           *lpEnd != ' ' &&
           *lpEnd != '\t' &&
           *lpEnd != '\r' &&
           *lpEnd != '\n')
    {
        if (*lpEnd == ':')
            return(FALSE);
        else
            lpEnd = NWAnsiNext(lpEnd);
    }

    chEnd = *lpEnd;
    *lpEnd = 0;

    while (pLabelList)
    {
        if (!_stricmp (pLabelList->pLabel, lpLabel))
        {
            if ( fGlobalHaveNulledLineSeparator )
            {

                *lpGlobalLineSeparator = '\n';    // recover the changes made.
                fGlobalHaveNulledLineSeparator = FALSE;
            }

            lpGlobalLine = pLabelList->pNextLine;

            lpGlobalLineSeparator = lpGlobalLine ? (lpGlobalLine - 1) : NULL;

            fLabelFound = TRUE;
            break;
        }

        pLabelList = pLabelList->pNext;
    }

    if (!fLabelFound)
    {
        DisplayMessage (IDR_LABEL_NOT_FOUND, lpLabel);
        fGlobalExitFlag = TRUE;
    }

    *lpEnd = chEnd;
    return( TRUE );
}

/*
 * Attach [FileServer[/UserName[;Password]]]
 */
int AttachHandler (char *lpParam)
{
    unsigned int iRet = 0;
    int  fCommandHandled = FALSE;
    char serverName[MAX_NAME_LEN] = "";
    char userName[MAX_NAME_LEN] = "";
    char password[MAX_PASSWORD_LEN] = "";
    char *lpSlash, *lpSemiColon, *lpServerName, *lpUserName;
    unsigned int conn;
    int  bAlreadyAttached = FALSE, bReadPassword = TRUE;

    do // FALSE loop.
    {
        NotQuotedStringTranslate (lpParam, TRUE);

        // Make sure that there is at most 1 slash.
        lpSlash = strchr (lpParam, '\\');

        if (lpSlash == NULL)
        {
            lpSlash = strchr (lpParam, '/');
            if (lpSlash != NULL && strchr (lpSlash+1, '/'))
                break;
        }
        else
        {
            if (strchr (lpParam, '/') ||
                strchr (lpSlash+1, '/') ||
                strchr (lpSlash+1, '\\'))
            break;
        }

        // Break the string at slash.
        if (lpSlash)
            *lpSlash = 0;

        // Server name should not contain semicolon.
        if (strchr (lpParam, ';'))
            break;

        lpServerName = strtok (lpParam, __SPACES__);

        if (lpServerName == NULL)
        {
            if (lpSlash)
                break;
        }
        else
        {
            // Make sure that there is only one name in front of the slash.
            if (strtok (NULL, __SPACES__))
                break;

            // Copy the server name to the buffer.
            if (strlen (lpParam) > MAX_NAME_LEN-1)
                break;

            strcpy (serverName, lpParam);

            if (lpSlash)
            {
                lpSemiColon = strchr (lpSlash+1, ';');
                if (lpSemiColon)
                    *lpSemiColon = 0;

                lpUserName = strtok (lpSlash+1, __SPACES__);
                if (lpUserName)
                {
                    if ( strtok (NULL, __SPACES__))
                        break;

                    if (strlen (lpUserName) > MAX_NAME_LEN-1 )
                        break;

                    strcpy (userName, lpUserName);
                }

                if (lpSemiColon)
                {
                    if (strlen (lpSemiColon+1) > MAX_PASSWORD_LEN-1)
                        break;
                    strcpy (password, strtok (lpSemiColon+1, __SPACES__));
                    xstrupr (password);
                    bReadPassword = FALSE;
                }
            }
        }

        fCommandHandled = TRUE;

        if (serverName[0] == 0)
        {
            DisplayMessage(IDR_ENTER_SERVER_NAME);
            if (!ReadName(serverName))
                break;

            DisplayMessage(IDR_ENTER_LOGIN_NAME, serverName);
            if (!ReadName(userName))
                break;
        }
        else if (userName[0] == 0)
            strcpy (userName, LOGIN_NAME);

        if (iRet = CAttachToFileServer(serverName, &conn, &bAlreadyAttached))
        {
            if (!SCRIPT_ERROR)
                SCRIPT_ERROR = iRet;
            break;
        }

        // Do not need this connection
        DetachFromFileServer (conn);

        iRet = Login(userName, serverName, password, bReadPassword);

        // Clear out the password
        memset( password, 0, sizeof( password ) );

        //
        // tommye - MS bug 8194 (MCS 240)
        //
        // If we are already attached to this server, then 
        // pretend we were never here - just let everything 
        // succeed without adding this server to the attach
        // list again.
        //

        if (iRet == ERROR_SESSION_CREDENTIAL_CONFLICT) {
            memset( password, 0, sizeof( password ) );
            continue;
        }

        if (iRet)
        {
            // Ask for user name

            DisplayMessage(IDR_ENTER_LOGIN_NAME, serverName);
            if (!ReadName(userName))
                break;

            if (Login(userName, serverName, password, bReadPassword))
            {
                // Clear out the password
                memset( password, 0, sizeof( password ) );
                break;
            }
        }

        AddServerToAttachList( serverName, LIST_3X_SERVER );

    } while (FALSE);

    return(fCommandHandled);
}

/*
 * BREAK ON, enable ctrl-c, ctrl-break
 * BREAK OFF, disable ctrl-c, ctrl-break
 */
int BreakHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (IsOn(lpParam))
    {
        if (!fBreakOn)
            BreakOn();
    }
    else if (IsOff(lpParam))
    {
        if (fBreakOn)
            BreakOff();
    }
    else
        fCommandHandled = FALSE;

    return(fCommandHandled);
}


/*
 * DISPLAY [pathname]file
 * FDISPLAY [pathname]file
 */
int DisplayHandler (char *lpParam)
{
    FILE * stream;

    NotQuotedStringTranslate (lpParam, TRUE);

    if ((stream = fopen (lpParam, "r")) != NULL)
    {
        while (feof (stream) == 0)
            _fputchar(fgetc (stream));

        fclose (stream);
        DisplayMessage(IDR_NEWLINE);
    }

    return(TRUE);
}

/*
 * DOS BREAK ON,  enable ctrl-break checking for DOS
 * DOS BREAK OFF, disable ctrl-break checking for DOS
 */
int DosBreakHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (IsOn (lpParam))
        system ("BREAK ON");
    else if(IsOff (lpParam))
        system ("BREAK OFF");
    else
        fCommandHandled = FALSE;

    return(fCommandHandled);
}

/*
 * Used by SetHandler() and LocalSetHandler()
 * Return TRUE if lpParam points to name = "value", and set
 * lpParam to "name=value" on return.
 * Return FALSE otherwise.
 */
int VerifySetFormat (char *lpParam)
{
    int fCorrect = FALSE;
    char buffer[MAXLEN];
    char *lpBuffer = buffer;

    strcpy (buffer, lpParam);

    do
    {
        while (*lpBuffer != 0 && *lpBuffer != '=' && *lpBuffer != ' ' && *lpBuffer != '\t')
            lpBuffer = NWAnsiNext(lpBuffer);

        lpParam[lpBuffer-buffer]=0;
        strcat (lpParam, "=");

        if (*lpBuffer != '=')
            lpBuffer = RemoveSpaces (lpBuffer);

        if (*lpBuffer != '=')
            break;

        lpBuffer = RemoveSpaces (lpBuffer+1);

        if (*lpBuffer)
        {
            if (!QuotedStringTranslate (lpBuffer))
                break;

            strcat (lpParam, lpBuffer);
        }

        fCorrect = TRUE;
    }while (FALSE);

    return(fCorrect);
}

/*
 * Used by SetHandler() and LocalSetHandler()
 * Set the local environment variable.
 * Don't free the memory allocated because the environment variable will
 * point to free space otherwise.
 */
void SetLocalEnv(char *buffer)
{
    char *lpEnvString;
    lpEnvString = malloc(strlen (buffer) + 1);

    if (lpEnvString == NULL)
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
    else
    {
        strcpy (lpEnvString, buffer);
        _putenv (lpEnvString);
    }
}

/*
 * Set Dos environment variable.
 * [DOS] SET name = "value"
 */
int SetHandler (char *lpParam)
{

    int fCommandHandled;

    fCommandHandled = VerifySetFormat(lpParam);

    if (fCommandHandled)
    {

        if ( _strnicmp( "COMSPEC=", lpParam, strlen( "COMSPEC=" ) ) )
        {
            SetLocalEnv(lpParam);
            SetEnv (lpParam);
        }
    }

    return(fCommandHandled);
}

/*
 * Set local Dos environment variable.
 * [OPTION] [DOS] SET name = "value"
 */
int LocalSetHandler (char *lpParam)
{
    int fCommandHandled;

    fCommandHandled = VerifySetFormat(lpParam);

    if (fCommandHandled)
        if ( _strnicmp( "COMSPEC=", lpParam, strlen( "COMSPEC=" ) ) )
        {
            SetLocalEnv (lpParam);
        }

    return(fCommandHandled);
}

/*
 *  Used by DosVerifyHandler().
 *  Turn /V option of copy on.
 */
void DosVerifyOn(void)
{
}

/*
 *  Used by DosVerifyHandler().
 *  Turn /V option of copy off.
 */
void DosVerifyOff(void)
{
}

/*
 *  DOS VERYFY [ON|OFF], Turn /V option of copy on or off.
 */
int DosVerifyHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (IsOn(lpParam))
        DosVerifyOn();
    else if (IsOff(lpParam))
        DosVerifyOff();
    else
        fCommandHandled = FALSE;

    return(fCommandHandled);
}

/*
 *  DRIVE [driveletter: | n*:], set the default drive to the one specified.
 */
int DriveHandler (char *lpParam)
{
    int fCommandHandled = FALSE;
    WORD driveNum=0, n;
    char *pColon;

    do  // FALSE loop.
    {
        if ((pColon = strchr (lpParam, ':')) == NULL ||
            !EndOfLine (pColon + 1))
            break;

        if (*lpParam == '*')
        {
            *pColon = 0;
            if ((n = (USHORT) atoi (lpParam+1)) < 1)
                break;

            GetFirstDrive (&driveNum);
            driveNum += (n-1);
        }
        else if (pColon == lpParam+1 && isupper(*lpParam))
            driveNum = *lpParam - 'A' + 1;
        else
            break;

        if (_chdrive (driveNum))
            DisplayMessage(IDR_ERROR_SET_DEFAULT_DRIVE, 'A'+driveNum-1);
        else
            ExportCurrentDrive( driveNum );

        fCommandHandled = TRUE;

    } while (FALSE);

    return(fCommandHandled);
}

/*
 * Used by FireHandler()
 * Return TRUE if lpTemp points to the legal end of fire statement, ie
 * [TIMES][COMMENTS]. It also set the *lpTemp to 0 if lpTemp is not NULL.
 * Return FALSE otherwise.
 */
int IsEndOfFireCmd (char *lpTemp)
{
    int fEnd = FALSE;
    do
    {
        if (*lpTemp != 0)
        {
            if (*lpTemp != ' ' && *lpTemp != '\t' && *lpTemp != '\r')
                break;

            *lpTemp = 0;

            lpTemp = RemoveSpaces (lpTemp+1);

            if (!strncmp (lpTemp, "TIMES", 5))
                lpTemp += 5;

            if (!EndOfLine (lpTemp))
                break;
        }

        fEnd = TRUE;
    }while (FALSE);

    return(fEnd);
}

/*
 *  [FIRE | FIRE PHASERS] n TIMES.
 */
int FireHandler (char *lpParam)
{
    char *lpTemp, vartext[MAXLEN];
    int n = 0, nLen;
    time_t ltimeStart, ltimeEnd;

    if (EndOfLine (lpParam))
        n = 1;
    else if (isdigit(*lpParam))
    {
        lpTemp = lpParam;
        while (isdigit(*lpTemp))
            lpTemp++;

        if (IsEndOfFireCmd (lpTemp))
            n = atoi (lpParam);
    }
    else if (*lpParam == '%')
    {
        strcpy (vartext, lpParam+1);
        if (((nLen = VarTranslate (lpParam)) != 0) &&
            EndOfLine (lpParam+1+nLen))
            n = atoi (vartext);
    }

    if (n < 0)
        return(FALSE);
    else if (n == 0)  // Compatible with NetWare.
        n = 1;

    while (n--)
    {
        _beep( 610, 100 );
        _beep( 440, 50 );
        time(&ltimeStart);
        do
        {
            time(&ltimeEnd);
        }while (ltimeEnd-ltimeStart == 0);
    }

    return(TRUE);
}

/*
 * EXIT, terminate login script processing.
 */
int ExitHandler (char *lpParam)
{
    int  n;
    char buffer[16], *argv[10];

    // --- Multi user code merge. Citrix bug fixes ---
    // 11/18/96 cjc (Citrix)  Fix DrWatson for EXIT "" command.
    if (!lpParam || !strcmp(lpParam, "\"\"") ){
        CleanupExit(0);
    }

    if (EndOfLine (lpParam)) {
        CleanupExit(0);
        return(TRUE);
    }
    else if (QuotedStringTranslate (lpParam))
    {
        if (!fGlobalCompatible)
        {
            GetShellVersion (buffer, IDS_MACHINE);
            if (_stricmp (buffer, "IBM_PC"))
            {
                DisplayMessage(IDR_EXIT_NOT_SUPPORTED);
                return(TRUE);
            }
        }

        argv[0] = strtok (lpParam, __SPACES__);

        for (n = 1; n < 9; n++)
        {
            if ((argv[n] = strtok (NULL, __SPACES__)) == NULL)
                break;
        }

        argv[9] = NULL;

        if ((SCRIPT_ERROR = (int) _spawnvp (P_WAIT, argv[0], argv)) == -1)
            DisplayMessage(IDR_BAD_COMMAND);

        CleanupExit (0);
        return(TRUE);
    }
    else
        return(FALSE);
}

BOOL    nwVarNameCompare(LPCSTR src,LPCSTR target)
{
    CHAR    szTempName[64];
    LPSTR   pT = szTempName;

    if (!_strnicmp(src,target,strlen(target))) {

        //
        // try to reject obvious problems like
        // %LJUNK where %L would be fine
        //
        if ( !isalpha(src[strlen(target)]) 
             || IsDBCSLeadByte(src[strlen(target)])
           )

            return 0;

        else 
            return 1;

    }

    strcpy(szTempName,target);

    while (*pT) {
        if (!IsDBCSLeadByte(*pT)) {
            if ('_' == *pT)
                *pT = ' ';
        }
        pT = NWAnsiNext(pT);
    }

    if (!_strnicmp(src,szTempName,strlen(szTempName))) {

        //
        // try to reject obvious problems like
        // %LJUNK where %L would be fine
        //
        if ( !isalpha(src[strlen(target)]) 
            || IsDBCSLeadByte(src[strlen(target)])
           )

            return 0;

        else 
            return 1;

    }

    return 1;
}


/*
 *  Used by the EvalSingleCond() in IfHandler()
 *  Return TRUE if buffer is the right member of condition statement.
 *  *pfCondition is TRUE if the condition meet, FALSE if not.
 *  *ppRest points to the end of the condition statement.
 *  Return FALSE if buffer is not the right member of condition statement.
 */
int MemberOf (char *buffer, int *pfCondition, char **ppRest)
{
    int i, nChar, fSucceed = FALSE;
    char *lpTemp;
    BYTE dataBuffer[128];
    unsigned char moreFlag;
    unsigned char propertyType;
    unsigned long dwObjectId, *pdwGroups;
    char GroupName[MAXLEN];
    unsigned char segment;

    *pfCondition = FALSE;
    do
    {
        if ((buffer = strchr (buffer, '\"')) == NULL)
            break;

        if ((lpTemp = strchr (buffer+1, '\"')) == NULL)
            break;

        nChar = (int) (lpTemp - buffer + 1);

        if (nChar >= MAXLEN)
            break;

        strncpy (GroupName, buffer, nChar);
        GroupName[nChar] = 0;
        if (!QuotedStringTranslate (GroupName))
            break;

        fSucceed = TRUE;
        *pfCondition = FALSE;
        *ppRest = RemoveSpaces (lpTemp+1);

        if (strlen(GroupName) > MAX_NAME_LEN)
            break;

        if ( fNDS )
        {
            if ( IsMemberOfNDSGroup( GroupName ) )
            {
                *pfCondition = TRUE;
                return(TRUE);
            }

        }
        else 
        {
            if (GetBinderyObjectID (CONNECTION_ID,
                                    _strupr(GroupName),
                                    OT_USER_GROUP,
                                    &dwObjectId) )
                goto done;

            //
            // For all the group ID's, try and find a match
            //
            for ( segment = 1, moreFlag = TRUE; moreFlag && segment; segment++ )
            {
                if ( NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                                         LOGIN_NAME,
                                         OT_USER,
                                         "GROUPS_I'M_IN",
                                         segment,
                                         dataBuffer,
                                         &moreFlag,
                                         &propertyType)) 
                    goto done;

                pdwGroups = (unsigned long *) dataBuffer;

                for (i = 0; i < 32 && *(pdwGroups+i); i++)
                {
                    if (*(pdwGroups+i) == dwObjectId)
                    {
                        *pfCondition = TRUE;
                        return(TRUE);
                    }
                }
            }
        }

        *pfCondition = FALSE;
        fSucceed = TRUE;
    } while (FALSE);

done:

    return(fSucceed);
}

/*
 * Used by IsCompare() in EvalSingleCond() in IfHandler()
 * Return the next token.
 */
char *GetNextPart (char *lpTemp)
{
    INT i;

    if (strncmp (lpTemp, "VALUE", 5) == 0)
        lpTemp = RemoveSpaces (lpTemp+5);

    if (*lpTemp == '\"')
    {
        lpTemp++;
        while (*lpTemp != 0 && *lpTemp != '\"')
            lpTemp = NWAnsiNext(lpTemp);

        if (*lpTemp == 0)
            return(NULL);
        else
            lpTemp++;
    }
    else if (*lpTemp == '<')
    {
        while (*lpTemp != 0 && *lpTemp != '>')
            lpTemp = NWAnsiNext(lpTemp);

        if (*lpTemp == 0)
            return(NULL);
        else
            lpTemp++;
    }
    else
    {
        if (*lpTemp == '%')
            lpTemp++;

        for (i = 0; i < (fNDS ? NUMVAR : NUMVAR_3X); i++)
        {
            if (!nwVarNameCompare(lpTemp, varTable[i].VarName))
            {
                lpTemp += strlen(varTable[i].VarName);
                break;
            }
        }

        if (i == (fNDS ? NUMVAR : NUMVAR_3X))
            return(NULL);
    }

    return(lpTemp);
}

/*
 * Used by EvalSingleCond() in IfHandler()
 * left part of buffer could be "...", <...>, or ... for variables.
 * Return TRUE if buffer consists of <left> <compare operator> <right part> +
 * optional rest parts.
 * Return FALSE otherwise.
 */
int IsCompare (char *buffer, char **ppright,
               int *pnLeftLen, int *pnRightLen,
               int *pindex, char **ppRest)
{
    int i, nLen;
    char *lpTemp;

    if ((lpTemp = GetNextPart (buffer)) == NULL)
        return (FALSE);

    *pnLeftLen = (int) (lpTemp-buffer);
    lpTemp = RemoveSpaces (lpTemp);

    for (i = 0; COMPARE_OPERATORS[i][0]; i++)
    {
        nLen = strlen (COMPARE_OPERATORS[i]);

        if (!strncmp(lpTemp, COMPARE_OPERATORS[i], nLen))
        {
            *lpTemp = 0;
            lpTemp += nLen;
            *ppright = RemoveSpaces (lpTemp);
            *pindex = i;
            *ppRest = GetNextPart (*ppright);
            if ( *ppRest == NULL )
                return (FALSE);
            *pnRightLen = (int) (*ppRest - *ppright);
            *ppRest = RemoveSpaces (*ppRest);
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 *  Used by EvalSingleCond() in IfHandler()
 *  Evaluate lpLeft and lpRight and do the compare operation of index
 *  and put the result in *pfCondition.
 *  Return TRUE if succeed, FALSE otherwise.
 */
int Compare (char *lpLeft, char *lpRight,
             int nLeftLen, int nRightLen,
             int index, int *pfCondition)
{
    char szLeft[MAXLEN], szRight[MAXLEN], *lpTemp;
    int  nCompare, fValue = FALSE;

    if (strncmp (lpLeft, "VALUE", 5) == 0)
    {
        fValue = TRUE;
        lpTemp = RemoveSpaces (lpLeft+5);
        nLeftLen -= (int) (lpTemp - lpLeft);
        lpLeft = lpTemp;
    }
    if (strncmp (lpRight, "VALUE", 5) == 0)
    {
        fValue = TRUE;
        lpTemp = RemoveSpaces (lpRight+5);
        nRightLen -= (int) (lpTemp - lpRight);
        lpRight = lpTemp;
    }

    strncpy (szLeft, lpLeft, nLeftLen);
    strncpy (szRight, lpRight, nRightLen);

    szLeft[nLeftLen] = 0;
    szRight[nRightLen] = 0;

    if (!QuotedStringTranslate (szLeft) ||
        !QuotedStringTranslate (szRight))
        return(FALSE);

    if (fValue)
        nCompare = atoi(szLeft)-atoi(szRight);
    else
        nCompare = _stricmp (szLeft, szRight);

    if (IsNotEqual(index))
        *pfCondition = (nCompare != 0);
    else if (IsGreaterOrEqual(index))
        *pfCondition = (nCompare >= 0);
    else if (IsGreater(index))
        *pfCondition = (nCompare > 0);
    else if (IsLessOrEqual(index))
        *pfCondition =  (nCompare <= 0);
    else if (IsLess(index))
        *pfCondition = (nCompare < 0);
    else
        *pfCondition = (nCompare == 0);

    return(TRUE);
}

int IsMemberOf (char *buffer)
{
    int fIsMemberOf = FALSE;

    if (!strncmp (buffer, "MEMBER", 6))
    {
        buffer += 6;
        if (*buffer == ' ' || *buffer == '\t')
        {
            buffer = RemoveSpaces (buffer);
            if (!strncmp (buffer, "OF", 2))
            {
                buffer += 2;
                if (*buffer == ' ' || *buffer == '\t')
                    buffer = RemoveSpaces (buffer);
            }
        }

        fIsMemberOf = (*buffer == '"');
    }

    return(fIsMemberOf);
}

int NotMemberOf (char *buffer)
{
    int fNotMemberOf = FALSE;
    if (!strncmp (buffer, "NOT", 3))
    {
        buffer += 3;
        if (*buffer == ' ' || *buffer == '\t')
        {
            buffer = RemoveSpaces (buffer);
            fNotMemberOf = IsMemberOf (buffer);
        }
    }

    return(fNotMemberOf);
}


/*
 *  Used by IfHandler()
 *  Evaluate one condition clause and put result in *pfCondition, *ppRest
 *  points to the rest part of buffer.
 *  Return TRUE if succeed, FALSE otherwise.
 */
int EvalSingleCond (char *buffer, int *pfCondition)
{
    int index, fSuccess = FALSE, nLeftLen, nRightLen;
    char *pright, *pRest;

    if (IsMemberOf(buffer))
        fSuccess = MemberOf (buffer, pfCondition, &pRest);
    else if (NotMemberOf (buffer))
    {
        fSuccess = MemberOf (buffer, pfCondition, &pRest);
        *pfCondition = !(*pfCondition);
    }
    else if (IsCompare (buffer, &pright, &nLeftLen, &nRightLen, &index, &pRest))
        fSuccess = Compare (buffer, pright, nLeftLen, nRightLen, index, pfCondition);
    else if ( !_strnicmp ("ACCESS_SERVER", buffer, strlen("ACCESS_SERVER")) )
    {
        fSuccess = TRUE;
        *pfCondition = FALSE;
        pRest = buffer + strlen ("ACCESS_SERVER"); 
    }

    if (fSuccess)
        memmove (buffer, pRest, strlen (pRest)+1);
    
    return(fSuccess);
}

int EvaluateCondExpression(char *lpCondExpression, int *pfCondition)
{
    int fSuccess = FALSE, fCond;
    char *lpRight, *lpLeft, *lpOp;

    if (lpRight = strchr (lpCondExpression, ')'))
    {
        *lpRight = 0;
        if ((lpLeft = strrchr (lpCondExpression, '(')) == NULL ||
            !EvaluateCondExpression(lpLeft+1, pfCondition))
            return(FALSE);

        *lpLeft = (*pfCondition)? '1' : '0';
        memmove (lpLeft+1, lpRight+1, strlen (lpRight+1)+1);
        return(EvaluateCondExpression (lpCondExpression, pfCondition));
    }

    if (lpOp = strrchr (lpCondExpression, '+'))
    {
        *lpOp = 0;

        if (!EvaluateCondExpression (lpCondExpression, pfCondition) ||
            !EvaluateCondExpression (lpOp+1, &fCond))
            return(FALSE);

        *pfCondition = (*pfCondition || fCond);
        return(TRUE);
    }

    if (lpOp = strrchr (lpCondExpression, '*'))
    {
        *lpOp = 0;

        if (!EvaluateCondExpression (lpCondExpression, pfCondition) ||
            !EvaluateCondExpression (lpOp+1, &fCond))
            return(FALSE);

        *pfCondition = (*pfCondition && fCond);
        return(TRUE);
    }

    if (lpOp = strrchr (lpCondExpression, '^'))
    {
        *lpOp = 0;

        if (!EvaluateCondExpression (lpCondExpression, pfCondition) ||
            !EvaluateCondExpression (lpOp+1, &fCond))
            return(FALSE);

        *pfCondition = !(*pfCondition && fCond);
        return(TRUE);
    }

    if (!strcmp (lpCondExpression, "1"))
    {
        *pfCondition = TRUE;
        return(TRUE);
    }
    else if (!strcmp (lpCondExpression, "0"))
    {
        *pfCondition = FALSE;
        return(TRUE);
    }
    else
        return(FALSE);
}

/*
 *  Used by IfHandler()
 *  Evaluate up to 10 conditions.
 *  Return TRUE if succeed, FALSE otherwise.
 *  On return, buffer stores whatever after conditional expressions
 *  without leading spaces.
 */
int EvaluateCond(char *buffer, int *pfCondition)
{
    int fCondition = TRUE, fCurrent, fSucceed = FALSE, nCount;
    char CondExpression[MAXLEN], *lpCond = CondExpression, *lpBuffer = buffer;

    for (nCount = 0; nCount < 10; nCount++)
    {
        while (*lpBuffer == '(')
        {
            *lpCond = *lpBuffer;
            lpCond++;
            lpBuffer++;
        }

        lpBuffer = RemoveSpaces (lpBuffer);

        if (!EvalSingleCond (lpBuffer, &fCurrent))
            break;

        *lpCond = fCurrent? '1' : '0';
        lpCond++;

        while (*lpBuffer == ')')
        {
            *lpCond = *lpBuffer;
            lpCond++;
            lpBuffer++;
        }

        lpBuffer = RemoveSpaces (lpBuffer);

        if (*lpBuffer == ',')
        {
            *lpCond = '*';
            lpCond++;

            lpBuffer = RemoveSpaces (lpBuffer+1);

            if (!strncmp (lpBuffer, "AND", 3))
                lpBuffer = RemoveSpaces (lpBuffer+3);
        }
        else if (!strncmp (lpBuffer, "AND", 3))
        {
            *lpCond = '*';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+3);
        }
        else if (!strncmp (lpBuffer, "&&", 2))
        {
            *lpCond = '*';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+2);
        }
        else if ( (!strncmp (lpBuffer, "OR", 2)) ||
                  (!strncmp (lpBuffer, "||", 2)) )
        {
            *lpCond = '+';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+2);
        }
        /*
         * A NOR expression is documented in some books, but isn't
         * implemented in the 4X login.exe I have.
         */
        else if (!strncmp (lpBuffer, "NOR", 3))
        {
            *lpCond = '^';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+3);
        }
        else
        {
            fSucceed = TRUE;
            *lpCond = 0;
            lpBuffer = RemoveSpaces (lpBuffer);
            memmove (buffer, lpBuffer, strlen (lpBuffer)+1);
            break;
        }
    }

    if (fSucceed)
        fSucceed = EvaluateCondExpression (CondExpression, pfCondition);

    return(fSucceed);
}

/*
 *  If statement handler.
 */
int IfHandler (char *lpParam)
{
    int fCommandHandled = FALSE, fCondition;

    do
    {
        if (nCondIndex+1 == MAX_NUM_IF)
        {
            DisplayMessage(IDR_IF_TOO_DEEP);
            fGlobalExitFlag = TRUE;
            fGlobalIfTooDeep = TRUE;
            return TRUE;
        }

        if (EndOfLine (lpParam))
            break;

        if (!EvaluateCond (lpParam, &fCondition))
            break;

        if (!strncmp (lpParam, "THEN", 4))
        {
            lpParam = RemoveSpaces (lpParam+4);

            if (!strncmp (lpParam, "BEGIN", 5))
            {
                lpParam += 5;

                if (!EndOfLine (lpParam))
                    break;
            }
            else if((!strncmp (lpParam, "DO", 2)) &&
                    (strncmp (lpParam, "DOS", 3)))
            {
                lpParam += 2;
                if (!EndOfLine (lpParam))
                    break;
            }
        }
        else if (!strncmp (lpParam, "BEGIN", 5))
        {
            lpParam += 5;

            if (!EndOfLine (lpParam))
                break;
        }

        if (EndOfLine (lpParam))
        {
            nCondIndex++;
            aCondVal[nCondIndex] =
                (nCondIndex > 0 && !aCondVal[nCondIndex-1])?
                FALSE : fCondition;
        }
        else
        {
            if (fCondition && (nCondIndex == -1 || aCondVal[nCondIndex]))
                CommandDispatch (lpParam);
        }

        fCommandHandled = TRUE;

    }while (FALSE);

    return(fCommandHandled);
}

/*
 *  Else statement handler.
 */
int ElseHandler (char *lpParam)
{
    int fCommandHandled = FALSE;

    if (EndOfLine (lpParam))
    {
        if (nCondIndex == 0 ||
            nCondIndex > 0 && aCondVal[nCondIndex-1])
            aCondVal[nCondIndex] = !aCondVal[nCondIndex];

        fCommandHandled = TRUE;
    }

    return(fCommandHandled);
}

/*
 *  End statement handler.
 */
int EndHandler (char *lpParam)
{
    int fCommandHandled = FALSE;

    if (EndOfLine (lpParam))
    {
        if (nCondIndex > -1)
            nCondIndex--;

        fCommandHandled = TRUE;
    }

    return(fCommandHandled);
}

/*
 *  INCLUDE [pathname]filename
 */
int IncludeHandler (char *lpParam)
{
    int fCommandHandled = FALSE, nFileSize;
    char *lpLoginScript, *lpTemp;
    int  i, nCondIndexCopy;
    int  aCondValCopy[MAX_NUM_IF];
    int iRet;

    //
    //  Save off the old globals that track where we are.
    //

    LABEL_LIST *pLabelList = pGlobalLabelList;
    char *lpLine = lpGlobalLine;
    char *lpLineSeparator = lpGlobalLineSeparator;
    int  fHaveNulledLineSeparator = fGlobalHaveNulledLineSeparator;

    pGlobalLabelList = NULL;        // so that we don't free it.

    do
    {
        if (strtok (lpParam, __SPACES__) == NULL)
            break;

        lpTemp = strtok(NULL, __SPACES__);
        if (lpTemp && !EndOfLine (lpTemp))
            break;

        fCommandHandled = TRUE;

        // 8/6/96 cjc (Citrix merge) Fix problem with UNC names causing errors.
        NotQuotedStringTranslate(lpParam, FALSE);
//        NotQuotedStringTranslate(lpParam, TRUE);

        nCondIndexCopy = nCondIndex;
        for (i = 0; i < MAX_NUM_IF; i++)
            aCondValCopy[i] = aCondVal[i];

        /*
         * First we try a NDS object and then a file
         */
        iRet = FALSE;
        if ( fNDS ) 
        {
            iRet = ProcessLoginScriptProperty( lpParam );
            if ( !iRet )
            {
                char Fixup[MAXLEN];
                char * ptr;
                /*
                 * Strip off the . in front and add context at end
                 */
                ptr = RemoveSpaces (lpParam);
                if ( *ptr == '.' ) {
                    ptr++;
                    strncpy( Fixup, ptr, MAXLEN );
                }
                else {
                    strncpy( Fixup, ptr, MAXLEN );
                    if ( Fixup[strlen(Fixup)-1] != '.' )
                        strcat( Fixup, "." );
                    strcat( Fixup, LOGIN_CONTEXT );
                }
                iRet = ProcessLoginScriptProperty( Fixup );
            }
        }

        if ( !fNDS || !iRet )
        {
            nFileSize = NWGetFileSize (lpParam);
            if (nFileSize == 0)
            {
                DisplayMessage(IDR_ERROR_OPEN_SCRIPT, lpParam);
                break;
            }

            // user login script exists.
            lpLoginScript = malloc (nFileSize);
            if (lpLoginScript == NULL)
            {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                break;
            }

            LoadFile (lpParam, lpLoginScript, nFileSize);

            // dfergus 19 Apr 2001 - 192395
            // check lpLoginScript for contents
            //
            if( lpLoginScript[0] )
                ProcessLoginScript (lpLoginScript);

            free (lpLoginScript);
        }

        fGlobalExitFlag = FALSE;

        nCondIndex = nCondIndexCopy;
        for (i = 0; i < MAX_NUM_IF; i++)
            aCondVal[i] = aCondValCopy[i];

    }while (FALSE);

    //
    //  restore the globals that track where we are in the file.
    //

    pGlobalLabelList = pLabelList;
    lpGlobalLine = lpLine;
    lpGlobalLineSeparator = lpLineSeparator;
    fGlobalHaveNulledLineSeparator = fHaveNulledLineSeparator;


    return(fCommandHandled);
}

/*
 *  Map command handler.
 */
int MapHandler (char *lpParam)
{
    char buffer[MAXLEN]="";

    strcpy( buffer, lpParam );

    NotQuotedStringTranslate( buffer, TRUE );

    Map( buffer );

    return(TRUE);
}

/*
 *  PAUSE or WAIT.
 */
int PauseHandler (char *lpParam)
{
    int fCommandHandled = FALSE;

    if (EndOfLine (lpParam))
    {
        //Empty kb buffer first.
        while (_kbhit())
            _getch();

        DisplayMessage(IDR_STRIKE_KEY);
        _getch();
        DisplayMessage(IDR_NEWLINE);
        fCommandHandled = TRUE;
    }

    return(fCommandHandled);
}

/*
 * Used by WriteHandler().
 * Return TRUE if buffer ends with ';'. Set it to 0
 * Return FALSE otherwise.
 */
int EndWithSemicolon (char *buffer)
{
    char *lpLastSemicolon, *lpRest;
    lpLastSemicolon = strrchr (buffer, ';');
    if (lpLastSemicolon)
    {
        lpRest = RemoveSpaces (lpLastSemicolon+1);
        if (*lpRest == 0)
        {
            *lpLastSemicolon = 0;
            return(TRUE);
        }
    }

    return(FALSE);
}

char *ConvertPercent (char *buffer)
{
    char *lpPercent, *lpBuffer = buffer;
    int   nPercent = 0;

    while (lpPercent = strchr (lpBuffer, '%'))
    {
        nPercent++;
        lpBuffer = lpPercent+1;
    }

    if (nPercent == 0)
        return(NULL);

    lpBuffer = malloc (strlen(buffer)+nPercent+1);
    if (lpBuffer == NULL)
        return(NULL);

    strcpy (lpBuffer, buffer);

    lpPercent = strchr (lpBuffer, '%');

    while (lpPercent)
    {
        memmove (lpPercent+1, lpPercent, strlen (lpPercent)+1);
        lpPercent = strchr ( lpPercent+2, '%');
    }

    return(lpBuffer);
}

/*
 *  WRITE text, display a text message on the screen.
 */
int WriteHandler (char *lpParam)
{
    int fNewLine;
    char *lpBuffer;

    if (*lpParam == 0)
    {
        DisplayMessage(IDR_NEWLINE);
        return(TRUE);
    }

    fNewLine = !EndWithSemicolon (lpParam);

    if (!QuotedStringTranslate (lpParam))
        return FALSE;

    lpBuffer = ConvertPercent (lpParam);
    if (lpBuffer == NULL)
    {
        DisplayOemString(lpParam);
    }
    else
    {
        DisplayOemString(lpBuffer);
        free (lpBuffer);
    }

    if (fNewLine)
        DisplayMessage(IDR_NEWLINE);

    return(TRUE);
}

/*
 * Used by ShiftHandler().
 * Return TURE if the line is all numbers + [comments]
 * Return FALSE otherwise.
 */
int AreAllNumbers(char *buffer)
{
    while (isdigit(*buffer))
        buffer++;

    return(EndOfLine (buffer));
}

/*
 *  Set the nGlobalShiftDelta variable.
 */
int ShiftHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (EndOfLine (lpParam))
        nGlobalShiftDelta++;
    else if (*lpParam == '-')
    {
        lpParam = RemoveSpaces (lpParam+1);
        if (!AreAllNumbers(lpParam))
            fCommandHandled = FALSE;
        else
            nGlobalShiftDelta -= atoi (lpParam);
    }
    else
    {
        if (*lpParam == '+')
            lpParam = RemoveSpaces (lpParam+1);

        if (!AreAllNumbers(lpParam))
            fCommandHandled = FALSE;
        else
            nGlobalShiftDelta += atoi (lpParam);
    }

    return(fCommandHandled);
}

/*
 *  Set the machine name.
 */
int MachineHandler   (char *lpParam)
{
    int nLen, i;

    if (*lpParam != '=')
        return(FALSE);

    lpParam = RemoveSpaces (lpParam+1);
    if (!QuotedStringTranslate(lpParam))
        return(FALSE);

    nLen = strlen (lpParam);
    for (i = nLen; i < 15; i++)
        *(lpParam+i) = ' ';

    *(lpParam+15) = 0;

    return(TRUE);
}

/*
 *  Set the fGlobalCompatible variable.
 */
int CompatibleHandler(char *lpParam)
{
    if (!EndOfLine (lpParam))
        return(FALSE);

    fGlobalCompatible = TRUE;
    return(TRUE);
}

/*
 *  Clear the screen
 */
int ClearHandler(char *lpParam)
{
    CONSOLE_SCREEN_BUFFER_INFO coninfo;
    COORD scrolltarget;
    CHAR_INFO chinfo;
    SMALL_RECT scrollrect;

    if ( hconout == INVALID_HANDLE_VALUE )
    {
        hconout = CreateFile( L"CONOUT$", GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                              OPEN_EXISTING, 0, NULL );
    }

    if ( hconout == INVALID_HANDLE_VALUE )
        return TRUE;

    GetConsoleScreenBufferInfo( hconout, &coninfo );

    scrolltarget.Y = (SHORT)(0 - coninfo.dwSize.Y);
    scrolltarget.X = 0;

    scrollrect.Top = 0;
    scrollrect.Left = 0;
    scrollrect.Bottom = coninfo.dwSize.Y;
    scrollrect.Right =  coninfo.dwSize.X;
    chinfo.Char.AsciiChar = ' ';
    chinfo.Attributes = coninfo.wAttributes;
    ScrollConsoleScreenBufferA( hconout, &scrollrect, NULL,
                               scrolltarget, &chinfo);

    coninfo.dwCursorPosition.X = 0;
    coninfo.dwCursorPosition.Y = 0;

    SetConsoleCursorPosition( hconout, coninfo.dwCursorPosition );
    return(TRUE);
}

/*
 *  Display the Last Login Time 
 */

int LastLoginTimeHandler(char *lpParam)
{
    BYTE dataBuffer[128];
    unsigned char moreFlag;
    unsigned char propertyType;

    if ( fNDS )
    {
        nwShowLastLoginTime();
    }
    else
    {
        SYSTEMTIME st;
        WCHAR DateBuffer[TIMEDATE_SIZE];
        WCHAR TimeBuffer[TIMEDATE_SIZE];

        NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                             LOGIN_NAME,
                             OT_USER,
                             "MISC_LOGIN_INFO",
                             1,
                             dataBuffer,
                             &moreFlag,
                             &propertyType);

        /**
            Get the data into SYSTEMTIME format:
                0 = year
                1 = month
                2 = day
                3 = hour
                4 = minute
                5 = second
                6 = day of week
        **/

        memset(&st, 0, sizeof(SYSTEMTIME));
        st.wYear        = dataBuffer[0];
        st.wMonth       = dataBuffer[1];
        st.wDay         = dataBuffer[2];
        st.wHour        = dataBuffer[3];
        st.wMinute      = dataBuffer[4];
        st.wSecond      = dataBuffer[5];
        st.wDayOfWeek   = dataBuffer[6];

        /** Get the info based on the local settings **/

        GetDateFormat(
                    LOCALE_USER_DEFAULT,
                    DATE_LONGDATE,
                    &st,
                    NULL,
                    TimeBuffer,
                    TIMEDATE_SIZE);

        GetTimeFormat(
                    LOCALE_USER_DEFAULT,
                    0,
                    &st,
                    NULL,
                    TimeBuffer,
                    TIMEDATE_SIZE);

       DisplayMessage(IDR_LASTLOGIN, DateBuffer, TimeBuffer);
    }

    return(TRUE);
}



/*
 *  Change and/or display the current context.
 */
int ContextHandler (char *lpParam)
{
    unsigned char Buffer[MAXLEN];
    unsigned char * ptr;
    unsigned char CurrentContext[MAXLEN];

    if ( *lpParam ) 
    {
        NotQuotedStringTranslate(lpParam, TRUE);

        ptr = RemoveSpaces (lpParam);

        if ( NDSCanonicalizeName( lpParam, Buffer, MAXLEN, TRUE ) )
        {
            DisplayMessage(IDR_CHANGE_CONTEXT_ERROR, lpParam);
            return(TRUE);
        }

        if ( NDSChangeContext( Buffer ) )
        {
            DisplayMessage(IDR_CHANGE_CONTEXT_ERROR, lpParam);
            return(TRUE);
        }
    }

    if ( NDSGetContext( CurrentContext, MAXLEN ) )
    {
        DisplayMessage(IDR_GET_CONTEXT_ERROR);
    }
    else
    {
        DisplayMessage(IDR_DISPLAY_CONTEXT, CurrentContext);
    }
    return(TRUE);
}

/*
 *  Do nothing. Return TRUE so the the command will not
 *  be considered as bad.
 */
int ScriptServerHandler (char *lpParam)
{
    return(TRUE);
}

/*
 *  If this is a 4X login, do not execute the default login script.
 */
int NoDefaultHandler (char *lpParam)
{
    if ( fNDS )
        fNoDefaultLoginScript = TRUE;
    return(TRUE);
}

/*
 *  Do nothing. Return TRUE so the the command will not
 *  be considered as bad.
 */
int NullHandler (char *lpParam)
{
    return(TRUE);
}

#define NUMBER_ARGUMENTS 20

/*
 *   External commands start with '#', such as #command /c cls
 */
void ExternalCmdHandler (char *lpCommand)
{
    int n;
    int i;
    unsigned int CommandLength;
    char *lpCmdName, *argv[NUMBER_ARGUMENTS];

    for ( n = 0; n < NUMBER_ARGUMENTS; n++ )
        argv[n] = NULL;

    if ((nCondIndex == -1) || aCondVal[nCondIndex])
    {
        //Convert variables first.
        NotQuotedStringTranslate(lpCommand, FALSE);

        lpCommand = RemoveSpaces(lpCommand+1);
        lpCmdName = strtok (lpCommand, __SPACES__);

        lpCmdName = NTNWtoUNCFormat(lpCmdName);

        argv[0] = lpCmdName;

        for (n = 1; n < NUMBER_ARGUMENTS - 1; n++)
        {
            if ((argv[n] = strtok (NULL, __SPACES__)) == NULL)
                break;
        }


        /*
         * Capture command 
         */
        CommandLength = strlen( lpCommand );

        /*
         * First see if a COMMAND.COM is invoked
         */
        if ( ( ( CommandLength >= strlen("COMMAND.COM") )  &&
             ( !_stricmp( &lpCommand[CommandLength-strlen("COMMAND.COM")], "COMMAND.COM") ) ) ||
                 ( ( CommandLength >= strlen("COMMAND") )  &&
                 ( !_stricmp( &lpCommand[CommandLength-strlen("COMMAND")], "COMMAND") ) ) )
        {
            /*
             * Search for the CAPTURE argument
             */
            for ( i = 1; i < n; i++ )
            {
                CommandLength = strlen( argv[i] );
                if ( ( ( CommandLength >= strlen("CAPTURE.EXE") )  &&
                       ( !_stricmp( &(argv[i])[CommandLength-strlen("CAPTURE.EXE")], "CAPTURE.EXE") ) ) ||
                     ( ( CommandLength >= strlen("CAPTURE") )  &&
                     ( !_stricmp( &(argv[i])[CommandLength-strlen("CAPTURE")], "CAPTURE") ) ) ) {
                    Capture( argv + i, n - i );
                    return;
                }
            }
        }
        else
        {
            /*
             * Is this a CAPTURE command?
             */
            if ( ( ( CommandLength >= strlen("CAPTURE.EXE") )  &&
                 ( !_stricmp( &lpCommand[CommandLength-strlen("CAPTURE.EXE")], "CAPTURE.EXE") ) ) ||
                 ( ( CommandLength >= strlen("CAPTURE") )  &&
                 ( !_stricmp( &lpCommand[CommandLength-strlen("CAPTURE")], "CAPTURE") ) ) ) {
                    Capture( argv, n );
                    return;
            }
        }

        if ((SCRIPT_ERROR = (int) _spawnvp (P_WAIT, lpCmdName, argv)) == -1)
        {
            if (errno == ENOENT)
                DisplayMessage(IDR_ENOENT, lpCommand);
            else
                DisplayMessage(IDR_CANNOT_EXECUTE, lpCommand);
        }
    }
}

/*
 *  Printe out the bad command line.
 */
void BadCommandHandler (char *lpCommand)
{
    DisplayMessage(IDR_SCRIPT_ERROR);
    DisplayMessage(IDR_ORIGINAL_LINE_WAS, lpCommand);
}


/*
 *  Swap the object id.
 */
DWORD SwapLong(DWORD number)
{
    BYTE    *p, tmp[4];

    p = (BYTE *)&number;

    tmp[0] = p[3];
    tmp[1] = p[2];
    tmp[2] = p[1];
    tmp[3] = p[0];

    return(*(DWORD *)tmp);
}

/*
 *  Remove leading spaces, including tabs.
 */
char *RemoveSpaces (char * buffer)
{
    while (*buffer == ' ' || *buffer == '\t')
        buffer++;
    return(buffer);
}

/*
 *  Return TRUE if buffer points to the end of the lind, FALSE otherwise.
 */
int EndOfLine (char *buffer)
{
    int fEndOfLine = FALSE;

    buffer = RemoveSpaces (buffer);

    if (*buffer == '\0' ||
        *buffer == ';' ||
        *buffer == '*' ||
        *buffer == '\r')
        fEndOfLine = TRUE;

    return(fEndOfLine);
}

/*
 *  Return TRUE if lpParam points to "ON", FALSE otherwise.
 */
int IsOn (char *lpParam)
{
    int fOn = FALSE;

    if (!strncmp (lpParam, "ON", 2))
    {
        lpParam += 2;
        fOn = EndOfLine (lpParam);
    }

    return(fOn);
}

/*
 *  Return TRUE if lpParam points to "OFF", FALSE otherwise.
 */
int IsOff (char *lpParam)
{
    int fOff = FALSE;

    if (!strncmp (lpParam, "OFF", 3))
    {
        lpParam += 3;
        fOff = EndOfLine (lpParam);
    }

    return(fOff);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the value of time variable specified by index.
 */
void GetTime (char *buffer, int index)
{
    time_t     currentTime;
    struct tm *tmCurrentTime;

    time (&currentTime);
    tmCurrentTime = localtime(&currentTime);

    switch (index)
    {
    case IDS_DAY:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_mday);
        break;
    case IDS_DAY_OF_WEEK:
        LoadStringA(NULL, IDR_SUNDAY+tmCurrentTime->tm_wday, buffer, 256);
        break;
    case IDS_MONTH:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_mon+1);
        break;
    case IDS_MONTH_NAME:
        LoadStringA(NULL, IDR_JANUARY+tmCurrentTime->tm_mon, buffer, 256);
        break;
    case IDS_NDAY_OF_WEEK:
        sprintf (buffer, "%d\0", tmCurrentTime->tm_wday+1);
        break;
    case IDS_SHORT_YEAR:
        sprintf (buffer, "%04d\0", tmCurrentTime->tm_year+1900);
        strcpy (buffer, buffer+2);
        break;
    case IDS_YEAR:
        sprintf (buffer, "%04d\0", tmCurrentTime->tm_year+1900);
        break;
    case IDS_AM_PM:
        LoadStringA(NULL, IDR_AM+(tmCurrentTime->tm_hour>=12? 1:0),buffer, 256);
        break;
    case IDS_GREETING_TIME:
        if (tmCurrentTime->tm_hour >= 6 && tmCurrentTime->tm_hour < 12)
            index=0;
        else if (tmCurrentTime->tm_hour >= 12 && tmCurrentTime->tm_hour < 18)
            index=1;
        else
            index=2;

        LoadStringA(NULL, IDR_GREETING_MORNING+index, buffer, 256);
        break;
    case IDS_HOUR:
        if (tmCurrentTime->tm_hour > 12)
            tmCurrentTime->tm_hour -= 12;
        sprintf (buffer, "%d\0", tmCurrentTime->tm_hour);
        break;
    case IDS_HOUR24:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_hour);
        break;
    case IDS_MINUTE:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_min);
        break;
    case IDS_SECOND:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_sec);
        break;
    default:
        *buffer = 0;
    }
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer login user's full name.
 */
void GetFullName (char *buffer)
{
    unsigned int  iRet = 0;
    unsigned char moreFlag;
    unsigned char propertyType;

    if ( fNDS )
    {
        NDSGetVar ( "Full Name", buffer, 128 );
        if ( buffer[0] == '\0' )
            strcpy (buffer, "* Unknown *");
    }
    else
    {
        iRet = NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                                    LOGIN_NAME,
                                    OT_USER,
                                    "IDENTIFICATION",
                                    1,
                                    buffer,
                                    &moreFlag,
                                    &propertyType);
        if (iRet)
            strcpy (buffer, "* Unknown *");
    }
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer login user's object id.
 */
void GetUserID (char *buffer)
{
    unsigned long dwObjectID = 0;

    if ( fNDS )
        dwObjectID = GUserObjectID;
    else
        NTGetUserID( CONNECTION_ID, &dwObjectID );
    sprintf (buffer, "%lx\0", SwapLong(dwObjectID));
    _strupr (buffer);
}

unsigned int GetDays (unsigned int year, BYTE month, BYTE date)
{
    unsigned int i, days = 0;

    for (i = 1; i < month; i++)
    {
        if (i == 2)
            days += (year%4)? 28 : 29;
        else if (i == 4 || i == 6 || i == 9 || i == 11)
            days += 30;
        else
            days += 31;
    }

    days += date;
    return(days);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the days in which the password expires.
 */
void GetPasswordExpires (char *buffer)
{
    unsigned int  iRet = 0;
    unsigned int  iRet2 = 0;
    unsigned char moreFlag;
    unsigned int  yearCurrent, yearEnd, days;
    BYTE          monthCurrent, dayCurrent, monthEnd, dayEnd;
    unsigned int exptime = 0, logintime = 0;
    unsigned char propertyType;


    if ( fNDS )
    {
        iRet = NDSGetUserProperty ("Password Expiration Time", (PBYTE)&exptime,
                             4, NULL, NULL);
        iRet2 = NDSGetUserProperty ("Login Time", (PBYTE)&logintime,
                             4, NULL, NULL);

        if ( ( exptime && logintime ) && !iRet && !iRet2 )
        {
            if ( exptime <= logintime )
                strcpy( buffer, "0" );
            else
                sprintf( buffer, "%u", ((exptime-logintime)/(60*60*24)) + 1 );
        }
        else
        {
            sprintf( buffer, "%u", 0x7FFF );
        }
    }
    else 
    {
        NTGetTheDate( &yearCurrent, &monthCurrent, &dayCurrent );
        NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                             LOGIN_NAME,
                             OT_USER,
                             "LOGIN_CONTROL",
                             1,
                             buffer,
                             &moreFlag,
                             &propertyType);

        yearEnd = 1900 + buffer[4];
        monthEnd = buffer[5];
        dayEnd = buffer[6];

        if (monthEnd == 0)
            days = (((yearCurrent%4)? 365 : 366) - GetDays (yearCurrent, monthCurrent, dayCurrent));
        else if (yearEnd == yearCurrent)
        {
            if (monthEnd < monthCurrent ||
                (monthEnd == monthCurrent && dayEnd <= dayCurrent))
                days = 0;
            else
                days = GetDays (yearEnd, monthEnd, dayEnd) - GetDays (yearCurrent, monthCurrent, dayCurrent) - 1;
        }
        else
            days = ((yearCurrent%4)? 364 : 365) + GetDays (yearEnd, monthEnd, dayEnd) - GetDays (yearCurrent, monthCurrent, dayCurrent);

        sprintf (buffer, "%u", days);
    }
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer value of the dos environment variable.
 *  If the variable is not found, buffer is set to be empty string.
 */
void GetDosEnv (char *buffer)
{
    char *lpTemp;

    // This could be called from "%<x>" where x is not upcase. capitalize
    // the string first to be sure.
    _strupr(buffer);

    lpTemp = strchr (buffer, '>');
    if (lpTemp) {
        *lpTemp = 0;

        lpTemp = getenv (buffer+1);

        if (lpTemp && (strlen(lpTemp) < MAXLEN)) {
            strcpy (buffer, lpTemp);
            return;
        }
    }

    *buffer = 0;
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the 8 bytes network address.
 */
void GetNetWorkAddr (char *buffer)
{
    unsigned char   internetAddress[10] = {0,0,0,0,0,0,0,0,0,0};

    GetInternetAddress (CONNECTION_ID,
                        CONNECTION_NUMBER,
                        internetAddress);

    sprintf (buffer,
             "%02X%02X%02X%02X\0",
             internetAddress[0],
             internetAddress[1],
             internetAddress[2],
             internetAddress[3] );
}


/*
 *  Used by VarTranslate().
 *  Copy to buffer the 12 bytes node address to buffer.
 */
void GetPStation (char *buffer)
{
    unsigned char   internetAddress[10] = {0,0,0,0,0,0,0,0,0,0};

    GetInternetAddress (CONNECTION_ID,
                        CONNECTION_NUMBER,
                        internetAddress);

    sprintf (buffer,
             "%02X%02X%02X%02X%02X%02X\0",
             internetAddress[4],
             internetAddress[5],
             internetAddress[6],
             internetAddress[7],
             internetAddress[8],
             internetAddress[9]);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the decimal string representing the remaining account
 *  balance
 */
void GetAccountBalance (char *buffer)
{
    DWORD balance;
    BYTE dataBuffer[128];
    unsigned char moreFlag;
    unsigned char propertyType;
    unsigned int err;

    if ( fNDS )
    {
        err = NDSGetUserProperty ("Account Balance", dataBuffer,128, NULL, NULL);
    }
    else
    {
        err = NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                                   LOGIN_NAME,
                                   OT_USER,
                                   "ACCOUNT_BALANCE",
                                   1,
                                   dataBuffer,
                                   &moreFlag,
                                   &propertyType);
    }

    if ( err )
        balance = 0;
    else 
        balance = *((DWORD *)dataBuffer); 

    sprintf (buffer, "%d", balance);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer MACHINE, SMACHINE, OS, OS_VERSION or SHELL_TYPE
 *  to buffer according to index.
 */
void GetShellVersion(char *buffer, int index)
{
    static char szTemp[40];
    char *lpTemp;
    BYTE shellmajor, shellminor, shellnum;

    NTGetVersionOfShell( szTemp, &shellmajor, &shellminor, &shellnum );

    lpTemp = szTemp;

    switch (index)
    {
    case IDS_OS:
        strcpy (buffer, lpTemp);
        break;
    case IDS_OS_VERSION:
        lpTemp += (strlen (lpTemp)+1);
        strcpy (buffer, lpTemp);
        break;
    case IDS_MACHINE:
        lpTemp += (strlen (lpTemp)+1);
        lpTemp += (strlen (lpTemp)+1);
        strcpy (buffer, lpTemp);
        break;
    case IDS_SMACHINE:
        lpTemp += (strlen (lpTemp)+1);
        lpTemp += (strlen (lpTemp)+1);
        lpTemp += (strlen (lpTemp)+1);
        strcpy (buffer, lpTemp);
        break;
    case IDS_SHELL_TYPE:
    case IDS_SHELL_VERSION:
        sprintf (buffer, "V%d.%d%d%c", shellmajor, shellminor/10, shellminor%10, 'A'+shellnum);
        break;
    default:
        *buffer = 0;
        break;
    }
}

void GetArgv(char *buffer)
{
    int n;

    n = atoi (buffer)+nGlobalShiftDelta;

    if (n == 0)
        strcpy (buffer, PREFERRED_SERVER);
    else if (n == 1)
        strcpy (buffer, LOGIN_NAME);
    else if (n > 1 && n < ARGC)
        strcpy (buffer, ARGV[n]);
    else
        *buffer = 0;
}

/*
 *  vartext is an array of size MAXLEN.
 *  vartext points to a string starts with a variable on enter.
 *  vartext stores the value of the variable on exit.
 *  Return the lenth of the variable.
 */
int VarTranslate(char *vartext)
{
    int i, nVarLen = 0;

    for (i = 0; i < (fNDS ? NUMVAR : NUMVAR_3X); i++)
    {
        if (!nwVarNameCompare(vartext, varTable[i].VarName))
        {
            nVarLen = strlen(varTable[i].VarName);

            switch ( i )
            {
            case IDS_DAY_OF_WEEK:
            case IDS_DAY:
            case IDS_MONTH_NAME:
            case IDS_MONTH:
            case IDS_NDAY_OF_WEEK:
            case IDS_SHORT_YEAR:
            case IDS_YEAR:
            case IDS_AM_PM:
            case IDS_GREETING_TIME:
            case IDS_HOUR24:
            case IDS_HOUR:
            case IDS_MINUTE:
            case IDS_SECOND:
                GetTime (vartext, i);
                break;
            case IDS_FULL_NAME:
                GetFullName (vartext);
                break;
            case IDS_LOGIN_NAME:
                strcpy (vartext, LOGIN_NAME);
                /*
                 *  4X LOGIN.EXE always truncates and replaces spaces
                 *  with underscores.   There was a report that some
                 *  versions of 3X LOGIN.EXE do this also. 
                 */
                if ( fNDS )
                {
                    int i;
                    vartext[8] = '\0';
                    for ( i = 0; i < 8; i++ )
                        if ( vartext[i] == ' ' )
                            vartext[i] = '_';
                }
                break;
            case IDS_USER_ID:
                GetUserID (vartext);
                break;
            case IDS_PASSWORD_EXPIRES:
                GetPasswordExpires (vartext);
                break;
            case IDS_NETWORK_ADDRESS:
            case IDS_NETWORK:
                GetNetWorkAddr (vartext);
                break;
            case IDS_FILE_SERVER:
                strcpy (vartext, PREFERRED_SERVER);
                break;
            case IDS_ACCESS_SERVER:
            case IDS_ACCESS:
                strcpy (vartext, "0");
                break;
            case IDS_ERROR_LEVEL:
            case IDS_ERRORLEVEL:
                sprintf (vartext, "%u", SCRIPT_ERROR);
                break;
            case IDS_MACHINE:
            case IDS_OS_VERSION:
            case IDS_OS:
            case IDS_SMACHINE:
            case IDS_SHELL_TYPE:
            case IDS_SHELL_VERSION:
                GetShellVersion (vartext, i);
                break;
            case IDS_STATION:
                sprintf (vartext, "%d", CONNECTION_NUMBER);
                break;
            case IDS_P_STATION:
                GetPStation (vartext);
                break;
            case IDS_LAST_NAME:
            case IDS_SURNAME:
                strcpy (vartext, LAST_NAME);
                break;
            case IDS_LOGIN_CONTEXT: 
                strcpy (vartext, LOGIN_CONTEXT);
                break;
            case IDS_NETWARE_REQUESTER:
            case IDS_REQUESTER_VERSION:
            case IDS_DOS_REQUESTER:
            case IDS_REQUESTER:
                strcpy (vartext, REQUESTER_VERSION);
                break;
            case IDS_REQUESTER_CONTEXT:
                strcpy (vartext, REQUESTER_CONTEXT);
                break;
            case IDS_ACCOUNT_BALANCE: 
                GetAccountBalance (vartext);
                break;
            case IDS_CN: 
                strcpy (vartext, COMMON_NAME);
                break;
            case IDS_HOME_DIRECTORY:
                {
                    char buffer[MAXLEN];

                    vartext[0] = '\0';
                    NDSGetVar ( varTable[i].VarName, buffer, MAXLEN );
                    if ( buffer[0] )
                        ConverNDSPathToNetWarePathA( buffer, NULL, vartext );
                }
                break;
            case IDS_ADMINISTRATIVE_ASSISTANT:
            case IDS_ALLOW_UNLIMITED_CREDIT:
            case IDS_DESCRIPTION:
            case IDS_EMAIL_ADDRESS:
            case IDS_EMPLOYEE_ID:
            case IDS_FACSIMILE_TELEPHONE_NUMBER:
            case IDS_GROUP_MEMBERSHIP:
            case IDS_HIGHER_PRIVILEGES:
            case IDS_INITIALS:
            case IDS_LANGUAGE:
            case IDS_LOCKED_BY_INTRUDER:
            case IDS_LOGIN_DISABLED:
            case IDS_LOGIN_GRACE_LIMIT:
            case IDS_LOGIN_GRACE_REMAINING:
            case IDS_LOGIN_INTRUDER_ATTEMPTS:
            case IDS_LOGIN_MAXIMUM_SIMULTANEOUS:
            case IDS_MAILSTOP:
            case IDS_MESSAGE_SERVER:
            case IDS_MINIMUM_ACCOUNT_BALANCE:
            case IDS_OBJECT_CLASS:
            case IDS_OU:
            case IDS_PASSWORD_ALLOW_CHANGE:
            case IDS_PASSWORD_MINIMUM_LENGTH:
            case IDS_PASSWORD_REQUIRED:
            case IDS_PASSWORD_UNIQUE_REQUIRED:
            case IDS_PASSWORDS_USED:
            case IDS_PHYSICAL_DELIVERY_OFFICE_NAME:
            case IDS_POSTAL_ADDRESS:
            case IDS_POSTAL_CODE:
            case IDS_POSTAL_OFFICE_BOX:
            case IDS_PRIVATE_KEY:
            case IDS_PROFILE:
            case IDS_REVISION:
            case IDS_SECURITY_EQUALS:
            case IDS_SECURITY_FLAGS:
            case IDS_SEE_ALSO:
            case IDS_SERVER_HOLDS:
            case IDS_SUPERVISOR:
            case IDS_TELEPHONE_NUMBER:
            case IDS_TITLE:
            case IDS_CERTIFICATE_VALIDITY_INTERVAL:
            case IDS_EQUIVALENT_TO_ME:
            case IDS_GENERATIONAL_QUALIFIER:
            case IDS_GIVEN_NAME:
            case IDS_MAILBOX_ID:
            case IDS_MAILBOX_LOCATION:
            case IDS_PROFILE_MEMBERSHIP:
            case IDS_SA:
            case IDS_S:
            case IDS_L:
                NDSGetVar ( varTable[i].VarName, vartext, MAXLEN );
                break;
            }
            return(nVarLen);
        }
    }

    if (isdigit(*vartext))
    {
        while (isdigit(vartext[nVarLen]))
            nVarLen++;
        GetArgv(vartext);
    }
    else if (*vartext == '<')
    {
        nVarLen = 1;
        while (vartext[nVarLen] != '>' && vartext[nVarLen] != 0)
        {
            if (IsDBCSLeadByte(vartext[nVarLen]))
                nVarLen++;
            nVarLen++;
        }

        if (vartext[nVarLen] == 0)
            nVarLen = 0;
        else
        {
            nVarLen++;
            GetDosEnv (vartext);
        }
    }

    return(nVarLen);
}

/*
 *  Parse path string.
 *  If find the %variable value, replace it, otherwise keep as it is.
 */
void  NotQuotedStringTranslate(char *buf, BOOL Remove_dbs)
{
    char *pPercentSign, *pRest, vartext[MAXLEN];
    int   nVarLen, nInsertlen;

    if ( Remove_dbs )
    {
        // Convert \\ to \.
        pRest = buf;
        for (pRest = buf; *pRest; pRest = NWAnsiNext(pRest))
        {
            if (*pRest == '\\' && *(pRest+1) == '\\')
                memmove (pRest, pRest+1, strlen (pRest));
        }
    }

    // Convert variables following '%' sign.
    pRest = buf;
    while (pPercentSign = strchr(pRest, '%'))
    {
        pRest = pPercentSign+1;

        strcpy (vartext, pRest);

        nVarLen = VarTranslate(vartext);

        if (nVarLen == 0)
            continue;

        nInsertlen = strlen (vartext);
        if (strlen (buf) + nInsertlen - nVarLen < MAXLEN)
        {
            pRest = pPercentSign+1+nVarLen;

            memmove (pPercentSign+nInsertlen, pRest, strlen (pRest)+1);
            memmove (pPercentSign, vartext, nInsertlen);
            pRest = pPercentSign+nInsertlen;
        }
    }
}

/*
 *  Used by QuotedStringTranslate()
 *  On enter, *ppTemp point to a variable, on exit *ppTemp points to the
 *  charecter next to the variable. *ppBuffer points to the end of the
 *  value of the variable.
 */
int DoVarTranslate (char **ppTemp, char **ppBuffer, unsigned int nMaxLen, int fInquotes)
{
    int nVarLen;
    char vartext[MAXLEN];

    strcpy (vartext, *ppTemp);

    nVarLen = VarTranslate (vartext);

    if (nVarLen != 0)
    {
        if (strlen(vartext) >= nMaxLen)
            return(FALSE);

        strcpy (*ppBuffer, vartext);
        (*ppBuffer) = (*ppBuffer) + strlen (vartext);
        (*ppTemp) += nVarLen;
    }
    else if (fInquotes)
    {
        strcpy (*ppBuffer, "%");
        (*ppBuffer) += 1;
    }
    else
        return(FALSE);

    return(TRUE);
}

/*
 *  Used by QuotedStringTranslate()
 *  On entry, *(*ppTemp -1) is '\', if **ppTemp is one of those special
 *  characters, put the value in **ppBuffer, otherwise copy '\\\ and
 *  whatever is in *ppBuffer to *ppBuffer.
 */
void TranslateSpecialChar (char **ppTemp, char **ppBuffer)
{
    (*ppTemp)++;

    if (**ppTemp == '\\')
        **(ppBuffer) = '\\';
    else if (**ppTemp == 'n')
        **(ppBuffer) ='\n';
    else if (**ppTemp == 'r')
        **(ppBuffer) ='\r';
    else if (**ppTemp == '\"')
        **(ppBuffer) ='\"';
    else if (**ppTemp == '7')
        **(ppBuffer) ='\7';
    else
    {
        **(ppBuffer) = '\\';
        (*ppBuffer)++;
        return;
    }

    (*ppBuffer)++;
    (*ppTemp)++;;
}

/*
 *  Used by QuotedStringTranslate().
 *  Return TRUE if there are more interesting strings and it's seperated by ';'
 *  FALSE otherwise.
 */
int GetNextString (char **ppTemp, int *pfEnd)
{
    int fMore = FALSE;

    (*ppTemp) = RemoveSpaces (*ppTemp);

    *pfEnd = (**ppTemp == 0);

    if (**ppTemp == ';')
    {
        (*ppTemp) = RemoveSpaces (*ppTemp+1);
        fMore = TRUE;
    }

    return(fMore);
}


int GetLastShiftOp (char *buffer, char *pchOp, char *lpRest)
{
    int i, inquotes = FALSE;

    // NetWare compatibility fix.
    // for (i = strlen (buffer)-1; i >= 0; i--)

    for (i = 0; buffer[i]; i++)
    {
        if (buffer[i] == '\"' && buffer [i-1] != '\\')
            inquotes = !inquotes;
        if (!inquotes &&
            ( (buffer[i] == '>' && buffer[i+1] == '>')
            ||(buffer[i] == '<' && buffer[i+1] == '<')))
        {
            *pchOp = buffer[i];
            buffer[i] = 0;
            strcpy (lpRest, RemoveSpaces(buffer+i+2));
            return(TRUE);
        }
    }

    return(FALSE);
}
int GetLastAddOp (char *buffer, char *pchOp, char *lpRest)
{
    int i, inquotes = FALSE;

    // NetWare compatibility fix.
    // for (i = strlen (buffer)-1; i >= 0; i--)

    for (i = 0; buffer[i]; i++)
    {
        if (buffer[i] == '\"' && buffer [i-1] != '\\')
            inquotes = !inquotes;
        if (!inquotes &&
            (buffer[i] == '+' || buffer[i] == '-') )
        {
            *pchOp = buffer[i];
            buffer[i] = 0;
            strcpy (lpRest, RemoveSpaces(buffer+i+1));
            return(TRUE);
        }
    }

    return(FALSE);
}

int GetLastMultiplyOp (char *buffer, char *pchOp, char *lpRest)
{
    int i, inquotes = FALSE;

    // NetWare compatibility fix.
    // for (i = strlen (buffer)-1; i >= 0; i--)
    for (i = 0; buffer[i]; i++)
    {
        if (buffer[i] == '\"' && buffer [i-1] != '\\')
            inquotes = !inquotes;
        if (!inquotes &&
            (buffer[i] == '*' || buffer[i] == '/' || buffer[i] == '%') )
        {

            *pchOp = buffer[i];
            buffer[i] = 0;
            strcpy (lpRest, RemoveSpaces(buffer+i+1));
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 *  Used by QuotedStringTranslate.
 *  Return TRUE if input buffer is right format, FALSE otherwise.
 */
int SingleStringTranslate (char *buffer)
{
    int   inquotes = FALSE, fEnd = FALSE, nShift, nLen;
    char  szRest[MAXLEN], chOp;
    char *lpTemp = szRest, *lpBuffer=buffer;

    buffer = RemoveSpaces (buffer);

    if (GetLastShiftOp (buffer, &chOp, szRest))
    {
        if (!QuotedStringTranslate (buffer))
            return(FALSE);

        while (isdigit (*lpTemp))
            lpTemp++;

        if (!EndOfLine(lpTemp))
            return(FALSE);

        *lpTemp = 0;

        nShift = atoi (szRest);
        nLen = strlen (buffer);

        if (nShift >= nLen)
            *buffer = 0;
        else
        {
            if (chOp == '<')
                memmove (buffer, buffer+nShift, nLen-nShift);

            *(buffer+nLen-nShift) = 0;
        }
    }
    else if (GetLastAddOp (buffer, &chOp, szRest))
    {
        if (!QuotedStringTranslate (buffer) ||
            !QuotedStringTranslate (szRest))
            return(FALSE);

        sprintf (buffer, "%d", (chOp == '+')? (atoi (buffer) + atoi (szRest))
                                            : (atoi (buffer) - atoi (szRest)));
    }
    else if (GetLastMultiplyOp (buffer, &chOp, szRest))
    {
        if (!QuotedStringTranslate (buffer) ||
            !QuotedStringTranslate (szRest))
            return(FALSE);

        if (chOp == '*')
            sprintf (buffer, "%d", atoi (buffer) * atoi (szRest));
        else
        {
            if (atoi (szRest) == 0)
            {
                DisplayMessage(IDR_DIVIDE_BY_ZERO);
                strcpy (buffer, "0");
            }
            else
            {
                sprintf (buffer, "%d",(chOp == '/')? (atoi (buffer) / atoi (szRest))
                                                   : (atoi (buffer) % atoi (szRest)));
            }
        }
    }
    else
    {
        strcpy (szRest, buffer);
        *buffer = 0;

        while (*lpTemp)
        {
            if (inquotes)
            {
                if (*lpTemp == '\\')
                    TranslateSpecialChar (&lpTemp, &buffer);
                else if (*lpTemp == '\"')
                {
                    inquotes = !inquotes;
                    lpTemp++;
                    if (!GetNextString (&lpTemp, &fEnd))
                        break;
                }
                else if (*lpTemp == '%')
                {
                    lpTemp++;
                    DoVarTranslate (&lpTemp, &buffer, MAXLEN-(UINT)(buffer-lpBuffer), TRUE);
                }
                else
                {
                    *buffer =  *lpTemp;
                    if (IsDBCSLeadByte(*buffer))
                    {
                        buffer++;
                        lpTemp++;
                        *buffer =  *lpTemp;
                    }
                    buffer++;
                    lpTemp++;
                }
            }
            else
            {
                if (*lpTemp == '\"')
                {
                    inquotes = !inquotes;
                    lpTemp++;
                }
                else
                {
                    if (!DoVarTranslate (&lpTemp, &buffer, MAXLEN-(UINT)(buffer-lpBuffer), FALSE) ||
                        !GetNextString (&lpTemp, &fEnd))
                        break;
                }
            }
        }
        if (!fEnd)
        {
            if ( inquotes )
                DisplayMessage( IDR_NO_END_QUOTE );
            return(FALSE);
        }
        *buffer = 0;
    }

    return(TRUE);
}

/*
 *  Replace the variables in the string with their value.
 *  Use this function when the input string is quoted format.
 *  Return TRUE if input buffer is right format, FALSE otherwise.
 */
int QuotedStringTranslate (char *buffer)
{
    char  szTemp[MAXLEN], *lpLeft, *lpRight, *ptr = buffer, *pNext;
    int inquotes;

    lpLeft = *buffer == '('? buffer : NULL;
    lpRight = *buffer == ')'? buffer : NULL;
    inquotes = (*ptr == '"');

    while (*ptr)
    {
        pNext = NWAnsiNext (ptr);

        if (*pNext == '"' && *(ptr) != '\\')
        {
            pNext++;
            inquotes = !inquotes;
        }

        ptr = pNext;

        if (!inquotes)
        {
            if (*ptr == '(')
                lpLeft = ptr;
            else if (*ptr == ')')
            {
                lpRight = ptr;

                *lpRight = 0;

                if (lpLeft == NULL)
                    return(FALSE);

                if (lpRight - lpLeft <= 1) //There should be something in the backets.
                    return(FALSE);

                *lpLeft = 0;

                strncpy (szTemp, lpLeft+1, (UINT)(lpRight-lpLeft));

                if (!SingleStringTranslate (szTemp))
                    return(FALSE);

                if (strlen (buffer) + strlen(szTemp) + strlen (lpRight+1) + 2 >= MAXLEN)
                    return(FALSE);

                *lpLeft = '"';
                *(lpLeft+1+strlen(szTemp)) = '"';
                memmove (lpLeft+2+strlen(szTemp), lpRight+1, strlen (lpRight+1)+1);
                memmove (lpLeft+1, szTemp, strlen(szTemp));

                lpLeft = *buffer == '('? buffer : NULL;
                lpRight = *buffer == ')'? buffer : NULL;
                ptr = buffer;
                inquotes = (*ptr == '"');
            }
        }
    }

    if (lpLeft != NULL || lpRight != NULL)
        return(FALSE);
    return(SingleStringTranslate (buffer));
}


void BreakOff(void)
{
    fBreakOn = FALSE;

    NTBreakOff();
}

void BreakOn(void)
{
    fBreakOn = TRUE;

    NTBreakOn();
}

/*
 *  Used by ComspecHandler() and SetHandler()
 *  Set dos environment variable.
 */
int SetEnv (char *lpEnvLine)
{
    ExportEnv( lpEnvLine );
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\psdb.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nwlibs\psdb.c

Abstract:

    Read the Print Con database file APIs.

Author:

    Shawn Walker (v-swalk) 12-12-1994

Revision History:

--*/
#include "common.h"

extern DWORD SwapLong(DWORD number);

unsigned int
PSGetJobName(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    );

#define MAX_JOB_NAME_ENTRY  37

#define O_RDONLY        0x0000        /* open for reading only */
#define O_WRONLY        0x0001        /* open for writing only */
#define O_RDWR          0x0002        /* open for reading and writing */
#define O_APPEND        0x0008        /* writes done at eof */
#define O_CREAT         0x0100        /* create and open file */
#define O_TRUNC         0x0200        /* open and truncate */
#define O_EXCL          0x0400        /* open only if file doesn't already exist */
#define O_TEXT          0x4000        /* file mode is text (translated) */
#define O_BINARY        0x8000        /* file mode is binary (untranslated) */

#define S_IEXEC         0000100         /* execute/search permission, owner */
#define S_IWRITE        0000200         /* write permission, owner */
#define S_IREAD         0000400         /* read permission, owner */
#define S_IFCHR         0020000         /* character special */
#define S_IFDIR         0040000         /* directory */
#define S_IFREG         0100000         /* regular */
#define S_IFMT          0170000         /* file type mask */

#include <pshpack1.h>
typedef struct _PRINTCON_HEADER {
    unsigned char   Text[115];
    unsigned char   MajorVersion;
    unsigned char   MinorVersion1;
    unsigned char   MinorVersion2;
    unsigned char   DefaultJobName[32];
} PRINTCON_HEADER, *PPRINTCON_HEADER;

#define PRINTCON_HEADER_SIZE    sizeof(PRINTCON_HEADER)

typedef struct _JOB_NAME_AREA {
    unsigned char   JobName[32];
    unsigned long   JobRecordOffset;
} JOB_NAME_AREA, *PJOB_NAME_AREA;

#define JOB_NAME_AREA_SIZE    sizeof(JOB_NAME_AREA)

typedef struct _JOB_RECORD_AREA {
    unsigned char   ServerName[NCP_BINDERY_OBJECT_NAME_LENGTH];
    unsigned char   QueueName[NCP_BINDERY_OBJECT_NAME_LENGTH];
    unsigned char   TabSize;
    unsigned short  NumberOfCopies;
    unsigned char   FormName[40];
    unsigned char   NotifyWhenDone; //0=No, 1=Yes
    unsigned long   PrintServerID;
    unsigned char   Name[13];
    unsigned char   BannerName[13];
    unsigned char   Device[33];
    unsigned char   Mode[33];
    unsigned char   BannerFlag;     //0=No Banner, 1=Banner
    unsigned char   DataType;       //1=Byte,0=Stream
    unsigned char   FormFeed;       //0=Don't Suppress FF, 1=Suppress FF
    unsigned short  TimeoutCount;
    unsigned char   LocalPrinter;   //1=LPT1, 2=LPT2, 3=LPT3
    unsigned char   AutoEndCap;     //0=Don't Auto EndCap, 1=Do Auto EndCap
} JOB_RECORD_AREA, *PJOB_RECORD_AREA;
#include <poppack.h>

#define JOB_RECORD_AREA_SIZE    sizeof(JOB_RECORD_AREA)


/*++
*******************************************************************

        PSJobGetDefault

Routine Description:

        Get the default print job configuration from the printcon.dat
        file.

Arguments:

        ConnectionHandle = The connection handle to use.
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PSJobGetDefault(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PSGetJobName(
                ConnectionHandle,
                SearchFlag,
                pOwner,
                pJobName,
                pJobRecord,
                TRUE);
}


/*++
*******************************************************************

        PSJobRead

Routine Description:

        Get the print job configuration from the printcon.dat file.

Arguments:

        ConnectionHandle = The connection handle to use.
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PSJobRead(
    unsigned int    ConnectionHandle,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PSGetJobName(
                ConnectionHandle,
                0,
                pOwner,
                pJobName,
                pJobRecord,
                FALSE);
}


/*++
*******************************************************************

        PSGetJobName

Routine Description:

        Common routine to get the print job configuration from the
        printcon.dat file.

Arguments:

        ConnectionHandle = The connection handle to use.
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.
        GetDefault = TRUE = get the default job name, FALSE = Don't get
                      the default job name.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PSGetJobName(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    )
{
    unsigned char   *pSearchJobName;
    unsigned long   ObjectId;
    FILE            *stream = NULL;
    unsigned int    Count;
    unsigned int    Bytes;
    unsigned int    RetCode;
    unsigned int    ConnectionNumber;
    JOB_NAME_AREA   JobNameArea;
    JOB_RECORD_AREA JobRecord;
    PRINTCON_HEADER PrintConHeader;
    unsigned char   MailDirPath[NCP_MAX_PATH_LENGTH];

    /** Get the connection number for this connection **/

    RetCode = GetConnectionNumber(ConnectionHandle, &ConnectionNumber);
    if (RetCode) {
        goto CommonExit;
    }

    RetCode = GetBinderyObjectID (ConnectionHandle, LOGIN_NAME,
                                  OT_USER, &ObjectId);
    if (RetCode) {
        goto CommonExit;
    }

    /** Build the path to open the file **/

    sprintf(MailDirPath, "SYS:MAIL/%lX/PRINTCON.DAT", SwapLong(ObjectId));

    stream = fopen(NTNWtoUNCFormat( MailDirPath), "rb");
    if (stream == NULL) {
        RetCode = PS_ERR_OPENING_DB;
        goto CommonExit;
    }

    Bytes = fread( (unsigned char *) &PrintConHeader, sizeof( char), PRINTCON_HEADER_SIZE, stream);
    if (Bytes < PRINTCON_HEADER_SIZE) {
        RetCode = PS_ERR_INTERNAL_ERROR;
        goto CommonExit;
    }

    /** Check the version number **/

    if ((PrintConHeader.MajorVersion != 3 &&
         PrintConHeader.MajorVersion != 1) ||
        PrintConHeader.MinorVersion1 != 1 ||
        PrintConHeader.MinorVersion2 != 1) {

        RetCode = PS_ERR_BAD_VERSION;
        goto CommonExit;
    }
    /** Get the name we are looking for **/

    if (GetDefault) {
        if (PrintConHeader.DefaultJobName[0] == 0) {
            RetCode = PS_ERR_NO_DEFAULT_SPECIFIED;
            goto CommonExit;
        }
        pSearchJobName = PrintConHeader.DefaultJobName;
    }
    else {
        pSearchJobName = pJobName;
    }

    Count = 0;

    /** Go through all of the job entry to look for the name **/

    while (Count < MAX_JOB_NAME_ENTRY) {
        Bytes = fread( (unsigned char *) &JobNameArea, sizeof(unsigned char), JOB_NAME_AREA_SIZE, stream);
        if (Bytes < JOB_NAME_AREA_SIZE) {
            RetCode = PS_ERR_INTERNAL_ERROR;
            goto CommonExit;
        }
        Count++;

        /** Skip the entry with a null job name **/

        if (JobNameArea.JobName[0] == 0) {
            continue;
        }
    
        /** Is this the job name we are looking for? **/

        if (!_strcmpi(pSearchJobName, JobNameArea.JobName)) {
            break;
        }
    }

    /** See if we found the job name **/

    if (Count > MAX_JOB_NAME_ENTRY) {
        if (GetDefault) {
            RetCode = PS_ERR_GETTING_DEFAULT;
        }
        else {
            RetCode = PS_ERR_READING_RECORD;
        }
        goto CommonExit;
    }

    if (fseek(stream, JobNameArea.JobRecordOffset, SEEK_SET)) {
        RetCode = PS_ERR_READING_RECORD;
        goto CommonExit;
    }

    Bytes = fread( (unsigned char *) &JobRecord, sizeof(unsigned char), JOB_RECORD_AREA_SIZE, stream);
    if (Bytes < JOB_RECORD_AREA_SIZE) {
        RetCode = PS_ERR_READING_RECORD;
        goto CommonExit;
    }

    memset(pJobRecord, 0, PS_JOB_RECORD_SIZE);

    if (JobRecord.NotifyWhenDone) {
        pJobRecord->PrintJobFlag |= PS_JOB_NOTIFY;
    }
    if (JobRecord.BannerFlag) {
        pJobRecord->PrintJobFlag |= PS_JOB_PRINT_BANNER;
    }
    if (JobRecord.DataType) {
        pJobRecord->PrintJobFlag |= PS_JOB_EXPAND_TABS;
    }
    if (JobRecord.FormFeed) {
        pJobRecord->PrintJobFlag |= PS_JOB_NO_FORMFEED;
    }
    if (JobRecord.AutoEndCap) {
        pJobRecord->PrintJobFlag |= PS_JOB_AUTO_END;
    }
    if (JobRecord.TimeoutCount) {
        pJobRecord->PrintJobFlag |= PS_JOB_TIMEOUT;
    }

    pJobRecord->Copies                    = JobRecord.NumberOfCopies;
    pJobRecord->TabSize                   = JobRecord.TabSize;
    pJobRecord->TimeOutCount              = JobRecord.TimeoutCount;
    pJobRecord->LocalPrinter              = JobRecord.LocalPrinter;

    strcpy(pJobRecord->Mode,                JobRecord.Mode);
    strcpy(pJobRecord->Device,              JobRecord.Device);
    strcpy(pJobRecord->FormName,            JobRecord.FormName);
    strcpy(pJobRecord->BannerName,          JobRecord.BannerName);
    strcpy(pJobRecord->u.NonDS.PrintQueue,  JobRecord.QueueName);
    strcpy(pJobRecord->u.NonDS.FileServer,  JobRecord.ServerName);

    if (GetDefault && pJobName) {
        strcpy(pJobName, JobNameArea.JobName);
    }

    if (pOwner) {
        *pOwner = 0;
    }

CommonExit:

    if (stream != NULL) {
        fclose( stream );
    }

    return RetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\inc\common.h ===
/*************************************************************************
*
*  COMMON.H
*
*  Common header file
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\COMMON.H  $
*  
*     Rev 1.3   22 Dec 1995 14:20:06   terryt
*  Add Microsoft headers
*  
*     Rev 1.2   22 Nov 1995 15:44:26   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 15:18:46   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:05:30   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 17:03:32   terryt
*  CAPTURE support
*  
*     Rev 1.1   26 Jul 1995 16:01:12   terryt
*  Get rid of unneccessary externs
*  
*     Rev 1.0   15 May 1995 19:09:28   terryt
*  Initial revision.
*  
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <nds.h>
#include <ndsapi32.h>
#include <nwapi32.h>

#include "dbcs.h"
#include "inc\nwlibs.h"

#include "nwscript.h"


#define MAX_NAME_LEN      48
#define MAX_PASSWORD_LEN  128
#define MAX_PATH_LEN      304  //From NW programmer's guide p268.

/* for map only */
#define MAX_VOLUME_LEN    256      // 17 for 3X
#define MAX_DIR_PATH_LEN  256

/* for capture only */
#define MAX_JOB_NAME_LEN     32
#define MAX_QUEUE_NAME_LEN   1024
#define MAX_BANNER_USER_NAME 13

/* for common only */
#define PATH_SEPERATOR   ";"

/* For building time/date strings */

#define TIMEDATE_SIZE 64

/*
    Function definations
 */
/* used by login.c and script.c */
void BreakOff(void);
void BreakOn(void);

/* used by common setpass*/
void xstrupr(char *buffer);
void ReadPassword(char * Password);

/* used by map attach login*/
int  CAttachToFileServer(char *ServerName, unsigned int *pConn, int * pbAlreadyAttached);
int  Login(char *UserName, char *ServerName, char *Password, int bReadPassword);

/* used by map attach login*/
int  ReadName (char * Name);

/* used by map login */
void DisplayError(int error ,char *functionName);
char * GetDosEnv1(void);
char * NWGetPath(void);
int GetRestEnvLen (char *lpRest);

int MemorySegmentLargeEnough (int nInsertByte);
int  IsSearchDrive(int driveNum);
int  GetDriveFromSearchNumber (int searchNumber);

/* used by login logout*/
void SetLoginDirectory (PBYTE);

/* used by all */
int  Map (char * buffer);
void DisplayMapping(void);
int  CGetDefaultConnectionID ( unsigned int * pConn );
int  GetConnectionInfo (unsigned int conn,
                        char * serverName,
                        char * userName,
                        unsigned int * pconnNum,
                        unsigned char * loginTime);

extern char * LOGIN_NAME;
extern char *NDS_FULL_NAME;
extern char *REQUESTER_CONTEXT;
extern char *TYPED_USER_NAME;
extern PWCHAR TYPED_USER_NAME_w;
extern PBYTE NDSTREE;
extern PWCHAR NDSTREE_w;
extern UNICODE_STRING NDSTREE_u;
extern PBYTE PREFERRED_SERVER;

/*
    String definitions.
 */
extern char *__Day__[7];
extern char *__Month__[12];
extern char *__AMPM__[2];
extern char *__GREETING__[3];

extern char __DEL__[];
extern char __REM__[];
extern char __INS__[];
extern char __ROOT__[];
extern char __NEXT__[];

extern char __AUTOENDCAP__[];
extern char __BANNER__[];
extern char __COPIES__[];
extern char __CREATE__[];
extern WCHAR __DISABLED__[];
extern WCHAR __ENABLED__[];
extern WCHAR __YES__[];
extern WCHAR __NO__[];
extern WCHAR __SECONDS__[];
extern WCHAR __CONVERT_TO_SPACE__[];
extern WCHAR __NO_CONVERSION__[];
extern WCHAR __NOTIFY_USER__[];
extern WCHAR __NOT_NOTIFY_USER__[];
extern WCHAR __NONE__[];
extern char __FORMFEED__[];
extern char __FORM__[];
extern char __JOB_DESCRIPTION__[];
extern char __JOB__[];
extern char __KEEP__[];
extern char __LOCAL__[];
extern char __LOCAL_2__[];
extern char __LOCAL_3__[];
extern char __NAME__[];
extern char __NOAUTOENDCAP__[];
extern char __NOBANNER__[];
extern char __NOFORMFEED__[];
extern char __NONOTIFY__[];
extern char __NOTABS__[];
extern char __NOTIFY__[];
extern char __QUEUE__[];
extern char __PRINTER__[];
extern char __OPT_NO__[];
extern char __SERVER__[];
extern char __SHORT_FOR_AUTOENDCAP__[];
extern char __SHORT_FOR_BANNER__[];
extern char __SHORT_FOR_COPIES__[];
extern char __SHORT_FOR_CREATE__[];
extern char __SHORT_FOR_FORMFEED__[];
extern char __SHORT_FOR_FORM__[];
extern char __SHORT_FOR_JOB__[];
extern char __SHORT_FOR_KEEP__[];
extern char __SHORT_FOR_LOCAL__[];
extern char __SHORT_FOR_NAME__[];
extern char __SHORT_FOR_NOAUTOENDCAP__[];
extern char __SHORT_FOR_NOBANNER__[];
extern char __SHORT_FOR_NOFORMFEED__[];
extern char __SHORT_FOR_NONOTIFY__[];
extern char __SHORT_FOR_NOTABS__[];
extern char __SHORT_FOR_NOTIFY__[];
extern char __SHORT_FOR_QUEUE__[];
extern char __SHORT_FOR_PRINTER__[];
extern char __SHORT_FOR_SERVER__[];
extern char __SHORT_FOR_TABS__[];
extern char __SHORT_FOR_TIMEOUT__[];
extern char __SHOW__[];
extern char __TABS__[];
extern char __TIMEOUT__[];

extern unsigned int CaptureStringsLoaded;
extern unsigned int fNDS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\wide.c ===
/*************************************************************************
*
*  WIDE.C
*
*  Wide character translation routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\WIDE.C  $
*  
*     Rev 1.2   10 Apr 1996 14:24:14   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:56:36   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:27:18   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:08:20   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:37:32   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:11:14   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"


/********************************************************************

        szToWide

Routine Description:

        Given a single byte character string, convert to wide

Arguments:

        lpszW   - Wide character string returned
        lpszC   - Single character string input
        nSize   - length of Wide character buffer

Return Value:
        0 = success
        else NT error

 *******************************************************************/
DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
    )
{
    if (!MultiByteToWideChar(CP_OEMCP,
                             MB_PRECOMPOSED,
                             lpszC,
                             -1,
                             lpszW,
                             nSize))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}

/********************************************************************

        WideTosz

Routine Description:

        Given a wide character string, convert to single

Arguments:

        lpszC   - Single character string returned
        lpszW   - Wide character string input
        nSize   - length of single character buffer

Return Value:
        0 = success
        else NT error

 *******************************************************************/
DWORD
WideTosz( 
    LPSTR lpszC, 
    LPWSTR lpszW, 
    INT nSize 
    )
{
    if (!WideCharToMultiByte(CP_OEMCP,
                             0,
                             (LPCWSTR) lpszW,
                             -1,
                             lpszC,
                             nSize,
                             NULL, 
                             NULL))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}

/********************************************************************

        ConvertUnicodeToAscii

Routine Description:

        Given a wide character string, convert to single

Arguments:

        Buffer - buffer to be converted

Return Value:
        none

 *******************************************************************/
void
ConvertUnicodeToAscii( PVOID Buffer ) 
{
    LPCWSTR lpszW = Buffer;
    BYTE Destination[1024];

    WideTosz( (LPSTR)Destination, (LPWSTR)Buffer, 1024 );

    strcpy( Buffer, Destination );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\version.c ===
/*************************************************************************
*
*  VERSION.C
*
*  Shell version information
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\VERSION.C  $
*  
*     Rev 1.2   10 Apr 1996 14:24:08   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:56:28   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:27:10   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:08:18   terryt
*  Initial revision.
*  
*     Rev 1.1   26 Jul 1995 14:17:24   terryt
*  Clean up comments
*  
*     Rev 1.0   15 May 1995 19:11:12   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"


/*
 *  MSDOS is not neccessarily the best thing to put out,
 *  maybe Windows_NT, NT or NTDOS.  The OS_VERSION is also a problem.
 *  The script variables don't neccessarily have to match the DOS variables.
 *
 *  The shell version numbers may change with 4.X support.
 */
 
#define CLIENT_ID_STRING "MSDOS\0V5.00\0IBM_PC\0IBM"
#define CLIENT_SHELL_MAJOR  0x03
#define CLIENT_SHELL_MINOR  0x1a
#define CLIENT_SHELL_NUMBER 0x00


void
NTGetVersionOfShell( char * buffer,
                     unsigned char * shellmajor,
                     unsigned char * shellminor,
                     unsigned char * shellnum )
{
    *shellmajor = CLIENT_SHELL_MAJOR;
    *shellminor = CLIENT_SHELL_MINOR;
    *shellnum = CLIENT_SHELL_NUMBER;
    memcpy( buffer, CLIENT_ID_STRING, strlen(CLIENT_ID_STRING));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\unc.c ===
/*************************************************************************
*
*  UNC.C
*
*  NetWare format to UNC format
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\UNC.C  $
*  
*     Rev 1.4   10 Apr 1996 14:24:00   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.4   12 Mar 1996 19:56:18   terryt
*  Relative NDS names and merge
*  
*     Rev 1.3   04 Jan 1996 18:57:26   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.2   22 Dec 1995 14:27:04   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   22 Dec 1995 11:09:18   terryt
*  Fixes
*  
*     Rev 1.0   15 Nov 1995 18:08:14   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:37:24   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:11:10   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "inc/common.h"

/********************************************************************

        NTNWtoUNCFormat

Routine Description:

        Given a connection handle and a path, change it to UNC format
        if it's in NetWare format.  I.E.

        SYS:\usr\terryt   ==>   \\HELIUM\SYS\usr\terryt

        Don't do the conversion if it's not in NetWare format.

Arguments:

        ConnectionHandle   -  Connection Handle
        NetWarePath        -  Input original path

Return Value:
        UNC string

 *******************************************************************/
char *
NTNWtoUNCFormat( char * NetWarePath )
{
    static char UNCPath[1024];
    unsigned int Result;
    char ServerName[48];
    char * p;
    char * q;

    /*
     *  If it's UNC already, leave it alone
     */
    if ( ( NetWarePath[0] == '\\' ) && ( NetWarePath[1] == '\\' ) )
        return NetWarePath;
    if ( ( NetWarePath[0] == '/' ) && ( NetWarePath[1] == '/' ) )
        return NetWarePath;

    /*
     *  if it's drive:dir, leave it alone
     */
    if ( NetWarePath[0] && ( NetWarePath[1] == ':' ) )
        return NetWarePath;

    /*
     *  if it's not volume:dir, leave it alone
     */
    p = strchr( NetWarePath, ':' );
    if ( !p )
        return NetWarePath;

    /*
     * if slashes before :, it must be a file server
     */
    q = strchr( NetWarePath, '\\' );
    if ( q && ( q < p ) )
    {
        strcpy( UNCPath, "\\\\" );
        *p = '\0';
        strcat( UNCPath, NetWarePath );
        if (( *(p + 1) != '\\' ) && ( *(p + 1) != '/' ) )
           strcat( UNCPath, "\\" );
        strcat( UNCPath, p + 1 );
        *p = ':';
        return UNCPath;
    }

    q = strchr( NetWarePath, '/' );
    if ( q && ( q < p ) )
    {
        strcpy( UNCPath, "\\\\" );
        *q = '\\';
        *p = '\0';
        strcat( UNCPath, NetWarePath );
        if (( *(p + 1) != '\\' ) && ( *(p + 1) != '/' ) )
           strcat( UNCPath, "\\" );
        strcat( UNCPath, p + 1 );
        *q = '/';
        *p = ':';
        return UNCPath;
    }

    strcpy( UNCPath, "\\\\" );
    strcat( UNCPath, PREFERRED_SERVER );
    strcat( UNCPath, "\\" );
    *p = '\0';
    strcat( UNCPath, NetWarePath );
    if (( *(p + 1) != '\\' ) && ( *(p + 1) != '/' ) )
        strcat( UNCPath, "\\" );
    strcat( UNCPath, p + 1 );
    *p = ':';

    return UNCPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\inc\ntnw.h ===
/*************************************************************************
*
*  NTNW.H
*
*  NT specific NetWare defines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\NTNW.H  $
*  
*     Rev 1.1   22 Dec 1995 14:20:20   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:05:34   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:09:36   terryt
*  Initial revision.
*  
*************************************************************************/

/*
 * This must be kept in sync with the NWAPI32 library.  This are
 * internal data structures and routines.
 */
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

extern NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    );

DWORD szToWide( LPWSTR lpszW, LPCSTR lpszC, INT nSize );
DWORD WideTosz( LPSTR lpszC, LPWSTR lpszW, INT nSize );

extern TCHAR NW_PROVIDER[60];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\inc\nwlibs.h ===
/*************************************************************************
*
*  NWLIBS.H
*
*  Prototypes
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\NWLIBS.H  $
*  
*     Rev 1.1   22 Dec 1995 14:20:28   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:05:36   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 17:03:46   terryt
*  CAPTURE support
*  
*     Rev 1.0   15 May 1995 19:09:40   terryt
*  Initial revision.
*  
*************************************************************************/

/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\nwlibs.h

Abstract:

    NW Libs prototypes.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

--*/

#ifndef _NWLIBS_H_
#define _NWLIBS_H_


/*++
*******************************************************************
        NetWare defaults
*******************************************************************
--*/
#define NCP_BINDERY_OBJECT_NAME_LENGTH      48
#define NCP_SERVER_NAME_LENGTH              NCP_BINDERY_OBJECT_NAME_LENGTH

#define NCP_MAX_PATH_LENGTH                 255
#define NCP_VOLUME_LENGTH                   256   // 16 in 3X


/*++
*******************************************************************
        Defines for GetDrive Status
*******************************************************************
--*/

#define NETWARE_UNMAPPED_DRIVE          0x0000
#define NETWARE_FREE_DRIVE              0x0000
#define NETWARE_LOCAL_FREE_DRIVE        0x0800
#define NETWARE_LOCAL_DRIVE             0x1000
#define NETWARE_NETWORK_DRIVE           0x2000
#define NETWARE_LITE_DRIVE              0x4000
#define NETWARE_PNW_DRIVE               0x4000
#define NETWARE_NETWARE_DRIVE           0x8000

#define NETWARE_FORMAT_NETWARE          0
#define NETWARE_FORMAT_SERVER_VOLUME    1
#define NETWARE_FORMAT_DRIVE            2
#define NETWARE_FORMAT_UNC              3

#define NCP_JOB_DESCRIPTION_LENGTH  50
#define NCP_BANNER_TEXT_LENGTH      13
#define NCP_FORM_NAME_LENGTH        13
#define NCP_QUEUE_NAME_LENGTH       65

#define CAPTURE_FLAG_PRINT_BANNER  0x80
#define CAPTURE_FLAG_EXPAND_TABS   0x40
#define CAPTURE_FLAG_NOTIFY        0x10
#define CAPTURE_FLAG_NO_FORMFEED   0x08
#define CAPTURE_FLAG_KEEP          0x04
#define DEFAULT_PRINT_FLAGS        0xC0
#define DEFAULT_BANNER_TEXT        "LPT:"

typedef struct _NETWARE_CAPTURE_FLAGS_RW {
    unsigned char   JobDescription[NCP_JOB_DESCRIPTION_LENGTH];
    unsigned char   JobControlFlags;
    unsigned char   TabSize;
    unsigned short  NumCopies;
    unsigned short  PrintFlags;
    unsigned short  MaxLines;
    unsigned short  MaxChars;
    unsigned char   FormName[NCP_FORM_NAME_LENGTH];
    unsigned char   Reserved1[9];
    unsigned short  FormType;
    unsigned char   BannerText[NCP_BANNER_TEXT_LENGTH];
    unsigned char   Reserved2;
    unsigned short  FlushCaptureTimeout;
    unsigned char   FlushCaptureOnClose;
} NETWARE_CAPTURE_FLAGS_RW, *PNETWARE_CAPTURE_FLAGS_RW, *LPNETWARE_CAPTURE_FLAGS_RW;

typedef struct _NETWARE_CAPTURE_FLAGS_RO {
    unsigned short  ConnectionID;
    unsigned short  SetupStringMaxLen;
    unsigned short  ResetStringMaxLen;
    unsigned char   LPTCaptureFlag;
    unsigned char   FileCaptureFlag;
    unsigned char   TimingOutFlag;
    unsigned char   InProgress;
    unsigned char   PrintQueueFlag;
    unsigned char   PrintJobValid;
    unsigned char   QueueName[NCP_QUEUE_NAME_LENGTH];
    unsigned char   ServerName[NCP_SERVER_NAME_LENGTH];
} NETWARE_CAPTURE_FLAGS_RO, *PNETWARE_CAPTURE_FLAGS_RO, *LPNETWARE_CAPTURE_FLAGS_RO;

#define NETWARE_CAPTURE_FLAGS_RO_SIZE    sizeof(NETWARE_CAPTURE_FLAGS_RO)
#define NETWARE_CAPTURE_FLAGS_RW_SIZE    sizeof(NETWARE_CAPTURE_FLAGS_RW)

#define PS_FORM_NAME_SIZE       12
#define PS_BANNER_NAME_SIZE     12
#define PS_BANNER_FILE_SIZE     12
#define PS_DEVICE_NAME_SIZE     32
#define PS_MODE_NAME_SIZE       32

#define PS_BIND_NAME_SIZE       NCP_BINDERY_OBJECT_NAME_LENGTH
#define PS_MAX_NAME_SIZE        514

/** Flags for the PS_JOB_REC structure PrintJobFlag field **/

#define PS_JOB_EXPAND_TABS          0x00000001    /* File type:0=Stream 1=Tab */
#define PS_JOB_NO_FORMFEED          0x00000002    /* Formfeed tail:0=Yes 1=No */
#define PS_JOB_NOTIFY               0x00000004    /* Notify:0=No 1=Yes */
#define PS_JOB_PRINT_BANNER         0x00000008    /* Banner:0=No 1=Yes */
#define PS_JOB_AUTO_END             0x00000010    /* Auto endcap:0=No 1=Yes */
#define PS_JOB_TIMEOUT              0x00000020    /* Enable T.O.:0=No 1=Yes */

#define PS_JOB_ENV_DS               0x00000040    /* Use D.S. Environment */
#define PS_JOB_ENV_MASK             0x000001C0    /* Bindery vs. D.S. Mask */

#define PS_JOB_DS_PRINTER           0x00000200    /* D.S. Printer not Queue */
#define PS_JOB_PRINTER_MASK         0x00000E00    /* D.S. Printer vs. Queue */

/** Default Flags **/

#define PS_JOB_DEFAULT              (NWPS_JOB_PRINT_BANNER | NWPS_JOB_AUTO_END)
#define PS_JOB_DEFAULT_COPIES       1             /* Default Number of Copies */
#define PS_JOB_DEFAULT_TAB          8             /* Default Tab Expansion */

typedef struct _PS_JOB_RECORD {
    DWORD   PrintJobFlag;
    SHORT   Copies;
    SHORT   TimeOutCount;
    UCHAR   TabSize;
    UCHAR   LocalPrinter;
    CHAR    FormName[PS_FORM_NAME_SIZE + 2];
    CHAR    Name[PS_BANNER_NAME_SIZE + 2];
    CHAR    BannerName[PS_BANNER_FILE_SIZE + 2];
    CHAR    Device[PS_DEVICE_NAME_SIZE + 2];
    CHAR    Mode[PS_MODE_NAME_SIZE + 2];
    union {
        struct {
            /** Pad structures on even boundries **/

            CHAR    FileServer[PS_BIND_NAME_SIZE + 2];
            CHAR    PrintQueue[PS_BIND_NAME_SIZE + 2];
            CHAR    PrintServer[PS_BIND_NAME_SIZE + 2];
        } NonDS;
        CHAR    DSObjectName[PS_MAX_NAME_SIZE];
    } u;
    UCHAR   Reserved[392];
} PS_JOB_RECORD, *PPS_JOB_RECORD;

#define PS_JOB_RECORD_SIZE      sizeof(PS_JOB_RECORD)


/*++
*******************************************************************
        FUCNTION PROTOTYPES
*******************************************************************
--*/

/** ATTACH.C **/

unsigned int
AttachToFileServer(
    unsigned char     *pServerName,
    unsigned int      *pNewConnectionId
    );

unsigned int
DetachFromFileServer(
    unsigned int ConnectionId
    );

/** NCP.C **/

unsigned int
GetBinderyObjectID(
    unsigned int       ConnectionHandle,
    char              *pObjectName,
    unsigned short     ObjectType,
    unsigned long     *pObjectId
    );


/** CONNECT.C **/

unsigned int
GetDefaultConnectionID(
    unsigned int *pConnectionHandle
    );

unsigned int
GetConnectionHandle(
    unsigned char *pServerName,
    unsigned int  *pConnectionHandle
    );

unsigned int
GetConnectionNumber(
    unsigned int  ConnectionHandle,
    unsigned int *pConnectionNumber
    );

unsigned int
GetFileServerName(
    unsigned int  ConnectionHandle,
    char          *pServerName
    );

unsigned int
GetInternetAddress(
    unsigned int     ConnectionHandle,
    unsigned int     ConnectionNumber,
    unsigned char   *pInternetAddress
    );

/** DRIVE.C **/

unsigned int
GetDriveStatus(
    unsigned short  DriveNumber,
    unsigned short  PathFormat,
    unsigned short *pStatus,
    unsigned int   *pConnectionHandle,
    unsigned char  *pRootPath,
    unsigned char  *pRelativePath,
    unsigned char  *pFullPath
    );

unsigned int
GetFirstDrive(
    unsigned short *pFirstDrive
    );

unsigned int
ParsePath(
    unsigned char   *pPath,
    unsigned char   *pServerName,           //OPTIONAL
    unsigned char   *pVolumeName,           //OPTIONAL
    unsigned char   *pDirPath               //OPTIONAL
    );

unsigned int
SetDriveBase(
    unsigned short   DriveNumber,
    unsigned char   *ServerName,
    unsigned int     DirHandle,
    unsigned char   *pDirPath
    );

unsigned int
DeleteDriveBase(
    unsigned short DriveNumber
    );

unsigned int
GetDirectoryPath(
    unsigned char  ConnectionHandle,
    unsigned char  Handle,
    unsigned char *pPath
    );

unsigned int
IsDriveRemote(
    unsigned char  DriveNumber,
    unsigned int  *pRemote
    );

/** CAPTURE.C **/

unsigned int
EndCapture(
    unsigned char LPTDevice
    );

#define PS_ERR_BAD_VERSION                  0x7770
#define PS_ERR_GETTING_DEFAULT              0x7773
#define PS_ERR_OPENING_DB                   0x7774
#define PS_ERR_READING_DB                   0x7775
#define PS_ERR_READING_RECORD               0x7776
#define PS_ERR_INTERNAL_ERROR               0x7779
#define PS_ERR_NO_DEFAULT_SPECIFIED         0x777B

unsigned int
PSJobGetDefault(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
PSJobRead(
    unsigned int    ConnectionHandle,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
PS40JobGetDefault(
    unsigned int    NDSCaptureFlag,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
PS40JobRead(
    unsigned int    NDSCaptureFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
GetCaptureFlags(
    unsigned char        LPTDevice,
    PNETWARE_CAPTURE_FLAGS_RW pCaptureFlagsRW,
    PNETWARE_CAPTURE_FLAGS_RO pCaptureFlagsRO
    );

unsigned int
StartQueueCapture(
    unsigned int    ConnectionHandle,
    unsigned char   LPTDevice,
    unsigned char  *pServerName,
    unsigned char  *pQueueName
    );

unsigned int
GetDefaultPrinterQueue (
    unsigned int  ConnectionHandle,
    unsigned char *pServerName,
    unsigned char *pQueueName
    );

#endif /* _NWLIBS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\inc\dbcs.h ===
/*************************************************************************
*
*  DBCS.H
*
*  DBCS header file
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\DBCS.H  $
*  
*     Rev 1.1   22 Dec 1995 14:20:14   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:05:32   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 17:03:40   terryt
*  CAPTURE support
*  
*     Rev 1.0   15 May 1995 19:09:32   terryt
*  Initial revision.
*  
*************************************************************************/
unsigned char *NWAnsiNext(unsigned char *puch);
unsigned char *NWAnsiPrev(unsigned char *psz, unsigned char *puch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\perf\nwdata.c ===
//
//  NWData.c
//
// This file contains the initalized Object and counter definition for NetWare
// redirector performance extensible DLL.
// This would be the place to add more counters and the change the definitions
// of the current ones.
// 
#include "windows.h"
#include <winperf.h>
#include "NWPerf.h"

NW_DATA_DEFINITION NWDataDefinition = {
    {   sizeof(NW_DATA_DEFINITION)+ 
        SIZE_OF_COUNTER_BLOCK,        // Total Bytes ( Size of this header, the counter definitions
                                      // and the size of the actual counter data )
        sizeof(NW_DATA_DEFINITION),   // Definition length ( This header and the counter definitions )
        sizeof(PERF_OBJECT_TYPE),     // Header Length ( This header )
        NWOBJ,                        // Object Name Title Index    
        0,                            // Object Name Title
        NWOBJ,                        // Object Help Title Index
        0,                            // Object Help Title
        PERF_DETAIL_NOVICE,           // Detail Level
        (sizeof(NW_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION), // Number of Counters
        0,                            // Default Counters
       -1,                            // On NT5, signifies no instances
        0,                            // Code Page
        {0,0},                        // Perf Time
        {0,0}                         // Perf Freq
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        389,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        406,
        0,
        391,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IO_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        401,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        PACKETS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        265,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        267,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        NCPS_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        276,
        0,
        277,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_TRANSMITTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        278,
        0,
        279,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        NCPS_TRANSMITTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        10,
        0,
        289,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RDR_READ_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        290,
        0,
        291,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RANDOM_READ_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        292,
        0,
        293,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        READ_NCPS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        12,
        0,
        299,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RDR_WRITE_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        300,
        0,
        301,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RANDOM_WRITE_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        302,
        0,
        303,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WRITE_NCPS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        314,
        0,
        315,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SESSIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        316,
        0,
        317,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        RECONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        CONNECT_2X_ID,
        0,
        CONNECT_2X_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NETWARE_2X_CONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        CONNECT_3X_ID,
        0,
        CONNECT_3X_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NETWARE_3X_CONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        CONNECT_4X_ID,
        0,
        CONNECT_4X_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NETWARE_4X_CONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        326,
        0,
        327,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SERVER_DISCONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_READ_ID,
        0,
        PACKET_BURST_READ_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_READ_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_READ_TO_ID,
        0,
        PACKET_BURST_READ_TO_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_READ_TO_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_WRITE_ID,
        0,
        PACKET_BURST_WRITE_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_WRITE_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_WRITE_TO_ID,
        0,
        PACKET_BURST_WRITE_TO_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_WRITE_TO_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_IO_ID,
        0,
        PACKET_BURST_IO_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_IO_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nwscript\inc\nwscript.h ===
/******************************************************************************
*
*  NWSCRIPT.H
*
*   This module contains typedefs and defines required for the
*   NetWare script utility.
*
*   Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\NWSCRIPT.H  $
*  
*     Rev 1.10   18 Apr 1996 16:53:02   terryt
*  Various enhancements
*  
*     Rev 1.9   10 Apr 1996 14:22:36   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.10   12 Mar 1996 19:42:52   terryt
*  Relative NDS name support
*  
*     Rev 1.9   07 Mar 1996 18:34:46   terryt
*  Misc fixes
*  
*     Rev 1.8   22 Jan 1996 16:44:02   terryt
*  Add automatic map attaches
*  
*     Rev 1.7   08 Jan 1996 13:58:34   terryt
*  Correct NDS Preferred Server
*  
*     Rev 1.6   05 Jan 1996 17:19:08   terryt
*  Ensure context is the correct login default
*  
*     Rev 1.5   04 Jan 1996 18:58:34   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.4   22 Dec 1995 14:20:34   terryt
*  Add Microsoft headers
*  
*     Rev 1.3   28 Nov 1995 17:13:56   terryt
*  Cleanup resource file
*  
*     Rev 1.2   22 Nov 1995 15:44:34   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 16:11:34   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:05:38   terryt
*  Initial revision.
*  
*     Rev 1.5   25 Aug 1995 17:03:52   terryt
*  CAPTURE support
*  
*     Rev 1.4   18 Jul 1995 16:07:52   terryt
*  Screen out capture commands
*  
*     Rev 1.3   17 Jul 1995 09:43:02   terryt
*  Use Microsoft name for environment
*  
*     Rev 1.2   23 Jun 1995 09:49:58   terryt
*  Add error message for mapping over MS network drive
*  
*     Rev 1.1   23 May 1995 19:38:14   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:09:42   terryt
*  Initial revision.
*  
******************************************************************************/


#define SCRIPT_ENVIRONMENT_VALUENAME L"Volatile Environment"
#define REGISTRY_PROVIDER L"System\\CurrentControlSet\\Services\\NWCWorkstation\\networkProvider"
#define REGISTRY_PROVIDERNAME L"Name"

typedef enum SYNTAX
{
        NDSI_UNKNOWN,                                   /* 0  */
        NDSI_DIST_NAME,                                 /* 1  */
        NDSI_CE_STRING,                                 /* 2  */
        NDSI_CI_STRING,                                 /* 3  */
        NDSI_PR_STRING,                                 /* 4  */
        NDSI_NU_STRING,                                 /* 5  */
        NDSI_CI_LIST,                                   /* 6  */
        NDSI_BOOLEAN,                                   /* 7  */
        NDSI_INTEGER,                                   /* 8  */
        NDSI_OCTET_STRING,                              /* 9  */
        NDSI_TEL_NUMBER,                                /* 10 */
        NDSI_FAX_NUMBER,                                /* 11 */
        NDSI_NET_ADDRESS,                               /* 12 */
        NDSI_OCTET_LIST,                                /* 13 */
        NDSI_EMAIL_ADDRESS,                             /* 14 */
        NDSI_PATH,                                      /* 15 */
        NDSI_REPLICA_POINTER,                           /* 16 */
        NDSI_OBJECT_ACL,                                /* 17 */
        NDSI_PO_ADDRESS,                                /* 18 */
        NDSI_TIMESTAMP,                                 /* 19 */
        NDSI_CLASS_NAME,                                /* 20 */
        NDSI_STREAM,                                    /* 21 */
        NDSI_COUNTER,                                   /* 22 */
        NDSI_BACK_LINK,                                 /* 23 */
        NDSI_TIME,                                      /* 24 */
        NDSI_TYPED_NAME,                                /* 25 */
        NDSI_HOLD,                                      /* 26 */
        NDSI_INTERVAL,                                  /* 27 */
        NDSI_TAX_COUNT                                  /* 28 */
} SYNTAX;

#define DSCL_AFP_SERVER                      "AFP Server"
#define DSCL_ALIAS                           "Alias"
#define DSCL_BINDERY_OBJECT                  "Bindery Object"
#define DSCL_BINDERY_QUEUE                   "Bindery Queue"
#define DSCL_COMPUTER                        "Computer"
#define DSCL_COUNTRY                         "Country"
#define DSCL_DEVICE                          "Device"
#define DSCL_DIRECTORY_MAP                   "Directory Map"
#define DSCL_EXTERNAL_ENTITY                 "External Entity"
#define DSCL_GROUP                           "Group"
#define DSCL_LIST                            "List"
#define DSCL_LOCALITY                        "Locality"
#define DSCL_MESSAGE_ROUTING_GROUP           "Message Routing Group"
#define DSCL_MESSAGING_SERVER                "Messaging Server"
#define DSCL_NCP_SERVER                      "NCP Server"
#define DSCL_ORGANIZATION                    "Organization"
#define DSCL_ORGANIZATIONAL_PERSON           "Organizational Person"
#define DSCL_ORGANIZATIONAL_ROLE             "Organizational Role"
#define DSCL_ORGANIZATIONAL_UNIT             "Organizational Unit"
#define DSCL_PARTITION                       "Partition"
#define DSCL_PERSON                          "Person"
#define DSCL_PRINT_SERVER                    "Print Server"
#define DSCL_PRINTER                         "Printer"
#define DSCL_PROFILE                         "Profile"
#define DSCL_QUEUE                           "Queue"
#define DSCL_RESOURCE                        "Resource"
#define DSCL_SERVER                          "Server"
#define DSCL_TOP                             "Top"
#define DSCL_UNKNOWN                         "Unknown"
#define DSCL_USER                            "User"
#define DSCL_VOLUME                          "Volume"

#define DSAT_HOST_SERVER                     "Host Server"
#define DSAT_HOST_RESOURCE_NAME              "Host Resource Name"
#define DSAT_PATH                            "Path"

void ConvertUnicodeToAscii( PVOID );

void NTGetTheDate( unsigned int *, unsigned char *, unsigned char * );
void NTGetVersionOfShell( char *, unsigned char *, unsigned char *, unsigned char * );
void NTBreakOff( void );
void NTBreakOn( void );
unsigned short NTNetWareDriveStatus( unsigned short );
unsigned int NTGetNWDrivePath( unsigned short, unsigned char *, unsigned char * );
char * NTNWtoUNCFormat( char * );
unsigned int NTLoginToFileServer( char *, char *, char * );
unsigned int NTAttachToFileServer( unsigned char *, unsigned int * );
unsigned int NTIsConnected( unsigned char * );
unsigned int NTSetDriveBase( unsigned char *, unsigned char *, unsigned char * );
unsigned int NTGetUserID( unsigned int, unsigned long * );
unsigned int NTIsNetWareDrive( unsigned int );
void NTInitProvider( void );
void DisplayMessage( unsigned int, ... );
void DisplayOemString( char * );
void ExportEnv( unsigned char * );
void ExportCurrentDirectory( int );
void ExportCurrentDrive( int );
void GetOldPaths( void );
void NTPrintExtendedError( void );
unsigned int NTGetCurrentDirectory( unsigned char, unsigned char * );
void Capture( char ** argv, unsigned int );
unsigned int ConverNDSPathToNetWarePathA(char *, char *, char *);

#define CONTEXT_MAX 256
#define ATTRBUFSIZE 2048
#define NDS_NAME_CHARS 1024


unsigned int NDSInitUserProperty( void );
unsigned int NDSGetUserProperty( PBYTE, PBYTE Data, unsigned int, SYNTAX *, unsigned int * );
void NDSGetVar ( PBYTE, PBYTE, unsigned int );
unsigned int NDSChangeContext( PBYTE );
unsigned int NDSGetContext( PBYTE, unsigned int );
unsigned int Is40Server( unsigned int );
unsigned int NDSfopenStream ( PBYTE, PBYTE, PHANDLE, unsigned int * );
unsigned int IsMemberOfNDSGroup( PBYTE );
unsigned int NDSGetProperty ( PBYTE, PBYTE, PBYTE, unsigned int, unsigned int * );
unsigned int NDSTypeless( LPSTR, LPSTR );
void CleanupExit( int );
void NDSCleanup( void );
int NTGetNWUserName( PWCHAR, PWCHAR, int );
unsigned int NDSGetClassName( LPSTR, LPSTR );

unsigned int NDSCanonicalizeName( PBYTE, PBYTE, int, int );

#define LIST_3X_SERVER 1
#define LIST_4X_SERVER 2

BOOL IsServerInAttachList( char *, unsigned int );
void AddServerToAttachList( char *, unsigned int );
int DoAttachProcessing( char * );

#define FLAGS_LOCAL_CONTEXT   0x1
#define FLAGS_NO_CONTEXT      0x2
#define FLAGS_TYPED_NAMES     0x4

unsigned int NDSAbbreviateName( DWORD, LPSTR, LPSTR );

/*
 * Resource string IDs
 */
#define IDR_ERROR                       100
#define IDR_NO_DEFAULT_CONNECTION       101
#define IDR_NO_KNOWN_FILE_SERVER        102
#define IDR_LOCAL_DRIVE                 103
#define IDR_NETWARE_DRIVE               104
#define IDR_DASHED_LINE                 105
#define IDR_LOCAL_SEARCH                106
#define IDR_NETWARE_SEARCH              107
#define IDR_NOT_ENOUGH_MEMORY           108
#define IDR_PASSWORD                    109
#define IDR_ATTACHED                    110
#define IDR_ACCESS_DENIED               111
#define IDR_UNAUTHORIZED_LOGIN_TIME     112
#define IDR_LOGIN_DENIED_NO_CONNECTION  113
#define IDR_UNAUTHORIZED_LOGIN_STATION  114
#define IDR_ACCOUNT_DISABLED            115
#define IDR_PASSWORD_EXPRIED_NO_GRACE   116
#define IDR_MAP_NOT_ATTACHED_SERVER     117
#define IDR_MAP_USAGE                   118
#define IDR_UNDEFINED                   119
#define IDR_DIRECTORY_NOT_FOUND         120
#define IDR_VOLUME_NOT_EXIST            121
#define IDR_WRONG_DRIVE                 122
#define IDR_DEL_DRIVE                   123
#define IDR_DEL_SEARCH_DRIVE            124
#define IDR_SEARCH_DRIVE_NOT_EXIST      125
#define IDR_NOT_NETWORK_DRIVE           126
#define IDR_NO_DRIVE_AVAIL              127
#define IDR_INVALID_PATH                128
#define IDR_CAN_NOT_CHANGE_DRIVE        129
#define IDR_MAP_INVALID_PATH            130
#define IDR_MAP_FAILED                  131
#define IDR_NO_SCRIPT_FILE              132
#define IDR_STRIKE_KEY                  133
#define IDR_CANNOT_EXECUTE              134
#define IDR_ENOENT                      135
#define IDR_EXIT_NOT_SUPPORTED          136
#define IDR_IF_TOO_DEEP                 137
#define IDR_SCRIPT_ERROR                138
#define IDR_ORIGINAL_LINE_WAS           139
#define IDR_BAD_COMMAND                 140
#define IDR_LABEL_NOT_FOUND             141
#define IDR_NO_VOLUME                   142
#define IDR_ERROR_DURING                143
#define IDR_MAP_ERROR                   144
#define IDR_ENTER_SERVER_NAME           145
#define IDR_ENTER_LOGIN_NAME            146
#define IDR_ERROR_SET_DEFAULT_DRIVE     147
#define IDR_ERROR_OPEN_SCRIPT           148
#define IDR_DIVIDE_BY_ZERO              149
#define IDR_NEWLINE                     150
#define IDR_SERVER_USER                 151
#define IDR_NON_NETWARE_NETWORK_DRIVE   152
#define IDR_CAPTURE_USAGE               153
#define IDR_COPIES_EXPECTED             154
#define IDR_COPIES_OUTOF_RANGE          155
#define IDR_FILE_CAPTURE_UNSUPPORTED    156
#define IDR_FORM_EXPECTED               157
#define IDR_INVALID_BANNER              158
#define IDR_INVALID_FORM_NAME           159
#define IDR_INVALID_FORM_TYPE           160
#define IDR_INVALID_LPT_NUMBER          161
#define IDR_INVALID_PATH_NAME           162
#define IDR_JOB_NOT_FOUND               163
#define IDR_LPT_NUMBER_EXPECTED         164
#define IDR_LPT_STATUS                  165
#define IDR_NOT_ACTIVE                  166
#define IDR_NO_AUTOENDCAP               167
#define IDR_NO_PRINTERS                 168
#define IDR_LPT_STATUS_NO_BANNER        169
#define IDR_QUEUE_NOT_EXIST             170
#define IDR_SERVER_NOT_FOUND            171
#define IDR_SUCCESS_QUEUE               172
#define IDR_TABSIZE_OUTOF_RANGE         173
#define IDR_TAB_SIZE_EXPECTED           174
#define IDR_TIMEOUT_OUTOF_RANGE         175
#define IDR_TIME_OUT_EXPECTED           176
#define IDR_UNKNOW_FLAG                 177
#define IDR_DISABLED                    178
#define IDR_ENABLED                     179
#define IDR_YES                         180
#define IDR_NO                          181
#define IDR_SECONDS                     182
#define IDR_CONVERT_TO_SPACE            183
#define IDR_NO_CONVERSION               184
#define IDR_NOTIFY_USER                 185
#define IDR_NOT_NOTIFY_USER             186
#define IDR_NONE                        187
#define IDR_CONNECTION_REFUSED          188
#define IDR_LASTLOGIN_PM                189
#define IDR_LASTLOGIN_AM                190
#define IDR_ALL_LOCAL_DRIVES            191
#define IDR_CHANGE_CONTEXT_ERROR        192
#define IDR_GET_CONTEXT_ERROR           193
#define IDR_DISPLAY_CONTEXT             194
#define IDR_LPT_STATUS_NDS              195
#define IDR_LPT_STATUS_NO_BANNER_NDS    196
#define IDR_NO_QUEUE                    197
#define IDR_LASTLOGIN                   198
#define IDR_TREE_OPEN_FAILED            199
#define IDR_NDS_CONTEXT_INVALID         200
#define IDR_NDS_USERNAME_FAILED         201
#define IDR_QUERY_INFO_FAILED           202
#define IDR_NO_RESPONSE                 203
#define IDR_NDSQUEUE_NOT_EXIST          204
#define IDR_NDSSUCCESS_QUEUE            205
#define IDR_CAPTURE_FAILED              206
#define IDR_CURRENT_TREE                207
#define IDR_CURRENT_SERVER              208
#define IDR_CURRENT_CONTEXT             209
#define IDR_AUTHENTICATING_SERVER       210
#define IDR_NO_END_QUOTE                211
#define IDR_ALREADY_ATTACHED            212

//
// BEGIN WARNING!!!  Items below MUST be consequtive. Eg. the code assumes 
// that March is January+2.
//

#define IDR_GREETING_MORNING            300
#define IDR_GREETING_AFTERNOON          301
#define IDR_GREETING_EVENING            302

#define IDR_AM                          305
#define IDR_PM                          306

#define IDR_SUNDAY                      310
#define IDR_MONDAY                      311
#define IDR_TUESDAY                     312
#define IDR_WEDNESDAY                   313
#define IDR_THURSDAY                    314
#define IDR_FRIDAY                      315
#define IDR_SATURDAY                    316

#define IDR_JANUARY                     320
#define IDR_FEBRUARY                    321
#define IDR_MARCH                       322
#define IDR_APRIL                       323
#define IDR_MAY                         324
#define IDR_JUNE                        325
#define IDR_JULY                        326
#define IDR_AUGUST                      327
#define IDR_SEPTEMBER                   328
#define IDR_OCTOBER                     329
#define IDR_NOVEMBER                    330
#define IDR_DECEMBER                    331

//
// END WARNING!!!  
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\perf\nwperf.c ===
/****************************************************************************

    PROGRAM: NWPerf.c

    PURPOSE: Contains library routines for providing perfmon with data

    FUNCTIONS:
*******************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntddnwfs.h>
#include "NWPerf.h"
#include "prfutil.h"

#ifndef QFE_BUILD
#include "ntprfctr.h"
#endif



BOOL gbInitOK = FALSE;

HANDLE hNetWareRdr ;
extern NW_DATA_DEFINITION NWDataDefinition;

#ifdef QFE_BUILD
TCHAR PerformanceKeyName [] =
        TEXT("SYSTEM\\CurrentControlSet\\Services\\NWrdr\\Performance");
TCHAR FirstCounterKeyName [] = TEXT("First Counter");
TCHAR FirstHelpKeyName [] = TEXT("First Help");
#endif

/****************************************************************************
   FUNCTION: OpenNetWarePerformanceData

   Purpose:  This routine also initializes the data structures used to pass
             data back to the registry

   Return:   None.
r****************************************************************************/
DWORD APIENTRY
OpenNetWarePerformanceData(
                       LPWSTR pInstances )
{

    LONG status;
#ifdef QFE_BUILD
    HKEY hKeyPerf = 0;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
#else
    NT_PRODUCT_TYPE ProductType;
    DWORD dwFirstCounter = NWCS_CLIENT_COUNTER_INDEX ;
    DWORD dwFirstHelp = NWCS_CLIENT_HELP_INDEX ;
#endif

    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING DeviceNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;

#ifdef QFE_BUILD
    status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
        PerformanceKeyName,
        0L, KEY_ALL_ACCESS, &hKeyPerf );

    if (status != ERROR_SUCCESS) {
        goto OpenExitPoint;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx( hKeyPerf, FirstCounterKeyName, 0L, &type,
        (LPBYTE)&dwFirstCounter, &size);

    if (status != ERROR_SUCCESS) {
        goto OpenExitPoint;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx( hKeyPerf, FirstHelpKeyName,
        0L, &type, (LPBYTE)&dwFirstHelp, &size );

    if (status != ERROR_SUCCESS) {
        goto OpenExitPoint;
    }
#endif

    //
    //  NOTE: the initialization program could also retrieve
    //      LastCounter and LastHelp if they wanted to do
    //      bounds checking on the new number. e.g.
    //
    //      counter->CounterNameTitleIndex += dwFirstCounter;
    //      if (counter->CounterNameTitleIndex > dwLastCounter) {
    //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
    //      }

    NWDataDefinition.NWObjectType.ObjectNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NWObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    // Counters not defined in Redirector, setup the correct IDs
    NWDataDefinition.PacketBurstRead.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstRead.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstReadTimeouts.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstReadTimeouts.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstWrite.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstWrite.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstWriteTimeouts.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstWriteTimeouts.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstIO.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstIO.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.NetWare2XConnects.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NetWare2XConnects.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.NetWare3XConnects.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NetWare3XConnects.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.NetWare4XConnects.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NetWare4XConnects.CounterHelpTitleIndex += dwFirstHelp;


#ifndef QFE_BUILD
    // Check for WorkStation or Server and use the gateway indexes if
    // currently running on Server.
    // If RtlGetNtProductType is not successful or ProductType is
    // WinNt machine, ObjectNameTitleIndex and ObjectHelpTitleIndex are set
    // to the correct values already.
#ifdef GATEWAY_ENABLED
    if ( RtlGetNtProductType( &ProductType))
    {
        if ( ProductType != NtProductWinNt )
        {
            NWDataDefinition.NWObjectType.ObjectNameTitleIndex = NWCS_GATEWAY_COUNTER_INDEX;
            NWDataDefinition.NWObjectType.ObjectHelpTitleIndex = NWCS_GATEWAY_HELP_INDEX;
        }
    }
#endif
#endif

    hNetWareRdr = NULL;

    RtlInitUnicodeString(&DeviceNameU, DD_NWFS_DEVICE_NAME_U);

    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceNameU,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    status = NtCreateFile(&hNetWareRdr,
                          SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                          );

    gbInitOK = TRUE; // ok to use this function

    status = ERROR_SUCCESS; // for successful exit

#ifdef QFE_BUILD
OpenExitPoint:
    if (hKeyPerf)
       RegCloseKey (hKeyPerf); // close key to registry
#endif

    return ((DWORD) status);
}


/****************************************************************************
   FUNCTION: CollectNetWarePerformanceData

   Purpose:  This routine will return the data for the NetWare counters.

   Arguments:IN       LPWSTR   lpValueName
                 pointer to a wide character string passed by registry.

             IN OUT   LPVOID   *lppData
                 IN: pointer to the address of the buffer to receive the
                 completed PerfDataBlock and subordinate structures. This
                 routine will append its data to the buffer starting at
                 the point referenced by *lppData.

                 OUT: points to the first byte after the data structure
                 added by this routine. This routine updated the value at
                 lppdata after appending its data.

             IN OUT   LPDWORD  lpcbTotalBytes
                 IN: the address of the DWORD that tells the size in bytes
                 of the buffer referenced by the lppData argument

                 OUT: the number of bytes added by this routine is written
                 to the DWORD pointed to by this argument

             IN OUT   LPDWORD  NumObjectTypes
                 IN: the address of the DWORD to receive the number of
                 objects added by this routine

                 OUT: the number of objects added by this routine is written
                 to the DWORD pointed to by this argument

    Return:  ERROR_MORE_DATA if buffer passed is too small to hold data
                             any error conditions encountered are reported
                             to the event log if event logging is enabled.

             ERROR_SUCCESS   if success or any other error. Errors, however
                             are also reported to the event log.

****************************************************************************/
DWORD APIENTRY
CollectNetWarePerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes)
{
    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    DWORD  dwQueryType;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    NW_DATA_DEFINITION *pNWDataDefinition;
    LONG status;
    NW_REDIR_STATISTICS NWRdrStatistics;
    LARGE_INTEGER UNALIGNED *pliCounter;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // before doing anything else, see if Open went OK
    //
    if (!gbInitOK) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    // If the caller only wanted some counter, check if we have 'em
    if (dwQueryType == QUERY_ITEMS){
        if ( !(IsNumberInUnicodeList (
               NWDataDefinition.NWObjectType.ObjectNameTitleIndex,
                lpValueName))) {
             // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pNWDataDefinition = (NW_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(NW_DATA_DEFINITION) + SIZE_OF_COUNTER_BLOCK;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ((DWORD) ERROR_MORE_DATA);
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    memmove( pNWDataDefinition, &NWDataDefinition,
             sizeof(NW_DATA_DEFINITION) );

    // Point at the byte right after all the definitions
    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pNWDataDefinition[1];

    // The first DWORD should specify the size of actual data block
    pPerfCounterBlock->ByteLength = SIZE_OF_COUNTER_BLOCK;

    // Move the pointer up
    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);


    // Open the NetWare data
    if ( hNetWareRdr != NULL) {
        status = NtFsControlFile(hNetWareRdr,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_NWR_GET_STATISTICS,
                                 NULL,
                                 0,
                                 &NWRdrStatistics,
                                 sizeof(NWRdrStatistics)
                                 );
    }
    if ( hNetWareRdr != NULL && NT_SUCCESS(status) ) {

        pliCounter = (LARGE_INTEGER UNALIGNED * ) (&pPerfCounterBlock[1]);

        pliCounter->QuadPart = NWRdrStatistics.BytesReceived.QuadPart +
                                NWRdrStatistics.BytesTransmitted.QuadPart;

        pdwCounter = (PDWORD) ++pliCounter;
        *pdwCounter = NWRdrStatistics.ReadOperations +
                      NWRdrStatistics.WriteOperations;
        pliCounter = (LARGE_INTEGER UNALIGNED * ) ++pdwCounter;
        pliCounter->QuadPart = NWRdrStatistics.NcpsReceived.QuadPart + 
                               NWRdrStatistics.NcpsTransmitted.QuadPart;
        *++pliCounter = NWRdrStatistics.BytesReceived;
        *++pliCounter = NWRdrStatistics.NcpsReceived;
        *++pliCounter = NWRdrStatistics.BytesTransmitted;
        *++pliCounter = NWRdrStatistics.NcpsTransmitted;
        pdwCounter = (PDWORD) ++pliCounter;
        *pdwCounter = NWRdrStatistics.ReadOperations;
        *++pdwCounter = NWRdrStatistics.RandomReadOperations;
        *++pdwCounter = NWRdrStatistics.ReadNcps;
        *++pdwCounter = NWRdrStatistics.WriteOperations;
        *++pdwCounter = NWRdrStatistics.RandomWriteOperations;
        *++pdwCounter = NWRdrStatistics.WriteNcps;
        *++pdwCounter = NWRdrStatistics.Sessions;
        *++pdwCounter = NWRdrStatistics.Reconnects;
        *++pdwCounter = NWRdrStatistics.NW2xConnects;
        *++pdwCounter = NWRdrStatistics.NW3xConnects;
        *++pdwCounter = NWRdrStatistics.NW4xConnects;
        *++pdwCounter = NWRdrStatistics.ServerDisconnects;

        *++pdwCounter = NWRdrStatistics.PacketBurstReadNcps;
        *++pdwCounter = NWRdrStatistics.PacketBurstReadTimeouts;
        *++pdwCounter = NWRdrStatistics.PacketBurstWriteNcps;
        *++pdwCounter = NWRdrStatistics.PacketBurstWriteTimeouts;
        *++pdwCounter = NWRdrStatistics.PacketBurstReadNcps +
                        NWRdrStatistics.PacketBurstWriteNcps;

        //
        // Add an extra empty DWORD to pad the buffer to an 8-byte boundary
        //
        *++pdwCounter = 0;

        *lppData = (LPVOID) ++pdwCounter;

    } else {

        //
        // Failure to access Redirector: clear counters to 0
        //

        memset(&pPerfCounterBlock[1],
               0,
               SIZE_OF_COUNTER_BLOCK - sizeof(pPerfCounterBlock));

        pdwCounter = (PDWORD) ((PBYTE) pPerfCounterBlock + SIZE_OF_COUNTER_BLOCK);
        *lppData = (LPVOID) pdwCounter;

    }


    // We sent data for only one Object. (Remember not to confuse this
    // with counters. Even if more counters are added, the number of object
    // is still only one. However, this does not mean more objects cannot
    // be added
    *lpNumObjectTypes = 1;

    // Fill in the number of bytes we copied - incl. the definitions and the
    // counter data.
    *lpcbTotalBytes = (DWORD) ((PBYTE) pdwCounter - (PBYTE) pNWDataDefinition);

    //
    // Make sure the output buffer is 8-byte aligned
    //
    ASSERT((*lpcbTotalBytes & 0x7) == 0);

    return ERROR_SUCCESS;
}

/****************************************************************************
   FUNCTION: CloseNetWarePerformanceData

   Purpose:  This routine closes the open handles to NetWare performance counters


   Return:   ERROR_SUCCESS

****************************************************************************/
DWORD APIENTRY
CloseNetWarePerformanceData(
)
{
    if ( hNetWareRdr ) {

        NtClose( hNetWareRdr );
        hNetWareRdr = NULL;
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\perf\nwperf.h ===
//
//    MODULE: NWPerf.H
//
//    This file contains all the defines and prototypes for the performnce
//    monitoring DLL for NetWare redirector
//
//    Date: Sept, 28 1993


//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
// All these definitions will have to be updated when new counters are added.
// if a new counter called COUNTX is added then the Help and Title indicies
// defines should include a new entry -  "#define COUNTXOBJ 4". This increases
// in increments of 2 because each counter has a title and help index.
//
// The Offset of the counters should have another entry - with the size of
// the data for COUNT -
// "#define COUNTER_OFFSET_COUNTX COUNTER_OFFSET_USERS+sizeof(COUNTX_TYPE)"
//
// The SIZE_OF_COUNTER_BLOCK will be updated to:
// "#define SIZE_OF_COUNTER_BLOCK  COUNTER_OFFSET_COUNTX + sizeof(DWORD)"
//
// Finally the NW_DATA_DEFINITION will have a new PERF_COUNTER_DEFINTIION
// entry

// Title and Help index defines. These are used for looking up the Registry
// to get at the counter indicies for the title and help strings.

#define NW_NUM_OBJECTS              1
#define NWOBJ                       0
#define PACKET_BURST_READ_ID        2
#define PACKET_BURST_READ_TO_ID     4
#define PACKET_BURST_WRITE_ID       6
#define PACKET_BURST_WRITE_TO_ID    8
#define PACKET_BURST_IO_ID         10
#define CONNECT_2X_ID              12
#define CONNECT_3X_ID              14
#define CONNECT_4X_ID              16

//
// NetWare Redirector data object definitions.
// The offsets of the counters. The first DWORD is the size of the counter
// data block. In WinPerf, you will see this as PERF_COUNTER_BLOCK.ByteLength
//
#define BYTES_OFFSET                    sizeof(DWORD)
#define IO_OPERATIONS_OFFSET            BYTES_OFFSET + sizeof(LARGE_INTEGER)
#define PACKETS_OFFSET                  IO_OPERATIONS_OFFSET + sizeof(DWORD)
#define BYTES_RECEIVED_OFFSET           PACKETS_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define NCPS_RECEIVED_OFFSET            BYTES_RECEIVED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define BYTES_TRANSMITTED_OFFSET               \
                                        NCPS_RECEIVED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define NCPS_TRANSMITTED_OFFSET                \
                                        BYTES_TRANSMITTED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define RDR_READ_OPERATIONS_OFFSET                 \
                                        NCPS_TRANSMITTED_OFFSET  + \
                                        sizeof(LARGE_INTEGER)
#define RANDOM_READ_OPERATIONS_OFFSET   RDR_READ_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define READ_NCPS_OFFSET                RANDOM_READ_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define RDR_WRITE_OPERATIONS_OFFSET     READ_NCPS_OFFSET + \
                                        sizeof(DWORD)
#define RANDOM_WRITE_OPERATIONS_OFFSET  RDR_WRITE_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define WRITE_NCPS_OFFSET               RANDOM_WRITE_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define SESSIONS_OFFSET                 WRITE_NCPS_OFFSET + \
                                        sizeof(DWORD)
#define RECONNECTS_OFFSET               SESSIONS_OFFSET + \
                                        sizeof(DWORD)
#define NETWARE_2X_CONNECTS_OFFSET      RECONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define NETWARE_3X_CONNECTS_OFFSET      NETWARE_2X_CONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define NETWARE_4X_CONNECTS_OFFSET      NETWARE_3X_CONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define SERVER_DISCONNECTS_OFFSET       NETWARE_4X_CONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_READ_OFFSET        SERVER_DISCONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_READ_TO_OFFSET     PACKET_BURST_READ_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_WRITE_OFFSET       PACKET_BURST_READ_TO_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_WRITE_TO_OFFSET    PACKET_BURST_WRITE_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_IO_OFFSET          PACKET_BURST_WRITE_TO_OFFSET + \
                                        sizeof(DWORD)
#define EIGHT_BYTE_PAD_OFFSET           PACKET_BURST_IO_OFFSET + \
                                        sizeof(DWORD)
#define SIZE_OF_COUNTER_BLOCK           EIGHT_BYTE_PAD_OFFSET + \
                                        sizeof(DWORD)




// The definition of the NetWare Data definition. This structure holds the
// definition for actual NetWare object and the definition for each of the
// counters.
typedef struct _NW_DATA_DEFINITION {
    PERF_OBJECT_TYPE        NWObjectType;
    PERF_COUNTER_DEFINITION Bytes;
    PERF_COUNTER_DEFINITION IoOperations;
    PERF_COUNTER_DEFINITION Ncps;
    PERF_COUNTER_DEFINITION BytesReceived;
    PERF_COUNTER_DEFINITION NcpsReceived;
    PERF_COUNTER_DEFINITION BytesTransmitted;
    PERF_COUNTER_DEFINITION NcpsTransmitted;
    PERF_COUNTER_DEFINITION ReadOperations;
    PERF_COUNTER_DEFINITION RandomReadOperations;
    PERF_COUNTER_DEFINITION ReadNcps;
    PERF_COUNTER_DEFINITION WriteOperations;
    PERF_COUNTER_DEFINITION RandomWriteOperations;
    PERF_COUNTER_DEFINITION WriteNcps;
    PERF_COUNTER_DEFINITION Sessions;
    PERF_COUNTER_DEFINITION Reconnects;
    PERF_COUNTER_DEFINITION NetWare2XConnects;
    PERF_COUNTER_DEFINITION NetWare3XConnects;
    PERF_COUNTER_DEFINITION NetWare4XConnects;
    PERF_COUNTER_DEFINITION ServerDisconnects;
    PERF_COUNTER_DEFINITION PacketBurstRead;
    PERF_COUNTER_DEFINITION PacketBurstReadTimeouts;
    PERF_COUNTER_DEFINITION PacketBurstWrite;
    PERF_COUNTER_DEFINITION PacketBurstWriteTimeouts;
    PERF_COUNTER_DEFINITION PacketBurstIO;
} NW_DATA_DEFINITION;

#pragma pack ()

PM_OPEN_PROC         OpenNetWarePerformanceData;
PM_COLLECT_PROC      CollectNetWarePerformanceData;
PM_CLOSE_PROC        CloseNetWarePerformanceData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\perf\prfutil.c ===
//
// Prfutil.h
//
// Utility procedures from the VGACTRS code in the DDK
//
#include "windows.h"
#include <winperf.h>

#define DEFINE_STRING
#include "prfutil.h"

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    TCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    TCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    TCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = TEXT(' ');
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - TEXT('0'));
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\perf\prfutil.h ===
//
// Prfutil.h
//
// Utility procedures from the VGACTRS code in the DDK
//
#ifndef _PRFUTIL_
#define _PRF_UTIL_

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

#define DIGIT           1
#define DELIMITER       2
#define INVALID         3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

BOOL  IsNumberInUnicodeList ( IN DWORD   dwNumber, IN LPWSTR  lpwszUnicodeList );
DWORD GetQueryType          ( IN LPWSTR lpValue );

// only prfutil.c will define GLOBAL_STRING
#ifdef DEFINE_STRING
TCHAR GLOBAL_STRING[]  = TEXT("Global");
TCHAR FOREIGN_STRING[] = TEXT("Foreign");
TCHAR COSTLY_STRING[]  = TEXT("Costly");
TCHAR NULL_STRING[]    = TEXT("\0");    // pointer to null string
#else
extern TCHAR GLOBAL_STRING[];
extern TCHAR FOREIGN_STRING[];
extern TCHAR COSTLY_STRING[];
extern TCHAR NULL_STRING[];
#endif


#endif // _PRFUTIL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\cleanup.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements the file cleanup routine for Netware Redirector.

Author:

    Manny Weiser (mannyw)    9-Feb-1993

Revision History:

--*/

#include "procs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
NwCommonCleanup (
    IN PIRP_CONTEXT IrpContext
    );


NTSTATUS
NwCleanupRcb (
    IN PIRP Irp,
    IN PRCB Rcb
    );

NTSTATUS
NwCleanupScb (
    IN PIRP Irp,
    IN PSCB Scb
    );

NTSTATUS
NwCleanupIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PICB Icb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdCleanup )
#pragma alloc_text( PAGE, NwCommonCleanup )
#pragma alloc_text( PAGE, NwCleanupScb )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, NwCleanupIcb )
#endif

#endif

#if 0   // Not pageable

NwCleanupRcb

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCleanupFile API calls.

Arguments:

    DeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdCleanup\n", 0);

    //
    // Call the common cleanup routine.
    //

    TopLevel = NwIsIrpTopLevel( Irp );

    FsRtlEnterFileSystem();

    try {

        IrpContext = AllocateIrpContext( Irp );
        status = NwCommonCleanup( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( IrpContext == NULL ) {
        
            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            // We had some trouble trying to perform the requested
            // operation, so we'll abort the I/O request with
            // the error status that we get back from the
            // execption code.
            //

            status = NwProcessException( IrpContext, GetExceptionCode() );
        }
    }

    if ( IrpContext ) {
        NwCompleteRequest( IrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "NwFsdCleanup -> %08lx\n", status );
    return status;
}


NTSTATUS
NwCommonCleanup (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for cleaning up a file.

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsContext2;

    PAGED_CODE();

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonCleanup\n", 0);
    DebugTrace( 0, Dbg, "IrpContext       = %08lx\n", (ULONG_PTR)IrpContext);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG_PTR)irpSp->FileObject);

    try {

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed.
        //

        if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                                &fsContext,
                                                &fsContext2 )) == NTC_UNDEFINED) {

            DebugTrace(0, Dbg, "The file is disconnected\n", 0);

            status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "NwCommonCleanup -> %08lx\n", status );
            try_return( NOTHING );
        }

        //
        // Decide how to handle this IRP.
        //

        switch (nodeTypeCode) {

        case NW_NTC_RCB:       // Cleanup the file system

            status = NwCleanupRcb( Irp, (PRCB)fsContext2 );
            break;

        case NW_NTC_SCB:       // Cleanup the server control block

            status = NwCleanupScb( Irp, (PSCB)fsContext2 );
            break;

        case NW_NTC_ICB:       // Cleanup the remote file
        case NW_NTC_ICB_SCB:   // Cleanup the server

            status = NwCleanupIcb( IrpContext, Irp, (PICB)fsContext2 );
            break;

#ifdef NWDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheck( RDR_FILE_SYSTEM );
            break;
#endif

        }

    try_exit: NOTHING;

    } finally {

        DebugTrace(-1, Dbg, "NwCommonCleanup -> %08lx\n", status);

    }

    return status;
}


NTSTATUS
NwCleanupRcb (
    IN PIRP Irp,
    IN PRCB Rcb
    )

/*++

Routine Description:

    The routine cleans up a RCB.

    This routine grabs a spinlock so must not be paged out while running.

    Do not reference the code section since this will start the timer and
    we don't stop it in the rcb close path.

Arguments:

    Irp - Supplies the IRP associated with the cleanup.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT closingFileObject;
    BOOLEAN OwnRcb;
    BOOLEAN OwnMessageLock = FALSE;
    KIRQL OldIrql;
    PLIST_ENTRY listEntry, nextListEntry;
    PIRP_CONTEXT pTestIrpContext;
    PIO_STACK_LOCATION pTestIrpSp;
    PIRP pTestIrp;

    DebugTrace(+1, Dbg, "NwCleanupRcb...\n", 0);

    //
    //  Now acquire exclusive access to the Rcb
    //

    NwAcquireExclusiveRcb( Rcb, TRUE );
    OwnRcb = TRUE;

    status = STATUS_SUCCESS;

    try {

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        IoRemoveShareAccess( irpSp->FileObject,
                             &Rcb->ShareAccess );

        NwReleaseRcb( Rcb );
        OwnRcb = FALSE;

        closingFileObject = irpSp->FileObject;


        //
        //  Walk the message queue and complete any outstanding Get Message IRPs
        //

        KeAcquireSpinLock( &NwMessageSpinLock, &OldIrql );
        OwnMessageLock = TRUE;

        for ( listEntry = NwGetMessageList.Flink;
              listEntry != &NwGetMessageList;
              listEntry = nextListEntry ) {

            nextListEntry = listEntry->Flink;

            //
            //  If the file object of the queued request, matches the file object
            //  that is being closed, remove the IRP from the queue, and
            //  complete it with an error.
            //

            pTestIrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );
            pTestIrp = pTestIrpContext->pOriginalIrp;
            pTestIrpSp = IoGetCurrentIrpStackLocation( pTestIrp );

            if ( pTestIrpSp->FileObject == closingFileObject ) {
                RemoveEntryList( listEntry );

                IoAcquireCancelSpinLock( &pTestIrp->CancelIrql );
                IoSetCancelRoutine( pTestIrp, NULL );
                IoReleaseCancelSpinLock( pTestIrp->CancelIrql );

                NwCompleteRequest( pTestIrpContext, STATUS_INVALID_HANDLE );
            }

        }

        KeReleaseSpinLock( &NwMessageSpinLock, OldIrql );
        OwnMessageLock = FALSE;

    } finally {

        if ( OwnRcb ) {
            NwReleaseRcb( Rcb );
        }

        if ( OwnMessageLock ) {
            KeReleaseSpinLock( &NwMessageSpinLock, OldIrql );
        }

        DebugTrace(-1, Dbg, "NwCleanupRcb -> %08lx\n", status);
    }

    //
    //  And return to our caller
    //

    return status;
}


NTSTATUS
NwCleanupScb (
    IN PIRP Irp,
    IN PSCB Scb
    )

/*++

Routine Description:

    The routine cleans up an ICB.

Arguments:

    Irp - Supplies the IRP associated with the cleanup.

    Scb - Supplies the SCB to cleanup.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCleanupScb...\n", 0);

    Status = STATUS_SUCCESS;

    try {

        //
        // Ensure that this SCB is still active.
        //

        NwVerifyScb( Scb );

        //
        // Cancel any IO on this SCB.
        //

    } finally {

        DebugTrace(-1, Dbg, "NwCleanupScb -> %08lx\n", Status);
    }

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
NwCleanupIcb (
    IN PIRP_CONTEXT pIrpContext,
    IN PIRP Irp,
    IN PICB Icb
    )

/*++

Routine Description:

    The routine cleans up an ICB.

Arguments:

    Irp - Supplies the IRP associated with the cleanup.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS Status;
    PNONPAGED_FCB NpFcb;

    DebugTrace(+1, Dbg, "NwCleanupIcb...\n", 0);

    Status = STATUS_SUCCESS;

    try {

        Icb->State = ICB_STATE_CLEANED_UP;

        //
        // Cancel any IO on this ICB.
        //

#if 0
        //  HACKHACK

        if ( Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_DCB ) {

            PLIST_ENTRY listEntry;

            NwAcquireExclusiveRcb( &NwRcb, TRUE );

            for ( listEntry = FnList.Flink; listEntry != &FnList ; listEntry = listEntry->Flink ) {

                PIRP_CONTEXT IrpContext;

                IrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );

                if ( IrpContext->Icb == Icb ) {

                    PIRP irp = pIrpContext->pOriginalIrp;

                    IoAcquireCancelSpinLock( &irp->CancelIrql );
                    IoSetCancelRoutine( irp, NULL );
                    IoReleaseCancelSpinLock( irp->CancelIrql );

                    RemoveEntryList( &IrpContext->NextRequest );
                    NwCompleteRequest( IrpContext, STATUS_NOT_SUPPORTED );
                    break;
                }
            }

            NwReleaseRcb( &NwRcb );
        }
#endif

        //
        // If this is a remote file clear all the cache garbage.
        //

        if ( Icb->NodeTypeCode == NW_NTC_ICB ) {

            if ( Icb->HasRemoteHandle ) {

                //
                // Free all of file lock structures that are still hanging around.
                //

                pIrpContext->pScb = Icb->SuperType.Fcb->Scb;
                pIrpContext->pNpScb = Icb->SuperType.Fcb->Scb->pNpScb;

                NwFreeLocksForIcb( pIrpContext, Icb );

                NwDequeueIrpContext( pIrpContext, FALSE );

                //
                //
                //
                //  If this is an executable opened over the net, then
                //  its possible that the executables image section
                //  might still be kept open.
                //
                //  Ask MM to flush the section closed.  This will fail
                //  if the executable in question is still running.
                //

                NpFcb = Icb->SuperType.Fcb->NonPagedFcb;
                MmFlushImageSection(&NpFcb->SegmentObject, MmFlushForWrite);

                //
                //  There is also a possiblity that there is a user section
                //  open on this file, in which case we need to force the
                //  section closed to make sure that they are cleaned up.
                //

                MmForceSectionClosed(&NpFcb->SegmentObject, TRUE);

            }

            //
            //  Acquire the fcb and remove shared access.
            //

            NwAcquireExclusiveFcb( Icb->SuperType.Fcb->NonPagedFcb, TRUE );

            IoRemoveShareAccess(
                Icb->FileObject,
                &Icb->SuperType.Fcb->ShareAccess );

            NwReleaseFcb( Icb->SuperType.Fcb->NonPagedFcb );
        }


    } finally {

        DebugTrace(-1, Dbg, "NwCleanupIcb -> %08lx\n", Status);
    }

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\cache.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Cache.c

Abstract:

    This module implements internal caching support routines.  It does
    not interact with the cache manager.

Author:

    Manny Weiser     [MannyW]    05-Jan-1994

Revision History:

--*/

#include "Procs.h"

//
//  The local debug trace level
//

BOOLEAN
SpaceForWriteBehind(
    PNONPAGED_FCB NpFcb,
    ULONG FileOffset,
    ULONG BytesToWrite
    );

BOOLEAN
OkToReadAhead(
    PFCB Fcb,
    IN ULONG FileOffset,
    IN UCHAR IoType
    );

#define Dbg                              (DEBUG_TRACE_CACHE)

//
//  Local procedure prototypes
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, CacheRead )
#pragma alloc_text( PAGE, SpaceForWriteBehind )
#pragma alloc_text( PAGE, CacheWrite )
#pragma alloc_text( PAGE, OkToReadAhead )
#pragma alloc_text( PAGE, CalculateReadAheadSize )
#pragma alloc_text( PAGE, FlushCache )
#pragma alloc_text( PAGE, AcquireFcbAndFlushCache )
#endif


ULONG
CacheRead(
    IN PNONPAGED_FCB NpFcb,
    IN ULONG FileOffset,
    IN ULONG BytesToRead,
    IN PVOID UserBuffer
    , IN BOOLEAN WholeBufferOnly
    )
/*++

Routine Description:

    This routine attempts to satisfy a user read from cache.  It returns
    the number of bytes actually copied from cache.

Arguments:

    NpFcb - A pointer the the nonpaged FCB of the file being read.

    FileOffset - The file offset to read.

    BytesToRead - The number of bytes to read.

    UserBuffer - A pointer to the users target buffer.

    WholeBufferOnly - Do a cache read only if we can satisfy the entire
        read request.

Return Value:

    The number of bytes copied to the user buffer.

--*/
{
    ULONG BytesToCopy;

    PAGED_CODE();

    if (DisableReadCache) return 0 ;

    DebugTrace(0, Dbg, "CacheRead...\n", 0 );
    DebugTrace( 0, Dbg, "FileOffset = %d\n", FileOffset );
    DebugTrace( 0, Dbg, "ByteCount  = %d\n", BytesToRead );

    NwAcquireSharedFcb( NpFcb, TRUE );

    //
    //  If this is a read ahead and it contains some data that the user
    //  could be interested in, copy the interesting data.
    //

    if ( NpFcb->CacheType == ReadAhead &&
         NpFcb->CacheDataSize != 0 &&
         FileOffset >= NpFcb->CacheFileOffset &&
         FileOffset <= NpFcb->CacheFileOffset + NpFcb->CacheDataSize ) {

        if ( NpFcb->CacheBuffer ) {

            //
            // Make sure we have a CacheBuffer.
            //

            BytesToCopy =
                MIN ( BytesToRead,
                      NpFcb->CacheFileOffset +
                          NpFcb->CacheDataSize - FileOffset );

            if ( WholeBufferOnly && BytesToCopy != BytesToRead ) {
                NwReleaseFcb( NpFcb );
                return( 0 );
            }

            RtlCopyMemory(
                UserBuffer,
                NpFcb->CacheBuffer + ( FileOffset - NpFcb->CacheFileOffset ),
                BytesToCopy );

            DebugTrace(0, Dbg, "CacheRead -> %d\n", BytesToCopy );

        } else {

            ASSERT(FALSE);      // we should never get here
            DebugTrace(0, Dbg, "CacheRead -> %08lx\n", 0 );
            BytesToCopy = 0;
        }


    } else {

        DebugTrace(0, Dbg, "CacheRead -> %08lx\n", 0 );
        BytesToCopy = 0;
    }

    NwReleaseFcb( NpFcb );
    return( BytesToCopy );
}


BOOLEAN
SpaceForWriteBehind(
    PNONPAGED_FCB NpFcb,
    ULONG FileOffset,
    ULONG BytesToWrite
    )
/*++

Routine Description:

    This routine determines if it is ok to write behind this data to
    this FCB.

Arguments:

    NpFcb - A pointer the the NONPAGED_FCB of the file being written.

    FileOffset - The file offset to write.

    BytesToWrite - The number of bytes to write.

Return Value:

    The number of bytes copied to the user buffer.

--*/
{
    PAGED_CODE();


    if ( NpFcb->CacheDataSize == 0 ) {
        NpFcb->CacheFileOffset = FileOffset;
    }

    if ( NpFcb->CacheDataSize == 0 && BytesToWrite >= NpFcb->CacheSize ) {
        return( FALSE );
    }

    if ( FileOffset - NpFcb->CacheFileOffset + BytesToWrite >
         NpFcb->CacheSize )  {

        return( FALSE );

    }

    return( TRUE );
}


BOOLEAN
CacheWrite(
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PNONPAGED_FCB NpFcb,
    IN ULONG FileOffset,
    IN ULONG BytesToWrite,
    IN PVOID UserBuffer
    )
/*++

Routine Description:

    This routine attempts to satisfy a user write to cache.  The write
    succeeds if it is sequential and fits in the cache buffer.

Arguments:

    IrpContext - A pointer to request parameters.

    NpFcb - A pointer the the NONPAGED_FCB of the file being read.

    FileOffset - The file offset to write.

    BytesToWrite - The number of bytes to write.

    UserBuffer - A pointer to the users source buffer.

Return Value:

    The number of bytes copied to the user buffer.

--*/
{
    ULONG CacheSize;
    NTSTATUS status;

    PAGED_CODE();

    if (DisableWriteCache) return FALSE ;

    DebugTrace( +1, Dbg, "CacheWrite...\n", 0 );
    DebugTrace(  0, Dbg, "FileOffset = %d\n", FileOffset );
    DebugTrace(  0, Dbg, "ByteCount  = %d\n", BytesToWrite );

    //
    // Grab the FCB resource so that we can check the
    // share access.  (Bug 68546)
    //

    NwAcquireSharedFcb( NpFcb, TRUE );

    if ( NpFcb->Fcb->ShareAccess.SharedWrite ||
         NpFcb->Fcb->ShareAccess.SharedRead ) {

        DebugTrace(  0, Dbg, "File is not open in exclusive mode\n", 0 );
        DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );

        NwReleaseFcb( NpFcb );
        return( FALSE );
    }

    NwReleaseFcb( NpFcb );

    //
    //  Note, If we decide to send data to the server we must be at the front
    //  of the queue before we grab the Fcb exclusive.
    //

TryAgain:

    NwAcquireExclusiveFcb( NpFcb, TRUE );

    //
    //  Allocate a cache buffer if we don't already have one.
    //

    if ( NpFcb->CacheBuffer == NULL ) {

        if ( IrpContext == NULL ) {
            DebugTrace(  0, Dbg, "No cache buffer\n", 0 );
            DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );
            NwReleaseFcb( NpFcb );
            return( FALSE );
        }

        NpFcb->CacheType = WriteBehind;

        if (( IrpContext->pNpScb->SendBurstModeEnabled ) ||
            ( IrpContext->pNpScb->ReceiveBurstModeEnabled )) {

           CacheSize = IrpContext->pNpScb->MaxReceiveSize;

        } else {

           CacheSize = IrpContext->pNpScb->BufferSize;

        }

        try {

            NpFcb->CacheBuffer = ALLOCATE_POOL_EX( NonPagedPool, CacheSize );
            NpFcb->CacheSize = CacheSize;

            NpFcb->CacheMdl = ALLOCATE_MDL( NpFcb->CacheBuffer, CacheSize, FALSE, FALSE, NULL );

            if ( NpFcb->CacheMdl == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmBuildMdlForNonPagedPool( NpFcb->CacheMdl );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            if ( NpFcb->CacheBuffer != NULL) {
                FREE_POOL( NpFcb->CacheBuffer );

                NpFcb->CacheBuffer = NULL;
                NpFcb->CacheSize = 0;

            }

            DebugTrace(  0, Dbg, "Allocate failed\n", 0 );
            DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );

            NpFcb->CacheDataSize = 0;
            NwReleaseFcb( NpFcb );
            return( FALSE );
        }

        NpFcb->CacheFileOffset = 0;
        NpFcb->CacheDataSize = 0;

    } else if ( NpFcb->CacheType != WriteBehind ) {

        DebugTrace( -1, Dbg, "CacheWrite not writebehind -> FALSE\n", 0 );
        NwReleaseFcb( NpFcb );
        return( FALSE );

    }

    //
    //  If the data is non sequential and non overlapping, flush the
    //  existing cache.
    //

    if ( NpFcb->CacheDataSize != 0 &&
         ( FileOffset < NpFcb->CacheFileOffset ||
           FileOffset > NpFcb->CacheFileOffset + NpFcb->CacheDataSize ) ) {

        //
        // Release and then AcquireFcbAndFlush() will get us to the front
        // of the queue before re-acquiring. This avoids potential deadlocks.
        //

        NwReleaseFcb( NpFcb );

        if ( IrpContext != NULL ) {
            DebugTrace(  0, Dbg, "Data is not sequential, flushing data\n", 0 );

            status = AcquireFcbAndFlushCache( IrpContext, NpFcb );

            if ( !NT_SUCCESS( status ) ) {
                ExRaiseStatus( status );
            }

        }

    DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );
    return( FALSE );

    }

    //
    //  The data is sequential, see if it fits.
    //

    if ( SpaceForWriteBehind( NpFcb, FileOffset, BytesToWrite ) ) {

        try {

            RtlCopyMemory(
                NpFcb->CacheBuffer + ( FileOffset - NpFcb->CacheFileOffset ),
                UserBuffer,
                BytesToWrite );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            DebugTrace( 0, Dbg, "Bad user mode buffer in CacheWrite.\n", 0 );
            DebugTrace(-1, Dbg, "CacheWrite -> FALSE\n", 0 );
            NwReleaseFcb( NpFcb );
            return ( FALSE );
        }

        if ( NpFcb->CacheDataSize <
             (FileOffset - NpFcb->CacheFileOffset + BytesToWrite) ) {

            NpFcb->CacheDataSize =
                FileOffset - NpFcb->CacheFileOffset + BytesToWrite;

        }

        DebugTrace(-1, Dbg, "CacheWrite -> TRUE\n", 0 );
        NwReleaseFcb( NpFcb );
        return( TRUE );

    } else if ( IrpContext != NULL ) {

        //
        //  The data didn't fit in the cache. If the cache is empty
        //  then its time to return because it never will fit and we
        //  have no stale data. This can happen if this request or
        //  another being processed in parallel flush the cache and
        //  TryAgain.
        //

        if ( NpFcb->CacheDataSize == 0 ) {
            DebugTrace(-1, Dbg, "CacheWrite -> FALSE\n", 0 );
            NwReleaseFcb( NpFcb );
            return( FALSE );
        }

        //
        //  The data didn't fit in the cache, flush the cache
        //

        DebugTrace(  0, Dbg, "Cache is full, flushing data\n", 0 );

        //
        //  We must be at the front of the Queue before writing.
        //

        NwReleaseFcb( NpFcb );

        status = AcquireFcbAndFlushCache( IrpContext, NpFcb );

        if ( !NT_SUCCESS( status ) ) {
            ExRaiseStatus( status );
        }

        //
        //  Now see if it fits in the cache. We need to repeat all
        //  the tests again because two requests can flush the cache at the
        //  same time and the other one of them could have nearly filled it again.
        //

        goto TryAgain;

    } else {
        DebugTrace(-1, Dbg, "CacheWrite full -> FALSE\n", 0 );
        NwReleaseFcb( NpFcb );
        return( FALSE );
    }
}


BOOLEAN
OkToReadAhead(
    PFCB Fcb,
    IN ULONG FileOffset,
    IN UCHAR IoType
    )
/*++

Routine Description:

    This routine determines whether the attempted i/o is sequential (so that
    we can use the cache).

Arguments:

    Fcb - A pointer the the Fcb of the file being read.

    FileOffset - The file offset to read.

Return Value:

    TRUE - The operation is sequential.
    FALSE - The operation is not sequential.

--*/
{
    PAGED_CODE();

    if ( Fcb->NonPagedFcb->CacheType == IoType &&
         !Fcb->ShareAccess.SharedWrite &&
         FileOffset == Fcb->LastReadOffset + Fcb->LastReadSize ) {

        DebugTrace(0, Dbg, "Io is sequential\n", 0 );
        return( TRUE );

    } else {

        DebugTrace(0, Dbg, "Io is not sequential\n", 0 );
        return( FALSE );

    }
}


ULONG
CalculateReadAheadSize(
    IN PIRP_CONTEXT IrpContext,
    IN PNONPAGED_FCB NpFcb,
    IN ULONG CacheReadSize,
    IN ULONG FileOffset,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine determines the amount of data that can be read ahead,
    and sets up for the read.

    Note: Fcb must be acquired exclusive before calling.

Arguments:

    NpFcb - A pointer the the nonpaged FCB of the file being read.

    FileOffset - The file offset to read.

Return Value:

    The amount of data to read.

--*/
{
    ULONG ReadSize;
    ULONG CacheSize;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "CalculateReadAheadSize\n", 0 );

    if (( IrpContext->pNpScb->SendBurstModeEnabled ) ||
        ( IrpContext->pNpScb->ReceiveBurstModeEnabled )) {

        CacheSize = IrpContext->pNpScb->MaxReceiveSize;

    } else {

        CacheSize = IrpContext->pNpScb->BufferSize;

    }

    //
    // The caller of this routine owns the FCB exclusive, so
    // we don't have to worry about the NpFcb fields like
    // ShareAccess.
    //

    if ( OkToReadAhead( NpFcb->Fcb, FileOffset - CacheReadSize, ReadAhead ) &&
         ByteCount < CacheSize ) {

        ReadSize = CacheSize;

    } else {

        //
        //  Do not read ahead.
        //

        DebugTrace( 0, Dbg, "No read ahead\n", 0 );
        DebugTrace(-1, Dbg, "CalculateReadAheadSize -> %d\n", ByteCount );
        return ( ByteCount );

    }

    //
    //  Allocate pool for the segment of the read
    //

    if ( NpFcb->CacheBuffer == NULL ) {

        try {

            NpFcb->CacheBuffer = ALLOCATE_POOL_EX( NonPagedPool, ReadSize );
            NpFcb->CacheSize = ReadSize;

            NpFcb->CacheMdl = ALLOCATE_MDL( NpFcb->CacheBuffer, ReadSize, FALSE, FALSE, NULL );
            if ( NpFcb->CacheMdl == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmBuildMdlForNonPagedPool( NpFcb->CacheMdl );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            if ( NpFcb->CacheBuffer != NULL) {
                FREE_POOL( NpFcb->CacheBuffer );

                NpFcb->CacheBuffer = NULL;
            }

            NpFcb->CacheSize = 0;
            NpFcb->CacheDataSize = 0;

            DebugTrace( 0, Dbg, "Failed to allocated buffer\n", 0 );
            DebugTrace(-1, Dbg, "CalculateReadAheadSize -> %d\n", ByteCount );
            return( ByteCount );
        }

    } else {
        ReadSize = MIN ( NpFcb->CacheSize, ReadSize );
    }

    DebugTrace(-1, Dbg, "CalculateReadAheadSize -> %d\n", ReadSize );
    return( ReadSize );
}

NTSTATUS
FlushCache(
    PIRP_CONTEXT IrpContext,
    PNONPAGED_FCB NpFcb
    )
/*++

Routine Description:

    This routine flushes the cache buffer for the NpFcb.  The caller must
    have acquired the FCB exclusive prior to making this call!

Arguments:

    IrpContext - A pointer to request parameters.

    NpFcb - A pointer the the nonpaged FCB of the file to flush.

Return Value:

    The amount of data to read.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if ( NpFcb->CacheDataSize != 0 && NpFcb->CacheType == WriteBehind ) {

        LARGE_INTEGER ByteOffset;

        ByteOffset.QuadPart = NpFcb->CacheFileOffset;

        status = DoWrite(
                    IrpContext,
                    ByteOffset,
                    NpFcb->CacheDataSize,
                    NpFcb->CacheBuffer,
                    NpFcb->CacheMdl );

        //
        // DoWrite leaves us at the head of the queue.  The caller
        // is responsible for dequeueing the irp context appropriately.
        //

        if ( NT_SUCCESS( status ) ) {
            NpFcb->CacheDataSize = 0;
        }
    }

    return( status );
}

NTSTATUS
AcquireFcbAndFlushCache(
    PIRP_CONTEXT IrpContext,
    PNONPAGED_FCB NpFcb
    )
/*++

Routine Description:

    This routine acquires the FCB exclusive and flushes the cache
    buffer for the acquired NpFcb.

Arguments:

    IrpContext - A pointer to request parameters.

    NpFcb - A pointer the the nonpaged FCB of the file to flush.

Return Value:

    The amount of data to read.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    NwAppendToQueueAndWait( IrpContext );

    NwAcquireExclusiveFcb( NpFcb, TRUE );

    status = FlushCache( IrpContext, NpFcb );

    //
    //  Release the FCB and remove ourselves from the queue.
    //  Frequently the caller will want to grab a resource so
    //  we need to be off the queue then.
    //

    NwReleaseFcb( NpFcb );
    NwDequeueIrpContext( IrpContext, FALSE );

    return( status );
}

VOID
FlushAllBuffers(
    PIRP_CONTEXT pIrpContext
)
/*+++

    Pretty self descriptive - flush all the buffers.  The caller should
    not own any locks and should not be on an SCB queue.
    
---*/
{

    PLIST_ENTRY pVcbListEntry;
    PLIST_ENTRY pFcbListEntry;
    PVCB pVcb;
    PFCB pFcb;
    PNONPAGED_SCB pOriginalNpScb;
    PNONPAGED_SCB pNpScb;
    PNONPAGED_FCB pNpFcb;
    
    DebugTrace( 0, Dbg, "FlushAllBuffers...\n", 0 );

    ASSERT( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) );
    pOriginalNpScb = pIrpContext->pNpScb;

    //
    // Grab the RCB so that we can touch the global VCB list.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    for ( pVcbListEntry = GlobalVcbList.Flink;
          pVcbListEntry != &GlobalVcbList;
          pVcbListEntry = pVcbListEntry->Flink ) {

        pVcb = CONTAINING_RECORD( pVcbListEntry, VCB, GlobalVcbListEntry );
        pNpScb = pVcb->Scb->pNpScb;

        pIrpContext->pNpScb = pNpScb;
        pIrpContext->pNpScb->pScb;

        //
        // Reference this SCB and VCB so they don't go away.
        //

        NwReferenceScb( pNpScb );
        NwReferenceVcb( pVcb );

        //
        // Release the RCB so we can get to the head of
        // the queue safely...
        //

        NwReleaseRcb( &NwRcb );
        NwAppendToQueueAndWait( pIrpContext );

        //
        // Reacquire the RCB so we can walk the FCB list safely.
        //

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        // Flush all the FCBs for this VCB.
        //

        for ( pFcbListEntry = pVcb->FcbList.Flink;
              pFcbListEntry != &(pVcb->FcbList) ;
              pFcbListEntry = pFcbListEntry->Flink ) {

            pFcb = CONTAINING_RECORD( pFcbListEntry, FCB, FcbListEntry );
            pNpFcb = pFcb->NonPagedFcb;

            NwAcquireExclusiveFcb( pNpFcb, TRUE ); 
            FlushCache( pIrpContext, pNpFcb );
            NwReleaseFcb( pNpFcb );
        }

        NwDereferenceVcb( pVcb, pIrpContext, TRUE );
        NwReleaseRcb( &NwRcb );

        NwDequeueIrpContext( pIrpContext, FALSE );

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        NwDereferenceScb( pNpScb );

    }

    //
    // Release and restore.
    //

    NwReleaseRcb( &NwRcb );

    if ( pOriginalNpScb ) {

        pIrpContext->pNpScb = pOriginalNpScb;
        pIrpContext->pScb = pOriginalNpScb->pScb;

    } else {

        pIrpContext->pNpScb = NULL;
        pIrpContext->pScb = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\callback.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements NCP Response callback routines.

Author:

    Manny Weiser    [MannyW]    3-Mar-1993

Revision History:

--*/

#include "procs.h"

#define Dbg                              (DEBUG_TRACE_EXCHANGE)

#ifdef ALLOC_PRAGMA
#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, SynchronousResponseCallback )
#pragma alloc_text( PAGE1, AsynchResponseCallback )
#endif
#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
SynchronousResponseCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    )
/*++

Routine Description:

    This routine is the callback routine for an NCP which has no
    return parameters and the caller blocks waiting for a response.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    BytesAvailable - Actual number of bytes in the received message.

    RspData - Points to the receive buffer.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    PEPrequest  *pNcpHeader;
    PEPresponse *pNcpResponse;

    DebugTrace( 0, Dbg, "SynchronousResponseCallback\n", 0 );
    ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

#ifdef MSWDBG
        ASSERT( pIrpContext->Event.Header.SignalState == 0 );
        pIrpContext->DebugValue = 0x103;
#endif
        pIrpContext->pOriginalIrp->IoStatus.Status = STATUS_REMOTE_NOT_LISTENING;
        NwSetIrpContextEvent( pIrpContext );

        return STATUS_REMOTE_NOT_LISTENING;
    }

    pIrpContext->ResponseLength = BytesAvailable;

    //
    //  Simply copy the data into the response buffer, if it is not
    //  already there (because we used an IRP to receive the data).
    //

    if ( RspData != pIrpContext->rsp ) {
        CopyBufferToMdl( pIrpContext->RxMdl, 0, RspData, pIrpContext->ResponseLength );
    }

    //
    // Remember the returned error code.
    //

    pNcpHeader = (PEPrequest *)pIrpContext->rsp;
    pNcpResponse = (PEPresponse *)(pNcpHeader + 1);

    pIrpContext->ResponseParameters.Error = pNcpResponse->error;

    //
    //  Tell the caller that the response has been received.
    //

#ifdef MSWDBG
    ASSERT( pIrpContext->Event.Header.SignalState == 0 );
    pIrpContext->DebugValue = 0x104;
#endif

    pIrpContext->pOriginalIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrpContext->pOriginalIrp->IoStatus.Information = BytesAvailable;

    NwSetIrpContextEvent( pIrpContext );
    return STATUS_SUCCESS;
}

NTSTATUS
AsynchResponseCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    )
/*++

Routine Description:

    This routine is the callback routine for an NCP which has no
    return parameters and the caller DOES NOT BLOCK waiting for a
    response.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    BytesAvailable - Actual number of bytes in the received message.

    RspData - Points to the receive buffer.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    NTSTATUS Status;

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        Status = STATUS_REMOTE_NOT_LISTENING;

    } else {

        if ( ((PNCP_RESPONSE)RspData)->Status != 0 ) {

            Status = STATUS_LINK_FAILED;

        } else {

            Status = NwErrorToNtStatus( ((PNCP_RESPONSE)RspData)->Error );

        }
    }

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );
    NwCompleteRequest( pIrpContext, Status );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\convert.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Convert.c

Abstract:

    This module implements conversion routine to map NT formats to
    Netware and vice versa.

Author:

    Manny Weiser    [MannyW]    3-Mar-1993

Revision History:

--*/

#include "Procs.h"

typedef union _NCP_DATE {
    USHORT Ushort;
    struct {
        USHORT Day : 5;
        USHORT Month : 4;
        USHORT Year : 7;
    } Struct;
} NCP_DATE;

typedef union _NCP_TIME {
    USHORT Ushort;
    struct {
        USHORT TwoSeconds : 5;
        USHORT Minutes : 6;
        USHORT Hours : 5;
    } Struct;
} NCP_TIME;

#define BASE_DOS_ERROR  ((NTSTATUS )0xC0010000L)


struct {
    UCHAR NetError;
    NTSTATUS ResultingStatus;
} Error_Map[] = {
    //  NetWare specific error mappings
    {  1, STATUS_DISK_FULL },
    {128, STATUS_SHARING_VIOLATION },
    {129, STATUS_INSUFF_SERVER_RESOURCES },
    {130, STATUS_ACCESS_DENIED },
    {131, STATUS_DATA_ERROR },
    {132, STATUS_ACCESS_DENIED },
    {133, STATUS_OBJECT_NAME_COLLISION },
    {134, STATUS_OBJECT_NAME_COLLISION },
    {135, STATUS_OBJECT_NAME_INVALID },
    {136, STATUS_INVALID_HANDLE },
    {137, STATUS_ACCESS_DENIED },
    {138, STATUS_ACCESS_DENIED },
    {139, STATUS_ACCESS_DENIED },
    {140, STATUS_ACCESS_DENIED },
    {141, STATUS_SHARING_VIOLATION },
    {142, STATUS_SHARING_VIOLATION },
    {143, STATUS_ACCESS_DENIED },
    {144, STATUS_ACCESS_DENIED },
    {145, STATUS_OBJECT_NAME_COLLISION },
    {146, STATUS_OBJECT_NAME_COLLISION },
    {147, STATUS_ACCESS_DENIED },
    {148, STATUS_ACCESS_DENIED },
    {149, STATUS_ACCESS_DENIED },
    {150, STATUS_INSUFF_SERVER_RESOURCES },
    {151, STATUS_NO_SPOOL_SPACE },
    {152, STATUS_NO_SUCH_DEVICE },
    {153, STATUS_DISK_FULL },
    {154, STATUS_NOT_SAME_DEVICE },
    {155, STATUS_INVALID_HANDLE },
    {156, STATUS_OBJECT_PATH_NOT_FOUND },
    {157, STATUS_INSUFF_SERVER_RESOURCES },
    {158, STATUS_OBJECT_PATH_INVALID },
    {159, STATUS_SHARING_VIOLATION },
    {160, STATUS_DIRECTORY_NOT_EMPTY },
    {161, STATUS_DATA_ERROR },
    {162, STATUS_FILE_LOCK_CONFLICT },
    {165, STATUS_OBJECT_NAME_NOT_FOUND },
    {191, STATUS_OBJECT_NAME_INVALID },    // Name space not loaded
    {192, STATUS_ACCESS_DENIED},
    {193, STATUS_ACCOUNT_RESTRICTION },
    {194, STATUS_ACCOUNT_RESTRICTION },
    {195, STATUS_ACCOUNT_DISABLED},
    {197, STATUS_ACCOUNT_DISABLED },
    {198, STATUS_ACCESS_DENIED },
    {211, STATUS_ACCESS_DENIED },
    {212, STATUS_PRINT_QUEUE_FULL },
    {213, STATUS_PRINT_CANCELLED },
    {214, STATUS_ACCESS_DENIED },
    {215, STATUS_PASSWORD_RESTRICTION },
    {216, STATUS_PASSWORD_RESTRICTION },
#ifdef QFE_BUILD
    {217, STATUS_ACCOUNT_RESTRICTION },
    {218, STATUS_ACCOUNT_RESTRICTION },
    {219, STATUS_ACCOUNT_RESTRICTION },
#else
    {217, STATUS_CONNECTION_COUNT_LIMIT },
    {218, STATUS_LOGIN_TIME_RESTRICTION },
    {219, STATUS_LOGIN_WKSTA_RESTRICTION },
#endif
    {220, STATUS_ACCOUNT_DISABLED },
    {222, STATUS_PASSWORD_EXPIRED },
    {223, NWRDR_PASSWORD_HAS_EXPIRED },
    {231, STATUS_REMOTE_SESSION_LIMIT },
    {236, STATUS_UNEXPECTED_NETWORK_ERROR },
    {251, STATUS_INVALID_PARAMETER },
    {252, STATUS_NO_MORE_ENTRIES },
    {253, STATUS_FILE_LOCK_CONFLICT },
    {254, STATUS_FILE_LOCK_CONFLICT },
    {255, STATUS_UNSUCCESSFUL},

    //  DOS error mappings
    //{ ERROR_INVALID_FUNCTION, STATUS_NOT_IMPLEMENTED },
    { ERROR_FILE_NOT_FOUND, STATUS_NO_SUCH_FILE },
    { ERROR_PATH_NOT_FOUND, STATUS_OBJECT_PATH_NOT_FOUND },
    { ERROR_TOO_MANY_OPEN_FILES, STATUS_TOO_MANY_OPENED_FILES },
    { ERROR_ACCESS_DENIED, STATUS_ACCESS_DENIED },
    { ERROR_INVALID_HANDLE, STATUS_INVALID_HANDLE },
    { ERROR_NOT_ENOUGH_MEMORY, STATUS_INSUFFICIENT_RESOURCES },
    { ERROR_INVALID_ACCESS, STATUS_ACCESS_DENIED },
    { ERROR_INVALID_DATA, STATUS_DATA_ERROR },

    { ERROR_CURRENT_DIRECTORY, STATUS_DIRECTORY_NOT_EMPTY },
    { ERROR_NOT_SAME_DEVICE, STATUS_NOT_SAME_DEVICE },
    { ERROR_NO_MORE_FILES, STATUS_NO_MORE_FILES },
/* */
/* These are the universal int 24 mappings for the old INT 24 set of errors */
/* */
    { ERROR_WRITE_PROTECT, STATUS_MEDIA_WRITE_PROTECTED},
    { ERROR_BAD_UNIT, STATUS_UNSUCCESSFUL}, // ***
    { ERROR_NOT_READY, STATUS_DEVICE_NOT_READY },
    { ERROR_BAD_COMMAND, STATUS_UNSUCCESSFUL}, // ***
    { ERROR_CRC, STATUS_CRC_ERROR },
    { ERROR_BAD_LENGTH, STATUS_DATA_ERROR },
    { ERROR_SEEK, STATUS_UNSUCCESSFUL },// ***
    { ERROR_NOT_DOS_DISK, STATUS_DISK_CORRUPT_ERROR }, //***
    { ERROR_SECTOR_NOT_FOUND, STATUS_NONEXISTENT_SECTOR },
    { ERROR_OUT_OF_PAPER, STATUS_DEVICE_PAPER_EMPTY},
    { ERROR_WRITE_FAULT, STATUS_UNSUCCESSFUL}, // ***
    { ERROR_READ_FAULT, STATUS_UNSUCCESSFUL}, // ***
    { ERROR_GEN_FAILURE, STATUS_UNSUCCESSFUL }, // ***
/* */
/* These are the new 3.0 error codes reported through INT 24 */
/* */
    { ERROR_SHARING_VIOLATION, STATUS_SHARING_VIOLATION },
    { ERROR_LOCK_VIOLATION, STATUS_FILE_LOCK_CONFLICT },
    { ERROR_WRONG_DISK, STATUS_WRONG_VOLUME },
//    { ERROR_FCB_UNAVAILABLE, },
//    { ERROR_SHARING_BUFFER_EXCEEDED, },
/* */
/* New OEM network-related errors are 50-79 */
/* */
    { ERROR_NOT_SUPPORTED, STATUS_NOT_SUPPORTED },
    { ERROR_REM_NOT_LIST, STATUS_REMOTE_NOT_LISTENING },
    { ERROR_DUP_NAME, STATUS_DUPLICATE_NAME },
    { ERROR_BAD_NETPATH, STATUS_BAD_NETWORK_PATH },
    { ERROR_NETWORK_BUSY, STATUS_NETWORK_BUSY },
    { ERROR_DEV_NOT_EXIST, STATUS_DEVICE_DOES_NOT_EXIST },
    { ERROR_TOO_MANY_CMDS, STATUS_TOO_MANY_COMMANDS },
    { ERROR_ADAP_HDW_ERR, STATUS_ADAPTER_HARDWARE_ERROR },
    { ERROR_BAD_NET_RESP,  STATUS_INVALID_NETWORK_RESPONSE },
    { ERROR_UNEXP_NET_ERR, STATUS_UNEXPECTED_NETWORK_ERROR },
    { ERROR_BAD_REM_ADAP, STATUS_BAD_REMOTE_ADAPTER },
    { ERROR_PRINTQ_FULL, STATUS_PRINT_QUEUE_FULL },
    { ERROR_NO_SPOOL_SPACE, STATUS_NO_SPOOL_SPACE },
    { ERROR_PRINT_CANCELLED, STATUS_PRINT_CANCELLED },
    { ERROR_NETNAME_DELETED, STATUS_NETWORK_NAME_DELETED },
    { ERROR_NETWORK_ACCESS_DENIED, STATUS_NETWORK_ACCESS_DENIED },
    { ERROR_BAD_DEV_TYPE, STATUS_BAD_DEVICE_TYPE },
    { ERROR_BAD_NET_NAME, STATUS_BAD_NETWORK_NAME },
    { ERROR_TOO_MANY_NAMES, STATUS_TOO_MANY_NAMES },
    { ERROR_TOO_MANY_SESS, STATUS_REMOTE_SESSION_LIMIT },
    { ERROR_SHARING_PAUSED, STATUS_SHARING_PAUSED },
    { ERROR_REQ_NOT_ACCEP, STATUS_REQUEST_NOT_ACCEPTED },
    { ERROR_REDIR_PAUSED, STATUS_REDIRECTOR_PAUSED },
/* */
/* End of INT 24 reportable errors */
/* */
    { ERROR_FILE_EXISTS, STATUS_OBJECT_NAME_COLLISION },
//    { ERROR_DUP_FCB, },
//    { ERROR_CANNOT_MAKE, },
//    { ERROR_FAIL_I24, },
/* */
/* New 3.0 network related error codes */
/* */
//    { ERROR_OUT_OF_STRUCTURES, },
//    { ERROR_ALREADY_ASSIGNED, },
    { ERROR_INVALID_PASSWORD, STATUS_WRONG_PASSWORD },
    { ERROR_INVALID_PARAMETER, STATUS_INVALID_PARAMETER },
    { ERROR_NET_WRITE_FAULT, STATUS_NET_WRITE_FAULT },
/* */
/* New error codes for 4.0 */
/* */
//    { ERROR_NO_PROC_SLOTS, },
//    { ERROR_NOT_FROZEN, },
//    { ERR_TSTOVFL, },
//    { ERR_TSTDUP, },
//    { ERROR_NO_ITEMS, },
//    { ERROR_INTERRUPT, },

//    { ERROR_TOO_MANY_SEMAPHORES, },
//    { ERROR_EXCL_SEM_ALREADY_OWNED, },
//    { ERROR_SEM_IS_SET, },
//    { ERROR_TOO_MANY_SEM_REQUESTS, },
//    { ERROR_INVALID_AT_INTERRUPT_TIME, },

//    { ERROR_SEM_OWNER_DIED, },
//    { ERROR_SEM_USER_LIMIT, },
//    { ERROR_DISK_CHANGE, },
//    { ERROR_DRIVE_LOCKED, },
    { ERROR_BROKEN_PIPE, STATUS_PIPE_BROKEN },
/* */
/* New error codes for 5.0 */
/* */
    //
    //  NOTE:  ERROR_OPEN_FAILED is handled specially.
    //

    //
    //  The mapping of ERROR_OPEN_FAILED is context sensitive.  If the
    //  disposition requested in the Open_AndX SMB is FILE_CREATE, this
    //  error means that the file already existed.  If the disposition
    //  is FILE_OPEN, it means that the file does NOT exist!
    //

    { ERROR_OPEN_FAILED, STATUS_OPEN_FAILED },
//    { ERROR_BUFFER_OVERFLOW, },
    { ERROR_DISK_FULL, STATUS_DISK_FULL },
//    { ERROR_NO_MORE_SEARCH_HANDLES, },
//    { ERROR_INVALID_TARGET_HANDLE, },
//    { ERROR_PROTECTION_VIOLATION, STATUS_ACCESS_VIOLATION },
//    { ERROR_VIOKBD_REQUEST, },
//    { ERROR_INVALID_CATEGORY, },
//    { ERROR_INVALID_VERIFY_SWITCH, },
//    { ERROR_BAD_DRIVER_LEVEL, },
//    { ERROR_CALL_NOT_IMPLEMENTED, },
    { ERROR_SEM_TIMEOUT, STATUS_IO_TIMEOUT },
    { ERROR_INSUFFICIENT_BUFFER, STATUS_BUFFER_TOO_SMALL },
    { ERROR_INVALID_NAME, STATUS_OBJECT_NAME_INVALID },
    { ERROR_INVALID_LEVEL, STATUS_INVALID_LEVEL },
//    { ERROR_NO_VOLUME_LABEL, },

/* NOTE:  DosQFSInfo no longer returns the above error; it is still here for */
/*    api\d_qfsinf.asm.                  */

//    { ERROR_MOD_NOT_FOUND, },
//    { ERROR_PROC_NOT_FOUND, },

//    { ERROR_WAIT_NO_CHILDREN, },

//    { ERROR_CHILD_NOT_COMPLETE, },

//    { ERROR_DIRECT_ACCESS_HANDLE, },
                                    /* for direct disk access */
                                    /* handles */
//    { ERROR_NEGATIVE_SEEK, },
                                    /* with negitive offset */
//    { ERROR_SEEK_ON_DEVICE, },
                                    /* on device or pipe */
    { ERROR_BAD_PATHNAME, STATUS_OBJECT_PATH_INVALID },   //*

/*
 * Error codes 230 - 249 are reserved for MS Networks
 */
    { ERROR_BAD_PIPE, STATUS_INVALID_PARAMETER },
    { ERROR_PIPE_BUSY, STATUS_PIPE_NOT_AVAILABLE },
    { ERROR_NO_DATA, STATUS_PIPE_EMPTY },
    { ERROR_PIPE_NOT_CONNECTED, STATUS_PIPE_DISCONNECTED },
    { ERROR_MORE_DATA, STATUS_BUFFER_OVERFLOW },

    { ERROR_VC_DISCONNECTED, STATUS_VIRTUAL_CIRCUIT_CLOSED },
};

#define NUM_ERRORS sizeof(Error_Map) / sizeof(Error_Map[0])

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CONVERT)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NtToNwShareFlags )
#pragma alloc_text( PAGE, NtAttributesToNwAttributes )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, pNwErrorToNtStatus )
#pragma alloc_text( PAGE1, NwBurstResultToNtStatus )
#pragma alloc_text( PAGE1, NwConnectionStatusToNtStatus )
#pragma alloc_text( PAGE1, NwDateTimeToNtTime )
#pragma alloc_text( PAGE1, NwNtTimeToNwDateTime )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif

UCHAR
NtToNwShareFlags(
    ULONG DesiredAccess,
    ULONG NtShareFlags
    )
/*++

Routine Description:

    This routine maps a NT desired/share access to Netware share flag bits.

Arguments:

    DesiredAccess - Desired access for open as specified in the read IRP.
    NtShareFlags - The NT share flags from the create IRP.

Return Value:

    Netware share mode.

--*/
{
    UCHAR NwShareFlags = 0;
    ULONG lDesiredAccess;

    PAGED_CODE();

    //
    //  Ignore share delete, since we can't do anything with it.
    //

    switch ( NtShareFlags & (FILE_SHARE_READ | FILE_SHARE_WRITE) ) {

    case 0:
       // ---- Multi-user code merge -------
       // AJ: NW_OPEN_EXCLUSIVE under NT means NW_DENY_WRITE | NW_DENY_READ. 
       // NW_OPEN_EXCLUSIVE flag is mapped to AR_COMPITIBLITY under NetWare. Which does 
       // not serve the purpose as if it is under NT. Under Netware we have AR_DENY_READ and
       // AR_DENY_WRITE which maps to NW_DENY_READ and NW_DENY_WRITE respectivly.
        NwShareFlags = NW_DENY_WRITE | NW_DENY_READ;
//        NwShareFlags = NW_OPEN_EXCLUSIVE;   
        break;

    case FILE_SHARE_READ:
        NwShareFlags = NW_DENY_WRITE;
        break;

    case FILE_SHARE_WRITE:
        NwShareFlags = NW_DENY_READ;
        break;

    case FILE_SHARE_WRITE | FILE_SHARE_READ:
        NwShareFlags = 0;

    }

    //
    // Treat append the same as write.
    //

    if ( DesiredAccess & FILE_APPEND_DATA) {

        lDesiredAccess = DesiredAccess | FILE_WRITE_DATA;

    } else {

        lDesiredAccess = DesiredAccess;

    }

    switch ( lDesiredAccess & (FILE_EXECUTE | FILE_WRITE_DATA | FILE_READ_DATA) ) {

    case (FILE_EXECUTE | FILE_WRITE_DATA | FILE_READ_DATA):
    case (FILE_EXECUTE | FILE_WRITE_DATA):
        NwShareFlags |= NW_OPEN_EXCLUSIVE | NW_OPEN_FOR_WRITE | NW_OPEN_FOR_READ;
        break;

    case (FILE_EXECUTE | FILE_READ_DATA):
    case (FILE_EXECUTE):
        NwShareFlags |= NW_OPEN_EXCLUSIVE | NW_OPEN_FOR_READ;
        break;

    case (FILE_WRITE_DATA | FILE_READ_DATA):
        NwShareFlags |= NW_OPEN_FOR_WRITE | NW_OPEN_FOR_READ;
        break;

    case (FILE_WRITE_DATA):
        NwShareFlags |= NW_OPEN_FOR_WRITE;
        break;

    default:
        NwShareFlags |= NW_OPEN_FOR_READ;
        break;
    }

    if (NwShareFlags & NW_OPEN_EXCLUSIVE) {

        //
        //  Remove the NW_DENY_* flags if exclusive is already specified since
        //  this interferes with the shareable flag.
        //

        return( NwShareFlags & ~(NW_DENY_READ | NW_DENY_WRITE) );
    }

    return( NwShareFlags );
}


UCHAR
NtAttributesToNwAttributes(
    ULONG FileAttributes
    )
/*++

Routine Description:

    This routine maps a NT attributes mask to a Netware mask.

Arguments:

    DesiredAccess - Desired access for open as specified in the read IRP.

Return Value:

    Netware share mode.

--*/
{
    return( (UCHAR)FileAttributes & 0x3F );
}

NTSTATUS
pNwErrorToNtStatus(
    UCHAR NwError
    )
/*++

Routine Description:

    This routine converts a Netware error code to an NT status code.

Arguments:

    NwError - The netware error.

Return Value:

    NTSTATUS - The converted status.

--*/

{
    int i;

    ASSERT(NwError != 0);

    //
    //  Errors 2 through 127 are mapped as DOS errors.
    //

    if ( NwError > 1 && NwError < 128 ) {
        return( BASE_DOS_ERROR + NwError );
    }

    //
    //  For other errors, search the table for the matching error number.
    //

    for ( i = 0; i < NUM_ERRORS; i++ ) {
        if ( Error_Map[i].NetError == NwError ) {
            return( Error_Map[i].ResultingStatus );
        }
    }

    DebugTrace( 0, 0, "No error mapping for error %d\n", NwError );

#ifdef NWDBG
    Error( EVENT_NWRDR_NETWORK_ERROR, (NTSTATUS)0xC0010000 | NwError, NULL, 0, 0 );
#endif

    return( (NTSTATUS)0xC0010000 | NwError );
}

NTSTATUS
NwBurstResultToNtStatus(
    ULONG Result
    )
/*++

Routine Description:

    This routine converts a Netware burst result code to an NT status code.

Arguments:

    Result - The netware burst result.

Return Value:

    NTSTATUS - The converted status.

--*/

{
    NTSTATUS Status;

    //
    // the 3 high order bits should not be set. but if they are,
    // we return an error.
    //
    if (Result & 0xFFFFFF00)
        return( STATUS_UNEXPECTED_NETWORK_ERROR );

    switch ( Result ) {

    case 0:
    case 3:   //  No data
        Status = STATUS_SUCCESS;
        break;

    case 1:
        Status = STATUS_DISK_FULL;
        break;

    case 2:   //  I/O error
        Status = STATUS_UNEXPECTED_IO_ERROR;
        break;

    default:
        Status = NwErrorToNtStatus( (UCHAR)Result );
        break;
    }

    return( Status );
}

NTSTATUS
NwConnectionStatusToNtStatus(
    UCHAR NwStatus
    )
/*++

Routine Description:

    This routine converts a Netware connection status code to an NT
    status code.

Arguments:

    NwStatus - The netware connection status.

Return Value:

    NTSTATUS - The converted status.

--*/

{
    if ( (NwStatus & 1) == 0 ) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_REMOTE_DISCONNECT;
    }
}

LARGE_INTEGER
NwDateTimeToNtTime (
    IN USHORT UDate,
    IN USHORT UTime
    )

/*++

Routine Description:

    This routine converts an NCP time to an NT time structure.

Arguments:

    Time - Supplies the time of day to convert
    Date - Supplies the day of the year to convert

Return Value:

    LARGE_INTEGER - Time structure describing input time.

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;
    NCP_DATE Date = *(NCP_DATE *)&UDate;
    NCP_TIME Time = *(NCP_TIME *)&UTime;

    if ( Date.Ushort == 0 && Time.Ushort == 0 ) {

        //
        //  The file time stamp is zero.   Do not return a file time of
        //  zero, since this will be biased to a negative time (due to
        //  time zone fixup), and no one will be able to display it
        //  correctly.  Instead, we "randomly" pick Jan 01, 1980 @ 12:00am
        //  as the file time.
        //
        // We assume that the netware server is in our time zone.

        RtlSecondsSince1980ToTime(0, &OutputTime);

    } else {

        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the packet are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }

        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }

        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;
        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {

            OutputTime.QuadPart = 0;
            return OutputTime;
        }

    }

    // Convert to UTC for the system.
    ExLocalTimeToSystemTime(&OutputTime, &OutputTime);
    return OutputTime;

}

NTSTATUS
NwNtTimeToNwDateTime (
    IN LARGE_INTEGER NtTime,
    IN PUSHORT NwDate,
    IN PUSHORT NwTime
    )

/*++

Routine Description:

    This routine converts an NT time structure to an NCP time.

Arguments:

    NtTime - Supplies to NT Time to convert.

    NwDate - Returns the Netware format date.

    NwTime - Returns the Netware format time.

Return Value:

    The status of the operation.

--*/

{
    TIME_FIELDS TimeFields;
    NCP_DATE Date;
    NCP_TIME Time;

    if (NtTime.QuadPart == 0) {

        Time.Ushort = Date.Ushort = 0;

    } else {

        LARGE_INTEGER LocalTime;

        // We assume that the netware server is in our time zone.

        ExSystemTimeToLocalTime( &NtTime, &LocalTime );
        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        if (TimeFields.Year < 1980 || TimeFields.Year > (1980 + 127) ) {
            return( STATUS_INVALID_PARAMETER );
        }

        Date.Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date.Struct.Month = TimeFields.Month;
        Date.Struct.Day = TimeFields.Day;

        Time.Struct.Hours = TimeFields.Hour;
        Time.Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time.Struct.TwoSeconds = TimeFields.Second / 2;

    }

    *NwDate = *( USHORT *)&Date;
    *NwTime = *( USHORT *)&Time;
    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\close.c ===
/*++

Copyright (c) 1992-4  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for the NetWare
    redirector called by the dispatch driver.

Author:

    Colin Watson     [ColinW]    19-Dec-1992

Revision History:

--*/

#include "Procs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  Local procedure prototypes
//

NTSTATUS
NwCommonClose (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NwCloseRcb (
    IN PIRP_CONTEXT IrpContext,
    IN PRCB Rcb
    );

NTSTATUS
NwCloseIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdClose )
#pragma alloc_text( PAGE, NwCommonClose )
#pragma alloc_text( PAGE, NwCloseRcb )
#pragma alloc_text( PAGE, NwCloseIcb )
#endif


NTSTATUS
NwFsdClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Close.

Arguments:

    DeviceObject - Supplies the redirector device object.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdClose\n", 0);

    FsRtlEnterFileSystem();
    
    NwReferenceUnlockableCodeSection ();
    
    //
    //  Call the common Close routine
    //

    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        IrpContext = AllocateIrpContext( Irp );
        Status = NwCommonClose( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

       if ( IrpContext == NULL ) {

           //
           //  If we couldn't allocate an irp context, just complete
           //  irp without any fanfare.
           //

           Status = STATUS_INSUFFICIENT_RESOURCES;
           Irp->IoStatus.Status = Status;
           Irp->IoStatus.Information = 0;
           IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

       } else {

           //
           // We had some trouble trying to perform the requested
           // operation, so we'll abort the I/O request with
           // the error status that we get back from the
           // execption code.
           //

           Status = NwProcessException( IrpContext, GetExceptionCode() );
       }

    }

    if ( IrpContext ) {
        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, Status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdClose -> %08lx\n", Status);

    NwDereferenceUnlockableCodeSection ();
    UNREFERENCED_PARAMETER( DeviceObject );

    FsRtlExitFileSystem();
    
    return Status;
}


NTSTATUS
NwCommonClose (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for closing a file.

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsContext2;

    PAGED_CODE();

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonClose\n", 0);
    DebugTrace( 0, Dbg, "IrpContext       = %08lx\n", (ULONG_PTR)IrpContext);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG_PTR)irpSp->FileObject);
    try {

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed.
        //

        if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                                &fsContext,
                                                &fsContext2 )) == NTC_UNDEFINED) {

            DebugTrace(0, Dbg, "The file is disconnected\n", 0);

            status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "NwCommonClose -> %08lx\n", status );
            try_return( NOTHING );
        }

        //
        // Decide how to handle this IRP.
        //

        switch (nodeTypeCode) {


        case NW_NTC_RCB:       // Close the file system

            status = NwCloseRcb( IrpContext, (PRCB)fsContext2 );
            status = STATUS_SUCCESS;
            break;

        case NW_NTC_ICB:       // Close the remote file
        case NW_NTC_ICB_SCB:   // Close the SCB

            status = NwCloseIcb( IrpContext, (PICB)fsContext2 );
            NwDereferenceUnlockableCodeSection ();
            break;

#ifdef NWDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheck( RDR_FILE_SYSTEM );
            break;
#endif

        }

    try_exit: NOTHING;

    } finally {

        //
        //  Just in-case this handle was the last one before we unload.
        //

        NwUnlockCodeSections(TRUE);

        DebugTrace(-1, Dbg, "NwCommonClose -> %08lx\n", status);

    }

    return status;
}


NTSTATUS
NwCloseRcb (
    IN PIRP_CONTEXT IrpContext,
    IN PRCB Rcb
    )

/*++

Routine Description:

    The routine cleans up a RCB.

Arguments:

    IrpContext - Supplies the IRP context pointers for this close.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCloseRcb...\n", 0);

    //
    //  Now acquire exclusive access to the Rcb
    //

    NwAcquireExclusiveRcb( Rcb, TRUE );

    status = STATUS_SUCCESS;
    --Rcb->OpenCount;

    NwReleaseRcb( Rcb );

    DebugTrace(-1, Dbg, "MsCloseRcb -> %08lx\n", status);

    //
    //  And return to our caller
    //

    return status;
}


NTSTATUS
NwCloseIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb
    )

/*++

Routine Description:

    The routine cleans up an ICB.

Arguments:

    IrpContext - Supplies the IRP context pointers for this close.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS Status;
    PNONPAGED_SCB pNpScb;
    PVCB Vcb;
    PFCB Fcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCloseIcb...\n", 0);

    ASSERT( Icb->State == ICB_STATE_CLEANED_UP ||
            Icb->State == ICB_STATE_CLOSE_PENDING );

    //
    // If this is a remote file close the remote handle.
    //

    Status = STATUS_SUCCESS;
    IrpContext->Icb = Icb;
    Fcb = Icb->SuperType.Fcb;

    if (( Icb->NodeTypeCode == NW_NTC_ICB ) ||
        ( Icb->NodeTypeCode == NW_NTC_DCB )) {

        pNpScb = Fcb->Scb->pNpScb;
        IrpContext->pNpScb = pNpScb;

        if ( Icb->HasRemoteHandle ) {

            Vcb = Fcb->Vcb;

            //
            //  Dump the write behind cache.
            //

            Status = AcquireFcbAndFlushCache( IrpContext, Fcb->NonPagedFcb );

            if ( !NT_SUCCESS( Status ) ) {
                IoRaiseInformationalHardError(
                    STATUS_LOST_WRITEBEHIND_DATA,
                    &Fcb->FullFileName,
                    (PKTHREAD)IrpContext->pOriginalIrp->Tail.Overlay.Thread );
            }

            //
            //  Is this a print job?
            //  Icb->IsPrintJob will be false if a 16 bit app is
            //  responsible for sending the job.
            //

            if ( FlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) &&
                 Icb->IsPrintJob ) {

                //
                //  Yes, did we print?
                //

                if ( Icb->ActuallyPrinted ) {

                    //
                    //  Yes.  Send a close file and start queue job NCP
                    //

                    Status = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "Sdw",
                                NCP_ADMIN_FUNCTION, NCP_CLOSE_FILE_AND_START_JOB,
                                Vcb->Specific.Print.QueueId,
                                Icb->JobId );
                } else {

                    //
                    //  No.  Cancel the job.
                    //

                    Status = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "Sdw",
                                NCP_ADMIN_FUNCTION, NCP_CLOSE_FILE_AND_CANCEL_JOB,
                                Vcb->Specific.Print.QueueId,
                                Icb->JobId );
                }

            } else {

                if ( Icb->SuperType.Fcb->NodeTypeCode != NW_NTC_DCB ) {

                    //
                    //  No, send a close file NCP.
                    //

                    ASSERT( IrpContext->pTdiStruct == NULL );

                    Status = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "F-r",
                                NCP_CLOSE,
                                Icb->Handle, sizeof( Icb->Handle ) );

                    // If this is in the long file name space and
                    // the last access flag has been set, we have to
                    // reset the last access time _after_ closing the file.

                    if ( Icb->UserSetLastAccessTime &&
                         BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

                        Status = ExchangeWithWait(
                            IrpContext,
                            SynchronousResponseCallback,
                            "LbbWD_W_bDbC",
                            NCP_LFN_SET_INFO,
                            Fcb->Vcb->Specific.Disk.LongNameSpace,
                            Fcb->Vcb->Specific.Disk.LongNameSpace,
                            SEARCH_ALL_FILES,
                            LFN_FLAG_SET_INFO_LASTACCESS_DATE,
                            28,
                            Fcb->LastAccessDate,
                            8,
                            Fcb->Vcb->Specific.Disk.VolumeNumber,
                            Fcb->Vcb->Specific.Disk.Handle,
                            0,
                            &Fcb->RelativeFileName );
                    }

                    //
                    // If someone set the shareable bit, then
                    // see if we can send the NCP over the wire (all
                    // instances of the file need to be closed).
                    //

                    if ( BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LAZY_SET_SHAREABLE ) ) {
                        LazySetShareable( IrpContext, Icb, Fcb );
                    }

                } else {

                    Status = ExchangeWithWait (
                                 IrpContext,
                                 SynchronousResponseCallback,
                                 "Sb",
                                 NCP_DIR_FUNCTION, NCP_DEALLOCATE_DIR_HANDLE,
                                 Icb->Handle[0]);
                }

            }

            Icb->HasRemoteHandle = FALSE;
        }

    } else {

        pNpScb = Icb->SuperType.Scb->pNpScb;
        IrpContext->pNpScb = pNpScb;
        IrpContext->pScb = pNpScb->pScb;

        if ( Icb->HasRemoteHandle ) {

            //
            // If we have a remote handle this is a file stream ICB.  We
            // need to close the remote handle.  The exchange will get us
            // to the head of the queue to protect the SCB state.
            //

            Status = ExchangeWithWait(
                IrpContext,
                SynchronousResponseCallback,
                "F-r",
                NCP_CLOSE,
                Icb->Handle, sizeof( Icb->Handle ) );

            Icb->HasRemoteHandle = FALSE;

            pNpScb->pScb->OpenNdsStreams--;

            ASSERT( pNpScb->pScb->MajorVersion > 3 );

            //
            // Do we need to unlicense this connection?
            //

            if ( ( pNpScb->pScb->UserName.Length == 0 ) &&
                 ( pNpScb->pScb->VcbCount == 0 ) &&
                 ( pNpScb->pScb->OpenNdsStreams == 0 ) ) {
                NdsUnlicenseConnection( IrpContext );
            }

            NwDequeueIrpContext( IrpContext, FALSE );
        }

        if ( Icb->IsExCredentialHandle ) {
            ExCreateDereferenceCredentials( IrpContext, Icb->pContext );
        }

    }

    if ( Icb->Pid != INVALID_PID ) {

        //
        //  This ICB was involved in a search, send the end job,
        //  then free the PID.
        //

        NwUnmapPid(pNpScb, Icb->Pid, IrpContext );
    }

    //
    //  Update the time the SCB was last used.
    //

    KeQuerySystemTime( &pNpScb->LastUsedTime );

    //
    //  Wait the SCB queue.  We do this now since NwDeleteIcb may cause
    //  a packet to be sent by this thread (from NwCleanupVcb()) while
    //  holding the RCB.  To eliminate this potential source of deadlock,
    //  queue this IrpContext to the SCB queue before acquiring the RCB.
    //
    //  Also, we mark this IRP context not reconnectable, since the
    //  reconnect logic, will try to acquire the RCB.
    //

    NwAppendToQueueAndWait( IrpContext );
    ClearFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    //  Delete the ICB.
    //

    NwDeleteIcb( IrpContext, Icb );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwCloseIcb -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\const.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Const.h

Abstract:

    This module declares the obal data used by the NetWare redirector
    file system.

Author:

    Colin Watson    [ColinW]    14-Jan-1993

Revision History:

--*/

#ifndef _NWCONST_
#define _NWCONST_

//  Number of spare stack locations required in Irp's submitted to this
//  filesystem

#define NWRDR_IO_STACKSIZE 2

//
// NT uses a system time measured in 100 nanosecnd intervals. define
// convenient constants for setting the timer.
//

#define MICROSECONDS                10
#define MILLISECONDS                MICROSECONDS*1000
#define SECONDS                     MILLISECONDS*1000

#define NwOneSecond 10000000

//
//  Default number of times to retranmit a packet before giving up
//  on waiting for a response.
//

#define  DEFAULT_RETRY_COUNT   10

//
//  Amount of time, in seconds, an idle SCB or VCB should be kept around before
//  being cleaned up.
//

#define  DORMANT_SCB_KEEP_TIME   120
#define  DORMANT_VCB_KEEP_TIME   120

//
//  Largest netware file name
//

#define NW_MAX_FILENAME_LENGTH  255
#define NW_MAX_FILENAME_SIZE    ( NW_MAX_FILENAME_LENGTH * sizeof(WCHAR) )

//
//  Default frequency for running the scavenger (in 1/18th second ticks)
//  Approx once per minute.
//

#define DEFAULT_SCAVENGER_TICK_RUN_COUNT 1100

//
//  Size of the drive map table.   With room for 26 letter connections,
//  and 10 LPT connections.
//

#define MAX_DISK_REDIRECTIONS  26
#define MAX_LPT_REDIRECTIONS   10
#define DRIVE_MAP_TABLE_SIZE   (MAX_DISK_REDIRECTIONS + MAX_LPT_REDIRECTIONS)

//
//  The size of the largest packet we can generate, rounded up to DWORD
//  size.  This longest packet is a rename with two long filenames plus 
//  the header (256*2) + 32
//

#define  MAX_SEND_DATA      (512)+32
//
//  The size of the largest non READ packet we can receive, rounded up to DWORD
//  size. This longest packet is read queue job list of 250 jobs
//

#define  MAX_RECV_DATA      544+32

//
//  Best guess at max packet size, if the transport can't tell us.
//  Pick the largest value that will work on any net.
//

#define DEFAULT_PACKET_SIZE  512

//
//  How close we want to get to true MTU of a connection
//

#define BURST_PACKET_SIZE_TOLERANCE  8

//
//  Default tick count, in case the transport won't fess up.
//

#define DEFAULT_TICK_COUNT      2

//
//  Maximum number of times to retry SAP broadcast if we get no response
//

#define MAX_SAP_RETRIES         2

//
//  The maximum number of SAP response to process if we get many.
//

#define MAX_SAP_RESPONSES       4


#define LFN_NO_OS2_NAME_SPACE   -1

//
// The ordinal for the long namespace in the namespace packet.
//

#define DOS_NAME_SPACE_ORDINAL  0
#define LONG_NAME_SPACE_ORDINAL 4

//
//  Largest possible SAP Response size and size of a SAP record
//

#define MAX_SAP_RESPONSE_SIZE   512
#define SAP_RECORD_SIZE         (2 + 48 + 12 + 2)
#define FIND_NEAREST_RESP_SIZE  (2 + SAP_RECORD_SIZE)

//
//  Netware limits
//

#define MAX_SERVER_NAME_LENGTH   48
#define MAX_UNICODE_UID_LENGTH   8
#define MAX_USER_NAME_LENGTH     49
#define MAX_VOLUME_NAME_LENGTH   17

//
//  Maximum number of unique drive letters we will send to a server.
//  Only seems to matter to portable netWare servers.
//
#define MAX_DRIVES              64


//
//  Default Timeout Event interval. We do not want to fill up the
//  event-log with timeout events. If a timeout event has been logged
//  in the last timeout event interval, we will ignore further timeout
//  events.
//

#define DEFAULT_TIMEOUT_EVENT_INTERVAL  5


#endif // _NWCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\attach.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Attach.c

Abstract:

    This module implements the routines for the NetWare
    redirector to connect and disconnect from a server.

Author:

    Colin Watson    [ColinW]    10-Jan-1992

Revision History:

--*/

#include "Procs.h"
#include <stdlib.h>   // rand

//
// The number of bytes in the ipx host address, not
// including the socket.
//

#define IPX_HOST_ADDR_LEN 10

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

VOID
ExtractNextComponentName (
    OUT PUNICODE_STRING Name,
    IN PUNICODE_STRING Path,
    IN BOOLEAN ColonSeparator
    );

NTSTATUS
ExtractPathAndFileName(
    IN PUNICODE_STRING EntryPath,
    OUT PUNICODE_STRING PathString,
    OUT PUNICODE_STRING FileName
    );

NTSTATUS
DoBinderyLogon(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    );

NTSTATUS
ConnectToServer(
    IN PIRP_CONTEXT pIrpContext,
    OUT PSCB *pScbCollision
    );

BOOLEAN
ProcessFindNearestEntry(
    PIRP_CONTEXT IrpContext,
    PSAP_FIND_NEAREST_RESPONSE FindNearestResponse
    );

NTSTATUS
GetMaxPacketSize(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    );

PNONPAGED_SCB
FindServer(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    PUNICODE_STRING ServerName
    );

NTSTATUS
NwAllocateAndInitScb(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UidServerName OPTIONAL,
    IN PUNICODE_STRING ServerName OPTIONAL,
    OUT PSCB *ppScb
);

NTSTATUS
IndirectToSeedServer(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pNewServer
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ExtractNextComponentName )
#pragma alloc_text( PAGE, ExtractPathAndFileName )
#pragma alloc_text( PAGE, CrackPath )
#pragma alloc_text( PAGE, CreateScb )
#pragma alloc_text( PAGE, FindServer )
#pragma alloc_text( PAGE, ProcessFindNearestEntry )
#pragma alloc_text( PAGE, NegotiateBurstMode )
#pragma alloc_text( PAGE, GetMaxPacketSize )
#pragma alloc_text( PAGE, NwDeleteScb )
#pragma alloc_text( PAGE, NwLogoffAndDisconnect )
#pragma alloc_text( PAGE, InitializeAttach )
#pragma alloc_text( PAGE, OpenScbSockets )
#pragma alloc_text( PAGE, DoBinderyLogon )
#pragma alloc_text( PAGE, QueryServersAddress )
#pragma alloc_text( PAGE, TreeConnectScb )
#pragma alloc_text( PAGE, TreeDisconnectScb )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, ProcessFindNearest )
#pragma alloc_text( PAGE1, NwLogoffAllServers )
#pragma alloc_text( PAGE1, DestroyAllScb )
#pragma alloc_text( PAGE1, SelectConnection )
#pragma alloc_text( PAGE1, NwFindScb )
#pragma alloc_text( PAGE1, ConnectToServer )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


VOID
ExtractNextComponentName (
    OUT PUNICODE_STRING Name,
    IN PUNICODE_STRING Path,
    IN BOOLEAN ColonSeparator
    )

/*++

Routine Description:

    This routine extracts a the "next" component from a path string.

    It assumes that

Arguments:

    Name - Returns a pointer to the component.

    Path - Supplies a pointer to the backslash seperated pathname.

    ColonSeparator - A colon can be used to terminate this component
        name.

Return Value:

    None

--*/

{
    register USHORT i;                   // Index into Name string.

    PAGED_CODE();

    if (Path->Length == 0) {
        RtlInitUnicodeString(Name, NULL);
        return;
    }

    //
    //  Initialize the extracted name to the name passed in skipping the
    //  leading backslash.
    //

    //  DebugTrace(+0, Dbg, "NwExtractNextComponentName = %wZ\n", Path );

    Name->Buffer = Path->Buffer + 1;
    Name->Length = Path->Length - sizeof(WCHAR);
    Name->MaximumLength = Path->MaximumLength - sizeof(WCHAR);

    //
    // Scan forward finding the terminal "\" in the server name.
    //

    for (i=0;i<(USHORT)(Name->Length/sizeof(WCHAR));i++) {

        if ( Name->Buffer[i] == OBJ_NAME_PATH_SEPARATOR ||
             ( ColonSeparator && Name->Buffer[i] == L':' ) ) {
            break;
        }
    }

    //
    //  Update the length and maximum length of the structure
    //  to match the new length.
    //

    Name->Length = Name->MaximumLength = (USHORT)(i*sizeof(WCHAR));
}


NTSTATUS
ExtractPathAndFileName (
    IN PUNICODE_STRING EntryPath,
    OUT PUNICODE_STRING PathString,
    OUT PUNICODE_STRING FileName
    )
/*++

Routine Description:

    This routine cracks the entry path into two pieces, the path and the file
name component at the start of the name.


Arguments:

    IN PUNICODE_STRING EntryPath - Supplies the path to disect.
    OUT PUNICODE_STRING PathString - Returns the directory containing the file.
    OUT PUNICODE_STRING FileName - Returns the file name specified.

Return Value:

    NTSTATUS - SUCCESS


--*/

{
    UNICODE_STRING Component;
    UNICODE_STRING FilePath = *EntryPath;

    PAGED_CODE();

    //  Strip trailing separators
    while ( (FilePath.Length != 0) &&
            FilePath.Buffer[(FilePath.Length-1)/sizeof(WCHAR)] ==
                OBJ_NAME_PATH_SEPARATOR ) {

        FilePath.Length         -= sizeof(WCHAR);
        FilePath.MaximumLength  -= sizeof(WCHAR);
    }

    // PathString will become EntryPath minus FileName and trailing separators
    *PathString = FilePath;

    //  Initialize FileName just incase there are no components at all.
    RtlInitUnicodeString( FileName, NULL );

    //
    //  Scan through the current file name to find the entire path
    //  up to (but not including) the last component in the path.
    //

    do {

        //
        //  Extract the next component from the name.
        //

        ExtractNextComponentName(&Component, &FilePath, FALSE);

        //
        //  Bump the "remaining name" pointer by the length of this
        //  component
        //

        if (Component.Length != 0) {

            FilePath.Length         -= Component.Length+sizeof(WCHAR);
            FilePath.MaximumLength  -= Component.MaximumLength+sizeof(WCHAR);
            FilePath.Buffer         += (Component.Length/sizeof(WCHAR))+1;

            *FileName = Component;
        }


    } while (Component.Length != 0);

    //
    //  Take the name, subtract the last component of the name
    //  and concatenate the current path with the new path.
    //

    if ( FileName->Length != 0 ) {

        //
        //  Set the path's name based on the original name, subtracting
        //  the length of the name portion (including the "\")
        //

        PathString->Length -= (FileName->Length + sizeof(WCHAR));
        if ( PathString->Length != 0 ) {
            PathString->MaximumLength -= (FileName->MaximumLength + sizeof(WCHAR));
        } else{
            RtlInitUnicodeString( PathString, NULL );
        }
    } else {

        //  There was no path or filename

        RtlInitUnicodeString( PathString, NULL );
    }

    return STATUS_SUCCESS;
}


NTSTATUS
CrackPath (
    IN PUNICODE_STRING BaseName,
    OUT PUNICODE_STRING DriveName,
    OUT PWCHAR DriveLetter,
    OUT PUNICODE_STRING ServerName,
    OUT PUNICODE_STRING VolumeName,
    OUT PUNICODE_STRING PathName,
    OUT PUNICODE_STRING FileName,
    OUT PUNICODE_STRING FullName OPTIONAL
    )

/*++

Routine Description:

    This routine extracts the relevant portions from BaseName to extract
    the components of the user's string.


Arguments:

    BaseName - Supplies the base user's path.

    DriveName - Supplies a string to hold the drive specifier.

    DriveLetter - Returns the drive letter.  0 for none, 'A'-'Z' for
        disk drives, '1'-'9' for LPT connections.

    ServerName - Supplies a string to hold the remote server name.

    VolumeName - Supplies a string to hold the volume name.

    PathName - Supplies a string to hold the remaining part of the path.

    FileName - Supplies a string to hold the final component of the path.

    FullName - Supplies a string to put the Path followed by FileName

Return Value:

    NTSTATUS - Status of operation


--*/

{
    NTSTATUS Status;

    UNICODE_STRING BaseCopy = *BaseName;
    UNICODE_STRING ShareName;

    PAGED_CODE();

    RtlInitUnicodeString( DriveName, NULL);
    RtlInitUnicodeString( ServerName, NULL);
    RtlInitUnicodeString( VolumeName, NULL);
    RtlInitUnicodeString( PathName, NULL);
    RtlInitUnicodeString( FileName, NULL);
    *DriveLetter = 0;

    if (ARGUMENT_PRESENT(FullName)) {
        RtlInitUnicodeString( FullName, NULL);
    }

    //
    //  If the name is "\", or empty, there is nothing to do.
    //

    if ( BaseName->Length <= sizeof( WCHAR ) ) {
        return STATUS_SUCCESS;
    }

    ExtractNextComponentName(ServerName, &BaseCopy, FALSE);

    //
    //  Skip over the server name.
    //

    BaseCopy.Buffer += (ServerName->Length / sizeof(WCHAR)) + 1;
    BaseCopy.Length -= ServerName->Length + sizeof(WCHAR);
    BaseCopy.MaximumLength -= ServerName->MaximumLength + sizeof(WCHAR);

    if ((ServerName->Length == sizeof(L"X:") - sizeof(WCHAR) ) &&
        (ServerName->Buffer[(ServerName->Length / sizeof(WCHAR)) - 1] == L':'))
    {

        //
        //  The file name is of the form x:\server\volume\foo\bar
        //

        *DriveName = *ServerName;
        *DriveLetter = DriveName->Buffer[0];

        RtlInitUnicodeString( ServerName, NULL );
        ExtractNextComponentName(ServerName, &BaseCopy, FALSE);

        if ( ServerName->Length != 0 ) {

            //
            //  Skip over the server name.
            //

            BaseCopy.Buffer += (ServerName->Length / sizeof(WCHAR)) + 1;
            BaseCopy.Length -= ServerName->Length + sizeof(WCHAR);
            BaseCopy.MaximumLength -= ServerName->MaximumLength + sizeof(WCHAR);
        }
    }
    else if ( ( ServerName->Length == sizeof(L"LPTx") - sizeof(WCHAR) ) &&
         ( _wcsnicmp( ServerName->Buffer, L"LPT", 3 ) == 0) &&
         ( ServerName->Buffer[3] >= '0' && ServerName->Buffer[3] <= '9' ) )
    {

        //
        //  The file name is of the form LPTx\server\printq
        //

        *DriveName = *ServerName;
        *DriveLetter = DriveName->Buffer[3];

        RtlInitUnicodeString( ServerName, NULL );
        ExtractNextComponentName(ServerName, &BaseCopy, FALSE);

        if ( ServerName->Length != 0 ) {

            //
            //  Skip over the server name.
            //

            BaseCopy.Buffer += (ServerName->Length / sizeof(WCHAR)) + 1;
            BaseCopy.Length -= ServerName->Length + sizeof(WCHAR);
            BaseCopy.MaximumLength -= ServerName->MaximumLength + sizeof(WCHAR);
        }
    }

    if ( ServerName->Length != 0 ) {

        //
        //  The file name is of the form \\server\volume\foo\bar
        //  Set volume name to server\volume.
        //

        ExtractNextComponentName( &ShareName, &BaseCopy, TRUE );

        //
        //  Set volume name = \drive:\server\share  or \server\share if the
        //  path is UNC.
        //

        VolumeName->Buffer = ServerName->Buffer - 1;

        if ( ShareName.Length != 0 ) {

            VolumeName->Length = ServerName->Length + ShareName.Length + 2 * sizeof( WCHAR );

            if ( DriveName->Buffer != NULL ) {
                VolumeName->Buffer = DriveName->Buffer - 1;
                VolumeName->Length += DriveName->Length + sizeof(WCHAR);
            }

            BaseCopy.Buffer += ShareName.Length / sizeof(WCHAR) + 1;
            BaseCopy.Length -= ShareName.Length + sizeof(WCHAR);
            BaseCopy.MaximumLength -= ShareName.MaximumLength + sizeof(WCHAR);

        } else {

            VolumeName->Length = ServerName->Length + sizeof( WCHAR );
            return( STATUS_SUCCESS );

        }

        VolumeName->MaximumLength = VolumeName->Length;
    }
    else
    {
        //
        // server name is empty. this should only happen if we are
        // opening the redirector itself. if there is volume or other
        // components left, fail it.
        //

        if (BaseCopy.Length > sizeof(WCHAR))
        {
            return STATUS_BAD_NETWORK_PATH ;
        }
    }

    Status = ExtractPathAndFileName ( &BaseCopy, PathName, FileName );

    if (NT_SUCCESS(Status) &&
        ARGUMENT_PRESENT(FullName)) {

        //
        //  Use the feature that PathName and FileName are in the same buffer
        //  to return <pathname>\<filename>
        //

        if ( PathName->Buffer == NULL ) {

            //  return just <filename> or NULL

            *FullName =  *FileName;

        } else {
            //  Set FullFileName to <PathName>'\'<FileName>

            FullName->Buffer =  PathName->Buffer;

            FullName->Length = PathName->Length +
                FileName->Length +
                sizeof(WCHAR);

            FullName->MaximumLength = PathName->MaximumLength +
                FileName->MaximumLength +
                sizeof(WCHAR);
        }
    }

    return( Status );
}

NTSTATUS
GetServerByAddress(
    IN PIRP_CONTEXT pIrpContext,
    OUT PSCB *Scb,
    IN IPXaddress *pServerAddress
)
/*+++

Description:

    This routine looks up a server by address.  If it finds a server that
    has been connected, it returns it referenced.  Otherwise, it returns no
    server.

---*/
{

    NTSTATUS Status;
    PLIST_ENTRY ScbQueueEntry;
    KIRQL OldIrql;
    PNONPAGED_SCB pFirstNpScb, pNextNpScb;
    PNONPAGED_SCB pFoundNpScb = NULL;
    UNICODE_STRING CredentialName;

    //
    // Start at the head of the SCB list.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    if ( ScbQueue.Flink == &ScbQueue ) {
        KeReleaseSpinLock( &ScbSpinLock, OldIrql);
        return STATUS_UNSUCCESSFUL;
    }

    ScbQueueEntry = ScbQueue.Flink;
    pFirstNpScb = CONTAINING_RECORD( ScbQueueEntry,
                                     NONPAGED_SCB,
                                     ScbLinks );
    pNextNpScb = pFirstNpScb;

    //
    // Leave the first SCB referenced since we need it to
    // be there for when we walk all the way around the list.
    //

    NwReferenceScb( pFirstNpScb );
    NwReferenceScb( pNextNpScb );

    KeReleaseSpinLock( &ScbSpinLock, OldIrql);

    while ( TRUE ) {

        //
        // Check to see if the SCB address matches the address we have
        // and if the user uid matches the uid for this request.  Skip
        // matches that are abandoned anonymous creates.
        //

        if ( pNextNpScb->pScb ) {

            if ( ( RtlCompareMemory( (BYTE *) pServerAddress,
                                   (BYTE *) &pNextNpScb->ServerAddress,
                                   IPX_HOST_ADDR_LEN ) == IPX_HOST_ADDR_LEN ) &&
                 ( pIrpContext->Specific.Create.UserUid.QuadPart ==
                       pNextNpScb->pScb->UserUid.QuadPart ) &&
                 ( pNextNpScb->State != SCB_STATE_FLAG_SHUTDOWN ) &&
                 ( !IS_ANONYMOUS_SCB( pNextNpScb->pScb ) ) ) {

                if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

                    //
                    // If this isn't an ex-create server, you can't use
                    // it for this operation.
                    //

                    if ( !IsCredentialName( &(pNextNpScb->ServerName) ) ) {
                        goto ContinueLoop;
                    }

                    //
                    // On a credential create, the credential supplied has
                    // to match the extended credential for the server.
                    //

                    Status = GetCredentialFromServerName( &pNextNpScb->ServerName,
                                                          &CredentialName );
                    if ( !NT_SUCCESS( Status ) ) {
                        goto ContinueLoop;
                    }

                    if ( RtlCompareUnicodeString( &CredentialName,
                                                  pIrpContext->Specific.Create.puCredentialName,
                                                  TRUE ) ) {
                        goto ContinueLoop;
                    }

                } else {

                    //
                    // If this is an ex-create server, you can't use it for
                    // this operation.
                    //

                    if ( IsCredentialName( &(pNextNpScb->ServerName) ) ) {
                        goto ContinueLoop;
                    }
                }

                pFoundNpScb = pNextNpScb;
                DebugTrace( 0, Dbg, "GetServerByAddress: %wZ\n", &pFoundNpScb->ServerName );
                break;

            }
        }

ContinueLoop:

        //
        // Otherwise, get the next one in the list.  Don't
        // forget to skip the list head.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

        ScbQueueEntry = pNextNpScb->ScbLinks.Flink;

        if ( ScbQueueEntry == &ScbQueue ) {
            ScbQueueEntry = ScbQueue.Flink;
        }

        NwDereferenceScb( pNextNpScb );
        pNextNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        if ( pNextNpScb == pFirstNpScb ) {
            KeReleaseSpinLock( &ScbSpinLock, OldIrql );
            break;
        }

        //
        // Otherwise, reference this SCB and continue.
        //

        NwReferenceScb( pNextNpScb );
        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    }

    NwDereferenceScb( pFirstNpScb );

    if ( pFoundNpScb ) {
        *Scb = pFoundNpScb->pScb;
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;

}

NTSTATUS
CheckScbSecurity(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    IN BOOLEAN fDeferLogon
)
/*+++

    You must be at the head of the queue to call this function.
    This function makes sure that the Scb is valid for the user
    that requested it.

---*/
{

    NTSTATUS Status;
    BOOLEAN SecurityConflict = FALSE;

    ASSERT( pScb->pNpScb->State == SCB_STATE_IN_USE );

    //
    // If there's no user name or password, there's no conflict.
    //

    if ( ( puUserName == NULL ) &&
         ( puPassword == NULL ) ) {

        return STATUS_SUCCESS;
    }

    if ( pScb->UserName.Length &&
         pScb->UserName.Buffer ) {

        //
        // Do a bindery security check if we were bindery
        // authenticated to this server.
        //

        if ( !fDeferLogon &&
             puUserName != NULL &&
             puUserName->Buffer != NULL ) {

            ASSERT( pScb->Password.Buffer != NULL );

            if ( !RtlEqualUnicodeString( &pScb->UserName, puUserName, TRUE ) ||
                 ( puPassword &&
                   puPassword->Buffer &&
                   puPassword->Length &&
                   !RtlEqualUnicodeString( &pScb->Password, puPassword, TRUE ) )) {

                SecurityConflict = TRUE;

            }
        }

    } else {

        //
        // Do an nds security check.
        //

        Status = NdsCheckCredentials( pIrpContext,
                                      puUserName,
                                      puPassword );

        if ( !NT_SUCCESS( Status )) {

            SecurityConflict = TRUE;
        }

    }

    //
    // If there was a security conflict, see if we can just
    // take this connection over (i.e. there are no open
    // files or open handles to the server).
    //

    if ( SecurityConflict ) {

        if ( ( pScb->OpenFileCount == 0 ) &&
             ( pScb->IcbCount == 0 ) ) {

            if ( pScb->UserName.Buffer ) {
                FREE_POOL( pScb->UserName.Buffer );
            }

            RtlInitUnicodeString( &pScb->UserName, NULL );
            RtlInitUnicodeString( &pScb->Password, NULL );
            pScb->pNpScb->State = SCB_STATE_LOGIN_REQUIRED;

        } else {

            DebugTrace( 0, Dbg, "SCB security conflict.\n", 0 );
            return STATUS_NETWORK_CREDENTIAL_CONFLICT;

        }

    }

    DebugTrace( 0, Dbg, "SCB security check succeeded.\n", 0 );
    return STATUS_SUCCESS;

}

NTSTATUS
GetScb(
    OUT PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    OUT PBOOLEAN Existing
)
/*+++

Description:

    This routine locates an existing SCB or creates a new SCB.
    This is the first half of the original CreateScb routine.

Locks:

    See the anonymous create information in CreateScb().

---*/
{

    NTSTATUS Status;
    PSCB pScb = NULL;
    PNONPAGED_SCB pNpScb = NULL;
    BOOLEAN ExistingScb = TRUE;
    UNICODE_STRING UidServer;
    UNICODE_STRING ExCredName;
    PUNICODE_STRING puConnectName;
    KIRQL OldIrql;

    DebugTrace( 0, Dbg, "GetScb... %wZ\n", Server );

    if ( pServerAddress != NULL ) {
        DebugTrace( 0, Dbg, " ->Server Address         = (provided)\n", 0 );
    } else {
        DebugTrace( 0, Dbg, " ->Server Address         = NULL\n", 0 );
    }

    RtlInitUnicodeString( &UidServer, NULL );

    if ( ( Server == NULL ) ||
         ( Server->Length == 0 ) ) {

        //
        // No server name was provided.  Either this is a connect by address,
        // or a connect to a nearby bindery server (defaulting to the preferred
        // server).
        //

        if ( pServerAddress == NULL ) {

            //
            // No server address was provided, so this is an attempt to open
            // a nearby bindery server.
            //

            while (TRUE) {

                //
                // The loop checks that after we get to the front, the SCB
                // is still in the state we wanted.  If not, we need to
                // reselect another.
                //

                pNpScb = SelectConnection( NULL );

                //
                // Note: We'd like to call SelectConnection with the pNpScb
                // that we last tried, but if the scavenger runs before
                // this loop gets back to the select connection, we could
                // pass a bum pointer to SelectConnection, which is bad.
                //

                if ( pNpScb != NULL) {

                    pScb = pNpScb->pScb;

                    //
                    //  Queue ourselves to the SCB, wait to get to the front to
                    //  protect access to server State.
                    //

                    pIrpContext->pNpScb = pNpScb;
                    pIrpContext->pScb = pScb;

                    NwAppendToQueueAndWait( pIrpContext );

                    //
                    // These states have to match the conditions of the
                    // SelectConnection to prevent an infinite loop.
                    //

                    if (!((pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) ||
                          (pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) ||
                          (pNpScb->State == SCB_STATE_IN_USE ))) {

                        //
                        // No good any more as default server, select another.
                        //

                        pScb = NULL ;
                        NwDequeueIrpContext( pIrpContext, FALSE );
                        NwDereferenceScb( pNpScb );
                        continue ;

                    }
                }

                //
                // otherwise, we're done
                //

                break ;

            }

        } else {

            //
            // An address was provided, so we are attempting to do a lookup
            // based on address.  The server that we are looking for might
            // exist but not yet have its address recorded, so if we do an
            // anonymous create, we have to check at the end whether or not
            // someone else came in and successfully created while we were
            // looking up the name.
            //
            // We don't have to hold the RCB anymore since colliding creates
            // have to be handled gracefully anyway.
            //

            Status = GetServerByAddress( pIrpContext, &pScb, pServerAddress );

            if ( !NT_SUCCESS( Status ) ) {

                PLIST_ENTRY pTemp;

                //
                // No anonymous creates are allowed if we are not allowed
                // to send packets to the net (because it's not possible for
                // us to resolve the address to a name).
                //

                if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_NOCONNECT ) ) {
                    return STATUS_BAD_NETWORK_PATH;
                }

                //
                // There's no connection to this server, so we'll
                // have to create one.  Let's start with an anonymous
                // Scb.
                //

                Status = NwAllocateAndInitScb( pIrpContext,
                                               NULL,
                                               NULL,
                                               &pScb );

                if ( !NT_SUCCESS( Status )) {
                    return Status;
                }

                //
                // We've made the anonymous create, so put it on the scb
                // list and get to the head of the queue.
                //

                SetFlag( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

                pIrpContext->pScb = pScb;
                pIrpContext->pNpScb = pScb->pNpScb;

                ExInterlockedInsertHeadList( &pScb->pNpScb->Requests,
                                             &pIrpContext->NextRequest,
                                             &pScb->pNpScb->NpScbSpinLock );

                pTemp = &pScb->pNpScb->ScbLinks;
                KeAcquireSpinLock(&ScbSpinLock, &OldIrql);
                InsertTailList(&ScbQueue, pTemp);
                KeReleaseSpinLock(&ScbSpinLock, OldIrql);

                DebugTrace( 0, Dbg, "GetScb started an anonymous create.\n", 0 );
                ExistingScb = FALSE;

            } else {

                //
                // Get to the head of the queue and see if this was
                // an abandoned anonymous create.  If so, get the
                // right server and continue.
                //

                pIrpContext->pScb = pScb;
                pIrpContext->pNpScb = pScb->pNpScb;
                NwAppendToQueueAndWait( pIrpContext );

                if ( pScb->pNpScb->State == SCB_STATE_FLAG_SHUTDOWN ) {

                    //
                    // The create abandoned this scb, redoing a
                    // GetServerByAddress() is guaranteed to get
                    // us a good server if there is a server out
                    // there.
                    //

                    NwDequeueIrpContext( pIrpContext, FALSE );
                    NwDereferenceScb( pScb->pNpScb );

                    Status = GetServerByAddress( pIrpContext, &pScb, pServerAddress );

                    if ( NT_SUCCESS( Status ) ) {
                        ASSERT( pScb != NULL );
                        ASSERT( !IS_ANONYMOUS_SCB( pScb ) );
                    }

                } else {

                    ASSERT( !IS_ANONYMOUS_SCB( pScb ) );
                }
            }

            ASSERT( pScb != NULL );
            pNpScb = pScb->pNpScb;
        }

    } else {

        //
        // A server name was provided, so we are doing a straight
        // lookup or create by name.  Do we need to munge the name
        // for a supplemental credential connect?
        //

        RtlInitUnicodeString( &ExCredName, NULL );

        if ( ( pIrpContext->Specific.Create.fExCredentialCreate ) &&
             ( !IsCredentialName( Server ) ) ) {

            Status = BuildExCredentialServerName( Server,
                                                  pIrpContext->Specific.Create.puCredentialName,
                                                  &ExCredName );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            puConnectName = &ExCredName;

        } else {

            puConnectName = Server;
        }

        Status = MakeUidServer( &UidServer,
                                &pIrpContext->Specific.Create.UserUid,
                                puConnectName );


        if ( ExCredName.Buffer ) {
            FREE_POOL( ExCredName.Buffer );
        }

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        DebugTrace( 0, Dbg, " ->UidServer              = %wZ\n", &UidServer );

        ExistingScb = NwFindScb( &pScb, pIrpContext, &UidServer, Server );

        ASSERT( pScb != NULL );
        pNpScb = pScb->pNpScb;

        pIrpContext->pNpScb = pNpScb;
        pIrpContext->pScb = pScb;
        NwAppendToQueueAndWait(pIrpContext);

    }

    //
    // 1) We may or may not have a server (evidenced by pScb).
    //
    // 2) If we have a server and ExistingScb is TRUE, we have
    //    an existing server, possibly already connected.
    //    Otherwise, we have a newly created server that
    //    may or may not be anonymous.
    //
    // 3) If we are logged into this server make sure the supplied
    //    username and password, match the username and password
    //    that we logged in with.
    //

    if ( ( pScb ) && ( ExistingScb ) ) {

        if ( pNpScb->State == SCB_STATE_IN_USE ) {

            Status = CheckScbSecurity( pIrpContext,
                                       pScb,
                                       UserName,
                                       Password,
                                       DeferLogon );

            if ( !NT_SUCCESS( Status ) ) {

                if ( UidServer.Buffer != NULL ) {
                    FREE_POOL( UidServer.Buffer );
                }

                NwDequeueIrpContext( pIrpContext, FALSE );
                NwDereferenceScb( pNpScb );
                return Status;
            }
        }
    }

    *Scb = pScb;
    *Existing = ExistingScb;

#ifdef NWDBG

    if ( pScb != NULL ) {

        //
        // If we have a server, the SCB is referenced and we will
        // be at the head of the queue.
        //

        ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );

    }

#endif

    if ( UidServer.Buffer != NULL ) {
        FREE_POOL( UidServer.Buffer );
    }

    DebugTrace( 0, Dbg, "GetScb returned %08lx\n", pScb );
    return STATUS_SUCCESS;

}

NTSTATUS
ConnectScb(
    IN PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    IN BOOLEAN DeleteConnection,
    IN BOOLEAN ExistingScb
)
/*+++

Description:

    This routine puts the provided scb in the connected state.
    This is the second half of the original CreateScb routine.

Arguments:

    Scb              - The scb for the server we want to connect.
    pIrpContext      - The context for this request.
    Server           - The name of the server, or NULL.
    pServerAddress   - The address of the server, or NULL,
    UserName         - The name of the user to connect as, or NULL.
    Password         - The password for the user, or NULL.
    DeferLogon       - Should we defer the logon?
    DeleteConnection - Should we succeed even without the net so that
                       the delete request will succeed?
    ExistingScb      - Is this an existing SCB?

    If the SCB is anonymous, we need to safely check for colliding
    creates when we find out who the server is.

    If this is a reconnect attempt, this routine will not dequeue the
    irp context, which could cause a deadlock in the reconnect logic.

---*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    PSCB pScb = *Scb;
    PNONPAGED_SCB pNpScb = NULL;

    BOOLEAN AnonymousScb = FALSE;
    PSCB pCollisionScb = NULL;

    NTSTATUS LoginStatus;
    BOOLEAN TriedNdsLogin;

    PLOGON pLogon;
    BOOLEAN DeferredLogon = DeferLogon;
    PNDS_SECURITY_CONTEXT pNdsContext;
    NTSTATUS CredStatus;

    DebugTrace( 0, Dbg, "ConnectScb... %08lx\n", pScb );

    //
    // If we already have an SCB, find out where in the
    // connect chain we need to start off.
    //

    if ( pScb ) {

        pNpScb = pScb->pNpScb;
        AnonymousScb = IS_ANONYMOUS_SCB( pScb );

        if ( ExistingScb ) {

            ASSERT( !AnonymousScb );

            //
            //  If this SCB is in STATE_ATTACHING, we need to check
            //  the address in the SCB to make sure that it was at one
            //  point a valid server.  If it wasn't, then we shouldn't
            //  honor this create because it's probably a tree create.
            //

            if ( DeleteConnection ) {

                ASSERT( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) );

                if ( ( pNpScb->State == SCB_STATE_ATTACHING ) &&
                     ( (pNpScb->ServerAddress).Socket == 0 ) ) {

                    Status = STATUS_BAD_NETWORK_PATH;
                    goto CleanupAndExit;

                } else {

                    NwDequeueIrpContext( pIrpContext, FALSE );
                    return STATUS_SUCCESS;
                }
            }

RedoConnect:

            if ( pNpScb->State == SCB_STATE_ATTACHING ) {
                goto GetAddress;
            } else if ( pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {
                goto Connect;
            } else if ( pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) {
                goto Login;
            } else if ( pNpScb->State == SCB_STATE_IN_USE ) {
                goto InUse;
            } else {

                DebugTrace( 0, Dbg, "ConnectScb: Unknown Scb State %08lx\n", pNpScb->State );
                Status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

        } else {

            //
            // This is a new SCB, we have to run through the whole routine.
            //

            pNpScb->State = SCB_STATE_ATTACHING;
        }

    }

GetAddress:

    //
    //  Set the reroute attempted bit so that we don't try
    //  to reconnect during the connect.
    //

    SetFlag( pIrpContext->Flags, IRP_FLAG_REROUTE_ATTEMPTED );

    if ( !pServerAddress ) {

        //
        // If we don't have an address, this SCB cannot be anonymous!!
        //

        ASSERT( !AnonymousScb );

        //
        // We have to cast an exception frame for this legacy routine
        // that still uses structured exceptions.
        //

        try {

            pNpScb = FindServer( pIrpContext, pNpScb, Server );

            ASSERT( pNpScb != NULL );

            //
            // This is redundant unless the starting server was NULL.
            // FindServer returns the same SCB we provided to it
            // unless we called it with NULL.
            //

            pScb = pNpScb->pScb;
            pIrpContext->pNpScb = pNpScb;
            pIrpContext->pScb = pScb;
            NwAppendToQueueAndWait( pIrpContext );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            goto CleanupAndExit;
        }

    } else {

        //
        // Build the address into the NpScb since we already know it.
        //

        RtlCopyMemory( &pNpScb->ServerAddress,
                       pServerAddress,
                       sizeof( TDI_ADDRESS_IPX ) );

        if ( pNpScb->ServerAddress.Socket != NCP_SOCKET ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "CreateScb supplied server socket is deviant.\n", 0 );
        }

        BuildIpxAddress( pNpScb->ServerAddress.Net,
                         pNpScb->ServerAddress.Node,
                         pNpScb->ServerAddress.Socket,
                         &pNpScb->RemoteAddress );

        pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

    }

Connect:

    //
    // FindServer may have connected us to the server already,
    // so we may be able to skip the reconnect here.
    //

    if ( pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {

        //
        // If this is an anonymous scb, we have to be prepared
        // for ConnectToServer() to find that we've already connected
        // this server by name.  In this case, we cancel the
        // anonymous create and use the server that was created
        // while we were looking up the name.
        //

        Status = ConnectToServer( pIrpContext, &pCollisionScb );

        if (!NT_SUCCESS(Status)) {
            goto CleanupAndExit;
        }

        //
        // We succeeded.  If there's a collision scb, then we need to
        // abandon the anonymous scb and use the scb that we collided
        // with.  Otherwise, we successfully completed an anonymous
        // connect and can go on with the create normally.
        //

        if ( pCollisionScb ) {

            ASSERT( AnonymousScb );

            //
            // Deref and dequeue from the abandoned server.
            //

            NwDequeueIrpContext( pIrpContext, FALSE );
            NwDereferenceScb( pIrpContext->pNpScb );

            //
            // Queue to the appropriate server.
            //

            pIrpContext->pScb = pCollisionScb;
            pIrpContext->pNpScb = pCollisionScb->pNpScb;
            NwAppendToQueueAndWait( pIrpContext );

            pScb = pCollisionScb;
            pNpScb = pCollisionScb->pNpScb;
            *Scb = pCollisionScb;

            //
            // Re-start connecting the scb.
            //

            AnonymousScb = FALSE;
            ExistingScb = TRUE;

            pCollisionScb = NULL;

            DebugTrace( 0, Dbg, "Re-doing connect on anonymous collision.\n", 0 );
            goto RedoConnect;

        }

        DebugTrace( +0, Dbg, " Logout from server - just in case\n", 0);

        Status = ExchangeWithWait (
                     pIrpContext,
                     SynchronousResponseCallback,
                     "F",
                     NCP_LOGOUT );

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( !NT_SUCCESS( Status ) ) {
            goto CleanupAndExit;
        }

        DebugTrace( +0, Dbg, " Connect to real server = %X\n", Status);

        pNpScb->State = SCB_STATE_LOGIN_REQUIRED;
    }

Login:

    //
    // If we have credentials for the tree and this server was named
    // explicitly, we shouldn't defer the login or else the browse
    // view of the tree may be wrong.  For this reason, NdsServerAuthenticate
    // has to be a straight shot call and can't remove us from the head
    // of the queue.
    //

    if ( ( ( Server != NULL ) || ( pServerAddress != NULL ) ) &&
         ( DeferredLogon ) &&
         ( pScb->MajorVersion > 3 ) &&
         ( pScb->UserName.Length == 0 ) ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &pScb->UserUid, FALSE );
        NwReleaseRcb( &NwRcb );

        if ( pLogon ) {

            CredStatus = NdsLookupCredentials( pIrpContext,
                                               &pScb->NdsTreeName,
                                               pLogon,
                                               &pNdsContext,
                                               CREDENTIAL_READ,
                                               FALSE );

            if ( NT_SUCCESS( CredStatus ) ) {

                if ( ( pNdsContext->Credential != NULL ) &&
                     ( pNdsContext->CredentialLocked == FALSE ) ) {

                    DebugTrace( 0, Dbg, "Forcing authentication to %wZ.\n",
                                &pScb->UidServerName );
                    DeferredLogon = FALSE;
                }

                NwReleaseCredList( pLogon, pIrpContext );
            }
        }
    }

    if (pNpScb->State == SCB_STATE_LOGIN_REQUIRED && !DeferredLogon ) {

        //
        //  NOTE:   DoBinderyLogon() and DoNdsLogon() may return a
        //          warning status. If they do, we must return the
        //          warning status to the caller.
        //

        Status = STATUS_UNSUCCESSFUL;
        TriedNdsLogin = FALSE;

        //
        // We force a bindery login for a non 4.x server.  Otherwise, we
        // allow a fall-back from NDS style authentication to bindery style
        // authentication.
        //

        if ( pScb->MajorVersion >= 4 ) {

            ASSERT( pScb->NdsTreeName.Length != 0 );

            Status = DoNdsLogon( pIrpContext, UserName, Password );

            if ( NT_SUCCESS( Status ) ) {

                //
                // Do we need to re-license the connection?
                //

                if ( ( pScb->VcbCount > 0 ) || ( pScb->OpenNdsStreams > 0 ) ) {

                    Status = NdsLicenseConnection( pIrpContext );

                    if ( !NT_SUCCESS( Status ) ) {
                        Status = STATUS_REMOTE_SESSION_LIMIT;
                    }
                }

            }

            TriedNdsLogin = TRUE;
            LoginStatus = Status;

        }

        if ( !NT_SUCCESS( Status ) ) {

            Status = DoBinderyLogon( pIrpContext, UserName, Password );

        }

        if ( !NT_SUCCESS( Status ) ) {

            if ( TriedNdsLogin ) {

                //
                // Both login attempts have failed.  We usually prefer
                // the NDS status, but not always.
                //

               if ( ( Status != STATUS_WRONG_PASSWORD ) &&
                    ( Status != STATUS_ACCOUNT_DISABLED ) ) {
                   Status = LoginStatus;
               }
            }

            //
            //  Couldn't log on, be good boys and disconnect.
            //

            ExchangeWithWait (
                pIrpContext,
                SynchronousResponseCallback,
                "D-" );          // Disconnect

            Stats.Sessions--;

            if ( pScb->MajorVersion == 2 ) {
                Stats.NW2xConnects--;
            } else if ( pScb->MajorVersion == 3 ) {
                Stats.NW3xConnects--;
            } else if ( pScb->MajorVersion >= 4 ) {
                Stats.NW4xConnects--;
            }

            //
            // Demote this scb to reconnect required and exit.
            //

            pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
            goto CleanupAndExit;
        }

        pNpScb->State = SCB_STATE_IN_USE;
    }

    //
    // We have to be at the head of the queue to do the reconnect.
    //

    if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
        ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    } else {
        NwAppendToQueueAndWait( pIrpContext );
    }

    ReconnectScb( pIrpContext, pScb );

InUse:

    //
    // Ok, we've completed the connect routine.  Return this good server.
    //

    *Scb = pScb;

CleanupAndExit:

    //
    // The reconnect path must not do anything to remove the irp context from
    // the head of the queue since it also owns the irp context in the second
    // position on the queue and that irp context is running.
    //

    if ( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
        NwDequeueIrpContext( pIrpContext, FALSE );
    }

    DebugTrace( 0, Dbg, "ConnectScb: Connected %08lx\n", pScb );
    DebugTrace( 0, Dbg, "ConnectScb: Status was %08lx\n", Status );
    return Status;

}

NTSTATUS
CreateScb(
    OUT PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    IN BOOLEAN DeleteConnection
)
/*++

Routine Description:

    This routine connects to the requested server.

    The following mix of parameters are valid:

       Server Name, No Net Address - The routine will look up
           up the SCB or create a new one if necessary, getting
           the server address from a nearby bindery.

       No Server Name, Valid Net Address - The routine will
           look up the SCB by address or create a new one if
           necessary.  The name of the server will be set in
           the SCB upon return.

       Server Name, Valid Net Address - The routine will look
           up the SCB by name or will create a new one if
           necessary.  The supplied server address will be used,
           sparing a bindery query.

       No Server Name, No Net Address - A connection to the
           preferred server or a nearby server will be returned.

Arguments:

    Scb              - The pointer to the scb in question.
    pIrpContext      - The information for this request.
    Server           - The name of the server, or NULL.
    pServerAddress   - The address of the server, or NULL.
    UserName         - The username for the connect, or NULL.
    Password         - The password for the connect, or NULL.
    DeferLogon       - Should we defer the logon until later?
    DeleteConnection - Should we allow this even when there's no
                       net response so that the connection can
                       be deleted?

Return Value:

    NTSTATUS - Status of operation.  If the return status is STATUS_SUCCESS,
    then Scb must point to a valid Scb.  The irp context pointers will also
    be set, but the irp context will not be on the scb queue.

--*/
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PSCB pScb = NULL;
    PNONPAGED_SCB pOriginalNpScb = pIrpContext->pNpScb;
    PSCB pOriginalScb = pIrpContext->pScb;
    BOOLEAN ExistingScb = FALSE;
    BOOLEAN AnonymousScb = FALSE;
    PLOGON pLogon;
    PNDS_SECURITY_CONTEXT pNdsContext;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "CreateScb....\n", 0);

    //
    // Do not allow any SCB opens unless the redirector is running
    // unless they are no connect creates and we are waiting to bind.
    //

    if ( NwRcb.State != RCB_STATE_RUNNING ) {

        if ( ( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_NOCONNECT ) ||
             ( NwRcb.State != RCB_STATE_NEED_BIND ) ) ) {

            *Scb = NULL;
            DebugTrace( -1, Dbg, "CreateScb -> %08lx\n", STATUS_REDIRECTOR_NOT_STARTED );
            return STATUS_REDIRECTOR_NOT_STARTED;
        }
    }

    if ( UserName != NULL ) {
        DebugTrace( 0, Dbg, " ->UserName               = %wZ\n", UserName );
    } else {
        DebugTrace( 0, Dbg, " ->UserName               = NULL\n", 0 );
    }

    if ( Password != NULL ) {
        DebugTrace( 0, Dbg, " ->Password               = %wZ\n", Password );
    } else {
        DebugTrace( 0, Dbg, " ->Password               = NULL\n", 0 );
    }

    //
    // Get the SCB for this server.
    //

    Status = GetScb( &pScb,
                     pIrpContext,
                     Server,
                     pServerAddress,
                     UserName,
                     Password,
                     DeferLogon,
                     &ExistingScb );

    if ( !NT_SUCCESS( Status ) ) {
        *Scb = NULL;
        return Status;
    }

    //
    // At this point, we may or may not have an SCB.
    //
    // If we have an SCB, we know:
    //
    //     1. The scb is referenced.
    //     2. We are at the head of the queue.
    //
    // IMPORTANT POINT: The SCB may be anonymous.  If it is,
    // we do not hold the RCB, but rather we have to re-check
    // whether or not the server has shown up via a different
    // create when we find out who the anonymous server is.
    // We do this because there is a window where we have a
    // servers name but not its address and so our lookup by
    // address might be inaccurate.
    //

    if ( ( pScb ) && IS_ANONYMOUS_SCB( pScb ) ) {
        AnonymousScb = TRUE;
    }

    //
    // If we have a fully connected SCB, we need to go no further.
    //

    if ( ( pScb ) && ( pScb->pNpScb->State == SCB_STATE_IN_USE ) ) {

        ASSERT( !AnonymousScb );

        if ( ( pScb->MajorVersion >= 4 ) &&
             ( pScb->UserName.Buffer == NULL ) ) {

            //
            // This is an NDS authenticated server and we have
            // to make sure the credentials aren't locked for
            // logout.
            //

            NwAcquireExclusiveRcb( &NwRcb, TRUE );
            pLogon = FindUser( &pScb->UserUid, FALSE );
            NwReleaseRcb( &NwRcb );

            if ( pLogon ) {

                Status = NdsLookupCredentials( pIrpContext,
                                               &pScb->NdsTreeName,
                                               pLogon,
                                               &pNdsContext,
                                               CREDENTIAL_READ,
                                               FALSE );

                if ( NT_SUCCESS( Status ) ) {

                    if ( ( pNdsContext->Credential != NULL ) &&
                         ( pNdsContext->CredentialLocked == TRUE ) ) {

                        DebugTrace( 0, Dbg, "Denying create... we're logging out.\n", 0 );
                        Status = STATUS_DEVICE_BUSY;
                    }

                    NwReleaseCredList( pLogon, pIrpContext );
                }
            }
        }

        NwDequeueIrpContext( pIrpContext, FALSE );

        //
        // We must not change the irp context pointers if we're going
        // to fail this call or we may mess up ref counts and what not.
        //

        if ( NT_SUCCESS( Status ) ) {

           *Scb = pScb;

        } else {

           *Scb = NULL;
           NwDereferenceScb( pScb->pNpScb );

           pIrpContext->pNpScb = pOriginalNpScb;
           pIrpContext->pScb = pOriginalScb;

        }


        DebugTrace( -1, Dbg, "CreateScb: pScb = %08lx\n", pScb );
        return Status;
    }

    //
    // Run through the connect routines for this scb.  The scb may
    // be NULL if we're still looking for a nearby server.
    //

    Status = ConnectScb( &pScb,
                         pIrpContext,
                         Server,
                         pServerAddress,
                         UserName,
                         Password,
                         DeferLogon,
                         DeleteConnection,
                         ExistingScb );

    //
    // If ConnectScb fails, remove the extra ref count so
    // the scavenger will clean it up.  Anonymous failures
    // are also cleaned up by the scavenger.
    //

    if ( !NT_SUCCESS( Status ) ) {

        if ( pScb ) {
            NwDereferenceScb( pScb->pNpScb );
        }

        //
        // We must not change the irp context pointers if we're going
        // to fail this call or we may mess up ref counts and what not.
        //

        pIrpContext->pNpScb = pOriginalNpScb;
        pIrpContext->pScb = pOriginalScb;
        *Scb = NULL;

        DebugTrace( -1, Dbg, "CreateScb: Status = %08lx\n", Status );
        return Status;
    }

    //
    // If ConnectScb succeeds, then we must have an scb, the scb must
    // be in the IN_USE state (or LOGIN_REQUIRED if DeferLogon was
    // specified), it must be referenced, and we should not be on the
    // queue.
    //

    ASSERT( pScb );
    ASSERT( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) );
    ASSERT( pIrpContext->pNpScb == pScb->pNpScb );
    ASSERT( pIrpContext->pScb == pScb );
    ASSERT( pScb->pNpScb->Reference > 0 );

    *Scb = pScb;
    DebugTrace(-1, Dbg, "CreateScb -> pScb = %08lx\n", pScb );
    ASSERT( NT_SUCCESS( Status ) );

    return Status;
}
#define CTX_Retries 10

PNONPAGED_SCB
FindServer(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    PUNICODE_STRING ServerName
    )
/*++

Routine Description:

    This routine attempts to get the network address of a server.  If no
    servers are known, it first sends a find nearest SAP.

Arguments:

    pIrpContext - A pointer to the request parameters.

    pNpScb - A pointer to the non paged SCB for the server to get the
        address of.

Return Value:

    NONPAGED_SCB - A pointer the nonpaged SCB.  This is the same as the
        input value, unless the input SCB was NULL.  Then this is a
        pointer to the nearest server SCB.

    This routine raises status if it fails to get the server's address.

--*/
{
    NTSTATUS Status;
    ULONG Attempts;
    BOOLEAN FoundServer = FALSE;
    PNONPAGED_SCB pNearestNpScb = NULL;
    PNONPAGED_SCB pLastNpScb = NULL;

    BOOLEAN SentFindNearest = FALSE;
    BOOLEAN SentGeneral = FALSE;
    PMDL ReceiveMdl = NULL;
    PUCHAR ReceiveBuffer = NULL;
    IPXaddress  ServerAddress;

    BOOLEAN ConnectedToNearest = FALSE;
    BOOLEAN AllocatedIrpContext = FALSE;
    BOOLEAN LastScbWasValid;
    PIRP_CONTEXT pNewIrpContext;
    int ResponseCount;
    int NewServers;
    ULONG RetryCount = MAX_SAP_RETRIES;

    static LARGE_INTEGER TimeoutWait = {0,0};
    LARGE_INTEGER Now;

    PAGED_CODE();

    //
    //  If we had a SAP timeout less than 10 seconds ago, just fail this
    //  request immediately.  This allows dumb apps to exit a lot faster.
    //

    KeQuerySystemTime( &Now );
    if ( Now.QuadPart < TimeoutWait.QuadPart ) {
        ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
    }

    try {

        if (IsTerminalServer()) {
            // 
            // 1/31/97 cjc (Citrix code merge)
            //             Fix for Mellon Bank who restricted access based on the 
            //             preferred server the user logs into.  This caused a 
            //             problem for a user who tries to logon to a server that 
            //             the previous user doesn't have accesss to.  The previous 
            //             user's server is used to get the address of the current 
            //             logon user's preferred server but he can't see the new
            //             user's server.  Modifed this so it loops thru 10 servers
            //             rather than just the 1st 2 in the list.
            //
            RetryCount =CTX_Retries;
        }
        for ( Attempts = 0;  Attempts < RetryCount && !FoundServer ; Attempts++ ) {

            //
            //  If this SCB is now marked RECONNECT_REQUIRED, then
            //  it responded to the find nearest and we can immediately
            //  try to connect to it.
            //

            if ( pNpScb != NULL &&
                 pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {

                return pNpScb;
            }

            //
            //  Pick a server to use to find the address of the server that
            //  we are really interested in.
            //

            if (pLastNpScb) {

                //
                //  For some reason we couldn't use pNearestScb. Scan from this
                //  server onwards.
                //

                pNearestNpScb = SelectConnection( pLastNpScb );

                //  Allow pLastNpScb to be deleted.

                NwDereferenceScb( pLastNpScb );

                pLastNpScb = NULL;

                LastScbWasValid = TRUE;

            } else {

                pNearestNpScb = SelectConnection( NULL );
                LastScbWasValid = FALSE;

            }

            if ( pNearestNpScb == NULL ) {

                int i;

                if (LastScbWasValid) {
                    ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
                    return NULL;
                }
                //
                //  If we sent a find nearest, and still don't have a single
                //  entry in the server list, it's time to give up.
                //

                if (( SentFindNearest) &&
                    ( SentGeneral )) {

                    Error(
                        EVENT_NWRDR_NO_SERVER_ON_NETWORK,
                        STATUS_OBJECT_NAME_NOT_FOUND,
                        NULL,
                        0,
                        0 );

                    ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
                    return NULL;
                }

                //
                //  We don't have any active servers in the list.  Queue our
                //  IrpContext to the NwPermanentNpScb.  This insures that
                //  only one thread in the system in doing a find nearest at
                //  any one time.
                //

                DebugTrace( +0, Dbg, " Nearest Server\n", 0);

                if ( !AllocatedIrpContext ) {
                    AllocatedIrpContext = NwAllocateExtraIrpContext(
                                              &pNewIrpContext,
                                              &NwPermanentNpScb );

                    if ( !AllocatedIrpContext ) {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }
                }

                pNewIrpContext->pNpScb = &NwPermanentNpScb;

                //
                //  Allocate an extra buffer large enough for 4
                //  find nearest responses, or a general SAP response.
                //

                pNewIrpContext->Specific.Create.FindNearestResponseCount = 0;
                NewServers = 0;


                ReceiveBuffer = ALLOCATE_POOL_EX(
                                    NonPagedPool,
                                    MAX_SAP_RESPONSE_SIZE );

                pNewIrpContext->Specific.Create.FindNearestResponse[0] = ReceiveBuffer;

                for ( i = 1; i < MAX_SAP_RESPONSES ; i++ ) {
                    pNewIrpContext->Specific.Create.FindNearestResponse[i] =
                        ReceiveBuffer + i * SAP_RECORD_SIZE;
                }

                //
                //  Get the tick count for this net, so that we know how
                //  long to wait for SAP responses.
                //

                (VOID)GetTickCount( pNewIrpContext, &NwPermanentNpScb.TickCount );
                NwPermanentNpScb.SendTimeout = NwPermanentNpScb.TickCount + 10;

                if (!SentFindNearest) {

                    //
                    //  Send a find nearest SAP, and wait for up to several
                    //  responses. This allows us to handle a busy server
                    //  that responds quickly to SAPs but will not accept
                    //  connections.
                    //

                    Status = ExchangeWithWait (
                                pNewIrpContext,
                                ProcessFindNearest,
                                "Aww",
                                SAP_FIND_NEAREST,
                                SAP_SERVICE_TYPE_SERVER );

                    if ( Status == STATUS_NETWORK_UNREACHABLE ) {
                       
                        //
                        // IPX is not bound to anything that is currently
                        // up (which means it's probably bound only to the
                        // RAS WAN wrapper).  Don't waste 20 seconds trying
                        // to find a server.
                        //
                        
                        DebugTrace( 0, Dbg, "Aborting FindNearest.  No Net.\n", 0 );
                        NwDequeueIrpContext( pNewIrpContext, FALSE );
                        ExRaiseStatus( STATUS_NETWORK_UNREACHABLE );
                    }

                    //
                    //  Process the set of find nearest responses.
                    //

                    for (i = 0; i < (int)pNewIrpContext->Specific.Create.FindNearestResponseCount; i++ ) {
                        if (ProcessFindNearestEntry(
                                pNewIrpContext,
                                (PSAP_FIND_NEAREST_RESPONSE)pNewIrpContext->Specific.Create.FindNearestResponse[i] )
                            ) {

                            //
                            //  We found a server that was previously unknown.
                            //

                            NewServers++;
                        }
                    }
                }

                if (( !NewServers ) &&
                    ( !SentGeneral)){

                    SentGeneral = TRUE;

                    //
                    //  Either no SAP responses or can't connect to nearest servers.
                    //  Try a general SAP.
                    //

                    ReceiveMdl = ALLOCATE_MDL(
                                     ReceiveBuffer,
                                     MAX_SAP_RESPONSE_SIZE,
                                     TRUE,
                                     FALSE,
                                     NULL );

                    if ( ReceiveMdl == NULL ) {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }

                    MmBuildMdlForNonPagedPool( ReceiveMdl );
                    pNewIrpContext->RxMdl->Next = ReceiveMdl;

                    Status = ExchangeWithWait (
                                 pNewIrpContext,
                                 SynchronousResponseCallback,
                                 "Aww",
                                 SAP_GENERAL_REQUEST,
                                 SAP_SERVICE_TYPE_SERVER );

                    if ( NT_SUCCESS( Status ) ) {
                        DebugTrace( 0, Dbg, "Received %d bytes\n", pNewIrpContext->ResponseLength );
                        ResponseCount = ( pNewIrpContext->ResponseLength - 2 ) / SAP_RECORD_SIZE;

                        //
                        //  Process at most MAX_SAP_RESPONSES servers.
                        //

                        if ( ResponseCount > MAX_SAP_RESPONSES ) {
                            ResponseCount = MAX_SAP_RESPONSES;
                        }

                        for ( i = 0; i < ResponseCount; i++ ) {
                            ProcessFindNearestEntry(
                                pNewIrpContext,
                                (PSAP_FIND_NEAREST_RESPONSE)(pNewIrpContext->rsp + SAP_RECORD_SIZE * i)  );
                        }
                    }

                    pNewIrpContext->RxMdl->Next = NULL;
                    FREE_MDL( ReceiveMdl );
                    ReceiveMdl = NULL;
                }

                //
                //  We're done with the find nearest.  Free the buffer and
                //  dequeue from the permanent SCB.
                //

                FREE_POOL( ReceiveBuffer );
                ReceiveBuffer = NULL;
                NwDequeueIrpContext( pNewIrpContext, FALSE );

                if ( !NT_SUCCESS( Status ) &&
                     pNewIrpContext->Specific.Create.FindNearestResponseCount == 0 ) {

                    //
                    //  If the SAP timed out, map the error for MPR.
                    //

                    if ( Status == STATUS_REMOTE_NOT_LISTENING ) {
                        Status = STATUS_BAD_NETWORK_PATH;
                    }

                    //
                    //  Setup the WaitTimeout, and fail this request.
                    //

                    KeQuerySystemTime( &TimeoutWait );
                    TimeoutWait.QuadPart += NwOneSecond * 10;

                    ExRaiseStatus( Status );
                    return NULL;
                }

                SentFindNearest = TRUE;

            } else {

                if ( !AllocatedIrpContext ) {
                    AllocatedIrpContext = NwAllocateExtraIrpContext(
                                              &pNewIrpContext,
                                              pNearestNpScb );

                    if ( !AllocatedIrpContext ) {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }
                }

                //
                //  Point the IRP context at the nearest server.
                //

                pNewIrpContext->pNpScb = pNearestNpScb;
                NwAppendToQueueAndWait( pNewIrpContext );

                if ( pNearestNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {

                    //
                    //  We have no connection to this server, try to
                    //  connect now.  This is not a valid path for an
                    //  anonymous create, so there's no chance that
                    //  there will be a name collision.
                    //

                    Status = ConnectToServer( pNewIrpContext, NULL );
                    if ( !NT_SUCCESS( Status ) ) {

                        //
                        //  Failed to connect to the server.  Give up.
                        //  We'll try another server.
                        //

                        NwDequeueIrpContext( pNewIrpContext, FALSE );

                        //  Keep pNearestScb referenced
                        //  so it doesn't disappear.

                        pLastNpScb = pNearestNpScb;

                        continue;

                    } else {

                        pNearestNpScb->State = SCB_STATE_LOGIN_REQUIRED;
                        ConnectedToNearest = TRUE;

                    }
                }

                //
                // update the last used time for this SCB.
                //

                KeQuerySystemTime( &pNearestNpScb->LastUsedTime );

                if (( pNpScb == NULL ) ||
                    ( ServerName == NULL )) {

                    //
                    //  We're looking for any server so use this one.
                    //
                    //  We'll exit the for loop on the SCB queue,
                    //  and with this SCB referenced.
                    //

                    pNpScb = pNearestNpScb;
                    Status = STATUS_SUCCESS;
                    FoundServer = TRUE;
                    NwDequeueIrpContext( pNewIrpContext, FALSE );

                } else {

                    Status = QueryServersAddress(
                                 pNewIrpContext,
                                 pNearestNpScb,
                                 ServerName,
                                 &ServerAddress );

                    //
                    //  If we connect to this server just to query it's
                    //  bindery, disconnect now.
                    //

                    if (IsTerminalServer()) {
                        if (ConnectedToNearest) {

                            ExchangeWithWait (
                                             pNewIrpContext,
                                             SynchronousResponseCallback,
                                             "D-" );          // Disconnect
                            ConnectedToNearest = FALSE;
                            Stats.Sessions--;

                            if ( pNearestNpScb->MajorVersion == 2 ) {
                                Stats.NW2xConnects--;
                            } else if ( pNearestNpScb->MajorVersion == 3 ) {
                                Stats.NW3xConnects--;
                            } else if ( pNearestNpScb->MajorVersion == 4 ) {
                                Stats.NW4xConnects--;
                            }
                            pNearestNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

                        }
                    } else {

                        if ( ConnectedToNearest && NT_SUCCESS(Status) ) {

                            ExchangeWithWait (
                                             pNewIrpContext,
                                             SynchronousResponseCallback,
                                             "D-" );          // Disconnect

                            pNearestNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
                        }
                    }

                    if ( NT_SUCCESS( Status ) ) {

                        //
                        //  Success!
                        //
                        //  Point the SCB at the real server address and connect to it,
                        //  then logout.  (We logout for no apparent reason except
                        //  because this is what a netware redir does.)
                        //

                        RtlCopyMemory(
                            &pNpScb->ServerAddress,
                            &ServerAddress,
                            sizeof( TDI_ADDRESS_IPX ) );

                        if ( ServerAddress.Socket != NCP_SOCKET ) {
                            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "FindServer server socket is deviant.\n", 0 );
                        }

                        BuildIpxAddress(
                            ServerAddress.Net,
                            ServerAddress.Node,
                            ServerAddress.Socket,
                            &pNpScb->RemoteAddress );

                        FoundServer = TRUE;

                        NwDequeueIrpContext( pNewIrpContext, FALSE );
                        NwDereferenceScb( pNearestNpScb );

                        pNewIrpContext->pNpScb = pNpScb;
                        pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

                    } else {

                        NwDequeueIrpContext( pNewIrpContext, FALSE );

                        if ( (Status == STATUS_REMOTE_NOT_LISTENING ) ||
                             (Status == STATUS_BAD_NETWORK_PATH)) {

                            //
                            //  This server is no longer talking to us.
                            //  Try again. Keep pNearestScb referenced
                            //  so it doesn't disappear.
                            //

                            pLastNpScb = pNearestNpScb;

                            continue;

                        } else {

                            NwDereferenceScb( pNearestNpScb );

                            //
                            //  This nearest server doesn't know about
                            //  the server we are looking for. Give up
                            //  and let another rdr try.
                            //

                            ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
                            return NULL;
                        }
                    }
                }

            } // else
        } // for

    } finally {

        if ( ReceiveBuffer != NULL ) {
            FREE_POOL( ReceiveBuffer );
        }

        if ( ReceiveMdl != NULL ) {
            FREE_MDL( ReceiveMdl );
        }

        if ( AllocatedIrpContext ) {
            NwDequeueIrpContext( pNewIrpContext, FALSE );
            NwFreeExtraIrpContext( pNewIrpContext );
        }

        if (IsTerminalServer()) {
            if ( (Attempts == CTX_Retries) && pLastNpScb) {
                NwDereferenceScb( pLastNpScb );
            }
        } else {
            if (pLastNpScb) {
                NwDereferenceScb( pLastNpScb );
            }
        }

    }

    if ( !FoundServer ) {
        ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
    }

    return pNpScb;
}


NTSTATUS
ProcessFindNearest(
    IN struct _IRP_CONTEXT* pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine takes the full address of the remote server and builds
    the corresponding TA_IPX_ADDRESS.

Arguments:


Return Value:


--*/

{
    ULONG ResponseCount;
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "ProcessFindNearest...\n", 0);

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    if ( BytesAvailable == 0) {

        //
        //   Timeout.
        //

        pIrpContext->ResponseParameters.Error = 0;
        pIrpContext->pNpScb->OkToReceive = FALSE;

        ASSERT( pIrpContext->Event.Header.SignalState == 0 );
#if NWDBG
        pIrpContext->DebugValue = 0x101;
#endif
        NwSetIrpContextEvent( pIrpContext );
        DebugTrace(-1, Dbg, "ProcessFindNearest -> %08lx\n", STATUS_REMOTE_NOT_LISTENING);
        KeReleaseSpinLock( &ScbSpinLock, OldIrql );
        return STATUS_REMOTE_NOT_LISTENING;
    }

    if ( BytesAvailable >= FIND_NEAREST_RESP_SIZE &&
         Response[0] == 0 &&
         Response[1] == SAP_SERVICE_TYPE_SERVER ) {

        //
        //  This is a valid find nearest response.  Process the packet.
        //

        ResponseCount = pIrpContext->Specific.Create.FindNearestResponseCount++;
        ASSERT( ResponseCount < MAX_SAP_RESPONSES );

        //
        //  Copy the Find Nearest server response to the receive buffer.
        //

        RtlCopyMemory(
            pIrpContext->Specific.Create.FindNearestResponse[ResponseCount],
            Response,
            FIND_NEAREST_RESP_SIZE );

        //
        //  If we have reached critical mass on the number of find
        //  nearest responses, set the event to indicate that we
        //  are done.
        //

        if ( ResponseCount == MAX_SAP_RESPONSES - 1 ) {

            ASSERT( pIrpContext->Event.Header.SignalState == 0 );
#ifdef NWDBG
            pIrpContext->DebugValue = 0x102;
#endif
            pIrpContext->ResponseParameters.Error = 0;
            NwSetIrpContextEvent( pIrpContext );

        } else {
            pIrpContext->pNpScb->OkToReceive = TRUE;
        }

    } else {

        //
        //  Discard the invalid find nearest response.
        //

        pIrpContext->pNpScb->OkToReceive = TRUE;
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    DebugTrace(-1, Dbg, "ProcessFindNearest -> %08lx\n", STATUS_SUCCESS );
    return( STATUS_SUCCESS );
}

BOOLEAN
ProcessFindNearestEntry(
    PIRP_CONTEXT IrpContext,
    PSAP_FIND_NEAREST_RESPONSE FindNearestResponse
    )
{
    OEM_STRING OemServerName;
    UNICODE_STRING UidServerName;
    UNICODE_STRING ServerName;
    NTSTATUS Status;
    PSCB pScb;
    PNONPAGED_SCB pNpScb = NULL;
    BOOLEAN ExistingScb = TRUE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "ProcessFindNearestEntry\n", 0);

    ServerName.Buffer = NULL;
    UidServerName.Buffer = NULL;

    try {

        RtlInitString( &OemServerName, FindNearestResponse->ServerName );
        ASSERT( OemServerName.Length < MAX_SERVER_NAME_LENGTH * sizeof( WCHAR ) );

        Status = RtlOemStringToCountedUnicodeString(
                     &ServerName,
                     &OemServerName,
                     TRUE );

        if ( !NT_SUCCESS( Status ) ) {
            try_return( NOTHING );
        }

        //
        //  Lookup of the SCB by name.  If it is not found, an SCB
        //  will be created.
        //

        Status = MakeUidServer(
                        &UidServerName,
                        &IrpContext->Specific.Create.UserUid,
                        &ServerName );

        if (!NT_SUCCESS(Status)) {
            try_return( NOTHING );
        }

        ExistingScb = NwFindScb( &pScb, IrpContext, &UidServerName, &ServerName );
        ASSERT( pScb != NULL );
        pNpScb = pScb->pNpScb;

        //
        //  Copy the network address to the SCB, and calculate the
        //  IPX address.
        //

        RtlCopyMemory(
            &pNpScb->ServerAddress,
            &FindNearestResponse->Network,
            sizeof( TDI_ADDRESS_IPX )  );

        if ( pNpScb->ServerAddress.Socket != NCP_SOCKET ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "FindNearest server socket is deviant.\n", 0 );
        }

        BuildIpxAddress(
            pNpScb->ServerAddress.Net,
            pNpScb->ServerAddress.Node,
            pNpScb->ServerAddress.Socket,
            &pNpScb->RemoteAddress );

        if ( pNpScb->State == SCB_STATE_ATTACHING ) {

            //
            //  We are in the process of trying to connect to this
            //  server so mark it reconnect required so that
            //  CreateScb will know that we've found it address.
            //

            pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
        }

try_exit: NOTHING;

    } finally {

        if ( pNpScb != NULL ) {
            NwDereferenceScb( pNpScb );
        }

        if (UidServerName.Buffer != NULL) {
            FREE_POOL(UidServerName.Buffer);
        }

        RtlFreeUnicodeString( &ServerName );
    }

    //
    //  Tell the caller if we created a new Scb
    //


    if (ExistingScb) {
        DebugTrace(-1, Dbg, "ProcessFindNearestEntry ->%08lx\n", FALSE );
        return FALSE;
    } else {
        DebugTrace(-1, Dbg, "ProcessFindNearestEntry ->%08lx\n", TRUE );
        return TRUE;
    }
}


NTSTATUS
ConnectToServer(
    IN struct _IRP_CONTEXT* pIrpContext,
    OUT PSCB *pScbCollision
    )
/*++

Routine Description:

    This routine transfers connect and negotiate buffer NCPs to the server.

    This routine may be called upon to connect an anonymous scb.  Upon
    learning the name of the anonymous scb, it will determine if another
    create has completed while the name lookup was in progress.  If it has,
    then the routine will refer the called to that new scb.  Otherwise, the
    scb will be entered onto the scb list and used normally.  The RCB
    protects the scb list by name only.  For more info, see the comment
    in CreateScb().

Arguments:

    pIrpContext - supplies context and server information

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status, BurstStatus;
    PNONPAGED_SCB pNpScb = pIrpContext->pNpScb;
    PSCB pScb = pNpScb->pScb;
    BOOLEAN AnonymousScb = IS_ANONYMOUS_SCB( pScb );
    ULONG MaxSafeSize ;
    BOOLEAN LIPNegotiated ;
    PLOGON Logon;

    OEM_STRING OemServerName;
    UNICODE_STRING ServerName;
    UNICODE_STRING CredentialName;
    PUNICODE_STRING puConnectName;
    BYTE OemName[MAX_SERVER_NAME_LENGTH];
    WCHAR Server[MAX_SERVER_NAME_LENGTH];
    KIRQL OldIrql;
    UNICODE_STRING UidServerName;
    BOOLEAN Success;
    PLIST_ENTRY ScbQueueEntry;
    PUNICODE_PREFIX_TABLE_ENTRY PrefixEntry;

    PAGED_CODE();

    DebugTrace( +0, Dbg, " Connect\n", 0);

    RtlInitUnicodeString( &CredentialName, NULL );

    //
    //  Get the tick count for our connection to this server
    //

    Status = GetTickCount( pIrpContext, &pNpScb->TickCount );

    if ( !NT_SUCCESS( Status ) ) {
        pNpScb->TickCount = DEFAULT_TICK_COUNT;
    }

    pNpScb->SendTimeout = pNpScb->TickCount + 10;

    //
    //  Initialize timers for a server that supports burst but not LIP
    //

    pNpScb->NwLoopTime = pNpScb->NwSingleBurstPacketTime = pNpScb->SendTimeout;
    pNpScb->NwReceiveDelay = pNpScb->NwSendDelay = 0;

    pNpScb->NtSendDelay.QuadPart = 0;

    //
    //  Request connection
    //

    Status = ExchangeWithWait (
                 pIrpContext,
                 SynchronousResponseCallback,
                 "C-");

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    if (!NT_SUCCESS(Status)) {
        if ( Status == STATUS_UNSUCCESSFUL ) {
#ifdef QFE_BUILD
            Status = STATUS_TOO_MANY_SESSIONS;
#else
            Status = STATUS_REMOTE_SESSION_LIMIT;
#endif
            pNpScb->State = SCB_STATE_ATTACHING;

        } else if ( Status == STATUS_REMOTE_NOT_LISTENING ) {

            //
            //  The connect timed out, suspect that the server is down
            //  and put it back in the attaching state.
            //

            pNpScb->State = SCB_STATE_ATTACHING;
        }

        goto ExitWithStatus;
    }

    pNpScb->SequenceNo++;

    Stats.Sessions++;

    //
    //  Get server information
    //

    DebugTrace( +0, Dbg, "Get file server information\n", 0);

    Status = ExchangeWithWait (  pIrpContext,
                SynchronousResponseCallback,
                "S",
                NCP_ADMIN_FUNCTION, NCP_GET_SERVER_INFO );

    if ( NT_SUCCESS( Status ) ) {
        Status = ParseResponse( pIrpContext,
                                pIrpContext->rsp,
                                pIrpContext->ResponseLength,
                                "Nrbb",
                                OemName,
                                MAX_SERVER_NAME_LENGTH,
                                &pScb->MajorVersion,
                                &pScb->MinorVersion );
    }

    pNpScb->MajorVersion = pScb->MajorVersion;

    if (!NT_SUCCESS(Status)) {
        goto ExitWithStatus;
    }

    //
    // If this was an anonymous SCB, we need to check the name
    // for a create collision before we do anything else.
    //

    if ( AnonymousScb ) {

        //
        // Grab the RCB to protect the server prefix table.  We've
        // spent the time sending the packet to look up the server
        // name so we are a little greedy with the RCB to help
        // minimize the chance of a collision.
        //

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        // Make the uid server name.
        //

        OemServerName.Buffer = OemName;
        OemServerName.Length = 0;
        OemServerName.MaximumLength = sizeof( OemName );

        while ( ( OemServerName.Length < MAX_SERVER_NAME_LENGTH ) &&
                ( OemName[OemServerName.Length] != '\0' ) ) {
            OemServerName.Length++;
        }

        ServerName.Buffer = Server;
        ServerName.MaximumLength = sizeof( Server );
        ServerName.Length = 0;

        RtlOemStringToUnicodeString( &ServerName,
                                     &OemServerName,
                                     FALSE );

        //
        // If this is an extended credential create, munge the server name.
        //

        if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

            Status = BuildExCredentialServerName( &ServerName,
                                                  pIrpContext->Specific.Create.puCredentialName,
                                                  &CredentialName );

            if ( !NT_SUCCESS( Status ) ) {
                NwReleaseRcb( &NwRcb );
                goto ExitWithStatus;
            }

            puConnectName = &CredentialName;

        } else {

            puConnectName = &ServerName;
        }

        //
        // Tack on the uid.
        //

        Status = MakeUidServer( &UidServerName,
                                &pScb->UserUid,
                                puConnectName );

        if ( !NT_SUCCESS( Status ) ) {
            NwReleaseRcb( &NwRcb );
            goto ExitWithStatus;
        }

        //
        // Actually do the look up in the prefix table.
        //

        PrefixEntry = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, &UidServerName, 0 );

        if ( PrefixEntry != NULL ) {

            //
            // There was a collision with this anonymous create.  Dump
            // the anonymous scb and pick up the new one.
            //

            NwReleaseRcb( &NwRcb );
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Anonymous create collided for %wZ.\n", &UidServerName );

            //
            // Disconnect this connection so we don't clutter the server.
            //

            ExchangeWithWait ( pIrpContext,
                               SynchronousResponseCallback,
                               "D-" );

            FREE_POOL( UidServerName.Buffer );

            //
            // Since there was a collision, we know for a fact that there's another
            // good SCB for this server somewhere.  We set the state on this anonymous
            // SCB to SCB_STATE_FLAG_SHUTDOWN so that no one ever plays with the
            // anonymous SCB again.  The scavenger will clean it up soon.
            //

            pNpScb->State = SCB_STATE_FLAG_SHUTDOWN;

            if ( pScbCollision ) {
                *pScbCollision = CONTAINING_RECORD( PrefixEntry, SCB, PrefixEntry );
                NwReferenceScb( (*pScbCollision)->pNpScb );
                Status = STATUS_SUCCESS;
                goto ExitWithStatus;
            } else {
                 DebugTrace( 0, Dbg, "Invalid path for an anonymous create.\n", 0 );
                 Status = STATUS_INVALID_PARAMETER;
                 goto ExitWithStatus;
            }

        }

        //
        // This anonymous create didn't collide - cool!  Fill in the server
        // name, check the preferred, server setting, and put the SCB on the
        // SCB queue in the correct location.  This code is similar to pieces
        // of code in NwAllocateAndInitScb() and NwFindScb().
        //

        DebugTrace( 0, Dbg, "Completing anonymous create for %wZ!\n", &UidServerName );

        RtlCopyUnicodeString ( &pScb->UidServerName, &UidServerName );
        pScb->UidServerName.Buffer[ UidServerName.Length / sizeof( WCHAR ) ] = L'\0';

        pScb->UnicodeUid = pScb->UidServerName;
        pScb->UnicodeUid.Length = UidServerName.Length -
                                  puConnectName->Length -
                                  sizeof(WCHAR);

        //
        //  Make ServerName point partway down the buffer for UidServerName
        //

        pNpScb->ServerName.Buffer = (PWSTR)((PUCHAR)pScb->UidServerName.Buffer +
                                    UidServerName.Length - puConnectName->Length);

        pNpScb->ServerName.MaximumLength = puConnectName->Length;
        pNpScb->ServerName.Length = puConnectName->Length;

        //
        // Determine if this is our preferred server.
        //

        Logon = FindUser( &pScb->UserUid, FALSE );

        if (( Logon != NULL) &&
            (RtlCompareUnicodeString( puConnectName, &Logon->ServerName, TRUE ) == 0 )) {
           pScb->PreferredServer = TRUE;
           NwReferenceScb( pNpScb );
        }

        FREE_POOL( UidServerName.Buffer );

        //
        //  Insert the name of this server into the prefix table.
        //

        Success = RtlInsertUnicodePrefix( &NwRcb.ServerNameTable,
                                          &pScb->UidServerName,
                                          &pScb->PrefixEntry );

#ifdef NWDBG
        if ( !Success ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Entering duplicate SCB %wZ.\n", &pScb->UidServerName );
            DbgBreakPoint();
        }
#endif

        //
        // This create is complete, release the RCB.
        //

        NwReleaseRcb( &NwRcb );

        //
        // If this is our preferred server, we have to move this guy
        // to the head of the scb list.  We do this after the create
        // because we can't acquire the ScbSpinLock while holding the
        // RCB.
        //

        if ( pScb->PreferredServer ) {

            KeAcquireSpinLock(&ScbSpinLock, &OldIrql);
            RemoveEntryList( &pNpScb->ScbLinks );
            InsertHeadList( &ScbQueue, &pNpScb->ScbLinks );
            KeReleaseSpinLock( &ScbSpinLock, OldIrql );
        }

    }

    if ( pScb->MajorVersion == 2 ) {

        Stats.NW2xConnects++;
        pNpScb->PageAlign = TRUE;

    } else if ( pScb->MajorVersion == 3 ) {

        Stats.NW3xConnects++;

        if (pScb->MinorVersion > 0xb) {
            pNpScb->PageAlign = FALSE;
        } else {
            pNpScb->PageAlign = TRUE;
        }

    } else if ( pScb->MajorVersion >= 4 ) {

        Stats.NW4xConnects++;
        pNpScb->PageAlign = FALSE;

        NdsPing( pIrpContext, pScb );

    }

    //
    //  Get the local net max packet size.  This is the max frame size
    //  does not include space for IPX or lower level headers.
    //

    Status = GetMaximumPacketSize( pIrpContext, &pNpScb->Server, &pNpScb->MaxPacketSize );

    //
    //  If the transport won't tell us, pick the largest size that
    //  is guaranteed to work.
    //
    if ( !NT_SUCCESS( Status ) ) {
        pNpScb->BufferSize = DEFAULT_PACKET_SIZE;
        pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;
    } else {
        pNpScb->BufferSize = (USHORT)pNpScb->MaxPacketSize;
    }
    MaxSafeSize = pNpScb->MaxPacketSize ;

    //
    //  Negotiate a burst mode connection. Keep track of that status.
    //

    Status = NegotiateBurstMode( pIrpContext, pNpScb, &LIPNegotiated );
    BurstStatus = Status ;

    if (!NT_SUCCESS(Status) || !LIPNegotiated) {

        //
        //  Negotiate buffer size with server if we didnt do burst
        //  sucessfully or if burst succeeded but we didnt do LIP.
        //

        DebugTrace( +0, Dbg, "Negotiate Buffer Size\n", 0);

        Status = ExchangeWithWait (  pIrpContext,
                    SynchronousResponseCallback,
                    "Fw",
                    NCP_NEGOTIATE_BUFFER_SIZE,
                    pNpScb->BufferSize );

        DebugTrace( +0, Dbg, "                 %X\n", Status);
        DebugTrace( +0, Dbg, " Parse response\n", 0);

        if ( NT_SUCCESS( Status ) ) {
            Status = ParseResponse( pIrpContext,
                                    pIrpContext->rsp,
                                    pIrpContext->ResponseLength,
                                    "Nw",
                                    &pNpScb->BufferSize );

            //
            // Dont allow the server to fool us into using a
            // packet size bigger than what the media can support.
            // We have at least one case of server returning 4K while
            // on ethernet.
            //
            // Use PacketThreshold so that the PacketAdjustment can be
            // avoided on small packet sizes such as those on ethernet.
            //

            if (MaxSafeSize > (ULONG)PacketThreshold) {
                MaxSafeSize -= (ULONG)LargePacketAdjustment;
            }

            //
            // If larger than number we got from transport, taking in account
            // IPX header (30) & NCP header (BURST_RESPONSE is a good worst
            // case), we adjust accordingly.
            //
            if (pNpScb->BufferSize >
                    (MaxSafeSize - (30 + sizeof(NCP_BURST_READ_RESPONSE))))
            {
                pNpScb->BufferSize = (USHORT)
                    (MaxSafeSize - (30 + sizeof(NCP_BURST_READ_RESPONSE))) ;
            }

            //
            //  An SFT III server responded with a BufferSize of 0!
            //

            pNpScb->BufferSize = MAX(pNpScb->BufferSize,DEFAULT_PACKET_SIZE);

            //
            // If an explicit registry default was set, we honour that.
            // Note that this only applies in the 'default' case, ie. we
            // didnt negotiate LIP successfully. Typically, we dont
            // expect to use this, because the server will drop to 512 if
            // it finds routers in between. But if for some reason the server
            // came back with a number that was higher than what some router
            // in between can take, we have this as manual override.
            //

            if (DefaultMaxPacketSize != 0)
            {
                pNpScb->BufferSize = MIN (pNpScb->BufferSize,
                                          (USHORT)DefaultMaxPacketSize) ;
            }
        }

        if (NT_SUCCESS(BurstStatus)) {
            //
            // We negotiated burst but not LIP. Save the packet size we
            // have from above and renegotiate the burst so that the
            // server knows how much it can send to us. And then take
            // the minimum of the two to make sure we are safe.
            //
            USHORT SavedPacketSize =  pNpScb->BufferSize ;

            Status = NegotiateBurstMode( pIrpContext, pNpScb, &LIPNegotiated );

            pNpScb->BufferSize = MIN(pNpScb->BufferSize,SavedPacketSize) ;
        }
    }

ExitWithStatus:

    if ( CredentialName.Buffer ) {
        FREE_POOL( CredentialName.Buffer );
    }

    return Status;
}


NTSTATUS
NegotiateBurstMode(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    BOOLEAN *LIPNegotiated
    )
/*++

Routine Description:

    This routine negotiates a burst mode connection with the specified
    server.

Arguments:

    pIrpContext - Supplies context and server information.

    pNpScb - A pointer to the NONPAGED_SCB for the server we are
        negotiating with.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    *LIPNegotiated = FALSE ;

    if (pNpScb->MaxPacketSize == DEFAULT_PACKET_SIZE) {
        return STATUS_NOT_SUPPORTED;
    }

    if ( NwBurstModeEnabled ) {

        pNpScb->BurstRenegotiateReqd = TRUE;

        pNpScb->SourceConnectionId = rand();
        pNpScb->MaxSendSize = NwMaxSendSize;
        pNpScb->MaxReceiveSize = NwMaxReceiveSize;
        pNpScb->BurstSequenceNo = 0;
        pNpScb->BurstRequestNo = 0;

        Status = ExchangeWithWait(
                     pIrpContext,
                     SynchronousResponseCallback,
                     "FDdWdd",
                     NCP_NEGOTIATE_BURST_CONNECTION,
                     pNpScb->SourceConnectionId,
                     pNpScb->BufferSize,
                     pNpScb->Burst.Socket,
                     pNpScb->MaxSendSize,
                     pNpScb->MaxReceiveSize );

        if ( NT_SUCCESS( Status )) {
            Status = ParseResponse(
                         pIrpContext,
                         pIrpContext->rsp,
                         pIrpContext->ResponseLength,
                         "Ned",
                         &pNpScb->DestinationConnectionId,
                         &pNpScb->MaxPacketSize );

            if (pNpScb->MaxPacketSize <= DEFAULT_PACKET_SIZE) {
                pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;
            }
        }

        if ( NT_SUCCESS( Status )) {

            if (NT_SUCCESS(GetMaxPacketSize( pIrpContext, pNpScb ))) {
                *LIPNegotiated = TRUE ;
            }

            pNpScb->SendBurstModeEnabled = TRUE;
            pNpScb->ReceiveBurstModeEnabled = TRUE;

            //
            //  Use this size as the max read and write size instead of
            //  negotiating. This is what the VLM client does and is
            //  important because the negotiate will give a smaller value.
            //

            pNpScb->BufferSize = (USHORT)pNpScb->MaxPacketSize;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_SUPPORTED;
}



VOID
RenegotiateBurstMode(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    This routine renegotiates a burst mode connection with the specified
    server.   I don't know why we need this but it seems to be required
    by Netware latest burst implementation.

Arguments:

    pIrpContext - Supplies context and server information.

    pNpScb - A pointer to the NONPAGED_SCB for the server we are
        negotiating with.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( 0, DEBUG_TRACE_LIP, "Re-negotiating burst mode.\n", 0);

    pNpScb->SourceConnectionId = rand();
    pNpScb->MaxSendSize = NwMaxSendSize;
    pNpScb->MaxReceiveSize = NwMaxReceiveSize;
    pNpScb->BurstSequenceNo = 0;
    pNpScb->BurstRequestNo = 0;

    Status = ExchangeWithWait(
                 pIrpContext,
                 SynchronousResponseCallback,
                 "FDdWdd",
                 NCP_NEGOTIATE_BURST_CONNECTION,
                 pNpScb->SourceConnectionId,
                 pNpScb->MaxPacketSize,
                 pNpScb->Burst.Socket,
                 pNpScb->MaxSendSize,
                 pNpScb->MaxReceiveSize );

    if ( NT_SUCCESS( Status )) {
        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "Ned",
                     &pNpScb->DestinationConnectionId,
                     &pNpScb->MaxPacketSize );

        //
        //  Randomly downgrade the max burst size, because that is what
        //  the netware server does, and the new burst NLM requires.
        //

        pNpScb->MaxPacketSize -= 66;

    }

    if ( !NT_SUCCESS( Status ) ||
         (pNpScb->MaxPacketSize <= DEFAULT_PACKET_SIZE)) {

        pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;
        pNpScb->SendBurstModeEnabled = FALSE;
        pNpScb->ReceiveBurstModeEnabled = FALSE;

    } else {

        //
        //  Use this size as the max read and write size instead of
        //  negotiating. This is what the VLM client does and is
        //  important because the negotiate will give a smaller value.
        //

        pNpScb->BufferSize = (USHORT)pNpScb->MaxPacketSize;

    }
}


NTSTATUS
GetMaxPacketSize(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    This routine attempts to use the LIP protocol to find the true MTU of
    the network.

Arguments:

    pIrpContext - Supplies context and server information.

    pNpScb - A pointer to the NONPAGED_SCB for the server we are '
        negotiating with.

Return Value:

    None.

--*/
{
    PUSHORT Buffer = NULL;
    USHORT value;
    int index;
    PMDL PartialMdl = NULL, FullMdl = NULL;
    PMDL ReceiveMdl;
    NTSTATUS Status;
    USHORT EchoSocket, LipPacketSize = 0;
    int MinPacketSize, MaxPacketSize, CurrentPacketSize;
    ULONG RxMdlLength = MdlLength(pIrpContext->RxMdl);  //  Save so we can restore it on exit.

    BOOLEAN SecondTime = FALSE;
    LARGE_INTEGER StartTime, Now, FirstPing, SecondPing, temp;

    PAGED_CODE();

    DebugTrace( +1, DEBUG_TRACE_LIP, "GetMaxPacketSize...\n", 0);

    //
    //  Negotiate LIP, attempt to negotiate a buffer of full network
    //  size.
    //

    Status = ExchangeWithWait(
                 pIrpContext,
                 SynchronousResponseCallback,
                 "Fwb",
                 NCP_NEGOTIATE_LIP_CONNECTION,
                 pNpScb->BufferSize,
                 0 );  // Flags

    if ( NT_SUCCESS( Status )) {
        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "Nwx",
                     &LipPacketSize,
                     &EchoSocket );
    }

      //
      //  Speedup RAS
      //

      MaxPacketSize = (int) LipPacketSize - LipPacketAdjustment ;

    if (( !NT_SUCCESS( Status )) ||
        ( MaxPacketSize <= DEFAULT_PACKET_SIZE ) ||
        ( EchoSocket == 0 )) {

        //
        //  The server does not support LIP.
        //  Portable NW gives no error but socket 0.
        //  We have a report of a 3.11 server returning MaxPacketSize 0
        //

        return STATUS_NOT_SUPPORTED;
    }

    //
    // Account for the IPX header, which is not counted in
    // the reported packet size.  This causes problems for
    // servers with poorly written net card drivers that
    // abend when they get an oversize packet.
    //
    // This was reported by Richard Florance (richfl).
    //

    MaxPacketSize -= 30;

    pNpScb->EchoCounter = MaxPacketSize;

    //
    //  We will use the Echo address for the LIP protocol.
    //

    BuildIpxAddress(
        pNpScb->ServerAddress.Net,
        pNpScb->ServerAddress.Node,
        EchoSocket,
        &pNpScb->EchoAddress );

    try {

        Buffer = ALLOCATE_POOL_EX( NonPagedPool, MaxPacketSize );

        //
        //  Avoid RAS compression algorithm from making the large and small
        //  buffers the same length since we want to see the difference in
        //  transmission times.
        //

        for (index = 0, value = 0; index < MaxPacketSize/2; index++, value++) {
            Buffer[index] = value;
        }

        FullMdl = ALLOCATE_MDL( Buffer, MaxPacketSize, TRUE, FALSE, NULL );
        if ( FullMdl == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        PartialMdl = ALLOCATE_MDL( Buffer, MaxPacketSize, TRUE, FALSE, NULL );
        if ( PartialMdl == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        ReceiveMdl = ALLOCATE_MDL( Buffer, MaxPacketSize, TRUE, FALSE, NULL );
        if ( ReceiveMdl == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

    } except( NwExceptionFilter( pIrpContext->pOriginalIrp, GetExceptionInformation() )) {

        if ( Buffer != NULL ) {
            FREE_POOL( Buffer );
        }

        if ( FullMdl != NULL ) {
            FREE_MDL( FullMdl );
        }

        if ( PartialMdl != NULL ) {
            FREE_MDL( FullMdl );
        }

        return STATUS_NOT_SUPPORTED;
    }

    MmBuildMdlForNonPagedPool( FullMdl );

    //
    //  Allocate a receive MDL and chain in to the IrpContext receive MDL.
    //

    pIrpContext->RxMdl->ByteCount = sizeof( NCP_RESPONSE ) + sizeof(ULONG);
    MmBuildMdlForNonPagedPool( ReceiveMdl );
    pIrpContext->RxMdl->Next = ReceiveMdl;

    CurrentPacketSize = MaxPacketSize;
    MinPacketSize = DEFAULT_PACKET_SIZE;

    //  Log values before we update them.
    DebugTrace( 0, DEBUG_TRACE_LIP, "Using TickCount       = %08lx\n", pNpScb->TickCount * pNpScb->MaxPacketSize);
    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwSendDelay   = %08lx\n", pNpScb->NwSendDelay );
    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay H = %08lx\n", pNpScb->NtSendDelay.HighPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay L = %08lx\n", pNpScb->NtSendDelay.LowPart );

    //
    // The LIP sequence number is used to let us know if the response packet we are looking
    // at goes with the packet that we just sent.  On a really slow link, it could be a
    // response that we have already given up on.
    // 
    // The LIP tick adjustment tells ExchangeWithWait to try waiting a little longer.
    //

    pNpScb->LipSequenceNumber = 0;
    pNpScb->LipTickAdjustment = 0;

    //
    //  Loop using the bisection method to find the maximum packet size. Feel free to
    //  use shortcuts to avoid unnecessary timeouts.
    //

    while (TRUE) {

        //
        // Every time we send a packet, increment the LIP sequence number.
        // We check the LIP sequence number in ServerDatagramHandler.
        //

        pNpScb->LipSequenceNumber++;

        DebugTrace( 0, DEBUG_TRACE_LIP, "Sending %d byte echo\n", CurrentPacketSize );

        IoBuildPartialMdl(
            FullMdl,
            PartialMdl,
            Buffer,
            CurrentPacketSize - sizeof(NCP_RESPONSE) - sizeof(ULONG) );

        //
        //  Send an echo packet.  If we get a response, then we know that
        //  the minimum packet size we can use is at least as big as the
        //  echo packet size.
        //

        pIrpContext->pTdiStruct = &pIrpContext->pNpScb->Echo;

        //
        // Short-circuit the even better RAS compression.
        //

        for ( index = 0; index < MaxPacketSize/2; index++, value++) {
            Buffer[index] = value;
        }

        KeQuerySystemTime( &StartTime );

        Status = ExchangeWithWait(
                      pIrpContext,
                      SynchronousResponseCallback,
                      "E_DDf",
                      sizeof(NCP_RESPONSE ),
                      pNpScb->EchoCounter,
                      pNpScb->LipSequenceNumber,
                      PartialMdl );

        if (( Status != STATUS_REMOTE_NOT_LISTENING ) ||
            ( SecondTime )) {

            KeQuerySystemTime( &Now );
            DebugTrace( 0, DEBUG_TRACE_LIP, "Response received %08lx\n", Status);

            if (!SecondTime) {

                MinPacketSize = CurrentPacketSize;
                FirstPing.QuadPart = Now.QuadPart - StartTime.QuadPart;
            }

        } else {

            DebugTrace( 0, DEBUG_TRACE_LIP, "No response\n", 0);
            MaxPacketSize = CurrentPacketSize;
        }

        pNpScb->EchoCounter++;
        MmPrepareMdlForReuse( PartialMdl );


        if ((  MaxPacketSize - MinPacketSize <= LipAccuracy ) ||
            (  SecondTime )) {

            //
            //  We have the maximum packet size.
            //  Now - StartTime is how long it takes for the round-trip.  Now we'll
            //  try the same thing with a small packet and see how long it takes.  From
            //  this we'll derive a throughput rating.
            //


            if ( SecondTime) {

                SecondPing.QuadPart = Now.QuadPart - StartTime.QuadPart;
                break;

            } else {
                SecondTime = TRUE;
                //  Use a small packet size to verify that the server is still up.
                CurrentPacketSize = sizeof(NCP_RESPONSE) + sizeof(ULONG) * 2;
            }

        } else {

            //
            //  Calculate the next packet size guess.
            //

            if (( Status == STATUS_REMOTE_NOT_LISTENING ) &&
                ( MaxPacketSize == 1463 )) {

                CurrentPacketSize = 1458;

            } else if (( Status == STATUS_REMOTE_NOT_LISTENING ) &&
                ( MaxPacketSize == 1458 )) {

                CurrentPacketSize = 1436;

            } else {

                //
                //  We didn't try one of our standard sizes so use the chop search
                //  to get to the next value.
                //

                CurrentPacketSize = ( MaxPacketSize + MinPacketSize ) / 2;

            }
        }
    }

    DebugTrace( 0, DEBUG_TRACE_LIP, "Set maximum burst packet size to %d\n", MinPacketSize );
    DebugTrace( 0, DEBUG_TRACE_LIP, "FirstPing  H = %08lx\n", FirstPing.HighPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "FirstPing  L = %08lx\n", FirstPing.LowPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "SecondPing H = %08lx\n", SecondPing.HighPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "SecondPing L = %08lx\n", SecondPing.LowPart );

    //
    // Avoid a divide by zero error if something bad happened.
    //

    if ( FirstPing.QuadPart != 0 ) {
        pNpScb->LipDataSpeed = (ULONG) ( ( (LONGLONG)MinPacketSize * (LONGLONG)1600000 )
                                         / FirstPing.QuadPart );
    } else {
        pNpScb->LipDataSpeed = 0;
    }

    DebugTrace( 0, DEBUG_TRACE_LIP, "LipDataSpeed: %d\n", pNpScb->LipDataSpeed );

    if ((NT_SUCCESS(Status)) &&
        ( MinPacketSize > DEFAULT_PACKET_SIZE )) {

        temp.QuadPart = FirstPing.QuadPart - SecondPing.QuadPart;

        if (temp.QuadPart > 0) {

            //
            //  Convert to single trip instead of both ways.
            //

            temp.QuadPart = temp.QuadPart / (2 * 1000);

        } else {

            //
            //  Small packet ping is slower or the same speed as the big ping.
            //  We can't time a small enough interval so go for no delay at all.
            //

            temp.QuadPart = 0;

        }


        ASSERT(temp.HighPart == 0);

        pNpScb->NwGoodSendDelay = pNpScb->NwBadSendDelay = pNpScb->NwSendDelay =
            MAX(temp.LowPart, (ULONG)MinSendDelay);

        pNpScb->NwGoodReceiveDelay = pNpScb->NwBadReceiveDelay = pNpScb->NwReceiveDelay =
            MAX(temp.LowPart, (ULONG)MinReceiveDelay);

        //
        //  Time for a big packet to go one way.
        //

        pNpScb->NwSingleBurstPacketTime = pNpScb->NwReceiveDelay;

        pNpScb->NtSendDelay.QuadPart = pNpScb->NwReceiveDelay * -1000;


        //
        //  Maximum that SendDelay is allowed to reach
        //

        pNpScb->NwMaxSendDelay = MAX( 52, MIN( pNpScb->NwSendDelay, MaxSendDelay ));
        pNpScb->NwMaxReceiveDelay = MAX( 52, MIN( pNpScb->NwReceiveDelay, MaxReceiveDelay ));

        //
        //  Time for a small packet to get to the server and back.
        //

        temp.QuadPart = SecondPing.QuadPart / 1000;
        pNpScb->NwLoopTime = temp.LowPart;

        DebugTrace( 0, DEBUG_TRACE_LIP, "Using TickCount            = %08lx\n", pNpScb->TickCount * pNpScb->MaxPacketSize);
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwSendDelay        = %08lx\n", pNpScb->NwSendDelay );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwMaxSendDelay     = %08lx\n", pNpScb->NwMaxSendDelay );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwMaxReceiveDelay  = %08lx\n", pNpScb->NwMaxReceiveDelay );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwLoopTime         = %08lx\n", pNpScb->NwLoopTime );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay H      = %08lx\n", pNpScb->NtSendDelay.HighPart );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay L      = %08lx\n", pNpScb->NtSendDelay.LowPart );

        //
        //  Reset Tdi struct so that we send future NCPs from the server socket.
        //

        pIrpContext->pTdiStruct = NULL;

        //
        //  Now decouple the MDL
        //

        pIrpContext->TxMdl->Next = NULL;
        pIrpContext->RxMdl->Next = NULL;
        pIrpContext->RxMdl->ByteCount = RxMdlLength;

        //
        //  Calculate the maximum amount of data we can send in a burst write
        //  packet after all the header info is stripped.
        //

        pNpScb->MaxPacketSize = MinPacketSize - sizeof( NCP_BURST_WRITE_REQUEST );

        FREE_MDL( PartialMdl );
        FREE_MDL( ReceiveMdl );
        FREE_MDL( FullMdl );
        FREE_POOL( Buffer );


        DebugTrace( -1, DEBUG_TRACE_LIP, "GetMaxPacketSize -> VOID\n", 0);
        return STATUS_SUCCESS;

    } else {

        //
        //  If the small packet couldn't echo then assume the worst.
        //

        //
        //  Reset Tdi struct so that we send future NCPs from the server socket.
        //

        pIrpContext->pTdiStruct = NULL;

        //
        //  Now decouple the MDL
        //

        pIrpContext->TxMdl->Next = NULL;
        pIrpContext->RxMdl->Next = NULL;
        pIrpContext->RxMdl->ByteCount = RxMdlLength;

        FREE_MDL( PartialMdl );
        FREE_MDL( ReceiveMdl );
        FREE_MDL( FullMdl );
        FREE_POOL( Buffer );


        DebugTrace( -1, DEBUG_TRACE_LIP, "GetMaxPacketSize -> VOID\n", 0);
        return STATUS_NOT_SUPPORTED;
    }

}


VOID
DestroyAllScb(
    VOID
    )

/*++

Routine Description:

    This routine destroys all server control blocks.

Arguments:


Return Value:


--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PNONPAGED_SCB pNpScb;

    DebugTrace(+1, Dbg, "DestroyAllScbs....\n", 0);

    KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

    //
    //  Walk the list of SCBs and kill them all.
    //

    while (!IsListEmpty(&ScbQueue)) {

        ScbQueueEntry = RemoveHeadList( &ScbQueue );
        pNpScb = CONTAINING_RECORD(ScbQueueEntry, NONPAGED_SCB, ScbLinks);

        //
        //  We can't hold the spin lock while deleting an SCB, so release
        //  it now.
        //

        KeReleaseSpinLock(&ScbSpinLock, OldIrql);

        NwDeleteScb( pNpScb->pScb );

        KeAcquireSpinLock(&ScbSpinLock, &OldIrql);
    }

    KeReleaseSpinLock(&ScbSpinLock, OldIrql);

    DebugTrace(-1, Dbg, "DestroyAllScb\n", 0 );
}


VOID
NwDeleteScb(
    PSCB pScb
    )
/*++

Routine Description:

    This routine deletes an SCB.  The SCB must not be in use.

    *** The caller must own the RCB exclusive.

Arguments:

    Scb - The SCB to delete

Return Value:

    None.

--*/
{
    PNONPAGED_SCB pNpScb;
    PLIST_ENTRY CacheEntry;
    PNDS_OBJECT_CACHE_ENTRY ObjectCache;
    BOOLEAN AnonymousScb = IS_ANONYMOUS_SCB( pScb );

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwDeleteScb...\n", 0);

    pNpScb = pScb->pNpScb;

    //
    // Make sure we are not deleting a logged in connection
    // or we will hang up the license until the server times
    // it out.
    //

    ASSERT( pNpScb->State != SCB_STATE_IN_USE );
    ASSERT( pNpScb->Reference == 0 );
    ASSERT( !pNpScb->Sending );
    ASSERT( !pNpScb->Receiving );
    ASSERT( !pNpScb->OkToReceive );
    ASSERT( IsListEmpty( &pNpScb->Requests ) );
    ASSERT( IsListEmpty( &pScb->IcbList ) );
    ASSERT( pScb->IcbCount == 0 );
    ASSERT( pScb->VcbCount == 0 );


    DebugTrace(0, Dbg, "Cleaning up SCB %08lx\n", pScb);

    if ( AnonymousScb ) {
        DebugTrace(0, Dbg, "SCB is anonymous\n", &pNpScb->ServerName );
    } else {
        ASSERT( IsListEmpty( &pScb->ScbSpecificVcbQueue ) );
        DebugTrace(0, Dbg, "SCB is %wZ\n", &pNpScb->ServerName );
    }

    DebugTrace(0, Dbg, "SCB state is %d\n", &pNpScb->State );

    if ( !AnonymousScb ) {
        RtlRemoveUnicodePrefix ( &NwRcb.ServerNameTable, &pScb->PrefixEntry );
    }

    IPX_Close_Socket( &pNpScb->Server );
    IPX_Close_Socket( &pNpScb->WatchDog );
    IPX_Close_Socket( &pNpScb->Send );
    IPX_Close_Socket( &pNpScb->Echo);
    IPX_Close_Socket( &pNpScb->Burst);

    NwUninitializePidTable( pNpScb );        

    FREE_POOL( pNpScb );

    if ( pScb->UserName.Buffer != NULL ) {
        FREE_POOL( pScb->UserName.Buffer );
    }

    //
    //  Free the object cache buffer if there is one.
    //

    if( pScb->ObjectCacheBuffer != NULL ) {

        //
        //  Remove any references this cache has to other SCBs.
        //
        //  NOTE:  We do not need the lock here, since no one else
        //         can be using this SCB.
        //

        CacheEntry = pScb->ObjectCacheList.Flink;

        while( CacheEntry != &(pScb->ObjectCacheList) ) {

            ObjectCache = CONTAINING_RECORD( CacheEntry, NDS_OBJECT_CACHE_ENTRY, Links );

            if( ObjectCache->Scb != NULL ) {

                NwDereferenceScb( ObjectCache->Scb->pNpScb );
                ObjectCache->Scb = NULL;
            }

            CacheEntry = CacheEntry->Flink;
        }

        FREE_POOL( pScb->ObjectCacheBuffer );
    }

    FREE_POOL( pScb );

    DebugTrace(-1, Dbg, "NwDeleteScb -> VOID\n", 0);
}


PNONPAGED_SCB
SelectConnection(
    PNONPAGED_SCB NpScb OPTIONAL
    )
/*++

Routine Description:

    Find a default server (which is also the nearest server).
    If NpScb is not supplied, simply return the first server in
    the list.  If it is supplied return the next server in the
    list after the given server.

Arguments:

    NpScb - The starting point for the server search.

Return Value:

    Scb to be used or NULL.

--*/
{
    PLIST_ENTRY ScbQueueEntry;
    KIRQL OldIrql;
    PNONPAGED_SCB pNextNpScb;

    DebugTrace(+1, Dbg, "SelectConnection....\n", 0);
    KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

    if ( NpScb == NULL ) {
        ScbQueueEntry = ScbQueue.Flink ;
    } else {
        ScbQueueEntry = NpScb->ScbLinks.Flink;
    }

    for ( ;
          ScbQueueEntry != &ScbQueue ;
          ScbQueueEntry = ScbQueueEntry->Flink ) {

        pNextNpScb = CONTAINING_RECORD(
                         ScbQueueEntry,
                         NONPAGED_SCB,
                         ScbLinks );

        //
        //  Check to make sure that this SCB is usable.
        //

        if (( pNextNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) ||
            ( pNextNpScb->State == SCB_STATE_LOGIN_REQUIRED ) ||
            ( pNextNpScb->State == SCB_STATE_IN_USE )) {

            NwReferenceScb( pNextNpScb );

            KeReleaseSpinLock(&ScbSpinLock, OldIrql);
            DebugTrace(+0, Dbg, "  NpScb        = %lx\n", pNextNpScb );
            DebugTrace(-1, Dbg, "   NpScb->State = %x\n", pNextNpScb->State );
            return pNextNpScb;
        }
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql);
    DebugTrace(-1, Dbg, "       NULL\n", 0);
    return NULL;
}


VOID
NwLogoffAllServers(
    PIRP_CONTEXT pIrpContext,
    PLARGE_INTEGER Uid
    )
/*++

Routine Description:

    This routine sends a logoff to all connected servers created by the Logon
    user or all servers if Logon is NULL.

Arguments:

    Uid - Supplies the servers to disconnect from.

Return Value:

    none.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PLIST_ENTRY NextScbQueueEntry;
    PNONPAGED_SCB pNpScb;

    DebugTrace( 0, Dbg, "NwLogoffAllServers\n", 0 );

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    for (ScbQueueEntry = ScbQueue.Flink ;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry =  NextScbQueueEntry ) {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        //
        //  Reference the SCB so that it doesn't disappear while we
        //  are disconnecting.
        //

        NwReferenceScb( pNpScb );

        //
        //  Release the SCB spin lock so that we can send a logoff
        //  NCP.
        //

        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

        //
        //  Destroy this Scb if its not the permanent Scb and either we
        //  are destroying all Scb's or it was created for this user.
        //

        if (( pNpScb->pScb != NULL ) &&
            (( Uid == NULL ) ||
             ( pNpScb->pScb->UserUid.QuadPart == (*Uid).QuadPart))) {

            NwLogoffAndDisconnect( pIrpContext, pNpScb );
        }

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

        //
        //  Release the temporary reference.
        //

        NextScbQueueEntry = pNpScb->ScbLinks.Flink;
        NwDereferenceScb( pNpScb );
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );
}


VOID
NwLogoffAndDisconnect(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    This routine sends a logoff and disconnects from the name server.

Arguments:

    pIrpContext - A pointer to the current IRP context.
    pNpScb - A pointer to the server to logoff and disconnect.

Return Value:

    None.

--*/
{
    PSCB pScb = pNpScb->pScb;

    PAGED_CODE();

    pIrpContext->pNpScb = pNpScb;
    pIrpContext->pScb = pScb;

    //
    //  Queue ourselves to the SCB, and wait to get to the front to
    //  protect access to server State.
    //

    NwAppendToQueueAndWait( pIrpContext );

    //
    //  If we are logging out from the preferred server, free the preferred
    //  server reference.
    //

    if ( pScb != NULL &&
         pScb->PreferredServer ) {
        pScb->PreferredServer = FALSE;
        NwDereferenceScb( pNpScb );
    }

    //
    //  Nothing to do if we are not connected.
    //

    if ( pNpScb->State != SCB_STATE_IN_USE &&
         pNpScb->State != SCB_STATE_LOGIN_REQUIRED ) {

        NwDequeueIrpContext( pIrpContext, FALSE );
        return;
    }

    //
    //  If we timeout then we don't want to go to the bother of
    //  reconnecting.
    //

    ClearFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    //  Logout and disconnect.
    //

    if ( pNpScb->State == SCB_STATE_IN_USE ) {

        ExchangeWithWait (
            pIrpContext,
            SynchronousResponseCallback,
            "F",
            NCP_LOGOUT );
    }

    ExchangeWithWait (
        pIrpContext,
        SynchronousResponseCallback,
        "D-" );          // Disconnect

    Stats.Sessions--;

    if ( pScb->MajorVersion == 2 ) {
        Stats.NW2xConnects--;
    } else if ( pScb->MajorVersion == 3 ) {
        Stats.NW3xConnects--;
    } else if ( pScb->MajorVersion >= 4 ) {
        Stats.NW4xConnects--;
    }

    //
    //  dfergus 19 Apr 2001 #302137
    //  Removed the following fix for fix #302137
    //
    // tommye - MS 25584 / MCS 274
    //
    // Added code to look for this tree in the user's cached
    // credentials and remove it if there is one.  This fixes
    // a problem where the user could perform a tree connect 
    // providing the user name and password, delete the connection
    // then connect again successfully providing only the user name 
    // (we would get the password from the cached credentials).
    //
    // 5/31/00 - made changes to locking per conversation with Anoop
    //
/*  // Begin 302137
    {
        PLOGON pLogon = NULL;

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &pScb->UserUid, FALSE );
        NwReleaseRcb( &NwRcb );

        if (pLogon) {
            PLIST_ENTRY pFirst, pNext;
            PNDS_SECURITY_CONTEXT pNdsContext;

            // Lock the credential list while we walk it

            NwAcquireExclusiveCredList( pLogon, pIrpContext );

            pFirst = &pLogon->NdsCredentialList;
            pNext  = pLogon->NdsCredentialList.Flink;

            // Go through the credential list and find a match for the tree name 

            while ( pNext && ( pFirst != pNext ) ) {

                pNdsContext = (PNDS_SECURITY_CONTEXT)
                              CONTAINING_RECORD( pNext,
                                                 NDS_SECURITY_CONTEXT,
                                                 Next );

                ASSERT( pNdsContext->ntc == NW_NTC_NDS_CREDENTIAL );

                // If this is the same tree, free the entry

                if ( !RtlCompareUnicodeString( &pScb->NdsTreeName,
                                               &pNdsContext->NdsTreeName,
                                               TRUE ) ) {

                    DebugTrace(0, Dbg, "   Removing cached credential for tree %wZ\n", &pNdsContext->NdsTreeName);

                    RemoveEntryList( &pNdsContext->Next );
                    FreeNdsContext( pNdsContext );

                    break;
                }

                pNext = pNdsContext->Next.Flink;
            }

            // Release the lock 

            NwReleaseCredList( pLogon, pIrpContext );
        }
    }
*/  //  End 302137
    //
    //  Free the remembered username and password.
    //

    if ( pScb != NULL && pScb->UserName.Buffer != NULL ) {
        FREE_POOL( pScb->UserName.Buffer );
        RtlInitUnicodeString( &pScb->UserName, NULL );
        RtlInitUnicodeString( &pScb->Password, NULL );
    }

    pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

    NwDequeueIrpContext( pIrpContext, FALSE );
    return;
}


VOID
InitializeAttach (
    VOID
    )
/*++

Routine Description:

    Initialize global structures for attaching to servers.

Arguments:

    none.

Return Value:

    none.

--*/
{
    PAGED_CODE();

    KeInitializeSpinLock( &ScbSpinLock );
    InitializeListHead(&ScbQueue);
}


NTSTATUS
OpenScbSockets(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    Open the communications sockets for an SCB.

Arguments:

    pIrpContext - The IRP context pointers for the request in progress.

    pNpScb - The SCB to connect to the network.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Auto allocate to the server socket.
    //

    pNpScb->Server.Socket = 0;

    Status = IPX_Open_Socket (pIrpContext, &pNpScb->Server);

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Watchdog Socket is Server.Socket+1
    //

    pNpScb->WatchDog.Socket = NextSocket( pNpScb->Server.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->WatchDog );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Send Socket is WatchDog.Socket+1
    //

    pNpScb->Send.Socket = NextSocket( pNpScb->WatchDog.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->Send );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Echo socket
    //

    pNpScb->Echo.Socket = NextSocket( pNpScb->Send.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->Echo );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Burst socket
    //

    pNpScb->Burst.Socket = NextSocket( pNpScb->Echo.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->Burst );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
DoBinderyLogon(
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    )
/*++

Routine Description:

    Performs a bindery based encrypted logon.

    Note: Rcb is held exclusively so that we can access the Logon queue
          safely.

Arguments:

    pIrpContext - The IRP context pointers for the request in progress.

    UserName - The user name to use to login.

    Password - The password to use to login.

Return Value:

    The status of the operation.

--*/
{
    PNONPAGED_SCB pNpScb;
    PSCB pScb;
    UNICODE_STRING Name;
    UNICODE_STRING PWord;
    UCHAR EncryptKey[ENCRYPTION_KEY_SIZE ];
    NTSTATUS Status;
    PVOID Buffer;
    PLOGON Logon = NULL;
    PWCH OldBuffer;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "DoBinderyLogon...\n", 0);

    //
    //  First get an encryption key.
    //

    DebugTrace( +0, Dbg, " Get Login key\n", 0);

    Status = ExchangeWithWait (
                IrpContext,
                SynchronousResponseCallback,
                "S",
                NCP_ADMIN_FUNCTION, NCP_GET_LOGIN_KEY );

    pNpScb = IrpContext->pNpScb;
    pScb = pNpScb->pScb;

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    if ( NT_SUCCESS( Status ) ) {
        Status = ParseResponse(
                     IrpContext,
                     IrpContext->rsp,
                     IrpContext->ResponseLength,
                     "Nr",
                     EncryptKey, sizeof(EncryptKey) );
    }

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    //
    //  Choose a name and password to use to connect to the server.  Use
    //  the user supplied if the exist.  Otherwise if the server already
    //  has a remembered username use the remembered name.   If nothing
    //  else is available use the defaults from logon.  Finally, if the
    //  user didn't even logon, use GUEST no password.
    //


    if ( UserName != NULL && UserName->Buffer != NULL ) {

        Name = *UserName;

    } else if ( pScb->UserName.Buffer != NULL ) {

        Name = pScb->UserName;

    } else {

        Logon = FindUser( &pScb->UserUid, FALSE );

        if (Logon != NULL ) {
            Name = Logon->UserName;
        } else {
            ASSERT( FALSE && "No logon record found" );
            return( STATUS_ACCESS_DENIED );
        }
    }

    if ( Password != NULL && Password->Buffer != NULL ) {

        PWord = *Password;

    } else if ( pScb->Password.Buffer != NULL ) {
        /*
         *  Password is not passed in, or implied.
         *  If the user name matches or was not passed in,
         *  then use the SCB password,
         *  else use a null password.
         */
        if ( UserName == NULL || UserName->Buffer == NULL ||
             ( RtlEqualUnicodeString( &pScb->UserName, UserName, TRUE )) ) {
            PWord = pScb->Password;
        } else {
            PWord.Buffer = L"";
            PWord.Length = PWord.MaximumLength = 0;
        }

    } else {

        if ( Logon == NULL ) {
            Logon = FindUser( &pScb->UserUid, FALSE );
        }

        if ( Logon != NULL ) {
            PWord = Logon->PassWord;
        } else {
            ASSERT( FALSE && "No logon record found" );
            return( STATUS_ACCESS_DENIED );
        }
    }


    if ( !NT_SUCCESS(Status) ) {

        //
        //  Failed to get an encryption key.  Login to server, plain text
        //

        DebugTrace( +0, Dbg, " Plain Text Login\n", 0);

        Status = ExchangeWithWait (
                    IrpContext,
                    SynchronousResponseCallback,
                    "SwJU",  // JimTh 5/19/2001 - Send Name using 'J' option, DBCS translation if on Far East system
                    NCP_ADMIN_FUNCTION, NCP_PLAIN_TEXT_LOGIN,
                    OT_USER,
                    &Name,
                    &PWord);

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( NT_SUCCESS( Status ) ) {
            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N" );
        }

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( !NT_SUCCESS( Status )) {
            return( STATUS_WRONG_PASSWORD);
        }

    } else if ( NT_SUCCESS( Status ) ) {

        //
        //  We have an encryption key. Get the ObjectId
        //

        UCHAR Response[ENCRYPTION_KEY_SIZE];
        UCHAR ObjectId[OBJECT_ID_SIZE];
        OEM_STRING UOPassword;

        DebugTrace( +0, Dbg, " Query users objectid\n", 0);

        Status = ExchangeWithWait (
                    IrpContext,
                    SynchronousResponseCallback,
                    "SwJ", // JimTh 5/19/2001 - Send Name using 'J' option, DBCS translation if on Far East system
                    NCP_ADMIN_FUNCTION, NCP_QUERY_OBJECT_ID,
                    OT_USER,
                    &Name);

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( NT_SUCCESS( Status ) ) {

            //
            //  Save the new address in a local copy so that we can logout.
            //

            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "Nr",
                         ObjectId, OBJECT_ID_SIZE );
        }

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if (!NT_SUCCESS(Status)) {
            return( STATUS_NO_SUCH_USER );
        }

        //
        //  Convert the unicode password to uppercase and then the oem
        //  character set.
        //

        if ( PWord.Length > 0 ) {

            Status = RtlUpcaseUnicodeStringToOemString( &UOPassword, &PWord, TRUE );
            if (!NT_SUCCESS(Status)) {
                return( Status );
            }

        } else {
            UOPassword.Buffer = "";
            UOPassword.Length = UOPassword.MaximumLength = 0;
        }

        RespondToChallenge( ObjectId, &UOPassword, EncryptKey, Response);

        if ( PWord.Length > 0) {
            RtlFreeAnsiString( &UOPassword );
        }

        DebugTrace( +0, Dbg, " Encrypted Login\n", 0);

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "SrwJ", // JimTh 5/19/2001 - Send Name using 'J' option, DBCS translation if on Far East system
                     NCP_ADMIN_FUNCTION, NCP_ENCRYPTED_LOGIN,
                     Response, sizeof(Response),
                     OT_USER,
                     &Name);

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( NT_SUCCESS( Status ) ) {

            //
            //  Save the new address in a local copy so that we can logout
            //

            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N" );
        }

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( !NT_SUCCESS( Status )) {

            //
            //  Special case error mappings.
            //

            if (( Status == STATUS_UNSUCCESSFUL ) ||
                ( Status == STATUS_UNEXPECTED_NETWORK_ERROR /* 2.2 servers */  )) {
                Status = STATUS_WRONG_PASSWORD;
            }

            if ( Status == STATUS_LOCK_NOT_GRANTED ) {
                Status = STATUS_ACCOUNT_RESTRICTION;  // Bindery locked
            }

            if ( Status == STATUS_DISK_FULL ) {
#ifdef QFE_BUILD
                Status = STATUS_TOO_MANY_SESSIONS;
#else
                Status = STATUS_REMOTE_SESSION_LIMIT;
#endif
            }

            if ( Status == STATUS_FILE_LOCK_CONFLICT ) {
                Status = STATUS_SHARING_PAUSED;
            }

            if ( Status == STATUS_NO_MORE_ENTRIES ) {
                Status = STATUS_NO_SUCH_USER;    // No such object on "Login Object Encrypted" NCP.
            }

            //
            // Netware 4.x servers return a different NCP error for
            // a disabled account (from intruder lockout) on bindery login,
            // and nwconvert maps this to a dos error.  In this special case,
            // we'll catch it and map it back.
            //

            if ( ( IrpContext->pNpScb->pScb->MajorVersion >= 4 ) &&
                 ( Status == 0xC001003B ) ) {
                Status = STATUS_ACCOUNT_DISABLED;
            }

            return( Status );
        }

    } else {

        return( Status );

    }


    //
    //  Success.  Save the username & password for reconnect.
    //

    //
    //  Setup to free the old user name and password buffer.
    //

    if ( pScb->UserName.Buffer != NULL ) {
        OldBuffer = pScb->UserName.Buffer;
    } else {
        OldBuffer = NULL;
    }

    Buffer = ALLOCATE_POOL( NonPagedPool, Name.Length + PWord.Length );
    if ( Buffer == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    pScb->UserName.Buffer = Buffer;
    pScb->UserName.Length = pScb->UserName.MaximumLength = Name.Length;
    RtlMoveMemory( pScb->UserName.Buffer, Name.Buffer, Name.Length );

    pScb->Password.Buffer = (PWCHAR)((PCHAR)Buffer + Name.Length);
    pScb->Password.Length = pScb->Password.MaximumLength = PWord.Length;
    RtlMoveMemory( pScb->Password.Buffer, PWord.Buffer, PWord.Length );

    if ( OldBuffer != NULL ) {
        FREE_POOL( OldBuffer );
    }
    return( Status );
}

NTSTATUS
NwAllocateAndInitScb(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UidServerName OPTIONAL,
    IN PUNICODE_STRING ServerName OPTIONAL,
    OUT PSCB *ppScb
)
/*++

Routine Description:

    This routine returns a pointer to a newly created SCB.  If
    the UidServerName and ServerName are supplied, the SCB name
    fields are initialized to this name.  Otherwise, the name
    fields are left blank to be filled in later.

    If UidServerName is provided, ServerName MUST also be provided!!

    The returned SCB is NOT filed in the server prefix table since
    it might not yet have a name.

Return Value:

    The created SCB or NULL.

--*/
{

    NTSTATUS Status;
    PSCB pScb = NULL;
    PNONPAGED_SCB pNpScb = NULL;
    USHORT ServerNameLength;
    PLOGON Logon;
    PNDS_OBJECT_CACHE_ENTRY ObjectEntry;
    ULONG EntrySize;
    ULONG i;

    //
    // Allocate enough space for a credential munged tree name.
    //

    pScb = ALLOCATE_POOL ( PagedPool,
               sizeof( SCB ) +
               ( ( NDS_TREE_NAME_LEN + MAX_NDS_NAME_CHARS + 2 ) * sizeof( WCHAR ) ) );

    if ( !pScb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( pScb, sizeof( SCB ) );
    RtlInitializeBitMap( &pScb->DriveMapHeader, pScb->DriveMap, MAX_DRIVES );

    //
    //  Initialize pointers to ensure cleanup on error case operates
    //  correctly.
    //

    if ( UidServerName &&
         UidServerName->Length ) {

        ServerNameLength = UidServerName->Length + sizeof( WCHAR );

    } else {

        ServerNameLength = ( MAX_SERVER_NAME_LENGTH * sizeof( WCHAR ) ) +
                           ( MAX_UNICODE_UID_LENGTH * sizeof( WCHAR ) ) +
                           ( 2 * sizeof( WCHAR ) );

    }

    pScb->pNpScb = ALLOCATE_POOL ( NonPagedPool,
                       sizeof( NONPAGED_SCB ) + ServerNameLength );

    if ( !pScb->pNpScb ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    RtlZeroMemory( pScb->pNpScb, sizeof( NONPAGED_SCB ) );

    pNpScb = pScb->pNpScb;
    pNpScb->pScb = pScb;

    //
    //  If we know the server name, copy it to the allocated buffer.
    //  Append a NULL so that we can use the name a nul-terminated string.
    //

    pScb->UidServerName.Buffer = (PWCHAR)( pScb->pNpScb + 1 );
    pScb->UidServerName.MaximumLength = ServerNameLength;
    pScb->UidServerName.Length = 0;

    RtlInitUnicodeString( &(pNpScb->ServerName), NULL );

    if ( UidServerName &&
         UidServerName->Length ) {

        RtlCopyUnicodeString ( &pScb->UidServerName, UidServerName );
        pScb->UidServerName.Buffer[ UidServerName->Length / sizeof( WCHAR ) ] = L'\0';

        pScb->UnicodeUid = pScb->UidServerName;
        pScb->UnicodeUid.Length = UidServerName->Length -
                                  ServerName->Length -
                                  sizeof(WCHAR);

        //
        //  Make ServerName point partway down the buffer for UidServerName
        //

        pNpScb->ServerName.Buffer = (PWSTR)((PUCHAR)pScb->UidServerName.Buffer +
                                    UidServerName->Length - ServerName->Length);

        pNpScb->ServerName.MaximumLength = ServerName->Length;
        pNpScb->ServerName.Length = ServerName->Length;

    }

    pScb->NdsTreeName.MaximumLength = NDS_TREE_NAME_LEN * sizeof( WCHAR );
    pScb->NdsTreeName.Buffer = (PWCHAR)(pScb + 1);

    pScb->NodeTypeCode = NW_NTC_SCB;
    pScb->NodeByteSize = sizeof(SCB);
    InitializeListHead( &pScb->ScbSpecificVcbQueue );
    InitializeListHead( &pScb->IcbList );

    //
    // Remember UID of the file creator so we can find the username and
    // password to use for this Scb when we need it.
    //

    pScb->UserUid = pIrpContext->Specific.Create.UserUid;

    //
    //  Initialize the non-paged part of the SCB.
    //

    pNpScb->NodeTypeCode = NW_NTC_SCBNP;
    pNpScb->NodeByteSize = sizeof(NONPAGED_SCB);

    //
    //  Set the initial SCB reference count.
    //

    if ( UidServerName &&
         UidServerName->Length ) {

        Logon = FindUser( &pScb->UserUid, FALSE );

        if (( Logon != NULL) &&
            (RtlCompareUnicodeString( ServerName, &Logon->ServerName, TRUE ) == 0 )) {
            pScb->PreferredServer = TRUE;
        }
    }

    if ( pScb->PreferredServer ) {
        pNpScb->Reference = 2;
    } else {
        pNpScb->Reference = 1;
    }

    //
    //  Finish linking the two parts of the Scb together.
    //

    pNpScb->pScb = pScb;

    KeInitializeSpinLock( &pNpScb->NpScbSpinLock );
    KeInitializeSpinLock( &pNpScb->NpScbInterLock );
    InitializeListHead( &pNpScb->Requests );

    RtlFillMemory( &pNpScb->LocalAddress, sizeof(IPXaddress), 0xff);

    pNpScb->State = SCB_STATE_ATTACHING;
    pNpScb->SequenceNo = 1;

    Status = OpenScbSockets( pIrpContext, pNpScb );
    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Server,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->WatchDog,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &WatchDogDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Send,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &SendDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Echo,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 pNpScb );

    pNpScb->EchoCounter = 2;

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Burst,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    KeQuerySystemTime( &pNpScb->LastUsedTime );

    //
    //  Set burst mode data.
    //

    pNpScb->BurstRequestNo = 0;
    pNpScb->BurstSequenceNo = 0;

    //
    //  Initialize the NDS object cache if it is enabled.
    //

    if( NdsObjectCacheSize != 0 ) {

        //
        //  Determine the size of each entry.  This must be eight byte aligned,
        //  since they will all be allocated in one big block.
        //
        //  NOTE:  The NDS_OBJECT_CACHE_ENTRY structure must already be aligned.
        //

        EntrySize = sizeof(NDS_OBJECT_CACHE_ENTRY) + (((sizeof(WCHAR) * MAX_NDS_NAME_CHARS) + 7) & ~7);

        //
        //  Allocate the buffer for the cache.  If memory cannot be allocated, it is not
        //  fatal.  In this case, the object cache is just disabled for this SCB.
        //

        pScb->ObjectCacheBuffer = ALLOCATE_POOL( PagedPool,
                                                 (EntrySize * NdsObjectCacheSize) );

        if( pScb->ObjectCacheBuffer != NULL ) {

            //
            //  Initialize the object cache buffer.  It is one big block of memory that
            //  is broken up into cache entries.  Each entry is connected to the next
            //  via a list entry.  This way the entries can be manipulated on the linked
            //  list, but there is only one allocation to deal with.
            //

            InitializeListHead( &(pScb->ObjectCacheList) );

            RtlZeroMemory( pScb->ObjectCacheBuffer,
                           (EntrySize * NdsObjectCacheSize) );

            for( i = 0; i < NdsObjectCacheSize; i++ ) {

                ObjectEntry = (PNDS_OBJECT_CACHE_ENTRY)(((PBYTE)(pScb->ObjectCacheBuffer)) + (EntrySize * i));

                InsertTailList( &(pScb->ObjectCacheList), &(ObjectEntry->Links) );

                //
                //  The buffer for the object name string immediately follows the cache entry.
                //

                ObjectEntry->ObjectName.Buffer = (PWCHAR)(ObjectEntry + 1);
                ObjectEntry->ObjectName.MaximumLength = MAX_NDS_NAME_CHARS * sizeof(WCHAR);
            }

            //
            //  This semaphore protects the object cache.
            //

            KeInitializeSemaphore( &(pScb->ObjectCacheLock),
                                   1,
                                   1 );
        }
    }

    if ( ppScb ) {
        *ppScb = pScb;
    }

    if (NwInitializePidTable( pNpScb )) {

        return STATUS_SUCCESS;
    
    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

ExitWithCleanup:

    if ( pNpScb != NULL ) {

        IPX_Close_Socket( &pNpScb->Server );
        IPX_Close_Socket( &pNpScb->WatchDog );
        IPX_Close_Socket( &pNpScb->Send );
        IPX_Close_Socket( &pNpScb->Echo );
        IPX_Close_Socket( &pNpScb->Burst );

        FREE_POOL( pNpScb );
    }

    FREE_POOL(pScb);
    return Status;

}


BOOLEAN
NwFindScb(
    OUT PSCB *Scb,
    PIRP_CONTEXT IrpContext,
    PUNICODE_STRING UidServerName,
    PUNICODE_STRING ServerName
    )
/*++

Routine Description:

    This routine returns a pointer to the SCB for the named server.
    The name is looked up in the SCB table.  If it is found, a
    pointer to the SCB is returned.  If none is found an SCB is
    created and initialized.

    This routine returns with the SCB referenced and the SCB
    resources held.

Arguments:

    Scb - Returns a pointer to the found / created SCB.

    IrpContext - The IRP context pointers for the request in progress.

    ServerName - The name of the server to find / create.

Return Value:

    TRUE - An old SCB was found.

    FALSE - A new SCB was created, or an attempt to create the SCB failed.

--*/
{
    BOOLEAN RcbHeld;
    PUNICODE_PREFIX_TABLE_ENTRY PrefixEntry;
    NTSTATUS Status;
    PSCB pScb = NULL;
    PNONPAGED_SCB pNpScb = NULL;
    KIRQL OldIrql;
    BOOLEAN Success, PreferredServerIsSet;

    //
    //  Acquire the RCB exclusive to protect the prefix table.
    //  Then lookup the name of this server.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    RcbHeld = TRUE;
    PrefixEntry = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, UidServerName, 0 );

    if ( PrefixEntry != NULL ) {

        //
        // We found the SCB, increment the reference count and return
        // success.
        //

        pScb = CONTAINING_RECORD( PrefixEntry, SCB, PrefixEntry );
        pNpScb = pScb->pNpScb;

        NwReferenceScb( pNpScb );

        //
        //  Release the RCB.
        //

        NwReleaseRcb( &NwRcb );

        DebugTrace(-1, Dbg, "NwFindScb -> %08lx\n", pScb );
        *Scb = pScb;
        return( TRUE );
    }

    //
    //  We do not have a connection to this server so create the new Scb if requested.
    //

    if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_NOCONNECT ) ) {
        NwReleaseRcb( &NwRcb );
        *Scb = NULL;
        return(FALSE);
    }

    try {

        Status = NwAllocateAndInitScb( IrpContext,
                                       UidServerName,
                                       ServerName,
                                       &pScb );

        if ( !NT_SUCCESS( Status )) {
            ExRaiseStatus( Status );
        }

        ASSERT( pScb != NULL );

        pNpScb = pScb->pNpScb;

        PreferredServerIsSet = pScb->PreferredServer;

        //
        //*******************************************************************
        //
        //  From this point on we must not fail to create the Scb because the
        //  another thread will be able to reference the Scb causing severe
        //  problems in the finaly clause or in the other thread.
        //
        //*******************************************************************
        //

        //
        //  Insert this SCB in the global list if SCBs.
        //  If it is the default (i.e. preferred) server, stick it at the
        //  front of the queue so that SelectConnection() will select it
        //  for bindery queries.
        //

        KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

        if ( PreferredServerIsSet ) {
            InsertHeadList(&ScbQueue, &pNpScb->ScbLinks);
        } else {
            InsertTailList(&ScbQueue, &pNpScb->ScbLinks);
        }

        KeReleaseSpinLock(&ScbSpinLock, OldIrql);

        //
        //  Insert the name of this server into the prefix table.
        //

        Success = RtlInsertUnicodePrefix(
                      &NwRcb.ServerNameTable,
                      &pScb->UidServerName,
                      &pScb->PrefixEntry );

#ifdef NWDBG
        if ( !Success ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Entering duplicate SCB %wZ.\n", &pScb->UidServerName );
            DbgBreakPoint();
        }
#endif

        //
        //  The Scb is now in the prefix table. Any new requests for this
        //  connection can be added to the Scb->Requests queue while we
        //  attach to the server.
        //

        NwReleaseRcb( &NwRcb );
        RcbHeld = FALSE;

        //
        // If we got an error we should have raised an exception.
        //

        ASSERT( NT_SUCCESS( Status ) );

    } finally {

        if ( !NT_SUCCESS( Status ) || AbnormalTermination() ) {
            *Scb = NULL;
        } else {
            *Scb = pScb;
        }

        if (RcbHeld) {
            NwReleaseRcb( &NwRcb );
        }

    }

    return( FALSE );
}

NTSTATUS
QueryServersAddress(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNearestScb,
    PUNICODE_STRING pServerName,
    IPXaddress *pServerAddress
    )
{
    NTSTATUS Status;
    UNICODE_STRING NewServer;
    USHORT CurrChar = 0;
    BOOLEAN SeedServerRedirect = FALSE;
    PNONPAGED_SCB pOrigNpScb;

    PAGED_CODE();

    if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

        //
        //  Unmunge the server name if this is a
        //  supplemental credential connect.
        //

        UnmungeCredentialName( pServerName, &NewServer );

    } else if ( EnableMultipleConnects ) {

        //
        //  Strip server name trailer, if it exists.  If there
        //  was no trailer, the length will end up being exactly
        //  the same as when we started.
        //

         Status = DuplicateUnicodeStringWithString(
                                                   &NewServer,
                                                   pServerName,
                                                   PagedPool
                                                   );
         if ( NT_SUCCESS( Status ) ) {

            return Status;
         }

        while ( (CurrChar < (NewServer.Length / sizeof(WCHAR))) &&
            NewServer.Buffer[CurrChar] != ((WCHAR)L'#') ) {
            CurrChar++;
        }
        NewServer.Length = CurrChar * sizeof(WCHAR);

    } else {
    
        //
        // If we support seed server indirection, check the server
        // name for a seed server.  If there is a seed server specified,
        // connect us to it.
        //


        if ( AllowSeedServerRedirection ) {
   
            pOrigNpScb = pIrpContext->pNpScb;
            NwDequeueIrpContext( pIrpContext, FALSE );

            Status = IndirectToSeedServer( pIrpContext,
                                           pServerName,
                                           &NewServer );

            if ( NT_SUCCESS( Status ) ) {

                SeedServerRedirect = TRUE;

            } else {

                NwAppendToQueueAndWait( pIrpContext );
            }
        }

        //
        // If we didn't get redirected to a seed server, then
        // just set up the server name like normal and try that.
        // 

        if ( !SeedServerRedirect ) {

           NewServer.Length = pServerName->Length;
           NewServer.MaximumLength = pServerName->MaximumLength;
           NewServer.Buffer = pServerName->Buffer;

        }

    }

    //
    //  Query the bindery of the nearest server looking for
    //  the network address of the target server.
    //

    DebugTrace( +0, Dbg, "Query servers address\n", 0);

    Status = ExchangeWithWait (
                 pIrpContext,
                 SynchronousResponseCallback,
                 "SwUbp",
                 NCP_ADMIN_FUNCTION, NCP_QUERY_PROPERTY_VALUE,
                 OT_FILESERVER,
                 &NewServer,
                 1,     //  Segment number
                 NET_ADDRESS_PROPERTY );

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    if ( NT_SUCCESS( Status ) ) {

        //
        //  Save the new address.
        //

        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "Nr",
                     pServerAddress, sizeof(TDI_ADDRESS_IPX) );
    }

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    //
    //  Map the server not found error to something sensible.
    //

    if (( Status == STATUS_NO_MORE_ENTRIES ) ||
        ( Status == STATUS_VIRTUAL_CIRCUIT_CLOSED ) ||
        ( Status == NwErrorToNtStatus(ERROR_UNEXP_NET_ERR))) {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    if ( SeedServerRedirect ) {

         //
         // Dequeue from the seed server and free the ref count.
         // There should always be an original server, but just
         // in case there's not, we check.
         //

         NwDequeueIrpContext( pIrpContext, FALSE );
         NwDereferenceScb( pIrpContext->pNpScb );

         ASSERT( pOrigNpScb != NULL );

         if ( pOrigNpScb ) {

             pIrpContext->pNpScb = pOrigNpScb;
             pIrpContext->pScb = pOrigNpScb->pScb;
             NwAppendToQueueAndWait( pIrpContext );

         } else {

             pIrpContext->pNpScb = NULL;
             pIrpContext->pScb = NULL;
         }

    }

    return( Status );
}



VOID
TreeConnectScb(
    IN PSCB Scb
    )
/*++

Routine Description:

    This routine increments the tree connect count for a SCB.

Arguments:

    Scb - A pointer to the SCB to connect to.

Return Value:

    None.

--*/
{
    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    Scb->AttachCount++;
    Scb->OpenFileCount++;
    NwReferenceScb( Scb->pNpScb );
    NwReleaseRcb( &NwRcb );
}


NTSTATUS
TreeDisconnectScb(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )
/*++

Routine Description:

    This routine decrements the tree connect count for a SCB.

    ***  This routine must be called with the RCB resource held.

Arguments:

    Scb - A pointer to the SCB to disconnect.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    if ( Scb->AttachCount > 0 ) {

        Scb->AttachCount--;
        Scb->OpenFileCount--;
        NwDereferenceScb( Scb->pNpScb );

        Status = STATUS_SUCCESS;

        if ( Scb->OpenFileCount == 0 ) {

            //
            //  Logoff and disconnect from the server now.
            //  Hold on to the SCB lock.
            //  This prevents another thread from trying to access
            //  SCB will this thread is logging off.
            //

            NwLogoffAndDisconnect( IrpContext, Scb->pNpScb );
        }
    } else {
        Status = STATUS_INVALID_HANDLE;
    }

    NwDequeueIrpContext( IrpContext, FALSE );
    return( Status );
}


VOID
ReconnectScb(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb
    )
/*++

Routine Description:

    This routine reconnects all the dir handles to a server
    when reconnecting an SCB.


Arguments:

    pScb - A pointer to the SCB that has just been reconnected.

Return Value:

    None.

--*/
{
    //
    //  If this is a reconnect, kill all old ICB and VCB handles
    //

    if ( pScb->VcbCount != 0 ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        //  Invalid all ICBs
        //

        NwInvalidateAllHandlesForScb( pScb );
        NwReleaseRcb( &NwRcb );

        //
        //  Acquire new VCB handles for all VCBs.
        //

        NwReopenVcbHandlesForScb( pIrpContext, pScb );
    }
}

NTSTATUS
IndirectToSeedServer(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pNewServer
)
/*+++

    Description: This function takes a server name.  If that server name
    is in the format target_server(seed_server), this routine will:
     
      1) put the target server in pNewServer
      2) lookup the seed server and queue the irp context to it
    
---*/
{

    NTSTATUS Status;
    UNICODE_STRING SeedServer;
    PWCHAR pwCurrent;
    PSCB pScb;
    
    RtlInitUnicodeString( &SeedServer, NULL );
    RtlInitUnicodeString( pNewServer, NULL );

    pwCurrent = pServerName->Buffer;

    DebugTrace( 0, Dbg, "IndirectToSeedServer: %wZ\n", pServerName );

    while ( pNewServer->Length <= pServerName->Length ) {

        if ( *pwCurrent == L'(' ) {

            pNewServer->Buffer = pServerName->Buffer;
            pNewServer->MaximumLength = pNewServer->Length;
            DebugTrace( 0, Dbg, "Target server is %wZ.\n", pNewServer );

            SeedServer.Length = pServerName->Length -
                                pNewServer->Length;

            if ( SeedServer.Length <= ( 2 * sizeof( WCHAR ) ) ) {
                
                SeedServer.Length = 0;

            } else {

                SeedServer.Length -= ( 2 * sizeof( WCHAR ) );
                SeedServer.Buffer = pwCurrent + 1;
                SeedServer.MaximumLength = SeedServer.Length;
                DebugTrace( 0, Dbg, "Seed server is %wZ.\n", &SeedServer );

            }

            break;
            
        } else {

            pNewServer->Length += sizeof( WCHAR );
            pwCurrent++;
        }
    }

    if ( SeedServer.Length == 0 ) {
        DebugTrace( 0, Dbg, "IndirectToSeedServer failed to decode nested name.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now do something about it.
    //

    Status = CreateScb( &pScb,
                        pIrpContext,
                        &SeedServer,
                        NULL,
                        NULL,
                        NULL,
                        TRUE,
                        FALSE );
    
    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "Couldn't contact seed server.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    NwAppendToQueueAndWait( pIrpContext );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\convert.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Convert.h

Abstract:

    This module declares the types used to permit exchange.c to be used
    with minimal change in the NetWare file system.

Author:

    Colin Watson    [ColinW]    23-Dec-1992

Revision History:

--*/

#ifndef _CONVERT_
#define _CONVERT_

#define byte UCHAR
#define word USHORT
#define dword ULONG

#define offsetof(r,f)  ((size_t)&(((r*)0)->f))
#define byteswap(x)    ((x>>8)+((x&0xFF)<<8))

#endif //_CONVERT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\create4.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    create4.c

Abstract:

    This implements the NDS create routines.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include "Procs.h"

#define Dbg (DEBUG_TRACE_NDS)

//
// Pageable.
//

#pragma alloc_text( PAGE, NdsCreateTreeScb )
#pragma alloc_text( PAGE, ConnectBinderyVolume )
#pragma alloc_text( PAGE, HandleVolumeAttach )
#pragma alloc_text( PAGE, NdsGetDsObjectFromPath )
#pragma alloc_text( PAGE, NdsVerifyObject )
#pragma alloc_text( PAGE, NdsVerifyContext )
#pragma alloc_text( PAGE, NdsMapObjectToServerShare )

//
// Not page-able:
//
// NdsSelectConnection (holds a spin lock)
//

NTSTATUS
NdsSelectConnection(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puTreeName,
    PUNICODE_STRING puUserName,
    PUNICODE_STRING puPassword,
    BOOL DeferredLogon,
    BOOL UseBinderyConnections,
    PNONPAGED_SCB *ppNpScb
)
/*++

Routine Description:

    Find a nearby tree connection point for the given tree.

    DeferredLogon tells us whether or not we need to
    initiate a login/authenticate exchange yet.  If we have
    credentials to a tree, we are NOT allowed to hand off
    a connection that has not been logged in because the view
    of the tree may be different from what it is supposed to
    be.

    UseBinderyConnections tells us whether or not we want
    to return bindery authenticated connections as valid
    nds browse points.

Return Value:

    Scb to a server that belongs to the tree we want.

--*/
{

    NTSTATUS Status = STATUS_BAD_NETWORK_PATH;

    PLOGON pLogon;
    PLIST_ENTRY ScbQueueEntry;
    KIRQL OldIrql;

    PNONPAGED_SCB pFirstNpScb, pNextNpScb;
    PNONPAGED_SCB pFoundNpScb = NULL;
    PSCB pScb;
    LARGE_INTEGER Uid;

    PNONPAGED_SCB pOriginalNpScb;
    PSCB pOriginalScb;

    PNDS_SECURITY_CONTEXT pNdsContext;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    BOOL PasswordExpired = FALSE;

    //
    // Save the original server pointers.
    //

    pOriginalNpScb = pIrpContext->pNpScb;
    pOriginalScb = pIrpContext->pScb;

    Uid = pIrpContext->Specific.Create.UserUid;

    //
    // Determine if we need a guest browse connection.
    //

    if ( DeferredLogon ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &Uid, FALSE );
        NwReleaseRcb( &NwRcb );

        if ( pLogon ) {

            Status = NdsLookupCredentials( pIrpContext,
                                           puTreeName,
                                           pLogon,
                                           &pNdsContext,
                                           CREDENTIAL_READ,
                                           FALSE );

            if ( NT_SUCCESS( Status ) ) {

                if ( ( pNdsContext->Credential != NULL ) &&
                     ( pNdsContext->CredentialLocked == FALSE ) ) {

                    DebugTrace( 0, Dbg, "Forcing authenticated browse to %wZ.\n", puTreeName );
                    DeferredLogon = FALSE;
                }

                NwReleaseCredList( pLogon, pIrpContext );
            }
        }
    }

    //
    // Start at the head of the SCB list.
    //

    KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

    if ( ScbQueue.Flink == &ScbQueue ) {
        KeReleaseSpinLock( &ScbSpinLock, OldIrql);
        return STATUS_BAD_NETWORK_PATH;
    }

    ScbQueueEntry = ScbQueue.Flink;
    pFirstNpScb = CONTAINING_RECORD( ScbQueueEntry,
                                     NONPAGED_SCB,
                                     ScbLinks );
    pNextNpScb = pFirstNpScb;

    //
    // Leave the first SCB referenced since we need it to
    // be there for when we walk all the way around the list.
    //

    NwReferenceScb( pFirstNpScb );
    NwReferenceScb( pNextNpScb );

    KeReleaseSpinLock( &ScbSpinLock, OldIrql);

    while ( TRUE ) {

        //
        // Check to see if the SCB we have is in the correct tree
        // and is usable.  Make sure we skip over the permanent
        // npscb since it isn't a tree connection.  The current
        // SCB is always referenced while we're in here.
        //

        if ( pNextNpScb->pScb ) {

            pScb = pNextNpScb->pScb;

            if ( RtlEqualUnicodeString( puTreeName, &pScb->NdsTreeName, TRUE ) &&
                 Uid.QuadPart == pScb->UserUid.QuadPart ) {

               pIrpContext->pNpScb = pNextNpScb;
               pIrpContext->pScb = pNextNpScb->pScb;
               NwAppendToQueueAndWait( pIrpContext );

               switch ( pNextNpScb->State ) {

                    case SCB_STATE_RECONNECT_REQUIRED:

                        //
                        //  Reconnect to the server.  This is not
                        //  a valid path for an anonymous create,
                        //  so there's no chance that we'll get
                        //  a name collision.
                        //

                        Status = ConnectToServer( pIrpContext, NULL );

                        if (!NT_SUCCESS(Status)) {
                            break;
                        }

                        pNextNpScb->State = SCB_STATE_LOGIN_REQUIRED;

                    case SCB_STATE_LOGIN_REQUIRED:

                        //
                        // See if we can login if requested.
                        //

                        if ( !DeferredLogon ) {

                            Status = DoNdsLogon( pIrpContext, puUserName, puPassword );

                            if ( !NT_SUCCESS( Status ) ) {
                                break;
                            }

                            //
                            // If we get a warning from this, we need to return it!
                            //

                            if ( Status == NWRDR_PASSWORD_HAS_EXPIRED ) {
                                PasswordExpired = TRUE;
                            }

                            //
                            // Do we have to re-license the connection?
                            //

                            if ( ( pScb->VcbCount > 0 ) || ( pScb->OpenNdsStreams > 0 ) ) {

                                Status = NdsLicenseConnection( pIrpContext );

                                if ( !NT_SUCCESS( Status ) ) {
                                    Status = STATUS_REMOTE_SESSION_LIMIT;
                                    break;
                                }
                            }

                            pNextNpScb->State = SCB_STATE_IN_USE;
                        }

                   case SCB_STATE_IN_USE:

                        if ( pNextNpScb->State == SCB_STATE_IN_USE ) {

                            if ( ( !UseBinderyConnections ) &&
                                 ( pNextNpScb->pScb->UserName.Length != 0 ) ) {

                                //
                                // We may not want to use a connection that has been
                                // bindery authenticated to read the NDS tree because
                                // we don't have a way to validate that the NDS and
                                // bindery users are the same.
                                //

                                Status = STATUS_ACCESS_DENIED;
                                break;
                            }

                            //
                            // Verify that we have security rights to this server.
                            //

                            Status = CheckScbSecurity( pIrpContext,
                                                       pNextNpScb->pScb,
                                                       puUserName,
                                                       puPassword,
                                                       ( BOOLEAN )DeferredLogon );

                            if ( !NT_SUCCESS( Status ) ) {
                                break;
                            }

                            //
                            // Check SCB security might return with state login required.
                            //

                            if ( ( pNextNpScb->State == SCB_STATE_LOGIN_REQUIRED ) &&
                                 ( !DeferredLogon ) ) {

                                Status = DoNdsLogon( pIrpContext, puUserName, puPassword );

                                if ( !NT_SUCCESS( Status ) ) {
                                    break;
                                }

                                pNextNpScb->State = SCB_STATE_IN_USE;
                            }

                        } else {

                            //
                            // If we picked up an already good SCB and the
                            // login was deferred, set success and continue.
                            //

                            ASSERT( DeferredLogon == TRUE );
                            Status = STATUS_SUCCESS;
                        }

                        pFoundNpScb = pNextNpScb;
                        DebugTrace( 0, Dbg, "NdsSelectConnection: NpScb = %lx\n", pFoundNpScb );
                        break;

                   default:

                       break;

                }

                NwDequeueIrpContext( pIrpContext, FALSE );

                if ( pFoundNpScb ) {
                    ASSERT( NT_SUCCESS( Status ) );
                    break;
                }

                if ( Status == STATUS_WRONG_PASSWORD ||
                     Status == STATUS_NO_SUCH_USER ) {
                    NwDereferenceScb( pNextNpScb );
                    break;
                }

                //
                // Restore the server pointers.
                //

                pIrpContext->pNpScb = pOriginalNpScb;
                pIrpContext->pScb = pOriginalScb;

            }
        }

        //
        // Otherwise, get the next one in the list.  Don't
        // forget to skip the list head.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

        ScbQueueEntry = pNextNpScb->ScbLinks.Flink;

        if ( ScbQueueEntry == &ScbQueue ) {
            ScbQueueEntry = ScbQueue.Flink;
        }

        NwDereferenceScb( pNextNpScb );
        pNextNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        if ( pNextNpScb == pFirstNpScb ) {

            KeReleaseSpinLock( &ScbSpinLock, OldIrql );
            Status = STATUS_BAD_NETWORK_PATH;
            break;
        }

        //
        // Otherwise, reference this SCB and continue.
        //

        NwReferenceScb( pNextNpScb );
        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    }

    NwDereferenceScb( pFirstNpScb );
    *ppNpScb = pFoundNpScb;

    if ( ( NT_SUCCESS( Status ) ) &&
         ( PasswordExpired ) ) {
        Status = NWRDR_PASSWORD_HAS_EXPIRED;
    }

    return Status;
}

NTSTATUS
NdsCreateTreeScb(
    IN PIRP_CONTEXT pIrpContext,
    IN OUT PSCB *ppScb,
    IN PUNICODE_STRING puTree,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    IN BOOLEAN DeferredLogon,
    IN BOOLEAN DeleteOnClose
)
/*++

Description:

    Given a tree name, find us a connection point to the tree.  This is
    done by getting the server addresses out of the bindery and looking
    up the names of the servers for those addresses.

    When we are all done we need to return the preferred connection
    point in ppScb.

Arguments:

    pIrpContext - irp context for this request
    ppScb       - pointer to a pointer to the scb that we want
    puTree      - tree we want to talk to

--*/
{

    NTSTATUS Status;

    PLARGE_INTEGER pUid;
    PNONPAGED_SCB pNpExistingScb;

    UNICODE_STRING UidServerName;
    PSCB pTreeScb = NULL;

    PSCB pNearestTreeScb = NULL;
    PNONPAGED_SCB pNpNearestTreeScb = NULL;

    PSCB pNearbyScb = NULL;
    BOOLEAN fOnNearbyQueue = FALSE;
    PIRP_CONTEXT pExtraIrpContext = NULL;

    UNICODE_STRING ScanTreeName;
    WCHAR ScanBuffer[NDS_TREE_NAME_LEN + 2];
    int i;

    IPXaddress DirServerAddress;
    CHAR DirServerName[MAX_SERVER_NAME_LENGTH];
    ULONG dwLastOid = (ULONG)-1;

    UNICODE_STRING CredentialName;
    PUNICODE_STRING puConnectName;

    PAGED_CODE();

    UidServerName.Buffer = NULL;

    //
    // Make sure the tree name is reasonable, first.
    //

    if ( ( !puTree ) ||
         ( !puTree->Length ) ||
         ( puTree->Length / sizeof( WCHAR ) ) > NDS_TREE_NAME_LEN ) {

        *ppScb = NULL;            //***Terminal Server Merge

        return STATUS_INVALID_PARAMETER;
    }

    //
    // If this is an extended credential create, munge the name.
    //

    RtlInitUnicodeString( &CredentialName, NULL );

    if (  ( pIrpContext->Specific.Create.fExCredentialCreate ) &&
          ( !IsCredentialName( puTree ) ) ) {

        Status = BuildExCredentialServerName( puTree,
                                              puUserName,
                                              &CredentialName );

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

        puConnectName = &CredentialName;

    } else {

        puConnectName = puTree;
    }

    //
    // First check to see if we already have a connection
    // to this tree that we can use...  If so, this will
    // leave the irp context pointed at that server for us.
    //
    // This time around, don't use bindery authenticated
    // connections to browse the tree.
    //

    Status = NdsSelectConnection( pIrpContext,
                                  puConnectName,
                                  puUserName,
                                  puPassword,
                                  DeferredLogon,
                                  FALSE,
                                  &pNpExistingScb );

    if ( NT_SUCCESS( Status ) && pNpExistingScb ) {
        *ppScb = pNpExistingScb->pScb;
        ASSERT( *ppScb != NULL );
        ASSERT( NT_SUCCESS( Status ) );
        goto ExitWithCleanup;
    }

    //
    // If there was an authentication failure, bail out.
    //

    if ( Status == STATUS_NO_SUCH_USER ||
         Status == STATUS_WRONG_PASSWORD ) {
        goto ExitWithCleanup;
        *ppScb = NULL;              //Terminal Server code merge
    }

    //
    // Otherwise, we need to select a dir server.  To do this,
    // we have to look up dir server names by address.  To do
    // this we create an SCB for synchronization with the name
    // *tree*, which isn't a valid server name.
    //

    ScanTreeName.Length = sizeof( WCHAR );
    ScanTreeName.MaximumLength = sizeof( ScanBuffer );
    ScanTreeName.Buffer = ScanBuffer;

    ScanBuffer[0] = L'*';
    RtlAppendUnicodeStringToString( &ScanTreeName, puTree );
    ScanBuffer[( ScanTreeName.Length / sizeof( WCHAR ) )] = L'*';
    ScanTreeName.Length += sizeof( WCHAR );

    //
    // Now make it a uid server name.
    //

    Status = MakeUidServer( &UidServerName,
                            &pIrpContext->Specific.Create.UserUid,
                            &ScanTreeName );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    NwFindScb( &pTreeScb,
               pIrpContext,
               &UidServerName,
               &ScanTreeName );

    if ( !pTreeScb ) {
        DebugTrace( 0, Dbg, "Failed to get a tree scb for synchronization.\n", 0 );
        goto ExitWithCleanup;
    }

    //
    // Get a nearby server connection and prepare to
    // do the bindery scan for tree connection points.
    // Don't forget to copy the user uid for security.
    //

    if ( !NwAllocateExtraIrpContext( &pExtraIrpContext,
                                     pTreeScb->pNpScb ) ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;

    }

    pExtraIrpContext->Specific.Create.UserUid.QuadPart =
        pIrpContext->Specific.Create.UserUid.QuadPart;

    //
    // Append a wildcard to the tree name for the bindery scan.
    //

    ScanTreeName.Length = 0;
    ScanTreeName.MaximumLength = sizeof( ScanBuffer );
    ScanTreeName.Buffer = ScanBuffer;

    RtlCopyUnicodeString( &ScanTreeName, puTree );

    i = ScanTreeName.Length / sizeof( WCHAR );

    while( i <= NDS_TREE_NAME_LEN ) {
       ScanBuffer[i++] = L'_';
    }

    ScanBuffer[NDS_TREE_NAME_LEN] = L'*';
    ScanTreeName.Length = (NDS_TREE_NAME_LEN + 1) * sizeof( WCHAR );

    DebugTrace( 0, Dbg, "Scanning for NDS tree %wZ.\n", puTree );

    //
    // Now we lookup the dir server addresses in the bindery and
    // try to make dir server connections.
    //

    while ( TRUE ) {

        if ( ( pNearbyScb ) && ( !fOnNearbyQueue ) ) {

            //
            // Get back to the head of the nearby server so we can continue
            // looking for dir servers.  If the nearby server is no good anymore,
            // dereference the connection and set the nearby scb pointer to
            // NULL.  This will cause us to get a new nearby server when we
            // continue.
            //

            NwAppendToQueueAndWait( pExtraIrpContext );

            if ( !( ( pNearbyScb->pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) ||
                    ( pNearbyScb->pNpScb->State == SCB_STATE_IN_USE ) ) ) {

                NwDequeueIrpContext( pExtraIrpContext, FALSE );
                NwDereferenceScb( pNearbyScb->pNpScb );
                pNearbyScb = NULL;

                //
                // Don't restart the search.  If our bindery server went down in
                // the middle of a connect, the connect will fail and that's ok.
                // If we restart the search we can end up in this loop forever.
                //

            } else {

                fOnNearbyQueue = TRUE;
            }

        }

        //
        // Get a bindery server to talk to if we don't have one.  This may
        // be our first time through this loop, or our server may have
        // gone bad (see above).
        //
        // Optimization:  What if this CreateScb returns a valid dir server
        // for the tree we are looking for?  We should use it!!
        //

        if ( !pNearbyScb ) {
            Status = CreateScb( &pNearbyScb,
                                pExtraIrpContext,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                TRUE,
                                FALSE );

            if ( !NT_SUCCESS( Status ) ) {
                goto ExitWithCleanup;
            }

            ASSERT( pExtraIrpContext->pNpScb == pNearbyScb->pNpScb );
            ASSERT( pExtraIrpContext->pScb == pNearbyScb );

            NwAppendToQueueAndWait( pExtraIrpContext );
            fOnNearbyQueue = TRUE;

        }

        //
        // Look up the dir server address from our nearby server.
        //

        Status = ExchangeWithWait( pExtraIrpContext,
                                   SynchronousResponseCallback,
                                   "SdwU",
                                   NCP_ADMIN_FUNCTION, NCP_SCAN_BINDERY_OBJECT,
                                   dwLastOid,
                                   OT_DIRSERVER,
                                   &ScanTreeName );

        if ( !NT_SUCCESS( Status ) ) {

            //
            // We're out of options for dir servers.
            //

            Status = STATUS_BAD_NETWORK_PATH;
            break;
        }

        Status = ParseResponse( pExtraIrpContext,
                                pExtraIrpContext->rsp,
                                pExtraIrpContext->ResponseLength,
                                "Nd_r",
                                &dwLastOid,
                                sizeof( WORD ),
                                DirServerName,
                                MAX_SERVER_NAME_LENGTH );

        if ( !NT_SUCCESS( Status ) ) {
            break;
        }

        Status = ExchangeWithWait ( pExtraIrpContext,
                                    SynchronousResponseCallback,
                                    "Swbrbp",
                                    NCP_ADMIN_FUNCTION, NCP_QUERY_PROPERTY_VALUE,
                                    OT_DIRSERVER,
                                    0x30,
                                    DirServerName,
                                    MAX_SERVER_NAME_LENGTH,
                                    1,                       //  Segment number
                                    NET_ADDRESS_PROPERTY );

        if ( !NT_SUCCESS( Status ) ) {

            DebugTrace( 0, Dbg, "No net address property for this dir server.\n", 0 );
            continue;
        }

        Status = ParseResponse( pExtraIrpContext,
                                pExtraIrpContext->rsp,
                                pExtraIrpContext->ResponseLength,
                                "Nr",
                                &DirServerAddress,
                                sizeof(TDI_ADDRESS_IPX) );

        if ( !NT_SUCCESS( Status ) ) {

            DebugTrace( 0, Dbg, "Couldn't parse net address property for this dir server.\n", 0 );
            continue;
        }

        //
        // We get back some odd socket number here, but we really want to
        // connect to the NCP socket.
        //

        DirServerAddress.Socket = NCP_SOCKET;

        //
        // We know the address of the dir server, so do an anonymous
        // create to it.  Use the original irp context so the uid is
        // correct.  Note that we have to dequeue from the nearby scb
        // in case we are referred to that server!
        //

        NwDequeueIrpContext( pExtraIrpContext, FALSE );
        fOnNearbyQueue = FALSE;

        NwDequeueIrpContext( pIrpContext, FALSE );

        Status = CreateScb( &pNearestTreeScb,
                            pIrpContext,
                            NULL,
                            &DirServerAddress,
                            puUserName,
                            puPassword,
                            DeferredLogon,
                            DeleteOnClose );

        if ( !NT_SUCCESS( Status ) ) {

            if ( Status == STATUS_NO_SUCH_USER ||
                 Status == STATUS_WRONG_PASSWORD ||
                 Status == STATUS_ACCESS_DENIED ||
                 Status == STATUS_ACCOUNT_DISABLED ||
                 Status == STATUS_LOGIN_TIME_RESTRICTION ||
                 Status == STATUS_REMOTE_SESSION_LIMIT ||
                 Status == STATUS_CONNECTION_COUNT_LIMIT ||
                 Status == STATUS_NETWORK_CREDENTIAL_CONFLICT ||
                 Status == STATUS_PASSWORD_EXPIRED ) {
               break;
            }

            continue;
        }

        //
        // If the server we got back was bindery authenticated,
        // it is NOT a valid dir server for us to use (yet)!!
        //

        if ( pNearestTreeScb->UserName.Length != 0 ) {

            Status = STATUS_ACCESS_DENIED;
            NwDequeueIrpContext( pIrpContext, FALSE );
            NwDereferenceScb( pNearestTreeScb->pNpScb );

            continue;
        }

        //
        // Otherwise, we're golden.  Break out of here!
        //

        DebugTrace( 0, Dbg, "Dir server: %wZ\n", &pNearestTreeScb->UidServerName );
        *ppScb = pNearestTreeScb;
        ASSERT( NT_SUCCESS( Status ) );
        break;

   }
   //
   // We have been wholly unable to get a browse connection
   // to this tree.  Try again but this time allow the use
   // of connections that are bindery authenticated.  We don't
   // need the nearby server anymore.
   //

   if ( pNearbyScb ) {

       NwDequeueIrpContext( pExtraIrpContext, FALSE );
       NwDereferenceScb( pNearbyScb->pNpScb );
   }

   if ( ( Status != STATUS_SUCCESS ) &&
        ( Status != STATUS_NO_SUCH_USER ) &&
        ( Status != STATUS_WRONG_PASSWORD ) &&
        ( Status != STATUS_ACCESS_DENIED ) &&
        ( Status != STATUS_ACCOUNT_DISABLED ) &&
        ( Status != STATUS_LOGIN_TIME_RESTRICTION ) &&
        ( Status != STATUS_REMOTE_SESSION_LIMIT ) &&
        ( Status != STATUS_CONNECTION_COUNT_LIMIT ) &&
        ( Status != STATUS_NETWORK_CREDENTIAL_CONFLICT ) &&
        ( Status != STATUS_PASSWORD_EXPIRED ) ) {

       Status = NdsSelectConnection( pIrpContext,
                                     puConnectName,
                                     puUserName,
                                     puPassword,
                                     DeferredLogon,
                                     TRUE,
                                     &pNpExistingScb );

       if ( NT_SUCCESS( Status ) && pNpExistingScb ) {
           *ppScb = pNpExistingScb->pScb;
           ASSERT( *ppScb != NULL );
       }
   }

ExitWithCleanup:

    //
    // Clean up and bail.
    //

    if ( pExtraIrpContext ) {
        NwFreeExtraIrpContext( pExtraIrpContext );
    }

    if ( UidServerName.Buffer != NULL ) {
        FREE_POOL( UidServerName.Buffer );
    }

    if ( pTreeScb ) {
        NwDereferenceScb( pTreeScb->pNpScb );
    }

    if ( CredentialName.Buffer ) {
        FREE_POOL( CredentialName.Buffer );
    }

    if (!NT_SUCCESS(Status)) {
        *ppScb = NULL;
    }

    return Status;

}

NTSTATUS
ConnectBinderyVolume(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puServerName,
    PUNICODE_STRING puVolumeName
)
/*++

Description:

    Given a server name and a volume, try to connect the volume.
    This is used in QueryPath to pre-connect a volume.

--*/
{

    NTSTATUS Status;
    PSCB pScb;
    PVCB pVcb;

    PAGED_CODE();

    //
    // Try making a server connection with this name.
    //

    Status = CreateScb( &pScb,
                        pIrpContext,
                        puServerName,
                        NULL,
                        NULL,
                        NULL,
                        FALSE,
                        FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    DebugTrace( 0, Dbg, "Bindery volume connect got server %wZ\n", puServerName );

    //
    // If we succeeded, do a standard bindery volume attach.
    //

    NwAppendToQueueAndWait( pIrpContext );
    NwAcquireOpenLock( );

    try {

        pVcb = NwFindVcb( pIrpContext,
                          puVolumeName,
                          RESOURCETYPE_ANY,
                          0,
                          FALSE,
                          FALSE );

    } finally {

        NwReleaseOpenLock( );

    }

    if ( pVcb == NULL ) {

        Status = STATUS_BAD_NETWORK_PATH;

    } else {

        //
        // We should not have jumped servers since this was explicit.
        //

        ASSERT( pScb == pIrpContext->pScb );

        //
        //  Remove NwFindVcb reference. Don't supply an IrpContext
        //  so the Vcb doesn't get destroyed immediately after we just
        //  created it because no-one else has it referenced.
        //

        NwDereferenceVcb( pVcb, NULL, FALSE );
        DebugTrace( 0, Dbg, "Bindery volume connect got volume %wZ\n", puVolumeName );
    }

    NwDequeueIrpContext( pIrpContext, FALSE );
    NwDereferenceScb( pIrpContext->pNpScb );
    return Status;

}

NTSTATUS
HandleVolumeAttach(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puServerName,
    PUNICODE_STRING puVolumeName
)
/*++

Description:

    This function is only callable from the QUERY_PATH code path!

    This functions takes a server name and volume name from
    QueryPath() and resolves it into a server/volume connection.
    The server/volume name can be plain or can refer to an
    nds tree and the nds path to a volume object.

    In the nds case, we only verify that the volume object exists.

Arguments:

    pIrpContext   - irp context for this request
    puServerName  - server name or nds tree name
    puVolumeName  - volume name or nds path to volume object

--*/
{

    NTSTATUS Status;
    PSCB pScb;

    UNICODE_STRING uDsObject;
    DWORD dwVolumeOid, dwObjectType;

    PAGED_CODE();

    //
    // Try the bindery server/volume case first.
    //

    Status = ConnectBinderyVolume( pIrpContext,
                                   puServerName,
                                   puVolumeName );
    if ( NT_SUCCESS( Status ) ) {
        return Status;
    }

    if ( Status == STATUS_NETWORK_UNREACHABLE ) {

        // IPX is not bound to anything that is currently
        // up (which means it's probably bound only to the
        // RAS WAN wrapper).  Don't waste time looking for
        // a ds tree.
        //

        return STATUS_BAD_NETWORK_PATH;
    }

    //
    // See if this is a tree name and get a ds connection.
    //

    pIrpContext->Specific.Create.NdsCreate = TRUE;

    Status = NdsCreateTreeScb( pIrpContext,
                               &pScb,
                               puServerName,
                               NULL,
                               NULL,
                               TRUE,
                               FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // If we have a tree, resolve the volume object.
    // TRACKING: We should actually check to see if we
    // already have a connection to this object before
    // we hit the ds.
    //

    Status = NdsGetDsObjectFromPath( pIrpContext,
                                     &uDsObject );

    if ( !NT_SUCCESS( Status ) ) {
        NwDereferenceScb( pIrpContext->pNpScb );
        return Status;
    }

    Status = NdsVerifyObject( pIrpContext,           // irp context for the request
                              &uDsObject,            // path to volume object
                              TRUE,                  // allow a server jump
                              DEFAULT_RESOLVE_FLAGS, // resolver flags
                              &dwVolumeOid,          // volume oid from the ds
                              &dwObjectType );       // volume or print queue

    //
    // We may have jumped servers in the VerifyObject code,
    // so just make sure we dereference the correct server.
    //

    NwDereferenceScb( pIrpContext->pNpScb );
    return Status;

}

NTSTATUS
NdsGetDsObjectFromPath(
    IN PIRP_CONTEXT pIrpContext,
    OUT PUNICODE_STRING puDsObject
)
/*++

Description:

    Take the full path from the create irp context and
    extract out the ds path of the desired object.

    The supplied unicode string shouldn't have a buffer;
    it will be set up to point into the user's buffer
    referred to by the irp context.

Arguments:

    pIrpContext - an irp context from a create path request
    puDsObject  - unicode string that will refer to the correct ds path

--*/
{

   DWORD dwPathSeparators;
   USHORT NewHead;

   PAGED_CODE();

   //
   // The VolumeName is one of the following:
   //
   //     \X:\Server\Volume.Object.Path
   //     \Server\Volume.Object.Path
   //

   *puDsObject = pIrpContext->Specific.Create.VolumeName;

   //
   // Skip the leading slash.
   //

   puDsObject->Length -= sizeof( WCHAR );
   puDsObject->Buffer += 1;

   //
   // How many more are there to overcome?
   //

   NewHead = 0;
   dwPathSeparators = pIrpContext->Specific.Create.DriveLetter ? 2 : 1;

   while ( NewHead < puDsObject->Length &&
           dwPathSeparators ) {

       if ( puDsObject->Buffer[NewHead/sizeof(WCHAR)] == OBJ_NAME_PATH_SEPARATOR ) {
           dwPathSeparators--;
       }

       NewHead += sizeof( WCHAR );
   }

   if ( dwPathSeparators ||
        NewHead == puDsObject->Length) {

       //
       // Something wasn't formed right in the volume name.
       //

       return STATUS_BAD_NETWORK_PATH;
   }

   puDsObject->Length -= NewHead;
   puDsObject->Buffer += NewHead/sizeof(WCHAR);

   //
   // If there is a leading dot, skip it.
   //

   if ( puDsObject->Buffer[0] == L'.' ) {

       puDsObject->Length -= sizeof( WCHAR );
       puDsObject->Buffer += 1;
   }

   puDsObject->MaximumLength = puDsObject->Length;

   DebugTrace( 0, Dbg, "DS object: %wZ\n", puDsObject );

   return STATUS_SUCCESS;
}

NTSTATUS
NdsVerifyObject(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puDsObject,
    IN BOOLEAN fAllowServerJump,
    IN DWORD dwResolverFlags,
    OUT PDWORD pdwDsOid,
    OUT PDWORD pdwObjectType
)
/*++

Description:

    This function verifies that a ds path refers to a volume
    object, print queue, or a dir map.  It returns the oid
    of the object.

    If fAllowServerJump is set to false, this simply looks up
    the oid on the current server but doesn't verify the object
    type.  This routine checks all appropriate contexts for the
    object, unlike ResolveNameKm.

Parameters:

    pIrpContext       - irp context for this request, pointed to the ds server
    puDsObject        - path to the object in the ds
    fAllowServerJump  - allow a server jump to take place
    pdwDsOid          - destination of the ds oid of the object
    pdwObjectType     - NDS_OBJECTTYPE_VOLUME, NDS_OBJECTTYPE_QUEUE, or NDS_OBJECTTYPE_DIRMAP

--*/
{

    NTSTATUS Status;

    PNDS_SECURITY_CONTEXT pCredentials = NULL;
    PUNICODE_STRING puAppendableContext;

    UNICODE_STRING uFdnObject;
    WCHAR FdnObject[MAX_NDS_NAME_CHARS];

    PLOGON pLogon;
    PSCB pScb;
    USHORT i;

    LOCKED_BUFFER NdsRequest;
    DWORD dwObjectOid, dwObjectType;

    UNICODE_STRING uVolume;
    UNICODE_STRING uQueue;
    UNICODE_STRING uDirMap;

    UNICODE_STRING uReplyString;
    WCHAR ReplyBuffer[32];
    BOOLEAN fHoldingCredentialList = FALSE;
    BOOLEAN fPartiallyDistinguished = FALSE;

    PLIST_ENTRY ListHead;
    PLIST_ENTRY Entry;
    PNDS_OBJECT_CACHE_ENTRY ObjectEntry = NULL;
    LARGE_INTEGER CurrentTick;
    BOOLEAN UseEntry = FALSE;
    BOOLEAN ObjectCacheLocked = FALSE;

    PAGED_CODE();

    NdsRequest.pRecvBufferVa = NULL;

    //
    // Get the user credentials.
    //

    pScb = pIrpContext->pNpScb->pScb;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &pScb->UserUid, FALSE );
    NwReleaseRcb( &NwRcb );

    //
    // Get the credential.  We don't care if it's locked or
    // not since we're just querying the ds.
    //
    // Also, get to the head of the queue before you grab
    // the credentials and call NdsResolveNameKm
    //

    NwAppendToQueueAndWait ( pIrpContext );

    if ( pLogon ) {

        Status = NdsLookupCredentials( pIrpContext,
                                       &pScb->NdsTreeName,
                                       pLogon,
                                       &pCredentials,
                                       CREDENTIAL_READ,
                                       FALSE );

        if ( NT_SUCCESS( Status ) ) {
            ASSERT( pCredentials != NULL );
            fHoldingCredentialList = TRUE;
        }

    }

    //
    //  Check to see if we have already seen this request.
    //  If the ObjectCacheBuffer is NULL, then there is no cache
    //  for this SCB.
    //

    if( pScb->ObjectCacheBuffer != NULL ) {

        //
        //  Acquire the cache lock so that the cache can be messed with.
        //  This wait should never fail, but if it does, act as if there
        //  is no cache for this SCB.  The lock is released before returning
        //  from this function.
        //

        Status = KeWaitForSingleObject( &(pScb->ObjectCacheLock),
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        if( NT_SUCCESS(Status) ) {

            //
            //  Reference this SCB so it cannot go away, and
            //  remember it is locked and referenced.
            //

            NwReferenceScb( pScb->pNpScb );
            ObjectCacheLocked = TRUE;

            //
            //  Walk the cache looking for a match.
            //

            ListHead = &(pScb->ObjectCacheList);
            Entry = ListHead->Flink;

            while( Entry != ListHead ) {

                ObjectEntry = CONTAINING_RECORD( Entry, NDS_OBJECT_CACHE_ENTRY, Links );

                //
                //  Three things are checked; the object name, the AllowServerJump flag,
                //  and the Resolver flags.  If these all match, then this exact request has
                //  been seen before and the results are already known.  If any one of these
                //  does not match, then the request is different.
                //

                if( RtlEqualUnicodeString( puDsObject,
                                           &(ObjectEntry->ObjectName),
                                           TRUE )                        &&
                    fAllowServerJump == ObjectEntry->AllowServerJump     &&
                    dwResolverFlags == ObjectEntry->ResolverFlags ) {

                    //
                    //  A match was found, but the timeout and SCB must be looked at to
                    //  see if this entry needs to be refreshed.
                    //

                    KeQueryTickCount( &CurrentTick );

                    if( ObjectEntry->Scb != NULL && CurrentTick.QuadPart < ObjectEntry->Timeout.QuadPart ) {

                        UseEntry = TRUE;
                    }

                    //
                    //  If an entry was found, exit the loop.  This needs to
                    //  happen regardless of whether the data in the entry is
                    //  valid.  If the data is not valid, then it will be update
                    //  in the code below.
                    //

                    break;
                }

                Entry = Entry->Flink;
            }

            if( Entry == ListHead ) {

                //
                //  No entry was found.  Reuse the oldest entry in the cache.
                //

                Entry = ListHead->Blink;
                ObjectEntry = CONTAINING_RECORD( Entry, NDS_OBJECT_CACHE_ENTRY, Links );

            } else if( UseEntry == TRUE ) {

                //
                //  An entry was found and its data is up to date.
                //  Just return the data in the cache and save network bandwidth.
                //

                dwObjectOid = ObjectEntry->DsOid;
                dwObjectType = ObjectEntry->ObjectType;

                //
                //  If needed, simulate a server jump by changing the SCB in the IRP_CONTEXT.
                //

                if( ObjectEntry->Scb != pScb ) {

                    NwDequeueIrpContext( pIrpContext, FALSE );

                    NwReferenceScb( ObjectEntry->Scb->pNpScb );
                    pIrpContext->pScb = ObjectEntry->Scb;
                    pIrpContext->pNpScb = ObjectEntry->Scb->pNpScb;
                    NwDereferenceScb( pScb->pNpScb );

                    NwAppendToQueueAndWait( pIrpContext );
                }

                goto CompletedObject;
            }

            //
            //  At this point we are going to reuse an exisiting entry.  If there is an
            //  SCB pointed to by it, dereference it.
            //

            if( ObjectEntry->Scb != NULL ) {

                NwDereferenceScb( ObjectEntry->Scb->pNpScb );
                ObjectEntry->Scb = NULL;
            }
        }
    }

    //
    // Check to see if it's at least partially distinguished already.
    //

    i = 0;
    while (i < puDsObject->Length / sizeof( WCHAR ) ) {

        if ( puDsObject->Buffer[i++] == L'.' ) {
            fPartiallyDistinguished = TRUE;
        }
    }

    //
    // If it's partially distinguished, try it without the context first.
    //

    if ( fPartiallyDistinguished ) {

        Status = NdsResolveNameKm ( pIrpContext,
                                    puDsObject,
                                    &dwObjectOid,
                                    fAllowServerJump,
                                    dwResolverFlags );

        if ( NT_SUCCESS( Status ) ) {

            DebugTrace( 0, Dbg, "VerifyObject: %wZ\n", puDsObject );
            goto GetObjectType;
        }
    }

    //
    // If that failed, or if it wasn't partially distinguished,
    // see if there's a current context we can append.
    //

    if ( ( pCredentials ) &&
         ( pCredentials->CurrentContext.Length ) ) {

        if ( ( puDsObject->Length + pCredentials->CurrentContext.Length ) < sizeof( FdnObject ) ) {

            //
            // Append the context.
            //

            uFdnObject.MaximumLength = sizeof( FdnObject );
            uFdnObject.Buffer = FdnObject;

            RtlCopyMemory( FdnObject, puDsObject->Buffer, puDsObject->Length );
            uFdnObject.Length = puDsObject->Length;

            if ( uFdnObject.Buffer[( uFdnObject.Length / sizeof( WCHAR ) ) - 1] == L'.' ) {
                uFdnObject.Length -= sizeof( WCHAR );
            }

            if ( pCredentials->CurrentContext.Buffer[0] != L'.' ) {
                uFdnObject.Buffer[uFdnObject.Length / sizeof( WCHAR )] = L'.';
                uFdnObject.Length += sizeof( WCHAR );
            }

            RtlCopyMemory( ((BYTE *)FdnObject) + uFdnObject.Length,
                           pCredentials->CurrentContext.Buffer,
                           pCredentials->CurrentContext.Length );

            uFdnObject.Length += pCredentials->CurrentContext.Length;

            //
            // Resolve this name.
            //

            Status = NdsResolveNameKm ( pIrpContext,
                                        &uFdnObject,
                                        &dwObjectOid,
                                        fAllowServerJump,
                                        dwResolverFlags );

            if ( NT_SUCCESS( Status ) ) {

                DebugTrace( 0, Dbg, "VerifyObject: %wZ\n", &uFdnObject );
                goto GetObjectType;
            }

        }

    }

    //
    // This is not a valid name.
    //

    DebugTrace( 0, Dbg, "VerifyObject: No ds object to resolve.\n", 0 );

    if( ObjectCacheLocked == TRUE ) {

        NwDereferenceScb( pScb->pNpScb );

        KeReleaseSemaphore( &(pScb->ObjectCacheLock),
                            0,
                            1,
                            FALSE );

        ObjectCacheLocked = FALSE;
    }

    if ( fHoldingCredentialList ) {
        NwReleaseCredList( pLogon, pIrpContext );
        fHoldingCredentialList = FALSE;
    }

    return STATUS_BAD_NETWORK_PATH;


GetObjectType:

    if ( fHoldingCredentialList ) {
        NwReleaseCredList( pLogon, pIrpContext );
        fHoldingCredentialList = FALSE;
    }

    //
    // If a server jump is not allowed, we don't need to worry
    // about getting the object type.
    //

    if ( !fAllowServerJump ) {
        dwObjectType = 0;
        goto CompletedObject;
    }

    //
    // Resolve the object and get its information.
    //

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        if( ObjectCacheLocked == TRUE ) {

            NwDereferenceScb( pScb->pNpScb );

            KeReleaseSemaphore( &(pScb->ObjectCacheLock),
                                0,
                                1,
                                FALSE );

            ObjectCacheLocked = FALSE;
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = FragExWithWait( pIrpContext,
                             NDSV_READ_ENTRY_INFO,
                             &NdsRequest,
                             "DD",
                             0,
                             dwObjectOid );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Verify that it's a volume object.
    //

    RtlInitUnicodeString( &uVolume, VOLUME_ATTRIBUTE );
    RtlInitUnicodeString( &uQueue, QUEUE_ATTRIBUTE );
    RtlInitUnicodeString( &uDirMap, DIR_MAP_ATTRIBUTE );

    uReplyString.Length = 0;
    uReplyString.MaximumLength = sizeof( ReplyBuffer );
    uReplyString.Buffer = ReplyBuffer;

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_T",
                            sizeof( NDS_RESPONSE_GET_OBJECT_INFO ),
                            &uReplyString );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    dwObjectType = 0;

    if ( !RtlCompareUnicodeString( &uVolume, &uReplyString, FALSE ) ) {
        dwObjectType = NDS_OBJECTTYPE_VOLUME;
    } else if ( !RtlCompareUnicodeString( &uQueue, &uReplyString, FALSE ) ) {
        dwObjectType = NDS_OBJECTTYPE_QUEUE;
    } else if ( !RtlCompareUnicodeString( &uDirMap, &uReplyString, FALSE ) ) {
        dwObjectType = NDS_OBJECTTYPE_DIRMAP;
    }

    if ( !dwObjectType ) {

        DebugTrace( 0, Dbg, "DS object is not a connectable type.\n", 0 );
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto ExitWithCleanup;
    }

CompletedObject:

    //
    //  See if the cache needs to be updated.  If an entry was
    //  found in the cache or the oldest is being replace, then
    //  ObjectEntry will point to that entry, but UseEntry will
    //  be FALSE.  If the data from the cache was used, then
    //  UseEntry will be TRUE.  If the cache is disabled or there
    //  was some other problem, then ObjectEntry will be NULL.
    //

    if( ObjectEntry != NULL && UseEntry == FALSE ) {

        //
        //  Store the results in the cache entry.
        //

        ObjectEntry->DsOid = dwObjectOid;
        ObjectEntry->ObjectType = dwObjectType;

        ObjectEntry->Scb = pIrpContext->pScb;
        NwReferenceScb( ObjectEntry->Scb->pNpScb );

        //
        //  Store the information describing the request.
        //

        ObjectEntry->ResolverFlags = dwResolverFlags;
        ObjectEntry->AllowServerJump = fAllowServerJump;

        RtlCopyUnicodeString( &(ObjectEntry->ObjectName),
                              puDsObject );

        //
        //  Set the timeout.
        //

        KeQueryTickCount( &CurrentTick );
        ObjectEntry->Timeout.QuadPart = CurrentTick.QuadPart + (NdsObjectCacheTimeout * 100);

        //
        //  Remove this entry from wherever it is in the list, and
        //  insert it on the front.
        //

        RemoveEntryList( Entry );
        InsertHeadList( ListHead, Entry );
    }

    if ( pdwDsOid ) {
        *pdwDsOid = dwObjectOid;
    }

    if ( pdwObjectType ) {
        *pdwObjectType = dwObjectType;
    }

    Status = STATUS_SUCCESS;

ExitWithCleanup:

   if( ObjectCacheLocked == TRUE ) {

       NwDereferenceScb( pScb->pNpScb );

       KeReleaseSemaphore( &(pScb->ObjectCacheLock),
                           0,
                           1,
                           FALSE );
   }

   if ( fHoldingCredentialList ) {
       NwReleaseCredList( pLogon, pIrpContext );
   }

   if ( NdsRequest.pRecvBufferVa ) {
       NdsFreeLockedBuffer( &NdsRequest );
   }

   return Status;
}

NTSTATUS
NdsVerifyContext(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puTree,
    PUNICODE_STRING puContext
)
/*++

    Given a context and a tree, verify that the context is a
    valid container in the tree.

    This call may cause the irpcontex to jump servers to an
    referred dir server.  If so, the scb pointers in the irp
    context will be updated, the old server will be dereferenced,
    and the new server will hold the reference for this request.

--*/
{

    NTSTATUS Status;
    DWORD dwOid, dwSubordinates;
    LOCKED_BUFFER NdsRequest;
    PSCB pScb, pTreeScb;
    PNONPAGED_SCB pNpScb;

    PAGED_CODE();

    //
    // Establish a browse connection to the tree we want to query.
    //

    NdsRequest.pRecvBufferVa = NULL;

    pScb = pIrpContext->pScb;
    pNpScb = pIrpContext->pNpScb;

    Status = NdsCreateTreeScb( pIrpContext,
                               &pTreeScb,
                               puTree,
                               NULL,
                               NULL,
                               TRUE,
                               FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        pTreeScb = NULL;
        goto ExitWithCleanup;
    }

    Status = NdsResolveNameKm ( pIrpContext,
                                puContext,
                                &dwOid,
                                TRUE,
                                DEFAULT_RESOLVE_FLAGS );

    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "NdsVerifyContext: resolve failed.\n", 0 );
        goto ExitWithCleanup;
    }

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        NdsRequest.pRecvBufferVa = NULL;
        goto ExitWithCleanup;
    }

    Status = FragExWithWait( pIrpContext,
                             NDSV_READ_ENTRY_INFO,
                             &NdsRequest,
                             "DD",
                             0,
                             dwOid );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Verify that it's a volume object by checking the
    // third DWORD, which is the subordinate count.
    //

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_D",
                            2 * sizeof( DWORD ),
                            &dwSubordinates );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    if ( !dwSubordinates ) {

        DebugTrace( 0, Dbg, "No subordinates in VerifyContext.\n", 0 );
        Status = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    //
    // Success!
    //

ExitWithCleanup:

    //
    // We may have jumped servers in the resolve name call,
    // so make sure we dereference the correct SCB!
    //

    if ( pTreeScb ) {
        NwDereferenceScb( pIrpContext->pNpScb );
    }

    //
    // Restore the connection to the original server.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );
    pIrpContext->pScb = pScb;
    pIrpContext->pNpScb = pNpScb;

    if ( NdsRequest.pRecvBufferVa ) {
        NdsFreeLockedBuffer( &NdsRequest );
    }

    return Status;
}


NTSTATUS
NdsMapObjectToServerShare(
    PIRP_CONTEXT pIrpContext,
    PSCB *ppScb,
    PUNICODE_STRING puServerSharePath,
    BOOLEAN CreateTreeConnection,
    PDWORD pdwObjectId
)
/*++

Description:

    This function takes a pointer to a tree scb and an irp
    context for a create request.  It looks up the ds object
    from the create request in the ds and maps it to
    the appropriate server/share duple.

    The FullPathName and VolumeName strings in the create
    section of the irp context are updated and a connection
    to the real host server is established so that the
    create request can continue as desired.

--*/
{

    NTSTATUS Status;
    LOCKED_BUFFER NdsRequest;

    UNICODE_STRING uServerAttribute;
    UNICODE_STRING uVolumeAttribute;
    UNICODE_STRING uQueueAttribute;
    UNICODE_STRING uPathAttribute;

    UNICODE_STRING uHostServer;
    UNICODE_STRING uRealServerName;
    UNICODE_STRING uHostVolume;
    UNICODE_STRING uHostPath;
    UNICODE_STRING uIntermediateVolume;

    UNICODE_STRING uDsObjectPath;
    DWORD dwObjectOid, dwObjectType, dwDirMapType;

    DWORD dwTotalPathLen;
    USHORT usSrv;
    PSCB pOldScb, pNewServerScb;

    UNICODE_STRING UserName, Password;
    ULONG ShareType;

    PAGED_CODE();

    //
    // Set up strings and buffers.
    //

    RtlInitUnicodeString( &uServerAttribute, HOST_SERVER_ATTRIBUTE );
    RtlInitUnicodeString( &uVolumeAttribute, HOST_VOLUME_ATTRIBUTE );
    RtlInitUnicodeString( &uQueueAttribute, HOST_QUEUE_ATTRIBUTE );
    RtlInitUnicodeString( &uPathAttribute, HOST_PATH_ATTRIBUTE );

    RtlInitUnicodeString( &uHostServer, NULL );
    RtlInitUnicodeString( &uRealServerName, NULL );
    RtlInitUnicodeString( &uHostVolume, NULL );
    RtlInitUnicodeString( &uHostPath, NULL );
    RtlInitUnicodeString( &uIntermediateVolume, NULL );

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    uHostServer.Buffer = ALLOCATE_POOL( PagedPool, 4 * MAX_NDS_NAME_SIZE );

    if ( !uHostServer.Buffer ) {

        NdsFreeLockedBuffer( &NdsRequest );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    uHostServer.MaximumLength = MAX_NDS_NAME_SIZE;

    uHostVolume.Buffer = ( PWCHAR )(((BYTE *)uHostServer.Buffer) + MAX_NDS_NAME_SIZE);
    uHostVolume.MaximumLength = MAX_NDS_NAME_SIZE;

    uHostPath.Buffer = ( PWCHAR )(((BYTE *)uHostVolume.Buffer) + MAX_NDS_NAME_SIZE);
    uHostPath.MaximumLength = MAX_NDS_NAME_SIZE;

    uIntermediateVolume.Buffer = ( PWCHAR )(((BYTE *)uHostPath.Buffer) + MAX_NDS_NAME_SIZE);
    uIntermediateVolume.MaximumLength = MAX_NDS_NAME_SIZE;

    //
    // First get the object id from the ds.
    //

    Status = NdsGetDsObjectFromPath( pIrpContext, &uDsObjectPath );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    pOldScb = pIrpContext->pScb;

    Status = NdsVerifyObject( pIrpContext,
                              &uDsObjectPath,
                              TRUE,            // allow server jumping
                              DEFAULT_RESOLVE_FLAGS,
                              &dwObjectOid,
                              &dwObjectType );

    //
    // We may have jumped servers.
    //

    *ppScb = pIrpContext->pScb;

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // If this is a dir map, grab the target volume and re-verify
    // the object for connectability.
    //

    if ( dwObjectType == NDS_OBJECTTYPE_DIRMAP ) {

        //
        // First get the volume object and path.
        //

        Status = NdsReadAttributesKm( pIrpContext,
                                      dwObjectOid,
                                      &uPathAttribute,
                                      &NdsRequest );

        if ( !NT_SUCCESS( Status )) {
            goto ExitWithCleanup;
        }

        //
        // Dig out the volume path and the directory path.
        //

        Status = ParseResponse( NULL,
                        NdsRequest.pRecvBufferVa,
                        NdsRequest.dwBytesWritten,
                        "G_____S_ST",
                        sizeof( DWORD ),       // completion code
                        sizeof( DWORD ),       // iter handle
                        sizeof( DWORD ),       // info type
                        sizeof( DWORD ),       // attribute count
                        sizeof( DWORD ),       // syntax id
                        NULL,                  // attribute name
                        3 * sizeof( DWORD ),   // unknown
                        &uIntermediateVolume,  // ds volume
                        &uHostPath );          // dir map path

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

        //
        // Verify the target volume object.
        //

        Status = NdsVerifyObject( pIrpContext,
                                  &uIntermediateVolume,
                                  TRUE,
                                  DEFAULT_RESOLVE_FLAGS,
                                  &dwObjectOid,
                                  &dwDirMapType );

        //
        // We may have jumped servers.
        //

        *ppScb = pIrpContext->pScb;

        if ( !NT_SUCCESS( Status )) {
            goto ExitWithCleanup;
        }

        ASSERT( dwDirMapType == NDS_OBJECTTYPE_VOLUME );

    }

    //
    // Get the server (for any connectable object).
    //

    Status = NdsReadStringAttribute( pIrpContext,
                                     dwObjectOid,
                                     &uServerAttribute,
                                     &uHostServer );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Get the host volume or queue.
    //

    if ( dwObjectType == NDS_OBJECTTYPE_VOLUME ||
         dwObjectType == NDS_OBJECTTYPE_DIRMAP ) {

        Status = NdsReadStringAttribute( pIrpContext,
                                         dwObjectOid,
                                         &uVolumeAttribute,
                                         &uHostVolume );

    } else if (  dwObjectType == NDS_OBJECTTYPE_QUEUE ) {

        Status = NdsReadStringAttribute( pIrpContext,
                                         dwObjectOid,
                                         &uQueueAttribute,
                                         &uHostVolume );

    } else {

        Status = STATUS_BAD_NETWORK_PATH;

    }

    if ( !NT_SUCCESS( Status )) {
        goto ExitWithCleanup;
    }

    //
    // Dig out the actual server name from the X.500 name.
    //

    Status = NdsGetServerBasicName( &uHostServer,
                                    &uRealServerName );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Make sure we have enough space in the new buffer to format
    // the new connect string of \X:\Server\Share\Path,
    // \LPTX\Server\Share\Path, or \Server\Share\Path.
    //

    dwTotalPathLen = uRealServerName.Length + uHostVolume.Length;
    dwTotalPathLen += ( sizeof( L"\\\\" ) - sizeof( L"" ) );

    //
    // Account for the correct prefix.  We count on single character
    // drive and printer letters here.  Again, maybe unwise later on.
    //

    if ( pIrpContext->Specific.Create.DriveLetter ) {

        if ( dwObjectType == NDS_OBJECTTYPE_VOLUME ||
             dwObjectType == NDS_OBJECTTYPE_DIRMAP ) {

            dwTotalPathLen += ( sizeof( L"X:\\" ) - sizeof( L"" ) );

        } else if ( dwObjectType == NDS_OBJECTTYPE_QUEUE ) {

           dwTotalPathLen += ( sizeof( L"LPT1\\" ) - sizeof( L"" ) );

        } else {

            Status = STATUS_BAD_NETWORK_PATH;
            goto ExitWithCleanup;
        }
    }

    //
    // Count space for the path and filename if present.
    //

    if ( pIrpContext->Specific.Create.PathName.Length ) {
        dwTotalPathLen += pIrpContext->Specific.Create.PathName.Length;
    }

    if ( dwObjectType == NDS_OBJECTTYPE_DIRMAP ) {
        dwTotalPathLen += uHostPath.Length;
        dwTotalPathLen += ( sizeof( L"\\" ) - sizeof( L"" ) );
    }

    if ( pIrpContext->Specific.Create.FileName.Length ) {
        dwTotalPathLen += pIrpContext->Specific.Create.FileName.Length;
        dwTotalPathLen += ( sizeof( L"\\" ) - sizeof( L"" ) );
    }

    if ( dwTotalPathLen > puServerSharePath->MaximumLength ) {

        DebugTrace( 0 , Dbg, "NdsMapObjectToServerShare: Buffer too small.\n", 0 );
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitWithCleanup;
    }

    //
    // First dequeue the irp context from the dir server we've been
    // talking to, then make the connect to the new server.  We logged
    // in earlier so this will get us an authenticated connection.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );

    //
    // Since it's possible for us to get attaching to a bindery
    // authenticated resource, we have to dig out the user name
    // and password for the create call!!
    //

    ReadAttachEas( pIrpContext->pOriginalIrp,
                   &UserName,
                   &Password,
                   &ShareType,
                   NULL );

    Status = CreateScb( &pNewServerScb,
                        pIrpContext,
                        &uRealServerName,
                        NULL,
                        &UserName,
                        &Password,
                        FALSE,
                        FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    ASSERT( pNewServerScb->pNpScb->State == SCB_STATE_IN_USE );

    NwDereferenceScb( (*ppScb)->pNpScb );
    *ppScb = pNewServerScb;

    //
    // Re-query the OID of the print queue object on this server
    // or it could be wrong.  Do not permit any sort of a server
    // jump this time.
    //

    if ( dwObjectType == NDS_OBJECTTYPE_QUEUE ) {

       Status = NdsVerifyObject( pIrpContext,
                                 &uDsObjectPath,
                                 FALSE,
                                 RSLV_CREATE_ID,
                                 &dwObjectOid,
                                 NULL );

       if ( !NT_SUCCESS( Status )) {
           goto ExitWithCleanup;
       }

    }

    if ( pdwObjectId ) {
        *pdwObjectId = dwObjectOid;
    }

    //
    // Re-format the path strings in the irp context.  The nds share
    // length tells us how much of the NDS share name is interesting
    // for getting the directory handle.
    //

    usSrv = 0;
    pIrpContext->Specific.Create.dwNdsShareLength = 0;

    puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
    puServerSharePath->Length = sizeof( WCHAR );
    usSrv += sizeof( WCHAR );

    //
    // Set the proper prefix for this connect type.
    //

    if ( pIrpContext->Specific.Create.DriveLetter ) {

        if ( dwObjectType == NDS_OBJECTTYPE_QUEUE ) {

            puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = L'L';
            usSrv += sizeof( WCHAR );

            puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = L'P';
            usSrv += sizeof( WCHAR );

            puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = L'T';
            usSrv += sizeof( WCHAR );
        }

        puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] =
            pIrpContext->Specific.Create.DriveLetter;
        usSrv += sizeof( WCHAR );

        if ( dwObjectType != NDS_OBJECTTYPE_QUEUE ) {

            puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = L':';
            usSrv += sizeof( WCHAR );
        }

        puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
        usSrv += sizeof( WCHAR );

        puServerSharePath->Length = usSrv;
    }

    //
    // Append the server name.
    //

    Status = RtlAppendUnicodeStringToString( puServerSharePath, &uRealServerName );
    if (!NT_SUCCESS(Status)) {
        goto ExitWithCleanup;
    }
    usSrv += uRealServerName.Length;

    puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
    puServerSharePath->Length += sizeof( WCHAR );
    usSrv += sizeof( WCHAR );

    //
    // Append the volume for volumes or the full ds path to
    // the print queue for queues.
    //

    if ( dwObjectType == NDS_OBJECTTYPE_VOLUME ||
         dwObjectType == NDS_OBJECTTYPE_DIRMAP ) {

        Status = RtlAppendUnicodeStringToString( puServerSharePath, &uHostVolume );
        if (!NT_SUCCESS(Status)) {
            goto ExitWithCleanup;
        }
        usSrv += uHostVolume.Length;
        pIrpContext->Specific.Create.dwNdsShareLength += uHostVolume.Length;

    } else if ( dwObjectType == NDS_OBJECTTYPE_QUEUE ) {

       Status = RtlAppendUnicodeStringToString( puServerSharePath, &uDsObjectPath );
       if (!NT_SUCCESS(Status)) {
           goto ExitWithCleanup;
       }
       usSrv += uDsObjectPath.Length;
       pIrpContext->Specific.Create.dwNdsShareLength += uDsObjectPath.Length;

    }

    //
    // Append the dir map path.
    //

    if ( dwObjectType == NDS_OBJECTTYPE_DIRMAP ) {

        puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
        puServerSharePath->Length += sizeof( WCHAR );
        usSrv += sizeof( WCHAR );
        pIrpContext->Specific.Create.dwNdsShareLength += sizeof( WCHAR );

        Status = RtlAppendUnicodeStringToString( puServerSharePath, &uHostPath );
        if (!NT_SUCCESS(Status)) {
            goto ExitWithCleanup;
        }
        usSrv += uHostPath.Length;
        pIrpContext->Specific.Create.dwNdsShareLength += uHostPath.Length;

    }

    //
    // Handle the path and file if they exist.
    //

    if ( pIrpContext->Specific.Create.PathName.Length ) {

        ASSERT( dwObjectType != NDS_OBJECTTYPE_QUEUE );
        Status = RtlAppendUnicodeStringToString( puServerSharePath,
                                        &pIrpContext->Specific.Create.PathName );
        if (!NT_SUCCESS(Status)) {
            goto ExitWithCleanup;
        }
        usSrv += pIrpContext->Specific.Create.PathName.Length;

        //
        // If this is a tree connection, then include the path in
        // the share name so that the map point is correct.
        //

        if ( CreateTreeConnection ) {
            pIrpContext->Specific.Create.dwNdsShareLength +=
                pIrpContext->Specific.Create.PathName.Length;
        }
    }

    if ( pIrpContext->Specific.Create.FileName.Length ) {

        ASSERT( dwObjectType != NDS_OBJECTTYPE_QUEUE );

        puServerSharePath->Buffer[usSrv/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
        puServerSharePath->Length += sizeof( WCHAR );
        usSrv += sizeof( WCHAR );

        Status = RtlAppendUnicodeStringToString( puServerSharePath,
                                        &pIrpContext->Specific.Create.FileName );
        if (!NT_SUCCESS(Status)) {
            goto ExitWithCleanup;
        }
        usSrv += pIrpContext->Specific.Create.FileName.Length;

        //
        // If this is a tree connection, then include the file in
        // the share name so that the map point is correct.
        //

        if ( CreateTreeConnection ) {
            pIrpContext->Specific.Create.dwNdsShareLength += sizeof( WCHAR );
            pIrpContext->Specific.Create.dwNdsShareLength +=
                pIrpContext->Specific.Create.FileName.Length;
        }
    }

    //
    // Record the object type in the irp context.
    //

    pIrpContext->Specific.Create.dwNdsObjectType = dwObjectType;

    DebugTrace( 0, Dbg, "DS Object path is %wZ\n", &pIrpContext->Specific.Create.FullPathName );
    DebugTrace( 0, Dbg, "Resolved path is %wZ\n", puServerSharePath );

ExitWithCleanup:


    NdsFreeLockedBuffer( &NdsRequest );
    FREE_POOL( uHostServer.Buffer );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\crypto.h ===
/* crypto.h
 *
 * Prototypes and definitions for services in crypto.c
 *
 * ported to win nt from win 95 on 6/95
 * Cory West
 */

#include <windef.h>

#define CIPHERBLOCKSIZE 8                 // size of RC2 block
#define MAX_RSA_BITS    512               // actually 420
#define MAX_RSA_BYTES   (MAX_RSA_BITS/8)

#define B_PSIZEBITS     210
#define B_PSIZEWORDS    (1 + B_PSIZEBITS/32)

void __cdecl
GenRandomBytes(
    BYTE *output,
    int len
);

//
// Generate an 8 byte key from a seed of the given length.
//

void __cdecl
GenKey8(
    BYTE *keyData,
    int keyDataLen,
    BYTE key8[8]
);

void __cdecl
MD2(
    BYTE *input,
    const int inlen,
    BYTE *output
);

//
// RC2 encrypt and decrypt wrappers.
//

int __cdecl
CBCEncrypt(
    BYTE *key,            // secret key
    BYTE const *ivec,     // initialization vector, NULL implies zero vector
    BYTE *const input,    // plain text
    int inlen,            // size of plaintext
    BYTE *const output,   // encrypted text
    int *outlen,          // OUTPUT: size of encrypted text
    const int checksumlen // size of checksum, if 0 no checksum is used
);

int __cdecl
CBCDecrypt(
    BYTE *key,        // secret key
    BYTE *ivec,       // initialization vector, null ptr implies zero vector
    BYTE *input,      // encrypted text
    int inlen,        // size of encrypted text
    BYTE *output,     // plain text
    int *outlen,      // OUTPUT: size of plaintext
    int checksumlen   // size of checksum; 0=> no checksum
);

//
// Wrappers to the RSA code.
//

int __cdecl
RSAGetInputBlockSize(
    BYTE *keydata,
    int keylen
);

BYTE * __cdecl
RSAGetModulus(
    BYTE *keydata,
    int keylen,
    int *modSize
);

BYTE * _cdecl
RSAGetPublicExponent(
    BYTE *keydata,
    int keylen,
    int *expSize
);

int __cdecl
RSAPack(
    BYTE *input,
    int inlen,
    BYTE *output,
    int blocksize
);

int __cdecl
RSAPublic(
    BYTE *pukeydata,    // BSAFE 1 itemized public key data
    int pukeylen,       // length of BSAFE1 keydata (including sign)
    BYTE *input,        // input block
    int inlen,          // size of input (< modulus)
    BYTE *output        // encrypted block (modulus sized)
);

int __cdecl
RSAPrivate(
    BYTE *prkeydata,
    int prkeylen,
    BYTE *input,
    int inlen,
    BYTE *output
);

int __cdecl
RSAModMpy(
    BYTE *pukeydata,    // BSAFE 1 itemized public key data
    int pukeylen,       // length of BSAFE1 keydata (including sign)
    BYTE *input1,       // input block
    int inlen1,         // size of input (< modulus)
    BYTE *input2,       // multiplier
    int inlen2,         // size of multiplier
    BYTE *output        // encrypted block (modulus sized)
);

int __cdecl
RSAModExp(
    BYTE *pukeydata,    // BSAFE 1 itemized public key data
    int pukeylen,       // length of BSAFE1 keydata (including sign)
    BYTE *input1,       // input block
    int inlen1,         // size of input (< modulus)
    BYTE *exponent,
    int explen,
    BYTE *output        // encrypted block (modulus sized)
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\deviosup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    deviosup.c

Abstract:

    This module implements the memory locking routines for the netware
    redirector.

Author:

    Manny Weiser (mannyw)   10-Mar-1993

Revision History:

--*/

#include "procs.h"

//
// Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwMapUserBuffer )
#pragma alloc_text( PAGE, NwLockUserBuffer )
#endif


VOID
NwMapUserBuffer (
    IN OUT PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *UserBuffer
    )

/*++

Routine Description:

    This routine obtains a usable virtual address for the user buffer
    for the current I/O request in the specified mode.

Arguments:

    Irp - Pointer to the Irp for the request.

    AccessMode - UserMode or KernelMode.

    UserBuffer - Returns pointer to mapped user buffer.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    AccessMode;

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        *UserBuffer = Irp->UserBuffer;
        return;
    }

    //
    // Get a system virtual address for the buffer.
    //

    *UserBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
    return;
}


VOID
NwLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the FSD while still in the user context.

Arguments:

    Irp - Pointer to the IRP for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/

{
    PMDL mdl;

    PAGED_CODE();

    if (Irp->MdlAddress == NULL) {

        //
        // This read is bound for the current process.  Perform the
        // same functions as above, only do not switch processes.
        //

        mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, TRUE, Irp );

        if (mdl == NULL) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        try {

            MmProbeAndLockPages( mdl,
                                 Irp->RequestorMode,
                                 Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            IoFreeMdl( mdl );
            Irp->MdlAddress = NULL;
            ExRaiseStatus( FsRtlNormalizeNtstatus( GetExceptionCode(),
                                                   STATUS_INVALID_USER_BUFFER ));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Debug.c

Abstract:

    This module declares the Debug only code used by the NetWare redirector
    file system.

Author:

    Colin Watson    [ColinW]    05-Jan-1993

Revision History:

--*/
#include "procs.h"
#include <stdio.h>
#include <stdarg.h>

#define LINE_SIZE 511
#define BUFFER_LINES 50


#ifdef NWDBG

#include <stdlib.h>    // rand()
int FailAllocateMdl = 0;

ULONG MaxDump = 256;
CHAR DBuffer[BUFFER_LINES*LINE_SIZE+1];
PCHAR DBufferPtr = DBuffer;

//
// The reference count debug buffer.
//

CHAR RBuffer[BUFFER_LINES*LINE_SIZE+1];
PCHAR RBufferPtr = RBuffer;

LIST_ENTRY MdlList;

VOID
HexDumpLine (
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t,
    USHORT      flag
    );

ULONG
NwMemDbg (
    IN PCH Format,
    ...
    )

//++
//
//  Routine Description:
//
//      Effectively DbgPrint to the debugging console.
//
//  Arguments:
//
//      Same as for DbgPrint
//
//--

{
    va_list arglist;
    int Length;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    Length = _vsnprintf(DBufferPtr, LINE_SIZE, Format, arglist);

    if (Length < 0) {
        DbgPrint( "NwRdr: Message is too long for NwMemDbg\n");
        return 0;
    }

    va_end(arglist);

    ASSERT( Length <= LINE_SIZE );
    ASSERT( Length != 0 );
    ASSERT( DBufferPtr < &DBuffer[BUFFER_LINES*LINE_SIZE+1]);
    ASSERT( DBufferPtr >= DBuffer);

    DBufferPtr += Length;
    DBufferPtr[0] = '\0';

    // Avoid running off the end of the buffer and exit

    if (DBufferPtr >= (DBuffer+((BUFFER_LINES-1) * LINE_SIZE))) {
        DBufferPtr = DBuffer;

    }

    return 0;
}

VOID
RefDbgTrace (
    PVOID Resource,
    DWORD Count,
    BOOLEAN Reference,
    PBYTE FileName,
    UINT Line
)
/**

  Routine Description:

      NwRefDebug logs reference count operations to expose
      reference count errors or leaks in the redirector.

  Arguments:

    Resource  - The object we're adjusting the reference count on.
    Count     - The current count on the object.
    Reference - If TRUE we are doing a REFERENCE.
                Otherwise, we are doing a DEREFERENCE.
    FileName  - The callers file name.
    Line      - The callers line number.

**/
{
    int Length;
    int NextCount;

    //
    // Format the output into a buffer and then print it.
    //

    if ( Reference )
        NextCount = Count + 1;
    else
       NextCount = Count - 1;

    Length = sprintf( RBufferPtr,
                      "%p: R=%p, %lu -> %lu (%s, line %d)\n",
                      (PVOID)PsGetCurrentThread(),
                      Resource,
                      Count,
                      NextCount,
                      FileName,
                      Line );

    if (Length < 0) {
        DbgPrint( "NwRdr: Message is too long for NwRefDbg\n");
        return;
    }

    ASSERT( Length <= LINE_SIZE );
    ASSERT( Length != 0 );
    ASSERT( RBufferPtr < &RBuffer[BUFFER_LINES*LINE_SIZE+1]);
    ASSERT( RBufferPtr >= RBuffer);

    RBufferPtr += Length;
    RBufferPtr[0] = '\0';

    // Avoid running off the end of the buffer and exit

    if (RBufferPtr >= (RBuffer+((BUFFER_LINES-1) * LINE_SIZE))) {
        RBufferPtr = RBuffer;
    }

    return;
}

VOID
RealDebugTrace(
    LONG Indent,
    ULONG Level,
    PCH Message,
    PVOID Parameter
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
    if ( (Level == 0) || (NwMemDebug & Level )) {
        NwMemDbg( Message, PsGetCurrentThread(), 1, "", Parameter );
    }

    if ( (Level == 0) || (NwDebug & Level )) {

        if ( Indent < 0) {
            NwDebugTraceIndent += Indent;
        }

        DbgPrint( Message, PsGetCurrentThread(), NwDebugTraceIndent, "", Parameter );

        if ( Indent > 0) {
            NwDebugTraceIndent += Indent;
        }

        if (NwDebugTraceIndent < 0) {
            NwDebugTraceIndent = 0;
        }
    }
}

VOID
dump(
    IN ULONG Level,
    IN PVOID far_p,
    IN ULONG  len
    )
/*++

Routine Description:
    Dump Min(len, MaxDump) bytes in classic hex dump style if debug
    output is turned on for this level.

Arguments:

    IN Level - 0 if always display. Otherwise only display if a
    corresponding bit is set in NwDebug.

    IN far_p - address of buffer to start dumping from.

    IN len - length in bytes of buffer.

Return Value:

    None.

--*/
{
    ULONG     l;
    char    s[80], t[80];
    PCHAR far_pchar = (PCHAR)far_p;

    if ( (Level == 0) || (NwDebug & Level )) {
        if (len > MaxDump)
            len = MaxDump;

        while (len) {
            l = len < 16 ? len : 16;

            DbgPrint("\n%lx ", far_pchar);
            HexDumpLine (far_pchar, l, s, t, 0);
            DbgPrint("%s%.*s%s", s, 1 + ((16 - l) * 3), "", t);
            NwMemDbg ( "%lx: %s%.*s%s\n",
                        far_pchar, s, 1 + ((16 - l) * 3), "", t);

            len    -= l;
            far_pchar  += l;
        }
        DbgPrint("\n");

    }
}

VOID
dumpMdl(
    IN ULONG Level,
    IN PMDL Mdl
    )
/*++

Routine Description:
    Dump the memory described by each part of a chained Mdl.

Arguments:

    IN Level - 0 if always display. Otherwise only display if a
    corresponding bit is set in NwDebug.

    Mdl - Supplies the addresses of the memory to be dumped.

Return Value:

    None.

--*/
{
    PMDL Next;
    ULONG len;


    if ( (Level == 0) || (NwDebug & Level )) {
        Next = Mdl; len = 0;
        do {

            dump(Level, MmGetSystemAddressForMdlSafe(Next, LowPagePriority), MIN(MmGetMdlByteCount(Next), MaxDump-len));

            len += MmGetMdlByteCount(Next);
        } while ( (Next = Next->Next) != NULL &&
                    len <= MaxDump);
    }
}

VOID
HexDumpLine (
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t,
    USHORT      flag
    )
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

    flag;
}

typedef struct _NW_POOL_HEADER {
    ULONG Signature;
    ULONG BufferSize;
    ULONG BufferType;
    LIST_ENTRY ListEntry;
    ULONG Pad;  // Pad to Q-word align
} NW_POOL_HEADER, *PNW_POOL_HEADER;

typedef struct _NW_POOL_TRAILER {
    ULONG Signature;
} NW_POOL_TRAILER;

typedef NW_POOL_TRAILER UNALIGNED *PNW_POOL_TRAILER;

PVOID
NwAllocatePool(
    ULONG Type,
    ULONG Size,
    BOOLEAN RaiseStatus
    )
{
    PCHAR Buffer;
    PNW_POOL_HEADER PoolHeader;
    PNW_POOL_TRAILER PoolTrailer;

    if ( RaiseStatus ) {
        Buffer = FsRtlAllocatePoolWithTag(
                     Type,
                     sizeof( NW_POOL_HEADER ) + sizeof( NW_POOL_TRAILER ) + Size,
                     'scwn' );
    } else {
#ifndef QFE_BUILD
        Buffer = ExAllocatePoolWithTag(
                     Type,
                     sizeof( NW_POOL_HEADER )+sizeof( NW_POOL_TRAILER )+Size,
                     'scwn' );
#else
        Buffer = ExAllocatePool(
                     Type,
                     sizeof( NW_POOL_HEADER )+sizeof( NW_POOL_TRAILER )+Size );
#endif

        if ( Buffer == NULL ) {
            return( NULL );
        }
    }

    PoolHeader = (PNW_POOL_HEADER)Buffer;
    PoolTrailer = (PNW_POOL_TRAILER)(Buffer + sizeof( NW_POOL_HEADER ) + Size);

    PoolHeader->Signature = 0x11111111;
    PoolHeader->BufferSize = Size;
    PoolHeader->BufferType = Type;

    PoolTrailer->Signature = 0x99999999;

    if ( Type == PagedPool ) {
        ExAcquireResourceExclusive( &NwDebugResource, TRUE );
        InsertTailList( &NwPagedPoolList, &PoolHeader->ListEntry );
        ExReleaseResource( &NwDebugResource );
    } else if ( Type == NonPagedPool ) {
        ExInterlockedInsertTailList( &NwNonpagedPoolList, &PoolHeader->ListEntry, &NwDebugInterlock );
    } else {
        KeBugCheck( RDR_FILE_SYSTEM );
    }

    return( Buffer + sizeof( NW_POOL_HEADER ) );
}

VOID
NwFreePool(
    PVOID Buffer
    )
{
    PNW_POOL_HEADER PoolHeader;
    PNW_POOL_TRAILER PoolTrailer;
    KIRQL OldIrql;

    PoolHeader = (PNW_POOL_HEADER)((PCHAR)Buffer - sizeof( NW_POOL_HEADER ));
    ASSERT( PoolHeader->Signature == 0x11111111 );
    ASSERT( PoolHeader->BufferType == PagedPool ||
            PoolHeader->BufferType == NonPagedPool );

    PoolTrailer = (PNW_POOL_TRAILER)((PCHAR)Buffer + PoolHeader->BufferSize );
    ASSERT( PoolTrailer->Signature == 0x99999999 );

    if ( PoolHeader->BufferType == PagedPool ) {
        ExAcquireResourceExclusive( &NwDebugResource, TRUE );
        RemoveEntryList( &PoolHeader->ListEntry );
        ExReleaseResource( &NwDebugResource );
    } else {
        KeAcquireSpinLock( &NwDebugInterlock, &OldIrql );
        RemoveEntryList( &PoolHeader->ListEntry );
        KeReleaseSpinLock( &NwDebugInterlock, OldIrql );
    }

    ExFreePool( PoolHeader );
}

//
//  Debug functions for allocating and deallocating IRPs and MDLs
//

PIRP
NwAllocateIrp(
    CCHAR Size,
    BOOLEAN ChargeQuota
    )
{
    ExInterlockedIncrementLong( &IrpCount, &NwDebugInterlock );
    return IoAllocateIrp( Size, ChargeQuota );
}

VOID
NwFreeIrp(
    PIRP Irp
    )
{
    ExInterlockedDecrementLong( &IrpCount, &NwDebugInterlock );
    IoFreeIrp( Irp );
}

typedef struct _NW_MDL {
    LIST_ENTRY  Next;
    PUCHAR      File;
    int         Line;
    PMDL        pMdl;
} NW_MDL, *PNW_MDL;

//int DebugLine = 2461;

PMDL
NwAllocateMdl(
    PVOID Va,
    ULONG Length,
    BOOLEAN Secondary,
    BOOLEAN ChargeQuota,
    PIRP Irp,
    PUCHAR FileName,
    int Line
    )
{
    PNW_MDL Buffer;

    static BOOLEAN MdlSetup = FALSE;

    if (MdlSetup == FALSE) {

        InitializeListHead( &MdlList );

        MdlSetup = TRUE;
    }

    if ( FailAllocateMdl != 0 ) {
        if ( ( rand() % FailAllocateMdl ) == 0 ) {
            return(NULL);
        }
    }

#ifndef QFE_BUILD
    Buffer = ExAllocatePoolWithTag(
                 NonPagedPool,
                 sizeof( NW_MDL),
                 'scwn' );
#else
    Buffer = ExAllocatePool(
                 NonPagedPool,
                 sizeof( NW_MDL));
#endif

    if ( Buffer == NULL ) {
        return( NULL );
    }

    ExInterlockedIncrementLong( &MdlCount, &NwDebugInterlock );

    Buffer->File = FileName;
    Buffer->Line = Line;
    Buffer->pMdl = IoAllocateMdl( Va, Length, Secondary, ChargeQuota, Irp );

    ExInterlockedInsertTailList( &MdlList, &Buffer->Next, &NwDebugInterlock );

/*
    if (DebugLine == Line) {
        DebugTrace( 0, DEBUG_TRACE_MDL, "AllocateMdl -> %08lx\n", Buffer->pMdl );
        DebugTrace( 0, DEBUG_TRACE_MDL, "AllocateMdl -> %08lx\n", Line );
    }
*/
    return(Buffer->pMdl);
}

VOID
NwFreeMdl(
    PMDL Mdl
    )
{
    PLIST_ENTRY MdlEntry;
    PNW_MDL Buffer;
    KIRQL OldIrql;

    ExInterlockedDecrementLong( &MdlCount, &NwDebugInterlock );

    KeAcquireSpinLock( &NwDebugInterlock, &OldIrql );
    //  Find the Mdl in the list and remove it.

    for (MdlEntry = MdlList.Flink ;
         MdlEntry != &MdlList ;
         MdlEntry =  MdlEntry->Flink ) {

        Buffer = CONTAINING_RECORD( MdlEntry, NW_MDL, Next );

        if (Buffer->pMdl == Mdl) {

            RemoveEntryList( &Buffer->Next );

            KeReleaseSpinLock( &NwDebugInterlock, OldIrql );

            IoFreeMdl( Mdl );
            DebugTrace( 0, DEBUG_TRACE_MDL, "FreeMDL - %08lx\n", Mdl );
/*
            if (DebugLine == Buffer->Line) {
                DebugTrace( 0, DEBUG_TRACE_MDL, "FreeMdl -> %08lx\n", Mdl );
                DebugTrace( 0, DEBUG_TRACE_MDL, "FreeMdl -> %08lx\n", Buffer->Line );
            }
*/
            ExFreePool(Buffer);

            return;
        }
    }
    ASSERT( FALSE );

    KeReleaseSpinLock( &NwDebugInterlock, OldIrql );
}

/*
VOID
NwLookForMdl(
    )
{
    PLIST_ENTRY MdlEntry;
    PNW_MDL Buffer;
    KIRQL OldIrql;

    KeAcquireSpinLock( &NwDebugInterlock, &OldIrql );
    //  Find the Mdl in the list and remove it.

    for (MdlEntry = MdlList.Flink ;
         MdlEntry != &MdlList ;
         MdlEntry =  MdlEntry->Flink ) {

        Buffer = CONTAINING_RECORD( MdlEntry, NW_MDL, Next );

        if (Buffer->Line == DebugLine) {

            DebugTrace( 0, DEBUG_TRACE_MDL, "LookForMdl -> %08lx\n", Buffer );
            DbgBreakPoint();

        }
    }

    KeReleaseSpinLock( &NwDebugInterlock, OldIrql );
}
*/

//
//  Function version of resource macro, to make debugging easier.
//

VOID
NwAcquireExclusiveRcb(
    PRCB Rcb,
    BOOLEAN Wait )
{
    ExAcquireResourceExclusive( &((Rcb)->Resource), Wait );
}

VOID
NwAcquireSharedRcb(
    PRCB Rcb,
    BOOLEAN Wait )
{
    ExAcquireResourceShared( &((Rcb)->Resource), Wait );
}

VOID
NwReleaseRcb(
    PRCB Rcb )
{
    ExReleaseResource( &((Rcb)->Resource) );
}

VOID
NwAcquireExclusiveFcb(
    PNONPAGED_FCB pFcb,
    BOOLEAN Wait )
{
    ExAcquireResourceExclusive( &((pFcb)->Resource), Wait );
}

VOID
NwAcquireSharedFcb(
    PNONPAGED_FCB pFcb,
    BOOLEAN Wait )
{
    ExAcquireResourceShared( &((pFcb)->Resource), Wait );
}

VOID
NwReleaseFcb(
    PNONPAGED_FCB pFcb )
{
    ExReleaseResource( &((pFcb)->Resource) );
}

VOID
NwAcquireOpenLock(
    VOID
    )
{
    ExAcquireResourceExclusive( &NwOpenResource, TRUE );
}

VOID
NwReleaseOpenLock(
    VOID
    )
{
    ExReleaseResource( &NwOpenResource );
}


//
// code to dump ICBs
//

VOID DumpIcbs(VOID)
{
    PVCB Vcb;
    PFCB Fcb;
    PICB Icb;
    PLIST_ENTRY VcbListEntry;
    PLIST_ENTRY FcbListEntry;
    PLIST_ENTRY IcbListEntry;
    KIRQL OldIrql;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    DbgPrint("\nICB      Pid      State    Scb/Fcb  Name\n", 0);
    for ( VcbListEntry = GlobalVcbList.Flink;
          VcbListEntry != &GlobalVcbList ;
          VcbListEntry = VcbListEntry->Flink ) {

        Vcb = CONTAINING_RECORD( VcbListEntry, VCB, GlobalVcbListEntry );

        for ( FcbListEntry = Vcb->FcbList.Flink;
              FcbListEntry != &(Vcb->FcbList) ;
              FcbListEntry = FcbListEntry->Flink ) {

            Fcb = CONTAINING_RECORD( FcbListEntry, FCB, FcbListEntry );

            for ( IcbListEntry = Fcb->IcbList.Flink;
                  IcbListEntry != &(Fcb->IcbList) ;
                  IcbListEntry = IcbListEntry->Flink ) {

                Icb = CONTAINING_RECORD( IcbListEntry, ICB, ListEntry );

                DbgPrint("%08lx", Icb);
                DbgPrint(" %08lx",(DWORD)Icb->Pid);
                DbgPrint(" %08lx",Icb->State);
                DbgPrint(" %08lx",Icb->SuperType.Scb);
                DbgPrint(" %wZ\n",
                           &(Icb->FileObject->FileName) );
            }
        }
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );
    NwReleaseRcb( &NwRcb );
}

#endif // ifdef NWDBG

//
// Ref counting debug routines.
//

#ifdef NWDBG

VOID
ChkNwReferenceScb(
    PNONPAGED_SCB pNpScb,
    PBYTE FileName,
    UINT Line,
    BOOLEAN Silent
) {

    if ( (pNpScb)->NodeTypeCode != NW_NTC_SCBNP ) {
        DbgBreakPoint();
    }

    if ( !Silent) {
        RefDbgTrace( pNpScb, pNpScb->Reference, TRUE, FileName, Line );
    }

    ExInterlockedIncrementLong( &(pNpScb)->Reference, &(pNpScb)->NpScbInterLock );
}

VOID
ChkNwDereferenceScb(
    PNONPAGED_SCB pNpScb,
    PBYTE FileName,
    UINT Line,
    BOOLEAN Silent
) {

    if ( (pNpScb)->Reference == 0 ) {
        DbgBreakPoint();
    }

    if ( (pNpScb)->NodeTypeCode != NW_NTC_SCBNP ) {
        DbgBreakPoint();
    }

    if ( !Silent ) {
        RefDbgTrace( pNpScb, pNpScb->Reference, FALSE, FileName, Line );
    }

    ExInterlockedDecrementLong( &(pNpScb)->Reference, &(pNpScb)->NpScbInterLock );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\data.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Data.h

Abstract:

    This module declares the global data used by the NetWare redirector
    file system.

Author:

    Colin Watson     [ColinW]        15-Dec-1992
    Anoop Anantha    [AnoopA]        24-Jun-1998

Revision History:

--*/

#ifndef _NWDATA_
#define _NWDATA_

extern PEPROCESS FspProcess;
extern PDEVICE_OBJECT FileSystemDeviceObject;
extern RCB NwRcb;

extern KSPIN_LOCK ScbSpinLock;
extern KSPIN_LOCK NwTimerSpinLock;
extern LIST_ENTRY ScbQueue;
extern NONPAGED_SCB NwPermanentNpScb;
extern SCB NwPermanentScb;

extern LARGE_INTEGER NwMaxLarge;
extern ULONG NwAbsoluteTotalWaitTime;

extern TDI_ADDRESS_IPX OurAddress;
extern UNICODE_STRING IpxTransportName;
extern HANDLE IpxHandle;
extern PDEVICE_OBJECT pIpxDeviceObject;
extern PFILE_OBJECT pIpxFileObject;

extern LIST_ENTRY LogonList;
extern LOGON Guest;
extern LARGE_INTEGER DefaultLuid;

extern LIST_ENTRY GlobalVcbList;
extern ULONG CurrentVcbEntry;

//
//  Drive mapping table of redirected drives.
//

extern PVCB GlobalDriveMapTable[];                  //Terminal Server merge
//  NDS Preferred Server from registry key
extern UNICODE_STRING NDSPreferredServer;           //Terminal Server merge
extern WCHAR NDSPrefSvrName[];                      //Terminal Server merge

//extern PVCB DriveMapTable[];

//
//  The global structure used to contain our fast I/O callbacks
//

extern FAST_IO_DISPATCH NwFastIoDispatch;

//
//  Configurable paramaters
//

extern SHORT DefaultRetryCount;

extern ULONG NwScavengerTickCount;
extern ULONG NwScavengerTickRunCount;
extern KSPIN_LOCK NwScavengerSpinLock;

extern LIST_ENTRY NwGetMessageList;
extern KSPIN_LOCK NwMessageSpinLock;

extern LIST_ENTRY NwPendingLockList;
extern KSPIN_LOCK NwPendingLockSpinLock;

extern ERESOURCE NwOpenResource;

extern LONG PreferNDSBrowsing;

#if 0
extern LIST_ENTRY FnList;  // HACKHACK
#endif

extern BOOLEAN NwBurstModeEnabled;
extern ULONG NwMaxSendSize;
extern ULONG NwMaxReceiveSize;
extern ULONG NwPrintOptions;
extern UNICODE_STRING NwProviderName;

extern LONG MaxSendDelay;
extern LONG MaxReceiveDelay;
extern LONG MinSendDelay;
extern LONG MinReceiveDelay;
extern LONG BurstSuccessCount;
extern LONG BurstSuccessCount2;
extern LONG AllowGrowth;
extern LONG DontShrink;
extern LONG SendExtraNcp;
extern LONG DefaultMaxPacketSize;
extern LONG PacketThreshold;
extern LONG LargePacketAdjustment;
extern LONG LipPacketAdjustment;
extern LONG LipAccuracy;
extern LONG MaxWriteTimeout;
extern LONG MaxReadTimeout;
extern LONG WriteTimeoutMultiplier;
extern LONG ReadTimeoutMultiplier;

extern ULONG DisableAltFileName;

#define MAX_NDS_OBJECT_CACHE_SIZE                (0x00000080)
extern ULONG NdsObjectCacheSize;
#define MAX_NDS_OBJECT_CACHE_TIMEOUT             (0x00000258)  // (10 minutes)
extern ULONG NdsObjectCacheTimeout;

extern ULONG EnableMultipleConnects;
extern ULONG AllowSeedServerRedirection;

extern ULONG ReadExecOnlyFiles;

extern KQUEUE   KernelQueue;
extern BOOLEAN  WorkerThreadRunning;
extern HANDLE   WorkerThreadHandle;

#ifdef _PNP_POWER_

extern BOOLEAN fSomePMDevicesAreActive;
extern BOOLEAN fPoweringDown;

#endif

extern LONG Japan;     //  Controls special DBCS translation
extern LONG Korean;     //  Controls special Korean translation
extern LONG DisableReadCache ;
extern LONG DisableWriteCache ;
extern LONG FavourLongNames ;           // use LFN where possible

extern DWORD LongNameFlags;
#define LFN_FLAG_DISABLE_LONG_NAMES     (0x00000001)
extern ULONG DirCacheEntries;
#define MAX_DIR_CACHE_ENTRIES                    (0x00000080)

extern LARGE_INTEGER TimeOutEventInterval;

extern NW_REDIR_STATISTICS Stats;
extern ULONG ContextCount;

extern SECTION_DESCRIPTOR NwSectionDescriptor;
extern ERESOURCE NwUnlockableCodeResource;

extern ULONG LockTimeoutThreshold;

#ifndef _PNP_POWER_

extern HANDLE TdiBindingHandle;
extern UNICODE_STRING TdiIpxDeviceName;

#endif

extern BOOLEAN DelayedProcessLineChange;
extern PIRP DelayedLineChangeIrp;

#ifdef NWDBG

#define DEBUG_TRACE_ALWAYS               (0x00000000)
#define DEBUG_TRACE_CLEANUP              (0x00000001)
#define DEBUG_TRACE_CLOSE                (0x00000002)
#define DEBUG_TRACE_CREATE               (0x00000004)
#define DEBUG_TRACE_FSCTRL               (0x00000008)
#define DEBUG_TRACE_IPX                  (0x00000010)
#define DEBUG_TRACE_LOAD                 (0x00000020)
#define DEBUG_TRACE_EXCHANGE             (0x00000040)
#define DEBUG_TRACE_FILOBSUP             (0x00000080)
#define DEBUG_TRACE_STRUCSUP             (0x00000100)
#define DEBUG_TRACE_FSP_DISPATCHER       (0x00000200)
#define DEBUG_TRACE_FSP_DUMP             (0x00000400)
#define DEBUG_TRACE_WORKQUE              (0x00000800)
#define DEBUG_TRACE_UNWIND               (0x00001000)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00002000)
#define DEBUG_TRACE_ICBS                 (0x00004000)
#define DEBUG_TRACE_FILEINFO             (0x00008000)
#define DEBUG_TRACE_DIRCTRL              (0x00010000)
#define DEBUG_TRACE_CONVERT              (0x00020000)
#define DEBUG_TRACE_WRITE                (0x00040000)
#define DEBUG_TRACE_READ                 (0x00080000)
#define DEBUG_TRACE_VOLINFO              (0x00100000)
#define DEBUG_TRACE_LOCKCTRL             (0x00200000)
#define DEBUG_TRACE_USERNCP              (0x00400000)
#define DEBUG_TRACE_SECURITY             (0x00800000)
#define DEBUG_TRACE_CACHE                (0x01000000)
#define DEBUG_TRACE_LIP                  (0x02000000)
#define DEBUG_TRACE_MDL                  (0x04000000)
#define DEBUG_TRACE_PNP                  (0x08000000)

#define DEBUG_TRACE_NDS                  (0x10000000)
#define DEBUG_TRACE_SCAVENGER            (0x40000000)
#define DEBUG_TRACE_TIMER                (0x80000000)

extern ULONG NwDebug;
extern ULONG NwMemDebug;
extern LONG NwDebugTraceIndent;

#define DebugTrace( I, L, M, P )  RealDebugTrace( I, L, "%08lx: %*s"M, (PVOID)(P) )

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                \
        DebugTrace(0, DEBUG_TRACE_UNWIND, #X ", Abnormal termination.\n", 0); \
    }                                                                         \
}

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG NwFsdEntryCount;
extern ULONG NwFspEntryCount;
extern ULONG NwIoCallDriverCount;
extern ULONG NwTotalTicks[];

extern KSPIN_LOCK NwDebugInterlock;
extern ERESOURCE NwDebugResource;

extern LIST_ENTRY NwPagedPoolList;
extern LIST_ENTRY NwNonpagedPoolList;

extern ULONG MdlCount;
extern ULONG IrpCount;

#define DebugDoit(X)                     {X;}

extern LONG NwPerformanceTimerLevel;

#define TimerStart(LEVEL) {                                     \
    LARGE_INTEGER TStart, TEnd;                                 \
    LARGE_INTEGER TElapsed;                                     \
    TStart = KeQueryPerformanceCounter( NULL );                 \

#define TimerStop(LEVEL,s)                                      \
    TEnd = KeQueryPerformanceCounter( NULL );                   \
    TElapsed = RtlLargeIntegerSubtract( TEnd, TStart );         \
 /* NwTotalTicks[NwLogOf(LEVEL)] += TElapsed.LowPart;       */  \
    if (FlagOn( NwPerformanceTimerLevel, (LEVEL))) {            \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart );   \
    }                                                           \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define DebugDoit(X)                     {NOTHING;}

#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)

#endif // NWDBG

#endif // _NWDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\create.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for the NetWare
    redirector called by the dispatch driver.

Author:

    Colin Watson    [ColinW]    19-Dec-1992
    Manny Weiser    [MannyW]    15-Feb-1993

Revision History:

--*/

#include "Procs.h"

NTSTATUS
NwCommonCreate (
    IN PIRP_CONTEXT IrpContext
    );

IO_STATUS_BLOCK
OpenRedirector(
    IN PIRP_CONTEXT IrpContext,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    PFILE_OBJECT FileObject
    );

IO_STATUS_BLOCK
CreateRemoteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING DriveName
    );

IO_STATUS_BLOCK
ChangeDirectory(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb
    );

IO_STATUS_BLOCK
CreateDir(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb
    );

NTSTATUS
FileOrDirectoryExists(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    PUNICODE_STRING Name,
    OUT PBOOLEAN IsAFile
    );

IO_STATUS_BLOCK
OpenFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE SearchFlags,
    IN BYTE ShareFlags
    );

IO_STATUS_BLOCK
CreateNewFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE SearchFlags,
    IN BYTE ShareFlags
    );

IO_STATUS_BLOCK
CreateOrOverwriteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE CreateAttributes,
    IN BYTE OpenFlags,
    IN BOOLEAN CreateOperation
    );

IO_STATUS_BLOCK
OpenRenameTarget(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB Dcb,
    IN PICB* Icb
    );

IO_STATUS_BLOCK
CreatePrintJob(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb,
    PUNICODE_STRING DriveName
    );

VOID
CloseFile(
    PIRP_CONTEXT pIrpContext,
    PICB pIcb
    );


BOOLEAN
MmDisableModifiedWriteOfSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer
    );

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdCreate )
#pragma alloc_text( PAGE, NwCommonCreate )
#pragma alloc_text( PAGE, ReadAttachEas )
#pragma alloc_text( PAGE, OpenRedirector )
#pragma alloc_text( PAGE, CreateRemoteFile )
#pragma alloc_text( PAGE, ChangeDirectory )
#pragma alloc_text( PAGE, CreateDir )
#pragma alloc_text( PAGE, FileOrDirectoryExists )
#pragma alloc_text( PAGE, OpenFile )
#pragma alloc_text( PAGE, CreateNewFile )
#pragma alloc_text( PAGE, CreateOrOverwriteFile )
#pragma alloc_text( PAGE, OpenRenameTarget )
#pragma alloc_text( PAGE, CreatePrintJob )
#pragma alloc_text( PAGE, CloseFile )
#endif


NTSTATUS
NwFsdCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    DeviceObject - Supplies the device object for the redirector.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    TimerStart(Dbg);
    DebugTrace(+1, Dbg, "NwFsdCreate\n", 0);

    //
    //  Call the common create routine, with block allowed if the operation
    //  is synchronous.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        IrpContext = AllocateIrpContext( Irp );
        Status = NwCommonCreate( IrpContext );

    } except( NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( IrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = Status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            Status = NwProcessException( IrpContext, GetExceptionCode() );
        }
    }

    if ( IrpContext  ) {
        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, Status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdCreate -> %08lx\n", Status );

    TimerStop(Dbg,"NwFsdCreate");

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);
}


NTSTATUS
NwCommonCreate (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file called by
    both the fsd and fsp threads.

Arguments:

    IrpContext - Supplies the context information for the IRP to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    ULONG Options;
    BOOLEAN CreateTreeConnection;
    BOOLEAN DeleteOnClose;
    BOOLEAN DeferredLogon;
    BOOLEAN DereferenceCodeSection = FALSE;
    BOOLEAN OpenedTreeHandle = FALSE;

    BOOLEAN fNDSLookupFirst = FALSE;
    USHORT  iBufferIndex = 0;
    DWORD   dwSlashCount = 0;

    UNICODE_STRING CreateFileName;
    UNICODE_STRING Drive;
    UNICODE_STRING Server;
    UNICODE_STRING Volume;
    UNICODE_STRING Path;
    UNICODE_STRING FileName;
    UNICODE_STRING UserName, Password;
    ULONG ShareType;
    WCHAR DriveLetter;
    DWORD dwExtendedCreate = FALSE;

    PSCB Scb = NULL;
    PICB Icb;
    UNICODE_STRING DefaultServer;
    SECURITY_SUBJECT_CONTEXT SubjectContext;


    PAGED_CODE();

    //
    //  Get the current IRP stack location
    //

    Irp = IrpContext->pOriginalIrp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // tommye - MS bug 30091 / MCS 262 - added some safety nets around those pointers
    // containing pointers so we don't bugcheck in the debug code.
    //

    DebugTrace(+1, Dbg, "NwCommonCreate\n", 0 );
    DebugTrace( 0, Dbg, "Irp                       = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "->Flags                   = %08lx\n", Irp->Flags );
    DebugTrace( 0, Dbg, "->FileObject              = %08lx\n", IrpSp->FileObject );
    if (IrpSp->FileObject) {
        DebugTrace( 0, Dbg, " ->RelatedFileObject      = %08lx\n", IrpSp->FileObject->RelatedFileObject );
        DebugTrace( 0, Dbg, " ->FileName               = \"%wZ\"\n",    &IrpSp->FileObject->FileName );
    }
    DebugTrace( 0, Dbg, "->AllocationSize.LowPart  = %08lx\n", Irp->Overlay.AllocationSize.LowPart );
    DebugTrace( 0, Dbg, "->AllocationSize.HighPart = %08lx\n", Irp->Overlay.AllocationSize.HighPart );
    DebugTrace( 0, Dbg, "->SystemBuffer            = %08lx\n", Irp->AssociatedIrp.SystemBuffer );
    DebugTrace( 0, Dbg, "->IrpSp->Flags            = %08lx\n", IrpSp->Flags );
    if (IrpSp->Parameters.Create.SecurityContext) {
        DebugTrace( 0, Dbg, "->DesiredAccess           = %08lx\n", IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    }
    DebugTrace( 0, Dbg, "->Options                 = %08lx\n", IrpSp->Parameters.Create.Options );
    DebugTrace( 0, Dbg, "->Disposition             = %08lx\n", (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);
    DebugTrace( 0, Dbg, "->FileAttributes          = %04x\n",  IrpSp->Parameters.Create.FileAttributes );
    DebugTrace( 0, Dbg, "->ShareAccess             = %04x\n",  IrpSp->Parameters.Create.ShareAccess );
    DebugTrace( 0, Dbg, "->EaLength                = %08lx\n", IrpSp->Parameters.Create.EaLength );

    CreateFileName    = IrpSp->FileObject->FileName;
    Options           = IrpSp->Parameters.Create.Options;
    DesiredAccess     = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    ShareAccess       = IrpSp->Parameters.Create.ShareAccess;

    CreateTreeConnection    = BooleanFlagOn( Options, FILE_CREATE_TREE_CONNECTION );
    DeleteOnClose           = BooleanFlagOn( Options, FILE_DELETE_ON_CLOSE );

    DefaultServer.Buffer = NULL;

    //
    //  Make sure the input large integer is valid
    //

    if (Irp->Overlay.AllocationSize.HighPart != 0) {

        DebugTrace(-1, Dbg, "NwCommonCreate -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Fail requests that don't have the proper impersonation level.
    //

    /* This test is overly restrictive and unnecessary
    if ( IrpSp->Parameters.Create.SecurityContext ) {

        if ( IrpSp->Parameters.Create.SecurityContext->SecurityQos ) {

            if ( IrpSp->Parameters.Create.SecurityContext->SecurityQos->ImpersonationLevel <
                 SecurityImpersonation ) {

                DebugTrace(-1, Dbg, "NwCommonCreate -> Insufficient impersation level.\n", 0);
                return STATUS_ACCESS_DENIED;
            }
        }
    }
    */

    Iosb.Status = STATUS_SUCCESS;

    FileObject        = IrpSp->FileObject;
    IrpContext->pNpScb = NULL;

    IrpContext->Specific.Create.UserUid =
        GetUid(&IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext);

    try {

        if ( IrpSp->FileObject->RelatedFileObject != NULL ) {

            //
            //  If we open a handle then the DereferenceCodeSection flag
            //  will be set to false. The dereference will eventually
            //  happen when the file is closed.
            //

            NwReferenceUnlockableCodeSection();
            DereferenceCodeSection = TRUE;

            //
            // Record the relative file name for this open.
            //

            IrpContext->Specific.Create.FullPathName = CreateFileName;

            Iosb = CreateRemoteFile( IrpContext, NULL );

            //
            // If we succeeded, we want to keep the code section
            // referenced because we have opened a handle.
            //

            if ( NT_SUCCESS( Iosb.Status ) ) {
                DereferenceCodeSection = FALSE;
            }

            try_return( Iosb.Status );
        }

        Iosb.Status = CrackPath (
                          &CreateFileName,
                          &Drive,
                          &DriveLetter,
                          &Server,
                          &Volume,
                          &Path,
                          &FileName,
                          NULL );

        if ( !NT_SUCCESS(Iosb.Status)) {
            try_return(Iosb.Status);
        }

        //
        //  Remember this good info.
        //

        IrpContext->Specific.Create.VolumeName = Volume;
        IrpContext->Specific.Create.PathName = Path;
        IrpContext->Specific.Create.DriveLetter = DriveLetter;
        IrpContext->Specific.Create.FileName = FileName;
        IrpContext->Specific.Create.FullPathName = CreateFileName;

        RtlInitUnicodeString( &IrpContext->Specific.Create.UidConnectName, NULL );


        //
        //  For now assume default username and password
        //

        ShareType = RESOURCETYPE_ANY;
        RtlInitUnicodeString( &UserName, NULL );
        RtlInitUnicodeString( &Password, NULL );

        if ((Server.Length == 0) && (CreateFileName.Length == 0)) {

            //
            //  Opened the redirector itself
            //

            Iosb = OpenRedirector(
                       IrpContext,
                       DesiredAccess,
                       ShareAccess,
                       FileObject );

        } else if ( Server.Length == Volume.Length - sizeof( WCHAR ) ) {

            if (IpxHandle == 0 ) {

                //
                //  We're not bound to the transport and the user is not
                //  opening the redirector to tell us to bind so return failed.
                //

                try_return( Iosb.Status = STATUS_REDIRECTOR_NOT_STARTED );
            }

            NwReferenceUnlockableCodeSection();
            DereferenceCodeSection = TRUE;

            //
            //  If the only requested access is FILE_LIST_DIRECTORY,
            //  defer the logon.  This will allow all CreateScb to
            //  succeed with when the user or password is invalid, so
            //  that the user can see volumes, or enumerate servers
            //  on the server.
            //

            if ( (DesiredAccess & ~( FILE_LIST_DIRECTORY | SYNCHRONIZE ) ) == 0 ) {
                DeferredLogon = TRUE;
            } else {
                DeferredLogon = FALSE;
            }

            //
            //  Server = "Server", Volume = "\Server"
            //

            if ( Server.Length == sizeof(WCHAR) && Server.Buffer[0] == L'*') {

                //
                //  Attempt to open \\*, open a handle to the preferred
                //  server
                //

                PLOGON Logon;

                NwAcquireExclusiveRcb( &NwRcb, TRUE );

                Logon = FindUser( &IrpContext->Specific.Create.UserUid, FALSE);
                ASSERT( Logon != NULL );

                //
                //  Capture the name to avoid holding Rcb or referencing
                //  the logon structure.
                //

                Iosb.Status = DuplicateUnicodeStringWithString (
                                    &DefaultServer,
                                    &Logon->ServerName,
                                    PagedPool);

                NwReleaseRcb( &NwRcb );

                if (!NT_SUCCESS(Iosb.Status)) {
                    try_return( Iosb.Status );
                }

                //
                //  If the user specified a preferred server and we managed
                //  to capture the name, try and connect to it.
                //

                if (DefaultServer.Length != 0) {

                    Iosb.Status = CreateScb(
                                    &Scb,
                                    IrpContext,
                                    &DefaultServer,
                                    NULL,
                                    NULL,
                                    NULL,
                                    DeferredLogon,
                                    FALSE );


                } else {

                    //
                    //  Record that we could not get to the server specified
                    //  in the login structure and that we should attempt to
                    //  use the nearest server.
                    //

                    Iosb.Status = STATUS_BAD_NETWORK_PATH;
                }

                if ( !NT_SUCCESS(Iosb.Status)) {

                    PNONPAGED_SCB NpScb;

                    //
                    //  First dequeue the IRP context, in case it was left
                    //  on an SCB queue.
                    //

                    NwDequeueIrpContext( IrpContext, FALSE );

                    //
                    //  Cannot get to the Preferred server so use any
                    //  server we have a connection to.
                    //


                    NpScb = SelectConnection( NULL );

                    if (NpScb != NULL ) {

                        Scb = NpScb->pScb;

                        Iosb.Status = CreateScb(
                                          &Scb,
                                          IrpContext,
                                          &NpScb->ServerName,
                                          NULL,
                                          NULL,
                                          NULL,
                                          DeferredLogon,
                                          FALSE );

                        //
                        //  Release the SCB reference we obtained from
                        //  SelectConnection().
                        //

                        NwDereferenceScb( NpScb );
                    }
                }

                if ( !NT_SUCCESS(Iosb.Status)) {

                    //
                    //  First dequeue the IRP context, in case it was left
                    //  on an SCB queue.
                    //

                    NwDequeueIrpContext( IrpContext, FALSE );

                    //
                    //  Let CreateScb try and find a nearest server to talk
                    //  to.
                    //

                    Iosb.Status = CreateScb(
                                      &Scb,
                                      IrpContext,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      DeferredLogon,
                                      FALSE );
                }

                if ( !NT_SUCCESS(Iosb.Status)) {
                    try_return( Iosb.Status );
                }

            } else {

                //
                // On handle opens to a server or tree we support the concept
                // of an open with supplemental credentials.  In this case, we return
                // a handle to the server or a dir server using the provided
                // credentials regardless of whether or not there are existing
                // connections to the resource.  This is primarily for admin
                // tools like OleDs.
                //

                ReadAttachEas( Irp, &UserName, &Password, &ShareType, &dwExtendedCreate );

                if ( dwExtendedCreate ) {

                    ASSERT( UserName.Length > 0 );

                    IrpContext->Specific.Create.fExCredentialCreate = TRUE;
                    IrpContext->Specific.Create.puCredentialName = &UserName;

                    //
                    // Reference the credentials before doing the create so
                    // we are guaranteed not to lose them.  This call will
                    // create a credential shell if none exists.  This keeps
                    // our reference counting consistent.  We track the
                    // credentials pointer in the irp context specific data.
                    //

                    Iosb.Status = ExCreateReferenceCredentials( IrpContext, &Server );

                    if ( !NT_SUCCESS( Iosb.Status ) ) {
                        try_return( Iosb.Status );
                    }

                }
				
                if (PreferNDSBrowsing) {

                    //
                    //   Attempt to open \\TREE
                    //
				   
                    Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                    &Scb,           // dest scb
                                                    &Server,        // tree we want
                                                    &UserName,
                                                    &Password,
                                                    DeferredLogon,
                                                    DeleteOnClose );
				
                    if ( NT_SUCCESS( Iosb.Status ) ) {
                        OpenedTreeHandle = TRUE;
                    }
				    
                    if ( ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ) ||
                         ( Iosb.Status == STATUS_BAD_NETWORK_PATH ) ||
                         ( Iosb.Status == STATUS_UNSUCCESSFUL ) ) {
					
                        //
                        // If we couldn't find the server or something
                        // inexplicable occurred, attempt to open \\server
                        //
					
                        Iosb.Status = CreateScb(
                                                &Scb,
                                                IrpContext,
                                                &Server,
                                                NULL,
                                                &UserName,
                                                &Password,
                                                DeferredLogon,
                                                DeleteOnClose );
                        }
				
                    }else{
					
                    //
                    //  Attempt to open \\server
                    //

                    Iosb.Status = CreateScb(
                                            &Scb,
                                            IrpContext,
                                            &Server,
                                            NULL,
                                            &UserName,
                                            &Password,
                                            DeferredLogon,
                                            DeleteOnClose );

                    if ( ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ) ||
                         ( Iosb.Status == STATUS_BAD_NETWORK_PATH ) ||
                         ( Iosb.Status == STATUS_UNSUCCESSFUL ) ) {

                        //
                        // If we couldn't find the server or something
                        // inexplicable occurred, attempt to open \\tree.
                        //

                        Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                        &Scb,           // dest scb
                                                        &Server,        // tree we want
                                                        &UserName,
                                                        &Password,
                                                        DeferredLogon,
                                                        DeleteOnClose );
                        if ( NT_SUCCESS( Iosb.Status ) ) {
                            OpenedTreeHandle = TRUE;
                        }
                    }
                }


                //  if( IsTerminalServer() ) clause below has been shifted down as we are more
                //  likely to be opening a tree or server than a pserver.
                //  so we need to check there first.

				if (IsTerminalServer()) {
            
                    /*
                     * This is an attempt to get GUEST to work for printman.
                     * I.E. If you have no connection, try the guest 
                     * connection.
                     */
                    if ( ( !NT_SUCCESS(Iosb.Status) ) &&
                         ( Iosb.Status == STATUS_NO_SUCH_USER ) &&
                         ( !CreateTreeConnection ) &&
                         ( !DeferredLogon ) ) {

                        DebugTrace( -1, Dbg, " Attempting default GUEST logon for %wZ\n", &Server );

                        Iosb.Status = CreateScb(
                                               &Scb,
                                               IrpContext,
                                               &Server,
                                               NULL,
                                               &Guest.UserName,
                                               &Guest.PassWord,
                                               DeferredLogon,
                                               DeleteOnClose );
                    }
				}

                if ( !NT_SUCCESS( Iosb.Status ) ) {

                    //
                    // If we failed to get the bindery server for
                    // some legitimate reason, bail out now.
                    //
                    try_return( Iosb.Status );
                }

                //
                // We must have a connection at this point.  We don't tree
                // connect the dir server since it's virtual.
                //

                if ( !OpenedTreeHandle && CreateTreeConnection && !DeleteOnClose ) {
                        TreeConnectScb( Scb );
                }

            }

            //
            //  Now create the ICB.
            //

            ASSERT( Iosb.Status == STATUS_SUCCESS );
            ASSERT( Scb != NULL );

            Icb = NwCreateIcb( NW_NTC_ICB_SCB, Scb );
            Icb->FileObject = FileObject;
            NwSetFileObject( FileObject, NULL, Icb );

            //
            // Indicate that the SCB was opened.
            //

            Icb->State = ICB_STATE_OPENED;

            //
            // Is this a tree handle?
            //

            Icb->IsTreeHandle = OpenedTreeHandle;

            //
            // If this was an extended create, associate this handle
            // with its extended credentials so that we can cleanup
            // when all the handles are closed.
            //

            if ( IrpContext->Specific.Create.fExCredentialCreate ) {

                ASSERT( IrpContext->Specific.Create.pExCredentials != NULL );
                Icb->pContext = IrpContext->Specific.Create.pExCredentials;
                Icb->IsExCredentialHandle = TRUE;

            }

        } else {

            NwReferenceUnlockableCodeSection();
            DereferenceCodeSection = TRUE;

            DeferredLogon = FALSE;

            if ( CreateTreeConnection ) {

                //
                // We ignore the extended create attribute here because
                // we DO NOT support extended credential creates to random
                // files and directories!
                //

                ReadAttachEas( Irp, &UserName, &Password, &ShareType, NULL );

                if ( DeleteOnClose ) {

                    //
                    //  Opening a directory to delete a volume.  Do not
                    //  force logon.
                    //

                    DeferredLogon = TRUE;
                }
            }
						
            IrpContext->Specific.Create.ShareType = ShareType;
            IrpContext->Specific.Create.NdsCreate = FALSE;
			
            //
            //  Check to see if this is an NDS object, if so set the flag to check NDS first.
            //  The only way a DOT can be in the Volume name is if it is an NDS Object, 
            //  between the third and fourth slashes.
            //

            fNDSLookupFirst = FALSE;

            for (iBufferIndex=0; iBufferIndex < (USHORT)(Volume.Length/sizeof(WCHAR)); iBufferIndex++ ) {
                if  (Volume.Buffer[iBufferIndex] == L'\\')                  
                    dwSlashCount++;
			
                if (dwSlashCount > 3) {
                    fNDSLookupFirst = FALSE;
                    break;   
                }
                if (Volume.Buffer[iBufferIndex] == L'.') {
                    fNDSLookupFirst = TRUE;
                    break;
                }
            }

			if (fNDSLookupFirst) {  

				IrpContext->Specific.Create.NdsCreate = TRUE;
				IrpContext->Specific.Create.NeedNdsData = TRUE;
	 
				Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                &Scb,
                                                &Server,
                                                &UserName,
                                                &Password,
                                                DeferredLogon,
                                                DeleteOnClose );


				
                if ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ||
                     Iosb.Status == STATUS_BAD_NETWORK_PATH ||
                     Iosb.Status == STATUS_UNSUCCESSFUL ) {
					
                    //
                    //  Not found, do a bindery lookup
                    //
					
                    IrpContext->Specific.Create.NdsCreate = FALSE;
                    IrpContext->Specific.Create.NeedNdsData = FALSE;
					
                    Iosb.Status = CreateScb(
                                            &Scb,
                                            IrpContext,
                                            &Server,
                                            NULL,
                                            &UserName,
                                            &Password,
                                            DeferredLogon,
                                            DeleteOnClose );				
                }
			
			
            }else {
				
                //
                //  Object appears to be bindery, check there first.
                //

				Iosb.Status = CreateScb(
                                        &Scb,
                                        IrpContext,
                                        &Server,
                                        NULL,
                                        &UserName,
                                        &Password,
                                        DeferredLogon,
                                        DeleteOnClose );
				

		        if ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ||
	                 Iosb.Status == STATUS_BAD_NETWORK_PATH ||
					 Iosb.Status == STATUS_UNSUCCESSFUL ) {

	                //
		            // If we couldn't find the server or something
			        // inexplicable occurred, attempt to open \\tree.
				    //

					IrpContext->Specific.Create.NdsCreate = TRUE;
					IrpContext->Specific.Create.NeedNdsData = TRUE;

					Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                    &Scb,
                                                    &Server,
                                                    &UserName,
                                                    &Password,
                                                    DeferredLogon,
                                                    DeleteOnClose );
					
	            }
			}

            //
            // If we have success, then there's a volume to connect.
            //

            if ( NT_SUCCESS( Iosb.Status ) ) {

                NTSTATUS CreateScbStatus;

                ASSERT( Scb != NULL );

                //
                //  Remember the status from create SCB, since it might
                //  be an interesting warning.
                //

                CreateScbStatus = Iosb.Status;

                //
                // We catch this exception in case we have to retry the
                // create on the NDS path.  This is horrable, as does the
                // exception structure in this code right now, but it's
                // legacy and now is not the time to change it.
                //

                try {

                    Iosb = CreateRemoteFile(
                               IrpContext,
                               &Drive );

                } except ( EXCEPTION_EXECUTE_HANDLER ) {

                    Iosb.Status = GetExceptionCode();
                }

                //
                // If this is a server whose name is the same as the tree
                // that it is a member of, and the create was marked as
                // non-nds and it failed, retry an nds create.
                //

                if ( ( !NT_SUCCESS( Iosb.Status) ) &&
                     ( !(IrpContext->Specific.Create.NdsCreate) ) &&
                     ( RtlEqualUnicodeString( &(Scb->pNpScb->ServerName),
                                              &(Scb->NdsTreeName),
                                              TRUE ) ) ) {

                    IrpContext->Specific.Create.NdsCreate = TRUE;
                    IrpContext->Specific.Create.NeedNdsData = TRUE;

                    Iosb = CreateRemoteFile(
                               IrpContext,
                               &Drive );

                    //
                    // If this fails, it will raise status before setting IOSB
                    // and we'll return the status from the original create,
                    // which is the more interesting one.
                    //

                }

                //
                //  If we successfully open the remote file, return the
                //  CreateScb status instead.
                //

                if ( NT_SUCCESS( Iosb.Status ) ) {
                    Iosb.Status = CreateScbStatus;
                }

            }
        }

        //
        // If we succeeded, we want to keep the code section
        // referenced because we have opened a handle.
        //

        if ( NT_SUCCESS( Iosb.Status ) ) {
            DereferenceCodeSection = FALSE;
        }

    try_exit: NOTHING;
    } finally {

        //
        // Track the Scb in the IrpContext, not in the local Scb
        // variable since we may have been routed to another server
        // in process.
        //

        if (( Scb != NULL ) && ( IrpContext->pNpScb != NULL )) {
            NwDereferenceScb( IrpContext->pNpScb );
        }

        if ( DefaultServer.Buffer != NULL ) {
            FREE_POOL( DefaultServer.Buffer );
        }

        if ( ( IrpContext->Specific.Create.fExCredentialCreate ) &&
             ( IrpContext->Specific.Create.pExCredentials ) &&
             ( !NT_SUCCESS( Iosb.Status ) ) ) {

            ExCreateDereferenceCredentials( 
                IrpContext,
                IrpContext->Specific.Create.pExCredentials
            );
        }

        DebugTrace(-1, Dbg, "NwCommonCreate -> %08lx\n", Iosb.Status);

        if ( DereferenceCodeSection ) {
            NwDereferenceUnlockableCodeSection ();
        }

    }

    //
    //  Map a timeout error to server not found, so that MPR will
    //  try to connect on the next network provider instead of giving up,
    //  which is wrong wrong wrong.
    //

    if ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ) {
        Iosb.Status = STATUS_BAD_NETWORK_PATH;
    }

    //
    // Map an unbound transport error to server not found, so that MPR
    // will try to connect on the next provider.
    //

    if ( Iosb.Status == STATUS_NETWORK_UNREACHABLE ) {
        Iosb.Status = STATUS_BAD_NETWORK_PATH;
    }

    return Iosb.Status;
}


NTSTATUS
ReadAttachEas(
    IN PIRP Irp,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING Password,
    OUT PULONG ShareType,
    OUT PDWORD CredentialExtension
    )

/*++

Routine Description:

    This routine processes the EAs provided when the caller attempts
    to attach to a remote server.

    Note: This routine does not create additional storage for the names.
    It is the callers responsibility to save them if required.

Arguments:

    Irp - Supplies all the information

    UserName - Returns the value of the User name EA

    Password - Returns the value of the password EA

    ShareType -  Returns the value of the share type EA

    CredentialExtension - Returns whether or not this create
        should use the provided credentials for an credential
        extended connection.  This is primarily for OleDs
        accessing the ds in multiple security contexts.

Return Value:

    NTSTATUS - Status of operation

--*/
{

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_FULL_EA_INFORMATION EaBuffer = Irp->AssociatedIrp.SystemBuffer;

    PAGED_CODE();

    RtlInitUnicodeString( UserName, NULL );
    RtlInitUnicodeString( Password, NULL );
    *ShareType = RESOURCETYPE_ANY;
    if ( CredentialExtension ) {
        *CredentialExtension = FALSE;
    }

    DebugTrace(+1, Dbg, "ReadAttachEas....\n", 0);

    if ( EaBuffer != NULL) {

        while (TRUE) {
            ULONG EaNameLength = EaBuffer->EaNameLength;

            if (strcmp(EaBuffer->EaName, EA_NAME_USERNAME) == 0) {

                UserName->Length = EaBuffer->EaValueLength;
                UserName->MaximumLength = EaBuffer->EaValueLength;
                UserName->Buffer = (PWSTR)(EaBuffer->EaName+EaNameLength+1);

            } else if (strcmp(EaBuffer->EaName, EA_NAME_PASSWORD) == 0) {

                Password->Length = EaBuffer->EaValueLength;
                Password->MaximumLength = EaBuffer->EaValueLength;
                Password->Buffer = (PWSTR)(EaBuffer->EaName+EaNameLength+1);

            } else if ((strcmp(EaBuffer->EaName, EA_NAME_TYPE) == 0) &&
                       (EaBuffer->EaValueLength >= sizeof(ULONG))) {

                *ShareType = *(ULONG UNALIGNED *)(EaBuffer->EaName+EaNameLength+1);

            } else if (strcmp(EaBuffer->EaName, EA_NAME_CREDENTIAL_EX) == 0)  {

                if ( CredentialExtension ) {
                    *CredentialExtension = TRUE;
                    DebugTrace(0, Dbg, "ReadAttachEas signals a credential extension.\n", 0 );
                }

            } else {
                DebugTrace(0, Dbg, "ReadAttachEas Unknown EA -> %s\n", EaBuffer->EaName);
            }

            if (EaBuffer->NextEntryOffset == 0) {
                break;
            } else {
                EaBuffer = (PFILE_FULL_EA_INFORMATION) ((PCHAR) EaBuffer+EaBuffer->NextEntryOffset);
            }
        }
    }

    DebugTrace(-1, Dbg, "ReadAttachEas -> %08lx\n", STATUS_SUCCESS);

    return STATUS_SUCCESS;

}


IO_STATUS_BLOCK
OpenRedirector(
    IN PIRP_CONTEXT IrpContext,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routines opens a handle to the redirector device.

Arguments:

    IrpContext - Supplies all the information

    DesiredAccess - The requested access to the redirector.

    ShareAccess - The requested share access to the redirector.

    FileObject - A pointer to the caller file object.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/

{
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();

    //
    //  Note that the object manager will only allow an administrator
    //  to open the redir itself.   This is good.
    //

    DebugTrace(+1, Dbg, "NwOpenRedirector\n", 0);

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    try {

        //
        //  Set the new share access
        //

        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                       ShareAccess,
                                                       FileObject,
                                                       &NwRcb.ShareAccess,
                                                       TRUE ))) {

            DebugTrace(0, Dbg, "bad share access\n", 0);

            try_return( NOTHING );
        }

        NwSetFileObject( FileObject, NULL,  &NwRcb );
        ++NwRcb.OpenCount;

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        NwReleaseRcb( &NwRcb );
        DebugTrace(-1, Dbg, "NwOpenRedirector -> Iosb.Status = %08lx\n", iosb.Status);

    }

    //
    // Return to the caller.
    //

    return iosb;
}


IO_STATUS_BLOCK
CreateRemoteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING DriveName
    )
/*++

Routine Description:

    This routines opens a remote file or directory.

Arguments:

    IrpContext - Supplies all the information

    DriveName - The drive name.  One of three forms X:, LPTx, or NULL.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    ULONG DesiredAccess;
    ULONG ShareAccess;
    PFILE_OBJECT FileObject;

    UNICODE_STRING FileName;
    PFILE_OBJECT RelatedFileObject;
    ULONG Options;
    ULONG FileAttributes;

    BOOLEAN CreateDirectory;
    BOOLEAN OpenDirectory;
    BOOLEAN DirectoryFile;
    BOOLEAN NonDirectoryFile;
    BOOLEAN DeleteOnClose;
    BOOLEAN OpenTargetDirectory;
    ULONG AllocationSize;

    // Unhandled open features.

    // PFILE_FULL_EA_INFORMATION EaBuffer;
    // ULONG EaLength;
    // BOOLEAN SequentialOnly;
    // BOOLEAN NoIntermediateBuffering;
    // BOOLEAN IsPagingFile;
    // BOOLEAN NoEaKnowledge;

    ULONG CreateDisposition;

    PFCB Fcb = NULL;
    PICB Icb = NULL;
    PDCB Dcb;
    PVCB Vcb = NULL;
    PSCB Scb;

    BOOLEAN IsAFile;
    BOOLEAN MayBeADirectory = FALSE;
    BOOLEAN OwnOpenLock = FALSE;
    BOOLEAN SetShareAccess = FALSE;

    BYTE SearchFlags;
    BYTE ShareFlags;

    BOOLEAN CreateTreeConnection = FALSE;
    PUNICODE_STRING VolumeName;

    NTSTATUS Status;
    UNICODE_STRING NdsConnectName;
    WCHAR ConnectBuffer[MAX_NDS_NAME_CHARS];
    BOOLEAN MadeUidNdsName = FALSE;

    PAGED_CODE();

    Irp = IrpContext->pOriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    DesiredAccess = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    ShareAccess   = IrpSp->Parameters.Create.ShareAccess;
    FileObject    = IrpSp->FileObject;
    OpenTargetDirectory = BooleanFlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY );

    //
    //  It is ok to attempt a reconnect if this request fails with a
    //  connection error.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );


    try {

        //
        //  Reference our input parameters to make things easier
        //

        RelatedFileObject = FileObject->RelatedFileObject;

        //
        // We actually want the parsed file name.
        // FileName          = FileObject->FileName;
        //
        FileName          = IrpContext->Specific.Create.FullPathName;
        Options           = IrpSp->Parameters.Create.Options;
        FileAttributes    = IrpSp->Parameters.Create.FileAttributes;
        AllocationSize    = Irp->Overlay.AllocationSize.LowPart;

        //
        //  Short circuit an attempt to open a wildcard name.
        //

        if ( FsRtlDoesNameContainWildCards( &FileName ) ) {
            try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
        }

        //  Decipher Option flags and values
        //

        DirectoryFile           = BooleanFlagOn( Options, FILE_DIRECTORY_FILE );
        NonDirectoryFile        = BooleanFlagOn( Options, FILE_NON_DIRECTORY_FILE );
        DeleteOnClose           = BooleanFlagOn( Options, FILE_DELETE_ON_CLOSE );

        //
        //  Things we currently ignore, because netware servers don't support it.
        //

        // SequentialOnly          = BooleanFlagOn( Options, FILE_SEQUENTIAL_ONLY );
        // NoIntermediateBuffering = BooleanFlagOn( Options, FILE_NO_INTERMEDIATE_BUFFERING );
        // NoEaKnowledge           = BooleanFlagOn( Options, FILE_NO_EA_KNOWLEDGE );
        // EaBuffer                = Irp->AssociatedIrp.SystemBuffer;
        // EaLength                = IrpSp->Parameters.Create.EaLength;
        // IsPagingFile            = BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE );

        if ( BooleanFlagOn( Options, FILE_CREATE_TREE_CONNECTION ) ) {
            CreateDisposition = FILE_OPEN;
        } else {
            CreateDisposition = (Options >> 24) & 0x000000ff;
        }

        CreateDirectory = (BOOLEAN)(DirectoryFile &&
                                    ((CreateDisposition == FILE_CREATE) ||
                                     (CreateDisposition == FILE_OPEN_IF)));

        OpenDirectory   = (BOOLEAN)(DirectoryFile &&
                                    ((CreateDisposition == FILE_OPEN) ||
                                     (CreateDisposition == FILE_OPEN_IF)));

        Dcb = NULL;
        if ( RelatedFileObject != NULL ) {

            PNONPAGED_DCB NonPagedDcb;

            NonPagedDcb = RelatedFileObject->FsContext;
            
            if ( NonPagedDcb ) {
                Dcb = NonPagedDcb->Fcb;
            }

            //
            // If there is a related file object then this is a relative open
            // and it better be a DCB.
            //

            if ( !Dcb || (NodeType( Dcb ) != NW_NTC_DCB) ) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);
                Iosb.Status =  STATUS_OBJECT_NAME_INVALID;
                try_return( Iosb );
            }


            //
            //  Obtain SCB pointers.
            //

            IrpContext->pScb = Dcb->Scb;
            IrpContext->pNpScb = Dcb->Scb->pNpScb;
        }

        //
        // We are about ready to send a packet.  Append this IRP context
        // the SCB workqueue, and wait until it gets to the front.
        //

        NwAppendToQueueAndWait( IrpContext );
        ASSERT( IrpContext->pNpScb->Requests.Flink == &IrpContext->NextRequest );

        //
        //  Acquire the Global FCB resource to ensure that one thread
        //  can't access the half created FCB of another thread.
        //

        NwAcquireOpenLock( );
        OwnOpenLock = TRUE;

        //
        //  Find the volume for this file.
        //

        CreateTreeConnection = BooleanFlagOn( Options, FILE_CREATE_TREE_CONNECTION );

        if ( CreateTreeConnection ) {
            VolumeName = &IrpContext->Specific.Create.FullPathName;
        } else {
            VolumeName = &IrpContext->Specific.Create.VolumeName;
        }

        if ( Dcb == NULL ) {

RetryFindVcb:

            Vcb = NwFindVcb(
                      IrpContext,
                      VolumeName,
                      IrpContext->Specific.Create.ShareType,
                      IrpContext->Specific.Create.DriveLetter,
                      CreateTreeConnection,
                      ( BOOLEAN )( CreateTreeConnection && DeleteOnClose ) );

            if ( Vcb == NULL ) {

                //
                //  If this create failed because we need nds data, get
                //  the data from the ds and resubmit the request.
                //

                if ( IrpContext->Specific.Create.NdsCreate &&
                     IrpContext->Specific.Create.NeedNdsData ) {

                    //
                    // Release the open resource so we can move around.
                    //

                    NwReleaseOpenLock( );
                    OwnOpenLock = FALSE;

                    //
                    // Take the volume name and build the server/share
                    // connect name.
                    //

                    NdsConnectName.Buffer = ConnectBuffer;
                    NdsConnectName.MaximumLength = sizeof( ConnectBuffer );
                    NdsConnectName.Length = 0;

                    //
                    // Get the ds information.  We may jump servers here.
                    //

                    Status = NdsMapObjectToServerShare( IrpContext,
                                                        &Scb,
                                                        &NdsConnectName,
                                                        CreateTreeConnection,
                                                        &(IrpContext->Specific.Create.dwNdsOid) );

                    if( !NT_SUCCESS( Status ) ) {
                        ExRaiseStatus( Status );
                    }

                    //
                    // Make sure we are on the scb queue after all the
                    // possible server jumping.
                    //

                    NwAppendToQueueAndWait( IrpContext );

                    NwAcquireOpenLock( );
                    OwnOpenLock = TRUE;

                    //
                    // Prepend the Uid to the server/share name.
                    //

                    MergeStrings( &IrpContext->Specific.Create.UidConnectName,
                                  &Scb->UnicodeUid,
                                  &NdsConnectName,
                                  PagedPool );

                    MadeUidNdsName = TRUE;

                    //
                    // We have the data, so re-do the connect.
                    //

                    IrpContext->Specific.Create.NeedNdsData = FALSE;
                    goto RetryFindVcb;

                } else {

                    //
                    //  If this was an open to delete a tree connect, and we failed
                    //  to find the VCB, simply return the error.
                    //

                    Iosb.Status = STATUS_BAD_NETWORK_PATH;
                    try_return ( Iosb );

                }

            }

        } else {

            Vcb = Dcb->Vcb;
            NwReferenceVcb( Vcb );

        }

        ASSERT( Vcb->Scb == IrpContext->pScb );

        //
        //  If this is the target name for a rename then we want to find the
        //  DCB for the parent directory.
        //

        if (OpenTargetDirectory) {

            Iosb = OpenRenameTarget(IrpContext, Vcb, Dcb, &Icb );
            if (Icb != NULL) {
                Fcb = Icb->SuperType.Fcb;
            }
            try_return ( Iosb );

        }

        //
        //  Find the FCB for this file.  If the FCB exists, we get a
        //  referenced pointer.  Otherwise a new FCB is created.
        //

        Fcb = NwFindFcb( IrpContext->pScb, Vcb, &FileName, Dcb );
        // in rare cases, NwFindFcb might return NULL instead of throwing an exception
        // Raid # 432500
        if (Fcb == NULL) {
            DebugTrace(0, Dbg, "NwFindFcb returned NULL in CreateRemoteFile\n", 0);
            Iosb.Status = STATUS_INVALID_PARAMETER;
            try_return( Iosb );
        }

        //
        //  Check the share access for this file.   The share access
        //  is updated if access is granted.
        //
        if (!IsTerminalServer() ||
            !FlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE )) {
            if ( Fcb->IcbCount > 0 ) {
                NwAcquireSharedFcb( Fcb->NonPagedFcb, TRUE );

                Iosb.Status = IoCheckShareAccess(
                                                DesiredAccess,
                                                ShareAccess,
                                                FileObject,
                                                &Fcb->ShareAccess,
                                                TRUE );

                NwReleaseFcb( Fcb->NonPagedFcb );

                if ( !NT_SUCCESS( Iosb.Status ) ) {
                    try_return( Iosb );
                }

            } else {

                NwAcquireExclusiveFcb( Fcb->NonPagedFcb, TRUE );

                IoSetShareAccess(
                                DesiredAccess,
                                ShareAccess,
                                FileObject,
                                &Fcb->ShareAccess );

                NwReleaseFcb( Fcb->NonPagedFcb );
            }

            SetShareAccess = TRUE;
        }
        //
        //  Now create the ICB.
        //

        Icb = NwCreateIcb( NW_NTC_ICB, Fcb );
        Icb->FileObject = FileObject;
        NwSetFileObject( FileObject, Fcb->NonPagedFcb, Icb );

#ifndef QFE_BUILD

        //
        //  Supply a resource for the modified page write to grab when
        //  writing mem mapped files.   We do this because it is imposed
        //  on us by the system, we do not require the resource for any
        //  real serialization.
        //

        // This flag should not be zeroed (nealch: May 6, 2002)
        //Fcb->NonPagedFcb->Header.Flags = 0;
        Fcb->NonPagedFcb->Header.Resource = NULL;

#endif

#ifdef NWFASTIO
        //
        //  Initialize private cache map so that the i/o system will call
        //  our fast path.
        //

        FileObject->PrivateCacheMap = (PVOID)1;
#endif

        IrpContext->Icb = Icb;

        //
        //  Allocate an 8 bit PID for this ICB. Use different thread so
        //  each Wow program gets its own id. This is because if the same id
        //  has locks using two handles and closes just one of them the locks
        //  on that handle are not discarded.
        //

        Iosb.Status = NwMapPid(IrpContext->pNpScb, (ULONG_PTR)PsGetCurrentThread(), &Icb->Pid );

        if ( !NT_SUCCESS( Iosb.Status ) ) {
            try_return( Iosb.Status );
        }

        //
        //  Try to figure out what it is we're expected to open.
        //

        Iosb.Status = STATUS_SUCCESS;

        if ( FlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {

            //
            //  Opening a print queue job.
            //

            Iosb = CreatePrintJob( IrpContext, Vcb, Icb, DriveName );

        } else if ( DirectoryFile ||
                    ( Fcb->State == FCB_STATE_OPENED &&
                      Fcb->NodeTypeCode == NW_NTC_DCB ) ) {

            //
            //  Opening a directory.
            //

            MayBeADirectory = TRUE;

            switch ( CreateDisposition ) {

            case FILE_OPEN:
                Iosb = ChangeDirectory( IrpContext, Vcb, Icb );
                break;

            case FILE_CREATE:
                Iosb = CreateDir( IrpContext, Vcb, Icb );
                break;

            case FILE_OPEN_IF:
                Iosb.Status = FileOrDirectoryExists( IrpContext,
                                  Vcb,
                                  Icb,
                                  &Icb->SuperType.Fcb->RelativeFileName,
                                  &IsAFile );

                //
                //  If the opener specified a directory, fail this request
                //  if the object is a file.
                //

                if ( NT_SUCCESS( Iosb.Status ) && IsAFile ) {
                    Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                } else if ( !NT_SUCCESS( Iosb.Status )) {
                    Iosb = CreateDir( IrpContext, Vcb, Icb );
                }
                break;

            case FILE_SUPERSEDE:
            case FILE_OVERWRITE:
            case FILE_OVERWRITE_IF:
                Iosb.Status = STATUS_INVALID_PARAMETER;
                break;

            default:
                KeBugCheck( RDR_FILE_SYSTEM );

            }

        } else {

            SearchFlags = NtAttributesToNwAttributes( FileAttributes );
            ShareFlags = NtToNwShareFlags( DesiredAccess, ShareAccess );

            IsAFile = NonDirectoryFile ||
                      (Fcb->State == FCB_STATE_OPENED &&
                       Fcb->NodeTypeCode == NW_NTC_FCB );
            //
            //  Assume we are opening a file.  If that fails, and it makes
            //  sense try to open a directory.
            //

            switch ( CreateDisposition ) {

            case FILE_OPEN:

                //
                //  If the disposition is FILE_OPEN try to avoid an unneeded
                //  open, for some desired access types.
                //

                switch ( DesiredAccess & ~SYNCHRONIZE ) {

                case FILE_WRITE_ATTRIBUTES:
                case FILE_READ_ATTRIBUTES:
                case DELETE:

                    Iosb.Status = FileOrDirectoryExists(
                                      IrpContext,
                                      Vcb,
                                      Icb,
                                      &Icb->SuperType.Fcb->RelativeFileName,
                                      &IsAFile );

                    if ( !IsAFile) {
                        MayBeADirectory = TRUE;
                    }

                    //
                    //  Fail open of read only file for delete access,
                    //  since the netware server won't fail the delete.
                    //

                    if ( NT_SUCCESS( Iosb.Status ) &&
                         CreateDisposition == DELETE &&
                         FlagOn( Icb->NpFcb->Attributes, NW_ATTRIBUTE_READ_ONLY ) ) {

                        Iosb.Status = STATUS_ACCESS_DENIED;
                    }

                    if ( ( Iosb.Status == STATUS_OBJECT_NAME_NOT_FOUND ) &&
                         ( (DesiredAccess & ~SYNCHRONIZE) == DELETE ) ) {
                        //
                        // we may not have scan rights. fake the return as OK.
                        // NW allows the delete without scan rights.
                        //
                        Iosb.Status = STATUS_SUCCESS;
                    }

                    break;

                default:

                    Iosb = OpenFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags );

                    if ( ( Iosb.Status == STATUS_OBJECT_NAME_NOT_FOUND ||
                           Iosb.Status == STATUS_FILE_IS_A_DIRECTORY )
                            && !IsAFile) {

                        //
                        // Opener didn't specify file or directory, and open
                        // file failed.  So try open directory.
                        //

                        Iosb = ChangeDirectory( IrpContext, Vcb, Icb );
                        MayBeADirectory = TRUE;

                    } else if ( (Iosb.Status == STATUS_SHARING_VIOLATION) &&
                                ((ShareFlags == (NW_OPEN_FOR_READ | NW_DENY_WRITE)) ||
                                (ShareFlags == (NW_OPEN_FOR_READ)))) {

                        //
                        // if the file was already open exclusive (eg. GENERIC_EXECUTE)
                        // then a debugger opening it again for read will fail with
                        // sharing violation. In this case, we will try open exclusive
                        // again to see if that passes.
                        //

                        ShareFlags |= NW_OPEN_EXCLUSIVE ;
                        ShareFlags &= ~(NW_DENY_WRITE | NW_DENY_READ);
                        Iosb = OpenFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags );
                    }

                    break;

                }

                break;

            case FILE_CREATE:
                Iosb = CreateNewFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags );
                break;

            case FILE_OPEN_IF:
                Iosb.Status = FileOrDirectoryExists( IrpContext,
                                  Vcb,
                                  Icb,
                                  &Icb->SuperType.Fcb->RelativeFileName,
                                  &IsAFile );

                if ( NT_SUCCESS( Iosb.Status ) ) {
                    Iosb = OpenFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags );
                } else {
                    Iosb = CreateNewFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags );
                }

                if ( !NT_SUCCESS( Iosb.Status ) && !IsAFile) {

                    //
                    // Opener didn't specify file or directory, and open
                    // file and create new file both failed.  So try open
                    // or create directory.
                    //

                    MayBeADirectory = TRUE;
                    Iosb.Status = FileOrDirectoryExists(
                                       IrpContext,
                                       Vcb,
                                       Icb,
                                       &Icb->SuperType.Fcb->RelativeFileName,
                                       &IsAFile);

                    if ( NT_SUCCESS( Iosb.Status ) ) {
                        Iosb.Information = FILE_OPENED;
                    } else {
                        Iosb = CreateDir( IrpContext, Vcb, Icb );
                    }
                }

                break;

            //
            //  None of the below make sense for directories so if the
            //  file operation fails, just return the failure status
            //  to the user.
            //

            case FILE_SUPERSEDE:
            case FILE_OVERWRITE_IF:

                //
                //  Actually, if Overwrite is chosen, we are supposed to
                //  get the attributes for a file and OR them with the
                //  new attributes.
                //

                Iosb = CreateOrOverwriteFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags, FALSE );
                break;

            case FILE_OVERWRITE:
                Iosb.Status = FileOrDirectoryExists(
                                  IrpContext,
                                  Vcb,
                                  Icb,
                                  &Icb->SuperType.Fcb->RelativeFileName,
                                  &IsAFile );

                if ( NT_SUCCESS( Iosb.Status ) ) {
                    Iosb = CreateOrOverwriteFile( IrpContext, Vcb, Icb, SearchFlags, ShareFlags, FALSE );
                }

                break;

            default:
                KeBugCheck( RDR_FILE_SYSTEM );
            }


        }

try_exit: NOTHING;

    } finally {

        if ( Vcb != NULL ) {
            NwDereferenceVcb( Vcb, IrpContext, FALSE );
        }

        if ( MadeUidNdsName ) {
            FREE_POOL( IrpContext->Specific.Create.UidConnectName.Buffer );
        }

        if ( AbnormalTermination() || !NT_SUCCESS( Iosb.Status ) ) {

            //
            //  Remove the share access if necessary
            //

            if ( SetShareAccess ) {

                NwAcquireExclusiveFcb( Fcb->NonPagedFcb, TRUE );
                IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );
                NwReleaseFcb( Fcb->NonPagedFcb );
            }

            //
            //  Failed to create
            //

            if ( Icb != NULL ) {

                if ( Icb->Pid != 0 ) {
                    NwUnmapPid(IrpContext->pNpScb, Icb->Pid, NULL );
                }
                //
                //	dfergus 19 Apr 2001 #330484
                //
                NwDeleteIcb( NULL, Icb );
                //  added to fix 330484
                IrpContext->Icb = NULL;

                //
                //  if the operation failed, make sure we NULL out the
                //  FsContext field (nealch)
                //

                NwSetFileObject( FileObject, NULL, NULL );
            }

            //
            //  If this was a tree connect, derefence the extra
            //  reference on the VCB.
            //

            if ( CreateTreeConnection && !DeleteOnClose ) {
                if ( Vcb != NULL ) {
                    NwDereferenceVcb( Vcb, IrpContext, FALSE );
                }
            }

            NwDequeueIrpContext( IrpContext, FALSE );

        } else {

            Icb->State = ICB_STATE_OPENED;
            if ( Fcb->State == FCB_STATE_OPEN_PENDING ) {
                Fcb->State = FCB_STATE_OPENED;
            }

            if ( DeleteOnClose && !CreateTreeConnection ) {
                SetFlag( Fcb->Flags, FCB_FLAGS_DELETE_ON_CLOSE );
            }

            FileObject->SectionObjectPointer = &Fcb->NonPagedFcb->SegmentObject;

            if ( MayBeADirectory ) {

                //
                //  We successfully opened the file as a directory.
                //  If the DCB is newly created, it will be marked
                //  type FCB, update it.
                //

                Fcb->NodeTypeCode = NW_NTC_DCB;
            }

            NwDequeueIrpContext( IrpContext, FALSE );

        }

        if ( OwnOpenLock ) {
            NwReleaseOpenLock( );
        }

    }

    return( Iosb );
}


IO_STATUS_BLOCK
ChangeDirectory(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb
    )
/*++

Routine Description:

    This routines sets the directory for a remote drive.

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote drive.

    Icb - A pointer to the file we are opening.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;
    BYTE Attributes;
    BOOLEAN FirstTime = TRUE;

    PAGED_CODE();

    //
    //  No need to send a packet if we are opening the root of the volume.
    //

    if ( Icb->SuperType.Fcb->RelativeFileName.Length == 0 ) {

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

        return( Iosb );
    }

Retry:

    if ( !BooleanFlagOn( Icb->SuperType.Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "FwbbJ",
                          NCP_SEARCH_FILE,
                          -1,
                          Vcb->Specific.Disk.Handle,
                          SEARCH_ALL_DIRECTORIES,
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "N==_b",
                              14,
                              &Attributes );
        }


    } else {

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "LbbWDbDbC",
                          NCP_LFN_GET_INFO,
                          Vcb->Specific.Disk.LongNameSpace,
                          Vcb->Specific.Disk.LongNameSpace,
                          SEARCH_ALL_DIRECTORIES,
                          LFN_FLAG_INFO_ATTRIBUTES |
                               LFN_FLAG_INFO_MODIFY_TIME,
                          Vcb->Specific.Disk.VolumeNumber,
                          Vcb->Specific.Disk.Handle,
                          0,
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                             IrpContext,
                             IrpContext->rsp,
                             IrpContext->ResponseLength,
                             "N_b",
                             4,
                             &Attributes );
        }

        //
        //  Unfortunately, this succeeds even if the file in question
        //  is not a directory.
        //

        if ( NT_SUCCESS( Iosb.Status ) &&
             ( !FlagOn( Attributes, NW_ATTRIBUTE_DIRECTORY ) ) ) {

            Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
    }

    if ((Iosb.Status == STATUS_INVALID_HANDLE) &&
        (FirstTime)) {

        //
        //  Check to see if Volume handle is invalid. Caused when volume
        //  is unmounted and then remounted.
        //

        FirstTime = FALSE;

        NwReopenVcbHandle( IrpContext, Vcb );

        goto Retry;
    }

    Fcb = Icb->SuperType.Fcb;

    Fcb->NonPagedFcb->Attributes = (UCHAR)Attributes;
    SetFlag( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID );

    //
    //  Set information field assuming success.  It will be ignored
    //  if the NCP failed.
    //

    Iosb.Information = FILE_OPENED;

    if ( Iosb.Status == STATUS_UNSUCCESSFUL ) {
        Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    return( Iosb );
}


IO_STATUS_BLOCK
CreateDir(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb
    )
/*++

Routine Description:

    This routines create a new directory.

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote drive.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    if ( Icb->SuperType.Fcb->RelativeFileName.Length == 0 ) {
        Iosb.Status = STATUS_ACCESS_DENIED;
        return( Iosb );
    }

    if ( !BooleanFlagOn( Icb->SuperType.Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        if (!IsFatNameValid(&Icb->SuperType.Fcb->RelativeFileName)) {

            Iosb.Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            return( Iosb );

        }

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "SbbJ",
                          NCP_DIR_FUNCTION, NCP_CREATE_DIRECTORY,
                          Vcb->Specific.Disk.Handle,
                          0xFF,
                          &Icb->SuperType.Fcb->RelativeFileName );

    } else {

        Iosb.Status = ExchangeWithWait(
                          IrpContext,
                          SynchronousResponseCallback,
                          "LbbWDDWbDbC",
                          NCP_LFN_OPEN_CREATE,
                          Vcb->Specific.Disk.LongNameSpace,
                          LFN_FLAG_OM_CREATE,
                          0,       // Search Flags,
                          0,       // Return Info Mask
                          NW_ATTRIBUTE_DIRECTORY,
                          0x00ff,  // Desired access
                          Vcb->Specific.Disk.VolumeNumber,
                          Vcb->Specific.Disk.Handle,
                          0,       // Short directory flag
                          &Icb->SuperType.Fcb->RelativeFileName );

    }

    if ( NT_SUCCESS( Iosb.Status ) ) {
        Iosb.Status = ParseResponse(
                          IrpContext,
                          IrpContext->rsp,
                          IrpContext->ResponseLength,
                          "N" );
    }

    //
    //  Set information field assuming success.  It will be ignored
    //  if the NCP failed.
    //

    Iosb.Information = FILE_CREATED;

    if ( Iosb.Status == STATUS_UNSUCCESSFUL ) {
        Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
    }

    return( Iosb );
}


NTSTATUS
FileOrDirectoryExists(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb OPTIONAL,
    PUNICODE_STRING Name,
    OUT PBOOLEAN IsAFile
    )
/*++

Routine Description:

    This routines looks to see if a file or directory exists.

Arguments:

    IrpContext - Supplies allx the information

    Vcb - A pointer to the VCB for the remote drive.

    Icb - A pointer to the ICB for the file we are looking for.

    Name - Fully qualified name.

    IsAFile - Returns TRUE is the found file is a file, FALSE if it is
        a directory.   Return nothing if the function returns FALSE.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    ULONG Attributes;
    ULONG FileSize;
    USHORT LastModifiedDate;
    USHORT LastModifiedTime;
    USHORT CreationDate;
    USHORT CreationTime = DEFAULT_TIME;
    USHORT LastAccessDate;
    NTSTATUS Status;
    PFCB Fcb;
    BOOLEAN FirstTime = TRUE;

    PAGED_CODE();

    //
    //  No need to send a packet if we are searching for the root of the volume.
    //

    if ( Name->Length == 0 ) {
        *IsAFile = FALSE;

        return( STATUS_SUCCESS );
    }

    //
    //  Decide how to handle this request.   If we have an ICB, use the FCB
    //  to determine the file name type, otherwise we have to make the
    //  decision here.
    //

    if ( Icb != NULL &&
         !BooleanFlagOn( Icb->SuperType.Fcb->Flags, FCB_FLAGS_LONG_NAME ) ||

         Vcb->Specific.Disk.LongNameSpace == LFN_NO_OS2_NAME_SPACE ||

         IsFatNameValid( Name ) ) {
Retry:
        //
        //  First try a file
        //

        IrpContext->ResponseLength = 0;

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "FwbbJ",
                     NCP_SEARCH_FILE,
                     -1,
                     Vcb->Specific.Disk.Handle,
                     SEARCH_ALL_FILES,
                     Name );

        if ( NT_SUCCESS( Status ) ) {
            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N==_b-dwwww",
                         14,
                         &Attributes,
                         &FileSize,
                         &CreationDate,
                         &LastAccessDate,
                         &LastModifiedDate,
                         &LastModifiedTime );
        }

        if ((Status == STATUS_INVALID_HANDLE) &&
            (FirstTime)) {

            //
            //  Check to see if Volume handle is invalid. Caused when volume
            //  is unmounted and then remounted.
            //

            FirstTime = FALSE;

            NwReopenVcbHandle( IrpContext, Vcb );

            goto Retry;
        }

        if ( Status == STATUS_UNSUCCESSFUL ) {

            //
            // Not a file, Is it a directory?
            //

            Status = ExchangeWithWait (
                         IrpContext,
                         SynchronousResponseCallback,
                         "FwbbJ",
                         NCP_SEARCH_FILE,
                         -1,
                         Vcb->Specific.Disk.Handle,
                         SEARCH_ALL_DIRECTORIES,
                         Name );

            if ( NT_SUCCESS( Status ) ) {
                Status = ParseResponse(
                             IrpContext,
                             IrpContext->rsp,
                             IrpContext->ResponseLength,
                             "N==_b",
                             14,
                             &Attributes );
            }

            //
            //  If the exchange or ParseResponse fails then exit with not found
            //

            if ( !NT_SUCCESS( Status ) ) {
                return( STATUS_OBJECT_NAME_NOT_FOUND );
            }

            *IsAFile = FALSE;
            ASSERT( (Attributes & NW_ATTRIBUTE_DIRECTORY) != 0 );

        } else {

            if ( Status == STATUS_UNEXPECTED_NETWORK_ERROR &&
                 IrpContext->ResponseLength >= sizeof( NCP_RESPONSE ) ) {

                //
                //  Work-around for netware bug.  If netware returns short
                //  packet, just return success.  We exit prematurely
                //  because we have no attributes to record.
                //

                Icb = NULL;
                *IsAFile = TRUE;
                return ( STATUS_SUCCESS );
            }

            if ( !NT_SUCCESS( Status ) ) {
                return( Status );
            }

            *IsAFile = TRUE;
            ASSERT( ( Attributes & NW_ATTRIBUTE_DIRECTORY ) == 0 );

        }

    }  else {

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "LbbWDbDbC",
                     NCP_LFN_GET_INFO,
                     Vcb->Specific.Disk.LongNameSpace,
                     Vcb->Specific.Disk.LongNameSpace,
                     SEARCH_ALL_DIRECTORIES,
                     LFN_FLAG_INFO_ATTRIBUTES |
                     LFN_FLAG_INFO_FILE_SIZE |
                     LFN_FLAG_INFO_MODIFY_TIME |
                     LFN_FLAG_INFO_CREATION_TIME,
                     Vcb->Specific.Disk.VolumeNumber,
                     Vcb->Specific.Disk.Handle,
                     0,
                     Name );

        if ( NT_SUCCESS( Status ) ) {
            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N_e=e_xx_xx_x",
                         4,
                         &Attributes,
                         &FileSize,
                         6,
                         &CreationTime,
                         &CreationDate,
                         4,
                         &LastModifiedTime,
                         &LastModifiedDate,
                         4,
                         &LastAccessDate );
        }

        //
        //  If the exchange or ParseResponse fails then exit with not found
        //

        if ( !NT_SUCCESS( Status ) ) {
            return( STATUS_OBJECT_NAME_NOT_FOUND );
        }

        if ( Attributes & NW_ATTRIBUTE_DIRECTORY) {
            *IsAFile = FALSE;
        } else {
            *IsAFile = TRUE;
        }
    }

    //
    //  If the caller supplied an ICB, update the FCB attributes.
    //  We'll use this info if the caller does a query attributes
    //  on the ICB.
    //

    if ( Icb != NULL && *IsAFile ) {

        Fcb = Icb->SuperType.Fcb;
        ASSERT( Fcb->NodeTypeCode == NW_NTC_FCB );

        Fcb->NonPagedFcb->Attributes = (UCHAR)Attributes;
        Fcb->NonPagedFcb->Header.FileSize.QuadPart = FileSize;
        Fcb->LastModifiedDate = LastModifiedDate;
        Fcb->LastModifiedTime = LastModifiedTime;
        Fcb->CreationTime = CreationTime;
        Fcb->CreationDate = CreationDate;
        Fcb->LastAccessDate = LastAccessDate;

        DebugTrace( 0, Dbg, "Attributes  -> %08lx\n", Fcb->NonPagedFcb->Attributes );
        DebugTrace( 0, Dbg, "FileSize.Low-> %08lx\n", Fcb->NonPagedFcb->Header.FileSize.LowPart );
        DebugTrace( 0, Dbg, "ModifiedDate-> %08lx\n", Fcb->LastModifiedDate );
        DebugTrace( 0, Dbg, "ModifiedTime-> %08lx\n", Fcb->LastModifiedTime );
        DebugTrace( 0, Dbg, "CreationTime-> %08lx\n", Fcb->CreationTime );
        DebugTrace( 0, Dbg, "CreationDate-> %08lx\n", Fcb->CreationDate );
        DebugTrace( 0, Dbg, "LastAccDate -> %08lx\n", Fcb->LastAccessDate );

        SetFlag( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID );
    }

    return( STATUS_SUCCESS );
}


IO_STATUS_BLOCK
OpenFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE Attributes,
    IN BYTE OpenFlags
    )
/*++

Routine Description:

    This routines sets opens a file on a netware server.  It fails if
    the file does not exist.

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote drive.

    Icb - A pointer to the ICB we are opening.

    Attributes - Open attributes.

    OpenFlags - Open mode and sharing mode flags.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;

    PAGED_CODE();

    //
    //  No need to send a packet if we are trying to open the root of
    //  the volume as a file.
    //

    if ( Icb->SuperType.Fcb->RelativeFileName.Length == 0 ) {
        Iosb.Status = STATUS_FILE_IS_A_DIRECTORY;
        return( Iosb );
    }

    Fcb = Icb->SuperType.Fcb;
    ASSERT( NodeType( Fcb ) == NW_NTC_FCB );

    //
    //  Send the open request and wait for the response.
    //

    if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "FbbbJ",
                          NCP_OPEN_FILE,
                          Vcb->Specific.Disk.Handle,
                          SEARCH_ALL_FILES,
                          OpenFlags,
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( ( ReadExecOnlyFiles ) &&
             ( !NT_SUCCESS( Iosb.Status ) ) ) {

            //
            // Retry the open with the appropriate flags for
            // execute only files.
            //

            Iosb.Status = ExchangeWithWait (
                              IrpContext,
                              SynchronousResponseCallback,
                              "FbbbJ",
                              NCP_OPEN_FILE,
                              Vcb->Specific.Disk.Handle,
                              SEARCH_EXEC_ONLY_FILES,
                              OpenFlags,
                              &Icb->SuperType.Fcb->RelativeFileName );
        }

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Nr=_b-dwwww",
                              Icb->Handle,
                              sizeof( Icb->Handle ),
                              14,
                              &Fcb->NonPagedFcb->Attributes,
                              &Fcb->NonPagedFcb->Header.FileSize,
                              &Fcb->CreationDate,
                              &Fcb->LastAccessDate,
                              &Fcb->LastModifiedDate,
                              &Fcb->LastModifiedTime );

            Fcb->CreationTime = DEFAULT_TIME;

        }

    } else {

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "LbbWDDWbDbC",
                          NCP_LFN_OPEN_CREATE,
                          Vcb->Specific.Disk.LongNameSpace,
                          LFN_FLAG_OM_OPEN,
                          NW_ATTRIBUTE_HIDDEN | NW_ATTRIBUTE_SYSTEM,    // Search Flags,
                          LFN_FLAG_INFO_ATTRIBUTES |
                          LFN_FLAG_INFO_FILE_SIZE |
                          LFN_FLAG_INFO_MODIFY_TIME |
                          LFN_FLAG_INFO_CREATION_TIME,
                          0,               // Create attributes
                          OpenFlags,       // Desired access
                          Vcb->Specific.Disk.VolumeNumber,
                          Vcb->Specific.Disk.Handle,
                          0,       // Short directory flag
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( ( ReadExecOnlyFiles ) &&
             ( !NT_SUCCESS( Iosb.Status ) ) ) {
                                           
            Iosb.Status = ExchangeWithWait ( 
                              IrpContext,
                              SynchronousResponseCallback,
                              "LbbWDDWbDbC",
                              NCP_LFN_OPEN_CREATE,
                              Vcb->Specific.Disk.LongNameSpace,
                              LFN_FLAG_OM_OPEN,
                              NW_ATTRIBUTE_EXEC_ONLY,
                              LFN_FLAG_INFO_ATTRIBUTES |
                              LFN_FLAG_INFO_FILE_SIZE |
                              LFN_FLAG_INFO_MODIFY_TIME |
                              LFN_FLAG_INFO_CREATION_TIME,
                              0,               // Create attributes
                              OpenFlags,       // Desired access
                              Vcb->Specific.Disk.VolumeNumber,
                              Vcb->Specific.Disk.Handle,
                              0,       // Short directory flag
                              &Icb->SuperType.Fcb->RelativeFileName );
        }

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Ne_e=e_xx_xx_x",
                              &Icb->Handle[2],
                              6,
                              &Fcb->NonPagedFcb->Attributes,
                              &Fcb->NonPagedFcb->Header.FileSize,
                              6,
                              &Fcb->CreationTime,
                              &Fcb->CreationDate,
                              4,
                              &Fcb->LastModifiedTime,
                              &Fcb->LastModifiedDate,
                              4,
                              &Fcb->LastAccessDate );
        }
    }

    if ( NT_SUCCESS( Iosb.Status ) ) {

        //
        //  NT does not allow you to open a read only file for write access.
        //  Netware does.   To fake NT semantics, check to see if we should
        //  fail the open that the netware server just succeeded.
        //

        if ( ( Fcb->NonPagedFcb->Attributes & NW_ATTRIBUTE_READ_ONLY ) &&
             ( OpenFlags & NW_OPEN_FOR_WRITE  ) ) {

            CloseFile( IrpContext, Icb );
            Iosb.Status = STATUS_ACCESS_DENIED;
        }

        SetFlag( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID );
        Icb->HasRemoteHandle = TRUE;


        DebugTrace( 0, Dbg, "Attributes  -> %08lx\n", Fcb->NonPagedFcb->Attributes );
        DebugTrace( 0, Dbg, "FileSize.Low-> %08lx\n", Fcb->NonPagedFcb->Header.FileSize.LowPart );
        DebugTrace( 0, Dbg, "ModifiedDate-> %08lx\n", Fcb->LastModifiedDate );
        DebugTrace( 0, Dbg, "ModifiedTime-> %08lx\n", Fcb->LastModifiedTime );
        DebugTrace( 0, Dbg, "CreationDate-> %08lx\n", Fcb->CreationDate );
        DebugTrace( 0, Dbg, "CreationTime-> %08lx\n", Fcb->CreationTime );
        DebugTrace( 0, Dbg, "LastAccDate -> %08lx\n", Fcb->LastAccessDate );

    }

    //
    //  Set information field assuming success.  It will be ignored
    //  if the NCP failed.
    //

    Iosb.Information = FILE_OPENED;

    if ( Iosb.Status == STATUS_UNSUCCESSFUL ) {
        Iosb.Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return( Iosb );
}


IO_STATUS_BLOCK
CreateNewFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE CreateAttributes,
    IN BYTE OpenFlags
    )
/*++

Routine Description:

    This routines creates a new file on a netware server.  It fails
    if the file exists.

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote drive.

    Icb - A pointer to the ICB we are opening.

    CreateAttributes - Create attributes.

    OpenFlags - Open mode and sharing mode flags.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;
    UCHAR DelayedAttributes;
    BOOLEAN CloseAndReopen;

    PAGED_CODE();

    //
    //  If the user opens the file for shared access, then we will need to
    //  create the file close, then reopen it (since we have no NCP to say
    //  create with shared access).   If the file is being created read-only,
    //  and the creator requests write access then we pull the additional
    //  trick of creating the file without the read-only, and set it later,
    //  so that the second open can succeed.
    //

    CloseAndReopen = FALSE;
    DelayedAttributes = 0;

    if ( OpenFlags != NW_OPEN_EXCLUSIVE ) {
        CloseAndReopen = TRUE;

        if ( ( CreateAttributes & NW_ATTRIBUTE_READ_ONLY ) &&
             ( OpenFlags & NW_OPEN_FOR_WRITE ) ) {

            DelayedAttributes = CreateAttributes;
            CreateAttributes = 0;
        }
    }

    //
    //  Send the create request and wait for the response.
    //

    Fcb = Icb->SuperType.Fcb;

    if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        if (!IsFatNameValid(&Icb->SuperType.Fcb->RelativeFileName)) {

            Iosb.Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            return( Iosb );

        }

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "FbbJ",  // NCP Create New File
                          NCP_CREATE_NEW_FILE,
                          Vcb->Specific.Disk.Handle,
                          CreateAttributes,
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Nr=_b-dwwww",
                              Icb->Handle, sizeof( Icb->Handle ),
                              14,
                              &Fcb->NonPagedFcb->Attributes,
                              &Fcb->NonPagedFcb->Header.FileSize,
                              &Fcb->CreationDate,
                              &Fcb->LastAccessDate,
                              &Fcb->LastModifiedDate,
                              &Fcb->LastModifiedTime );

        Fcb->CreationTime = DEFAULT_TIME;

        }

    } else {

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "LbbWDDWbDbC",
                          NCP_LFN_OPEN_CREATE,
                          Vcb->Specific.Disk.LongNameSpace,
                          LFN_FLAG_OM_CREATE,
                          0,       // Search Flags
                          LFN_FLAG_INFO_ATTRIBUTES |
              LFN_FLAG_INFO_FILE_SIZE |
              LFN_FLAG_INFO_MODIFY_TIME |
              LFN_FLAG_INFO_CREATION_TIME,
                          CreateAttributes,
                          0,       // Desired access
                          Vcb->Specific.Disk.VolumeNumber,
                          Vcb->Specific.Disk.Handle,
                          0,       // Short directory flag
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Ne_e=e_xx_xx_x",
                              &Icb->Handle[2],
                              6,
                              &Fcb->NonPagedFcb->Attributes,
                              &Fcb->NonPagedFcb->Header.FileSize,
                              6,
                  &Fcb->CreationTime,
                              &Fcb->CreationDate,
                              4,
                              &Fcb->LastModifiedTime,
                              &Fcb->LastModifiedDate,
                              4,
                              &Fcb->LastAccessDate );
        }
    }

    if ( NT_SUCCESS( Iosb.Status ) ) {
        SetFlag( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID );
        Icb->HasRemoteHandle = TRUE;
        DebugTrace( 0, Dbg, "Attributes  -> %08lx\n", Fcb->NonPagedFcb->Attributes );
        DebugTrace( 0, Dbg, "FileSize.Low-> %08lx\n", Fcb->NonPagedFcb->Header.FileSize.LowPart );
        DebugTrace( 0, Dbg, "ModifiedDate-> %08lx\n", Fcb->LastModifiedDate );
        DebugTrace( 0, Dbg, "ModifiedTime-> %08lx\n", Fcb->LastModifiedTime );
        DebugTrace( 0, Dbg, "CreationDate-> %08lx\n", Fcb->CreationDate );
        DebugTrace( 0, Dbg, "CreationTime-> %08lx\n", Fcb->CreationTime );
        DebugTrace( 0, Dbg, "LastAcceDate-> %08lx\n", Fcb->LastAccessDate );
    }

    if ( Iosb.Status == STATUS_UNSUCCESSFUL ) {
        Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
    }

    if ( !NT_SUCCESS( Iosb.Status ) ) {
        return( Iosb );
    }


    //
    //  We've created the file, and the users wants shared access to the
    //  file.  Close the file and reopen in sharing mode.
    //

    if ( CloseAndReopen ) {
        CloseFile( IrpContext, Icb );
        Iosb = OpenFile( IrpContext, Vcb, Icb, CreateAttributes, OpenFlags );
    }

    //
    //  If we need to set attributes, do it now.  Ignore errors, if any.
    //

    if ( DelayedAttributes != 0 ) {

        ExchangeWithWait(
            IrpContext,
            SynchronousResponseCallback,
            "FbbbU",
            NCP_SET_FILE_ATTRIBUTES,
            DelayedAttributes,
            Fcb->Vcb->Specific.Disk.Handle,
            SEARCH_ALL_FILES,
            &Fcb->RelativeFileName );

    }

    //
    //  Set information field assuming success.  It will be ignored
    //  if the NCP failed.
    //

    Iosb.Information = FILE_CREATED;
    return( Iosb );
}


IO_STATUS_BLOCK
CreateOrOverwriteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE CreateAttributes,
    IN BYTE OpenFlags,
    IN BOOLEAN CreateOperation
    )
/*++

Routine Description:

    This routines creates a file on a netware server.  If the file
    exists it is overwritten.

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote drive.

    Icb - A pointer to the ICB we are opening.

    Attributes - Open attributes.

    OpenFlags - Open mode and sharing mode flags.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;
    UCHAR DelayedAttributes;
    BOOLEAN CloseAndReopen;

    PAGED_CODE();

    Fcb = Icb->SuperType.Fcb;

    //
    //  Send the request and wait for the response.
    //

    if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        if (!IsFatNameValid(&Icb->SuperType.Fcb->RelativeFileName)) {

            Iosb.Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            return( Iosb );

        }

        //
        //  If the user opens the file for shared access, then we will need to
        //  create the file close, then reopen it (since we have no NCP to say
        //  create with shared access).   If the file is being created read-only,
        //  and the creator requests write access then we pull the additional
        //  trick of creating the file without the read-only, and set it later,
        //  so that the second open can succeed.
        //

        if ( ( CreateAttributes & NW_ATTRIBUTE_READ_ONLY ) &&
             ( OpenFlags & NW_OPEN_FOR_WRITE ) ) {

            DelayedAttributes = CreateAttributes;
            CreateAttributes = 0;
        } else {
            DelayedAttributes = 0;
        }

        //
        //  Dos namespace create always returns the file exclusive.
        //

        if (!FlagOn(OpenFlags, NW_OPEN_EXCLUSIVE)) {
            CloseAndReopen = TRUE;
        } else {
            CloseAndReopen = FALSE;
        }

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "FbbJ",
                          NCP_CREATE_FILE,
                          Vcb->Specific.Disk.Handle,
                          CreateAttributes,
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Nr=_b-dwwww",
                              Icb->Handle,
                              sizeof( Icb->Handle ),
                              14,
                              &Fcb->NonPagedFcb->Attributes,
                              &Fcb->NonPagedFcb->Header.FileSize,
                              &Fcb->CreationDate,
                              &Fcb->LastAccessDate,
                              &Fcb->LastModifiedDate,
                              &Fcb->LastModifiedTime );

            Fcb->CreationTime = DEFAULT_TIME;

        }

        //
        //  We've created the file, and the users wants shared access to the
        //  file.  Close the file and reopen in sharing mode.
        //

        if (( NT_SUCCESS( Iosb.Status ) ) &&
            ( CloseAndReopen )) {

            CloseFile( IrpContext, Icb );
            Iosb = OpenFile( IrpContext, Vcb, Icb, CreateAttributes, OpenFlags );
        }

        if ( DelayedAttributes != 0 ) {
            ExchangeWithWait(
                IrpContext,
                SynchronousResponseCallback,
                "FbbbU",
                NCP_SET_FILE_ATTRIBUTES,
                DelayedAttributes,
                Fcb->Vcb->Specific.Disk.Handle,
                SEARCH_ALL_FILES,
                &Fcb->RelativeFileName );
        }

    } else {

        Iosb.Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "LbbWDDWbDbC",
                          NCP_LFN_OPEN_CREATE,
                          Vcb->Specific.Disk.LongNameSpace,
                          LFN_FLAG_OM_OVERWRITE,
                          0,       // Search Flags
                          LFN_FLAG_INFO_ATTRIBUTES |
              LFN_FLAG_INFO_FILE_SIZE |
              LFN_FLAG_INFO_MODIFY_TIME |
              LFN_FLAG_INFO_CREATION_TIME,
                          CreateAttributes,
                          OpenFlags,       // DesiredAccess
                          Vcb->Specific.Disk.VolumeNumber,
                          Vcb->Specific.Disk.Handle,
                          0,       // Short directory flag
                          &Icb->SuperType.Fcb->RelativeFileName );

        if ( NT_SUCCESS( Iosb.Status ) ) {
            Iosb.Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Ne_e=e_xx_xx_x",
                              &Icb->Handle[2],
                              6,
                              &Fcb->NonPagedFcb->Attributes,
                              &Fcb->NonPagedFcb->Header.FileSize,
                              6,
                              &Fcb->CreationTime,
                              &Fcb->CreationDate,
                              4,
                              &Fcb->LastModifiedTime,
                              &Fcb->LastModifiedDate,
                              4,
                              &Fcb->LastAccessDate );
        }
    }

    if ( NT_SUCCESS( Iosb.Status ) ) {
        SetFlag( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID );
        Icb->HasRemoteHandle = TRUE;
        DebugTrace( 0, Dbg, "Attributes  -> %08lx\n", Fcb->NonPagedFcb->Attributes );
        DebugTrace( 0, Dbg, "FileSize.Low-> %08lx\n", Fcb->NonPagedFcb->Header.FileSize.LowPart );
        DebugTrace( 0, Dbg, "ModifiedDate-> %08lx\n", Fcb->LastModifiedDate );
        DebugTrace( 0, Dbg, "ModifiedTime-> %08lx\n", Fcb->LastModifiedTime );
        DebugTrace( 0, Dbg, "CreationDate-> %08lx\n", Fcb->CreationDate );
        DebugTrace( 0, Dbg, "CreationTime-> %08lx\n", Fcb->CreationTime );
        DebugTrace( 0, Dbg, "LastAccDate -> %08lx\n", Fcb->LastAccessDate );
    } else {
        return( Iosb );
    }

    //
    //  Set information field assuming success.  It will be ignored
    //  if the NCP failed.
    //

    if ( CreateOperation) {
        Iosb.Information = FILE_CREATED;
    } else {
        Iosb.Information = FILE_OVERWRITTEN;
    }

    return( Iosb );
}


IO_STATUS_BLOCK
OpenRenameTarget(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB Dcb,
    IN PICB* Icb
    )
/*++

Routine Description:

    This routine opens a directory. If the filename provided specifies
    a directory then the file/directory to be renamed will be put in this
    directory.

    If the target foo\bar does not exist or is a file then the source of
    the rename must be a file and will end up in the directory foo with
    the name bar

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote drive.

    Dcb - A pointer to the DCB for relative opens.  If NULL the FileName
        is an full path name.  If non NUL the FileName is relative to
        this directory.

    Icb - A pointer to where the address of the Icb is to be stored.

Return Value:

    NT_STATUS - Status of operation

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;
    BOOLEAN FullNameIsAFile;
    BOOLEAN FullNameExists;
    BOOLEAN PathIsAFile;

#if 0
    UNICODE_STRING Drive;
    WCHAR DriveLetter;
    UNICODE_STRING Server;
    UNICODE_STRING Volume;
    UNICODE_STRING FileName;
#endif
    UNICODE_STRING Path;
    UNICODE_STRING FullName;
    UNICODE_STRING CompleteName;
    UNICODE_STRING VcbName;
    PWCH pTrailingSlash;

    USHORT i;
    USHORT DcbNameLength;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "OpenRenameTarget\n", 0);

    //
    //  Get the current IRP stack location
    //

    Irp = IrpContext->pOriginalIrp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Build a complete filename of the form \g:\server\volume\dir1\file
    //

    if ( Dcb != NULL ) {

        //
        //  Strip to UID portion of the DCB name.
        //

        for ( i = 0 ; i < Dcb->FullFileName.Length / sizeof(WCHAR) ; i++ ) {
            if ( Dcb->FullFileName.Buffer[i] == OBJ_NAME_PATH_SEPARATOR ) {
                break;
            }
        }

        ASSERT( Dcb->FullFileName.Buffer[i] == OBJ_NAME_PATH_SEPARATOR );

        //
        //  Now build the full name by appending the file name to the DCB name.
        //

        DcbNameLength = Dcb->FullFileName.Length - ( i * sizeof(WCHAR) );
        CompleteName.Length = DcbNameLength + IrpSp->FileObject->FileName.Length + sizeof( WCHAR);
        CompleteName.MaximumLength = CompleteName.Length;
        CompleteName.Buffer = ALLOCATE_POOL_EX( PagedPool, CompleteName.Length );

        RtlCopyMemory(
            CompleteName.Buffer,
            Dcb->FullFileName.Buffer + i,
            DcbNameLength );

        CompleteName.Buffer[ DcbNameLength / sizeof(WCHAR) ] = L'\\';

        RtlCopyMemory(
            CompleteName.Buffer + DcbNameLength / sizeof(WCHAR ) + 1,
            IrpSp->FileObject->FileName.Buffer,
            IrpSp->FileObject->FileName.Length );

        Dcb = NULL;

    } else {

        CompleteName = IrpSp->FileObject->FileName;

    }

    //
    //  Calculate the VCB name, without the UID prefix.
    //

    VcbName.Buffer = wcschr( Vcb->Name.Buffer, L'\\' );
    VcbName.Length = (USHORT) (Vcb->Name.Length -
        ( (PCHAR)VcbName.Buffer - (PCHAR)Vcb->Name.Buffer ));

    //
    //  Calculate the target relative name.   This is simply the complete
    //  name minus the VcbName and the leading backslash.
    //

    FullName.Buffer = CompleteName.Buffer + ( VcbName.Length / sizeof(WCHAR) ) + 1;
    FullName.Length = (USHORT) (CompleteName.Length -
        ( (PCHAR)FullName.Buffer - (PCHAR)CompleteName.Buffer ));

    //
    //  Calculate the target directory relative name.   This the the target
    //  full name, minus the last component of the name.
    //

    pTrailingSlash = FullName.Buffer + FullName.Length / sizeof(WCHAR) - 1;
    for ( i = 0; i < FullName.Length ; i += sizeof(WCHAR) ) {
        if ( *pTrailingSlash == L'\\' ) {
            break;
        }
        --pTrailingSlash;
    }


    Path.Buffer = FullName.Buffer;

    if ( i == FullName.Length ) {

        //
        //  If no trailing slash was found, the the target path is the
        //  root directory.
        //

        Path.Length = 0;

    } else {

        Path.Length = (USHORT) ((PCHAR)pTrailingSlash - (PCHAR)FullName.Buffer);

    }

#if 0
    Iosb.Status = CrackPath(
                      &CompleteName,
                      &Drive,
                      &DriveLetter,
                      &Server,
                      &Volume,
                      &Path,
                      &FileName,
                      &FullName );
#endif

    Iosb.Status = FileOrDirectoryExists( IrpContext,
                       Vcb,
                       NULL,
                       &Path,
                       &PathIsAFile );

    if ( !NT_SUCCESS( Iosb.Status) ) {

        //  The directory containing the file does not exist

        return(Iosb);
    }

    Iosb.Status = FileOrDirectoryExists( IrpContext,
                      Vcb,
                      NULL,
                      &FullName,
                      &FullNameIsAFile );

    if ( !NT_SUCCESS( Iosb.Status ) ) {
        FullNameExists = FALSE;
        Iosb.Information = FILE_DOES_NOT_EXIST;
    } else {
        FullNameExists = TRUE;
        Iosb.Information = 0;
    }

    DebugTrace( 0, Dbg, "FullNameExists     = %08lx\n", FullNameExists);
    DebugTrace( 0, Dbg, "FullNameIsAFile    = %08lx\n", FullNameIsAFile);

    try {
        UNICODE_STRING TargetPath;

        //
        //  Find the FCB for this file.  If the FCB exists, we get a
        //  referenced pointer.  Otherwise a new FCB is created.
        //  The file is the complete path minus the target filename.
        //

        TargetPath = CompleteName;

        Fcb = NwFindFcb( IrpContext->pScb, Vcb, &TargetPath, Dcb );
        // in rare cases, NwFindFcb might return NULL instead of throwing an exception
        // Raid # 432500
        if (Fcb == NULL) {
            DebugTrace(0, Dbg, "NwFindFcb returned NULL in OpenRenameTarget\n", 0);
            Iosb.Status = STATUS_INVALID_PARAMETER;
            try_return( Iosb );
        }

        //
        //  Now create the ICB.
        //

        *Icb = NwCreateIcb( NW_NTC_ICB, Fcb );

        (*Icb)->FileObject = IrpSp->FileObject;
        NwSetFileObject( IrpSp->FileObject, Fcb->NonPagedFcb, *Icb  );
        (*Icb)->Exists = FullNameExists;
        (*Icb)->IsAFile = FullNameIsAFile;

        try_return(Iosb.Status = STATUS_SUCCESS);

try_exit: NOTHING;

    } finally {


        if ( AbnormalTermination() || !NT_SUCCESS( Iosb.Status ) ) {

            //
            //  Failed to create
            //

            if ( *Icb != NULL ) {
                NwDeleteIcb( NULL, *Icb );
                *Icb = NULL;
            }
        }
    }

    DebugTrace(-1, Dbg, "OpenRenameTarget\n", Iosb.Status);

    return( Iosb );
}


IO_STATUS_BLOCK
CreatePrintJob(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb,
    PUNICODE_STRING DriveName
    )
/*++

Routine Description:

    This routines create a new directory.

Arguments:

    IrpContext - Supplies all the information

    Vcb - A pointer to the VCB for the remote print queue.

    Icb - A pointer to the newly created ICB.

    DriveName - LPTx

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;
    ANSI_STRING ODriveName;
    static CHAR LptName[] = "LPT" ;
    ULONG       PrintOptions;
    PLOGON      Logon;
    PUNICODE_STRING BannerName;

    PAGED_CODE();

    BannerName = &IrpContext->pScb->UserName;
    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    Logon = FindUser( &IrpContext->pScb->UserUid, TRUE );
    if ( Logon == NULL ) {
        PrintOptions = NwPrintOptions;
    } else {
        PrintOptions = Logon->NwPrintOptions;
        /*
         * If user name is GUEST, use the validated user name
         */
        if ((BannerName->Length == 0 ) ||
            (RtlCompareUnicodeString( BannerName, &Guest.UserName, TRUE ) == 0 )) {
            BannerName = &Logon->UserName;
        }
    }
    NwReleaseRcb( &NwRcb );

    //
    //  Make sure the print queue name is correct.
    //

    if ( Icb->SuperType.Fcb->RelativeFileName.Length != 0 ) {
        Iosb.Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        return( Iosb );
    }

    //
    //  Send a create queue job packet, and wait the response.
    //

    if ((DriveName->Length == 0 ) ||
        (!NT_SUCCESS(RtlUnicodeStringToOemString( &ODriveName, DriveName, TRUE )))) {
        //
        // if we dont have a name, use the string "LPT". we do this because
        // some printers insist on a name.
        //

        RtlInitString(&ODriveName, LptName);
    }


    Iosb.Status = ExchangeWithWait (
                                   IrpContext,
                                   SynchronousResponseCallback,
                                   "Sd_ddw_b_r_bbwwww_x-x_",  // Format string
                                   NCP_ADMIN_FUNCTION, NCP_CREATE_QUEUE_JOB,
                                   Vcb->Specific.Print.QueueId,// Queue ID
                                   6,                        // Skip bytes
                                   0xffffffff,               // Target Server ID number
                                   0xffffffff, 0xffff,       // Target Execution time
                                   11,                       // Skip bytes
                                   0x00,                     // Job Control Flags
                                   26,                       // Skip bytes
                                   ODriveName.Buffer, ODriveName.Length, // Description
                                   50 - ODriveName.Length ,              // Description pad
                                   0,                        // Version number
                                   8,                        // Tab Size
                                   1,                        // Number of copies
                                   PrintOptions,             // Control Flags
                                   0x3C,                     // Maximum lines
                                   0x84,                     // Maximum characters
                                   22,                       // Skip bytes
                                   BannerName, 13,           // Banner Name
                                   &Vcb->ShareName, 12,      // Header Name
                                   1+14+80                   // null last string & skip rest of client area
                                   );


    //
    // free the string if it was allocated
    //
    if (ODriveName.Buffer != LptName)
        RtlFreeAnsiString(&ODriveName);

    if ( NT_SUCCESS( Iosb.Status ) ) {
        Iosb.Status = ParseResponse(
                          IrpContext,
                          IrpContext->rsp,
                          IrpContext->ResponseLength,
                          "N_w_r",
                          22,
                          &Icb->JobId,
                          18,
                          Icb->Handle, sizeof(Icb->Handle) );

    }

    if ( NT_SUCCESS( Iosb.Status ) ) {

        Fcb = Icb->SuperType.Fcb;

        Fcb->NonPagedFcb->Attributes = 0;
        Fcb->CreationDate = 0;
        Fcb->LastAccessDate = 0;
        Fcb->LastModifiedDate = 0;
        Fcb->LastModifiedTime = 0;

        Icb->HasRemoteHandle = TRUE;
        Icb->IsPrintJob = TRUE;
        Icb->ActuallyPrinted = FALSE;

        SetFlag( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID );

    }

    //
    //  Set information field assuming success.  It will be ignored
    //  if the NCP failed.
    //

    Iosb.Information = FILE_CREATED;

    if ( Iosb.Status == STATUS_UNSUCCESSFUL ) {
        Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
    }


    return( Iosb );
}

VOID
CloseFile(
    PIRP_CONTEXT pIrpContext,
    PICB pIcb
    )
/*++

Routine Description:

    This routines closes an opened file.

Arguments:

    pIrpContext - Supplies all the information

    pIcb - A pointer to the newly created ICB.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ExchangeWithWait(
        pIrpContext,
        SynchronousResponseCallback,
        "F-r",
        NCP_CLOSE,
        pIcb->Handle, 6 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\data.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NwData.c

Abstract:

    This module declares the global data used by the Nw file system.

Author:

    Colin Watson     [ColinW]        19-Dec-1992
    Anoop Anantha    [AnoopA]        24-Jun-1998

Revision History:

--*/

#include "Procs.h"
#include <stdlib.h>

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

PEPROCESS FspProcess;

PDEVICE_OBJECT FileSystemDeviceObject = NULL;

//
// The volume control block for the redirector device.
//

RCB NwRcb;

//
//  The ScbSpinLock protects the entire ScbQueue and the first part of the
//  Scb entries on the queue. The first part of the Scb includes the name
//  of the server and a reference count
//

KSPIN_LOCK ScbSpinLock;
LIST_ENTRY ScbQueue;

//
// The NwTimerSpinLock protects the Timer and TimerStop flag.
//

KSPIN_LOCK NwTimerSpinLock;

//
// A permanent SCB to synchronize access to the network.
//

NONPAGED_SCB NwPermanentNpScb;

LARGE_INTEGER NwMaxLarge  = {MAXULONG,MAXLONG};

//
// tommye MS 90541 / MCS 277
// 
// Set NwAbsoluteTotalWaitTime to 200, which is 100 half-seconds (duh).  This gets
// referenced in NwProcessPositiveAck, which comes from the TimerDPC about every 
// half second or so.  This is the longest about of retries that we will send a 
// packet that we've gotten a positive ACK on.
//

ULONG NwAbsoluteTotalWaitTime = 200;

TDI_ADDRESS_IPX OurAddress = {0,0,0,0,0,0,0,0};
UNICODE_STRING IpxTransportName;
HANDLE IpxHandle = NULL;
PDEVICE_OBJECT pIpxDeviceObject = NULL;
PFILE_OBJECT pIpxFileObject = NULL;

LIST_ENTRY LogonList;
LOGON Guest;
LARGE_INTEGER DefaultLuid = ANONYMOUS_LOGON_LUID;

//
//  A global list of VCBs, and a monotonic increasing VCB entry, used to
//  control connection enumeration.
//

LIST_ENTRY GlobalVcbList;
ULONG CurrentVcbEntry;

#if 0
//
//   HACKHACK - List of outstanding find notify request
//   Protected by NwRcb resource.
//

LIST_ENTRY FnList;
#endif

//
//  Drive mapping table of redirected drives.  26 disk drive mappings +
//  10 LPT mappings.
//
//  Netware supports 32 disk redirections, but this funkiness is handled
//  by the 16-bit code.
//

PVCB GlobalDriveMapTable[DRIVE_MAP_TABLE_SIZE];  //MultiUser

FAST_IO_DISPATCH NwFastIoDispatch;

//
//  Scavenger related data
//

ULONG NwScavengerTickCount;     // The current tick count
ULONG NwScavengerTickRunCount;  // The count at which to run the scavenger routine
KSPIN_LOCK NwScavengerSpinLock; // Lock to protect access to the above.

//
//  Worker thread 
//

BOOLEAN WorkerThreadRunning = FALSE;

//
//  Message queue data
//

LIST_ENTRY NwGetMessageList;    // List of Get Message IRP contexts
KSPIN_LOCK NwMessageSpinLock;   // Protects the list above.

//
//  Pending lock list
//

LIST_ENTRY NwPendingLockList;    // List of pending File lock IRP contexts
KSPIN_LOCK NwPendingLockSpinLock;// Protects the list above.

//
//  Lock to synchronize all file opens.
//

ERESOURCE NwOpenResource;

//
//  Configuration data
//

LONG PreferNDSBrowsing = 0;  // when attempting to connect to UNC paths, attempt NDS connection first

BOOLEAN NwBurstModeEnabled = FALSE;
ULONG NwMaxSendSize = 0;
ULONG NwMaxReceiveSize = 0;
ULONG NwPrintOptions = 0x98;
UNICODE_STRING NwProviderName = { 0, 0, NULL };

LONG MaxSendDelay = 50000;
LONG MaxReceiveDelay = 50000;
LONG MinSendDelay = 0;
LONG MinReceiveDelay = 0;
LONG BurstSuccessCount = 1;
LONG BurstSuccessCount2 = 3;
LONG AllowGrowth = 0;
LONG DontShrink = 0;
LONG SendExtraNcp = 1;
LONG DefaultMaxPacketSize = 0;
LONG PacketThreshold = 1500;        // Size to use Large vs Small PacketAdjustment
LONG LargePacketAdjustment = 38;
LONG LipPacketAdjustment = 0;
LONG LipAccuracy = BURST_PACKET_SIZE_TOLERANCE;
LONG Japan = 0;     //  Controls special DBCS translation
LONG Korean = 0;     //  Controls special Korean translation
LONG DisableReadCache = 0;           // disable file i/o read cache
LONG DisableWriteCache = 0;          // disable file i/o write cache
LONG FavourLongNames = 1 ;           // use LFN where possible
DWORD LongNameFlags = 0;             // flags for handling long names
ULONG DirCacheEntries = 1;           // number of directory entries we cache
LARGE_INTEGER TimeOutEventInterval = {0, 0};
LONG MaxWriteTimeout  = 50 ;         // tick counts (see write.c)
LONG MaxReadTimeout   = 50 ;         // tick counts (see read.c)
LONG WriteTimeoutMultiplier = 100;   // expressed as percentage (see write.c)
LONG ReadTimeoutMultiplier = 100;    // expressed as percentage (see read.c)

ULONG EnableMultipleConnects = 0;
ULONG AllowSeedServerRedirection = 0;

ULONG ReadExecOnlyFiles = 0;
ULONG DisableAltFileName = 1;

ULONG NdsObjectCacheSize = 0;
ULONG NdsObjectCacheTimeout = 10;

//
//  Static storage area for perfmon statistics
//

NW_REDIR_STATISTICS Stats;
ULONG ContextCount = 0;

//
//  Data structure used to track discardable code.
//

SECTION_DESCRIPTOR NwSectionDescriptor;
ERESOURCE NwUnlockableCodeResource;

//
//  The lock timeout value.
//

ULONG LockTimeoutThreshold = 1;

//
// The Kernel Queue from where the reconnect work items are picked up.
//

KQUEUE  KernelQueue;

#ifndef _PNP_POWER_

//
// The TDI PNP Bind handle.
//

HANDLE TdiBindingHandle = NULL;
UNICODE_STRING TdiIpxDeviceName;
WCHAR IpxDevice[] = L"\\Device\\NwlnkIpx";

#endif

//
// We can't have the scavenger and a line change request running
// at the same time since they both run on worker threads and
// walk across all the SCBs.  Therefore, when either is running,
// we set the WorkerRunning value used by the scavenger to TRUE.
// If a scavenger run tries to happen while a line change request
// is running, it gets skipped.  If a line change request comes in
// while the scavenger is running, we set DelayedProcessLineChange
// to TRUE and run it when the scavenger finishes.
//
// These values are protected by the existing scavenger spin lock.
//

BOOLEAN DelayedProcessLineChange = FALSE;
PIRP DelayedLineChangeIrp = NULL;

#ifdef NWDBG

ULONG NwDebug = 0;
//ULONG NwDebug = 0xffffffbf;
ULONG NwMemDebug = 0xffffffff;
LONG NwDebugTraceIndent = 0;

ULONG NwFsdEntryCount = 0;
ULONG NwFspEntryCount = 0;
ULONG NwIoCallDriverCount = 0;

LONG NwPerformanceTimerLevel = 0x00000000;

ULONG NwTotalTicks[32] = { 0 };

//
//  Debug data for tracking pool usage
//

KSPIN_LOCK NwDebugInterlock;
ERESOURCE NwDebugResource;

LIST_ENTRY NwPagedPoolList;
LIST_ENTRY NwNonpagedPoolList;

ULONG MdlCount;
ULONG IrpCount;

#endif // NWDBG

//
//  Configurable parameters.
//

SHORT DefaultRetryCount = DEFAULT_RETRY_COUNT;

#ifdef _PNP_POWER_
BOOLEAN fPoweringDown = FALSE;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwInitializeData )
#endif

VOID
NwInitializeData(
    VOID
    )
{
    LARGE_INTEGER Now;

    PAGED_CODE();

    NwRcb.State = RCB_STATE_STOPPED;

#ifdef NWDBG
    //  Initialize pool before allocating any memory
    InitializeListHead( &NwPagedPoolList );
    InitializeListHead( &NwNonpagedPoolList );
    ExInitializeResourceLite( &NwDebugResource );
    KeInitializeSpinLock( &NwDebugInterlock );

    MdlCount = 0;
    IrpCount = 0;
#endif

    ExInitializeResourceLite( &NwOpenResource );

    //
    //  Initialize the scavenger spin lock and run tick count.
    //

    KeInitializeSpinLock( &NwScavengerSpinLock );
    NwScavengerTickRunCount = DEFAULT_SCAVENGER_TICK_RUN_COUNT;

    //
    //  Initialize the timer spin lock.
    //

    KeInitializeSpinLock( &NwTimerSpinLock );

    RtlInitUnicodeString( &IpxTransportName, NULL );

#ifndef _PNP_POWER_

    RtlInitUnicodeString( &TdiIpxDeviceName, IpxDevice );

#endif

    //
    //  Allocate a permanent Non-paged SCB.  This SCB is used to
    //  synchronize access to finding the nearest server.
    //  This initialization must be done before the first possible call
    //  to UnloadDriver.
    //

    RtlZeroMemory( &NwPermanentNpScb, sizeof( NONPAGED_SCB ) );

    NwPermanentNpScb.NodeTypeCode = NW_NTC_SCBNP;
    NwPermanentNpScb.NodeByteSize = sizeof(NONPAGED_SCB);
    NwPermanentNpScb.Reference = 1;

    InitializeListHead( &NwPermanentNpScb.Requests );

    //
    //  Initialize the logonlist to have a default entry with server NULL,
    //  username "GUEST" and null password. This will always be the last
    //  entry on the logonlist so that the workstation service can supply
    //  an override.
    //

    InitializeListHead( &LogonList );

    Guest.NodeTypeCode = NW_NTC_LOGON;
    Guest.NodeByteSize = sizeof(LOGON);
    {    
        //Multi-user. Initialize the DriveMapTable
        int i;
        for ( i = 0; i < DRIVE_MAP_TABLE_SIZE; i ++ )     
            Guest.DriveMapTable[i] = NULL;
    }
    RtlInitUnicodeString( &Guest.ServerName, NULL );
    RtlInitUnicodeString( &Guest.PassWord, NULL );
    RtlInitUnicodeString( &Guest.UserName, L"GUEST" );
    Guest.UserUid = DefaultLuid;
    InitializeListHead( &Guest.NdsCredentialList );
    InsertTailList( &LogonList, &Guest.Next );

    //
    //  Initialize the global VCB list.
    //

    InitializeListHead( &GlobalVcbList );
    CurrentVcbEntry = 1;

    //
    //  Initialize the Get message queue.
    //

    InitializeListHead( &NwGetMessageList );
    KeInitializeSpinLock( &NwMessageSpinLock );

    //
    //  Initialize the Pending lock queue.
    //

    InitializeListHead( &NwPendingLockList );
    KeInitializeSpinLock( &NwPendingLockSpinLock );

    //
    //  Insert the Permanent SCB in the global list of SCBs.
    //

    InsertHeadList( &ScbQueue, &NwPermanentNpScb.ScbLinks );

    //
    //  Initialize the Kernel Queue Object. Only one thread has to
    //  be concurrently active.
    //

    KeInitializeQueue( &KernelQueue, 1 ); 

    //
    // Spawn off our own worker thread which will service reroute and
    // reconnect attempts.
    //

    SpawnWorkerThread();

#if 0
    //  HACKHACK
    InitializeListHead( &FnList );
#endif

    //
    //  Seed the random number generator.
    //

    KeQuerySystemTime( &Now );
    srand( Now.LowPart );

    RtlZeroMemory( &Stats, sizeof( NW_REDIR_STATISTICS ) );

    ExInitializeResourceLite( &NwUnlockableCodeResource );

    NwSectionDescriptor.Base = BurstReadTimeout;
    NwSectionDescriptor.Handle = 0;
    NwSectionDescriptor.ReferenceCount = 0;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\dir.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements the file directory routines for the
    Netware Redirector.

Author:

    Manny Weiser (mannyw)     4-Mar-1993

Revision History:

--*/

#include "procs.h"


//
// Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)

NTSTATUS
NwCommonDirectoryControl (
    IN PIRP_CONTEXT pIrpContext
    );

NTSTATUS
NwQueryDirectory (
    IN PIRP_CONTEXT pIrpContext,
    IN PICB pIcb
    );

NTSTATUS
GetNextFile(
    PIRP_CONTEXT pIrpContext,
    PICB Icb,
    PULONG fileIndexLow,
    PULONG fileIndexHigh,
    UCHAR SearchAttributes,
    PNW_DIRECTORY_INFO NwDirInfo
    );

NTSTATUS
NtSearchMaskToNw(
    IN PUNICODE_STRING UcSearchMask,
    IN OUT POEM_STRING OemSearchMask,
    IN PICB Icb,
    IN BOOLEAN ShortNameSearch
    );

#if 0
VOID
NwCancelFindNotify (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdDirectoryControl )
#pragma alloc_text( PAGE, NwQueryDirectory )
#pragma alloc_text( PAGE, GetNextFile )
#pragma alloc_text( PAGE, NtSearchMaskToNw )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, NwCommonDirectoryControl )
#endif

#endif


#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdDirectoryControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the FSD routine that handles directory control
    functions (i.e., query and notify).

Arguments:

    NwfsDeviceObject - Supplies the device object for the directory function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.

--*/

{
    PIRP_CONTEXT pIrpContext = NULL;
    NTSTATUS status;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdDirectoryControl\n", 0);

    //
    // Call the common directory control routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonDirectoryControl( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            // We had some trouble trying to perform the requested
            // operation, so we'll abort the I/O request with
            // the error status that we get back from the
            // execption code.
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
        }

    }

    if ( pIrpContext ) {
        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdDirectoryControl -> %08lx\n", status );

    return status;
}


NTSTATUS
NwCommonDirectoryControl (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine does the common code for directory control functions.

Arguments:

    IrpContext - Supplies the request being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS status;

    PIRP Irp;
    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PDCB dcb;
    PVOID fsContext;

    //
    //  Get the current stack location
    //

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "CommonDirectoryControl...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG_PTR)Irp);

    //
    // Decode the file object to figure out who we are.  If the result
    // is not an ICB then its an illegal parameter.
    //

    if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            (PVOID *)&icb )) != NW_NTC_ICB) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status );
        return status;
    }

    dcb = (PDCB)icb->SuperType.Fcb;
    nodeTypeCode = dcb->NodeTypeCode;

    if ( nodeTypeCode != NW_NTC_DCB ) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status );
        return status;
    }

    IrpContext->pScb = icb->SuperType.Fcb->Scb;
    IrpContext->pNpScb = IrpContext->pScb->pNpScb;
    IrpContext->Icb = icb;

    //
    // Acquire exclusive access to the DCB. Get to front of queue
    // first to avoid deadlock potential.
    //

    NwAppendToQueueAndWait( IrpContext );
    NwAcquireExclusiveFcb( dcb->NonPagedFcb, TRUE );

    try {

        NwVerifyIcb( icb );

        //
        // We know this is a directory control so we'll case on the
        // minor function, and call the appropriate work routines.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DIRECTORY:

            status = NwQueryDirectory( IrpContext, icb );
            break;

        case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

#if 0
            if ( !icb->FailedFindNotify ) {
                icb->FailedFindNotify = TRUE;
#endif
                status = STATUS_NOT_SUPPORTED;
#if 0
            } else {

                //
                // HACKHACK
                // Cover for process that keeps trying to use
                // find notify even though we don't support it.
                //

                NwAcquireExclusiveRcb( &NwRcb, TRUE );
                IoAcquireCancelSpinLock( &Irp->CancelIrql );

                if ( Irp->Cancel ) {
                    status = STATUS_CANCELLED;
                } else {
                    InsertTailList( &FnList, &IrpContext->NextRequest );
                    IoMarkIrpPending( Irp );
                    IoSetCancelRoutine( Irp, NwCancelFindNotify );
                    status = STATUS_PENDING;
                }

                IoReleaseCancelSpinLock( Irp->CancelIrql );
                NwReleaseRcb( &NwRcb );

            }
#endif

            break;

        default:

            //
            // For all other minor function codes we say they're invalid
            // and complete the request.
            //

            DebugTrace(0, Dbg, "Invalid FS Control Minor Function Code %08lx\n", irpSp->MinorFunction);

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    } finally {

        NwDequeueIrpContext( IrpContext, FALSE );

        NwReleaseFcb( dcb->NonPagedFcb );
        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status);
    }

    return status;
}


NTSTATUS
NwQueryDirectory (
    IN PIRP_CONTEXT pIrpContext,
    IN PICB Icb
    )

/*++

Routine Description:

    This is the work routine for querying a directory.

Arugments:

    IrpContext - Supplies the Irp context information.

    Icb - Pointer the ICB for the request.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    PUCHAR buffer;
    CLONG systemBufferLength;
    UNICODE_STRING searchMask;
    ULONG fileIndexLow;
    ULONG fileIndexHigh;
    FILE_INFORMATION_CLASS fileInformationClass;
    BOOLEAN restartScan;
    BOOLEAN returnSingleEntry;
    BOOLEAN indexSpecified;
    PVCB vcb;

    BOOLEAN ansiStringAllocated = FALSE;
    UCHAR SearchAttributes;
    BOOLEAN searchRetry;

    static WCHAR star[] = L"*";

    BOOLEAN caseInsensitive = TRUE; //*** Make searches case insensitive

    ULONG lastEntry;
    ULONG nextEntry;
    ULONG totalBufferLength = 0;

    PFILE_BOTH_DIR_INFORMATION dirInfo;
    PFILE_NAMES_INFORMATION namesInfo;

    BOOLEAN canContinue = FALSE;
    BOOLEAN useCache = FALSE;
    BOOLEAN lastIndexFromServer = FALSE;
    PNW_DIRECTORY_INFO dirCache;
    PLIST_ENTRY entry;
    ULONG i;
    
    PAGED_CODE();

    //
    // Get the current stack location.
    //

    Irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    vcb = Icb->SuperType.Fcb->Vcb;

    DebugTrace(+1, Dbg, "NwQueryDirectory\n", 0 );
    DebugTrace( 0, Dbg, "Icb                  = %08lx\n", (ULONG_PTR)Icb);
    DebugTrace( 0, Dbg, "SystemBuffer         = %08lx\n", (ULONG_PTR)Irp->AssociatedIrp.SystemBuffer);
    DebugTrace( 0, Dbg, "Length               = %08lx\n", irpSp->Parameters.QueryDirectory.Length);
    DebugTrace( 0, Dbg, "Search Mask          = %08lx\n", (ULONG_PTR)irpSp->Parameters.QueryDirectory.FileName);
    DebugTrace( 0, Dbg, "FileIndex            = %08lx\n", irpSp->Parameters.QueryDirectory.FileIndex);
    DebugTrace( 0, Dbg, "FileInformationClass = %08lx\n", irpSp->Parameters.QueryDirectory.FileInformationClass);
    DebugTrace( 0, Dbg, "RestartScan          = %08lx\n", BooleanFlagOn(irpSp->Flags, SL_RESTART_SCAN));
    DebugTrace( 0, Dbg, "ReturnSingleEntry    = %08lx\n", BooleanFlagOn(irpSp->Flags, SL_RETURN_SINGLE_ENTRY));
    DebugTrace( 0, Dbg, "IndexSpecified       = %08lx\n", BooleanFlagOn(irpSp->Flags, SL_INDEX_SPECIFIED));

    //
    // Make local copies of the input parameters.
    //

    systemBufferLength = irpSp->Parameters.QueryDirectory.Length;

    restartScan = BooleanFlagOn(irpSp->Flags, SL_RESTART_SCAN);
    indexSpecified = BooleanFlagOn(irpSp->Flags, SL_INDEX_SPECIFIED);
    returnSingleEntry = BooleanFlagOn(irpSp->Flags, SL_RETURN_SINGLE_ENTRY);

    fileIndexLow = 0;
    fileIndexHigh = 0;

    fileInformationClass =
            irpSp->Parameters.QueryDirectory.FileInformationClass;

    if (irpSp->Parameters.QueryDirectory.FileName != NULL) {
        searchMask = *(PUNICODE_STRING)irpSp->Parameters.QueryDirectory.FileName;
    } else {
        searchMask.Length = 0;
        searchMask.Buffer = NULL;
    }

    buffer = Irp->UserBuffer;
    DebugTrace(0, Dbg, "Users Buffer -> %08lx\n", buffer);

    //
    //  It is ok to attempt a reconnect if this request fails with a
    //  connection error.
    //

    SetFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    // Check if the ICB already has a query template attached.  If it
    // does not already have one then we either use the string we are
    // given or we attach our own containing "*"
    //

    if ( Icb->NwQueryTemplate.Buffer == NULL ) {

        //
        // This is our first time calling query directory so we need
        // to either set the query template to the user specified string
        // or to "*.*".
        //

        if ( searchMask.Buffer == NULL ) {

            DebugTrace(0, Dbg, "Set template to *", 0);

            searchMask.Length = sizeof( star ) - sizeof(WCHAR);
            searchMask.Buffer = star;

        }

        DebugTrace(0, Dbg, "Set query template -> %wZ\n", (ULONG_PTR)&searchMask);

        //
        //  Map the NT search names to NCP.  Note that this must be
        //  done after the Unicode to OEM translation.
        //

        searchRetry = FALSE;

        do {

            status = NtSearchMaskToNw(
                         &searchMask,
                         &Icb->NwQueryTemplate,
                         Icb,
                         searchRetry );

            if ( !NT_SUCCESS( status ) ) {
                DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", status);
                return( status );
            }

            Icb->UQueryTemplate.Buffer = ALLOCATE_POOL( PagedPool, searchMask.Length );
            if (Icb->UQueryTemplate.Buffer == NULL ) {
                DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", STATUS_INSUFFICIENT_RESOURCES );
                return( STATUS_INSUFFICIENT_RESOURCES );
            }

            Icb->UQueryTemplate.MaximumLength = searchMask.Length;
            RtlCopyUnicodeString( &Icb->UQueryTemplate, &searchMask );

            //
            //  Now send a Search Initialize NCP.
            //
            //  Do a short search if the server doesn't support long names,
            //  or this is a short-name non-wild card search
            //

            if ( !Icb->ShortNameSearch ) {

                status = ExchangeWithWait(
                             pIrpContext,
                             SynchronousResponseCallback,
                             "Lbb-DbC",
                             NCP_LFN_SEARCH_INITIATE,
                             vcb->Specific.Disk.LongNameSpace,
                             vcb->Specific.Disk.VolumeNumber,
                             vcb->Specific.Disk.Handle,
                             LFN_FLAG_SHORT_DIRECTORY,
                             &Icb->SuperType.Fcb->RelativeFileName );

                if ( NT_SUCCESS( status ) ) {

                    status = ParseResponse(
                                 pIrpContext,
                                 pIrpContext->rsp,
                                 pIrpContext->ResponseLength,
                                 "Nbee",
                                 &Icb->SearchVolume,
                                 &Icb->SearchIndexHigh,
                                 &Icb->SearchIndexLow );
                }

            } else {

                status = ExchangeWithWait(
                             pIrpContext,
                             SynchronousResponseCallback,
                            "FbJ",
                             NCP_SEARCH_INITIATE,
                             vcb->Specific.Disk.Handle,
                             &Icb->SuperType.Fcb->RelativeFileName );

                if ( NT_SUCCESS( status ) ) {

                    status = ParseResponse(
                                 pIrpContext,
                                 pIrpContext->rsp,
                                 pIrpContext->ResponseLength,
                                 "Nbww-",
                                 &Icb->SearchVolume,
                                 &Icb->SearchHandle,
                                 &Icb->SearchIndexLow );
                }

            }

            //
            //  If we couldn't find the search path, and we did a long
            //  name search initiate, try again with a short name.
            //

            if ( status == STATUS_OBJECT_PATH_NOT_FOUND &&
                 !Icb->ShortNameSearch ) {

                searchRetry = TRUE;

                if ( Icb->UQueryTemplate.Buffer != NULL ) {
                    FREE_POOL( Icb->UQueryTemplate.Buffer );
                }

                RtlFreeOemString ( &Icb->NwQueryTemplate );

            } else {
                searchRetry = FALSE;
            }


        } while ( searchRetry );

        if ( !NT_SUCCESS( status ) ) {
            if (status == STATUS_UNSUCCESSFUL) {
                DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", STATUS_NO_SUCH_FILE);
                return( STATUS_NO_SUCH_FILE );
            }
            DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", status);
            return( status );
        }

        //
        //  Since we are doing a search we will need to send an End Of Job
        //  for this PID.
        //

        NwSetEndOfJobRequired(pIrpContext->pNpScb, Icb->Pid );

        fileIndexLow = Icb->SearchIndexLow;
        fileIndexHigh = Icb->SearchIndexHigh;

        //
        //  We can't ask for both files and directories, so first ask for
        //  files, then ask for directories.
        //

        SearchAttributes = NW_ATTRIBUTE_SYSTEM |
                           NW_ATTRIBUTE_HIDDEN |
                           NW_ATTRIBUTE_READ_ONLY;

        //
        //  If there are no wildcards in the search mask, then setup to
        //  not generate the . and .. entries.
        //

        if ( !FsRtlDoesNameContainWildCards( &Icb->UQueryTemplate ) ) {
            Icb->DotReturned = TRUE;
            Icb->DotDotReturned = TRUE;
        } else {
            Icb->DotReturned = FALSE;
            Icb->DotDotReturned = FALSE;
        }


    } else {

        //
        // Check if we were given an index to start with or if we need to
        // restart the scan or if we should use the index that was saved in
        // the ICB.
        //

        if (restartScan) {

            useCache = FALSE;
            fileIndexLow = (ULONG)-1;
            fileIndexHigh = Icb->SearchIndexHigh;

            //
            //  Send a Search Initialize NCP. The server often times out search
            //  handles and if this one has been sitting at the end of the
            //  directory then its likely we would get no files at all!
            //
            //  Do a short search if the server doesn't support long names,
            //  or this is a short-name non-wild card search
            //

            if ( !Icb->ShortNameSearch ) {

                status = ExchangeWithWait(
                             pIrpContext,
                             SynchronousResponseCallback,
                             "Lbb-DbC",
                             NCP_LFN_SEARCH_INITIATE,
                             vcb->Specific.Disk.LongNameSpace,
                             vcb->Specific.Disk.VolumeNumber,
                             vcb->Specific.Disk.Handle,
                             LFN_FLAG_SHORT_DIRECTORY,
                             &Icb->SuperType.Fcb->RelativeFileName );

                if ( NT_SUCCESS( status ) ) {

                    status = ParseResponse(
                                 pIrpContext,
                                 pIrpContext->rsp,
                                 pIrpContext->ResponseLength,
                                 "Nbee",
                                 &Icb->SearchVolume,
                                 &Icb->SearchIndexHigh,
                                 &Icb->SearchIndexLow );
                }

            } else {

                status = ExchangeWithWait(
                             pIrpContext,
                             SynchronousResponseCallback,
                            "FbJ",
                             NCP_SEARCH_INITIATE,
                             vcb->Specific.Disk.Handle,
                             &Icb->SuperType.Fcb->RelativeFileName );

                if ( NT_SUCCESS( status ) ) {

                    status = ParseResponse(
                                 pIrpContext,
                                 pIrpContext->rsp,
                                 pIrpContext->ResponseLength,
                                 "Nbww-",
                                 &Icb->SearchVolume,
                                 &Icb->SearchHandle,
                                 &Icb->SearchIndexLow );
                }

            }

            Icb->ReturnedSomething = FALSE;

            //
            //  We can't ask for both files and directories, so first ask for
            //  files, then ask for directories.
            //

            SearchAttributes = NW_ATTRIBUTE_SYSTEM |
                               NW_ATTRIBUTE_HIDDEN |
                               NW_ATTRIBUTE_READ_ONLY;
            Icb->SearchAttributes = SearchAttributes;

            Icb->DotReturned = FALSE;
            Icb->DotDotReturned = FALSE;

        } else if ((!indexSpecified) ||
                   (canContinue) ) {
            //
            //  Continue from the one of the last filenames.
            //

            SearchAttributes = Icb->SearchAttributes;
            if( !indexSpecified ) {

                useCache = FALSE;
                fileIndexLow = Icb->SearchIndexLow;
                fileIndexHigh = Icb->SearchIndexHigh;
            }

            if ( SearchAttributes == 0xFF && fileIndexLow == Icb->SearchIndexLow ) {

                //
                //  This is a completed search.
                //

                DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", STATUS_NO_MORE_FILES);
                return( STATUS_NO_MORE_FILES );
            }

        } else {

            //
            //  Someone's trying to do a resume from key.  The netware
            //  server doesn't support this, so neither do we.
            //

            DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", STATUS_NOT_IMPLEMENTED);
            return( STATUS_NOT_IMPLEMENTED );
        }

    }

    //
    //  Now we are committed to completing the Irp, we do that in
    //  the finally clause of the following try.
    //

    try {

        ULONG baseLength;
        ULONG lengthAdded;
        PNW_DIRECTORY_INFO nwDirInfo;
        ULONG FileNameLength;
        ULONG entriesToCreate;

        lastEntry = 0;
        nextEntry = 0;

        switch (fileInformationClass) {

        case FileDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName[0] );
            break;

        case FileFullDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName[0] );
            break;

        case FileNamesInformation:

            baseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION, FileName[0] );
            break;

        case FileBothDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName[0] );
            break;

        default:

            try_return( status = STATUS_INVALID_INFO_CLASS );
        }

        //
        //  It is not ok to attempt a reconnect if this request fails with a
        //  connection error, since our search handle would be invalid.
        //

        ClearFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

        //
        //  See if we have a dir cache.  If not, create one.
        //

        if( !Icb->DirCacheBuffer ) {

            entriesToCreate = 1;

            Icb->DirCacheBuffer = ALLOCATE_POOL ( PagedPool, (sizeof(NW_DIRECTORY_INFO) * entriesToCreate) );
            if( !Icb->DirCacheBuffer ) {
                try_return( status = STATUS_NO_MEMORY );
            }

            RtlZeroMemory( Icb->DirCacheBuffer, sizeof(NW_DIRECTORY_INFO) * entriesToCreate );

            dirCache = (PNW_DIRECTORY_INFO)Icb->DirCacheBuffer;

            for( i = 0; i < entriesToCreate; i++ ) {
                 InsertTailList( &(Icb->DirCache), &(dirCache->ListEntry) );
                 dirCache++;
            }
        }

        while ( TRUE ) {

            ULONG bytesToCopy;
            ULONG bytesRemainingInBuffer;

            DebugTrace(0, Dbg, "Top of Loop\n", 0);
            DebugTrace(0, Dbg, "CurrentIndex = %08lx\n", fileIndexLow);
            DebugTrace(0, Dbg, "LastEntry    = %08lx\n", lastEntry);
            DebugTrace(0, Dbg, "NextEntry    = %08lx\n", nextEntry);

            if( useCache ) {

                //
                // We need to use the data out of the entry we found in the cache.
                // dirCache points to the entry that matches, and the request was not
                // for the last file we read, so the entry after dirCache is the one
                // we want.
                //

                DebugTrace(0, Dbg, "Using cache\n", 0);
                entry = dirCache->ListEntry.Flink;
                dirCache = CONTAINING_RECORD( entry, NW_DIRECTORY_INFO, ListEntry );                
                nwDirInfo = dirCache;
                fileIndexLow = nwDirInfo->FileIndexLow;
                fileIndexHigh = nwDirInfo->FileIndexHigh;
                status = nwDirInfo->Status;

                //
                // Check to see if we should still keep using the cache or not.
                //

                if( entry->Flink == &(Icb->DirCache) ) {
            
                    //
                    // This is the last entry.  We need to stop using the cache.
                    //

                    useCache = FALSE;
                    Icb->CacheHint = NULL;

                } else {
                    Icb->CacheHint = entry;
                }

            } else {

                //
                //  Pull an entry from the dir cache.
                //

                entry = RemoveHeadList( &(Icb->DirCache) );
                nwDirInfo = CONTAINING_RECORD( entry, NW_DIRECTORY_INFO, ListEntry );

                nwDirInfo->FileName.Buffer = nwDirInfo->FileNameBuffer;
                nwDirInfo->FileName.MaximumLength = NW_MAX_FILENAME_SIZE;

                status = GetNextFile(
                             pIrpContext,
                             Icb,
                             &fileIndexLow,
                             &fileIndexHigh,
                             SearchAttributes,
                             nwDirInfo );

                //
                //  Store the return and the file index number,
                //  and then put this entry in the cache.
                //

                nwDirInfo->FileIndexLow = fileIndexLow;
                nwDirInfo->FileIndexHigh = fileIndexHigh;
                nwDirInfo->Status = status;
                InsertTailList( &(Icb->DirCache), &(nwDirInfo->ListEntry) );

                lastIndexFromServer = TRUE;

                //  SVR to avoid rescanning from end of dir all

                if (fileIndexLow != -1) {
                    Icb->LastSearchIndexLow = fileIndexLow;
                }
                //  SVR end

            }

            if ( NT_SUCCESS( status ) ) {

                DebugTrace(0, Dbg, "DirFileName    = %wZ\n", &nwDirInfo->FileName);
                DebugTrace(0, Dbg, "FileIndexLow   = %08lx\n", fileIndexLow);

                FileNameLength = nwDirInfo->FileName.Length;
                bytesRemainingInBuffer = systemBufferLength - nextEntry;

                ASSERT( bytesRemainingInBuffer >= baseLength );


        if (IsTerminalServer() && (LONG)NW_MAX_FILENAME_SIZE < FileNameLength ) 
            try_return( status = STATUS_BUFFER_OVERFLOW );

                //
                //  See how much of the name we will be able to copy into
                //  the system buffer.  This also dictates our return
                //  value.
                //

                if ( baseLength + FileNameLength <= bytesRemainingInBuffer ) {

                    bytesToCopy = FileNameLength;
                    status = STATUS_SUCCESS;

                } else {
                    if (IsTerminalServer()) {
                        try_return( status = STATUS_BUFFER_OVERFLOW );
                    }
                    bytesToCopy = bytesRemainingInBuffer - baseLength;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                //
                //  Note how much of buffer we are consuming and zero
                //  the base part of the structure.
                //

                lengthAdded = baseLength + bytesToCopy;
                RtlZeroMemory( &buffer[nextEntry], baseLength );

                switch (fileInformationClass) {

                case FileBothDirectoryInformation:

                    //
                    //  Fill in the short name, if this is a LFN volume.
                    //

                    DebugTrace(0, Dbg, "Getting directory both information\n", 0);

                    if (!DisableAltFileName) {

                        if ( nwDirInfo->DosDirectoryEntry != 0xFFFF &&
                             !IsFatNameValid( &nwDirInfo->FileName ) ) {

                            UNICODE_STRING ShortName;

                            status = ExchangeWithWait (
                                         pIrpContext,
                                         SynchronousResponseCallback,
                                         "SbDb",
                                         NCP_DIR_FUNCTION, NCP_GET_SHORT_NAME,
                                         Icb->SearchVolume,
                                         nwDirInfo->DosDirectoryEntry,
                                         0 );

                            if ( NT_SUCCESS( status ) ) {

                                dirInfo = (PFILE_BOTH_DIR_INFORMATION)&buffer[nextEntry];

                                //
                                //  Short name is in form 8.3 plus nul terminator.
                                //

                                ShortName.MaximumLength = 13  * sizeof(WCHAR) ;
                                ShortName.Buffer = dirInfo->ShortName;

                                status = ParseResponse(
                                             pIrpContext,
                                             pIrpContext->rsp,
                                             pIrpContext->ResponseLength,
                                             "N_P",
                                             15,
                                             &ShortName );

                                if ( NT_SUCCESS( status ) ) {
                                    dirInfo->ShortNameLength = (CCHAR)ShortName.Length;
                                }
                            }
                        }
                    }

                case FileFullDirectoryInformation:

                    //
                    //  We don't use EaLength, so fill in nothing here.
                    //

                    DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                case FileDirectoryInformation:

                    DebugTrace(0, Dbg, "Getting directory information\n", 0);

                    //
                    //  The eof indicates the number of instances and
                    //  allocation size is the maximum allowed
                    //

                    dirInfo = (PFILE_BOTH_DIR_INFORMATION)&buffer[nextEntry];

                    dirInfo->FileAttributes = nwDirInfo->Attributes;
                    dirInfo->FileNameLength = bytesToCopy;
                    dirInfo->EndOfFile.LowPart = nwDirInfo->FileSize;
                    dirInfo->EndOfFile.HighPart = 0;
                    dirInfo->AllocationSize = dirInfo->EndOfFile;
                    dirInfo->CreationTime = NwDateTimeToNtTime( nwDirInfo->CreationDate, nwDirInfo->CreationTime );
                    dirInfo->LastAccessTime = NwDateTimeToNtTime( nwDirInfo->LastAccessDate, 0 );
                    dirInfo->LastWriteTime = NwDateTimeToNtTime( nwDirInfo->LastUpdateDate, nwDirInfo->LastUpdateTime );
                    dirInfo->ChangeTime = dirInfo->LastWriteTime;
                    dirInfo->FileIndex = 0;
                    break;

                case FileNamesInformation:

                    DebugTrace(0, Dbg, "Getting names information\n", 0);


                    namesInfo = (PFILE_NAMES_INFORMATION)&buffer[nextEntry];

                    namesInfo->FileNameLength = FileNameLength;
                    namesInfo->FileIndex = 0;
                    break;

                default:

                    KeBugCheck( RDR_FILE_SYSTEM );
                }


                // Mapping for Novell's handling of Euro char in file names
                {
                    int index = 0;
                    WCHAR * pCurrChar = nwDirInfo->FileName.Buffer;
                    for (index = 0; index < (nwDirInfo->FileName.Length / 2); index++)
                    {
                        if (*(pCurrChar + index) == (WCHAR) 0x2560) // Its Novell's mapping of a Euro
                            *(pCurrChar + index) = (WCHAR) 0x20AC;  // set it to Euro
                    }
                }

                RtlMoveMemory( &buffer[nextEntry + baseLength],
                               nwDirInfo->FileName.Buffer,
                               bytesToCopy );

                dump( Dbg, &buffer[nextEntry], lengthAdded);
                //
                //  Setup the previous next entry offset.
                //

                *((PULONG)(&buffer[lastEntry])) = nextEntry - lastEntry;
                totalBufferLength = nextEntry + lengthAdded;

                //
                //  Set ourselves up for the next iteration
                //

                lastEntry = nextEntry;
                nextEntry += (ULONG)QuadAlign( lengthAdded );

                //
                //  Check if the last entry didn't completely fit
                //

                if ( status == STATUS_BUFFER_OVERFLOW ) {

                    try_return( NOTHING );
                }

                //
                //  Check if we are only to return a single entry
                //

                if (returnSingleEntry) {
                    try_return( status = STATUS_SUCCESS );
                }

            } else {

                //
                //  The search response contained an error.  If we have
                //  not yet enumerated directories, do them now.  Otherwise,
                //  we are done searching for files.
                //

                if ( status == STATUS_UNSUCCESSFUL &&
                     (!FlagOn(SearchAttributes, NW_ATTRIBUTE_DIRECTORY) || useCache) ) {

                    SetFlag( SearchAttributes, NW_ATTRIBUTE_DIRECTORY );
                    fileIndexLow = (ULONG)-1;
                    continue;

                } else {

                    //
                    //  Remember that this is a completed search and
                    //  quit the loop.
                    //

                    SearchAttributes = 0xFF;
                    break;
                }
            }

            //
            //  Here are the rules concerning filling up the buffer:
            //
            //  1.  The Io system garentees that there will always be
            //      enough room for at least one base record.
            //
            //  2.  If the full first record (including file name) cannot
            //      fit, as much of the name as possible is copied and
            //      STATUS_BUFFER_OVERFLOW is returned.
            //
            //  3.  If a subsequent record cannot completely fit into the
            //      buffer, none of it (as in 0 bytes) is copied, and
            //      STATUS_SUCCESS is returned.  A subsequent query will
            //      pick up with this record.
            //
            //  Since we cannot rewind a search, we'll guess that the
            //  next entry is a full length name.  If it mightn't fix,
            //  just bail and re the files we've got.
            //

            bytesRemainingInBuffer = systemBufferLength - nextEntry;

            if ( baseLength + NW_MAX_FILENAME_SIZE > bytesRemainingInBuffer ) {

                DebugTrace(0, Dbg, "Next entry won't fit\n", 0);
                try_return( status = STATUS_SUCCESS );
            }

        } // while ( TRUE )

    try_exit: NOTHING;
    } finally {

        //
        // At this point we're finished searching for files.
        // If the NextEntry is zero then we haven't found anything so we
        // will return no more files or no such file.
        //

        if ( status == STATUS_NO_MORE_FILES ||
             status == STATUS_UNSUCCESSFUL ||
             status == STATUS_SUCCESS ) {
            if (nextEntry == 0) {
                if (Icb->ReturnedSomething) {
                    status = STATUS_NO_MORE_FILES;
                } else {
                    status = STATUS_NO_SUCH_FILE;
                }
            } else {
                Icb->ReturnedSomething = TRUE;
                status = STATUS_SUCCESS;
            }

        }

        //
        //  Indicate how much of the system buffer we have used up.
        //

        Irp->IoStatus.Information = totalBufferLength;

        //
        //  Remember the last file index, so that we can resume this
        //  search.
        //

        //
        //  Update the last search index read as long as it didn't come from cache.
        //

        if( lastIndexFromServer ) {
            Icb->SearchIndexLow = fileIndexLow;
            Icb->SearchIndexHigh = fileIndexHigh;
        }

        Icb->SearchAttributes = SearchAttributes;

        DebugTrace(-1, Dbg, "NwQueryDirectory -> %08lx\n", status);
    }

    return status;
}

NTSTATUS
GetNextFile(
    PIRP_CONTEXT pIrpContext,
    PICB Icb,
    PULONG FileIndexLow,
    PULONG FileIndexHigh,
    UCHAR SearchAttributes,
    PNW_DIRECTORY_INFO DirInfo
    )
/*++

Routine Description:

    Get the next file in the directory being searched.

Arguments:

    pIrpContext - Supplies the request being processed.

    Icb - A pointer to the ICB for the directory to query.

    FileIndexLow, FileIndexHigh - On entry, the the index of the
        previous directory entry.  On exit, the index to the directory
        entry returned.

    SearchAttributes - Search attributes to use.

    DirInfo - Returns information for the directory entry found.

Return Value:

    NTSTATUS - The result status.

--*/
{
    NTSTATUS status;
    PVCB vcb;

    static UNICODE_STRING DotFile = { 2, 2, L"." };
    static UNICODE_STRING DotDotFile = { 4, 4, L".." };

    PAGED_CODE();

    DirInfo->DosDirectoryEntry = 0xFFFF;

    if ( !Icb->DotReturned ) {

        Icb->DotReturned = TRUE;

        //
        //  Return '.' only if it we are not searching in the root directory
        //  and it matches the search pattern.
        //

        if ( Icb->SuperType.Fcb->RelativeFileName.Length != 0 &&
             FsRtlIsNameInExpression( &Icb->UQueryTemplate, &DotFile, TRUE, NULL ) ) {

            RtlCopyUnicodeString( &DirInfo->FileName, &DotFile );
            DirInfo->Attributes = FILE_ATTRIBUTE_DIRECTORY;
            DirInfo->FileSize = 0;
            DirInfo->CreationDate = DEFAULT_DATE;
            DirInfo->LastAccessDate = DEFAULT_DATE;
            DirInfo->LastUpdateDate = DEFAULT_DATE;
            DirInfo->LastUpdateTime = DEFAULT_TIME;
            DirInfo->CreationTime = DEFAULT_TIME;

            return( STATUS_SUCCESS );
        }
    }

    if ( !Icb->DotDotReturned ) {

        Icb->DotDotReturned = TRUE;

        //
        //  Return '..' only if it we are not searching in the root directory
        //  and it matches the search pattern.
        //

        if ( Icb->SuperType.Fcb->RelativeFileName.Length != 0 &&
             FsRtlIsNameInExpression( &Icb->UQueryTemplate, &DotDotFile, TRUE, NULL ) ) {

            RtlCopyUnicodeString( &DirInfo->FileName, &DotDotFile );
            DirInfo->Attributes = FILE_ATTRIBUTE_DIRECTORY;
            DirInfo->FileSize = 0;
            DirInfo->CreationDate = DEFAULT_DATE;
            DirInfo->LastAccessDate = DEFAULT_DATE;
            DirInfo->LastUpdateDate = DEFAULT_DATE;
            DirInfo->LastUpdateTime = DEFAULT_TIME;
            DirInfo->CreationTime = DEFAULT_TIME;

            return( STATUS_SUCCESS );
        }
    }

    vcb = Icb->SuperType.Fcb->Vcb;
    if ( Icb->ShortNameSearch ) {

        status = ExchangeWithWait(
                     pIrpContext,
                     SynchronousResponseCallback,
                     "Fbwwbp",
                     NCP_SEARCH_CONTINUE,
                     Icb->SearchVolume,
                     Icb->SearchHandle,
                     *(PUSHORT)FileIndexLow,
                     SearchAttributes,
                     Icb->NwQueryTemplate.Buffer
                     );

        if ( !NT_SUCCESS( status )) {
            return status;
        }

        *FileIndexLow = 0;
        *FileIndexHigh = 0;

        if ( FlagOn(SearchAttributes, NW_ATTRIBUTE_DIRECTORY) ) {

            status = ParseResponse(
                         pIrpContext,
                         pIrpContext->rsp,
                         pIrpContext->ResponseLength,
                         "Nw=Rb-ww",
                         FileIndexLow,
                         &DirInfo->FileName, 14,
                         &DirInfo->Attributes,
                         &DirInfo->CreationDate,
                         &DirInfo->CreationTime
                         );

#if 0
            if ( DirInfo->CreationDate == 0 && DirInfo->CreationTime == 0 ) {
                DirInfo->CreationDate = DEFAULT_DATE;
                DirInfo->CreationTime = DEFAULT_TIME;
            }
#endif

            DirInfo->FileSize = 0;
            DirInfo->LastAccessDate = DirInfo->CreationDate;
            DirInfo->LastUpdateDate = DirInfo->CreationDate;
            DirInfo->LastUpdateTime = DirInfo->CreationTime;

        } else {

            status = ParseResponse(
                         pIrpContext,
                         pIrpContext->rsp,
                         pIrpContext->ResponseLength,
                         "Nw=Rb-dwwww",
                         FileIndexLow,
                         &DirInfo->FileName, 14,
                         &DirInfo->Attributes,
                         &DirInfo->FileSize,
                         &DirInfo->CreationDate,
                         &DirInfo->LastAccessDate,
                         &DirInfo->LastUpdateDate,
                         &DirInfo->LastUpdateTime
                         );

            DirInfo->CreationTime = DEFAULT_TIME;
        }

    }  else {

        status = ExchangeWithWait (
                     pIrpContext,
                     SynchronousResponseCallback,
                     "LbbWDbDDp",
                     NCP_LFN_SEARCH_CONTINUE,
                     vcb->Specific.Disk.LongNameSpace,
                     0,   // Data stream
                     SearchAttributes & SEARCH_ALL_DIRECTORIES,
                     LFN_FLAG_INFO_ATTRIBUTES |
                         LFN_FLAG_INFO_FILE_SIZE |
                         LFN_FLAG_INFO_MODIFY_TIME |
                         LFN_FLAG_INFO_CREATION_TIME |
                         LFN_FLAG_INFO_DIR_INFO |
                         LFN_FLAG_INFO_NAME,
                     vcb->Specific.Disk.VolumeNumber,
                     *FileIndexHigh,
                     *FileIndexLow,
                     Icb->NwQueryTemplate.Buffer );

        if ( NT_SUCCESS( status ) ) {
            status = ParseResponse(
                         pIrpContext,
                         pIrpContext->rsp,
                         pIrpContext->ResponseLength,
                         "N-ee_e_e_xx_xx_x_e_P",
                         FileIndexHigh,
                         FileIndexLow,
                         5,
                         &DirInfo->Attributes,
                         2,
                         &DirInfo->FileSize,
                         6,
                         &DirInfo->CreationTime,
                         &DirInfo->CreationDate,
                         4,
                         &DirInfo->LastUpdateTime,
                         &DirInfo->LastUpdateDate,
                         4,
                         &DirInfo->LastAccessDate,
                         14,
                         &DirInfo->DosDirectoryEntry,
                         20,
                         &DirInfo->FileName );
        }

        if ( FlagOn(SearchAttributes, NW_ATTRIBUTE_DIRECTORY) ) {
            DirInfo->FileSize = 0;
        }

    }

    if ( DirInfo->Attributes == 0 ) {
        DirInfo->Attributes = FILE_ATTRIBUTE_NORMAL;
    }

    return status;
}


NTSTATUS
NtSearchMaskToNw(
    IN PUNICODE_STRING UcSearchMask,
    IN OUT POEM_STRING OemSearchMask,
    IN PICB Icb,
    IN BOOLEAN ShortNameSearch
    )
/*++

Routine Description:

    This routine maps a netware path name to the correct netware format.

Arguments:

    UcSearchMask - The search mask in NT format.

    OemSearchMask - The search mask in Netware format.

    Icb - The ICB of the directory in which we are searching.

    ShortNameSearch - If TRUE, always do a short name search.

Return Value:

    NTSTATUS - The result status.

--*/

{
    USHORT i;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  Use a short name search if the volume does not support long names.
    //  or this is a short name ICB, and we are doing a short name, non
    //  wild-card search.
    //

    if ( Icb->SuperType.Fcb->Vcb->Specific.Disk.LongNameSpace == LFN_NO_OS2_NAME_SPACE ||

         ShortNameSearch ||

         ( !BooleanFlagOn( Icb->SuperType.Fcb->Flags, FCB_FLAGS_LONG_NAME ) &&
           !FsRtlDoesNameContainWildCards( UcSearchMask ) &&
           IsFatNameValid( UcSearchMask ) ) ) {

        Icb->ShortNameSearch = TRUE;

        // Mapping for Novell's handling of Euro char in file names
        {
            int index = 0;
            WCHAR * pCurrChar = UcSearchMask->Buffer;
            for (index = 0; index < (UcSearchMask->Length / 2); index++)
            {
                if (*(pCurrChar + index) == (WCHAR) 0x20AC) // Its a Euro
                    *(pCurrChar + index) = (WCHAR) 0x2560;  // set it to Novell's mapping for Euro

            }
        }

        //
        // Allocate space for and initialize the query templates.
        //

        status = RtlUpcaseUnicodeStringToOemString(
                     OemSearchMask,
                     UcSearchMask,
                     TRUE );

        if ( !NT_SUCCESS( status ) ) {
            return( status );
        }

        //
        //  Special case.  Map '*.*' to '*'.
        //

        if ( OemSearchMask->Length == 3 &&
             RtlCompareMemory( OemSearchMask->Buffer, "*.*", 3 ) == 3 ) {

            OemSearchMask->Length = 1;
            OemSearchMask->Buffer[1] = '\0';

        } else {


            for ( i = 0; i < OemSearchMask->Length ; i++ ) {

                //
                // In fact Novell server seems to convert all 0xBF, 0xAA, 0xAE
                // even if they are DBCS lead or trail byte.
                // We can't single out DBCS case in the conversion.
                //

                if( FsRtlIsLeadDbcsCharacter( OemSearchMask->Buffer[i] ) ) {

                    if((UCHAR)(OemSearchMask->Buffer[i]) == 0xBF ) {

                        OemSearchMask->Buffer[i] = (UCHAR)( 0x10 );

                    }else if((UCHAR)(OemSearchMask->Buffer[i]) == 0xAE ) {

                        OemSearchMask->Buffer[i] = (UCHAR)( 0x11 );

                    }else if((UCHAR)(OemSearchMask->Buffer[i]) == 0xAA ) {

                        OemSearchMask->Buffer[i] = (UCHAR)( 0x12 );

                    }

                    i++;
                    
                    if((UCHAR)(OemSearchMask->Buffer[i]) == 0x5C ) {

                        //
                        // The trailbyte is 0x5C, replace it with 0x13
                        //


                        OemSearchMask->Buffer[i] = (UCHAR)( 0x13 );

                    }
                    //
                    // Continue to check other conversions for trailbyte.
                    //
                }

                //  Single byte character that may need modification.
   
                switch ( (UCHAR)(OemSearchMask->Buffer[i]) ) {
   
                case ANSI_DOS_STAR:
                    OemSearchMask->Buffer[i] = (UCHAR)( 0x80 | '*' );
                    break;
   
                case ANSI_DOS_QM:
                    OemSearchMask->Buffer[i] = (UCHAR)( 0x80 | '?' );
                    break;
   
                case ANSI_DOS_DOT:
                    OemSearchMask->Buffer[i] = (UCHAR)( 0x80 | '.' );
                    break;
   
                //
                // Netware Japanese version The following character is
                // replaced with another one if the string is for File
                // Name only when sendding from Client to Server.
                //
                // SO        U+0xFF7F SJIS+0xBF     -> 0x10
                // SMALL_YO  U+0xFF6E SJIS+0xAE     -> 0x11
                // SMALL_E   U+0xFF64 SJIS+0xAA     -> 0x12
                //
                // The reason is unknown, Should ask Novell Japan.
                //
                // See Also exchange.c
   
                case 0xBF: // ANSI_DOS_KATAKANA_SO:
                    if (Japan) {
                        OemSearchMask->Buffer[i] = (UCHAR)( 0x10 );
                    }
                    break;
   
                case 0xAE: // ANSI_DOS_KATAKANA_SMALL_YO:
                    if (Japan) {
                        OemSearchMask->Buffer[i] = (UCHAR)( 0x11 );
                    }
                    break;
   
                case 0xAA: // ANSI_DOS_KATAKANA_SMALL_E:
                    if (Japan) {
                        OemSearchMask->Buffer[i] = (UCHAR)( 0x12 );
                    }
                    break;
                }            
            }
        }

    } else {

        USHORT size;
        PCHAR buffer;
        UNICODE_STRING src;
        OEM_STRING dest;

        Icb->ShortNameSearch = FALSE;

        //
        // Allocate space for and initialize the query templates.
        // We allocate an extra byte to account for the null terminator.
        //

#ifndef QFE_BUILD
        buffer = ExAllocatePoolWithTag( PagedPool,
                                        (UcSearchMask->Length) + 1,
                                        'scwn' );
#else
        buffer = ExAllocatePool( PagedPool,
                                 (UcSearchMask->Length) + 1 );
#endif
        if ( buffer == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        OemSearchMask->Buffer = buffer;

        //
        //  Special case.  Map '????????.???' to '*'.
        //

        if ( UcSearchMask->Length == 24 &&
             RtlCompareMemory( UcSearchMask->Buffer, L">>>>>>>>\">>>", 24 ) == 24 ) {

            OemSearchMask->Length = 3;
            OemSearchMask->Buffer[0] = (UCHAR)0xFF;
            OemSearchMask->Buffer[1] = '*';
            OemSearchMask->Buffer[2] = '\0';

            return STATUS_SUCCESS;
        }

        //
        //  Now convert the string, character by character
        //

        src.Buffer = UcSearchMask->Buffer;
        src.Length = 2;
        dest.Buffer = buffer;
        dest.MaximumLength = UcSearchMask->Length;

        size = UcSearchMask->Length / 2;

        for ( i = 0; i < size ; i++ ) {
            switch ( *src.Buffer ) {

            case L'*':
            case L'?':
                *dest.Buffer++ = LFN_META_CHARACTER;
                *dest.Buffer++ = (UCHAR)*src.Buffer++;
                break;

            case L'.':
                *dest.Buffer++ = (UCHAR)*src.Buffer++;
                break;

            case DOS_DOT:
                *dest.Buffer++ = LFN_META_CHARACTER;
                *dest.Buffer++ = (UCHAR)( 0x80 | '.' );
                src.Buffer++;
                break;

            case DOS_STAR:
                *dest.Buffer++ = LFN_META_CHARACTER;
                *dest.Buffer++ = (UCHAR)( 0x80 | '*' );
                src.Buffer++;
                break;

            case DOS_QM:
                *dest.Buffer++ = LFN_META_CHARACTER;
                *dest.Buffer++ = (UCHAR)( 0x80 | '?' );
                src.Buffer++;
                break;

            case 0x20AC: // Euro
                *src.Buffer = (WCHAR)0x2560; // change it to Novell's mapping 
                // intentional fall-through to get it mapped to OEM

            default:
                RtlUnicodeStringToCountedOemString( &dest, &src, FALSE );
                if( FsRtlIsLeadDbcsCharacter( dest.Buffer[0] ) ) {
                    dest.Buffer++;
                }
                dest.Buffer++;
                src.Buffer++;
            }
        }

        *dest.Buffer = '\0';
        OemSearchMask->Length = (USHORT)( dest.Buffer - buffer );
    }

    return STATUS_SUCCESS;
}

#if 0
VOID
NwCancelFindNotify (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an find notify IRP.

Arguments:

    DeviceObject - ignored

    Irp - Supplies the Irp being cancelled.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;

    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // We now need to void the cancel routine and release the io cancel
    // spin-lock.
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    for ( listEntry = FnList.Flink; listEntry != &FnList ; listEntry = listEntry->Flink ) {

        PIRP_CONTEXT IrpContext;

        IrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );

        if ( IrpContext->pOriginalIrp == Irp ) {
            RemoveEntryList( &IrpContext->NextRequest );
            NwCompleteRequest( IrpContext, STATUS_CANCELLED );
            break;
        }
    }

    NwReleaseRcb( &NwRcb );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\exchange.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Exchange.h

Abstract:

    This module defines all of the objects exported by exchange.c in the
    NetWare redirector.

Author:

    Colin Watson    [ColinW]    1-Feb-1993

Revision History:

--*/

#ifndef _NWEXCHANGE_
#define _NWEXCHANGE_

//
// Define the prototype for post_exchange routines.
//

struct _IRP_CONTEXT;
struct _NONPAGED_SCB;

//
//  Prototype for the exchange routine which starts an NCB transmission
//

NTSTATUS
_cdecl
Exchange
(
    struct _IRP_CONTEXT*    pIrpC,
    PEX             pEx,
    char*           f,
    ...
);

//
//  Prototype of routine that can be used to process the response packet
//

NTSTATUS
_cdecl
ExchangeReply(
    IN PUCHAR RspData,
    IN ULONG BytesIndicated,
    char*           f,
    ...                         //  format specific parameters
    );

USHORT
NextSocket(
    IN USHORT OldValue
    );

VOID
KickQueue(
    struct _NONPAGED_SCB*   pNpScb
    );

NTSTATUS
ServerDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pNpScb
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
WatchDogDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pNpScb
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
SendDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pNpScb
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

#endif // _NWEXCHANGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\encrypt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    This module implements the routines for the NetWare
    redirector to mangle an objectid, challenge key and
    password such that a NetWare server will accept the
    password as valid.

    This program uses information published in Byte Magazine.

Author:

    Colin Watson    [ColinW]    15-Mar-1993

Revision History:

--*/

#include <procs.h>


UCHAR Table[] = {
    0x78, 0x08, 0x64, 0xe4, 0x5c, 0x17, 0xbf, 0xa8,
    0xf8, 0xcc, 0x94, 0x1e, 0x46, 0x24, 0x0a, 0xb9,
    0x2f, 0xb1, 0xd2, 0x19, 0x5e, 0x70, 0x02, 0x66,
    0x07, 0x38, 0x29, 0x3f, 0x7f, 0xcf, 0x64, 0xa0,
    0x23, 0xab, 0xd8, 0x3a, 0x17, 0xcf, 0x18, 0x9d,
    0x91, 0x94, 0xe4, 0xc5, 0x5c, 0x8b, 0x23, 0x9e,
    0x77, 0x69, 0xef, 0xc8, 0xd1, 0xa6, 0xed, 0x07,
    0x7a, 0x01, 0xf5, 0x4b, 0x7b, 0xec, 0x95, 0xd1,
    0xbd, 0x13, 0x5d, 0xe6, 0x30, 0xbb, 0xf3, 0x64,
    0x9d, 0xa3, 0x14, 0x94, 0x83, 0xbe, 0x50, 0x52,
    0xcb, 0xd5, 0xd5, 0xd2, 0xd9, 0xac, 0xa0, 0xb3,
    0x53, 0x69, 0x51, 0xee, 0x0e, 0x82, 0xd2, 0x20,
    0x4f, 0x85, 0x96, 0x86, 0xba, 0xbf, 0x07, 0x28,
    0xc7, 0x3a, 0x14, 0x25, 0xf7, 0xac, 0xe5, 0x93,
    0xe7, 0x12, 0xe1, 0xf4, 0xa6, 0xc6, 0xf4, 0x30,
    0xc0, 0x36, 0xf8, 0x7b, 0x2d, 0xc6, 0xaa, 0x8d } ;


UCHAR Keys[32] =
{0x48,0x93,0x46,0x67,0x98,0x3D,0xE6,0x8D,
 0xB7,0x10,0x7A,0x26,0x5A,0xB9,0xB1,0x35,
 0x6B,0x0F,0xD5,0x70,0xAE,0xFB,0xAD,0x11,
 0xF4,0x47,0xDC,0xA7,0xEC,0xCF,0x50,0xC0};

#define XorArray( DEST, SRC ) {                             \
    PULONG D = (PULONG)DEST;                                \
    PULONG S = (PULONG)SRC;                                 \
    int i;                                                  \
    for ( i = 0; i <= 7 ; i++ ) {                           \
        D[i] ^= S[i];                                       \
    }                                                       \
}

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    );

int
Scramble(
    int   iSeed,
    UCHAR   achBuffer[32]
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, RespondToChallenge )
#pragma alloc_text( PAGE, Shuffle )
#pragma alloc_text( PAGE, Scramble )
#endif


VOID
RespondToChallenge(
    IN PUCHAR achObjectId,
    IN POEM_STRING Password,
    IN PUCHAR pChallenge,
    OUT PUCHAR pResponse
    )

/*++

Routine Description:

    This routine takes the ObjectId and Challenge key from the server and
    encrypts the user supplied password to develop a credential for the
    server to verify.

Arguments:
    IN PUCHAR achObjectId - Supplies the 4 byte user's bindery object id
    IN POEM_STRING Password - Supplies the user's uppercased password
    IN PUCHAR pChallenge - Supplies the 8 byte challenge key
    OUT PUCHAR pResponse - Returns the 8 byte response

Return Value:

    none.

--*/

{
    int     index;
    UCHAR   achK[32];
    UCHAR   achBuf[32];

    PAGED_CODE();

    Shuffle(achObjectId, Password->Buffer, Password->Length, achBuf);
    Shuffle( &pChallenge[0], achBuf, 16, &achK[0] );
    Shuffle( &pChallenge[4], achBuf, 16, &achK[16] );

    for (index = 0; index < 16; index++)
        achK[index] ^= achK[31-index];

    for (index = 0; index < 8; index++)
        pResponse[index] = achK[index] ^ achK[15-index];
}


VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    )

/*++

Routine Description:

    This routine shuffles around the object ID with the password

Arguments:

    IN achObjectId - Supplies the 4 byte user's bindery object id

    IN szUpperPassword - Supplies the user's uppercased password on the
        first call to process the password. On the second and third calls
        this parameter contains the OutputBuffer from the first call

    IN iPasswordLen - length of uppercased password

    OUT achOutputBuffer - Returns the 8 byte sub-calculation

Return Value:

    none.

--*/

{
    int     iTempIndex;
    int     iOutputIndex;
    UCHAR   achTemp[32];

    PAGED_CODE();

    //
    //  Truncate all trailing zeros from the password.
    //

    while (iPasswordLen > 0 && szUpperPassword[iPasswordLen-1] == 0 ) {
        iPasswordLen--;
    }

    //
    //  Initialize the achTemp buffer. Initialization consists of taking
    //  the password and dividing it up into chunks of 32. Any bytes left
    //  over are the remainder and do not go into the initialization.
    //
    //  achTemp[0] = szUpperPassword[0] ^ szUpperPassword[32] ^ szUpper...
    //  achTemp[1] = szUpperPassword[1] ^ szUpperPassword[33] ^ szUpper...
    //  etc.
    //

    if ( iPasswordLen > 32) {

        //  At least one chunk of 32. Set the buffer to the first chunk.

        RtlCopyMemory( achTemp, szUpperPassword, 32 );

        szUpperPassword +=32;   //  Remove the first chunk
        iPasswordLen -=32;

        while ( iPasswordLen >= 32 ) {
            //
            //  Xor this chunk with the characters already loaded into
            //  achTemp.
            //

            XorArray( achTemp, szUpperPassword);

            szUpperPassword +=32;   //  Remove this chunk
            iPasswordLen -=32;
        }

    } else {

        //  No chunks of 32 so set the buffer to zero's

        RtlZeroMemory( achTemp, sizeof(achTemp));

    }

    //
    //  achTemp is now initialized. Load the remainder into achTemp.
    //  The remainder is repeated to fill achTemp.
    //
    //  The corresponding character from Keys is taken to seperate
    //  each repitition.
    //
    //  As an example, take the remainder "ABCDEFG". The remainder is expanded
    //  to "ABCDEFGwABCDEFGxABCDEFGyABCDEFGz" where w is Keys[7],
    //  x is Keys[15], y is Keys[23] and z is Keys[31].
    //
    //

    if (iPasswordLen > 0) {
        int iPasswordOffset = 0;
        for (iTempIndex = 0; iTempIndex < 32; iTempIndex++) {

            if (iPasswordLen == iPasswordOffset) {
                iPasswordOffset = 0;
                achTemp[iTempIndex] ^= Keys[iTempIndex];
            } else {
                achTemp[iTempIndex] ^= szUpperPassword[iPasswordOffset++];
            }
        }
    }

    //
    //  achTemp has been loaded with the users password packed into 32
    //  bytes. Now take the objectid that came from the server and use
    //  that to munge every byte in achTemp.
    //

    for (iTempIndex = 0; iTempIndex < 32; iTempIndex++)
        achTemp[iTempIndex] ^= achObjectId[ iTempIndex & 3];

    Scramble( Scramble( 0, achTemp ), achTemp );

    //
    //  Finally take pairs of bytes in achTemp and return the two
    //  nibbles obtained from Table. The pairs of bytes used
    //  are achTemp[n] and achTemp[n+16].
    //

    for (iOutputIndex = 0; iOutputIndex < 16; iOutputIndex++) {

        unsigned int offset = achTemp[iOutputIndex << 1],
                     shift  = (offset & 0x1) ? 0 : 4 ;

        achOutputBuffer[iOutputIndex] =
            (Table[offset >> 1] >> shift) & 0xF ;

        offset = achTemp[(iOutputIndex << 1)+1],
        shift = (offset & 0x1) ? 4 : 0 ;

        achOutputBuffer[iOutputIndex] |=
            (Table[offset >> 1] << shift) & 0xF0;
    }

    return;
}

int
Scramble(
    int   iSeed,
    UCHAR   achBuffer[32]
    )

/*++

Routine Description:

    This routine scrambles around the contents of the buffer. Each buffer
    position is updated to include the contents of at least two character
    positions plus an EncryptKey value. The buffer is processed left to right
    and so if a character position chooses to merge with a buffer position
    to its left then this buffer position will include bits derived from at
    least 3 bytes of the original buffer contents.

Arguments:

    IN iSeed
    IN OUT achBuffer[32]

Return Value:

    none.

--*/

{
    int iBufferIndex;

    PAGED_CODE();

    for (iBufferIndex = 0; iBufferIndex < 32; iBufferIndex++) {
        achBuffer[iBufferIndex] =
            (UCHAR)(
                ((UCHAR)(achBuffer[iBufferIndex] + iSeed)) ^
                ((UCHAR)(   achBuffer[(iBufferIndex+iSeed) & 31] -
                    Keys[iBufferIndex] )));

        iSeed += achBuffer[iBufferIndex];
    }
    return iSeed;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\except.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Except.c

Abstract:

    This module implements the exception handling for the NetWare
    redirector called by the dispatch driver.

Author:

    Colin Watson    [ColinW]    19-Dec-1992

Revision History:

--*/

#include "Procs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

#if 0  // Not pageable
NwExceptionFilter
NwProcessException
#endif

LONG
NwExceptionFilter (
    IN PIRP Irp,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It inserts the status
    into the IrpContext and either indicates that we should handle
    the exception or bug check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;
#ifdef NWDBG
    PVOID ExceptionAddress;
    ExceptionAddress = ExceptionPointer->ExceptionRecord->ExceptionAddress;
#endif

    ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    DebugTrace(0, DEBUG_TRACE_UNWIND, "NwExceptionFilter %X\n", ExceptionCode);
#ifdef NWDBG
    DebugTrace(0, DEBUG_TRACE_UNWIND, "                  %X\n", ExceptionAddress);
#endif

    //
    // If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code
    // from the exception record.
    //

    if (ExceptionCode == STATUS_IN_PAGE_ERROR) {
        if (ExceptionPointer->ExceptionRecord->NumberParameters >= 3) {
            ExceptionCode = (NTSTATUS) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
        }
    }

    if (FsRtlIsNtstatusExpected( ExceptionCode )) {

        DebugTrace(0, DEBUG_TRACE_UNWIND, "Exception expected\n", 0);
        return EXCEPTION_EXECUTE_HANDLER;

    } else {

        return EXCEPTION_CONTINUE_SEARCH;
    }
}

NTSTATUS
NwProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine process an exception.  It either completes the request
    with the saved exception status or it sends it off to IoRaiseHardError()

Arguments:

    IrpContext - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    DebugTrace(0, Dbg, "NwProcessException\n", 0);

    Irp = IrpContext->pOriginalIrp;
    Irp->IoStatus.Status = ExceptionCode;

    //
    //  If the error is a hard error, or verify required, then we will complete
    //  it if this is a recursive Irp, or with a top-level Irp, either send
    //  it to the Fsp for verification, or send it to IoRaiseHardError, who
    //  will deal with it.
    //

    if (ExceptionCode == STATUS_CANT_WAIT) {

        Status = NwPostToFsp( IrpContext, TRUE );

    } else {

        //
        //  We got an error, so zero out the information field before
        //  completing the request if this was an input operation.
        //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
        //

        if ( FlagOn(Irp->Flags, IRP_INPUT_OPERATION) ) {

            Irp->IoStatus.Information = 0;
        }

        Status = ExceptionCode;

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the netware redirector.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include <procs.h>
#include <align.h>

#include <stdarg.h>

ULONG
SequenceNumber = 0;

#ifdef ALLOC_PRAGMA
#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, Error )
#endif
#endif

#if 0   // Not pageable

// see ifndef QFE_BUILD above

#endif

VOID
_cdecl
Error(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:

    UniqueErrorCode - The event code

    NtStatusCode - The NT status of the failure

    ExtraInformationBuffer - Raw data for the event

    ExtraInformationLength - The length of the raw data

    NumberOfInsertionString - The number of insertion strings that follow

    InsertionString - 0 or more insertion strings.

Return Value:

    None.

--*/
{

    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    int TotalErrorLogEntryLength;
    ULONG SizeOfStringData = 0;
    va_list ParmPtr;                    // Pointer to stack parms.

    if (NumberOfInsertionStrings != 0) {
        USHORT i;

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1) {
            PWSTR String = va_arg(ParmPtr, PWSTR);
            SizeOfStringData += (wcslen(String) + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength =
         min( ExtraInformationLength + sizeof(IO_ERROR_LOG_MESSAGE) + 1 + SizeOfStringData,
              ERROR_LOG_MAXIMUM_SIZE );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        FileSystemDeviceObject,
        (UCHAR)TotalErrorLogEntryLength
        );

    if (ErrorLogEntry != NULL) {
        PCHAR DumpData;
        ULONG RemainingSpace = TotalErrorLogEntryLength - sizeof( IO_ERROR_LOG_MESSAGE );
        USHORT i;
        ULONG SizeOfRawData;

        if (RemainingSpace > SizeOfStringData) {
            SizeOfRawData = RemainingSpace - SizeOfStringData;
        } else {
            SizeOfStringData = RemainingSpace;

            SizeOfRawData = 0;
        }

        //
        // Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = UniqueErrorCode;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatusCode;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.LowPart = 0;
        ErrorLogEntry->DeviceOffset.HighPart = 0;
        ErrorLogEntry->SequenceNumber = (ULONG)SequenceNumber ++;
        ErrorLogEntry->StringOffset =
            (USHORT)ROUND_UP_COUNT(
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + SizeOfRawData,
                    ALIGN_WORD);

        DumpData = (PCHAR)ErrorLogEntry->DumpData;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if (( ARGUMENT_PRESENT( ExtraInformationBuffer )) &&
            ( SizeOfRawData != 0 )) {
            ULONG Length;

            Length = min(ExtraInformationLength, (USHORT)SizeOfRawData);
            RtlCopyMemory(
                DumpData,
                ExtraInformationBuffer,
                Length);
            ErrorLogEntry->DumpDataSize = (USHORT)Length;
        } else {
            ErrorLogEntry->DumpDataSize = 0;
        }

        ErrorLogEntry->NumberOfStrings = 0;

        if (NumberOfInsertionStrings != 0) {
            PWSTR StringOffset = (PWSTR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);
            PWSTR InsertionString;

            //
            // Set up ParmPtr to point to first of the caller's parameters.
            //

            va_start(ParmPtr, LAST_NAMED_ARGUMENT);

            for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1) {
                InsertionString = va_arg(ParmPtr, PWSTR);

                if (((wcslen(InsertionString) + 1) * sizeof(WCHAR)) <= SizeOfStringData ) {

                    wcscpy(StringOffset, InsertionString);

                    StringOffset += wcslen(InsertionString) + 1;

                    SizeOfStringData -= (wcslen(InsertionString) + 1) * sizeof(WCHAR);

                    ErrorLogEntry->NumberOfStrings += 1;

                }

            }

        }

        IoWriteErrorLogEntry(ErrorLogEntry);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\exchange.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    exchange.c

Abstract:

    This module implements the File Create routine for the NetWare
    redirector called by the dispatch driver.

Author:

    Hans Hurvig     [hanshu]       Aug-1992  Created
    Colin Watson    [ColinW]    19-Dec-1992

Revision History:

--*/

#include "procs.h"
#include "tdikrnl.h"
#include <STDARG.H>

#define Dbg                              (DEBUG_TRACE_EXCHANGE)

//
//  Exchange.c Global constants
//

//  broadcast to socket 0x0452

TA_IPX_ADDRESS SapBroadcastAddress =
    {
        1,
        sizeof(TA_IPX_ADDRESS), TDI_ADDRESS_TYPE_IPX,
        0, 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, SAP_SOCKET
    };

UCHAR SapPacketType = PACKET_TYPE_SAP;
UCHAR NcpPacketType = PACKET_TYPE_NCP;

extern BOOLEAN WorkerRunning;   //  From timer.c

ULONG DropCount = 0;

#ifdef NWDBG
int AlwaysAllocateIrp = 1;
#endif

NTSTATUS
CompletionSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
FspGetMessage(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
CompletionWatchDogSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

USHORT
NextSocket(
    IN USHORT OldValue
    );

NTSTATUS
FormatRequest(
    PIRP_CONTEXT    pIrpC,
    PEX             pEx,
    char*           f,
    va_list         a              //  format specific parameters
    );

VOID
ScheduleReconnectRetry(
    PIRP_CONTEXT pIrpContext
    );

NTSTATUS
CopyIndicatedData(
    PIRP_CONTEXT pIrpContext,
    PCHAR RspData,
    ULONG BytesIndicated,
    PULONG BytesTaken,
    ULONG ReceiveDatagramFlags
    );

NTSTATUS
AllocateReceiveIrp(
    PIRP_CONTEXT pIrpContext,
    PVOID ReceiveData,
    ULONG BytesAvailable,
    PULONG BytesAccepted,
    PNW_TDI_STRUCT pTdiStruct
    );

NTSTATUS
ReceiveIrpCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
FspProcessServerDown(
    PIRP_CONTEXT IrpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NextSocket )
#pragma alloc_text( PAGE, ExchangeWithWait )
#pragma alloc_text( PAGE, NewRouteRetry )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, FspGetMessage )
#pragma alloc_text( PAGE1, Exchange )
#pragma alloc_text( PAGE1, BuildRequestPacket )
#pragma alloc_text( PAGE1, ParseResponse )
#pragma alloc_text( PAGE1, ParseNcpResponse )
#pragma alloc_text( PAGE1, FormatRequest )
#pragma alloc_text( PAGE1, PrepareAndSendPacket )
#pragma alloc_text( PAGE1, PreparePacket )
#pragma alloc_text( PAGE1, SendPacket )
#pragma alloc_text( PAGE1, AppendToScbQueue )
#pragma alloc_text( PAGE1, KickQueue )
#pragma alloc_text( PAGE1, SendNow )
#pragma alloc_text( PAGE1, SetEvent )
#pragma alloc_text( PAGE1, CompletionSend )
#pragma alloc_text( PAGE1, CopyIndicatedData )
#pragma alloc_text( PAGE1, AllocateReceiveIrp )
#pragma alloc_text( PAGE1, ReceiveIrpCompletion )
#pragma alloc_text( PAGE1, VerifyResponse )
#pragma alloc_text( PAGE1, ScheduleReconnectRetry )
#pragma alloc_text( PAGE1, ReconnectRetry )
#pragma alloc_text( PAGE1, NewRouteBurstRetry )
#endif

#endif

#if 0  // Not pageable
ServerDatagramHandler
WatchDogDatagramHandler
SendDatagramHandler
CompletionWatchDogSend
MdlLength
FreeReceiveIrp
FspProcessServerDown

// see ifndef QFE_BUILD above

#endif

NTSTATUS
_cdecl
Exchange(
    PIRP_CONTEXT    pIrpContext,
    PEX             pEx,
    char*           f,
    ...                       //  format specific parameters
    )
/*++

Routine Description:

    This routine is a wrapper for _Exchange.  See the comment
    in _Exchange for routine and argument description.

--*/

{
    va_list Arguments;
    NTSTATUS Status;

    va_start( Arguments, f );

    Status = FormatRequest( pIrpContext, pEx, f, Arguments );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    //
    //  We won't be completing this IRP now, so mark it pending.
    //

    IoMarkIrpPending( pIrpContext->pOriginalIrp );

    //
    //  Start the packet on it's way to the wire.
    //

    Status = PrepareAndSendPacket( pIrpContext );

    return( Status );
}

NTSTATUS
_cdecl
BuildRequestPacket(
    PIRP_CONTEXT    pIrpContext,
    PEX             pEx,
    char*           f,
    ...                       //  format specific parameters
    )
/*++

Routine Description:

    This routine is a wrapper for FormatRequest.  See the comment
    in FormatRequest for routine and argument description.

--*/

{
    va_list Arguments;
    NTSTATUS Status;

    va_start( Arguments, f );

    Status = FormatRequest( pIrpContext, pEx, f, Arguments );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    return( Status );
}


NTSTATUS
_cdecl
ParseResponse(
    PIRP_CONTEXT IrpContext,
    PUCHAR  Response,
    ULONG ResponseLength,
    char*  FormatString,
    ...                       //  format specific parameters
    )
/*++

Routine Description:

    This routine parse an NCP response.

Arguments:

    pIrpC - Supplies the irp context for the exchange request.  This may
            be NULL for generic packet types.

    f... - supplies the information needed to create the request to the
            server. The first byte indicates the packet type and the
            following bytes contain field types.

         Packet types:

            'B'      Burst primary response    ( byte * )
            'N'      NCP response              ( void )
            'S'      Burst secondary response  ( byte * )
            'G'      Generic packet            ( )

         Field types, request/response:

            'b'      byte              ( byte* )
            'w'      hi-lo word        ( word* )
            'x'      ordered word      ( word* )
            'd'      hi-lo dword       ( dword* )
            'e'      ordered dword     ( dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'p'      pstring to Unicode ( UNICODE_STRING * )
            'c'      cstring           ( char* )
            'r'      raw bytes         ( byte*, word )
            'R'      ASCIIZ to Unicode ( UNICODE_STRING *, word )

            Added 3/29/95 by CoryWest:

            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            'S'      unicode string copy as NDS_STRING (UNICODE_STRING *)
            'T'      terminal unicode string copy as NDS_STRING (UNICODE_STRING *)

            't'      terminal unicode string with the nds null copied
                     as NDS_STRING (UNICODE_STRING *) (for GetUseName)

            Not in use:

            's'      cstring copy as NDS_STRING (char* / char *, word)
            'V'      sized NDS value   ( byte **, dword *)
            'l'      what's this?

Return Value:

    STATUS - The converted error code from the NCP response.

--*/

{

    PEPresponse *pResponseParameters;
    PCHAR FormatByte;
    va_list Arguments;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS NcpStatus;
    ULONG Length;

    va_start( Arguments, FormatString );

    //
    // Make sure that we have an IrpContext unless we are doing
    // a scan of a generic packet.
    //

#ifdef NWDBG
    if ( *FormatString != 'G' ) {
        ASSERT( IrpContext != NULL );
    }
#endif

    switch ( *FormatString ) {

    //
    //  NCP response.
    //

    case 'N':

        Length = 8;   // The data begins 8 bytes into the packet

        pResponseParameters = (PEPresponse *)( ((PEPrequest *)Response) + 1);

        //
        // If there's a message pending for us on the server and we have
        // popups disabled, we won't pick it up, but we should continue
        // processing NCPs correctly!
        //

        if ( ( pResponseParameters->status == 0 ) ||
             ( pResponseParameters->status == 0x40 ) ) {
            Status = NwErrorToNtStatus( pResponseParameters->error );
        } else {
            Status = NwConnectionStatusToNtStatus( pResponseParameters->status );
            if ( Status == STATUS_REMOTE_DISCONNECT ) {
                Stats.ServerDisconnects++;
                IrpContext->pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
            }
        }

        break;

    //
    //  Burst response, first packet
    //

    case 'B':
    {
        PNCP_BURST_HEADER BurstResponse = (PNCP_BURST_HEADER)Response;

        byte* b = va_arg ( Arguments, byte* );
        ULONG  Result;
        ULONG  Offset = BurstResponse->BurstOffset;
        *b = BurstResponse->Flags;

        Length = 28;  // The data begins 28 bytes into the packet

        if ( Offset == 0 ) {

            //
            //  This is the first packet in the burst response.   Look
            //  at the result code.
            //
            //  Note that the result DWORD is in lo-hi order.
            //

            Result = *(ULONG UNALIGNED *)(Response + 36);

            switch ( Result ) {

            case 0:
            case 3:   //  No data
                break;

            case 1:
                Status = STATUS_DISK_FULL;
                break;

            case 2:   //  I/O error
                Status = STATUS_UNEXPECTED_IO_ERROR;
                break;

            default:
                Status = NwErrorToNtStatus( (UCHAR)Result );
                break;

            }
        }

        break;
    }

#if 0
    //
    //  Burst response, secondary packet
    //

    case 'S':
    {
        byte* b = va_arg ( Arguments, byte* );
        *b = Response[2];

        Length = 28;  // The data begins 28 bytes into the packet
        break;
    }
#endif

    case 'G':
        Length = 0;   // The data begins at the start of the packet
        break;

    default:
        ASSERT( FALSE );
        Status = STATUS_UNSUCCESSFUL;
        break;
    }

    //
    //  If this packet contains an error, simply return the error.
    //

    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    NcpStatus = Status;

    FormatByte = FormatString + 1;
    while ( *FormatByte ) {

        switch ( *FormatByte ) {

        case '-':
            Length += 1;
            break;

        case '=':
            Length += 2;
            break;

        case '_':
        {
            word l = va_arg ( Arguments, word );
            Length += l;
            break;
        }

        case 'b':
        {
            byte* b = va_arg ( Arguments, byte* );
            if (Length + 1 > ResponseLength)
            {
                Length++;
                break;
            }
            *b = Response[Length++];
            break;
        }

        case 'w':
        {
            byte* b = va_arg ( Arguments, byte* );
            if (Length + 2 > ResponseLength)
            {
                Length += 2;
                break;
            }
            b[1] = Response[Length++];
            b[0] = Response[Length++];
            break;
        }

        case 'x':
        {
            word* w = va_arg ( Arguments, word* );
            if (Length + 2 > ResponseLength)
            {
                Length += 2;
                break;
            }
            *w = *(word UNALIGNED *)&Response[Length];
            Length += 2;
            break;
        }

        case 'd':
        {
            byte* b = va_arg ( Arguments, byte* );
            if (Length + 4 > ResponseLength)
            {
                Length += 4;
                break;
            }
            b[3] = Response[Length++];
            b[2] = Response[Length++];
            b[1] = Response[Length++];
            b[0] = Response[Length++];
            break;
        }

        case 'e':
        {
            dword UNALIGNED * d = va_arg ( Arguments, dword* );
            if (Length + 4 > ResponseLength)
            {
                Length += 4;
                break;
            }
            *d = *(dword UNALIGNED *)&Response[Length];
            Length += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            word  l = 0;
            while ( l + Length < ResponseLength )
            {
                if ( Response[Length + l] == 0 )
                    break;
                l++;
            }
            if (Length + l+1 > ResponseLength) 
            {
                // reached end of buffer without finding terminiating NULL
                Length += l+1;
                break;
            }
            memcpy ( c, &Response[Length], l+1 );
            Length += l+1;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            byte  l = 0;
            if (Length + 1 > ResponseLength)
            {
                Length++;
                break;
            }
            l = Response[Length++];
            if (Length + l > ResponseLength)
            {
                break;
            }
            memcpy ( c, &Response[Length], l );
            c[l+1] = 0;
            // Assumed to be final parameter, so Length not adjusted
            break;
        }

        case 'P':
        {
            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            OEM_STRING OemString;

            if (Length + 1 > ResponseLength)
            {
                Length++;
                break;
            }
            OemString.Length = Response[Length++];
            if (Length + OemString.Length > ResponseLength)
            {
                break;
            }
            OemString.Buffer = &Response[Length];

            //
            //  Note the the Rtl function would set pUString->Buffer = NULL,
            //  if OemString.Length is 0.
            //

            if ( OemString.Length != 0 ) {

                Status = RtlOemStringToCountedUnicodeString( pUString, &OemString, FALSE );

                if (!NT_SUCCESS( Status )) {
                    pUString->Length = 0;
                    NcpStatus = Status;
                }

            } else {
                pUString->Length = 0;
            }

            // Assumed to be final parameter, so Length not adjusted
            break;
        }

        case 'r':
        {
            byte* b = va_arg ( Arguments, byte* );
            word  l = va_arg ( Arguments, word );
            TdiCopyLookaheadData( b, &Response[Length], l, 0);
            Length += l;
            break;
        }

        case 'R':
        {
            //
            //  Interpret the buffer as an ASCIIZ string.  Convert
            //  it to unicode in the preallocated buffer.
            //

            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            OEM_STRING OemString;
            USHORT len = va_arg ( Arguments, USHORT );

            OemString.Buffer = &Response[Length];
            OemString.Length = 0;
            // make sure not to go past end of Response 
            while ( OemString.Length + Length <= ResponseLength )
            {
                if ( Response[Length + OemString.Length] == 0 )
                    break;
                OemString.Length++;
            }
            OemString.MaximumLength = OemString.Length;

            if (Length + OemString.Length > ResponseLength)
            {
                Length += len;
                break;
            }

            //
            //  Note the the Rtl function would set pUString->Buffer = NULL,
            //  if OemString.Length is 0.
            //

            if ( OemString.Length != 0) {
                Status = RtlOemStringToCountedUnicodeString( pUString, &OemString, FALSE );

                if (!NT_SUCCESS( Status )) {

                    ASSERT( Status == STATUS_BUFFER_OVERFLOW );
                    pUString->Length = 0;
                    NcpStatus = Status;
                }

            } else {
                pUString->Length = 0;
            }

            Length += len;
            break;
        }

        case 'W':
        {

            WORD *w = va_arg ( Arguments, WORD* );
            if (Length + 2 > ResponseLength)
            {
                Length += 2;
                break;
            }
            *w = (* (WORD *)&Response[Length]);
            Length += 2;
            break;

        }

        case 'D':
        {

            DWORD *d = va_arg ( Arguments, DWORD* );
            if (Length + 4 > ResponseLength)
            {
                Length += 4;
                break;
            }
            *d = (* (DWORD *)&Response[Length]);
            Length += 4;
            break;

        }

        case 'S':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                if (Length + 4 > ResponseLength)
                {
                    Length += 4;
                    break;
                }
                strl = (USHORT)(* (DWORD *)&Response[Length]);

                //
                // Don't count the null terminator that is part of
                // Novell's counted unicode string.
                //

                pU->Length = strl - sizeof( WCHAR );
                Length += 4;
                if (Length + pU->Length <= ResponseLength)
                    RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );
                Length += ROUNDUP4(strl);

            } else {

                //
                // Skip over the string since we don't want it.
                //

                if (Length + 4 > ResponseLength)
                {
                    Length += 4;
                    break;
                }
                Length += ROUNDUP4((* (DWORD *)&Response[Length] ));
                Length += 4;
            }


            break;

        }

        case 's':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                if (Length + 4 > ResponseLength)
                {
                    Length += 4;
                    break;
                }
                strl = (USHORT)(* (DWORD *)&Response[Length]);
                pU->Length = strl;
                Length += 4;
                if (Length + pU->Length <= ResponseLength)
                    RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );
                Length += ROUNDUP4(strl);

            } else {

                //
                // Skip over the string since we don't want it.
                //

                if (Length + 4 > ResponseLength)
                {
                    Length += 4;
                    break;
                }
                Length += ROUNDUP4((* (DWORD *)&Response[Length] ));
                Length += 4;
            }


            break;

        }

        case 'T':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                if (Length + 4 > ResponseLength)
                {
                    Length += 4;
                    break;
                }
                strl = (USHORT)(* (DWORD *)&Response[Length] );
                strl -= sizeof( WCHAR );  // Don't count the NULL from NDS.

                if ( strl <= pU->MaximumLength ) {

                   pU->Length = strl;
                   Length += 4;
                   if (Length + pU->Length <= ResponseLength)
                       RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );

                   //
                   // No need to advance the pointers since this is
                   // specifically a termination case!
                   //

                } else {

                    pU->Length = 0;
                }

            }

            break;

        }

        case 't':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                if (Length + 4 > ResponseLength)
                {
                    Length += 4;
                    break;
                }
                strl = (USHORT)(* (DWORD *)&Response[Length] );

                if ( strl <= pU->MaximumLength ) {

                   pU->Length = strl;
                   Length += 4;
                   if (Length + pU->Length <= ResponseLength)
                       RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );

                   //
                   // No need to advance the pointers since this is
                   // specifically a termination case!
                   //

                } else {

                   pU->Length = 0;

                }

            }

            break;

        }

        /*
        case 's':
        {

            char *c = va_arg( Arguments, char * );
            WORD l = va_arg( Arguments, WORD );
            ULONG len = (* (DWORD *)&Response[Length]);
            Length += 4;

            // How to fix this?
            // l = WideCharToMultiByte(CP_ACP,0,(WCHAR *)&Response[Length],Length/2,c,l,0,0);
            // if (!l) {
            //     #ifdef NWDBG
            //     DbgPrint( "ParseResponse case s couldnt translate from WCHAR.\n" );
            //     #endif
            //     goto ErrorExit;
            // }

            len = ROUNDUP4(len);
            Length += len;
            break;

        }
        case 'V':
        {

            BYTE **b = va_arg( Arguments, BYTE **);
            DWORD *pLen = va_arg ( Arguments, DWORD *);
            DWORD len = (* (DWORD *)&Response[Length]);
            Length += 4;
            if (b) {
                *b = (BYTE *)&Response[Length];
            }
            if (pLen) {
                *pLen = len;
            }
            Length += ROUNDUP4(len);
            break;

        }

        case 'l':
        {

            BYTE* b = va_arg ( Arguments, BYTE* );
            BYTE* w = va_arg ( Arguments, BYTE* );
            WORD  i;

            b[1] = Response[Length++];
            b[0] = Response[Length++];

            for ( i = 0; i < ((WORD) *b); i++, w += sizeof(WORD) )
            {
                w[1] = Response[Length++];
                w[0] = Response[Length++];
            }

            break;
        }
        */

#ifdef NWDBG
        default:
            DbgPrintf ( "*****exchange: invalid response field, %x\n", *FormatByte );
            DbgBreakPoint();
#endif
        }

        if ( Length > ResponseLength ) {
#ifdef NWDBG
            DbgPrintf ( "*****exchange: not enough response data, %d\n", Length );

            if ( IrpContext ) {

                Error( EVENT_NWRDR_INVALID_REPLY,
                       STATUS_UNEXPECTED_NETWORK_ERROR,
                       NULL,
                       0,
                       1,
                       IrpContext->pNpScb->ServerName.Buffer );

            }
#endif
            return( STATUS_UNEXPECTED_NETWORK_ERROR );
        }

        FormatByte++;
    }

    va_end( Arguments );

    return( NcpStatus );
}

NTSTATUS
ParseNcpResponse(
    PIRP_CONTEXT IrpContext,
    PNCP_RESPONSE Response
    )
{
    NTSTATUS Status;

    if ( Response->Status == 0 ) {
        Status = NwErrorToNtStatus( Response->Error );
    } else {
        Status = NwConnectionStatusToNtStatus( Response->Status );
        if ( Status == STATUS_REMOTE_DISCONNECT ) {
            Stats.ServerDisconnects++;
            IrpContext->pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
        }
    }

    return( Status );
}

NTSTATUS
FormatRequest(
    PIRP_CONTEXT    pIrpC,
    PEX             pEx,
    char*           f,
    va_list         a              //  format specific parameters
    )
/*++

Routine Description:

    Send the packet described by f and the additional parameters. When a
    valid response has been received call pEx with the resonse.

    An exchange is a generic way of assembling a request packet of a
    given type, containing a set of fields, sending the packet, receiving
    a response packet, and disassembling the fields of the response packet.

    The packet type and each field is specified by individual
    characters in a format string.

    The exchange procedure takes such a format string plus additional
    parameters as necessary for each character in the string as specified
    below.

Arguments:                                                                     '']

    pIrpC - supplies the irp context for the exchange request.

    pEx - supplies the routine to process the data.

    f... - supplies the information needed to create the request to the
            server. The first byte indicates the packet type and the
            following bytes contain field types.

         Packet types:

            'A'      SAP broadcast     ( void )
            'B'      NCP burst         ( dword, dword, byte )
            'C'      NCP connect       ( void )
            'F'      NCP function      ( byte )
            'S'      NCP subfunction   ( byte, byte )
            'N'      NCP subfunction w/o size ( byte, byte )
            'D'      NCP disconnect    ( void )
            'E'      Echo data          ( void )

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            'W'      lo-hi word        ( word   /  word* )
            'D'      lo-hi dword       ( dword  /  dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )
            'J'      variant of U      ( UNICODE_STRING * )
            'c'      cstring           ( char* )
            'v'      cstring           ( UNICODE_STRING* )
            'r'      raw bytes         ( byte*, word )
            'w'      fixed length unicode ( UNICODE_STRING*, word )
            'C'      Component format name, with count ( UNICODE_STRING * )
            'N'      Component format name, no count ( UNICODE_STRING * )
            'f'      separate fragment ( PMDL )

         An 'f' field must be last, and in a response it cannot be
         preceeded by 'p' or 'c' fields.


Return Value:

    Normally returns STATUS_SUCCESS.

--*/
{
    NTSTATUS        status;
    char*           z;
    word            data_size;
    PNONPAGED_SCB   pNpScb = pIrpC->pNpScb;
    dword           dwData;

    ASSERT( pIrpC->NodeTypeCode == NW_NTC_IRP_CONTEXT );
    ASSERT( pIrpC->pNpScb != NULL );

    status= STATUS_LINK_FAILED;

    pIrpC->pEx = pEx;   //  Routine to process reply
    pIrpC->Destination = pNpScb->RemoteAddress;
    ClearFlag( pIrpC->Flags, IRP_FLAG_SEQUENCE_NO_REQUIRED );

    switch ( *f ) {

    case 'A':
        //  Send to local network (0), a broadcast (-1), socket 0x452
        pIrpC->Destination = SapBroadcastAddress;
        pIrpC->PacketType = SAP_BROADCAST;

        data_size = 0;
        pNpScb->RetryCount = 3;
        pNpScb->MaxTimeOut = 2 * pNpScb->TickCount + 10;
        pNpScb->TimeOut = pNpScb->MaxTimeOut;
        SetFlag( pIrpC->Flags, IRP_FLAG_RETRY_SEND );
        break;

    case 'E':
        pIrpC->Destination = pNpScb->EchoAddress;
        pIrpC->PacketType = NCP_ECHO;

        //
        //  For echo packets use a short timeout and a small retry count.
        //  Set the retry send bit, so that SendNow doesn't reset the
        //  RetryCount to a bigger number.  If we start getting packets
        //  after we've timed out, we'll increase the wait time.
        //

        pNpScb->RetryCount = 0;
        pNpScb->MaxTimeOut = 2 * pNpScb->TickCount + 7 + pNpScb->LipTickAdjustment;
        pNpScb->TimeOut = pNpScb->MaxTimeOut;
        SetFlag( pIrpC->Flags, IRP_FLAG_RETRY_SEND );
        SetFlag( pIrpC->Flags, IRP_FLAG_REROUTE_ATTEMPTED );

        data_size = 0;
        break;

    case 'C':
        pIrpC->PacketType = NCP_CONNECT;
        *(PUSHORT)&pIrpC->req[0] = PEP_COMMAND_CONNECT;
        pIrpC->req[2] = 0x00;
        pIrpC->req[3] = 0xFF;
        pIrpC->req[4] = 0x00;
        pIrpC->req[5] = 0xFF;
        data_size = 6;

        pNpScb->MaxTimeOut = 16 * pNpScb->TickCount + 10;
        pNpScb->TimeOut = 4 * pNpScb->TickCount + 10;
        pNpScb->SequenceNo = 0;
        break;

    case 'F':
        pIrpC->PacketType = NCP_FUNCTION;
        goto FallThrough;

    case 'S':
    case 'N':
        pIrpC->PacketType = NCP_SUBFUNCTION;
        goto FallThrough;

    case 'L':
        pIrpC->PacketType = NCP_SUBFUNCTION;
        goto FallThrough;

    case 'D':
        pIrpC->PacketType = NCP_DISCONNECT;
    FallThrough:
        if ( *f == 'D' ) {
            *(PUSHORT)&pIrpC->req[0] = PEP_COMMAND_DISCONNECT;
        } else {
            *(PUSHORT)&pIrpC->req[0] = PEP_COMMAND_REQUEST;
        }

        pNpScb->RetryCount = DefaultRetryCount ;
        pNpScb->MaxTimeOut = 2 * pNpScb->TickCount + 10;
        pNpScb->TimeOut = pNpScb->SendTimeout;

        //
        //  Mark this packet as SequenceNumberRequired.  We need to guarantee
        //  the packets are sent in sequence number order, so we will
        //  fill in the sequence number when we are ready to send the
        //  packet.
        //

        SetFlag( pIrpC->Flags, IRP_FLAG_SEQUENCE_NO_REQUIRED );
        pIrpC->req[3] = pNpScb->ConnectionNo;
        pIrpC->req[5] = pNpScb->ConnectionNoHigh;

        if ( pIrpC->Icb != NULL && pIrpC->Icb->Pid != INVALID_PID ) {
            pIrpC->req[4] = (UCHAR)pIrpC->Icb->Pid;
        } else {
            pIrpC->req[4] = 0xFF;
        }

        data_size = 6;

        if ( *f == 'L' ) {
            pIrpC->req[data_size++] = NCP_LFN_FUNCTION;
        }

        if ( *f != 'D' ) {
            pIrpC->req[data_size++] = va_arg( a, byte );
        }

        if ( *f == 'S' ) {
            data_size += 2;
            pIrpC->req[data_size++] = va_arg( a, byte );
        }

        if ( *f == 'N' ) {
            pIrpC->req[data_size++] = va_arg( a, byte );
        }

        break;

    case 'B':
        pIrpC->PacketType = NCP_BURST;
        *(PUSHORT)&pIrpC->req[0] = PEP_COMMAND_BURST;

        pNpScb->TimeOut = pNpScb->MaxTimeOut;

        //
        //  tommye - MS bug 2743 changed the RetryCount from 20 to be based off the 
        //  default retry count, nudged up a little. 
        //

        if ( !BooleanFlagOn( pIrpC->Flags, IRP_FLAG_RETRY_SEND ) ) {
            pNpScb->RetryCount = DefaultRetryCount * 2;
        }

        pIrpC->req[3] = 0x2;    // Stream Type = Big Send Burst

        *(PULONG)&pIrpC->req[4] = pNpScb->SourceConnectionId;
        *(PULONG)&pIrpC->req[8] = pNpScb->DestinationConnectionId;


        LongByteSwap( (*(PULONG)&pIrpC->req[16]) , pNpScb->CurrentBurstDelay  ); // Send delay time
        dwData = va_arg( a, dword );            // Size of data
        LongByteSwap( pIrpC->req[24], dwData );
        dwData = va_arg( a, dword );            // Offset of data
        LongByteSwap( pIrpC->req[28], dwData );
        pIrpC->req[2] = va_arg( a, byte );      // Burst flags

        data_size = 34;

        break;

    default:
        DbgPrintf ( "*****exchange: invalid packet type, %x\n", *f );
        DbgBreakPoint();
        va_end( a );
        return status;
    }

    z = f;
    while ( *++z && *z != 'f' )
    {
        switch ( *z )
        {
        case '=':
            pIrpC->req[data_size++] = 0;
        case '-':
            pIrpC->req[data_size++] = 0;
            break;

        case '_':
        {
            word l = va_arg ( a, word );
            ASSERT( data_size + l <= MAX_SEND_DATA );

            while ( l-- )
                pIrpC->req[data_size++] = 0;
            break;
        }

        case 's':
        {
            word l = va_arg ( a, word );
            ASSERT ( data_size + l <= MAX_SEND_DATA );
            data_size += l;
            break;
        }

        case 'i':
            pIrpC->req[4] = va_arg ( a, byte );
            break;

        case 'b':
            pIrpC->req[data_size++] = va_arg ( a, byte );
            break;

        case 'w':
        {
            word w = va_arg ( a, word );
            pIrpC->req[data_size++] = (byte) (w >> 8);
            pIrpC->req[data_size++] = (byte) (w >> 0);
            break;
        }


        case 'd':
        {
            dword d = va_arg ( a, dword );
            pIrpC->req[data_size++] = (byte) (d >> 24);
            pIrpC->req[data_size++] = (byte) (d >> 16);
            pIrpC->req[data_size++] = (byte) (d >>  8);
            pIrpC->req[data_size++] = (byte) (d >>  0);
            break;
        }

        case 'W':
        {
            word w = va_arg ( a, word );
            *(word UNALIGNED *)&pIrpC->req[data_size] = w;
            data_size += 2;
            break;
        }


        case 'D':
        {
            dword d = va_arg ( a, dword );
            *(dword UNALIGNED *)&pIrpC->req[data_size] = d;
            data_size += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( a, char* );
            word  l = (word)strlen( c );
            ASSERT (data_size + l <= MAX_SEND_DATA );

            RtlCopyMemory( &pIrpC->req[data_size], c, l+1 );
            data_size += l + 1;
            break;
        }

        case 'v':
        {
            PUNICODE_STRING pUString = va_arg ( a, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT (( data_size + Length <= MAX_SEND_DATA) && ( (Length & 0xffffff00) == 0) );

            OemString.Buffer = &pIrpC->req[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;
            status = RtlUnicodeStringToCountedOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));
            data_size += (USHORT)Length + 1;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( a, char* );
            byte  l = (byte)strlen( c );

            if ((data_size+l>MAX_SEND_DATA) ||
                ( (l & 0xffffff00) != 0) ) {

                ASSERT("***exchange: Packet too long!2!\n" && FALSE );
                return STATUS_OBJECT_PATH_SYNTAX_BAD;
            }

            pIrpC->req[data_size++] = l;
            RtlCopyMemory( &pIrpC->req[data_size], c, l );
            data_size += l;
            break;
        }

        case 'J':
        case 'U':
        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( a, PUNICODE_STRING );
            OEM_STRING OemString;
            PUCHAR  pOemString;
            ULONG Length;
            ULONG   i;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if (( data_size + Length > MAX_SEND_DATA ) ||
                ( (Length & 0xffffff00) != 0) ) {
                ASSERT("***exchange:Packet too long or name >255 chars!4!\n" && FALSE);
                return STATUS_OBJECT_PATH_SYNTAX_BAD;
            }

            pIrpC->req[data_size++] = (UCHAR)Length;
            OemString.Buffer = &pIrpC->req[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            if ( *z == 'u' ) {
                status = RtlUnicodeStringToCountedOemString(
                             &OemString,
                             pUString,
                             FALSE );
            } else {
                status = RtlUpcaseUnicodeStringToCountedOemString(
                             &OemString,
                             pUString,
                             FALSE );
            }

            if ( !NT_SUCCESS( status ) ) {
                return status;
            }

            data_size += (USHORT)Length;

            if (( Japan ) &&
                ( *z == 'J' )) {

                //
                // Netware Japanese version The following single byte character is replaced with another one
                // if the string is for File Name only when sending from Client to Server.
                //
                // U+0xFF7F SJIS+0xBF     -> 0x10
                // U+0xFF6E SJIS+0xAE     -> 0x11
                // U+0xFF64 SJIS+0xAA     -> 0x12
                //

                for ( i = 0 , pOemString = OemString.Buffer ; i < Length ; i++ , pOemString++ ) {

                    //
                    // In fact Novell server seems to convert all 0xBF, 0xAA, 0xAE
                    // and 0x5C even if they are DBCS lead or trail byte.
                    // We can't single out DBCS case in the conversion.
                    //

                    if( FsRtlIsLeadDbcsCharacter( *pOemString ) ) {

                        if(*pOemString == 0xBF ) {

                            *pOemString = 0x10;

                        }else if(*pOemString == 0xAE ) {

                            *pOemString = 0x11;

                        }else if(*pOemString == 0xAA ) {

                            *pOemString = 0x12;

                        }

                        // Trail byte

                        i++; pOemString++;

                        if(*pOemString == 0x5C ) {

                            //
                            // The trailbyte is 0x5C, replace it with 0x13
                            //


                            *pOemString = 0x13;

                        }
                        //
                        // Continue to check other conversions for trailbyte.
                        //

                    }

                    if ( *pOemString == 0xBF ) {

                        *pOemString = 0x10;

                    } else if ( *pOemString == 0xAA ) {

                            *pOemString = 0x12;

                    } else if ( *pOemString == 0xAE ) {

                        *pOemString = 0x11;
                    }
                }
            }

            break;
        }

        case 'r':
        {
            byte* b = va_arg ( a, byte* );
            word  l = va_arg ( a, word );
            if (data_size+l>MAX_SEND_DATA) {
                ASSERT("***exchange: Packet too long!6!\n"&& FALSE);
                return STATUS_UNSUCCESSFUL;
            }
            RtlCopyMemory( &pIrpC->req[data_size], b, l );
            data_size += l;
            break;
        }

        case 'x':
        {
            PUNICODE_STRING pUString = va_arg ( a, PUNICODE_STRING );
            ULONG RequiredLength = va_arg( a, word );
            ULONG Length;
            OEM_STRING OemString;

            //
            //  Convert this string to an OEM string.
            //

            status = RtlUnicodeStringToCountedOemString( &OemString, pUString, TRUE );
            ASSERT( NT_SUCCESS( status ));
            if (!NT_SUCCESS(status)) {
                return status;
            }

            if ( data_size + RequiredLength > MAX_SEND_DATA ) {
                ASSERT("***exchange: Packet too long!4!\n" && FALSE);
                return STATUS_UNSUCCESSFUL;
            }

            //
            //  Copy the oem string to the buffer, padded with 0's if
            //  necessary.
            //

            Length = MIN( OemString.Length, RequiredLength );
            RtlMoveMemory( &pIrpC->req[data_size], OemString.Buffer, Length );

            if ( RequiredLength > Length ) {
                RtlFillMemory(
                    &pIrpC->req[data_size+Length],
                    RequiredLength - Length,
                    0 );
            }

            RtlFreeAnsiString(&OemString);

            data_size += (USHORT)RequiredLength;
            break;
        }

        case 'C':
        case 'N':
        {
            PUNICODE_STRING pUString = va_arg ( a, PUNICODE_STRING );
            OEM_STRING OemString;
            PWCH thisChar, lastChar, firstChar;
            PCHAR componentCountPtr, pchar;
            CHAR componentCount;
            UNICODE_STRING UnicodeString;
            int i;

            //
            //  Copy the oem string to the buffer, in component format.
            //

            thisChar = pUString->Buffer;
            lastChar = &pUString->Buffer[ pUString->Length / sizeof(WCHAR) ];

            //
            //  Skip leading path separators
            //

            while ( (thisChar < lastChar) &&
                    (*thisChar == OBJ_NAME_PATH_SEPARATOR)) {
                thisChar++;
            }

            componentCount = 0;
            if ( *z == 'C' ) {
                componentCountPtr = &pIrpC->req[data_size++];
            }


            while ( thisChar < lastChar  ) {

                if ( data_size >= MAX_SEND_DATA - 1 ) {
                    ASSERT( ("***exchange: Packet too long or name > 255 chars!5!\n" && FALSE) );
                    return STATUS_OBJECT_PATH_SYNTAX_BAD;
                }

                firstChar = thisChar;

                while ( thisChar < lastChar &&
                        *thisChar != OBJ_NAME_PATH_SEPARATOR ) {

                    thisChar++;

                }

                ++componentCount;

                UnicodeString.Buffer = firstChar;
                UnicodeString.Length = (USHORT) (( thisChar - firstChar ) * sizeof(WCHAR));

                OemString.Buffer = &pIrpC->req[data_size + 1];
                OemString.MaximumLength = MAX_SEND_DATA - data_size - 1;

                status = RtlUnicodeStringToCountedOemString( &OemString, &UnicodeString, FALSE );

                pIrpC->req[data_size] = (UCHAR)OemString.Length;
                data_size += OemString.Length + 1;

                if ( !NT_SUCCESS( status ) || data_size > MAX_SEND_DATA ) {
                 // ASSERT("***exchange: Packet too long or name > 255 chars!5!\n" && FALSE );
                    return STATUS_OBJECT_PATH_SYNTAX_BAD;
                }

                //
                //  Search the result OEM string for the character 0xFF.
                //  If it's there, fail this request.  The server doesn't
                //  deal with 0xFF very well.
                //

                for ( pchar = OemString.Buffer, i = 0;
                      i < OemString.Length;
                      pchar++, i++ ) {

                            //
                            // We need to check for dbcs, because 0xff is a
                            // legal trail byte for EUDC characters.
                            //
                    if ( FsRtlIsLeadDbcsCharacter( (UCHAR)*pchar ) ) {

                        //
                        // Skip dbcs character.
                        //

                        pchar++; i++;
                        continue;
                    }

                    if (( (UCHAR)*pchar == LFN_META_CHARACTER ) ||
                         !FsRtlIsAnsiCharacterLegalHpfs(*pchar, FALSE) ) {

                        return STATUS_OBJECT_PATH_SYNTAX_BAD;
                    }

                }

                thisChar++;  // Skip the path separator

            }

            if ( *z == 'C' ) {
                *componentCountPtr = componentCount;
            }

            break;
        }

        default:
#ifdef NWDBG
            DbgPrintf ( "*****exchange: invalid request field, %x\n", *z );
            DbgBreakPoint();
#endif
            ;
        }

        if ( data_size > MAX_SEND_DATA )
        {
            DbgPrintf( "*****exchange: CORRUPT, too much request data\n" );
            DbgBreakPoint();
            va_end( a );
            return STATUS_UNSUCCESSFUL;
        }
    }

    pIrpC->TxMdl->ByteCount = data_size;

    if ( *z == 'f' )
    {
        PMDL mdl;

        //
        //  Fragment of data following Ipx header. Next parameter is
        //  the address of the mdl describing the fragment.
        //
        ++z;
        mdl = (PMDL) va_arg ( a, byte* );
        pIrpC->TxMdl->Next = mdl;

        data_size += (USHORT)MdlLength( mdl );
    }

    if ( *f == 'S' ) {

        pIrpC->req[7] = (data_size-9) >> 8;
        pIrpC->req[8] = (data_size-9);

    } else if ( *f == 'B' ) {

        //
        //  For burst packets set the number of bytes in this packet to
        //  a real number for burst requests, and to 0 for a missing packet
        //  request.
        //

        if ( *(PUSHORT)&pIrpC->req[34] == 0 ) {
            USHORT RealDataSize = data_size - 36;
            ShortByteSwap( pIrpC->req[32], RealDataSize );
        } else {
            *(PUSHORT)&pIrpC->req[32] = 0;
        }
    }

    va_end( a );
    return( STATUS_SUCCESS );
}

NTSTATUS
PrepareAndSendPacket(
    PIRP_CONTEXT    pIrpContext
    )
{
    PreparePacket( pIrpContext, pIrpContext->pOriginalIrp, pIrpContext->TxMdl );

    return SendPacket( pIrpContext, pIrpContext->pNpScb );
}

VOID
PreparePacket(
    PIRP_CONTEXT pIrpContext,
    PIRP pIrp,
    PMDL pMdl
    )
/*++

Routine Description:

    This routine builds the IRP for sending a packet.

Arguments:

    IrpContext - A pointer to IRP context information for the request
        being processed.

    Irp - The IRP to be used to submit the request to the transport.

    Mdl - A pointer to the MDL for the data to send.

Return Value:

    None.

--*/
{
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PNW_TDI_STRUCT pTdiStruct;

    DebugTrace(0, Dbg, "PreparePacket...\n", 0);

    pIrpContext->ConnectionInformation.UserDataLength = 0;
    pIrpContext->ConnectionInformation.OptionsLength = sizeof( UCHAR );
    pIrpContext->ConnectionInformation.Options =
            (pIrpContext->PacketType == SAP_BROADCAST) ?
                &SapPacketType : &NcpPacketType;
    pIrpContext->ConnectionInformation.RemoteAddressLength = sizeof(TA_IPX_ADDRESS);
    pIrpContext->ConnectionInformation.RemoteAddress = &pIrpContext->Destination;

#if NWDBG
    dump( Dbg,
        &pIrpContext->Destination.Address[0].Address[0],
        sizeof(TDI_ADDRESS_IPX));
    dumpMdl( Dbg, pMdl);
#endif

    //
    //  Set the socket to use for this send.  If unspecified in the
    //  IRP context, use the default (server) socket.
    //

    pTdiStruct = pIrpContext->pTdiStruct == NULL ?
                    &pIrpContext->pNpScb->Server : pIrpContext->pTdiStruct;

    CompletionRoutine = pIrpContext->CompletionSendRoutine == NULL ?
                        CompletionSend : pIrpContext->CompletionSendRoutine;

    TdiBuildSendDatagram(
        pIrp,
        pTdiStruct->pDeviceObject,
        pTdiStruct->pFileObject,
        CompletionRoutine,
        pIrpContext,
        pMdl,
        MdlLength( pMdl ),
        &pIrpContext->ConnectionInformation );

    //
    //  Set the run routine to send now, only if this is the main IRP
    //  for this irp context.
    //

    if ( pIrp == pIrpContext->pOriginalIrp ) {
        pIrpContext->RunRoutine = SendNow;
    }

    return;
}


NTSTATUS
SendPacket(
    PIRP_CONTEXT    pIrpC,
    PNONPAGED_SCB   pNpScb
    )
/*++

Routine Description:

    Queue a packet created by exchange and try to send it to the server.

Arguments:

    pIrpC - supplies the irp context for the request creating the socket.

    pNpScb - supplies the server to receive the request.

Return Value:

    STATUS_PENDING

--*/
{
    if ( AppendToScbQueue( pIrpC, pNpScb ) ) {
        KickQueue( pNpScb );
    }

    return STATUS_PENDING;
}


BOOLEAN
AppendToScbQueue(
    PIRP_CONTEXT    IrpContext,
    PNONPAGED_SCB   NpScb
    )
/*++

Routine Description:

    Queue an IRP context to the SCB, if it is not already there.

Arguments:

    IrpContext - Supplies the IRP context to queue.

    NpScb - Supplies the server to receive the request.

Return Value:

    TRUE - The IRP Context is at the front of the queue.
    FALSE - The IRP Context is not at the front of the queue.

--*/
{
    PLIST_ENTRY ListEntry;
#ifdef MSWDBG
    KIRQL OldIrql;
#endif
    DebugTrace(0, Dbg, "AppendToScbQueue... %08lx\n", NpScb);
    DebugTrace(0, Dbg, "IrpContext = %08lx\n", IrpContext );

    //
    //  Look at the IRP Context flags.  If the IRP is already on the
    //  queue, then it must be at the front and ready for processing.
    //

    if ( FlagOn( IrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) ) {
        ASSERT( NpScb->Requests.Flink == &IrpContext->NextRequest );
        return( TRUE );
    }

#ifdef MSWDBG
    NpScb->RequestQueued = TRUE;
#endif

#if 0  //  Resource layout changed on Daytona.  Disable for now.

    //
    //  Make sure that this thread isn't holding the RCB while waiting for
    //  the SCB queue.
    //

    ASSERT ( NwRcb.Resource.InitialOwnerThreads[0] != (ULONG)PsGetCurrentThread() );
#endif

    //
    //  The IRP Context was not at the front.  Queue it, then look to
    //  see if it was appended to an empty queue.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

#ifdef MSWDBG
    ExAcquireSpinLock( &NpScb->NpScbSpinLock, &OldIrql );
    if ( IsListEmpty(  &NpScb->Requests ) ) {
        ListEntry = NULL;
    } else {
        ListEntry = NpScb->Requests.Flink;
    }

    InsertTailList( &NpScb->Requests, &IrpContext->NextRequest );
    IrpContext->SequenceNumber = NpScb->SequenceNumber++;
    ExReleaseSpinLock( &NpScb->NpScbSpinLock, OldIrql );

#else
    ListEntry = ExInterlockedInsertTailList(
                    &NpScb->Requests,
                    &IrpContext->NextRequest,
                    &NpScb->NpScbSpinLock );
#endif

    if ( ListEntry == NULL ) {
        ASSERT( NpScb->Requests.Flink == &IrpContext->NextRequest );
        DebugTrace(-1, Dbg, "AppendToScbQueue -> TRUE\n", 0);
        return( TRUE );
    } else {
        DebugTrace(-1, Dbg, "AppendToScbQueue -> FALSE\n", 0);
        return( FALSE );
    }

}


VOID
KickQueue(
    PNONPAGED_SCB   pNpScb
    )
/*++

Routine Description:

    Queue a packet created by exchange and try to send it to the server.

    Note: NpScbSpinLock must be held before calling this routine.

Arguments:

    pNpScb - supplies the server queue to kick into life.

Return Value:

    none.

--*/
{

    PIRP_CONTEXT pIrpC;
    PRUN_ROUTINE RunRoutine;
    KIRQL OldIrql;


    DebugTrace( +1, Dbg, "KickQueue...%08lx\n", pNpScb);

    KeAcquireSpinLock( &pNpScb->NpScbSpinLock, &OldIrql );
    if ( IsListEmpty( &pNpScb->Requests )) {
        KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );
        DebugTrace( -1, Dbg, "             Empty Queue\n", 0);
        return;
    }

    pIrpC = CONTAINING_RECORD(pNpScb->Requests.Flink, IRP_CONTEXT, NextRequest);

    ASSERT( pIrpC->pNpScb->Requests.Flink == &pIrpC->NextRequest );
    ASSERT( pIrpC->NodeTypeCode == NW_NTC_IRP_CONTEXT);

    RunRoutine = pIrpC->RunRoutine;

    //  Only call the routine to tell it it is at the front once

    pIrpC->RunRoutine = NULL;

    KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );

    //
    //  If the redir is shutting down do not process this request
    //  unless we must.
    //

    if ( NwRcb.State != RCB_STATE_RUNNING  &&
         !FlagOn( pIrpC->Flags, IRP_FLAG_SEND_ALWAYS ) ) {

        //
        //  Note that it's safe to call the pEx routine without the
        //  spin lock held since this IrpContext just made it to the
        //  front of the queue, and so can't have i/o in progress.
        //

        if ( pIrpC->pEx != NULL) {
            pIrpC->pEx( pIrpC, 0, NULL );
            DebugTrace( -1, Dbg, "KickQueue\n", 0);
            return;
        }
    }

    if ( RunRoutine != NULL ) {

        ASSERT( pNpScb->Receiving == FALSE );

        RunRoutine( pIrpC );

    }

    DebugTrace( -1, Dbg, "KickQueue\n", 0);
    return;
}

VOID
SendNow(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine submits a TDI send request to the tranport layer.

Arguments:

    IrpContext - A pointer to IRP context information for the request
        being processed.

Return Value:

    None.

--*/
{
    PNONPAGED_SCB pNpScb;
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    pNpScb = IrpContext->pNpScb;

    if ( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_RETRY_SEND ) ) {
        pNpScb->RetryCount = DefaultRetryCount;
    }

    //
    //  Ensure that this IRP Context is really at the front of the queue.
    //

    ASSERT( pNpScb->Requests.Flink == &IrpContext->NextRequest );
    IrpContext->RunRoutine = NULL;

    //
    //  Make sure that this is a correctly formatted send request.
    //

    IrpSp = IoGetNextIrpStackLocation( IrpContext->pOriginalIrp );
    ASSERT( IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL );
    ASSERT( IrpSp->MinorFunction == TDI_SEND_DATAGRAM  );

    //
    // This IRP context has a packet ready to send.  Send it now.
    //

    pNpScb->Sending = TRUE;
    if ( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_NOT_OK_TO_RECEIVE ) ) {
        pNpScb->OkToReceive = TRUE;
    }
    pNpScb->Receiving = FALSE;
    pNpScb->Received  = FALSE;

    //
    //  If this packet requires a sequence number, set it now.
    //  The sequence number is updated when we receive a response.
    //
    //  We do not need to synchronize access to SequenceNo since
    //  this is the only active packet for this SCB.
    //

    if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_SEQUENCE_NO_REQUIRED ) ) {
        ClearFlag( IrpContext->Flags,  IRP_FLAG_SEQUENCE_NO_REQUIRED );
        IrpContext->req[2] = pNpScb->SequenceNo;
    }

    //
    //  If this packet is a burst packet, fill in the burst sequence number
    //  now, and burst request number.
    //

    if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_BURST_PACKET ) ) {

        LongByteSwap( IrpContext->req[12], pNpScb->BurstSequenceNo );
        pNpScb->BurstSequenceNo++;

        ShortByteSwap( IrpContext->req[20], pNpScb->BurstRequestNo );
        ShortByteSwap( IrpContext->req[22], pNpScb->BurstRequestNo );

    }

    DebugTrace( +0, Dbg, "Irp   %X\n", IrpContext->pOriginalIrp);
    DebugTrace( +0, Dbg, "pIrpC %X\n", IrpContext);
    DebugTrace( +0, Dbg, "Mdl   %X\n", IrpContext->TxMdl);

#if NWDBG
    dumpMdl( Dbg, IrpContext->TxMdl);
#endif

    {
        ULONG len = 0;
        PMDL Next = IrpContext->TxMdl;

        do {
            len += MmGetMdlByteCount(Next);
        } while (Next = Next->Next);

        Stats.BytesTransmitted.QuadPart += len;
    }

    Status = IoCallDriver(pNpScb->Server.pDeviceObject, IrpContext->pOriginalIrp);
    DebugTrace( -1, Dbg, "Transport returned: %08lx\n", Status );

    Stats.NcpsTransmitted.QuadPart++;

    return;

}


VOID
SetEvent(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine set the IrpContext Event to the signalled state.

Arguments:

    IrpContext - A pointer to IRP context information for the request
        being processed.

Return Value:

    None.

--*/
{
    //
    //  Ensure that this IRP Context is really at the front of the queue.
    //

    ASSERT( IrpContext->pNpScb->Requests.Flink == &IrpContext->NextRequest );

    //
    //  This IRP context has a thread waiting to get to the front of
    //  the queue.  Set the event to indicate that it can continue.
    //

#ifdef MSWDBG
    ASSERT( IrpContext->Event.Header.SignalState == 0 );
    IrpContext->DebugValue = 0x105;
#endif

    DebugTrace( +0, Dbg, "Setting event for IrpContext   %X\n", IrpContext );
    NwSetIrpContextEvent( IrpContext );
}


USHORT
NextSocket(
    IN USHORT OldValue
    )
/*++

Routine Description:

    This routine returns the byteswapped OldValue++ wrapping from 7fff.

Arguments:

    OldValue - supplies the existing socket number in the range
        0x4000 to 0x7fff.

Return Value:

    USHORT OldValue++

--*/

{
    USHORT TempValue = OldValue + 0x0100;

    if ( TempValue < 0x100 ) {
        if ( TempValue == 0x007f ) {
            //  Wrap back to 0x4000 from 0xff7f
            return 0x0040;
        } else {
            // Go from something like 0xff40 to 0x0041
            return TempValue + 1;
        }
    }
    return TempValue;
}


ULONG
MdlLength (
    register IN PMDL Mdl
    )
/*++

Routine Description:

    This routine returns the number of bytes in an MDL.

Arguments:

    IN PMDL Mdl - Supplies the MDL to determine the length on.

Return Value:

    ULONG - Number of bytes in the MDL

--*/

{
    register ULONG Size = 0;
    while (Mdl!=NULL) {
        Size += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }
    return Size;
}


NTSTATUS
CompletionSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the IrpContext associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PNONPAGED_SCB pNpScb;
    PIRP_CONTEXT pIrpC = (PIRP_CONTEXT) Context;
    KIRQL OldIrql;

    //
    //  Avoid completing the Irp because the Mdl etc. do not contain
    //  their original values.
    //

    DebugTrace( +1, Dbg, "CompletionSend\n", 0);
    DebugTrace( +0, Dbg, "Irp    %X\n", Irp);
    DebugTrace( +0, Dbg, "pIrpC  %X\n", pIrpC);
    DebugTrace( +0, Dbg, "Status %X\n", Irp->IoStatus.Status);

    pNpScb = pIrpC->pNpScb;
    KeAcquireSpinLock( &pNpScb->NpScbSpinLock, &OldIrql );

    ASSERT( pNpScb->Sending == TRUE );
    pNpScb->Sending = FALSE;

    //
    //  If we got a receive indication while waiting for send
    //  completion and the data is all valid, call the receive handler routine now.
    //

    if ( pNpScb->Received ) {

        pNpScb->Receiving = FALSE;
        pNpScb->Received  = FALSE;

        KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );

        pIrpC->pEx(
            pIrpC,
            pIrpC->ResponseLength,
            pIrpC->rsp );

    } else if (( Irp->IoStatus.Status == STATUS_DEVICE_DOES_NOT_EXIST  ) ||
               ( Irp->IoStatus.Status == STATUS_BAD_NETWORK_PATH ) ||
               ( Irp->IoStatus.Status == STATUS_INVALID_BUFFER_SIZE ) ||
               ( Irp->IoStatus.Status == STATUS_NETWORK_UNREACHABLE )) {
        //
        //  The send failed.
        //

        //
        //  If this SCB is still flagged okay to receive (how could it not?)
        //  simply call the callback routine to indicate failure.
        //
        //  If the SendCompletion hasn't happened, set up so that send
        //  completion will call the callback routine.
        //

        if ( pNpScb->OkToReceive ) {

            pNpScb->OkToReceive = FALSE;
            ClearFlag( pIrpC->Flags, IRP_FLAG_RETRY_SEND );

            KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );
            DebugTrace(+0, Dbg, "Send failed\n", 0 );

            pIrpC->ResponseParameters.Error = ERROR_UNEXP_NET_ERR;
            pIrpC->pEx( pIrpC, 0, NULL );

        } else {
            KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );
        }

    } else {

        KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );
    }

    DebugTrace( -1, Dbg, "CompletionSend STATUS_MORE_PROCESSING_REQUIRED\n", 0);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

#if NWDBG
BOOLEAN  UseIrpReceive = FALSE;
#endif


NTSTATUS
ServerDatagramHandler(
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler for the
    Server socket.

Arguments:

    TdiEventContext - Context provided for this event, a pointer to the
        non paged SCB.

    SourceAddressLength - Length of the originator of the datagram.

    SourceAddress - String describing the originator of the datagram.

    OptionsLength - Length of the buffer pointed to by Options.

    Options - Options for the receive.

    ReceiveDatagramFlags - Ignored.

    BytesIndicated - Number of bytes this indication.

    BytesAvailable - Number of bytes in complete Tsdu.

    BytesTaken - Returns the number of bytes used.

    Tsdu - Pointer describing this TSDU, typically a lump of bytes.

    IoRequestPacket - TdiReceive IRP if MORE_PROCESSING_REQUIRED.

Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    PNONPAGED_SCB pNpScb = (PNONPAGED_SCB)TdiEventContext;
    NTSTATUS Status = STATUS_DATA_NOT_ACCEPTED;
    UCHAR PacketType;
    PUCHAR RspData = (PUCHAR)Tsdu;
    PIRP_CONTEXT pIrpC;
    PNW_TDI_STRUCT pTdiStruct;
    BOOLEAN AcceptPacket = TRUE;
    PNCP_BURST_READ_RESPONSE pBurstRsp;
    NTSTATUS BurstStatus;

    *IoRequestPacket = NULL;
#if DBG
    pTdiStruct = NULL;
#endif

    if (pNpScb->NodeTypeCode != NW_NTC_SCBNP ) {

        DebugTrace(+0, 0, "nwrdr: Invalid Server Indication %x\n", pNpScb );
#if DBG
        DbgBreakPoint();
#endif
        return STATUS_DATA_NOT_ACCEPTED;
    }

#if NWDBG

    // Debug only trick to test IRP receive.

    if ( UseIrpReceive ) {
        BytesIndicated = 0;
    }
#endif

    DebugTrace(+1, Dbg, "ServerDatagramHandler\n", 0);
    DebugTrace(+0, Dbg, "Server              %x\n", pNpScb);
    DebugTrace(+0, Dbg, "BytesIndicated      %x\n", BytesIndicated);
    DebugTrace(+0, Dbg, "BytesAvailable      %x\n", BytesAvailable);

    //
    //  SourceAddress is the address of the server or the bridge tbat sent
    //  the packet.
    //

#if NWDBG
    dump( Dbg, SourceAddress, SourceAddressLength );
    dump( Dbg, Tsdu, BytesIndicated );
#endif

    if ( OptionsLength == 1 ) {
        PacketType = *(PCHAR)Options;
        DebugTrace(+0, Dbg, "PacketType          %x\n", PacketType);
    } else {
        DebugTrace(+0, Dbg, "OptionsLength       %x\n", OptionsLength);
#if NWDBG
        dump( Dbg, Options, OptionsLength );
#endif
    }

    KeAcquireSpinLockAtDpcLevel(&pNpScb->NpScbSpinLock );

    if ( !pNpScb->OkToReceive ) {

        //
        // This SCB is not expecting to receive any data.
        // Discard this packet.
        //

        DropCount++;
        DebugTrace(+0, Dbg, "OkToReceive == FALSE - discard packet\n", 0);
        AcceptPacket = FALSE;
        goto process_packet;
    }

    pIrpC = CONTAINING_RECORD(pNpScb->Requests.Flink, IRP_CONTEXT, NextRequest);

    ASSERT( pIrpC->NodeTypeCode == NW_NTC_IRP_CONTEXT);

    //
    //  Verify that this packet came from where we expect it to come from,
    //  and that is has a minimum size.
    //

    if ( ( pIrpC->PacketType != SAP_BROADCAST &&
           RtlCompareMemory(
               &pIrpC->Destination,
               SourceAddress,
               SourceAddressLength ) != (ULONG)SourceAddressLength ) ||
          BytesIndicated < 8 ) {

        AcceptPacket = FALSE;
#ifdef NWDBG
        DbgPrintf ( "***exchange: stray response tossed\n", 0 );
#endif
        goto process_packet;
    }

    switch ( pIrpC->PacketType ) {

    case SAP_BROADCAST:

        //
        //  We are expected a SAP Broadcast frame.  Ensure that this
        //  is a correctly formatted SAP.
        //

        if ( pIrpC->req[0] != RspData[0] ||
             pIrpC->req[2] != RspData[2] ||
             pIrpC->req[3] != RspData[3] ||
             SourceAddressLength != sizeof(TA_IPX_ADDRESS) ) {

            DbgPrintf ( "***exchange: bad SAP packet\n" );
            AcceptPacket = FALSE;
        }

        pTdiStruct = &pNpScb->Server;
        break;

    case NCP_BURST:

        if ( *(USHORT UNALIGNED *)&RspData[0] == PEP_COMMAND_BURST ) {

            if ( BytesIndicated < 36 ) {

                AcceptPacket = FALSE;

            } else if ( ( RspData[2] & BURST_FLAG_SYSTEM_PACKET ) &&
                        RspData[34] == 0 &&
                        RspData[35] == 0 ) {

                //
                //  We have burst mode busy reponse.
                //

                DebugTrace(+0, Dbg, "Burst mode busy\n", 0 );
                NwProcessPositiveAck( pNpScb );

                AcceptPacket = FALSE;

            } else {

                USHORT Brn;

                //
                //  Check the burst sequence number.
                //

                ShortByteSwap( Brn, RspData[20] );

                if ( pNpScb->BurstRequestNo == Brn ) {
                    pTdiStruct = &pNpScb->Burst;
                    AcceptPacket = TRUE;
                } else {
                    AcceptPacket = FALSE;
                }
            }
        } else {
            AcceptPacket = FALSE;
        }

        break;

    case NCP_ECHO:

        //
        // If this is the LIP packet that we are expecting, then accept it.
        // However, on a slow link, it could be an old LIP packet that we
        // have already given up on.  If this is the case, we should drop
        // the packet and increase the LIP max wait time.
        //
        // The sequence number is the fourth DWORD in the response and the
        // maximum LIP tick adjustment that we will allow is 18 ticks, which
        // is 1 second.
        //

        pTdiStruct = &pNpScb->Echo;

        if ( *(DWORD UNALIGNED *)&RspData[12] != pNpScb->LipSequenceNumber ) {

            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "LIP packet received out of order.\n", 0 );

            if ( pNpScb->LipTickAdjustment < 18 ) {
                pNpScb->LipTickAdjustment += 2;
            }

            AcceptPacket = FALSE;

        } else {

            AcceptPacket = TRUE;
        }

        break;

    default:

        pTdiStruct = &pNpScb->Server;

        //
        //  This is the handling for all packets types other than
        //  SAP Broadcasts.
        //

        ASSERT( (pIrpC->PacketType == NCP_CONNECT) ||
                (pIrpC->PacketType == NCP_FUNCTION) ||
                (pIrpC->PacketType == NCP_SUBFUNCTION) ||
                (pIrpC->PacketType == NCP_DISCONNECT));

        if ( *(USHORT UNALIGNED *)&RspData[0] == PEP_COMMAND_ACKNOWLEDGE ) {

            AcceptPacket = FALSE;

            if ( RspData[2] == pIrpC->req[2] &&
                 RspData[3] == pIrpC->req[3]  ) {

                //
                //  We have received an ACK frame.
                //

                DebugTrace(+0, Dbg, "Received positive acknowledge\n", 0 );
                NwProcessPositiveAck( pNpScb );

            }

            break;

        } else if ( *(USHORT UNALIGNED *)&RspData[0] == PEP_COMMAND_BURST ) {

            //
            //  This is a stray burst response, ignore it.
            //

            AcceptPacket = FALSE;
            break;

        } else if ( *(USHORT UNALIGNED *)&RspData[0] != PEP_COMMAND_RESPONSE ) {

            //
            //  We have received an invalid frame.
            //

            DbgPrintf ( "***exchange: invalid Response\n" );
            AcceptPacket = FALSE;
            break;

        } else if ( pIrpC->PacketType == NCP_CONNECT ) {

            pNpScb->SequenceNo   = RspData[2];
            pNpScb->ConnectionNo = RspData[3];
            pNpScb->ConnectionNoHigh = RspData[5];

            //  We should now continue to process the Connect
            break;
        }

        //
        //  Make sure this the response we expect.
        //

        if ( !VerifyResponse( pIrpC, RspData ) ) {

            //
            //  This is a stray or corrupt response.  Ignore it.
            //

            AcceptPacket = FALSE;
            break;

        } else {

            //
            //  We have received a valid, in sequence response.
            //  Bump the current sequence number.
            //

            ++pNpScb->SequenceNo;

        }

        if ( pIrpC->PacketType == NCP_FUNCTION ||
             pIrpC->PacketType == NCP_SUBFUNCTION ) {

            if ( ( RspData[7] &
                     ( NCP_STATUS_BAD_CONNECTION |
                       NCP_STATUS_NO_CONNECTIONS ) ) != 0 ) {
                //
                //  We've lost our connection to the server.
                //  Try to reconnect if it is allowed for this request.
                //

                pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

                if ( BooleanFlagOn( pIrpC->Flags, IRP_FLAG_RECONNECTABLE ) ) {
                    ClearFlag( pIrpC->Flags, IRP_FLAG_RECONNECTABLE );
                    AcceptPacket = FALSE;
                    if (!pNpScb->Sending) {
                        ScheduleReconnectRetry( pIrpC );
                        pNpScb->OkToReceive = FALSE;
                    } else {
                        //
                        // If we are sending, it is not OK schedule the
                        // retry now, because if we do and the send
                        // completion hasnt been run we could end up
                        // with 2 guys thinking they are at the front
                        // of the queue. We let the send complete and
                        // wait for that to fail instead. We will
                        // eventually reconnect.
                        //
                    }
                }

                break;

            } else if ( ( RspData[7] & NCP_STATUS_SHUTDOWN ) != 0 ) {

                //
                //  This server's going down.  We need to process this
                //  message in the FSP.   Copy the indicated data and
                //  process in the FSP.
                //

                pNpScb->State = SCB_STATE_ATTACHING;
                AcceptPacket = FALSE;
                pNpScb->OkToReceive = FALSE;
                pNpScb->Receiving = TRUE;

                CopyIndicatedData(
                    pIrpC,
                    RspData,
                    BytesIndicated,
                    BytesTaken,
                    ReceiveDatagramFlags );

                pIrpC->PostProcessRoutine = FspProcessServerDown;
                Status = NwPostToFsp( pIrpC, FALSE );

                break;
            }

        } else if ( pIrpC->PacketType == NCP_DISCONNECT ) {

            //
            //  We have received a disconnect frame.
            //

            break;
        }

    }

process_packet:
    if ( AcceptPacket ) {

        ASSERT ( !IsListEmpty( &pNpScb->Requests ));
        ASSERT( pIrpC->pEx != NULL );


        //
        //  If we received this packet without a retry, adjust the
        //  send timeout value.
        //

        if (( !BooleanFlagOn( pIrpC->Flags, IRP_FLAG_RETRY_SEND ) ) &&
            ( pIrpC->PacketType != NCP_BURST )) {

            SHORT NewTimeout;

            NewTimeout = ( pNpScb->SendTimeout + pNpScb->TickCount ) / 2;


            //
            // tommye - MS bug 10511 - added code to set pNpScb->TimeOut 
            // to sames as pNpScb->SendTimeout per bug report recommendation.
            //

            pNpScb->TimeOut = pNpScb->SendTimeout = MAX( NewTimeout, pNpScb->TickCount + 1 );

            DebugTrace( 0, Dbg, "Successful exchange, new send timeout = %d\n", pNpScb->SendTimeout );
        }

        //
        //  If the transport didn't indicate all of the data, we'll need
        //  to post a receive IRP.
        //

#ifdef NWDBG
        if (( BytesIndicated < BytesAvailable ) ||
            ( AlwaysAllocateIrp )){
#else
        if ( BytesIndicated < BytesAvailable ) {
#endif

            if ( ( BooleanFlagOn( pIrpC->Flags, IRP_FLAG_BURST_REQUEST ) ) &&
                 ( IsListEmpty( &pIrpC->Specific.Read.PacketList ) ) ) {

                pBurstRsp = (PNCP_BURST_READ_RESPONSE)RspData;
                BurstStatus = NwBurstResultToNtStatus( pBurstRsp->Result );

                //
                // If this entire burst failed with an error, we can't
                // let the receive data routine signal the caller until
                // the pEx gets called and we exit on the correct paths.
                //

                if ( !NT_SUCCESS( BurstStatus ) ) {

                    DebugTrace( 0, Dbg, "Special burst termination %08lx.\n", BurstStatus );
                    pIrpC->Specific.Read.Status = BurstStatus;

                    if ( pNpScb->Sending ) {

                        //
                        // If the send hasn't completed yet, we can't accept
                        // the packet because IPX may not have completed back
                        // to us yet!
                        //

                        KeReleaseSpinLockFromDpcLevel(&pNpScb->NpScbSpinLock );
                        DebugTrace(-1, Dbg, "ServerDatagramHandler -> STATUS_DATA_NOT_ACCEPTED (%08lx)\n", BurstStatus );
                        return( STATUS_DATA_NOT_ACCEPTED );

                    } else {

                        //
                        // Handle this one just like normal, except that we
                        // know it's going to fail in the receive data routine
                        // and we don't want the timeout routine to fire
                        // causing us all sort of grief, so we set OkToReceive
                        // to FALSE.
                        //

                        pNpScb->OkToReceive = FALSE;
                    }
                }

            }

            FreeReceiveIrp( pIrpC ); //  Free old Irp if one was allocated

            Status = AllocateReceiveIrp(
                         pIrpC,
                         RspData,
                         BytesAvailable,
                         BytesTaken,
                         pTdiStruct );

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

                pNpScb->OkToReceive = FALSE;
                pNpScb->Receiving   = TRUE;

            } else if (!NT_SUCCESS( Status ) ) {

                pIrpC->ReceiveIrp = NULL;
                Status = STATUS_INSUFFICIENT_RESOURCES;

            }

            KeReleaseSpinLockFromDpcLevel(&pNpScb->NpScbSpinLock );

            *IoRequestPacket = pIrpC->ReceiveIrp;

        } else {

           pNpScb->OkToReceive = FALSE;

            //
            //  The transport has indicated all of the data.
            //  If the send has completed, call the pEx routine,
            //  otherwise copy the data to a buffer and let the
            //  send completion routine call the pEx routine.
            //

            if ( pNpScb->Sending ) {
                DebugTrace( 0, Dbg, "Received data before send completion\n", 0 );

                Status = CopyIndicatedData(
                             pIrpC,
                             RspData,
                             BytesIndicated,
                             BytesTaken,
                             ReceiveDatagramFlags );

                if (NT_SUCCESS(Status)) {
                   pNpScb->Received    = TRUE;
                   pNpScb->Receiving   = TRUE;
                } else {
                    //  Ignore this packet
                    pNpScb->OkToReceive = TRUE;
                }

                KeReleaseSpinLockFromDpcLevel(&pNpScb->NpScbSpinLock );

            } else {
                pNpScb->Receiving = FALSE;
                pNpScb->Received  = FALSE;

                KeReleaseSpinLockFromDpcLevel(&pNpScb->NpScbSpinLock );

                DebugTrace(+0, Dbg, "Call pIrpC->pEx     %x\n", pIrpC->pEx );

                Status = pIrpC->pEx(pIrpC,
                                    BytesAvailable,
                                    RspData);
            }

            *BytesTaken = BytesAvailable;

        }

    } else { //(!AcceptPacket)

        KeReleaseSpinLockFromDpcLevel(&pNpScb->NpScbSpinLock );
        Status = STATUS_DATA_NOT_ACCEPTED;

    }

    Stats.NcpsReceived.QuadPart++;
    Stats.BytesReceived.QuadPart += BytesAvailable;

    DebugTrace(-1, Dbg, "ServerDatagramHandler -> %08lx\n", Status );
    return( Status );

} // ServerDatagramHandler

NTSTATUS
CopyIndicatedData(
    PIRP_CONTEXT pIrpContext,
    PCHAR ReceiveData,
    ULONG BytesIndicated,
    PULONG BytesAccepted,
    ULONG ReceiveDatagramFlags
    )
/*++

Routine Description:

    This routine copies indicated data to a buffer.  If the packet is small
    enough the data is copied to the preallocated receive buffer in the
    IRP context.   If the packet is too long, a new buffer is allocated.

Arguments:

    pIrpContext - A pointer the block of context information for the request
        in progress.

    ReceiveData - A pointer to the indicated data.

    BytesIndicated - The number of bytes available in the received packet.

    BytesAccepted - Returns the number of bytes accepted by the receive
        routine.

    ReceiveDatagramFlags - Receive flags given to us by the transport.

Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS Status;
    PMDL ReceiveMdl;
    PVOID MappedVa;
    ULONG BytesToCopy;
    BOOLEAN DeleteMdl = FALSE;

    pIrpContext->ResponseLength = BytesIndicated;

    //
    //  If there is a receive data routine, use it to generate the receive
    //  MDL, otherwise use the default MDL.
    //

    if ( pIrpContext->ReceiveDataRoutine != NULL ) {

        Status = pIrpContext->ReceiveDataRoutine(
                     pIrpContext,
                     BytesIndicated,
                     BytesAccepted,
                     ReceiveData,
                     &ReceiveMdl );

        if ( !NT_SUCCESS( Status ) ) {
            return( Status );
        }

        //
        //  We can accept up to the size of a burst read header, plus
        //  3 bytes of fluff for the unaligned read case.
        //

        ASSERT( *BytesAccepted <= sizeof(NCP_BURST_READ_RESPONSE) + 3 );

        BytesIndicated -= *BytesAccepted;
        ReceiveData += *BytesAccepted;

        DeleteMdl = TRUE;

    } else {

        *BytesAccepted = 0;
        ReceiveMdl = pIrpContext->RxMdl;

    }

    if ( ReceiveMdl != NULL ) {

        while ( BytesIndicated > 0 && ReceiveMdl != NULL ) {

            MappedVa = MmGetSystemAddressForMdlSafe( ReceiveMdl, NormalPagePriority );
            BytesToCopy = MIN( MmGetMdlByteCount( ReceiveMdl ), BytesIndicated );
            TdiCopyLookaheadData( MappedVa, ReceiveData, BytesToCopy, ReceiveDatagramFlags );

            ReceiveMdl = ReceiveMdl->Next;
            BytesIndicated -= BytesToCopy;
            ReceiveData += BytesToCopy;

            ASSERT( !( BytesIndicated != 0 && ReceiveMdl == NULL ) );
        }

        if (DeleteMdl) {

            PMDL Mdl = pIrpContext->Specific.Read.PartialMdl;
            PMDL NextMdl;

            while ( Mdl != NULL ) {
                NextMdl = Mdl->Next;
                DebugTrace( 0, Dbg, "Freeing MDL %x\n", Mdl );
                FREE_MDL( Mdl );
                Mdl = NextMdl;
            }

            pIrpContext->Specific.Read.PartialMdl = NULL;
        }
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
AllocateReceiveIrp(
    PIRP_CONTEXT pIrpContext,
    PVOID ReceiveData,
    ULONG BytesAvailable,
    PULONG BytesAccepted,
    PNW_TDI_STRUCT pTdiStruct
    )
/*++

Routine Description:

    This routine allocates an IRP and if necessary a receive buffer.  It
    then builds an MDL for the buffer and formats the IRP to do a TDI
    receive.

Arguments:

    pIrpContext - A pointer the block of context information for the request
        in progress.

    ReceiveData - The indicated data.

    BytesAvailable - The number of bytes available in the received packet.

    BytesAccepted - Returns the number of bytes accepted from the packet.

    pTdiStruct - A pointer to the TdiStruct which has indicated the receive.

Return Value:

    NTSTATUS - Status of receive operation
                STATUS_MORE_PROCESSING_REQUIRED means we were successful.

--*/
{
    PIRP Irp = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT( pTdiStruct != NULL );

    Irp = ALLOCATE_IRP( pIrpContext->pNpScb->Server.pDeviceObject->StackSize, FALSE );

    if ( Irp == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanExit;
    }

    //
    //  If there is no receive data routine for this IRP, the
    //  RxMdl must point to a valid place to put the data.
    //
    //  If there is a ReceiveDataRoutine it will build an MDL
    //

    if ( pIrpContext->ReceiveDataRoutine == NULL ) {

        ULONG LengthOfMdl;

        LengthOfMdl = MdlLength( pIrpContext->RxMdl );

        //
        //  If the server sent more data than we can receive, simply
        //  ignore the excess.  In particular 3.11 pads long name
        //  response with an excess of junk.
        //

        if ( BytesAvailable > LengthOfMdl ) {
            BytesAvailable = LengthOfMdl;
        }

        Irp->MdlAddress = pIrpContext->RxMdl;
        *BytesAccepted = 0;

    } else {

        Status = pIrpContext->ReceiveDataRoutine(
                     pIrpContext,
                     BytesAvailable,
                     BytesAccepted,
                     ReceiveData,
                     &Irp->MdlAddress );

        if ( !NT_SUCCESS( Status ) ||
             Irp->MdlAddress == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanExit;

        }

        SetFlag( pIrpContext->Flags, IRP_FLAG_FREE_RECEIVE_MDL );

    }

CleanExit:

    if ( !NT_SUCCESS( Status ) ) {

        if ( Irp != NULL ) {
            FREE_IRP( Irp );
        }

        Irp = NULL;
        pIrpContext->ReceiveIrp = NULL;
        Status = STATUS_DATA_NOT_ACCEPTED;
        return( Status );
    }

    pIrpContext->ReceiveIrp = Irp;
    Status = STATUS_MORE_PROCESSING_REQUIRED;

    pIrpContext->ResponseLength = BytesAvailable;

    TdiBuildReceive(
        Irp,
        pTdiStruct->pDeviceObject,
        pTdiStruct->pFileObject,
        ReceiveIrpCompletion,
        pIrpContext,
        Irp->MdlAddress,
        0,
        BytesAvailable - *BytesAccepted );

    IoSetNextIrpStackLocation( Irp );

    return( Status );
}

NTSTATUS
ReceiveIrpCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

    This routine is called when a recieve IRP completes.

Arguments:

    DeviceObject - Unused.

    Irp - The IRP that completed.

    Context - A pointer the block of context information for the request
        in progress.


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    PIRP_CONTEXT IrpContext = (PIRP_CONTEXT)Context;
    PIO_STACK_LOCATION IrpSp;
    PNONPAGED_SCB pNpScb;
    PMDL Mdl, NextMdl;
    KIRQL OldIrql;

    ASSERT( Irp == IrpContext->ReceiveIrp );

    pNpScb = IrpContext->pNpScb;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Free the IRP MDL if we allocated one specifically for this IRP.
    //

    if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_FREE_RECEIVE_MDL ) ) {

        Mdl = IrpContext->Specific.Read.PartialMdl;
        IrpContext->Specific.Read.PartialMdl = NULL;

        while ( Mdl != NULL ) {
            NextMdl = Mdl->Next;
            DebugTrace( 0, Dbg, "Freeing MDL %x\n", Mdl );
            FREE_MDL( Mdl );
            Mdl = NextMdl;
        }

    }

    if ( !NT_SUCCESS( Irp->IoStatus.Status ) ) {

        //
        //  Failed to receive the data.   Wait for more.
        //

        pNpScb->OkToReceive = TRUE;
        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    //  If the send has completed, call the pEx routine,
    //  otherwise copy the data to a buffer and let the
    //  send completion routine call the pEx routine.
    //

    KeAcquireSpinLock( &pNpScb->NpScbSpinLock, &OldIrql );

    if ( pNpScb->Sending ) {
        DebugTrace( 0, Dbg, "Received data before send completion\n", 0 );

        //
        //  Tell send completion to call pEx.
        //

        pNpScb->Received = TRUE;
        KeReleaseSpinLock(&pNpScb->NpScbSpinLock, OldIrql );

    } else {
        pNpScb->Receiving = FALSE;
        pNpScb->Received  = FALSE;

        KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );
        DebugTrace(+0, Dbg, "Call pIrpC->pEx     %x\n", IrpContext->pEx );
        IrpContext->pEx(
            IrpContext,
            IrpContext->ResponseLength,
            IrpContext->rsp );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
FreeReceiveIrp(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine frees a IRP that was allocated to do a receive.

Arguments:

    IrpContext - A pointer the block of context information for the request
        in progress.


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    if ( IrpContext->ReceiveIrp == NULL ) {
        return;
    }

    FREE_IRP( IrpContext->ReceiveIrp );
    IrpContext->ReceiveIrp = NULL;
}


NTSTATUS
WatchDogDatagramHandler(
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler for the
    Server socket.

Arguments:

    TdiEventContext - Context provided for this event, a pointer to the
        non paged SCB.

    SourceAddressLength - Length of the originator of the datagram.

    SourceAddress - String describing the originator of the datagram.

    OptionsLength - Length of the buffer pointed to by Options.

    Options - Options for the receive.

    ReceiveDatagramFlags - Ignored.

    BytesIndicated - Number of bytes this indication.

    BytesAvailable - Number of bytes in complete Tsdu.

    BytesTaken - Returns the number of bytes used.

    Tsdu - Pointer describing this TSDU, typically a lump of bytes.

    IoRequestPacket - TdiReceive IRP if MORE_PROCESSING_REQUIRED.

Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    PNONPAGED_SCB pNpScb = (PNONPAGED_SCB)TdiEventContext;
    PUCHAR RspData = (PUCHAR)Tsdu;

    *IoRequestPacket = NULL;


    //
    //  Transport will complete the processing of the request, we don't
    //  want the datagram.
    //


    DebugTrace(+1, Dbg, "WatchDogDatagramHandler\n", 0);
    DebugTrace(+0, Dbg, "SourceAddressLength %x\n", SourceAddressLength);
    DebugTrace(+0, Dbg, "BytesIndicated      %x\n", BytesIndicated);
    DebugTrace(+0, Dbg, "BytesAvailable      %x\n", BytesAvailable);
    DebugTrace(+0, Dbg, "BytesTaken          %x\n", *BytesTaken);
    //
    //  SourceAddress is the address of the server or the bridge tbat sent
    //  the packet.
    //

#if NWDBG
    dump( Dbg, SourceAddress, SourceAddressLength );
    dump( Dbg, Tsdu, BytesIndicated );
#endif

    if (pNpScb->NodeTypeCode != NW_NTC_SCBNP ) {
        DebugTrace(+0, 0, "nwrdr: Invalid Watchdog Indication %x\n", pNpScb );
#if DBG
        DbgBreakPoint();
#endif
        return STATUS_DATA_NOT_ACCEPTED;
    }

    Stats.NcpsReceived.QuadPart++;
    Stats.BytesReceived.QuadPart += BytesAvailable;

    if ( RspData[1] == NCP_SEARCH_CONTINUE ) {
        PIRP pIrp;
        PIRP_CONTEXT pIrpContext;

        pIrp = ALLOCATE_IRP( pNpScb->WatchDog.pDeviceObject->StackSize, FALSE);
        if (pIrp == NULL) {
            DebugTrace(-1, Dbg, "                       %lx\n", STATUS_DATA_NOT_ACCEPTED);
            return STATUS_DATA_NOT_ACCEPTED;
        }

        try {
            pIrpContext = AllocateIrpContext( pIrp );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            FREE_IRP( pIrp );
            DebugTrace(-1, Dbg, "                       %lx\n", STATUS_DATA_NOT_ACCEPTED);
            return STATUS_DATA_NOT_ACCEPTED;
        }


        pIrpContext->req[0] = pNpScb->ConnectionNo;

        //
        //  Response 'Y' or connection is valid and its from the right server,
        //      or 'N' if it is not.
        //

        if (( RspData[0] == pNpScb->ConnectionNo ) &&
            ( RtlCompareMemory(
                ((PTA_IPX_ADDRESS)SourceAddress)->Address[0].Address,
                &pNpScb->ServerAddress,
                8) == 8 ))
        {
            LARGE_INTEGER KillTime, Now;
            BOOL ScbIsOld ;

            //
            // Check if this is a not-logged-in SCB that has not been used
            // for while. If it is, answer NO. In attach.c, we dont disconnect
            // from a nearest server immediately to avoid the re-connect
            // overheads. This is where we time it out.
            //

            KeQuerySystemTime( &Now );
            KillTime.QuadPart = Now.QuadPart - ( NwOneSecond * DORMANT_SCB_KEEP_TIME);

            ScbIsOld = ((pNpScb->State == SCB_STATE_LOGIN_REQUIRED) &&
                        (pNpScb->LastUsedTime.QuadPart < KillTime.QuadPart))  ;


            pIrpContext->req[1] = ScbIsOld ? 'N' : 'Y';

            if (ScbIsOld)
            {
                pNpScb->State = SCB_STATE_RECONNECT_REQUIRED ;
                //
                //---- Multi-user code merge ----
                //
                Stats.Sessions--;

                if ( pNpScb->MajorVersion == 2 ) {
                    Stats.NW2xConnects--;
                } else if ( pNpScb->MajorVersion == 3 ) {
                    Stats.NW3xConnects--;
                } else if ( pNpScb->MajorVersion == 4 ) {
                    Stats.NW4xConnects--;
                }
                //---------------------------------
            }

            DebugTrace(-1,Dbg,"WatchDog Response: %s\n", ScbIsOld ? "N" : "Y");

        } else {

            pIrpContext->req[1] = 'N';
        }

        pIrpContext->TxMdl->ByteCount = 2;

        pIrpContext->ConnectionInformation.UserDataLength = 0;
        pIrpContext->ConnectionInformation.OptionsLength = sizeof( UCHAR );
        pIrpContext->ConnectionInformation.Options = &SapPacketType;
        pIrpContext->ConnectionInformation.RemoteAddressLength = sizeof(TA_IPX_ADDRESS);
        pIrpContext->ConnectionInformation.RemoteAddress = &pIrpContext->Destination;

        BuildIpxAddress(
            ((PTA_IPX_ADDRESS)SourceAddress)->Address[0].Address[0].NetworkAddress,
            ((PTA_IPX_ADDRESS)SourceAddress)->Address[0].Address[0].NodeAddress,
            ((PTA_IPX_ADDRESS)SourceAddress)->Address[0].Address[0].Socket,
            &pIrpContext->Destination);

        TdiBuildSendDatagram(
            pIrpContext->pOriginalIrp,
            pNpScb->WatchDog.pDeviceObject,
            pNpScb->WatchDog.pFileObject,
            &CompletionWatchDogSend,
            pIrpContext,
            pIrpContext->TxMdl,
            MdlLength(pIrpContext->TxMdl),
            &pIrpContext->ConnectionInformation);

        IoCallDriver(
            pNpScb->WatchDog.pDeviceObject,
            pIrpContext->pOriginalIrp );
    }

    DebugTrace(-1, Dbg, "                       %lx\n", STATUS_DATA_NOT_ACCEPTED);
    return STATUS_DATA_NOT_ACCEPTED;

    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( BytesTaken );
    UNREFERENCED_PARAMETER( Tsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( Options );
}


NTSTATUS
CompletionWatchDogSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the IrpContext associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{

    PIRP_CONTEXT pIrpC = (PIRP_CONTEXT) Context;

    //
    //  Avoid completing the Irp because the Mdl etc. do not contain
    //  their original values.
    //

    DebugTrace( +1, Dbg, "CompletionWatchDogSend\n", 0);
    DebugTrace( +0, Dbg, "Irp   %X\n", Irp);
    DebugTrace( -1, Dbg, "pIrpC %X\n", pIrpC);

    FREE_IRP( pIrpC->pOriginalIrp );

    pIrpC->pOriginalIrp = NULL; // Avoid FreeIrpContext modifying freed Irp.

    FreeIrpContext( pIrpC );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}


NTSTATUS
SendDatagramHandler(
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler for the
    Server socket.

Arguments:

    TdiEventContext - Context provided for this event, a pointer to the
        non paged SCB.

    SourceAddressLength - Length of the originator of the datagram.

    SourceAddress - String describing the originator of the datagram.

    OptionsLength - Length of the buffer pointed to by Options.

    Options - Options for the receive.

    ReceiveDatagramFlags - Ignored.

    BytesIndicated - Number of bytes this indication.

    BytesAvailable - Number of bytes in complete Tsdu.

    BytesTaken - Returns the number of bytes used.

    Tsdu - Pointer describing this TSDU, typically a lump of bytes.

    IoRequestPacket - TdiReceive IRP if MORE_PROCESSING_REQUIRED.

Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    PNONPAGED_SCB pNpScb = (PNONPAGED_SCB)TdiEventContext;
    PUCHAR RspData = (PUCHAR)Tsdu;
    PIRP_CONTEXT pIrpContext;
    PLIST_ENTRY listEntry;
    PIRP Irp;

    *IoRequestPacket = NULL;

    DebugTrace(0, Dbg, "SendDatagramHandler\n", 0);

    Stats.NcpsReceived.QuadPart++;
    Stats.BytesReceived.QuadPart += BytesAvailable;

    //
    //  Transport will complete the processing of the request, we don't
    //  want the datagram.
    //

    DebugTrace(+1, Dbg, "SendDatagramHandler\n", 0);
    DebugTrace(+0, Dbg, "SourceAddressLength %x\n", SourceAddressLength);
    DebugTrace(+0, Dbg, "BytesIndicated      %x\n", BytesIndicated);
    DebugTrace(+0, Dbg, "BytesAvailable      %x\n", BytesAvailable);
    DebugTrace(+0, Dbg, "BytesTaken          %x\n", *BytesTaken);

    //
    //  SourceAddress is the address of the server or the bridge tbat sent
    //  the packet.
    //

#if NWDBG
    dump( Dbg, SourceAddress, SourceAddressLength );
    dump( Dbg, Tsdu, BytesIndicated );
#endif

    if (pNpScb->NodeTypeCode != NW_NTC_SCBNP ) {
        DebugTrace(+0, Dbg, "nwrdr: Invalid SendDatagram Indication %x\n", pNpScb );
#if DBG
        DbgBreakPoint();
#endif
        return STATUS_DATA_NOT_ACCEPTED;
    }

    if (RspData[1] == BROADCAST_MESSAGE_WAITING ) {

        //
        //  Broadcast message waiting.  If the scavenger
        //  isn't running, it's safe to go get it.
        //

       KeAcquireSpinLockAtDpcLevel( &NwScavengerSpinLock );

       if ( WorkerRunning ) {

           //
           // The scavenger is running, we can't pick up this
           // message until the scavenger is done!
           //

           DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Delaying get message for scavenger.\n", 0 );
           KeReleaseSpinLockFromDpcLevel( &NwScavengerSpinLock );

       } else {

           //
           // Make sure the scavenger doesn't start.
           //

           WorkerRunning = TRUE;
           KeReleaseSpinLockFromDpcLevel( &NwScavengerSpinLock );

           listEntry = ExInterlockedRemoveHeadList(
                           &NwGetMessageList,
                           &NwMessageSpinLock );

           if ( listEntry != NULL ) {

               pIrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );

               //
               //  Clear the cancel routine for this IRP.
               //

               Irp = pIrpContext->pOriginalIrp;

               IoAcquireCancelSpinLock( &Irp->CancelIrql );
               IoSetCancelRoutine( Irp, NULL );
               IoReleaseCancelSpinLock( Irp->CancelIrql );

               pIrpContext->PostProcessRoutine = FspGetMessage;
               pIrpContext->pNpScb = pNpScb;
               pIrpContext->pScb = pNpScb->pScb;

               NwPostToFsp( pIrpContext, TRUE );

           } else {

               WorkerRunning = FALSE;
           }
       }

    }

    DebugTrace(-1, Dbg, "                       %lx\n", STATUS_DATA_NOT_ACCEPTED);
    return STATUS_DATA_NOT_ACCEPTED;

    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( BytesTaken );
    UNREFERENCED_PARAMETER( Tsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( Options );
}


NTSTATUS
FspGetMessage(
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine continues process a broadcast message waiting message.

Arguments:

    pIrpContext -  A pointer to the IRP context information for the
        request in progress.

Return Value:

    The status of the operation.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PNONPAGED_SCB pNpScb;
    BOOLEAN bFound = FALSE;

    UNICODE_STRING Message;
    NTSTATUS Status;
    PNWR_SERVER_MESSAGE ServerMessage;
    PUNICODE_STRING ServerName;
    ULONG MessageLength;
    short int i;

    PAGED_CODE();

    NwReferenceUnlockableCodeSection();

    //
    //  The Scb may be being deleted so carefully walk the list and reference it if
    //  we find it.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    ScbQueueEntry = ScbQueue.Flink;

    while ( ScbQueueEntry != &ScbQueue ) {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        if (pNpScb == IrpContext->pNpScb ) {

            NwReferenceScb( pNpScb );

            bFound = TRUE;
            break;
        }

        ScbQueueEntry = ScbQueueEntry->Flink;
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    if (!bFound) {

        //
        //  Server deleted. Its easiest to continue processing the IrpContext
        //  with an error than try to recover it and return it to the queue.
        //

        Status = STATUS_UNSUCCESSFUL;
        NwDereferenceUnlockableCodeSection();

        //
        // Re-enable the scavenger before we return!
        //

        WorkerRunning = FALSE;

        return( Status );
    }

    //
    //  If the message is telling us that the server is going down then don't
    //  work too hard trying to get the message. The server is persistent with
    //  respect to other messages so we'll come through here again when the
    //  problem has been resolved.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_REROUTE_ATTEMPTED );

    if ( UP_LEVEL_SERVER( IrpContext->pScb ) ) {
        Status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "S",
                     NCP_MESSAGE_FUNCTION, NCP_GET_ENTIRE_MESSAGE );
    } else {
        Status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "S",
                     NCP_MESSAGE_FUNCTION, NCP_GET_MESSAGE );
    }

    if ( !NT_SUCCESS( Status ) ) {
        NwDereferenceScb( pNpScb );
        NwDereferenceUnlockableCodeSection();

        //
        // Re-enable the scavenger before we return!
        //

        WorkerRunning = FALSE;

        return( Status );
    }

    ServerMessage = (PNWR_SERVER_MESSAGE)IrpContext->Specific.FileSystemControl.Buffer;
    MessageLength = IrpContext->Specific.FileSystemControl.Length;

    ServerName = &IrpContext->pNpScb->ServerName;
    if ( ServerName->Length + FIELD_OFFSET( NWR_SERVER_MESSAGE, Server ) + sizeof(WCHAR) > MessageLength ) {

        Status = STATUS_BUFFER_TOO_SMALL;
        NwDereferenceScb( pNpScb );
        NwDereferenceUnlockableCodeSection();

        //
        // Re-enable the scavenger before we return!
        //

        WorkerRunning = FALSE;

        return( Status );

    } else {
        // --- Multi-user -------------
        //  Need Login ID to send messages
        //
        ServerMessage->LogonId = *((PLUID)&IrpContext->pScb->UserUid);

        //
        //  Copy the server name to the output buffer.
        //

        ServerMessage->MessageOffset =
            ServerName->Length +
            FIELD_OFFSET( NWR_SERVER_MESSAGE, Server ) +
            sizeof(WCHAR);

        RtlMoveMemory(
            ServerMessage->Server,
            ServerName->Buffer,
            ServerName->Length );

        ServerMessage->Server[ ServerName->Length / sizeof(WCHAR) ] = L'\0';
    }

    //
    //  Copy the message to the user's buffer.
    //

    Message.Buffer = &ServerMessage->Server[ ServerName->Length / sizeof(WCHAR) ] + 1;
    Message.MaximumLength = (USHORT)( MessageLength - ( ServerName->Length + FIELD_OFFSET( NWR_SERVER_MESSAGE, Server ) + sizeof(WCHAR) ) );

    if ( NT_SUCCESS( Status) ) {
        Status = ParseResponse(
                     IrpContext,
                     IrpContext->rsp,
                     IrpContext->ResponseLength,
                     "NP",
                     &Message );
    }

    if ( !NT_SUCCESS( Status ) ) {
        NwDereferenceScb( pNpScb );
        NwDereferenceUnlockableCodeSection();

        //
        // Re-enable the scavenger before we return!
        //

        WorkerRunning = FALSE;

        return( Status );
    }

    //
    //  Strip the trailing spaces and append a NUL terminator to the message.
    //

    for ( i = Message.Length / sizeof(WCHAR) - 1; i >= 0 ; i-- ) {
        if ( Message.Buffer[ i ] != L' ') {
            Message.Length = (i + 1) * sizeof(WCHAR);
            break;
        }
    }

    if ( Message.Length > 0 ) {
        Message.Buffer[ Message.Length / sizeof(WCHAR) ] = L'\0';
    }

    IrpContext->pOriginalIrp->IoStatus.Information =
            ServerName->Length +
            FIELD_OFFSET( NWR_SERVER_MESSAGE, Server ) + sizeof(WCHAR) +
            Message.Length + sizeof(WCHAR);

    NwDereferenceScb( pNpScb );
    NwDereferenceUnlockableCodeSection();

    //
    // Re-enable the scavenger before we return!
    //

    WorkerRunning = FALSE;

    return( Status );
}


NTSTATUS
_cdecl
ExchangeWithWait(
    PIRP_CONTEXT    pIrpContext,
    PEX             pEx,
    char*           f,
    ...                         //  format specific parameters
    )
/*++

Routine Description:

    This routine sends a NCP packet and waits for the response.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    pEX, Context, f - See _Exchange

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    NTSTATUS Status;
    va_list Arguments;

    PAGED_CODE();

    //KeResetEvent( &pIrpContext->Event );

    va_start( Arguments, f );

    Status = FormatRequest( pIrpContext, pEx, f, Arguments );
    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    va_end( Arguments );

    Status = PrepareAndSendPacket( pIrpContext );
    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = KeWaitForSingleObject(
                 &pIrpContext->Event,
                 Executive,
                 KernelMode,
                 FALSE,
                 NULL
                 );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = pIrpContext->pOriginalIrp->IoStatus.Status;

    if ( NT_SUCCESS( Status ) &&
         pIrpContext->PacketType != SAP_BROADCAST ) {
        Status = NwErrorToNtStatus( pIrpContext->ResponseParameters.Error );
    }

    return( Status );
}

BOOLEAN
VerifyResponse(
    PIRP_CONTEXT pIrpContext,
    PVOID Response
    )
/*++

Routine Description:

    This routine verifies that a received response is the expected
    response for the current request.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    Response - A pointer to the buffer containing the response.

Return Value:

    TRUE - This is a valid response.
    FALSE - This is an invalid response.

--*/

{
    PNCP_RESPONSE pNcpResponse;
    PNONPAGED_SCB pNpScb;

    pNcpResponse = (PNCP_RESPONSE)Response;
    pNpScb = pIrpContext->pNpScb;

    if ( pNcpResponse->NcpHeader.ConnectionIdLow != pNpScb->ConnectionNo ) {
        DebugTrace(+0, Dbg, "VerifyResponse, bad connection number\n", 0);

        return( FALSE );
    }

    if ( pNcpResponse->NcpHeader.SequenceNumber != pNpScb->SequenceNo ) {
        DebugTrace(+1, Dbg, "VerifyResponse, bad sequence number %x\n", 0);
        DebugTrace(+0, Dbg, "  pNcpResponse->NcpHeader.SequenceNumber %x\n",
            pNcpResponse->NcpHeader.SequenceNumber);
        DebugTrace(-1, Dbg, "  pNpScb->SequenceNo %x\n", pNpScb->SequenceNo );

        return( FALSE );
    }

    return( TRUE );
}

VOID
ScheduleReconnectRetry(
    PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine schedules an a reconnect attempt, and then resubmits
    our request if the reconnect was successful.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

Return Value:

    None.

--*/
{
   PWORK_CONTEXT workContext;

    if (WorkerThreadRunning == TRUE) {

    //
    // Prepare the work context
    //

    workContext = AllocateWorkContext();

    if (workContext == NULL) {

       pIrpContext->pEx( pIrpContext, 0, NULL );
       return;
    }
    workContext->pIrpC = pIrpContext;
    workContext->NodeWorkCode = NWC_NWC_RECONNECT;

    //
    // and queue it.
    //
    DebugTrace( 0, Dbg, "Queueing reconnect work.\n", 0 );

    KeInsertQueue( &KernelQueue,
                   &workContext->Next
                   );

    } else {

       //
       // The worker thread is not running...
       //
       pIrpContext->pEx( pIrpContext, 0, NULL );
       return;
    }
 }


VOID
ReconnectRetry(
    IN PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine attempts to reconnect to a disconnected server.  If it
    is successful it resubmits an existing request.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

Return Value:

    None.

--*/
{
    PIRP_CONTEXT pNewIrpContext;
    PSCB pScb, pNewScb;
    PNONPAGED_SCB pNpScb;
    NTSTATUS Status;

    PAGED_CODE();

    pNpScb = pIrpContext->pNpScb;
    pScb = pNpScb->pScb;

    Stats.Reconnects++;

    if ( pScb == NULL ) {
        pScb = pNpScb->pScb;
        pIrpContext->pScb = pScb;
    }

    //
    //  Allocate a temporary IRP context to use to reconnect to the server
    //

    if ( !NwAllocateExtraIrpContext( &pNewIrpContext, pNpScb ) ) {
        pIrpContext->pEx( pIrpContext, 0, NULL );
        return;
    }

    pNewIrpContext->Specific.Create.UserUid = pScb->UserUid;
    pNewIrpContext->pNpScb = pNpScb;
    pNewIrpContext->pScb = pScb;

    //
    //  Reset the sequence numbers.
    //

    pNpScb->SequenceNo = 0;
    pNpScb->BurstSequenceNo = 0;
    pNpScb->BurstRequestNo = 0;

    //
    //  Now insert this new IrpContext to the head of the SCB queue for
    //  processing.  We can get away with this because we own the IRP context
    //  currently at the front of the queue.  With the RECONNECT_ATTEMPT
    //  flag set, ConnectScb() will not remove us from the head of the queue.
    //

    SetFlag( pNewIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );
    SetFlag( pNewIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT );

    ExInterlockedInsertHeadList(
        &pNpScb->Requests,
        &pNewIrpContext->NextRequest,
        &pNpScb->NpScbSpinLock );

    pNewScb = pNpScb->pScb;

    Status = ConnectScb( &pNewScb,
                         pNewIrpContext,
                         &pNpScb->ServerName,
                         NULL,
                         NULL,
                         NULL,
                         FALSE,
                         FALSE,
                         TRUE );

    if ( !NT_SUCCESS( Status ) ) {

        //
        //  Couldn't reconnect.  Free the extra IRP context, complete the
        //  original request with an error.
        //

        NwDequeueIrpContext( pNewIrpContext, FALSE );
        NwFreeExtraIrpContext( pNewIrpContext );
        pIrpContext->pEx( pIrpContext, 0, NULL );
        return;
    }

    ASSERT( pNewScb == pScb );

    //
    //  Try to reconnect the VCBs.
    //

    NwReopenVcbHandlesForScb( pNewIrpContext, pScb );

    //
    //  Dequeue and free the bonus IRP context.
    //

    NwDequeueIrpContext( pNewIrpContext, FALSE );
    NwFreeExtraIrpContext( pNewIrpContext );

    //
    //  Resubmit the original request, with a new sequence number.  Note that
    //  it's back at the front of the queue, but no longer reconnectable.
    //

    pIrpContext->req[2] = pNpScb->SequenceNo;
    pIrpContext->req[3] = pNpScb->ConnectionNo;
    pIrpContext->req[5] = pNpScb->ConnectionNoHigh;

    PreparePacket( pIrpContext, pIrpContext->pOriginalIrp, pIrpContext->TxMdl );
    SendNow( pIrpContext );

    return;
}


NTSTATUS
NewRouteRetry(
    IN PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine attempts to establish a new route to a non-responding server.
    If it is successful it resubmits the request in progress.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PNONPAGED_SCB pNpScb = pIrpContext->pNpScb;
    LARGE_INTEGER CurrentTime = {0, 0};

    PAGED_CODE();

    //
    //  Don't bother to re-rip if we are shutting down.
    //

    if ( NwRcb.State != RCB_STATE_SHUTDOWN ) {
        Status = GetNewRoute( pIrpContext );
    } else {
        Status = STATUS_REMOTE_NOT_LISTENING;
    }

    //
    //  Ask the transport to establish a new route to the server.
    //

    if ( !NT_SUCCESS( Status ) ) {

        //
        //  Attempt to get new route failed, fail the current request.
        //

        pIrpContext->ResponseParameters.Error = ERROR_UNEXP_NET_ERR;
        pIrpContext->pEx( pIrpContext, 0, NULL );

        if ( pNpScb != &NwPermanentNpScb ) {


            KeQuerySystemTime( &CurrentTime );

            if ( CanLogTimeOutEvent( pNpScb->NwNextEventTime,
                                    CurrentTime
                                    )) {

                LPWSTR serverName = pNpScb->ServerName.Buffer;
                if (serverName == NULL) {
                    serverName = L"";
                }

                Error(
                    EVENT_NWRDR_TIMEOUT,
                    STATUS_UNEXPECTED_NETWORK_ERROR,
                    NULL,
                    0,
                    1,
                    serverName);

                //
                //  Set the LastEventTime to the CurrentTime
                //

                UpdateNextEventTime(
                        pNpScb->NwNextEventTime,
                        CurrentTime,
                        TimeOutEventInterval
                        );

            }


            pNpScb->State = SCB_STATE_ATTACHING;
        }

    } else {

        //
        //  Got a new route, resubmit the request.  Allow retries
        //  with the new route.
        //

        pIrpContext->pNpScb->RetryCount = DefaultRetryCount / 2;

        PreparePacket( pIrpContext, pIrpContext->pOriginalIrp, pIrpContext->TxMdl );
        SendNow( pIrpContext );
    }

    //
    //  Return STATUS_PENDING so that the FSP dispatcher doesn't complete
    //  this request.
    //

    return( STATUS_PENDING );
}


NTSTATUS
NewRouteBurstRetry(
    IN PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine attempts to establish a new route to a non-responding server.
    If it is successful it resubmits the request in progress.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PIRP_CONTEXT pNewIrpContext;
    PNONPAGED_SCB pNpScb = pIrpContext->pNpScb;
    BOOLEAN LIPNegotiated ;
    LARGE_INTEGER CurrentTime = {0, 0};

    PAGED_CODE();

    //
    //  Don't bother to re-rip if we are shutting down.
    //

    if ( NwRcb.State == RCB_STATE_SHUTDOWN ) {
        return( STATUS_REMOTE_NOT_LISTENING );
    }

    //
    //  Ask the transport to establish a new route to the server.
    //

    Status = GetNewRoute( pIrpContext );

    if ( NT_SUCCESS( Status ) ) {

        //
        //  If this is a burst write, we must first complete the write
        //  request (there is no way to tell the server to abandon the write).
        //
        //  Set packet size down to 512 to guarantee that the packets will be
        //  forwarded, and resend the burst data.  Queue the new IRP context
        //  behind the burst write, so that we can establish a new burst
        //  connection.
        //
        //  Note that ResubmitBurstWrite may complete the request and
        //  free the IrpContext.
        //

        pNpScb->RetryCount = DefaultRetryCount / 2;

        if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_BURST_WRITE ) ) {

            Status = ResubmitBurstWrite( pIrpContext );

        } else {

            //
            //  Allocate a temporary IRP context to use to reconnect to the server
            //

            if ( NT_SUCCESS( Status ) ) {
                if ( !NwAllocateExtraIrpContext( &pNewIrpContext, pNpScb ) ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    pNewIrpContext->Specific.Create.UserUid = pIrpContext->Specific.Create.UserUid;

                    SetFlag( pNewIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );
                    SetFlag( pNewIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT );

                    //
                    // Since we're doing this from a worker thread, we can't
                    // let the dpc timer schedule _another_ worker thread
                    // request if this also times out or we may deadlock
                    // the delayed work queue.
                    //

                    SetFlag( pNewIrpContext->Flags, IRP_FLAG_REROUTE_ATTEMPTED );

                    pNewIrpContext->pNpScb = pNpScb;

                }
            }

            if ( NT_SUCCESS( Status ) ) {

                //
                //  Insert this new IrpContext to the head of
                //  the SCB queue for  processing.  We can get away with this
                //  because we own the IRP context currently at the front of
                //  the queue.
                //

                ExInterlockedInsertHeadList(
                    &pNpScb->Requests,
                    &pNewIrpContext->NextRequest,
                    &pNpScb->NpScbSpinLock );

                //
                //  Now prepare to resend the burst read.
                //

                PreparePacket( pIrpContext, pIrpContext->pOriginalIrp, pIrpContext->TxMdl );

                //
                //  Renegotiate the burst connection, this will automatically re-sync
                //  the burst connection.
                //
                //  TRACKING: We lose sizeof( NCP_BURST_WRITE_REQUEST ) each time
                //  we do this right now.
                //

                NegotiateBurstMode( pNewIrpContext, pNpScb, &LIPNegotiated );

                //
                //  Reset the sequence numbers.
                //

                pNpScb->BurstSequenceNo = 0;
                pNpScb->BurstRequestNo = 0;

                //
                //  Dequeue and free the bonus IRP context.
                //

                ASSERT( pNpScb->Requests.Flink == &pNewIrpContext->NextRequest );

                ExInterlockedRemoveHeadList(
                    &pNpScb->Requests,
                    &pNpScb->NpScbSpinLock );

                ClearFlag( pNewIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

                NwFreeExtraIrpContext( pNewIrpContext );

                //
                //  Got a new route, resubmit the request
                //

                Status = ResubmitBurstRead( pIrpContext );
            }
        }
    }

    if ( !NT_SUCCESS( Status ) ) {

        //
        //  Attempt to get new route failed, fail the current request.
        //

        pIrpContext->ResponseParameters.Error = ERROR_UNEXP_NET_ERR;
        pIrpContext->pEx( pIrpContext, 0, NULL );

        if ( pNpScb != &NwPermanentNpScb ) {


            KeQuerySystemTime( &CurrentTime );

            if ( CanLogTimeOutEvent( pNpScb->NwNextEventTime,
                                    CurrentTime
                                    )) {
                Error(
                    EVENT_NWRDR_TIMEOUT,
                    STATUS_UNEXPECTED_NETWORK_ERROR,
                    NULL,
                    0,
                    1,
                    pNpScb->ServerName.Buffer );

                //
                //  Set the LastEventTime to the CurrentTime
                //

                UpdateNextEventTime(
                        pNpScb->NwNextEventTime,
                        CurrentTime,
                        TimeOutEventInterval
                        );

            }

        }
    }

    //
    //  Return STATUS_PENDING so that the FSP dispatcher doesn't complete
    //  this request.
    //

    return( STATUS_PENDING );
}

NTSTATUS
FspProcessServerDown(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine process a response with the server shutdown bit set.
    It close all open handles for the server, and puts the server in
    the attaching state.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

Return Value:

    STATUS_PENDING.

--*/
{
    KIRQL OldIrql;

    PNONPAGED_SCB pNpScb = IrpContext->pNpScb;

    //
    //  Avoid the Scb from disappearing under us.
    //

    NwReferenceScb( pNpScb );

    //
    //  Move the IrpContext from the front of the queue just in-case it
    //  owns the Rcb.
    //

    KeAcquireSpinLock( &IrpContext->pNpScb->NpScbSpinLock, &OldIrql );

    if ( IrpContext->pNpScb->Sending ) {

        //
        //  Let send completion call the pEx routine
        //

        IrpContext->pNpScb->Received = TRUE;
        KeReleaseSpinLock( &IrpContext->pNpScb->NpScbSpinLock, OldIrql );

    } else {

        IrpContext->pNpScb->Receiving = FALSE;
        IrpContext->pNpScb->Received  = FALSE;
        KeReleaseSpinLock( &IrpContext->pNpScb->NpScbSpinLock, OldIrql );

        //
        //  Now call the callback routine.
        //

        IrpContext->pEx(
            IrpContext,
            IrpContext->ResponseLength,
            IrpContext->rsp );

    }

    //
    //  Close all active handles for this server.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    NwInvalidateAllHandlesForScb( pNpScb->pScb );
    NwReleaseRcb( &NwRcb );

    NwDereferenceScb( pNpScb );

    //
    //  Return STATUS_PENDING so that the FSP process doesn't complete
    //  this request.
    //

    return( STATUS_PENDING );
}


VOID
NwProcessSendBurstFailure(
    PNONPAGED_SCB NpScb,
    USHORT MissingFragmentCount
    )
/*++

Routine Description:

    This routine adjust burst parameters after an unsuccessful burst operation.

Arguments:

    NpScb - A pointer to the SCB that has experienced a burst failure.

    MissingFragmentCount - A measure of how many chunks were lost.

Return Value:

    None.

--*/
{
    LONG temp;

    DebugTrace( 0, DEBUG_TRACE_LIP, "Burst failure, NpScb = %X\n", NpScb );

    if ( NpScb->NwSendDelay != NpScb->CurrentBurstDelay ) {

        //
        //  This burst has already failed
        //

        return;
    }

    NpScb->NwBadSendDelay = NpScb->NwSendDelay;

    //
    //  Add to the send delay.  Never let it go above 5000ms.
    //

    temp = NpScb->NwGoodSendDelay - NpScb->NwBadSendDelay;

    if (temp >= 0) {
        NpScb->NwSendDelay += temp + 2;
    } else {
        NpScb->NwSendDelay += -temp + 2;
    }

    if ( NpScb->NwSendDelay > NpScb->NwMaxSendDelay ) {

        NpScb->NwSendDelay = NpScb->NwMaxSendDelay;

        //
        //  If we have slowed down a lot then it might be that the server or a
        //  bridge only has a small buffer on its NIC. If this is the case then
        //  rather than sending a big burst with long even gaps between the
        //  packets, we should try to send a burst the size of the buffer.
        //

        if ( !DontShrink ) {

            if (((NpScb->MaxSendSize - 1) / NpScb->MaxPacketSize) > 2 ) {

                //  Round down to the next packet

                NpScb->MaxSendSize = ((NpScb->MaxSendSize - 1) / NpScb->MaxPacketSize) * NpScb->MaxPacketSize;

                //
                //  Adjust SendDelay below threshold to see if things improve before
                //  we shrink the size again.
                //

                NpScb->NwSendDelay = NpScb->NwGoodSendDelay = NpScb->NwBadSendDelay = MinSendDelay;

            } else {

                //
                //  We reached the minimum size with the maximum delay. Give up on burst.
                //

                NpScb->SendBurstModeEnabled = FALSE;

            }

        }
    }

    NpScb->NtSendDelay.QuadPart = NpScb->NwSendDelay * -1000 ;

    DebugTrace( 0, DEBUG_TRACE_LIP, "New Send Delay = %d\n", NpScb->NwSendDelay );

    NpScb->SendBurstSuccessCount = 0;

}


VOID
NwProcessReceiveBurstFailure(
    PNONPAGED_SCB NpScb,
    USHORT MissingFragmentCount
    )
/*++

Routine Description:

    This routine adjust burst parameters after an unsuccessful burst operation.

Arguments:

    NpScb - A pointer to the SCB that has experienced a burst failure.

    MissingFragmentCount - A measure of how many chunks were lost.

Return Value:

    None.

--*/
{
    LONG temp;

    DebugTrace(+0, DEBUG_TRACE_LIP, "Burst failure, NpScb = %X\n", NpScb );

    if ( NpScb->NwReceiveDelay != NpScb->CurrentBurstDelay ) {

        //
        //  This burst has already failed
        //

        return;
    }

    NpScb->NwBadReceiveDelay = NpScb->NwReceiveDelay;

    //
    //  Add to the Receive delay.  Never let it go above 5000ms.
    //

    temp = NpScb->NwGoodReceiveDelay - NpScb->NwBadReceiveDelay;

    if (temp >= 0) {
        NpScb->NwReceiveDelay += temp + 2;
    } else {
        NpScb->NwReceiveDelay += -temp + 2;
    }


    if ( NpScb->NwReceiveDelay > NpScb->NwMaxReceiveDelay ) {

        NpScb->NwReceiveDelay = MaxReceiveDelay;

        //
        //  If we have slowed down a lot then it might be that the server or a
        //  bridge only has a small buffer on its NIC. If this is the case then
        //  rather than Receiveing a big burst with long even gaps between the
        //  packets, we should try to Receive a burst the size of the buffer.
        //

        if ( !DontShrink ) {

            if (((NpScb->MaxReceiveSize - 1) / NpScb->MaxPacketSize) > 2 ) {

                //  Round down to the next packet

                NpScb->MaxReceiveSize = ((NpScb->MaxReceiveSize - 1) / NpScb->MaxPacketSize) * NpScb->MaxPacketSize;

                //
                //  Adjust ReceiveDelay below threshold to see if things improve before
                //  we shrink the size again.
                //

                NpScb->NwReceiveDelay = NpScb->NwGoodReceiveDelay = NpScb->NwBadReceiveDelay = MinReceiveDelay;

            } else {

                //
                //  We reached the minimum size with the maximum delay. Give up on burst.
                //

                NpScb->ReceiveBurstModeEnabled = FALSE;

            }

        }

    }

    NpScb->ReceiveBurstSuccessCount = 0;

    DebugTrace( 0, DEBUG_TRACE_LIP, "New Receive Delay = %d\n", NpScb->NwReceiveDelay );
}


VOID
NwProcessSendBurstSuccess(
    PNONPAGED_SCB NpScb
    )
/*++

Routine Description:

    This routine adjust burst parameters after a successful burst operation.

Arguments:

    NpScb - A pointer to the SCB that has completed the burst.

Return Value:

    None.

--*/
{
    LONG temp;

    DebugTrace( 0, DEBUG_TRACE_LIP, "Successful burst, NpScb = %X\n", NpScb );

    if ( NpScb->NwSendDelay != NpScb->CurrentBurstDelay ) {

        //
        //  This burst has already failed
        //

        return;
    }

    if ( NpScb->SendBurstSuccessCount > BurstSuccessCount ) {

        if (NpScb->NwSendDelay != MinSendDelay ) {

            NpScb->NwGoodSendDelay = NpScb->NwSendDelay;

            temp = NpScb->NwGoodSendDelay - NpScb->NwBadSendDelay;

            if (temp >= 0) {
                NpScb->NwSendDelay -= 1 + temp;
            } else {
                NpScb->NwSendDelay -= 1 - temp;
            }

            if (NpScb->NwSendDelay < MinSendDelay ) {

                NpScb->NwSendDelay = MinSendDelay;

            }

            NpScb->NtSendDelay.QuadPart = NpScb->NwSendDelay * -1000;

            DebugTrace( 0, DEBUG_TRACE_LIP, "New Send Delay = %d\n", NpScb->NwSendDelay );

            //
            //  Start monitoring success at the new rate.
            //

            NpScb->SendBurstSuccessCount = 0;

        } else if ( NpScb->SendBurstSuccessCount > BurstSuccessCount2 ) {

            //
            //  We may have had a really bad patch causing BadSendDelay to be very big.
            //  If we leave it at its current value then at the first sign of trouble
            //  we will make SendDelay very big
            //

            NpScb->NwGoodSendDelay = NpScb->NwBadSendDelay =  NpScb->NwSendDelay;

            //
            //  Is it time to increase the number of packets in the burst?
            //  AllowGrowth == 0 to be the same as the VLM client.
            //

            if (( AllowGrowth ) &&
                ( NpScb->NwSendDelay <= MinSendDelay ) &&
                ( NpScb->MaxSendSize < NwMaxSendSize)) {

                NpScb->MaxSendSize += NpScb->MaxPacketSize;


                if ( NpScb->MaxSendSize > NwMaxSendSize) {

                    NpScb->MaxSendSize = NwMaxSendSize;

                }
            }

            NpScb->SendBurstSuccessCount = 0;

        } else {

            NpScb->SendBurstSuccessCount++;

        }


    } else {

        NpScb->SendBurstSuccessCount++;

    }

}


VOID
NwProcessReceiveBurstSuccess(
    PNONPAGED_SCB NpScb
    )
/*++

Routine Description:

    This routine adjust burst parameters after a successful burst operation.

Arguments:

    NpScb - A pointer to the SCB that has completed the burst.

Return Value:

    None.

--*/
{
    LONG temp;

    DebugTrace( 0, DEBUG_TRACE_LIP, "Successful burst, NpScb = %X\n", NpScb );

    if ( NpScb->NwReceiveDelay != NpScb->CurrentBurstDelay ) {

        //
        //  This burst has already failed
        //

        return;
    }

    if ( NpScb->ReceiveBurstSuccessCount > BurstSuccessCount ) {

        //
        //  Once the vlm client reaches the Maximum delay it does not
        //  shrink again.
        //

        if ( NpScb->NwReceiveDelay != MinReceiveDelay ) {

            NpScb->NwGoodReceiveDelay = NpScb->NwReceiveDelay;

            temp = NpScb->NwGoodReceiveDelay - NpScb->NwBadReceiveDelay;

            if (temp >= 0) {
                NpScb->NwReceiveDelay -= 1 + temp;
            } else {
                NpScb->NwReceiveDelay -= 1 - temp;
            }

            DebugTrace( 0, DEBUG_TRACE_LIP, "New Receive Delay = %d\n", NpScb->NwReceiveDelay );


            if (NpScb->NwReceiveDelay < MinReceiveDelay ) {
                NpScb->NwReceiveDelay = MinReceiveDelay;

            }

            //
            //  Start monitoring success at the new rate.
            //

            NpScb->ReceiveBurstSuccessCount = 0;

        } else if ( NpScb->ReceiveBurstSuccessCount > BurstSuccessCount2 ) {

            //
            //  We may have had a really bad patch causing BadReceiveDelay to be very big.
            //  If we leave it at its current value then at the first sign of trouble
            //  we will make ReceiveDelay very big
            //

            NpScb->NwGoodReceiveDelay = NpScb->NwBadReceiveDelay = NpScb->NwReceiveDelay;


            //
            //  Is it time to increase the number of packets in the burst?
            //

            if (( AllowGrowth ) &&
                ( NpScb->NwReceiveDelay <= MinReceiveDelay ) &&
                ( NpScb->MaxReceiveSize < NwMaxReceiveSize)) {

                NpScb->MaxReceiveSize += NpScb->MaxPacketSize;


                if ( NpScb->MaxReceiveSize > NwMaxReceiveSize) {

                    NpScb->MaxReceiveSize = NwMaxReceiveSize;

                }
            }

            NpScb->ReceiveBurstSuccessCount = 0;

        } else {

            NpScb->ReceiveBurstSuccessCount++;

        }

    } else {

        NpScb->ReceiveBurstSuccessCount++;

    }

}


VOID
NwProcessPositiveAck(
    PNONPAGED_SCB NpScb
    )
/*++

Routine Description:

    This routine processes a positive acknowledgement.

Arguments:

    NpScb - A pointer to the SCB that has experienced a burst failure.

Return Value:

    None.

--*/
{
    DebugTrace( 0, Dbg, "Positive ACK, NpScb = %X\n", NpScb );

    //
    // tommye MS 90541 / MCS 277
    //
    // Theory has it that we end up here about every half second, 
    // but I don't think we really know how long this packet has been
    // outstanding.  So, we'll just count this half-second event towards
    // our timeout.  Once this exceeds NwAbsoluteTotalWaitTime, then we
    // won't reset the RetryCount and the DPC should handle it from there.
    //

    NpScb->TotalWaitTime++;

    //
    //  If we have not waited longer than the absolute total, keep waiting.
    //  If we have waited too long, let ourselves timeout.
    //
    //  If NwAbsoluteTotalWaitTime is 0, then we are prepared to wait forever.
    //

    if ( NpScb->TotalWaitTime < NwAbsoluteTotalWaitTime ||
         NwAbsoluteTotalWaitTime == 0) {

        NpScb->RetryCount = DefaultRetryCount;

    } else {
        DebugTrace( 0, Dbg, "Request exceeds absolute total wait time\n", 0 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\fileinfo.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the get / set file information routines for
    Netware Redirector.

Author:

     Manny Weiser (mannyw)    4-Mar-1993

Revision History:

--*/

#include "procs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  local procedure prototypes
//

NTSTATUS
NwCommonQueryInformation (
    IN PIRP_CONTEXT pIrpContext
    );

NTSTATUS
NwCommonSetInformation (
    IN PIRP_CONTEXT pIrpContet
    );

NTSTATUS
NwQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
NwQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_STANDARD_INFORMATION Buffer
    );

NTSTATUS
NwQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_INTERNAL_INFORMATION Buffer
    );

NTSTATUS
NwQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_EA_INFORMATION Buffer
    );

NTSTATUS
NwQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NwQueryAltNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NwQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_POSITION_INFORMATION Buffer
    );

NTSTATUS
NwSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
NwSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_DISPOSITION_INFORMATION Buffer
    );

NTSTATUS
NwSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_RENAME_INFORMATION Buffer
    );

NTSTATUS
NwSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_POSITION_INFORMATION Buffer
    );

NTSTATUS
NwSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_ALLOCATION_INFORMATION Buffer
    );

NTSTATUS
NwSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_END_OF_FILE_INFORMATION Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdQueryInformation )
#pragma alloc_text( PAGE, NwFsdSetInformation )
#pragma alloc_text( PAGE, NwCommonQueryInformation )
#pragma alloc_text( PAGE, NwCommonSetInformation )
#pragma alloc_text( PAGE, NwQueryStandardInfo )
#pragma alloc_text( PAGE, NwQueryInternalInfo )
#pragma alloc_text( PAGE, NwQueryEaInfo )
#pragma alloc_text( PAGE, NwQueryNameInfo )
#pragma alloc_text( PAGE, NwQueryPositionInfo )
#pragma alloc_text( PAGE, NwSetBasicInfo )
#pragma alloc_text( PAGE, NwSetDispositionInfo )
#pragma alloc_text( PAGE, NwDeleteFile )
#pragma alloc_text( PAGE, NwSetRenameInfo )
#pragma alloc_text( PAGE, NwSetPositionInfo )
#pragma alloc_text( PAGE, NwSetAllocationInfo )
#pragma alloc_text( PAGE, NwSetEndOfFileInfo )
#pragma alloc_text( PAGE, OccurenceCount )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, NwQueryBasicInfo )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdQueryInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryInformationFile API
    calls.

Arguments:

    DeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;
    PIRP_CONTEXT pIrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdQueryInformation\n", 0);

    //
    // Call the common query information routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonQueryInformation( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
        }
    }

    if ( pIrpContext ) {

        if ( status != STATUS_PENDING ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdQueryInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
NwFsdSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD part of the NtSetInformationFile API
    calls.

Arguments:

    DeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS status;
    PIRP_CONTEXT pIrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdSetInformation\n", 0);

    //
    //  Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonSetInformation( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
        }

    }

    if ( pIrpContext ) {

        if ( status != STATUS_PENDING ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdSetInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
NwCommonQueryInformation (
    IN PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This is the common routine for querying information on a file.

Arguments:

    pIrpContext - Supplies Irp context information.

Return Value:

    NTSTATUS - the return status for the operation.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    FILE_INFORMATION_CLASS fileInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;

    PVOID fsContext, fsContext2;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    Irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", irpSp->Parameters.QueryFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG_PTR)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "NwCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    //  Make sure that this the user is querying an ICB.
    //

    switch (nodeTypeCode) {

    case NW_NTC_ICB:

        icb = (PICB)fsContext2;
        break;

    default:           // This is an illegal file object to query

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);

        DebugTrace(-1, Dbg, "NwCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    pIrpContext->Icb = icb;

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.QueryFile.Length;
    fileInformationClass = irpSp->Parameters.QueryFile.FileInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Now acquire shared access to the FCB
    //

    fcb = icb->SuperType.Fcb;

    try {

        NwVerifyIcbSpecial( icb );

        //
        // Based on the information class we'll do different actions.  Each
        // of the procedure that we're calling fill up as much of the
        // buffer as possible and return the remaining length, and status
        // This is done so that we can use them to build up the
        // FileAllInformation request.  These procedures do not complete the
        // IRP, instead this procedure must complete the IRP.
        //

        status = STATUS_SUCCESS;

        switch (fileInformationClass) {

        case FileAllInformation:

            AllInfo = buffer;

            //
            //  First call all the Query Info handlers we can call
            //  synchronously.
            //

            NwQueryInternalInfo( pIrpContext, icb, &AllInfo->InternalInformation );
            NwQueryEaInfo( pIrpContext, &AllInfo->EaInformation );
            NwQueryPositionInfo( pIrpContext, icb, &AllInfo->PositionInformation );

            length -= FIELD_OFFSET( FILE_ALL_INFORMATION, NameInformation );

            status = NwQueryNameInfo( pIrpContext, icb, &AllInfo->NameInformation, &length );

            if ( !NT_ERROR( status ) ) {
                status = NwQueryStandardInfo( pIrpContext, icb, &AllInfo->StandardInformation );
            }

            if ( !NT_ERROR( status ) ) {
                status = NwQueryBasicInfo( pIrpContext, icb, &AllInfo->BasicInformation );
            }

            break;


        case FileBasicInformation:

            length -= sizeof( FILE_BASIC_INFORMATION );
            status = NwQueryBasicInfo( pIrpContext, icb, buffer );

            break;

        case FileStandardInformation:

            //
            //  We will handle this call for information asynchronously.
            //  The callback routine will fill in the missing data, and
            //  complete the IRP.
            //
            //  Remember the buffer length, and status to return.
            //

            length -= sizeof( FILE_STANDARD_INFORMATION );
            status = NwQueryStandardInfo( pIrpContext, icb, buffer );
            break;

        case FileInternalInformation:

            status = NwQueryInternalInfo( pIrpContext, icb, buffer );
            length -= sizeof( FILE_INTERNAL_INFORMATION );
            break;

        case FileEaInformation:

            status = NwQueryEaInfo( pIrpContext, buffer );
            length -= sizeof( FILE_EA_INFORMATION );
            break;

        case FilePositionInformation:

            status = NwQueryPositionInfo( pIrpContext, icb, buffer );
            length -= sizeof( FILE_POSITION_INFORMATION );
            break;

        case FileNameInformation:

            status = NwQueryNameInfo( pIrpContext, icb, buffer, &length );
            break;

        case FileAlternateNameInformation:

            if (!DisableAltFileName) {
                status = NwQueryAltNameInfo( pIrpContext, icb, buffer, &length);
                break;
            }

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Set the information field to the number of bytes actually
        // filled in and then complete the request.  (This is
        // irrelavent if the Query worker function returned
        // STATUS_PENDING).
        //

        if ( status != STATUS_PENDING ) {
            Irp->IoStatus.Information =
                irpSp->Parameters.QueryFile.Length - length;
        }

    } finally {

        DebugTrace(-1, Dbg, "NwCommonQueryInformation -> %08lx\n", status );
    }

    return status;
}


NTSTATUS
NwCommonSetInformation (
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This is the common routine for setting information on a file.

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    FILE_INFORMATION_CLASS fileInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;
    PVOID fsContext;

    //
    // Get the current Irp stack location.
    //

    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    DebugTrace(+1, Dbg, "NwCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG_PTR)irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.SetFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", irpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG_PTR)irp->AssociatedIrp.SystemBuffer);

    //
    // Get a pointer to the FCB and ensure that this is a server side
    // handler to a file.
    //

    if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            (PVOID *)&icb )) == NTC_UNDEFINED ) {

        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "NwCommonSetInformation -> %08lx\n", status );
        return status;
    }

    //
    //  Make sure that this the user is querying an ICB.
    //

    switch (nodeTypeCode) {

    case NW_NTC_ICB:

        fcb = icb->SuperType.Fcb;
        break;

    default:           // This is an illegal file object to query

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);

        DebugTrace(-1, Dbg, "NwCommonSetInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    IrpContext->Icb = icb;

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.SetFile.Length;
    fileInformationClass = irpSp->Parameters.SetFile.FileInformationClass;
    buffer = irp->AssociatedIrp.SystemBuffer;

    try {

        NwVerifyIcb( icb );

        //
        // Based on the information class we'll do different actions. Each
        // procedure that we're calling will complete the request.
        //

        switch (fileInformationClass) {

        case FileBasicInformation:

            status = NwSetBasicInfo( IrpContext, icb, buffer );
            break;

        case FileDispositionInformation:

            status = NwSetDispositionInfo( IrpContext, icb, buffer );
            break;

        case FileRenameInformation:

            status = NwSetRenameInfo( IrpContext, icb, buffer );
            break;

        case FilePositionInformation:

            status = NwSetPositionInfo( IrpContext, icb, buffer );
            break;

        case FileLinkInformation:

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case FileAllocationInformation:

            status = NwSetAllocationInfo( IrpContext, icb, buffer );
            break;

        case FileEndOfFileInformation:

            status = NwSetEndOfFileInfo( IrpContext, icb, buffer );
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }

    } finally {

        DebugTrace(-1, Dbg, "NwCommonSetInformation -> %08lx\n", status);
    }


    return status;
}


NTSTATUS
NwQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    OUT PFILE_BASIC_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine performs the query basic information operation.
    This routine cannot be paged, it is called from QueryStandardInfoCallback.

Arguments:

    Icb - Supplies a pointer the ICB for the file being querying.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PFCB Fcb;
    NTSTATUS Status;
    ULONG Attributes;
    USHORT CreationDate;
    USHORT CreationTime = DEFAULT_TIME;
    USHORT LastAccessDate;
    USHORT LastModifiedDate;
    USHORT LastModifiedTime;
    BOOLEAN FirstTime = TRUE;

    DebugTrace(0, Dbg, "QueryBasicInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );
    Fcb = Icb->SuperType.Fcb;

    //
    //  It is ok to attempt a reconnect if this request fails with a
    //  connection error.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    NwAcquireSharedFcb( Fcb->NonPagedFcb, TRUE );

    //
    // If we already know the file attributes, simply return them.
    //

    if ( FlagOn( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID ) ) {

        //
        // Set the various fields in the record
        //

        Buffer->CreationTime = NwDateTimeToNtTime(
                                   Fcb->CreationDate,
                                   Fcb->CreationTime
                                   );

        Buffer->LastAccessTime = NwDateTimeToNtTime(
                                     Fcb->LastAccessDate,
                                     DEFAULT_TIME
                                     );

        Buffer->LastWriteTime = NwDateTimeToNtTime(
                                    Fcb->LastModifiedDate,
                                    Fcb->LastModifiedTime
                                    );

        Buffer->ChangeTime.QuadPart = 0;

        DebugTrace(0, Dbg, "QueryBasic known %wZ\n", &Fcb->RelativeFileName);
        DebugTrace(0, Dbg, "LastModifiedDate %x\n", Fcb->LastModifiedDate);
        DebugTrace(0, Dbg, "LastModifiedTime %x\n", Fcb->LastModifiedTime);
        DebugTrace(0, Dbg, "CreationDate     %x\n", Fcb->CreationDate );
        DebugTrace(0, Dbg, "CreationTime     %x\n", Fcb->CreationTime );
        DebugTrace(0, Dbg, "LastAccessDate   %x\n", Fcb->LastAccessDate );

        Buffer->FileAttributes = Fcb->NonPagedFcb->Attributes;

        if ( Buffer->FileAttributes == 0 ) {
            Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        NwReleaseFcb( Fcb->NonPagedFcb );
        return STATUS_SUCCESS;

    } else if ( Fcb->RelativeFileName.Length == 0 ) {

        //
        //  Allow 'cd \' to work.
        //

        Buffer->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;

        Buffer->CreationTime = NwDateTimeToNtTime(
                                   DEFAULT_DATE,
                                   DEFAULT_TIME
                                   );

        Buffer->LastAccessTime = Buffer->CreationTime;
        Buffer->LastWriteTime = Buffer->CreationTime;
        Buffer->ChangeTime.QuadPart = 0;

        NwReleaseFcb( Fcb->NonPagedFcb );
        return STATUS_SUCCESS;

    } else {

        NwReleaseFcb( Fcb->NonPagedFcb );

        IrpContext->pNpScb = Fcb->Scb->pNpScb;
Retry:
        if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

            DebugTrace(0, Dbg, "QueryBasic short %wZ\n", &Fcb->RelativeFileName);

            Status = ExchangeWithWait (
                         IrpContext,
                         SynchronousResponseCallback,
                         "FwbbJ",
                         NCP_SEARCH_FILE,
                         -1,
                         Fcb->Vcb->Specific.Disk.Handle,
                         Fcb->NodeTypeCode == NW_NTC_FCB ?
                            SEARCH_ALL_FILES : SEARCH_ALL_DIRECTORIES,
                         &Icb->SuperType.Fcb->RelativeFileName );

            if ( NT_SUCCESS( Status ) ) {

                Status = ParseResponse(
                             IrpContext,
                             IrpContext->rsp,
                             IrpContext->ResponseLength,
                             "N==_b-==wwww",
                             14,
                             &Attributes,
                             &CreationDate,
                             &LastAccessDate,
                             &LastModifiedDate,
                             &LastModifiedTime);

                //
                // If this was a directory, there's no usable
                // time/date info from the server.
                //

                if ( ( NT_SUCCESS( Status ) ) &&
                     ( Attributes & NW_ATTRIBUTE_DIRECTORY ) ) {

                    CreationDate = DEFAULT_DATE;
                    LastAccessDate = DEFAULT_DATE;
                    LastModifiedDate = DEFAULT_DATE;
                    LastModifiedTime = DEFAULT_TIME;

                }
                   
            }

        } else {

            DebugTrace(0, Dbg, "QueryBasic long %wZ\n", &Fcb->RelativeFileName);

            Status = ExchangeWithWait (
                          IrpContext,
                          SynchronousResponseCallback,
                          "LbbWDbDbC",
                          NCP_LFN_GET_INFO,
                          Fcb->Vcb->Specific.Disk.LongNameSpace,
                          Fcb->Vcb->Specific.Disk.LongNameSpace,
                          Fcb->NodeTypeCode == NW_NTC_FCB ?
                            SEARCH_ALL_FILES : SEARCH_ALL_DIRECTORIES,
                          LFN_FLAG_INFO_ATTRIBUTES |
                          LFN_FLAG_INFO_MODIFY_TIME |
                          LFN_FLAG_INFO_CREATION_TIME,
                          Fcb->Vcb->Specific.Disk.VolumeNumber,
                          Fcb->Vcb->Specific.Disk.Handle,
                          0,
                          &Icb->SuperType.Fcb->RelativeFileName );

            if ( NT_SUCCESS( Status ) ) {
                Status = ParseResponse(
                             IrpContext,
                             IrpContext->rsp,
                             IrpContext->ResponseLength,
                             "N_e_xx_xx_x",
                             4,
                             &Attributes,
                             12,
                             &CreationTime,
                             &CreationDate,
                             4,
                             &LastModifiedTime,
                             &LastModifiedDate,
                             4,
                             &LastAccessDate );

            }
        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Set the various fields in the record
            //

            Buffer->CreationTime = NwDateTimeToNtTime(
                                       CreationDate,
                                       CreationTime
                                       );

            Buffer->LastAccessTime = NwDateTimeToNtTime(
                                         LastAccessDate,
                                         DEFAULT_TIME
                                         );

            Buffer->LastWriteTime = NwDateTimeToNtTime(
                                        LastModifiedDate,
                                        LastModifiedTime
                                        );

            Buffer->ChangeTime.QuadPart = 0;

            DebugTrace(0, Dbg, "CreationDate     %x\n", CreationDate );
            DebugTrace(0, Dbg, "CreationTime     %x\n", CreationTime );
            DebugTrace(0, Dbg, "LastAccessDate   %x\n", LastAccessDate );
            DebugTrace(0, Dbg, "LastModifiedDate %x\n", LastModifiedDate);
            DebugTrace(0, Dbg, "LastModifiedTime %x\n", LastModifiedTime);

            Buffer->FileAttributes = (UCHAR)Attributes;

            if ( Buffer->FileAttributes == 0 ) {
                Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
            }

        } else if ((Status == STATUS_INVALID_HANDLE) &&
            (FirstTime)) {

            //
            //  Check to see if Volume handle is invalid. Caused when volume
            //  is unmounted and then remounted.
            //

            FirstTime = FALSE;

            NwReopenVcbHandle( IrpContext, Fcb->Vcb );

            goto Retry;
        }

        return( Status );
    }
}

#if NWFASTIO

BOOLEAN
NwFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PICB Icb;
    PFCB Fcb;
    PVOID FsContext;

    FsRtlEnterFileSystem();

    try {
        //
        // Find out who are.
        //
    
        if ((NodeTypeCode = NwDecodeFileObject( FileObject,
                                                &FsContext,
                                                &Icb )) != NW_NTC_ICB ) {
    
            DebugTrace(-1, Dbg, "NwFastQueryStandardInfo -> FALSE\n", 0 );
            return FALSE;
        }
    
        Fcb = Icb->SuperType.Fcb;
    
        NwAcquireExclusiveFcb( Fcb->NonPagedFcb, TRUE );
    
        //
        // If we don't have the info handy, we can't use the fast path.
        //
    
        if ( !FlagOn( Fcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID ) ) {
            NwReleaseFcb( Fcb->NonPagedFcb );
            return( FALSE );
        }
    
        //
        // Set the various fields in the record
        //
    
        Buffer->CreationTime = NwDateTimeToNtTime(
                                   Fcb->CreationDate,
                                   Fcb->CreationTime
                                   );
    
        Buffer->LastAccessTime = NwDateTimeToNtTime(
                                     Fcb->LastAccessDate,
                                     DEFAULT_TIME
                                     );
    
        Buffer->LastWriteTime = NwDateTimeToNtTime(
                                    Fcb->LastModifiedDate,
                                    Fcb->LastModifiedTime
                                    );
    
        Buffer->ChangeTime.QuadPart = 0;

        DebugTrace(0, Dbg, "QueryBasic known %wZ\n", &Fcb->RelativeFileName);
        DebugTrace(0, Dbg, "LastModifiedDate %x\n", Fcb->LastModifiedDate);
        DebugTrace(0, Dbg, "LastModifiedTime %x\n", Fcb->LastModifiedTime);
        DebugTrace(0, Dbg, "CreationDate     %x\n", Fcb->CreationDate );
        DebugTrace(0, Dbg, "CreationTime     %x\n", Fcb->CreationTime );
        DebugTrace(0, Dbg, "LastAccessDate   %x\n", Fcb->LastAccessDate );
    
        Buffer->FileAttributes = Fcb->NonPagedFcb->Attributes;
    
        if ( Buffer->FileAttributes == 0 ) {
            Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }
    
        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = sizeof( *Buffer );
    
        NwReleaseFcb( Fcb->NonPagedFcb );
        return TRUE;
    
    } finally {
        
        FsRtlExitFileSystem();
    }
}
#endif


NTSTATUS
NwQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_STANDARD_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine perforNw the query standard information operation.

Arguments:

    Fcb - Supplies the FCB of the being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

Return Value:

    VOID

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    ULONG FileSize;
    BOOLEAN FirstTime = TRUE;

    PAGED_CODE();

    Fcb = Icb->SuperType.Fcb;

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    //
    //  Fill in the answers we already know.
    //

    Buffer->NumberOfLinks = 1;

    Buffer->DeletePending = (BOOLEAN)FlagOn( Fcb->Flags, FCB_FLAGS_DELETE_ON_CLOSE );

    if ( Fcb->NodeTypeCode == NW_NTC_FCB ) {
        Buffer->Directory = FALSE;
    } else {
        Buffer->Directory = TRUE;
    }

    if ( !Icb->HasRemoteHandle ) {

        //
        //  It is ok to attempt a reconnect if this request fails with a
        //  connection error.
        //

        SetFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

        if ( Fcb->NodeTypeCode == NW_NTC_DCB ||
             FlagOn( Fcb->Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {

            //
            //  Allow 'cd \' to work.
            //

            Buffer->AllocationSize.QuadPart = 0;
            Buffer->EndOfFile.QuadPart = 0;

            return STATUS_SUCCESS;

        } else {

            //
            //  No open handle for this file.  Use a path based NCP
            //  to get the file size.
            //
Retry:
            IrpContext->pNpScb = Fcb->Scb->pNpScb;

            if ( !BooleanFlagOn( Icb->SuperType.Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

                Status = ExchangeWithWait (
                             IrpContext,
                             SynchronousResponseCallback,
                             "FwbbJ",
                             NCP_SEARCH_FILE,
                             -1,
                             Fcb->Vcb->Specific.Disk.Handle,
                             SEARCH_ALL_FILES,
                             &Fcb->RelativeFileName );

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                 IrpContext,
                                 IrpContext->rsp,
                                 IrpContext->ResponseLength,
                                 "N_d",
                                 20,
                                 &FileSize );
                }

            } else {

                Status = ExchangeWithWait (
                             IrpContext,
                             SynchronousResponseCallback,
                             "LbbWDbDbC",
                             NCP_LFN_GET_INFO,
                             Fcb->Vcb->Specific.Disk.LongNameSpace,
                             Fcb->Vcb->Specific.Disk.LongNameSpace,
                             SEARCH_ALL_FILES,
                             LFN_FLAG_INFO_FILE_SIZE,
                             Fcb->Vcb->Specific.Disk.VolumeNumber,
                             Fcb->Vcb->Specific.Disk.Handle,
                             0,
                             &Fcb->RelativeFileName );

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                 IrpContext,
                                 IrpContext->rsp,
                                 IrpContext->ResponseLength,
                                 "N_e",
                                 10,
                                 &FileSize );
               }

           }

           if ((Status == STATUS_INVALID_HANDLE) &&
               (FirstTime)) {

               //
               //  Check to see if Volume handle is invalid. Caused when volume
               //  is unmounted and then remounted.
               //

               FirstTime = FALSE;

               NwReopenVcbHandle( IrpContext, Fcb->Vcb );

               goto Retry;
           }

           Buffer->AllocationSize.QuadPart = FileSize;
           Buffer->EndOfFile.QuadPart = FileSize;

        }

    } else {

        //
        // Start a Get file size NCP
        //

        IrpContext->pNpScb = Fcb->Scb->pNpScb;

        if ( Fcb->NodeTypeCode == NW_NTC_FCB ) {
            AcquireFcbAndFlushCache( IrpContext, Fcb->NonPagedFcb );
        }

        Status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "F-r",
                     NCP_GET_FILE_SIZE,
                     &Icb->Handle, sizeof(Icb->Handle ) );

        if ( NT_SUCCESS( Status ) ) {
            //
            // Get the data from the response.
            //

            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "Nd",
                         &FileSize );

        }

        if ( NT_SUCCESS( Status ) ) {

            //
            //  Fill in Allocation size and EOF, based on the response.
            //

            Buffer->AllocationSize.QuadPart = FileSize;
            Buffer->EndOfFile.QuadPart = Buffer->AllocationSize.QuadPart;

        }
    }

    return( Status );
}

#if NWFASTIO

BOOLEAN
NwFastQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/
{
    NODE_TYPE_CODE NodeTypeCode;
    PICB Icb;
    PFCB Fcb;
    PVOID FsContext;

    //
    // Find out who are.
    //

    try {
    
        FsRtlEnterFileSystem();

        if ((NodeTypeCode = NwDecodeFileObject( FileObject,
                                                &FsContext,
                                                &Icb )) != NW_NTC_ICB ) {
    
            DebugTrace(-1, Dbg, "NwFastQueryStandardInfo -> FALSE\n", 0 );
            return FALSE;
        }
    
        Fcb = Icb->SuperType.Fcb;
    
        //
        // If we have the info handy, we can use the fast path.
        //
    
        if ( Fcb->NodeTypeCode == NW_NTC_DCB ||
             FlagOn( Fcb->Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {
    
            Buffer->AllocationSize.QuadPart = 0;
            Buffer->EndOfFile.QuadPart = 0;
    
            Buffer->NumberOfLinks = 1;
            Buffer->DeletePending = (BOOLEAN)FlagOn( Fcb->Flags, FCB_FLAGS_DELETE_ON_CLOSE );
    
            Buffer->Directory = TRUE;
    
            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( *Buffer );
    
            return TRUE;
    
        } else {
    
            return FALSE;
    
        }
    } finally {

        FsRtlExitFileSystem();
    }
}
#endif


NTSTATUS
NwQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_INTERNAL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine perforNw the query internal information operation.

Arguments:

    Fcb - Supplies the FCB of the being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryInternalInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_INTERNAL_INFORMATION) );

    //
    // Set the internal index number to be the address of the ICB.
    //

    Buffer->IndexNumber.HighPart = 0;
    Buffer->IndexNumber.QuadPart = (ULONG_PTR)Icb->NpFcb;

    return( STATUS_SUCCESS );
}


NTSTATUS
NwQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_EA_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query Ea information operation.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

Return Value:

    VOID - The result of this query

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryEaInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory(Buffer, sizeof(FILE_EA_INFORMATION));

    return STATUS_SUCCESS;
}


NTSTATUS
NwQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information operation.

Arguments:

    Fcb - Supplies the FCB of the file to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies and receives the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    ULONG bytesToCopy;
    ULONG fileNameSize;
    PFCB Fcb = Icb->SuperType.Fcb;

    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryNameInfo...\n", 0);

    //
    //  Win32 expects the root directory name to be '\' terminated,
    //  the netware server does not.  So if this is a root directory,
    //  (i.e RelativeFileName length is 0) append a '\' to the path name.
    //

    //
    // See if the buffer is large enough, and decide how many bytes to copy.
    //

    *Length -= FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] );

    fileNameSize = Fcb->FullFileName.Length;
    if ( Fcb->RelativeFileName.Length == 0 ) {
        fileNameSize += sizeof(L'\\');
    }
    Buffer->FileNameLength = fileNameSize;

    if ( *Length >= fileNameSize ) {

        status = STATUS_SUCCESS;

        bytesToCopy = fileNameSize;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        bytesToCopy = *Length;
    }

    //
    // Copy over the file name and its length.
    //

    RtlMoveMemory(
        Buffer->FileName,
        Fcb->FullFileName.Buffer,
        bytesToCopy);

    //
    //  If this is a root directory, and there is space in the buffer
    //  append a '\' to make win32 happy.
    //

    if ( Fcb->RelativeFileName.Length == 0 && status == STATUS_SUCCESS ) {
        Buffer->FileName[ fileNameSize/sizeof(WCHAR) - 1 ] = L'\\';
    }

    *Length -= bytesToCopy;

    return status;
}

NTSTATUS
NwQueryAltNameInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PICB Icb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN PULONG Length
    )

/*++

Routine Description:

    This routine performs the AltName query name information operation.

Arguments:

    Fcb - Supplies the FCB of the file to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies and receives the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    ULONG bytesToCopy;
    ULONG fileNameSize;
    PFCB Fcb = Icb->SuperType.Fcb;

    UNICODE_STRING ShortName;
    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryAltNameInfo...\n", 0);

    pIrpContext->pNpScb = Fcb->Scb->pNpScb;

    //
    // See if the buffer is large enough, and decide how many bytes to copy.
    //

    *Length -= FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] );


    ShortName.MaximumLength = MAX_PATH;
    ShortName.Buffer=NULL;
    ShortName.Length = 0;


    status = ExchangeWithWait (
                     pIrpContext,
                     SynchronousResponseCallback,
                     "LbbWDbDbC",
                     NCP_LFN_GET_INFO,
                     Fcb->Vcb->Specific.Disk.LongNameSpace,
                     0x0,                                         //0x0 DOS Nam
                     SEARCH_ALL_DIRECTORIES,
                     LFN_FLAG_INFO_NAME,
                     Fcb->Vcb->Specific.Disk.VolumeNumber,
                     Fcb->Vcb->Specific.Disk.Handle,
                     0,
                     &Fcb->RelativeFileName );

    if (!NT_SUCCESS( status ) ){
        return status;
    }


    ShortName.Buffer= ALLOCATE_POOL(NonPagedPool,
            ShortName.MaximumLength+sizeof(WCHAR));
    if (ShortName.Buffer == NULL){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "N_P",
                     76,
                     &ShortName);

    if ( NT_SUCCESS( status ) ) {

          fileNameSize = ShortName.Length;

          if ( *Length >= fileNameSize ) {

              status = STATUS_SUCCESS;
              bytesToCopy = fileNameSize;

          } else {

              status = STATUS_BUFFER_OVERFLOW;
              bytesToCopy = *Length;
          }

         Buffer->FileNameLength = fileNameSize;

          RtlMoveMemory(
                  Buffer->FileName,
                  ShortName.Buffer,
                  bytesToCopy);

         *Length -= bytesToCopy;

    }


    FREE_POOL(ShortName.Buffer);

    return status;
}


NTSTATUS
NwQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_POSITION_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query position information operation.

Arguments:

    Fcb - Supplies the FCB of the file being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryPositionInfo...\n", 0);

    //
    // Return the current byte offset.  This info is totally
    // bogus for asynchronous files.  Also note that we don't
    // use the FilePosition member of the ICB for anything.
    //

    if ( Icb->FileObject ) {
        Buffer->CurrentByteOffset.QuadPart = Icb->FileObject->CurrentByteOffset.QuadPart;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NwSetBasicInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PICB Icb,
    IN PFILE_BASIC_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine sets the basic information for a file.

Arguments:

    pIrpContext - Supplies Irp context information.

    Icb - Supplies the ICB for the file being modified.

    Buffer - Supplies the buffer containing the data being set.

Return Value:

    NTSTATUS - Returns our completion status.

--*/

{
    PFCB Fcb;
    NTSTATUS Status;
    BOOLEAN SetTime = FALSE;
    BOOLEAN SetAttributes = FALSE;
    ULONG LfnFlag = 0;

    PAGED_CODE();

    DebugTrace(0, Dbg, "SetBasicInfo...\n", 0);

    Fcb = Icb->SuperType.Fcb;

    pIrpContext->pNpScb = Fcb->Scb->pNpScb;

    //
    //  Append this IRP context and wait to get to the front.
    //  then grab from FCB
    //

    NwAppendToQueueAndWait( pIrpContext );
    NwAcquireExclusiveFcb( Fcb->NonPagedFcb, TRUE );

    //
    //  It is ok to attempt a reconnect if this request fails with a
    //  connection error.
    //

    SetFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    if (Buffer->CreationTime.QuadPart != 0) {

        //
        //  Modify the creation time.
        //

        Status = NwNtTimeToNwDateTime(
                     Buffer->CreationTime,
                     &Fcb->CreationDate,
                     &Fcb->CreationTime );

        if ( !NT_SUCCESS( Status ) ) {
            NwReleaseFcb( Fcb->NonPagedFcb );
            return( Status );
        }

        SetTime = TRUE;
        LfnFlag |= LFN_FLAG_SET_INFO_CREATE_DATE | LFN_FLAG_SET_INFO_CREATE_TIME;
    }

    if (Buffer->LastAccessTime.QuadPart != 0) {

        USHORT Dummy;

        //
        //  Modify the last access time.
        //

        Status = NwNtTimeToNwDateTime(
                     Buffer->LastAccessTime,
                     &Fcb->LastAccessDate,
                     &Dummy );

        if ( !NT_SUCCESS( Status ) ) {
            NwReleaseFcb( Fcb->NonPagedFcb );
            return( Status );
        }

        SetTime = TRUE;
        LfnFlag |= LFN_FLAG_SET_INFO_LASTACCESS_DATE;

        // Set the last access flag in the ICB so that we update
        // last access time for real when we close this handle!

        Icb->UserSetLastAccessTime = TRUE;
    }

    if (Buffer->LastWriteTime.QuadPart != 0) {

        //
        //  Modify the last write time
        //

        Status = NwNtTimeToNwDateTime(
                     Buffer->LastWriteTime,
                     &Fcb->LastModifiedDate,
                     &Fcb->LastModifiedTime );

        if ( !NT_SUCCESS( Status ) ) {
            NwReleaseFcb( Fcb->NonPagedFcb );
            return( Status );
        }

        LfnFlag |= LFN_FLAG_SET_INFO_MODIFY_DATE | LFN_FLAG_SET_INFO_MODIFY_TIME;
    }


    if (Buffer->FileAttributes != 0) {
        LfnFlag |= LFN_FLAG_SET_INFO_ATTRIBUTES;
    }

    if ( LfnFlag == 0 ) {

        //
        // Nothing to set, simply return success.
        //

        Status = STATUS_SUCCESS;
    }

    if ( Fcb->NodeTypeCode == NW_NTC_FCB ) {

        //
        // Call plain FlushCache - we don't want to acquire and
        // release the NpFcb. We are already at the front and have the Fcb
        // exclusive.
        //

        FlushCache( pIrpContext, Fcb->NonPagedFcb );
    }

    if ( BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        Status = ExchangeWithWait(
                     pIrpContext,
                     SynchronousResponseCallback,
                     "LbbWDW--WW==WW==_W_bDbC",
                     NCP_LFN_SET_INFO,
                     Fcb->Vcb->Specific.Disk.LongNameSpace,
                     Fcb->Vcb->Specific.Disk.LongNameSpace,
                     Fcb->NodeTypeCode == NW_NTC_FCB ?
                        SEARCH_ALL_FILES : SEARCH_ALL_DIRECTORIES,
                     LfnFlag,
                     NtAttributesToNwAttributes( Buffer->FileAttributes ),
                     Fcb->CreationDate,
                     Fcb->CreationTime,
                     Fcb->LastModifiedDate,
                     Fcb->LastModifiedTime,
                     8,
                     Fcb->LastAccessDate,
                     8,
                     Fcb->Vcb->Specific.Disk.VolumeNumber,
                     Fcb->Vcb->Specific.Disk.Handle,
                     0,
                     &Fcb->RelativeFileName );

    } else {

        if ( LfnFlag & LFN_FLAG_SET_INFO_ATTRIBUTES ) {
            Status = ExchangeWithWait(
                         pIrpContext,
                         SynchronousResponseCallback,
                         "FbbbU",
                         NCP_SET_FILE_ATTRIBUTES,
                         NtAttributesToNwAttributes( Buffer->FileAttributes ),
                         Fcb->Vcb->Specific.Disk.Handle,
                         Fcb->NodeTypeCode == NW_NTC_FCB ?
                            SEARCH_ALL_FILES : SEARCH_ALL_DIRECTORIES,
                         &Fcb->RelativeFileName );

            if ( !NT_SUCCESS( Status ) ) {
                NwReleaseFcb( Fcb->NonPagedFcb );
                return( Status );
            }

        }

#if 0
        //
        //  We could conceivably use ScanDir/SetDir to update last access
        //  and create time.   Not supported yet.
        //

        if ( LfnFlag & ( LFN_FLAG_SET_INFO_LASTACCESS_DATE | LFN_FLAG_SET_INFO_CREATE_DATE ) ) {

            ULONG SearchIndex;
            ULONG Directory;

            Status = ExchangeWithWait(
                         pIrpContext,
                         SynchronousResponseCallback,
                         "SbbdU",
                         0x16, 0x1E,    // Scan dir entry
                         Fcb->Vcb->Specific.Disk.Handle,
                         0x06,       // Search attributes
                         -1,         // Search index
                         &Fcb->RelativeFileName );

            if ( NT_SUCCESS( Status ) ) {
                Status = ParseResponse(
                             pIrpContext,
                             pIrpContext->rsp,
                             pIrpContext->ResponseLength,
                             "Ndd",
                             &SearchIndex,
                             &Directory );
            }

            if ( NT_SUCCESS( Status ) ) {
                Status = ExchangeWithWait(
                             pIrpContext,
                             SynchronousResponseCallback,
                             "Sbbdddw=----_ww==ww==ww",
                             0x16, 0x25,    // Set dir entry
                             Fcb->Vcb->Specific.Disk.Handle,
                             0x06,       // Search attributes
                             SearchIndex,
                             0,         // Change Bits?
                             Directory,
                             12,
                             Fcb->CreationDate,
                             0,
                             Fcb->LastAccessDate,
                             0,
                             Fcb->LastModifiedDate,
                             Fcb->LastModifiedTime );
            }
        }
#endif

        if ( LfnFlag & LFN_FLAG_SET_INFO_MODIFY_DATE ) {
            Status = ExchangeWithWait(
                     pIrpContext,
                     SynchronousResponseCallback,
                     "F-rww-",
                     NCP_SET_FILE_TIME,
                     &Icb->Handle, sizeof( Icb->Handle ),
                     Fcb->LastModifiedTime,
                     Fcb->LastModifiedDate );
        }
    }

    NwReleaseFcb( Fcb->NonPagedFcb );

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
NwSetDispositionInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PICB Icb,
    IN PFILE_DISPOSITION_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine sets the disposition information for a file.

Arguments:

    pIrpContext - Supplies Irp context information.

    Icb - Supplies the ICB for the file being modified.

    Buffer - Supplies the buffer containing the data being set.

Return Value:

    NTSTATUS - Returns our completion status.

--*/
{
    PFCB Fcb;
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "SetDispositionInfo...\n", 0);

    Fcb = Icb->SuperType.Fcb;

    if ( FlagOn( Fcb->Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {

        //
        //  This is a print queue, just pretend this IRP succeeded.
        //

        Status = STATUS_SUCCESS;

    } else {

        //
        //  This is a real file or directory.  Mark it delete pending.
        //

        SetFlag( Fcb->Flags, FCB_FLAGS_DELETE_ON_CLOSE );

        pIrpContext->pNpScb = Fcb->Scb->pNpScb;
        pIrpContext->Icb = Icb;

        Icb->State = ICB_STATE_CLOSE_PENDING;

        //
        //  Go ahead, delete the file.
        //

        Status = NwDeleteFile( pIrpContext );
    }

    return( Status );
}

NTSTATUS
NwDeleteFile(
    PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine continues processing of the SetDispositionInfo request.
    It must run in the redirector FSP.

Arguments:

    pIrpContext -  A pointer to the IRP context information for the
        request in progress.

Return Value:

    The status of the operation.

--*/
{
    PICB Icb;
    PFCB Fcb;
    NTSTATUS Status;

    PAGED_CODE();

    Icb = pIrpContext->Icb;
    Fcb = Icb->SuperType.Fcb;

    ClearFlag( Fcb->Flags, FCB_FLAGS_DELETE_ON_CLOSE );

    //
    //  To a delete a file, first close the remote handle.
    //

    if ( Icb->HasRemoteHandle ) {

        Icb->HasRemoteHandle = FALSE;

        Status = ExchangeWithWait(
                     pIrpContext,
                     SynchronousResponseCallback,
                     "F-r",
                     NCP_CLOSE,
                     Icb->Handle, sizeof( Icb->Handle ) );
    }

    //
    //  Note that this request cannot be reconnectable since, it can
    //  be called via NwCloseIcb().   See comment in that routine for
    //  more info.
    //

    if ( Fcb->NodeTypeCode == NW_NTC_FCB ) {

        if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

            Status = ExchangeWithWait(
                        pIrpContext,
                         SynchronousResponseCallback,
                        "FbbJ",
                        NCP_DELETE_FILE,
                        Fcb->Vcb->Specific.Disk.Handle,
                        SEARCH_ALL_FILES,
                        &Fcb->RelativeFileName );

        } else {

            Status = ExchangeWithWait(
                        pIrpContext,
                         SynchronousResponseCallback,
                        "LbbW-DbC",
                        NCP_LFN_DELETE_FILE,
                        Fcb->Vcb->Specific.Disk.LongNameSpace,
                        Fcb->Vcb->Specific.Disk.VolumeNumber,
                        NW_ATTRIBUTE_SYSTEM | NW_ATTRIBUTE_HIDDEN,
                        Fcb->Vcb->Specific.Disk.Handle,
                        LFN_FLAG_SHORT_DIRECTORY,
                        &Fcb->RelativeFileName );
        }

    } else {

        ASSERT( Fcb->NodeTypeCode == NW_NTC_DCB );

        if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

            Status = ExchangeWithWait(
                        pIrpContext,
                         SynchronousResponseCallback,
                        "SbbJ",
                        NCP_DIR_FUNCTION, NCP_DELETE_DIRECTORY,
                        Fcb->Vcb->Specific.Disk.Handle,
                        SEARCH_ALL_DIRECTORIES,
                        &Fcb->RelativeFileName );
        } else {

            Status = ExchangeWithWait(
                        pIrpContext,
                         SynchronousResponseCallback,
                        "LbbW-DbC",
                        NCP_LFN_DELETE_FILE,
                        Fcb->Vcb->Specific.Disk.LongNameSpace,
                        Fcb->Vcb->Specific.Disk.VolumeNumber,
                        SEARCH_ALL_DIRECTORIES,
                        Fcb->Vcb->Specific.Disk.Handle,
                        LFN_FLAG_SHORT_DIRECTORY,
                        &Fcb->RelativeFileName );
        }

    }

    if ( NT_SUCCESS( Status )) {

        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "N" );

    } else {

        //
        // We can map all failures to STATUS_NO_SUCH_FILE
        // except ACCESS_DENIED, which happens with a read
        // only file.
        //

       if ( Status != STATUS_ACCESS_DENIED ) {
           Status = STATUS_NO_SUCH_FILE;
       }

    }

    return Status;
}

NTSTATUS
NwSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_RENAME_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine set rename information for a file.

Arguments:

    pIrpContext -  A pointer to the IRP context information for the
        request in progress.

    Icb - A pointer to the ICB of the file to set.

    Buffer - The request buffer.

Return Value:

    The status of the operation.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;
    NTSTATUS Status2;
    PFCB Fcb;
    PFCB TargetFcb;
    BOOLEAN HandleAllocated = FALSE;
    BYTE Handle;
    PICB TargetIcb = NULL;

    UNICODE_STRING OldDrive;
    UNICODE_STRING OldServer;
    UNICODE_STRING OldVolume;
    UNICODE_STRING OldPath;
    UNICODE_STRING OldFileName;
    UNICODE_STRING OldFullName;
    WCHAR OldDriveLetter;
    UNICODE_STRING OldFcbFullName;

    UNICODE_STRING NewDrive;
    UNICODE_STRING NewServer;
    UNICODE_STRING NewVolume;
    UNICODE_STRING NewPath;
    UNICODE_STRING NewFileName;
    UNICODE_STRING NewFullName;
    WCHAR NewDriveLetter;
    UNICODE_STRING NewFcbFullName;

    USHORT i;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "SetRenameInfo...\n", 0);

    //
    //  Can't try to set rename info on a print queue.
    //

    Fcb = Icb->SuperType.Fcb;

    if ( FlagOn( Fcb->Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  It is ok to attempt a reconnect if this request fails with a
    //  connection error.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    // Get the current stack location.
    //

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( 0, Dbg, " ->FullFileName               = %wZ\n",
        &Fcb->FullFileName);

    if (irpSp->Parameters.SetFile.FileObject != NULL) {

        TargetIcb = irpSp->Parameters.SetFile.FileObject->FsContext2;

        DebugTrace( 0, Dbg, " ->FullFileName               = %wZ\n",
            &TargetIcb->SuperType.Fcb->FullFileName);

        if ( TargetIcb->SuperType.Fcb->Scb != Icb->SuperType.Fcb->Scb ) {
            return STATUS_NOT_SAME_DEVICE;
        }

    } else {

        DebugTrace( 0, Dbg, " ->FullFileName  in users buffer\n", 0);
        DebugTrace(-1, Dbg, "SetRenameInfo %08lx\n", STATUS_NOT_IMPLEMENTED);
        return STATUS_NOT_IMPLEMENTED;
    }

    DebugTrace( 0, Dbg, " ->TargetFileName               = %wZ\n",
        &irpSp->Parameters.SetFile.FileObject->FileName);

    TargetFcb = ((PNONPAGED_FCB)irpSp->Parameters.SetFile.FileObject->FsContext)->Fcb;


    IrpContext->pNpScb = Fcb->Scb->pNpScb;

    NwAppendToQueueAndWait( IrpContext );
    NwAcquireExclusiveFcb( Fcb->NonPagedFcb, TRUE );

    try {

        //
        //  If either source or destination is a long name, use
        //  the long name path.
        //

        if ( !BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) &&
             IsFatNameValid( &TargetFcb->RelativeFileName ) &&
             !BooleanFlagOn( Fcb->Vcb->Flags, VCB_FLAG_LONG_NAME ) ) {

            //
            //  Strip to UID portion of the FCB name.
            //

            for ( i = 0 ; i < Fcb->FullFileName.Length / sizeof(WCHAR) ; i++ ) {
                if ( Fcb->FullFileName.Buffer[i] == OBJ_NAME_PATH_SEPARATOR ) {
                    break;
                }
            }

            ASSERT( Fcb->FullFileName.Buffer[i] == OBJ_NAME_PATH_SEPARATOR );

            OldFcbFullName.Length = Fcb->FullFileName.Length - i*sizeof(WCHAR);
            OldFcbFullName.Buffer = Fcb->FullFileName.Buffer + i;

            Status = CrackPath (
                          &OldFcbFullName,
                          &OldDrive,
                          &OldDriveLetter,
                          &OldServer,
                          &OldVolume,
                          &OldPath,
                          &OldFileName,
                          &OldFullName );

            ASSERT(NT_SUCCESS(Status));

            //
            //  Strip to UID portion of the FCB name.
            //

            TargetFcb = ((PNONPAGED_FCB)(irpSp->Parameters.SetFile.FileObject->FsContext))->Fcb;

            for ( i = 0 ; i < TargetFcb->FullFileName.Length / sizeof(WCHAR) ; i++ ) {
                if ( TargetFcb->FullFileName.Buffer[i] == OBJ_NAME_PATH_SEPARATOR ) {
                    break;
                }
            }

            ASSERT( TargetFcb->FullFileName.Buffer[i] == OBJ_NAME_PATH_SEPARATOR );

            NewFcbFullName.Length = TargetFcb->FullFileName.Length - i*sizeof(WCHAR);
            NewFcbFullName.Buffer = TargetFcb->FullFileName.Buffer + i;

            Status = CrackPath (
                          &NewFcbFullName,
                          &NewDrive,
                          &NewDriveLetter,
                          &NewServer,
                          &NewVolume,
                          &NewPath,
                          &NewFileName,
                          &NewFullName );

            ASSERT(NT_SUCCESS(Status));

            //
            //  Make sure that this is the same volume.
            //

            if ( RtlCompareUnicodeString( &NewVolume, &OldVolume, TRUE ) != 0 ) {
                try_return( Status = STATUS_NOT_SAME_DEVICE );
            }

            if (Icb->SuperType.Fcb->IcbCount != 1) {
                try_return( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  After a rename, the only operation allowed on the handle is an
            //  NtClose.
            //

            Icb->State = ICB_STATE_CLOSE_PENDING;

            if ((irpSp->Parameters.SetFile.ReplaceIfExists ) &&
                (TargetIcb->Exists)) {

                //  Delete the file

                Status2 = ExchangeWithWait(
                              IrpContext,
                              SynchronousResponseCallback,
                              "Fb-J",
                              NCP_DELETE_FILE,
                              TargetFcb->Vcb->Specific.Disk.Handle,
                              &TargetFcb->RelativeFileName );

#ifdef NWDBG
                if ( NT_SUCCESS( Status2 ) ) {
                    Status2 = ParseResponse(
                                  IrpContext,
                                  IrpContext->rsp,
                                  IrpContext->ResponseLength,
                                  "N" );
                }

                ASSERT(NT_SUCCESS(Status2));
#endif
            }

            //
            //  Need to create a handle to the directory containing the old
            //  file/directory name because directory rename does not contain a
            //  path and there might not be room for two paths in a file rename.
            //
            //  The way we do this is to allocate a temporary handle on the server.
            //  This request is at the front of the Scb->Requests queue and so can
            //  use the temporary handle and delete it without affecting any other
            //  requests.
            //

            if ( OldPath.Length == 0 ) {

                //  In the root so use the VCB handle.

                Handle = Fcb->Vcb->Specific.Disk.Handle;

            } else {

                Status = ExchangeWithWait (
                            IrpContext,
                            SynchronousResponseCallback,
                            "SbbJ",   // NCP Allocate temporary directory handle
                            NCP_DIR_FUNCTION, NCP_ALLOCATE_TEMP_DIR_HANDLE,
                            Fcb->Vcb->Specific.Disk.Handle,
                            '[',
                            &OldPath );

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                 IrpContext,
                                 IrpContext->rsp,
                                 IrpContext->ResponseLength,
                                 "Nb",
                                 &Handle );
                }

                if (!NT_SUCCESS(Status)) {
                    try_return(Status);
                }

                HandleAllocated = TRUE;
            }

            if ( Fcb->NodeTypeCode == NW_NTC_DCB ) {

                //
                //  We can only rename files in the same directory
                //

                if ( RtlCompareUnicodeString( &NewPath, &OldPath, TRUE ) != 0 ) {
                    try_return(Status = STATUS_NOT_SUPPORTED);

                } else {

                    Status = ExchangeWithWait (  IrpContext,
                                    SynchronousResponseCallback,
                                    "SbJJ",
                                    NCP_DIR_FUNCTION, NCP_RENAME_DIRECTORY,
                                    Handle,
                                    &OldFileName,
                                    &NewFileName);
                }

            } else {

                //
                //  We have to close the handle associated with the Icb that
                //  is doing the rename. Close that handle or the rename will
                //  fail for sure.
                //

                if ( Icb->HasRemoteHandle ) {

                    Status2 = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "F-r",
                                NCP_CLOSE,
                                Icb->Handle, sizeof( Icb->Handle ) );

                    Icb->HasRemoteHandle = FALSE;

#ifdef NWDBG
                    if ( NT_SUCCESS( Status2 ) ) {
                        Status2 = ParseResponse(
                                      IrpContext,
                                      IrpContext->rsp,
                                      IrpContext->ResponseLength,
                                      "N" );
                    }

                    ASSERT(NT_SUCCESS(Status2));
#endif
                }

                //
                //  Do the file rename Ncp.
                //

                Status = ExchangeWithWait (
                             IrpContext,
                             SynchronousResponseCallback,
                             "FbbJbJ",
                             NCP_RENAME_FILE,
                             Handle,
                             SEARCH_ALL_FILES,
                             &OldFileName,
                             Fcb->Vcb->Specific.Disk.Handle,
                             &NewFullName);
            }

        } else {

            //
            //  We are going through the long name path.   Ensure that the
            //  VCB supports long names.
            //

            if ( Icb->SuperType.Fcb->Vcb->Specific.Disk.LongNameSpace ==
                 LFN_NO_OS2_NAME_SPACE) {
                try_return( Status = STATUS_OBJECT_PATH_SYNTAX_BAD );
            }

            if (Icb->SuperType.Fcb->IcbCount != 1) {
                try_return( Status = STATUS_ACCESS_DENIED);
            }

            //
            //  After a rename, the only operation allowed on the handle is an
            //  NtClose.
            //

            Icb->State = ICB_STATE_CLOSE_PENDING;

            if ((irpSp->Parameters.SetFile.ReplaceIfExists ) &&
                (TargetIcb->Exists)) {

                //  Delete the file

                Status = ExchangeWithWait(
                            IrpContext,
                             SynchronousResponseCallback,
                            "LbbW-DbC",
                            NCP_LFN_DELETE_FILE,
                            TargetFcb->Vcb->Specific.Disk.LongNameSpace,
                            TargetFcb->Vcb->Specific.Disk.VolumeNumber,
                            SEARCH_ALL_FILES,
                            TargetFcb->Vcb->Specific.Disk.Handle,
                            LFN_FLAG_SHORT_DIRECTORY,
                            &TargetFcb->RelativeFileName );

#ifdef NWDBG
                if ( NT_SUCCESS( Status ) ) {
                    Status2 = ParseResponse(
                                  IrpContext,
                                  IrpContext->rsp,
                                  IrpContext->ResponseLength,
                                  "N" );
                }

                ASSERT(NT_SUCCESS(Status2));
#endif
            }

            if ( Fcb->NodeTypeCode == NW_NTC_DCB ) {

                //
                //  We can only rename files in the same directory
                //

                if ( Fcb->Vcb != TargetFcb->Vcb ) {
                    try_return(Status = STATUS_NOT_SUPPORTED);

                } else {

                    Status = ExchangeWithWait (
                                 IrpContext,
                                 SynchronousResponseCallback,
                                 "LbbWbDbbbDbbNN",
                                 NCP_LFN_RENAME_FILE,
                                 Fcb->Vcb->Specific.Disk.LongNameSpace,
                                 0,      //  Rename flag
                                 SEARCH_ALL_DIRECTORIES,
                                 Fcb->Vcb->Specific.Disk.VolumeNumber,
                                 Fcb->Vcb->Specific.Disk.Handle,
                                 LFN_FLAG_SHORT_DIRECTORY,
                                 OccurenceCount( &Fcb->RelativeFileName, OBJ_NAME_PATH_SEPARATOR ) + 1,
                                 Fcb->Vcb->Specific.Disk.VolumeNumber,
                                 Fcb->Vcb->Specific.Disk.Handle,
                                 LFN_FLAG_SHORT_DIRECTORY,
                                 OccurenceCount( &TargetFcb->RelativeFileName, OBJ_NAME_PATH_SEPARATOR ) + 1,
                                 &Fcb->RelativeFileName,
                                 &TargetFcb->RelativeFileName );
                }

            } else {

                //
                //  We have to close the handle associated with the Icb that
                //  is doing the rename. Close that handle or the rename will
                //  fail for sure.
                //

                if ( Icb->HasRemoteHandle ) {

                    Status2 = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "F-r",
                                NCP_CLOSE,
                                Icb->Handle, sizeof( Icb->Handle ) );

                    Icb->HasRemoteHandle = FALSE;

#ifdef NWDBG
                    if ( NT_SUCCESS( Status2 ) ) {
                        Status2 = ParseResponse(
                                      IrpContext,
                                      IrpContext->rsp,
                                      IrpContext->ResponseLength,
                                      "N" );
                    }

                    ASSERT(NT_SUCCESS(Status2));
#endif
                }

                //
                //  Do the file rename Ncp.
                //

                Status = ExchangeWithWait (
                             IrpContext,
                             SynchronousResponseCallback,
                             "LbbWbDbbbDbbNN",
                             NCP_LFN_RENAME_FILE,
                             Fcb->Vcb->Specific.Disk.LongNameSpace,
                             0,      //  Rename flag
                             SEARCH_ALL_FILES,
                             Fcb->Vcb->Specific.Disk.VolumeNumber,
                             Fcb->Vcb->Specific.Disk.Handle,
                             LFN_FLAG_SHORT_DIRECTORY,
                             OccurenceCount( &Fcb->RelativeFileName, OBJ_NAME_PATH_SEPARATOR ) + 1,
                             Fcb->Vcb->Specific.Disk.VolumeNumber,
                             Fcb->Vcb->Specific.Disk.Handle,
                             LFN_FLAG_SHORT_DIRECTORY,
                             OccurenceCount( &TargetFcb->RelativeFileName, OBJ_NAME_PATH_SEPARATOR ) + 1,
                             &Fcb->RelativeFileName,
                             &TargetFcb->RelativeFileName );
            }
        }

try_exit: NOTHING;
    } finally {

        if (HandleAllocated) {

            Status2 = ExchangeWithWait (
                        IrpContext,
                        SynchronousResponseCallback,
                        "Sb",   // NCP Deallocate directory handle
                        NCP_DIR_FUNCTION, NCP_DEALLOCATE_DIR_HANDLE,
                        Handle);
#ifdef NWDBG
            if ( NT_SUCCESS( Status2 ) ) {
                Status2 = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "N" );
            }

            ASSERT(NT_SUCCESS(Status2));
#endif

        }

        NwReleaseFcb( Fcb->NonPagedFcb );
    }

    DebugTrace(-1, Dbg, "SetRenameInfo %08lx\n", Status );

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    if ( Status != STATUS_PENDING ) {
        NwDequeueIrpContext( IrpContext, FALSE );
    }

    return Status;
}

NTSTATUS
NwSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_POSITION_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine sets position information for a file.

Arguments:

    pIrpContext -  A pointer to the IRP context information for the
        request in progress.

    Icb - A pointer to the ICB of the file to set.

    Buffer - The request buffer.

Return Value:

    The status of the operation.

--*/
{
    PAGED_CODE();

    ASSERT( Buffer->CurrentByteOffset.HighPart == 0 );

    if ( Icb->FileObject ) {
        Icb->FileObject->CurrentByteOffset.QuadPart = Buffer->CurrentByteOffset.QuadPart;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
NwSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_ALLOCATION_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine sets allocation information for a file.

Arguments:

    pIrpContext -  A pointer to the IRP context information for the
        request in progress.

    Icb - A pointer to the ICB of the file to set.

    Buffer - The request buffer.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PFCB fcb = (PFCB)Icb->SuperType.Fcb;
    PULONG pFileSize;

    PAGED_CODE();

    ASSERT( Buffer->AllocationSize.HighPart == 0);

    if ( fcb->NodeTypeCode == NW_NTC_FCB ) {

        pFileSize = &Icb->NpFcb->Header.FileSize.LowPart;

        IrpContext->pNpScb = fcb->Scb->pNpScb;

        if (BooleanFlagOn( fcb->Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {
            if (IsTerminalServer()) {
                // 2/10/97 cjc Fix problem for binary files not printing correctly
                //             if done via the COPY command.  Works with NT RDR so
                //             changed this to behave same way.
                return(STATUS_INVALID_PARAMETER);
            } else {
                return STATUS_SUCCESS;
            }
        }

    } else if ( fcb->NodeTypeCode == NW_NTC_SCB ) {

        pFileSize = &Icb->FileSize;

        IrpContext->pNpScb = ((PSCB)fcb)->pNpScb;

    } else {

        DebugTrace(0, Dbg, "Not a file or a server\n", 0);

        DebugTrace( 0, Dbg, "NwSetAllocationInfo -> %08lx\n", STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    NwAppendToQueueAndWait( IrpContext );

    if ( !Icb->HasRemoteHandle ) {

        Status = STATUS_INVALID_PARAMETER;

    } else if ( Buffer->AllocationSize.LowPart == *pFileSize ) {

        Status = STATUS_SUCCESS;

    } else {

        irp = IrpContext->pOriginalIrp;
        irpSp = IoGetCurrentIrpStackLocation( irp );

#ifndef QFE_BUILD
        if ( Buffer->AllocationSize.LowPart < *pFileSize ) {

            //
            //  Before we actually truncate, check to see if the purge
            //  is going to fail.
            //

            if (!MmCanFileBeTruncated( irpSp->FileObject->SectionObjectPointer,
                                       &Buffer->AllocationSize )) {

                return( STATUS_USER_MAPPED_FILE );
            }
        }
#endif

        if ( fcb->NodeTypeCode == NW_NTC_FCB ) {
            AcquireFcbAndFlushCache( IrpContext, fcb->NonPagedFcb );
        }

        Status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "F-rd=",
                     NCP_WRITE_FILE,
                     &Icb->Handle, sizeof( Icb->Handle ),
                     Buffer->AllocationSize.LowPart );

        if ( NT_SUCCESS( Status ) ) {
            *pFileSize = Buffer->AllocationSize.LowPart;
        }
    }

    NwDequeueIrpContext( IrpContext, FALSE );

    return( Status );
}

NTSTATUS
NwSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb,
    IN PFILE_END_OF_FILE_INFORMATION Buffer
    )
/*++

Routine Description:

    This routine sets end of file information for a file.

Arguments:

    pIrpContext -  A pointer to the IRP context information for the
        request in progress.

    Icb - A pointer to the ICB of the file to set.

    Buffer - The request buffer.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PFCB fcb = (PFCB)Icb->SuperType.Fcb;
    PULONG pFileSize;

    PAGED_CODE();

    ASSERT( Buffer->EndOfFile.HighPart == 0);

    if ( fcb->NodeTypeCode == NW_NTC_FCB ) {

        pFileSize = &Icb->NpFcb->Header.FileSize.LowPart;

        IrpContext->pNpScb = fcb->Scb->pNpScb;

        if (BooleanFlagOn( fcb->Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {

            return STATUS_SUCCESS;

        }

    } else if ( fcb->NodeTypeCode == NW_NTC_SCB ) {

        pFileSize = &Icb->FileSize;

        IrpContext->pNpScb = ((PSCB)fcb)->pNpScb;

    } else {

        DebugTrace(0, Dbg, "Not a file or a server\n", 0);

        DebugTrace( 0, Dbg, "NwSetAllocationInfo -> %08lx\n", STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    NwAppendToQueueAndWait( IrpContext );

    if ( !Icb->HasRemoteHandle ) {

        Status = STATUS_INVALID_PARAMETER;

    } else if ( Buffer->EndOfFile.LowPart == *pFileSize ) {

        Status = STATUS_SUCCESS;

    } else {

        irp = IrpContext->pOriginalIrp;
        irpSp = IoGetCurrentIrpStackLocation( irp );

#ifndef QFE_BUILD

        if ( Buffer->EndOfFile.LowPart < *pFileSize ) {

            //
            //  Before we actually truncate, check to see if the purge
            //  is going to fail.
            //

            if (!MmCanFileBeTruncated( irpSp->FileObject->SectionObjectPointer,
                                       &Buffer->EndOfFile )) {

                return( STATUS_USER_MAPPED_FILE );
            }
        }
#endif

        if ( fcb->NodeTypeCode == NW_NTC_FCB ) {
            AcquireFcbAndFlushCache( IrpContext, fcb->NonPagedFcb );
        }

        Status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "F-rd=",
                     NCP_WRITE_FILE,
                     &Icb->Handle, sizeof( Icb->Handle ),
                     Buffer->EndOfFile.LowPart );

        if ( NT_SUCCESS( Status ) ) {
            *pFileSize = Buffer->EndOfFile.LowPart;
        }
    }

    NwDequeueIrpContext( IrpContext, FALSE );

    return( Status );
}


ULONG
OccurenceCount (
    IN PUNICODE_STRING String,
    IN WCHAR SearchChar
    )
/*++

Routine Description:

    This routine counts the number of occurences of a search character
    in a string

Arguments:

    String - The string to search

    SearchChar - The character to search for.

Return Value:

    The occurence count.

--*/
{
    PWCH currentChar;
    PWCH endOfString;
    ULONG count = 0;

    PAGED_CODE();

    currentChar = String->Buffer;
    endOfString = &String->Buffer[ String->Length / sizeof(WCHAR) ];

    while ( currentChar < endOfString ) {
        if ( *currentChar == SearchChar ) {
            count++;
        }
        currentChar++;
    }

    return( count );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\filobsup.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    filobsup.c

Abstract:

    This module implements the Netware Redirector object support routines.

Author:

    Manny Weiser (mannyw)    10-Feb-1993

Revision History:

--*/

#include "procs.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwSetFileObject )
#pragma alloc_text( PAGE, NwDecodeFileObject )
#endif


VOID
NwSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to either an icb, fcb, vcb, or dcb
        structure.

    FsContext2 - Supplies a pointer to a icb, or is null.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwSetFileObject, FileObject = %08lx\n", (ULONG_PTR)FileObject );

    //
    // Set the fscontext fields of the file object.
    //

    FileObject->FsContext  = FsContext;
    FileObject->FsContext2 = FsContext2;

    DebugTrace(-1, Dbg, "NwSetFileObject -> VOID\n", 0);

    return;
}


NODE_TYPE_CODE
NwDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the mailslot file system and figures out what it really
    is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    FsContext - Receives a pointer to the FsContext pointer
    FsContext2 - Receives a pointer to the FsContext2 pointer

Return Value:

    NODE_TYPE_CODE - Returns the node type code for a Rcb, Scb, Dcb, Icb,
        or zero.

        Rcb - indicates that file object opens the netware redirector device.

        Scb - indicates that file object is for a server.

        Dcb - indicates that the file object is for a directory.

        Icb - indicates that the file object is for a file.

        Zero - indicates that the file object was for a netware file
            but has been closed.

--*/

{
    NODE_TYPE_CODE NodeTypeCode = NTC_UNDEFINED;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwDecodeFileObject, FileObject = %08lx\n", (ULONG_PTR)FileObject);

    //
    // Read the fs FsContext fields of the file object.
    //

    *FsContext = FileObject->FsContext;
    *FsContext2 = FileObject->FsContext2;

    ASSERT ( *FsContext2 != NULL );
    NodeTypeCode = NodeType( *FsContext2 );

    DebugTrace(-1, Dbg, "NwDecodeFileObject -> %08lx\n", NodeTypeCode);
    return NodeTypeCode;
}

BOOLEAN
NwIsIrpTopLevel (
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine detects if an Irp is the Top level requestor, ie. if it is OK
    to do a verify or pop-up now.  If TRUE is returned, then no file system
    resources are held above us.

Arguments:

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    if ( NwGetTopLevelIrp() == NULL ) {
        NwSetTopLevelIrp( Irp );
        return TRUE;
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\ipx.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Ipx.c

Abstract:

    This module implements the low level Ipx support routines for the NetWare
    redirector.

Author:

    Colin Watson    [ColinW]    28-Dec-1992

Revision History:

--*/

#include "Procs.h"
#include "wsnwlink.h"

//
//  Define IPX interfaces that should be in a public header file but aren't
//  (at least for NT 1.0).  For Daytona, include isnkrnl.h.
//

#define IPX_ID              'M'<<24 | 'I'<<16 | 'P'<<8 | 'X'

#define I_MIPX              (('I' << 24) | ('D' << 16) | ('P' << 8))
#define MIPX_SENDPTYPE      I_MIPX | 118 /* Send ptype in options on recv*/
#define MIPX_RERIPNETNUM    I_MIPX | 144 /* ReRip a network         */
#define MIPX_GETNETINFO     I_MIPX | 135 /* Get info on a network num    */
#define MIPX_LINECHANGE     I_MIPX | 310 /* queued until WAN line goes up/down */

#define Dbg                              (DEBUG_TRACE_IPX)

extern BOOLEAN WorkerRunning;   //  From timer.c

extern POBJECT_TYPE *IoFileObjectType;

typedef TA_IPX_ADDRESS UNALIGNED *PUTA_IPX_ADDRESS;

typedef struct _ADDRESS_INFORMATION {
    ULONG ActivityCount;
    TA_IPX_ADDRESS NetworkName;
    ULONG Unused;   // Junk needed to work around streams NWLINK bug.
} ADDRESS_INFORMATION, *PADDRESS_INFORMATION;

//
//  Handle difference between NT1.0 and use of ntifs.h
//
#ifdef IFS
    #define ATTACHPROCESS(_X) KeAttachProcess(_X);
#else
    #define ATTACHPROCESS(_X) KeAttachProcess(&(_X)->Pcb);
#endif

NTSTATUS
SubmitTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
CompletionEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
QueryAddressInformation(
    IN PIRP_CONTEXT pIrpContext,
    IN PNW_TDI_STRUCT pTdiStruct,
    OUT PADDRESS_INFORMATION AddressInformation
    );

NTSTATUS
QueryProviderInformation(
    IN PIRP_CONTEXT pIrpContext,
    IN PNW_TDI_STRUCT pTdiStruct,
    OUT PTDI_PROVIDER_INFO ProviderInfo
    );

USHORT
GetSocketNumber(
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc
    );

NTSTATUS
SetTransportOption(
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc,
    IN ULONG Option
    );

#ifndef QFE_BUILD

NTSTATUS
CompletionLineChange(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif
#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, IPX_Get_Local_Target )
#pragma alloc_text( PAGE, IPX_Get_Internetwork_Address )
#pragma alloc_text( PAGE, IPX_Get_Interval_Marker )
#pragma alloc_text( PAGE, IPX_Open_Socket )
#pragma alloc_text( PAGE, IPX_Close_Socket )
#pragma alloc_text( PAGE, IpxOpen )
#pragma alloc_text( PAGE, IpxOpenHandle )
#pragma alloc_text( PAGE, BuildIpxAddressEa )
#pragma alloc_text( PAGE, IpxClose )
#pragma alloc_text( PAGE, SetEventHandler )
#pragma alloc_text( PAGE, SubmitTdiRequest )
#pragma alloc_text( PAGE, GetSocketNumber )
#pragma alloc_text( PAGE, GetMaximumPacketSize )
#pragma alloc_text( PAGE, QueryAddressInformation )
#pragma alloc_text( PAGE, QueryProviderInformation )
#pragma alloc_text( PAGE, SetTransportOption )
#pragma alloc_text( PAGE, GetNewRoute )
#ifndef QFE_BUILD
#pragma alloc_text( PAGE, SubmitLineChangeRequest )
#pragma alloc_text( PAGE, FspProcessLineChange )
#endif

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, CompletionEvent )
#endif

#endif

#if 0  // Not pageable
BuildIpxAddress
CompletionLineChange

// see ifndef QFE_BUILD above

#endif


NTSTATUS
IPX_Get_Local_Target(
    IN IPXaddress* RemoteAddress,
    OUT NodeAddress* LocalTarget,
    OUT word* Ticks
    )
/*++

Routine Description:

    Determine the address in the caller's own network to which to transmit
    in order to reach the specified machine.

    This is not required for NT since the IPX transport handles the
    issue of determining routing between this machine and the remote
    address.

Arguments:

    RemoteAddress - Supplies the remote computers address
    NodeAddress - Where to store the intermediate machine address
    Ticks - Returns the expected number of ticks to reach the remote address

Return Value:

    status of the operation

--*/
{
    PAGED_CODE();

    DebugTrace(0, Dbg, "IPX_Get_Local_Target\n", 0);
    return STATUS_NOT_IMPLEMENTED;
}


VOID
IPX_Get_Internetwork_Address(
    OUT IPXaddress* LocalAddress
    )
/*++

Routine Description:

    Determine the callers full address in a set of interconnected networks.
    in order to reach the specified machine.

    This is not required for NT since the IPX transport handles the
    issue of determining routing between this machine and the remote
    address.

Arguments:

    LocalAddress - Where to store the local address

Return Value:

    none

--*/
{
    PAGED_CODE();

    DebugTrace(0, Dbg, "IPX_Get_Internetwork_Address\n", 0);
    RtlFillMemory(LocalAddress, sizeof(IPXaddress), 0xff);
}


word
IPX_Get_Interval_Marker(
    VOID
    )
/*++

Routine Description:

    Determine the interval marker in clock ticks.

Arguments:

Return Value:

    interval marker

--*/
{
    PAGED_CODE();

    DebugTrace(0, Dbg, "IPX_Get_Interval_Marker\n", 0);
    return 0xff;
}


NTSTATUS
IPX_Open_Socket(
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc
    )
/*++

Routine Description:

    Open a local socket to be used for a conection to a remote server.

Arguments:

    pIrpC - supplies the irp context for the request creating the socket.

    pTdiStruc - supplies where to record the handle and both device and file
        object pointers

Return Value:

    0 success

--*/
{
    NTSTATUS Status;
    UCHAR NetworkName[  sizeof( FILE_FULL_EA_INFORMATION )-1 +
                        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                        sizeof(TA_IPX_ADDRESS)];

    static UCHAR LocalNodeAddress[6] = {0,0,0,0,0,0};

    PAGED_CODE();

    DebugTrace(+1, Dbg, "IPX_Open_Socket %X\n", pTdiStruc->Socket);

    //
    //  Let the transport decide the network number and node address
    //  if the caller specified socket 0.  This will allow the transport
    //  to use whatever local adapters are available to get to the
    //  remote server.
    //

    BuildIpxAddressEa( (ULONG)0,
         LocalNodeAddress,
         (USHORT)pTdiStruc->Socket,
         NetworkName );

    Status = IpxOpenHandle( &pTdiStruc->Handle,
                             &pTdiStruc->pDeviceObject,
                             &pTdiStruc->pFileObject,
                             NetworkName,
                             FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                             TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                             sizeof(TA_IPX_ADDRESS));

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    if ( pTdiStruc->Socket == 0 ) {

        //
        //  Find out the socket number assigned by the transport
        //

        pTdiStruc->Socket = GetSocketNumber( pIrpC, pTdiStruc );
        DebugTrace(0, Dbg, "Assigned socket number %X\n", pTdiStruc->Socket );
    }

    //
    //  Tell transport to accept packet type being set in the connection
    //  information provided with the send datagram. Transport reports
    //  the packet type similarly on receive datagram.
    //

    Status = SetTransportOption(
                 pIrpC,
                 pTdiStruc,
                 MIPX_SENDPTYPE );

    DebugTrace(-1, Dbg, "                %X\n", Status );
    return Status;
}



VOID
IPX_Close_Socket(
    IN PNW_TDI_STRUCT pTdiStruc
    )
/*++

Routine Description:

    Terminate a connection over the network.

Arguments:

    pTdiStruc - supplies where to record the handle and both device and file
        object pointers

Return Value:

    none

--*/
{
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "IPX_Close_Socket %x\n", pTdiStruc->Socket);

    if ( pTdiStruc->Handle == NULL ) {
        return;
    }

    ObDereferenceObject( pTdiStruc->pFileObject );

    //
    //  Attach to the redirector's FSP to allow the handle for the
    //  connection to hang around.
    //

    if (PsGetCurrentProcess() != FspProcess) {
        ATTACHPROCESS(FspProcess);
        ProcessAttached = TRUE;
    }

    ZwClose( pTdiStruc->Handle );

    if (ProcessAttached) {
        //
        //  Now re-attach back to our original process
        //

        KeDetachProcess();
    }

    pTdiStruc->Handle = NULL;

    pTdiStruc->pFileObject = NULL;

    DebugTrace(-1, Dbg, "IPX_Close_Socket\n", 0);
    return;
}


NTSTATUS
IpxOpen(
    VOID
    )
/*++

Routine Description:

    Open handle to the Ipx transport.

Arguments:

    none.

Return Value:

    none

--*/
{
    NTSTATUS Status;

    Status = IpxOpenHandle( &IpxHandle,
                            &pIpxDeviceObject,
                            &pIpxFileObject,
                            NULL,
                            0 );

    DebugTrace(-1, Dbg, "IpxOpen of local node address %X\n", Status);
    return Status;
}


NTSTATUS
IpxOpenHandle(
    OUT PHANDLE pHandle,
    OUT PDEVICE_OBJECT* ppDeviceObject,
    OUT PFILE_OBJECT* ppFileObject,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )
/*++

Routine Description:

    Open handle to the Ipx transport.

Arguments:

    OUT Handle - The handle to the transport if return value is NT_SUCCESS

Return Value:

    none

--*/
{
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "IpxOpenHandle\n", 0);

    *pHandle = NULL;

    if (IpxTransportName.Buffer == NULL) {

        //
        // we are being called with an open ipx when transport is not bound
        //

        Status = STATUS_CONNECTION_INVALID ;
        DebugTrace(-1, Dbg, "IpxOpenHandle %X\n", Status);
        return Status ;
    }

    InitializeObjectAttributes (&AddressAttributes,
                                &IpxTransportName,
                                OBJ_CASE_INSENSITIVE,// Attributes
                                NULL,           // RootDirectory
                                NULL);          // SecurityDescriptor

    //
    //  Attach to the redirector's FSP to allow the handle for the
    //  connection to hang around. Normally we create 3 handles at once
    //  so the outer code already has done this to avoid the expensive
    //  attach procedure.
    //

    if (PsGetCurrentProcess() != FspProcess) {
        ATTACHPROCESS(FspProcess);
        ProcessAttached = TRUE;
    }

    Status = ZwCreateFile(pHandle,
                                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                &AddressAttributes, // Object Attributes
                                &IoStatusBlock, // Final I/O status block
                                NULL,           // Allocation Size
                                FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                FILE_SHARE_READ,// Sharing attributes
                                FILE_OPEN_IF,   // Create disposition
                                0,              // CreateOptions
                                EaBuffer,EaLength);

    if (!NT_SUCCESS(Status) ||
        !NT_SUCCESS(Status = IoStatusBlock.Status)) {

        goto error_cleanup2;

    }

    //
    //  Obtain a referenced pointer to the file object.
    //
    Status = ObReferenceObjectByHandle (
                                *pHandle,
                                0,
                                NULL,
                                KernelMode,
                                ppFileObject,
                                NULL
                                );

    if (!NT_SUCCESS(Status)) {

        goto error_cleanup;

    }

    if (ProcessAttached) {

        //
        //  Now re-attach back to our original process
        //

        KeDetachProcess();
    }

    *ppDeviceObject = IoGetRelatedDeviceObject( *ppFileObject );

    DebugTrace(-1, Dbg, "IpxOpenHandle %X\n", Status);
    return Status;

error_cleanup2:

   if ( *pHandle != NULL ) {
      
      ZwClose( *pHandle );
      *pHandle = NULL;
   }

error_cleanup:
    if (ProcessAttached) {

        //
        //  Now re-attach back to our original process
        //

        KeDetachProcess();
    }

    DebugTrace(-1, Dbg, "IpxOpenHandle %X\n", Status);
    return Status;
}


VOID
BuildIpxAddress(
    IN ULONG NetworkAddress,
    IN PUCHAR NodeAddress,
    IN USHORT Socket,
    OUT PTA_IPX_ADDRESS NetworkName
    )

/*++

Routine Description:

    This routine builds a TA_NETBIOS_ADDRESS structure in the locations pointed
    to by NetworkName. All fields are filled out.

Arguments:
    NetworkAddress - Supplies the network number
    NodeAddress - Supplies the node number
    Socket - The socket number (in Hi-Lo order)
    NetworkName - Supplies the structure to place the address

Return Value:

    none.

--*/

{
    //  Warn compiler that TAAddressCount may be mis-aligned.
    PUTA_IPX_ADDRESS UNetworkName = (PUTA_IPX_ADDRESS)NetworkName;

    DebugTrace(+0, Dbg, "BuildIpxAddress\n", 0);

    UNetworkName->TAAddressCount = 1;
    UNetworkName->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    UNetworkName->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IPX;

    RtlMoveMemory (
        UNetworkName->Address[0].Address[0].NodeAddress,
        NodeAddress,
        6);
    UNetworkName->Address[0].Address[0].NetworkAddress = NetworkAddress;
    UNetworkName->Address[0].Address[0].Socket = Socket;

} /* TdiBuildIpxAddress */


VOID
BuildIpxAddressEa (
    IN ULONG NetworkAddress,
    IN PUCHAR NodeAddress,
    IN USHORT Socket,
    OUT PVOID NetworkName
    )

/*++

Routine Description:

   Builds an EA describing a Netbios address in the buffer supplied by the
   user.

Arguments:

    NetworkAddress - Supplies the network number
    NodeAddress - Supplies the node number
    Socket -
    NetworkName - The Ea structure that describes the input parameters.

Return Value:

    An informative error code if something goes wrong. STATUS_SUCCESS if the
    ea is built properly.

--*/

{
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PTA_IPX_ADDRESS TAAddress;
    ULONG Length;

    DebugTrace(+0, Dbg, "BuildIpxAddressEa\n", 0);

    Length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof (TA_IPX_ADDRESS);
    EaBuffer = (PFILE_FULL_EA_INFORMATION)NetworkName;

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = sizeof (TA_IPX_ADDRESS);

    RtlCopyMemory (
        EaBuffer->EaName,
        TdiTransportAddress,
        EaBuffer->EaNameLength + 1);

    TAAddress = (PTA_IPX_ADDRESS)&EaBuffer->EaName[EaBuffer->EaNameLength+1];

    BuildIpxAddress(
        NetworkAddress,
        NodeAddress,
        Socket,
        TAAddress);


    return;

}


VOID
IpxClose(
    VOID
    )
/*++

Routine Description:

    Close handle to the Ipx transport.

Arguments:

    none

Return Value:

    none

--*/
{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "IpxClose...\n", 0);
    if ( pIpxFileObject ) {
        ObDereferenceObject( pIpxFileObject );
        pIpxFileObject = NULL;
    }

//    if ( pIpxDeviceObject ) {
//        ObDereferenceObject( pIpxDeviceObject );
//        pIpxDeviceObject = NULL;
//    }

    pIpxDeviceObject = NULL;

    if ( IpxTransportName.Buffer != NULL ) {
        FREE_POOL( IpxTransportName.Buffer );
        IpxTransportName.Buffer = NULL;
    }

    if (IpxHandle) {
        //
        //  Attach to the redirector's FSP to allow the handle for the
        //  connection to hang around.
        //

        if (PsGetCurrentProcess() != FspProcess) {
            ATTACHPROCESS(FspProcess);
            ZwClose( IpxHandle );
            KeDetachProcess();
        } else {
            ZwClose( IpxHandle );
        }

        IpxHandle = NULL;
    }
    DebugTrace(-1, Dbg, "IpxClose\n", 0);

}


NTSTATUS
SetEventHandler (
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc,
    IN ULONG EventType,
    IN PVOID pEventHandler,
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    pIrpC - supplies an Irp among other things.

    pTdiStruc - supplies the handle and both device and file object pointers
        to the transport.

    IN ULONG EventType, - Supplies the type of event.

    IN PVOID pEventHandler - Supplies the event handler.

    IN PVOID pContext - Supplies the context to be supplied to the event
            handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    TdiBuildSetEventHandler(pIrpC->pOriginalIrp,
                            pTdiStruc->pDeviceObject,
                            pTdiStruc->pFileObject,
                            NULL,
                            NULL,
                            EventType,
                            pEventHandler,
                            pContext);

    Status = SubmitTdiRequest(pTdiStruc->pDeviceObject,
                             pIrpC->pOriginalIrp);

    return Status;
}


NTSTATUS
SubmitTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PDevice_OBJECT DeviceObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    NTSTATUS Status;
    KEVENT Event;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "SubmitTdiRequest\n", 0);

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(pIrp, CompletionEvent, &Event, TRUE, TRUE, TRUE);

    //
    //  Submit the request
    //

    Status = IoCallDriver(pDeviceObject, pIrp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        DebugTrace(-1, Dbg, "SubmitTdiRequest %X\n", Status);
        return Status;
    }

    if (Status == STATUS_PENDING) {

        DebugTrace(+0, Dbg, "Waiting....\n", 0);

        Status = KeWaitForSingleObject(&Event,  // Object to wait on.
                                    Executive,  // Reason for waiting
                                    KernelMode, // Processor mode
                                    FALSE,      // Alertable
                                    NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            DebugTrace(-1, Dbg, "SubmitTdiRequest could not wait %X\n", Status);
            return Status;
        }

        Status = pIrp->IoStatus.Status;
    }

    DebugTrace(-1, Dbg, "SubmitTdiRequest %X\n", Status);

    return(Status);
}


NTSTATUS
CompletionEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    DebugTrace( 0, Dbg, "CompletionEvent\n", 0 );

    KeSetEvent((PKEVENT )Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}


USHORT
GetSocketNumber(
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc
    )
/*++

Routine Description:

    Use a TDI_ACTION to set the Option.

Arguments:

    pIrpC - supplies an Irp among other things.

    pTdiStruc - supplies the handle and both device and file object pointers
        to the transport.

    Option - supplies the option to set.

Return Value:

    0 failed otherwise the socket number.

--*/
{
    ADDRESS_INFORMATION AddressInfo;
    NTSTATUS Status;
    USHORT SocketNumber;

    PAGED_CODE();

    Status = QueryAddressInformation( pIrpC, pTdiStruc, &AddressInfo );

    if ( !NT_SUCCESS( Status ) ) {
        SocketNumber = 0;
    } else {
        SocketNumber = AddressInfo.NetworkName.Address[0].Address[0].Socket;

        RtlCopyMemory( &OurAddress,
            &AddressInfo.NetworkName.Address[0].Address[0],
            sizeof(TDI_ADDRESS_IPX));

    }

    return( SocketNumber );
}


NTSTATUS
GetMaximumPacketSize(
    IN PIRP_CONTEXT pIrpContext,
    IN PNW_TDI_STRUCT pTdiStruct,
    OUT PULONG pMaximumPacketSize
    )
/*++

Routine Description:

    Query the maximum packet size for this network.

Arguments:

    pIrpContext - supplies an Irp among other things.

    pTdiStruct - supplies the handle and both device and file object pointers
        to the transport.

    pMaximumPacketSize - Returns the maximum packet size for the network.

Return Value:

    The status of the query.

--*/
{
    TDI_PROVIDER_INFO ProviderInfo;

    NTSTATUS Status;

    PAGED_CODE();

    Status = QueryProviderInformation( pIrpContext, pTdiStruct, &ProviderInfo );

    if ( NT_SUCCESS( Status ) ) {
        *pMaximumPacketSize = ProviderInfo.MaxDatagramSize;
    }

    return( Status );
}

NTSTATUS
QueryAddressInformation(
    PIRP_CONTEXT pIrpContext,
    IN PNW_TDI_STRUCT pTdiStruct,
    PADDRESS_INFORMATION AddressInformation
    )
{
    NTSTATUS Status;

    PMDL MdlSave = pIrpContext->pOriginalIrp->MdlAddress;
    PMDL Mdl;

    PAGED_CODE();

    Mdl = ALLOCATE_MDL(
              AddressInformation,
              sizeof( *AddressInformation ),
              FALSE,  // Secondary Buffer
              FALSE,  // Charge Quota
              NULL);

    if ( Mdl == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {
        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        FREE_MDL( Mdl );
        return GetExceptionCode();
    }

    TdiBuildQueryInformation(
        pIrpContext->pOriginalIrp,
        pTdiStruct->pDeviceObject,
        pTdiStruct->pFileObject,
        CompletionEvent,
        NULL,
        TDI_QUERY_ADDRESS_INFO,
        Mdl);

    Status = SubmitTdiRequest( pTdiStruct->pDeviceObject, pIrpContext->pOriginalIrp);

    pIrpContext->pOriginalIrp->MdlAddress = MdlSave;
    MmUnlockPages( Mdl );
    FREE_MDL( Mdl );

    return( Status );
}


NTSTATUS
QueryProviderInformation(
    IN PIRP_CONTEXT pIrpContext,
    IN PNW_TDI_STRUCT pTdiStruct,
    PTDI_PROVIDER_INFO ProviderInfo
    )
{
    NTSTATUS Status;

    PMDL MdlSave = pIrpContext->pOriginalIrp->MdlAddress;
    PMDL Mdl;

    PAGED_CODE();

    Mdl = ALLOCATE_MDL(
              ProviderInfo,
              sizeof( *ProviderInfo ),
              FALSE,  // Secondary Buffer
              FALSE,  // Charge Quota
              NULL);

    if ( Mdl == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {
        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        FREE_MDL( Mdl );
        return GetExceptionCode();
    }

    TdiBuildQueryInformation(
        pIrpContext->pOriginalIrp,
        pTdiStruct->pDeviceObject,
        pTdiStruct->pFileObject,
        CompletionEvent,
        NULL,
        TDI_QUERY_PROVIDER_INFO,
        Mdl);

    Status = SubmitTdiRequest(pTdiStruct->pDeviceObject, pIrpContext->pOriginalIrp);

    pIrpContext->pOriginalIrp->MdlAddress = MdlSave;
    MmUnlockPages( Mdl );
    FREE_MDL( Mdl );

    return( Status );
}



NTSTATUS
SetTransportOption(
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc,
    IN ULONG Option
    )
/*++

Routine Description:

    Use a TDI_ACTION to set the Option.

Arguments:

    pIrpC - supplies an Irp among other things.

    pTdiStruc - supplies the handle and both device and file object pointers
        to the transport.

    Option - supplies the option to set.

Return Value:

    0 success

--*/
{
    static struct {
        TDI_ACTION_HEADER Header;
        BOOLEAN DatagramOption;
        ULONG BufferLength;
        ULONG Option;
    } SetPacketType = {
        IPX_ID,
        0,              // ActionCode
        0,              // Reserved
        TRUE,           // DatagramOption
        sizeof(ULONG)   // BufferLength
        };

    KEVENT Event;
    NTSTATUS Status;

    PIRP pIrp = pIrpC->pOriginalIrp;

    //
    //  Save the original MDL and System buffer address, to restore
    //  after the IRP completes.
    //
    //  We use both the MDL and SystemBuffer because NWLINK assumes that
    //  we are using SystemBuffer even though we are supposed to use the
    //  MDL to pass a pointer to the action buffer.
    //

    PMDL MdlSave = pIrp->MdlAddress;
    PCHAR SystemBufferSave = pIrp->AssociatedIrp.SystemBuffer;

    PMDL Mdl;

    PAGED_CODE();

    Mdl = ALLOCATE_MDL(
              &SetPacketType,
              sizeof( SetPacketType ),
              FALSE,  // Secondary Buffer
              FALSE,  // Charge Quota
              NULL );

    if ( Mdl == NULL ) {
        IPX_Close_Socket( pTdiStruc );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SetPacketType.Option = Option;

    try {
        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        FREE_MDL( Mdl );
        return GetExceptionCode();
    }

    KeInitializeEvent (
        &Event,
        SynchronizationEvent,
        FALSE);

    TdiBuildAction(
        pIrp,
        pTdiStruc->pDeviceObject,
        pTdiStruc->pFileObject,
        CompletionEvent,
        &Event,
        Mdl );

    //
    //  Set up the system buffer for NWLINK.
    //

    pIrp->AssociatedIrp.SystemBuffer = &SetPacketType;

    Status = IoCallDriver (pTdiStruc->pDeviceObject, pIrp);

    if ( Status == STATUS_PENDING ) {
        Status = KeWaitForSingleObject (
                     &Event,
                     Executive,
                     KernelMode,
                     FALSE,
                     NULL );

        if ( NT_SUCCESS( Status ) ) {
            Status = pIrp->IoStatus.Status;
        }
    }

    //
    //  Now restore the system buffer and MDL address in the IRP
    //

    pIrp->AssociatedIrp.SystemBuffer = SystemBufferSave;
    pIrp->MdlAddress = MdlSave;

    MmUnlockPages( Mdl );
    FREE_MDL( Mdl );

    return Status;
}


NTSTATUS
GetNewRoute(
    IN PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    Use a TDI_ACTION to get a new route.

Arguments:

    pIrpContext - Supplies IRP context information.

Return Value:

    The status of the operation.

--*/
{
    struct {
        TDI_ACTION_HEADER Header;
        BOOLEAN DatagramOption;
        ULONG BufferLength;
        ULONG Option;
        ULONG info_netnum;
        USHORT info_hopcount;
        USHORT info_netdelay;
        int info_cardnum;
        UCHAR info_router[6];
    } ReRipRequest = {
        IPX_ID,
        0,              // ActionCode
        0,              // Reserved
        TRUE,           // DatagramOption
        24              // Buffer length (not including header)
    };

    KEVENT Event;
    NTSTATUS Status;

    PIRP pIrp = pIrpContext->pOriginalIrp;

    //
    //  Save the original MDL and System buffer address, to restore
    //  after the IRP completes.
    //
    //  We use both the MDL and SystemBuffer because NWLINK assumes that
    //  we are using SystemBuffer even though we are supposed to use the
    //  MDL to pass a pointer to the action buffer.
    //

    PMDL MdlSave = pIrp->MdlAddress;
    PCHAR SystemBufferSave = pIrp->AssociatedIrp.SystemBuffer;

    PMDL Mdl;

    PAGED_CODE();

    Mdl = ALLOCATE_MDL(
              &ReRipRequest,
              sizeof( ReRipRequest ),
              FALSE,  // Secondary Buffer
              FALSE,  // Charge Quota
              NULL );

    if ( Mdl == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ReRipRequest.Option = MIPX_RERIPNETNUM;
    ReRipRequest.info_netnum = pIrpContext->pNpScb->ServerAddress.Net;

    try {
        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        FREE_MDL( Mdl );
        return GetExceptionCode();
    }

    KeInitializeEvent (
        &Event,
        SynchronizationEvent,
        FALSE);

    TdiBuildAction(
        pIrp,
        pIrpContext->pNpScb->Server.pDeviceObject,
        pIrpContext->pNpScb->Server.pFileObject,
        CompletionEvent,
        &Event,
        Mdl );

    //
    //  Set up the system buffer for NWLINK.
    //

    pIrp->AssociatedIrp.SystemBuffer = &ReRipRequest;

    Status = IoCallDriver ( pIrpContext->pNpScb->Server.pDeviceObject, pIrp);

    if ( Status == STATUS_PENDING ) {
        Status = KeWaitForSingleObject (
                     &Event,
                     Executive,
                     KernelMode,
                     FALSE,
                     NULL );

        if ( NT_SUCCESS( Status ) ) {
            Status = pIrp->IoStatus.Status;
        }
    }

    //
    //  Now restore the system buffer and MDL address in the IRP
    //

    pIrp->AssociatedIrp.SystemBuffer = SystemBufferSave;
    pIrp->MdlAddress = MdlSave;

    MmUnlockPages( Mdl );
    FREE_MDL( Mdl );

    return Status;
}


NTSTATUS
GetTickCount(
    IN PIRP_CONTEXT pIrpContext,
    OUT PUSHORT TickCount
    )
/*++

Routine Description:

    Use a TDI_ACTION to get a new route.

Arguments:

    pIrpContext - Supplies IRP context information.

Return Value:

    The status of the operation.

--*/
{
    struct {
        TDI_ACTION_HEADER Header;
        BOOLEAN DatagramOption;
        ULONG BufferLength;
        ULONG Option;
        IPX_NETNUM_DATA NetNumData;
    } GetTickCountInput = {
        IPX_ID,
        0,              // ActionCode
        0,              // Reserved
        TRUE,           // DatagramOption
        sizeof( IPX_NETNUM_DATA) + 2 * sizeof( ULONG )
    };

    struct _GET_TICK_COUNT_OUTPUT {
        ULONG Option;
        IPX_NETNUM_DATA NetNumData;
    };

    struct _GET_TICK_COUNT_OUTPUT *GetTickCountOutput;

    KEVENT Event;
    NTSTATUS Status;

    PIRP pIrp = pIrpContext->pOriginalIrp;

    //
    //  Save the original MDL and System buffer address, to restore
    //  after the IRP completes.
    //
    //  We use both the MDL and SystemBuffer because NWLINK assumes that
    //  we are using SystemBuffer even though we are supposed to use the
    //  MDL to pass a pointer to the action buffer.
    //

    PMDL MdlSave = pIrp->MdlAddress;
    PCHAR SystemBufferSave = pIrp->AssociatedIrp.SystemBuffer;

    PMDL Mdl;

    PAGED_CODE();

    Mdl = ALLOCATE_MDL(
              &GetTickCountInput,
              sizeof( GetTickCountInput ),
              FALSE,  // Secondary Buffer
              FALSE,  // Charge Quota
              NULL );

    if ( Mdl == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    GetTickCountInput.Option = MIPX_GETNETINFO;
    *(PULONG)GetTickCountInput.NetNumData.netnum = pIrpContext->pNpScb->ServerAddress.Net;

    try {
        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        FREE_MDL( Mdl );
        return GetExceptionCode();
    }

    KeInitializeEvent (
        &Event,
        SynchronizationEvent,
        FALSE);

    TdiBuildAction(
        pIrp,
        pIrpContext->pNpScb->Server.pDeviceObject,
        pIrpContext->pNpScb->Server.pFileObject,
        CompletionEvent,
        &Event,
        Mdl );

    //
    //  Set up the system buffer for NWLINK.
    //

    pIrp->AssociatedIrp.SystemBuffer = &GetTickCountInput;

    Status = IoCallDriver ( pIrpContext->pNpScb->Server.pDeviceObject, pIrp);

    if ( Status == STATUS_PENDING ) {
        Status = KeWaitForSingleObject (
                     &Event,
                     Executive,
                     KernelMode,
                     FALSE,
                     NULL );

        if ( NT_SUCCESS( Status ) ) {
            Status = pIrp->IoStatus.Status;
        }
    }

    DebugTrace( +0, Dbg, "Get Tick Count, net= %x\n", pIrpContext->pNpScb->ServerAddress.Net );

    if ( NT_SUCCESS( Status ) ) {

        //
        //  HACK-o-rama.   Streams and non-streams IPX have different output
        //  buffer formats.   For now accept both.
        //

        if ( IpxTransportName.Length == 32 ) {

            // ISNIPX format

            *TickCount = GetTickCountInput.NetNumData.netdelay;
        } else {

            //  NWLINK format

            GetTickCountOutput = (struct _GET_TICK_COUNT_OUTPUT *)&GetTickCountInput;
            *TickCount = GetTickCountOutput->NetNumData.netdelay;
        }

        DebugTrace( +0, Dbg, "Tick Count = %d\n", *TickCount );
        
        //
        // Don't let the transport have us wait forever.
        //

        if ( *TickCount > 600 ) {
            ASSERT( FALSE );
        }

    } else {
        DebugTrace( +0, Dbg, "GetTickCount failed, status = %X\n", Status );
    }

    //
    //  Now restore the system buffer and MDL address in the IRP
    //

    pIrp->AssociatedIrp.SystemBuffer = SystemBufferSave;
    pIrp->MdlAddress = MdlSave;

    MmUnlockPages( Mdl );
    FREE_MDL( Mdl );

    return Status;
}

#ifndef QFE_BUILD

static PIRP LineChangeIrp = NULL;


NTSTATUS
SubmitLineChangeRequest(
    VOID
    )
/*++

Routine Description:

    Use a TDI_ACTION to get a new route.

Arguments:

    pIrpContext - Supplies IRP context information.

Return Value:

    The status of the operation.

--*/
{
   NTSTATUS Status;

    struct _LINE_CHANGE {
        TDI_ACTION_HEADER Header;
        BOOLEAN DatagramOption;
        ULONG BufferLength;
        ULONG Option;
    } *LineChangeInput;

    PIRP pIrp;
    PMDL Mdl;

    PAGED_CODE();

    LineChangeInput = ALLOCATE_POOL( NonPagedPool, sizeof( struct _LINE_CHANGE ) );

    if (!LineChangeInput) {
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Complete initialization of the request, and allocate and build an
    //  MDL for the request input buffer.
    //

    LineChangeInput->Header.TransportId = IPX_ID;
    LineChangeInput->Header.ActionCode = 0;
    LineChangeInput->Header.Reserved = 0;
    LineChangeInput->DatagramOption = 2;
    LineChangeInput->BufferLength = 2 * sizeof( ULONG );
    LineChangeInput->Option = MIPX_LINECHANGE;

    Mdl = ALLOCATE_MDL(
              LineChangeInput,
              sizeof( *LineChangeInput ),
              FALSE,  // Secondary Buffer
              FALSE,  // Charge Quota
              NULL );

    if ( Mdl == NULL ) {
        FREE_POOL( LineChangeInput );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pIrp = ALLOCATE_IRP( pIpxDeviceObject->StackSize, FALSE );

    if ( pIrp == NULL ) {
        FREE_POOL( LineChangeInput );
        FREE_MDL( Mdl );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Remember this IRP so that we can cancel it.
    //

    LineChangeIrp = pIrp;

    MmBuildMdlForNonPagedPool( Mdl );

    //
    //  Build and submit a TDI request packet.
    //

    TdiBuildAction(
        pIrp,
        pIpxDeviceObject,
        pIpxFileObject,
        CompletionLineChange,
        NULL,
        Mdl );

    Status = IoCallDriver ( pIpxDeviceObject, pIrp );

    return( Status );
}



NTSTATUS
CompletionLineChange(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the transport completes a line change IRP.
    This means that we have switched nets, and that we should mark
    all of our servers disconnected.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - unused.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PMDL Mdl;
    PWORK_QUEUE_ITEM WorkQueueItem;

    DebugTrace( 0, Dbg, "CompletionLineChange\n", 0 );

    Mdl = Irp->MdlAddress;

    if ( !NT_SUCCESS( Irp->IoStatus.Status ) ) {
        FREE_POOL( Mdl->MappedSystemVa );
        FREE_MDL( Mdl );
        FREE_IRP( Irp );
        return( STATUS_MORE_PROCESSING_REQUIRED );
    }

    //
    // If the scavenger is running, simply make a note that
    // we need to do this when it is finished.
    //

    KeAcquireSpinLockAtDpcLevel( &NwScavengerSpinLock );

    if ( WorkerRunning ) {

       if ( ( DelayedProcessLineChange != FALSE ) &&
            ( DelayedLineChangeIrp != NULL ) ) {

           //
           // We've already got a line change.  Dump this one.
           //

           KeReleaseSpinLockFromDpcLevel( &NwScavengerSpinLock );

           DebugTrace( 0, Dbg, "Dumping an additional line change request.\n", 0 );

           FREE_POOL( Mdl->MappedSystemVa );
           FREE_MDL( Mdl );
           FREE_IRP( Irp );
           return( STATUS_MORE_PROCESSING_REQUIRED );

       } else {

           DebugTrace( 0, Dbg, "Delaying a line change request.\n", 0 );

           DelayedProcessLineChange = TRUE;
           DelayedLineChangeIrp = Irp;

           KeReleaseSpinLockFromDpcLevel( &NwScavengerSpinLock );
           return STATUS_MORE_PROCESSING_REQUIRED;

       }

    } else {

       //
       // Don't let the scavenger start up while we're running.
       //

       WorkerRunning = TRUE;
       KeReleaseSpinLockFromDpcLevel( &NwScavengerSpinLock );
    }

    WorkQueueItem = ALLOCATE_POOL( NonPagedPool, sizeof( *WorkQueueItem ) );
    if ( WorkQueueItem == NULL ) {
        FREE_POOL( Mdl->MappedSystemVa );
        FREE_MDL( Mdl );
        FREE_IRP( Irp );
        return( STATUS_MORE_PROCESSING_REQUIRED );
    }

    //
    //  Use the user buffer field as a convenient place to remember where
    //  the address of the WorkQueueItem.  We can get away with this since
    //  we don't let this IRP complete.
    //

    Irp->UserBuffer = WorkQueueItem;

    //
    //  Process the line change in the FSP.
    //

    ExInitializeWorkItem( WorkQueueItem, FspProcessLineChange, Irp );
    ExQueueWorkItem( WorkQueueItem, DelayedWorkQueue );

    return( STATUS_MORE_PROCESSING_REQUIRED );
}

VOID
FspProcessLineChange(
    IN PVOID Context
    )
{
    PIRP Irp;
    ULONG ActiveHandles;

    NwReferenceUnlockableCodeSection();

    Irp = (PIRP)Context;

    //
    //  Free the work queue item
    //

    FREE_POOL( Irp->UserBuffer );
    Irp->UserBuffer = NULL;

    //
    //  Invalid all remote handles
    //

    ActiveHandles = NwInvalidateAllHandles(NULL, NULL);

    //
    // Now that we're done walking all the servers, it's safe
    // to let the scavenger run again.
    //

    WorkerRunning = FALSE;

    //
    //  Resubmit the IRP
    //

    TdiBuildAction(
        Irp,
        pIpxDeviceObject,
        pIpxFileObject,
        CompletionLineChange,
        NULL,
        Irp->MdlAddress );

    IoCallDriver ( pIpxDeviceObject, Irp );

    NwDereferenceUnlockableCodeSection ();
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\fspdisp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the NetWare
    Fsp

Author:

    Colin Watson     [ColinW]    15-Dec-1992

Revision History:

--*/

#include "Procs.h"

//
//  Define our local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSP_DISPATCHER)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFspDispatch )
#endif

#if 0  //  Not pageable
NwPostToFsp
#endif


VOID
NwFspDispatch (
    IN PVOID Context
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:


    Context - Supplies the thread id.

Return Value:

    None - This routine never exits

--*/

{
    PIRP Irp;
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    PPOST_PROCESSOR PostProcessRoutine;
    BOOLEAN TopLevel;

    IrpContext = (PIRP_CONTEXT)Context;

    Irp = IrpContext->pOriginalIrp;
    ClearFlag( IrpContext->Flags, IRP_FLAG_IN_FSD );

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate FSP routine or case on the minor
    //  function and then call the FSP routine.  The FSP routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble (e.g., if NwReadSectorsSync has trouble).
    //


    DebugTrace(0, Dbg, "NwFspDispatch: Irp = 0x%08lx\n", Irp);

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        //
        //  If we have a run routine for this IRP context, then run it,
        //  if not fall through to the IRP handler.
        //

        if ( IrpContext->PostProcessRoutine != NULL ) {

            PostProcessRoutine = IrpContext->PostProcessRoutine;

            //
            //  Clear the run routine so that we don't run it again.
            //

            IrpContext->PostProcessRoutine = NULL;

            Status = PostProcessRoutine( IrpContext );

        } else {

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            switch ( IrpSp->MajorFunction ) {

            //
            //  For File System Control operations,
            //

            case IRP_MJ_FILE_SYSTEM_CONTROL:

                Status = NwCommonFileSystemControl( IrpContext );
                break;

            //
            //  For any other major operations, return an invalid
            //  request.
            //

            default:

                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;

            }

        }

        //
        //  We're done with this request.  Dequeue the IRP context from
        //  SCB and complete the request.
        //

        if ( Status != STATUS_PENDING ) {
            NwDequeueIrpContext( IrpContext, FALSE );
        }

        NwCompleteRequest( IrpContext, Status );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code.
        //

        (VOID) NwProcessException( IrpContext, GetExceptionCode() );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    return;
}


NTSTATUS
NwPostToFsp (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN MarkIrpPending
    )

/*++

Routine Description:

    This routine post an IRP context to an executive worker thread
    for FSP level processing.

    *** WARNING:  After calling this routine, the caller may no
                  longer access IrpContext.   This routine passes
                  the IrpContext to the FSP which may run and free
                  the IrpContext before this routine returns to the
                  caller.

Arguments:

    IrpContext - Supplies the Irp being processed.

    MarkIrpPending - If true, mark the IRP pending.

Return Value:

    STATUS_PENDING.

--*/

{
    PIRP Irp = IrpContext->pOriginalIrp;

    DebugTrace(0, Dbg, "NwPostToFsp: IrpContext = %X\n", IrpContext );
    DebugTrace(0, Dbg, "PostProcessRoutine = %X\n", IrpContext->PostProcessRoutine );

    if ( MarkIrpPending ) {

        //
        //  Mark this I/O request as being pending.
        //

        IoMarkIrpPending( Irp );
    }

    //
    //  Queue to IRP context to an ex worker thread.
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem, NwFspDispatch, IrpContext );
    ExQueueWorkItem( &IrpContext->WorkQueueItem, DelayedWorkQueue );

    return( STATUS_PENDING );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\init.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    NwInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for NetWare

Author:

    Colin Watson     [ColinW]    15-Dec-1992

Revision History:

--*/

#include "Procs.h"
#include "wdmsec.h"
#define Dbg                              (DEBUG_TRACE_LOAD)

//
// Private declaration because ZwQueryDefaultLocale isn't in any header.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
UnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
GetConfigurationInformation(
    PUNICODE_STRING RegistryPath
    );

VOID
ReadValue(
    HANDLE  ParametersHandle,
    PLONG   pVar,
    PWCHAR  Name
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DriverEntry )
#pragma alloc_text( PAGE, GetConfigurationInformation )
#pragma alloc_text( PAGE, ReadValue )
#endif

#if 0  // Not pageable
UnloadDriver
#endif

#ifdef _PNP_POWER_
extern HANDLE TdiBindingHandle;
#endif

static ULONG IrpStackSize;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the Nw file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING SddlString;
    PAGED_CODE();

    //DbgBreakPoint();

    InitializeAttach( );
    NwInitializeData();
    //NwInitializePidTable();      // Terminal Server code merge - 
                                   // NwInitalizePidTable in the NwAllocateAndInitScb
                                   // Pid table is per SCB base.

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &UnicodeString, DD_NWFS_DEVICE_NAME_U );
    RtlInitUnicodeString( &SddlString, L"D:P(A;;GX;;;WD)(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;LS)(A;;GA;;;NS)(A;;GX;;;RC)" );

    Status = IoCreateDeviceSecure( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_NETWORK_FILE_SYSTEM,
                             FILE_REMOTE_DEVICE,
                             FALSE,
                             &SddlString,
                             NULL,
                             &FileSystemDeviceObject );

    if (!NT_SUCCESS( Status )) {
        Error(EVENT_NWRDR_CANT_CREATE_DEVICE, Status, NULL, 0, 0);
        return Status;
    }

    //
    //  Initialize parameters to the defaults.
    //

    IrpStackSize = NWRDR_IO_STACKSIZE;

    //
    //  Attempt to read config information from the registry
    //

    GetConfigurationInformation( RegistryPath );

    //
    //  Set the stack size.
    //

    FileSystemDeviceObject->StackSize = (CCHAR)IrpStackSize;

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                   = (PDRIVER_DISPATCH)NwFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  = (PDRIVER_DISPATCH)NwFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    = (PDRIVER_DISPATCH)NwFsdClose;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      = (PDRIVER_DISPATCH)NwFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]           = (PDRIVER_DISPATCH)NwFsdDeviceIoControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        = (PDRIVER_DISPATCH)NwFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = (PDRIVER_DISPATCH)NwFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION]   = (PDRIVER_DISPATCH)NwFsdSetVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]        = (PDRIVER_DISPATCH)NwFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_READ]                     = (PDRIVER_DISPATCH)NwFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    = (PDRIVER_DISPATCH)NwFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          = (PDRIVER_DISPATCH)NwFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]             = (PDRIVER_DISPATCH)NwFsdLockControl;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]            = (PDRIVER_DISPATCH)NwFsdFlushBuffers;
    
#ifdef _PNP_POWER_
    DriverObject->MajorFunction[IRP_MJ_PNP]                      = (PDRIVER_DISPATCH)NwFsdProcessPnpIrp;
#endif

/*
    DriverObject->MajorFunction[IRP_MJ_QUERY_EA]                 = (PDRIVER_DISPATCH)NwFsdQueryEa;
    DriverObject->MajorFunction[IRP_MJ_SET_EA]                   = (PDRIVER_DISPATCH)NwFsdSetEa;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                 = (PDRIVER_DISPATCH)NwFsdShutdown;
*/
    DriverObject->DriverUnload = UnloadDriver;

#if NWFASTIO
    DriverObject->FastIoDispatch = &NwFastIoDispatch;

    NwFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    NwFastIoDispatch.FastIoCheckIfPossible =   NULL;
    NwFastIoDispatch.FastIoRead =              NwFastRead;
    NwFastIoDispatch.FastIoWrite =             NwFastWrite;
    NwFastIoDispatch.FastIoQueryBasicInfo =    NwFastQueryBasicInfo;
    NwFastIoDispatch.FastIoQueryStandardInfo = NwFastQueryStandardInfo;
    NwFastIoDispatch.FastIoLock =              NULL;
    NwFastIoDispatch.FastIoUnlockSingle =      NULL;
    NwFastIoDispatch.FastIoUnlockAll =         NULL;
    NwFastIoDispatch.FastIoUnlockAllByKey =    NULL;
    NwFastIoDispatch.FastIoDeviceControl =     NULL;
#endif

    NwInitializeRcb( &NwRcb );

    InitializeIrpContext( );

    NwPermanentNpScb.State = SCB_STATE_DISCONNECTING;

    //
    //  Do a kludge here so that we get to the "real" global variables.
    //

    //NlsLeadByteInfo = *(PUSHORT *)NlsLeadByteInfo;
    //NlsMbCodePageTag = *(*(PBOOLEAN *)&NlsMbCodePageTag);

#ifndef IFS
    FsRtlLegalAnsiCharacterArray = *(PUCHAR *)FsRtlLegalAnsiCharacterArray;
#endif

    //
    //  Register as a file system, notifies filters
    //

    IoRegisterFileSystem(FileSystemDeviceObject);

    DebugTrace(0, Dbg, "NetWare redirector loaded\n", 0);

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}

VOID
UnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the NetWare redirector filesystem.

Arguments:

     DriverObject - pointer to the driver object for the redirector

Return Value:

     None

--*/
{
    KIRQL OldIrql;
    NTSTATUS status;

    //
    // Lock down code
    //
    DebugTrace(0, Dbg, "UnloadDriver called\n", 0);

    //
    //  Unregister as a file system, notifies filters
    //

    IoUnregisterFileSystem(FileSystemDeviceObject);

    //
    // tommye - MS bug 33463
    //
    // Clean up our cached credentials - this fixes a
    // memory leak when we shut down.
    //

    {
        LARGE_INTEGER Unused;

        KeQuerySystemTime( &Unused );

        CleanupSupplementalCredentials(Unused, TRUE);
    }

    NwReferenceUnlockableCodeSection ();

    TerminateWorkerThread();
    
    #ifdef _PNP_POWER_

    //
    // Unregister the bind handler with tdi.
    //

    if ( TdiBindingHandle != NULL ) {
        status = TdiDeregisterPnPHandlers( TdiBindingHandle );
        TdiBindingHandle = NULL;
        DebugTrace(0, Dbg,"TDI binding handle deregistered\n",0);
    }

    #endif
    
    IpxClose();

    IPX_Close_Socket( &NwPermanentNpScb.Server );

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
    RemoveEntryList( &NwPermanentNpScb.ScbLinks );
    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    DestroyAllScb();

    UninitializeIrpContext();
    
    NwDereferenceUnlockableCodeSection ();
    NwUnlockCodeSections(FALSE);
    StopTimer();

    if (IpxTransportName.Buffer != NULL) {

        FREE_POOL(IpxTransportName.Buffer);

    }

    if ( NwProviderName.Buffer != NULL ) {
        FREE_POOL( NwProviderName.Buffer );
    }

    //NwUninitializePidTable();                 //Terminal Server code merge - 
                                                //NwUninitializePidTable is called in
                                                //NwDeleteScb. Pid table is per SCB base.

    ASSERT( IsListEmpty( &NwPagedPoolList ) );
    ASSERT( IsListEmpty( &NwNonpagedPoolList ) );

    ASSERT( MdlCount == 0 );
    ASSERT( IrpCount == 0 );

    NwDeleteRcb( &NwRcb );

#ifdef NWDBG
    ExDeleteResourceLite( &NwDebugResource );
#endif

    ExDeleteResourceLite( &NwOpenResource );
    ExDeleteResourceLite( &NwUnlockableCodeResource );

    IoDeleteDevice(FileSystemDeviceObject);

    DebugTrace(0, Dbg, "NetWare redirector unloaded\n\n", 0);

}


VOID
GetConfigurationInformation(
    PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine read redirector configuration information from the registry.

Arguments:

    RegistryPath - A pointer the a path to the

Return Value:

    None

--*/
{
    UNICODE_STRING UnicodeString;
    HANDLE ConfigHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG TimeOutEventinMins = 0L;
    LCID lcid;

    PAGED_CODE();

    Japan = FALSE;
    Korean = FALSE;


    ZwQueryDefaultLocale( FALSE, &lcid );

    if (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
        PRIMARYLANGID(lcid) == LANG_KOREAN ||
        PRIMARYLANGID(lcid) == LANG_CHINESE) {

            Japan = TRUE;
            if (PRIMARYLANGID(lcid) == LANG_KOREAN){
                Korean = TRUE;
            }
    }


    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey ( &ConfigHandle, KEY_READ, &ObjectAttributes );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    RtlInitUnicodeString( &UnicodeString, L"Parameters" );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        ConfigHandle,
        NULL
        );

    Status = ZwOpenKey( &ParametersHandle, KEY_READ, &ObjectAttributes );

    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ConfigHandle );
        return;
    }

    ReadValue( ParametersHandle, &IrpStackSize, L"IrpStackSize" );

    ReadValue( ParametersHandle, &MaxSendDelay, L"MaxSendDelay" );
    ReadValue( ParametersHandle, &MaxReceiveDelay, L"MaxReceiveDelay" );

    ReadValue( ParametersHandle, &MinSendDelay, L"MinSendDelay" );
    ReadValue( ParametersHandle, &MinReceiveDelay, L"MinReceiveDelay" );

    ReadValue( ParametersHandle, &BurstSuccessCount, L"BurstSuccessCount" );
    ReadValue( ParametersHandle, &BurstSuccessCount2, L"BurstSuccessCount2" );
    ReadValue( ParametersHandle, &MaxReadTimeout, L"MaxReadTimeout" );
    ReadValue( ParametersHandle, &MaxWriteTimeout, L"MaxWriteTimeout" );
    ReadValue( ParametersHandle, &ReadTimeoutMultiplier, L"ReadTimeoutMultiplier" );
    ReadValue( ParametersHandle, &WriteTimeoutMultiplier, L"WriteTimeoutMultiplier" );
    ReadValue( ParametersHandle, &AllowGrowth, L"AllowGrowth" );
    ReadValue( ParametersHandle, &DontShrink, L"DontShrink" );
    ReadValue( ParametersHandle, &SendExtraNcp, L"SendExtraNcp" );
    ReadValue( ParametersHandle, &DefaultMaxPacketSize, L"DefaultMaxPacketSize" );
    ReadValue( ParametersHandle, &PacketThreshold, L"PacketThreshold" );
    ReadValue( ParametersHandle, &LargePacketAdjustment, L"LargePacketAdjustment" );
    ReadValue( ParametersHandle, &LipPacketAdjustment, L"LipPacketAdjustment" );
    ReadValue( ParametersHandle, &LipAccuracy, L"LipAccuracy" );

    ReadValue( ParametersHandle, &DisableReadCache, L"DisableReadCache" );
    ReadValue( ParametersHandle, &DisableWriteCache, L"DisableWriteCache" );
    ReadValue( ParametersHandle, &FavourLongNames, L"FavourLongNames" );
    
    ReadValue( ParametersHandle, &LongNameFlags, L"LongNameFlags" );

    ReadValue( ParametersHandle, &DirCacheEntries, L"DirectoryCacheSize" );
    if( DirCacheEntries == 0 ) {
        DirCacheEntries = 1;
    }
    if( DirCacheEntries > MAX_DIR_CACHE_ENTRIES ) {
        DirCacheEntries = MAX_DIR_CACHE_ENTRIES;
    }

    ReadValue( ParametersHandle, &LockTimeoutThreshold, L"LockTimeout" );

    ReadValue( ParametersHandle, &TimeOutEventinMins, L"TimeOutEventinMins");

    ReadValue( ParametersHandle, &EnableMultipleConnects, L"EnableMultipleConnects");

    ReadValue( ParametersHandle, &AllowSeedServerRedirection, L"AllowSeedServerRedirection");

    ReadValue( ParametersHandle, &ReadExecOnlyFiles, L"ReadExecOnlyFiles");

    ReadValue( ParametersHandle, &DisableAltFileName, L"DisableAltFileName");

    ReadValue( ParametersHandle, &NwAbsoluteTotalWaitTime, L"AbsoluteTotalWaitTime");

    ReadValue( ParametersHandle, &NdsObjectCacheSize, L"NdsObjectCacheSize" );

    ReadValue( ParametersHandle, &NdsObjectCacheTimeout, L"NdsObjectCacheTimeout" );

	ReadValue ( ParametersHandle, &PreferNDSBrowsing, L"PreferNDSBrowsing" );
	
    //
    //  Make sure the object cache values are within bounds.
    //
    //  NOTE:  If the timeout is set to zero, then the cache is
    //         effectively disabled.  NdsObjectCacheSize is set
    //         to zero to accomplish this.
    //

    if( NdsObjectCacheSize > MAX_NDS_OBJECT_CACHE_SIZE ) {
        NdsObjectCacheSize = MAX_NDS_OBJECT_CACHE_SIZE;
    }

    if( NdsObjectCacheTimeout > MAX_NDS_OBJECT_CACHE_TIMEOUT  ) {
        NdsObjectCacheTimeout = MAX_NDS_OBJECT_CACHE_TIMEOUT;

    } else if( NdsObjectCacheTimeout == 0  ) {
        NdsObjectCacheSize = 0;
    }

    if (!TimeOutEventinMins) {
        //
        //  If for some reason, the registry has set the TimeOutEventInterval
        //  to zero, reset to the default value to avoid divide-by-zero
        //

        TimeOutEventinMins =  DEFAULT_TIMEOUT_EVENT_INTERVAL;
    }

    TimeOutEventInterval.QuadPart = TimeOutEventinMins * 60 * SECONDS;

    //
    //  tommye - MS bug 2743 we now get the RetryCount from the registry, providing
    //  a default of DEFAULT_RETRY_COUNT.
    //

    {
        LONG TempRetryCount;

        TempRetryCount = DEFAULT_RETRY_COUNT;
        ReadValue( ParametersHandle, &TempRetryCount, L"DefaultRetryCount");
        DefaultRetryCount = (SHORT) TempRetryCount & 0xFFFF;
    }

    ZwClose( ParametersHandle );
    ZwClose( ConfigHandle );


}

VOID
ReadValue(
    HANDLE  ParametersHandle,
    PLONG   pVar,
    PWCHAR  Name
    )
/*++

Routine Description:

    This routine reads a single redirector configuration value from the registry.

Arguments:

    Parameters  -   Supplies where to look for values.

    pVar        -   Address of the variable to receive the new value if the name exists.

    Name        -   Name whose value is to be loaded.

Return Value:

    None

--*/
{
    WCHAR Storage[256];
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;
    PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

    PAGED_CODE();

    UnicodeString.Buffer = Storage;

    RtlInitUnicodeString(&UnicodeString, Name );

    Status = ZwQueryValueKey(
                 ParametersHandle,
                 &UnicodeString,
                 KeyValueFullInformation,
                 Value,
                 sizeof(Storage),
                 &BytesRead );

    if ( NT_SUCCESS( Status ) ) {

        if ( Value->DataLength >= sizeof(ULONG) ) {

            *pVar = *(LONG UNALIGNED *)( (PCHAR)Value + Value->DataOffset );

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\fragex.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    FragEx.c

Abstract:

    This module implements the fragment exchanger routine for
    netware directory services access.

Author:

    Cory West    [CoryWest]    23-Feb-1995

Revision History:

--*/

#include <stdarg.h>
#include "Procs.h"

#define Dbg (DEBUG_TRACE_EXCHANGE)

#pragma alloc_text( PAGE, FragExWithWait )
#pragma alloc_text( PAGE, FormatBuf )
#pragma alloc_text( PAGE, FormatBufS )

NTSTATUS
_cdecl
FragExWithWait(
    IN PIRP_CONTEXT    pIrpContext,
    IN DWORD           NdsVerb,
    IN PLOCKED_BUFFER  pReplyBuffer,
    IN BYTE            *NdsRequestStr,
    ...
)
/*

Routine Description:

    Exchanges an NDS request in fragments and collects the fragments
    of the response.  The buffer passed in much be locked down for
    the transport.

Routine Arguments:

    pIrpContext    - A pointer to the context information for this IRP.
    NdsVerb        - The verb for that indicates the request.

    pReplyBuffer   - The locked down reply buffer.

    NdsReqestStr   - The format string for the arguments to this NDS request.
    Arguments      - The arguments that satisfy the NDS format string.

Return Value:

    NTSTATUS - Status of the exchange, but not the result code in the packet.

*/
{

    NTSTATUS Status;

    BYTE  *NdsRequestBuf;
    DWORD NdsRequestLen;

    BYTE *NdsRequestFrag, *NdsReplyFrag;
    DWORD NdsRequestBytesLeft, NdsReplyBytesLeft, NdsReplyLen;

    va_list Arguments;

    PMDL pMdlSendData = NULL,
         pTxMdlFrag = NULL,
         pRxMdlFrag = NULL;

    PMDL pOrigMdl;
    DWORD OrigRxMdlSize;
    BOOL bChangedMdl = FALSE;

    DWORD MaxFragSize, SendFragSize;
    DWORD ReplyFragSize, ReplyFragHandle;

    DWORD NdsFraggerHandle = DUMMY_ITER_HANDLE;

    // Remove later
    ULONG IterationsThroughLoop = 0;

    PAGED_CODE();

    DebugTrace( 0 , Dbg, "Entering FragExWithWait...\n", 0 );

    //
    // Allocate conversation buffer for the request.
    //

    NdsRequestBuf = ALLOCATE_POOL( PagedPool, ( NDS_BUFFER_SIZE * 2 ) );

    if ( !NdsRequestBuf ) {

        DebugTrace( 0, Dbg, "No memory for request buffer...\n", 0 );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Build the request in our local buffer.  Reserve the first
    // five DWORDs for the NDS request header.
    //

    if ( NdsRequestStr != NULL ) {

        va_start( Arguments, NdsRequestStr );

        NdsRequestFrag = (BYTE *) NdsRequestBuf + sizeof( NDS_REQUEST_HEADER );

        NdsRequestLen = FormatBuf( NdsRequestFrag,
                                   ( NDS_BUFFER_SIZE * 2 ) - sizeof( NDS_REQUEST_HEADER ),
                                   NdsRequestStr,
                                   Arguments );

        if ( !NdsRequestLen ) {

           Status = STATUS_UNSUCCESSFUL;
           goto ExitWithCleanup;

        }

        va_end( Arguments );

    } else {

        NdsRequestLen = 0;
    }

    //
    // Pack in the NDS preamble now that we know the length.
    //
    // The second DWORD in the preamble is the size of the NDS
    // request which includes the three DWORDs immediately
    // following the size in the preamble.
    //

    MaxFragSize = pIrpContext->pNpScb->BufferSize -
                  ( sizeof( NCP_REQUEST_WITH_SUB ) +
                    sizeof( NDS_REPLY_HEADER ) );

    FormatBufS( NdsRequestBuf,
                5 * sizeof( DWORD ),
                "DDDDD",
                MaxFragSize,                               // max fragment size
                NdsRequestLen + ( 3 * sizeof( DWORD ) ),   // request size
                0,                                         // fragment flags
                NdsVerb,                                   // nds verb
                pReplyBuffer->dwRecvLen );                 // reply buffer size

    NdsRequestLen += sizeof( NDS_REQUEST_HEADER );

    //
    // Map the entire request to the SendData mdl and lock it down.
    // we'll build partials into this data chunk as we proceed.
    //

    pMdlSendData = ALLOCATE_MDL( NdsRequestBuf,
                                 NdsRequestLen,
                                 FALSE,
                                 FALSE,
                                 NULL );

    if ( !pMdlSendData ) {

        DebugTrace( 0, Dbg, "Failed to allocate the request mdl...\n", 0 );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    try {

        MmProbeAndLockPages( pMdlSendData, KernelMode, IoReadAccess );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Failed to lock request data in FragExWithWait!\n", 0 );
        Status = GetExceptionCode();
        goto ExitWithCleanup;

    }

    //
    // Allocate space for send and receive partial mdls.
    //

    pTxMdlFrag = ALLOCATE_MDL( NdsRequestBuf,
                               NdsRequestLen,
                               FALSE,
                               FALSE,
                               NULL );

    if ( !pTxMdlFrag ) {

       DebugTrace( 0, Dbg, "Failed to allocate a tx mdl for this fragment...\n", 0 );
       Status = STATUS_INSUFFICIENT_RESOURCES;
       goto ExitWithCleanup;

    }

    pRxMdlFrag = ALLOCATE_MDL( pReplyBuffer->pRecvBufferVa,
                               pReplyBuffer->dwRecvLen,
                               FALSE,
                               FALSE,
                               NULL );

    if ( !pRxMdlFrag ) {

        DebugTrace( 0, Dbg, "Failed to allocate an rx mdl for this fragment...\n", 0 );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;

    }

    //
    // Store the original RxMdl parameters and temporarily shorten it to hold
    // only the response header.
    //

    pOrigMdl = pIrpContext->RxMdl->Next;
    OrigRxMdlSize = MmGetMdlByteCount( pIrpContext->RxMdl );
    pIrpContext->RxMdl->ByteCount = 16;
    bChangedMdl = TRUE;

    //
    // The request is formatted, so set our internal pointers
    // and start the exchange loop.
    //

    NdsReplyFrag = pReplyBuffer->pRecvBufferVa;
    NdsReplyBytesLeft = pReplyBuffer->dwRecvLen;
    NdsReplyLen = 0;

    NdsRequestFrag = NdsRequestBuf;
    NdsRequestBytesLeft = NdsRequestLen;

    while ( TRUE ) {

        IterationsThroughLoop++;


        //
        // If there's more data to send in the request, set up the next MDL frag.
        //

        if ( NdsRequestBytesLeft ) {

            if ( MaxFragSize < NdsRequestBytesLeft )
                SendFragSize = MaxFragSize;
            else
                SendFragSize = NdsRequestBytesLeft;

            IoBuildPartialMdl( pMdlSendData,
                               pTxMdlFrag,
                               NdsRequestFrag,
                               SendFragSize );

        }

        //
        // Set up the response partial mdl with the buffer space that we have
        // left.  If we are here and there's no space left in the user's buffer,
        // we're sort of hosed...
        //

        if ( !NdsReplyBytesLeft ) {

            DebugTrace( 0, Dbg, "No room for fragment reply.\n", 0 );
            Status = STATUS_BUFFER_OVERFLOW;
            goto ExitWithCleanup;

        }

        ASSERT( NdsReplyBytesLeft <= MmGetMdlByteCount( pRxMdlFrag ) );

        IoBuildPartialMdl( pReplyBuffer->pRecvMdl,
                           pRxMdlFrag,
                           NdsReplyFrag,
                           NdsReplyBytesLeft );

        pIrpContext->RxMdl->Next = pRxMdlFrag;
        pRxMdlFrag->Next = NULL;

        //
        // Do this transaction.
        //

        SetFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

        if ( NdsRequestBytesLeft ) {

            Status = ExchangeWithWait( pIrpContext,
                                       SynchronousResponseCallback,
                                       "NDf",
                                       NDS_REQUEST,         // NDS Function 104
                                       NDS_ACTION,          // NDS Subfunction 2
                                       NdsFraggerHandle,    // frag handle from the last response
                                       pTxMdlFrag );        // NDS MDL Fragment

            NdsRequestBytesLeft -= SendFragSize;
            NdsRequestFrag = (LPBYTE) NdsRequestFrag + SendFragSize;
            MmPrepareMdlForReuse( pTxMdlFrag );

            //
            // We may reuse this irp context, so we have to clear the
            // TxMdl chain (Exchange doesn't do it for us).
            //

            pIrpContext->TxMdl->Next = NULL;

        } else {

            //
            // There were no more request bytes to send, so we must have be allowed
            // to continue to request another response fragment.  NdsFraggerHandle
            // contains the fragger handle from the last response.
            //

            Status = ExchangeWithWait( pIrpContext,
                                       SynchronousResponseCallback,
                                       "ND",                    // We only care about the frag handle
                                       NDS_REQUEST,             // NDS Function 104
                                       NDS_ACTION,              // NDS Subfunction 2
                                       NdsFraggerHandle );      // the frag handle from last response
        }

        ClearFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

        //
        // Success?  Get the frag size and frag handle and see.
        //

        if ((!NT_SUCCESS( Status )) || (pIrpContext->ResponseLength == 0)) {

            DebugTrace( 0, Dbg, "Failed to exchange the fragment.\n", 0 );
            goto ExitWithCleanup;

        }

        Status = ParseResponse( pIrpContext,
                                pIrpContext->rsp,   // mapped into first rxmdl
                                MIN(16, pIrpContext->ResponseLength),
                                "NDD",
                                &ReplyFragSize,
                                &ReplyFragHandle );

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

        //
        // We got that fragment and it's already in our buffer.  We have to adjust
        // the index pointers, reset the MDLs, and continue on.  Remember, we don't
        // have to include space for the fragger handle since we've already got it.
        //

        ReplyFragSize -= sizeof( DWORD );

        if (ReplyFragSize > NdsReplyBytesLeft) {

            NdsReplyBytesLeft = 0;

        } else {

            NdsReplyBytesLeft -= ReplyFragSize;
        }

        NdsReplyFrag = (LPBYTE) NdsReplyFrag + ReplyFragSize;
        NdsReplyLen += ReplyFragSize;
        MmPrepareMdlForReuse( pRxMdlFrag );

        //
        // Inspect the fraghandle.
        //

        if ( ReplyFragHandle == DUMMY_ITER_HANDLE ) {

            // We are done!
            //
            // Invariant: There is a valid NDS response in the NdsReply
            // and Status is NT_SUCCESS.

            pReplyBuffer->dwBytesWritten = NdsReplyLen;
            goto ExitWithCleanup;

        } else {

            // There's more coming!  Remember the fragger handle and continue.

            NdsFraggerHandle = ReplyFragHandle;
        }

    }

    DebugTrace( 0, Dbg, "Invalid state in FragExWithWait()\n", 0 );

ExitWithCleanup:

    //
    // Unlock the request buffer and free its mdl.
    //

    if ( pMdlSendData ) {

        MmUnlockPages( pMdlSendData );
        FREE_MDL( pMdlSendData );
    }

    //
    // Free the partial mdls.
    //

    if ( pRxMdlFrag )
        FREE_MDL( pRxMdlFrag );

    if ( pTxMdlFrag )
       FREE_MDL( pTxMdlFrag );

    //
    // Free the request buffer.
    //

    FREE_POOL( NdsRequestBuf );

    //
    // Restore the original Irp->RxMdl parameters.
    //

    if ( bChangedMdl )
    {
        pIrpContext->RxMdl->Next = pOrigMdl;
        pIrpContext->RxMdl->ByteCount = OrigRxMdlSize;
    }

    return Status;

}

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
)
/*

Routine Description:

    Formats a buffer according to supplied the format string.

    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'V'      sized NDS value   ( byte *, dword / byte **, dword *)
            'S'      p unicode string copy as NDS_STRING (UNICODE_STRING *)
            's'      cstring copy as NDS_STRING (char* / char *, word)
            'r'      raw bytes         ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )

Routine Arguments:

    char *buf - destination buffer.
    int buflen - length of the destination buffer.
    char *format - format string.
    args - args to the format string.

Implementation Notes:

   This comes almost verbatim from the Win95 source code.  It duplicates
   work in FormatRequest().  Eventually, FormatRequest() should be split
   into two distinct routines: FormatBuffer() and MakeRequest().

*/
{
    ULONG ix;

    NTSTATUS status;
    const char *z = format;

    PAGED_CODE();

    //
    // Convert the input arguments into request packet.
    //

    ix = 0;

    while ( *z )
    {
        switch ( *z )
        {
        case '=':
            buf[ix++] = 0;
        case '-':
            buf[ix++] = 0;
            break;

        case '_':
        {
            WORD l = va_arg ( args, WORD );
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
#ifdef NWDBG
                DbgPrintf( "FormatBuf case '_' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }
            while ( l-- )
                buf[ix++] = 0;
            break;
        }

        case 'b':
            buf[ix++] = va_arg ( args, BYTE );
            break;

        case 'w':
        {
            WORD w = va_arg ( args, WORD );
            buf[ix++] = (BYTE) (w >> 8);
            buf[ix++] = (BYTE) (w >> 0);
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( args, DWORD );
            buf[ix++] = (BYTE) (d >> 24);
            buf[ix++] = (BYTE) (d >> 16);
            buf[ix++] = (BYTE) (d >>  8);
            buf[ix++] = (BYTE) (d >>  0);
            break;
        }

        case 'W':
        {
            WORD w = va_arg(args, WORD);
            (* (WORD *)&buf[ix]) = w;
            ix += 2;
            break;
        }

        case 'D':
        {
            DWORD d = va_arg (args, DWORD);
            (* (DWORD *)&buf[ix]) = d;
            ix += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( args, char* );
            WORD  l = (WORD)strlen( c );
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
#ifdef NWDBG
                DbgPrintf( "FormatBuf case 'c' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }
            RtlCopyMemory( &buf[ix], c, l+1 );
            ix += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( args, char* );
            WORD l = va_arg ( args, WORD );
            WORD len = strlen( c ) + 1;
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
#ifdef NWDBG
                DbgPrintf( "FormatBuf 'C' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }

            RtlCopyMemory( &buf[ix], c, len > l? l : len);
            ix += l;
            buf[ix-1] = 0;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( args, char* );
            BYTE  l = (BYTE)strlen( c );
            if (ix + (ULONG)l +1 > (ULONG)bufLen)
            {
#ifdef NWDBG
                DbgPrintf( "FormatBuf case 'p' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }
            buf[ix++] = l;
            RtlCopyMemory( &buf[ix], c, l );
            ix += l;
            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( args, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( ix + Length > (ULONG)bufLen ) {
#ifdef NWDBG
                DbgPrint( "FormatBuf case 'u' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }

            buf[ix++] = (UCHAR)Length;
            OemString.Buffer = &buf[ix];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));
            ix += (USHORT)Length;
            break;
        }

        case 'S':
        {
            PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
            ULONG Length, rLength;

            Length = pUString->Length;
            if (ix + Length + sizeof(Length) + sizeof( WCHAR ) > (ULONG)bufLen) {
                DebugTrace( 0, Dbg, "FormatBuf: case 'S' request buffer too small.\n", 0 );
                goto ErrorExit;
            }

            //
            // The VLM client uses the rounded up length and it seems to
            // make a difference!  Also, don't forget that NDS strings have
            // to be NULL terminated.
            //

            rLength = ROUNDUP4(Length + sizeof( WCHAR ));
            *((DWORD *)&buf[ix]) = rLength;
            ix += 4;
            RtlCopyMemory(&buf[ix], pUString->Buffer, Length);
            ix += Length;
            rLength -= Length;
            RtlFillMemory( &buf[ix], rLength, '\0' );
            ix += rLength;
            break;

        }

        case 's':
        {
           PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
           ULONG Length, rLength;

           Length = pUString->Length;
           if (ix + Length + sizeof(Length) + sizeof( WCHAR ) > (ULONG)bufLen) {
               DebugTrace( 0, Dbg, "FormatBuf: case 's' request buffer too small.\n", 0 );
               goto ErrorExit;
           }

           //
           // Don't use the padded size here, only the NDS null terminator.
           //

           rLength = Length + sizeof( WCHAR );
           *((DWORD *)&buf[ix]) = rLength;
           ix += 4;
           RtlCopyMemory(&buf[ix], pUString->Buffer, Length);
           ix += Length;
           rLength -= Length;
           RtlFillMemory( &buf[ix], rLength, '\0' );
           ix += rLength;
           break;


        }

        case 'V':
        {
            // too similar to 'S' - should be combined
            BYTE* b = va_arg ( args, BYTE* );
            DWORD  l = va_arg ( args, DWORD );
            if ( ix + l + sizeof(DWORD) > (ULONG)
               bufLen )
            {
#ifdef NWDBG
                DbgPrint( "FormatBuf case 'V' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }
            *((DWORD *)&buf[ix]) = l;
            ix += sizeof(DWORD);
            RtlCopyMemory( &buf[ix], b, l );
                        l = ROUNDUP4(l);
            ix += l;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( args, BYTE* );
            WORD  l = va_arg ( args, WORD );
            if ( ix + l > (ULONG)bufLen )
            {
#ifdef NWDBG
                DbgPrint( "FormatBuf case 'r' request buffer too small.\n" );
#endif
                goto ErrorExit;
            }
            RtlCopyMemory( &buf[ix], b, l );
            ix += l;
            break;
        }

        default:

#ifdef NWDBG
            DbgPrint( "FormatBuf  invalid request field, %x.\n", *z );
#endif
        ;

        }

        if ( ix > (ULONG)bufLen )
        {
#ifdef NWDBG
            DbgPrint( "FormatBuf: too much request data.\n" );
#endif
            goto ErrorExit;
        }


        z++;
    }

    return(ix);

ErrorExit:
    return 0;
}



int
_cdecl
FormatBufS(
    char *buf,
    int bufLen,
    const char *format,
    ...
)
/*++
    args from the stack
--*/
{
   va_list args;
   int len;

   PAGED_CODE();

   va_start(args, format);
   len = FormatBuf(buf, bufLen, format, args);
   va_end( args );

   return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\lock.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Lock.c

Abstract:

    This module implements the Lock routine for the NetWare redirector.

    Notes on the implementation of locks.

    o Netware servers handle lock conflicts differently than a LAN Man
      server, or NT file system would.  In particular:

      - A lock conflict on a single file handle (i.e. the same app owns
        the lock, and is trying to obtain a conflicting lock):  The
        netware server will fail the request only if the lock range is
        identical to a held lock.  Also, the lock fails immediately, even
        if the app requested a blocking lock.

      - A lock conflict generated by 2 app from the same workstation:
        The server will fail the request if the request lock overlaps an
        existing lock by even a single byte, but the server will fail the
        request immediately, even if the app requested a blocking lock.

      - A lock conflict generated by 2 different workstations:  This works
        as expected.  The lock fails if it overlaps an existing lock, and
        the request blocks if requested by the app.

    o The NT workstation needs to impose NT file system behaviour when dealing
      with a netware server.   There are 2 key elements (complications)
      added to the redirector to handle this.

      - A locally maintained lock database.  This is used to test for
        lock conflicts locally.  If a conflict is detected and the
        requestor asks for a blocking lock, the lock request is queued
        to a local lock conflict list.  This list is processed when real
        locks are released.

      - A pending lock list.  This is used to poll the netware server
        about remote lock conflicts.  We could not let our lock request
        block indefinitely as this would tie up our one channel of
        communication to the server.

    o The data structures

      - NonPagedFcb
              -> FileLockList - The list of existing locks.
              -> PendingLockList - The list of locks pending due to a
                                   local conflict.

      - NwPendingLockList
            The list of locks pending due to a remote conflict.  The
            locks are retried indefinitely using a polling mechanism.

            A request can be removed from the pending list via (1) a
            cleanup for the correct ICB (2) the IRP can be cancelled.
            (3) The server actually grants the lock.

    o Other notes:

      We play some games to allow us to use the FCB resource as the
      synchronization mechanism, even though much processing happens
      at raised IRQL.  Be careful not to break this.

Author:

    Colin Watson    [ColinW]    13-May-1993
    Manny Weiser    [MannyW]    16-May-1993

Revision History:

--*/

#include "Procs.h"


//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
NwCommonLock(
    PIRP_CONTEXT pIrpContext
    );

NTSTATUS
LockNcp(
    PIRP_CONTEXT IrpContext,
    PICB Icb
    );

NTSTATUS
LockNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
UnlockNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

BOOLEAN
LockIsOverlapping(
    PNONPAGED_FCB pNpFcb,
    LONG StartFileOffset,
    ULONG Length
    );

VOID
AddLockToFcb(
    PNONPAGED_FCB pNpFcb,
    PNW_FILE_LOCK FileLock
    );

VOID
RemoveLockFromFcb(
    PNONPAGED_FCB pNpFcb,
    PNW_FILE_LOCK FileLock
    );

VOID
ReattemptPendingLocks(
    PNONPAGED_FCB pNpFcb
    );

BOOLEAN
LockExists(
    PNONPAGED_FCB pNpFcb,
    LONG StartOffset,
    ULONG Length,
    PNW_FILE_LOCK *FileLock
    );

NTSTATUS
UnlockIcbLocks(
    PIRP_CONTEXT pIrpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdLockControl )
#pragma alloc_text( PAGE, NwCommonLock )
#pragma alloc_text( PAGE, LockNcp )
#pragma alloc_text( PAGE, NwFreeLocksForIcb )
#pragma alloc_text( PAGE, UnlockIcbLocks )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, LockNcpCallback )
#pragma alloc_text( PAGE1, UnlockNcpCallback )
#pragma alloc_text( PAGE1, AddLockToFcb )
#pragma alloc_text( PAGE1, RemoveLockFromFcb )
#pragma alloc_text( PAGE1, ReattemptPendingLocks )
#pragma alloc_text( PAGE1, LockExists )
#endif

#endif

#if 0  // Not pageable

/////#pragma alloc_text( PAGE, LockIsOverlapping ) //Not pageable
// see ifndef QFE_BUILD above

#endif



NTSTATUS
NwFsdLockControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    DeviceObject - Supplies the device object for the redirector.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    TimerStart(Dbg);
    DebugTrace(+1, Dbg, "NwFsdLockControl\n", 0);

    //
    //  Call the common lock routine, with block allowed if the operation
    //  is synchronous.
    //

    FsRtlEnt