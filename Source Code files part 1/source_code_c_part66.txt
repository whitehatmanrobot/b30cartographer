E )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					GetFirstGUID(m_pRequest->m_Value[iPos], wcAction);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `CLSID`, `Context`, `ProgId_Default`, `Description`, `AppId_`, `FileTypeMask`, `DefInprocHandler`, `Argument` from Class" );

    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `CLSID`=\'", wcAction, L"\'" );
    }

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Class", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = 39;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcCLSID, &dwBufSize));
                            PutProperty(m_pObj, pCLSID, wcCLSID);
                            PutProperty(m_pObj, pName, wcCLSID);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );
                            PutProperty(m_pObj, pContext, Buffer);

							wcProp.Append ( 3, wcCLSID, Buffer, wcProductCode );
							PutKeyProperty(m_pObj, pActionID, wcProp, &bCheck, m_pRequest);
							wcProp.Clear ( );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                    //====================================================
                        
                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pProgID, FALSE );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pDescription, pCaption );

                            dwBufSize = 39;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pAppID, wcBuf);

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 7, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pFileTypeMask, FALSE );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 8, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDefInprocHandler, FALSE );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 9, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pArgument, FALSE );

							// safe operation
							// lenght of wcCLSID is 39 and lenght of wcQuery1 is BUFF_SIZE ( 512 )

                            wcscpy(wcQuery1, L"select `RemoteName`, `Insertable` from Class where `CLSID`=\'");
                            wcscat(wcQuery1, wcCLSID);
                            wcscat(wcQuery1, L"\'");

                            if((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hSView)) !=
                                ERROR_BAD_QUERY_SYNTAX){

                                CheckMSI(uiStatus);

                                CheckMSI(g_fpMsiViewExecute(hSView, 0));

                                try{

                                    uiStatus = g_fpMsiViewFetch(hSView, &hSRecord);

                                    if(uiStatus != ERROR_NO_MORE_ITEMS){

                                        CheckMSI(uiStatus);

                                        dwBufSize = BUFF_SIZE;
										PutPropertySpecial ( hSRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pRemoteName, FALSE );

                                        PutProperty(m_pObj, pInsertable, g_fpMsiRecordGetInteger(hSRecord, 2));
                                    }

                                }catch(...){

                                    g_fpMsiViewClose(hSView);
                                    g_fpMsiCloseHandle(hSView);
                                    g_fpMsiCloseHandle(hSRecord);
                                    throw;
                                }

                                g_fpMsiViewClose(hSView);
                                g_fpMsiCloseHandle(hSView);
                                g_fpMsiCloseHandle(hSRecord);

                            }

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = NULL;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\classfac.h ===
//***************************************************************************

//

//  ClassFac.h

//

//  Module: WBEM Instance provider sample code

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _ClassFactory_H_
#define _ClassFactory_H_

#define _WIN32_DCOM

// This class is the class factory for CMSIProv objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\classinfoaction.h ===
// ClassInfoAction.h: interface for the CClassInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CLASSINFOACTION_H__75F6BA22_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_CLASSINFOACTION_H__75F6BA22_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CClassInfoAction : public CGenericClass  
{
public:
	CClassInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CClassInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_CLASSINFOACTION_H__75F6BA22_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\commandlineaccess.h ===
// CommandLineAccess.h: interface for the CCommandLineAccess class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COMMANDLINEACCESS_H__DB614F25_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_COMMANDLINEACCESS_H__DB614F25_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CCommandLineAccess : public CGenericClass  
{
public:
	CCommandLineAccess(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCommandLineAccess();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	void Cleanup(WCHAR * wcList[]);
	void Initialize(WCHAR * wcList[]);
};

#endif // !defined(AFX_COMMANDLINEACCESS_H__DB614F25_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\commandlineaccess.cpp ===
// CommandLineAccess.cpp: implementation of the CCommandLineAccess class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <tchar.h>
#include "CommandLineAccess.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCommandLineAccess::CCommandLineAccess(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCommandLineAccess::~CCommandLineAccess()
{

}

HRESULT CCommandLineAccess::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord = NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery1[BUFF_SIZE];
    WCHAR wcCommand[BUFF_SIZE];
    WCHAR *wcDone[MSI_MAX_APPLICATIONS];
    WCHAR wcProductCode[39];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    TCHAR cBuf[MAX_COMPUTERNAME_LENGTH + 1];

    //These will change from class to class
    bool bName, bRepeat;
    INSTALLSTATE piInstalled;

    if ( atAction != ACTIONTYPE_ENUM )
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;
	}

    Initialize(wcDone);

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery1, L"select distinct `Shortcut`, `Component_`, `Arguments` from Shortcut");

	QueryExt wcQuery ( L"select distinct `ComponentId` from Component where `Component`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery1, L"Shortcut", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);
                    bRepeat = false;

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------

                    PutProperty(m_pObj, pCreationClassName, L"Win32_CommandLineAccess");
                    PutProperty(m_pObj, pSystemCreationClassName, L"Win32_ComputerSystem");

                    dwBufSize = MAX_COMPUTERNAME_LENGTH+1;
                    if(!GetComputerName(cBuf, &dwBufSize)) throw WBEM_E_FAILED;

					#ifndef	UNICODE
                    WCHAR wcComputer[MAX_COMPUTERNAME_LENGTH + 1];
                    mbstowcs(wcComputer, cBuf, MAX_COMPUTERNAME_LENGTH + 1);

                    PutProperty(m_pObj, pSystemName, wcComputer);
					#else	UNICODE
                    PutProperty(m_pObj, pSystemName, cBuf);
					#endif	UNICODE

                //====================================================

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

					// make query on fly
					wcQuery.Append ( 2, Buffer, L"\'" );

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery, &hSEView));
                    CheckMSI(g_fpMsiViewExecute(hSEView, 0));

                    try{

                        uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                        if(uiStatus != ERROR_NO_MORE_ITEMS){

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hSERecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( ValidateComponentID ( Buffer, wcProductCode ) )
							{
                                dwBufSize = BUFF_SIZE;
                                piInstalled = g_fpMsiGetComponentPathW(wcProductCode, Buffer, wcCommand, &dwBufSize);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if ( (wcscmp(wcCommand, L"") != 0) &&
									 (piInstalled != INSTALLSTATE_UNKNOWN) &&
									 (piInstalled != INSTALLSTATE_ABSENT) )
								{
									if ( wcCommand [ dwBufSize-1 ] == L'\\' )
									{
										wcCommand [ dwBufSize-1 ] = L'\0';
									}

                                    int i = 0;
                                    while(wcDone[i]){

                                        if(wcscmp(wcDone[i], wcCommand) == 0){

                                            bRepeat = true;
                                            break;
                                        }
                                        i++;
                                    }

                                    if(!bRepeat){

                                        if ( ( wcDone[i] = new WCHAR [ wcslen ( wcCommand ) + 1 ] ) == NULL )
										{
                                            Cleanup(wcDone);
                                            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                        }

                                        wcscpy(wcDone[i], wcCommand);
                                    }

                                    PutKeyProperty(m_pObj, pName, wcCommand, &bName, m_pRequest);
                                    PutProperty(m_pObj, pCaption, wcCommand);
                                    PutProperty(m_pObj, pDescription, wcCommand);
                                
                                    dwBufSize = BUFF_SIZE;
									GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                    if ( Buffer && Buffer [0] != 0 )
									{
										PutProperty ( m_pObj, pCommandLine, wcCommand, 2, L" ", Buffer );
                                    }
									else
									{
	                                    PutProperty(m_pObj, pCommandLine, wcCommand);
									}

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                //----------------------------------------------------

                                    if(bName) bMatch = true;

                                    if(((atAction != ACTIONTYPE_GET) || bMatch) && !bRepeat){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }

                    }catch(...){

                        g_fpMsiCloseHandle(hSERecord);
                        g_fpMsiViewClose(hSEView);
                        g_fpMsiCloseHandle(hSEView);
                        throw;
                    }

                    if(m_pObj){

                        m_pObj->Release();
                        m_pObj = NULL;
                    }

                    g_fpMsiCloseHandle(hSERecord);
                    g_fpMsiViewClose(hSEView);
                    g_fpMsiCloseHandle(hSEView);

                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

            if(m_pObj){
                
                m_pObj->Release();
                m_pObj = NULL;
            }

            Cleanup(wcDone);

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	Cleanup(wcDone);
    return hr;
}

void CCommandLineAccess::Cleanup(WCHAR * wcList[])
{
    int i = 0;

    while(wcList[i]) delete wcList[i++];
}

void CCommandLineAccess::Initialize(WCHAR * wcList[])
{
    for(int i = 0; i < MSI_MAX_APPLICATIONS; i++) wcList[i] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\condition.h ===
// Condition.h: interface for the CCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONDITION_H__75F6BA21_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_CONDITION_H__75F6BA21_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CCondition : public CGenericClass  
{
public:
	CCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_CONDITION_H__75F6BA21_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\condition.cpp ===
// Condition.cpp: implementation of the CCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Condition.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCondition::CCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCondition::~CCondition()
{

}

HRESULT CCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bCheck;

    if ( atAction != ACTIONTYPE_ENUM )
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;
	}

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Feature_`, `Level`, `Condition` from Condition");

    SetSinglePropertyPath(L"CheckID");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Condition", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcProp, dwDynBuffer, dynBuffer, Buffer );

                    PutProperty(m_pObj, pName, Buffer);
                    PutProperty(m_pObj, pFeature, Buffer);
                    PutProperty(m_pObj, pCaption, Buffer);
                    PutProperty(m_pObj, pDescription, Buffer);

                    if ( ValidateFeatureName ( Buffer, wcProductCode ) )
					{
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 2, wcBuf, wcProductCode);

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

					//====================================================

                        PutProperty(m_pObj, pLevel, g_fpMsiRecordGetInteger(hRecord, 2));

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pCondition, FALSE );

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }
					else
					{
						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}
					}

                    m_pObj->Release();
                    m_pObj = NULL;
                
                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\directoryspecification.h ===
// DirectorySpecification.h: interface for the CDirectorySpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIRECTORYSPECIFICATION_H__DB614F27_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_DIRECTORYSPECIFICATION_H__DB614F27_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CDirectorySpecification : public CGenericClass  
{
public:
	CDirectorySpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CDirectorySpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:

	DWORD CreateDirectoryPath	(	MSIHANDLE hProduct,
									MSIHANDLE hDatabase,
									WCHAR *wcDir,
									WCHAR *wcPath,
									DWORD *dwPath
								);

	WCHAR * ParseDefDir(WCHAR *wcDefaultDir);
};

#endif // !defined(AFX_DIRECTORYSPECIFICATION_H__DB614F27_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\createfolder.cpp ===
// CreateFolder.cpp: implementation of the CCreateFolder class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CreateFolder.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCreateFolder::CCreateFolder(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CCreateFolder::~CCreateFolder()
{

}

HRESULT CCreateFolder::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR * wcBuf = NULL;
	WCHAR * wcProductCode = NULL;

    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;

	try
	{
		if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcProductCode = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		SetSinglePropertyPath(L"ActionID");
    
		//improve getobject performance by optimizing the query
		if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

			BSTR bstrCompare;

			int iPos = -1;
			bstrCompare = SysAllocString ( L"ActionID" );

			if ( bstrCompare )
			{
				if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							SysFreeString ( bstrCompare );
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

						bGotID = true;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

				}

				SysFreeString ( bstrCompare );
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

		Query wcQuery;
		wcQuery.Append ( 1, L"select distinct `Component_`, `Directory_` from CreateFolder" );

		if( bGotID )
		{
			wcQuery.Append ( 3, L" where `Directory_`=\'", wcAction, L"\'" );
		}

		LPWSTR Buffer = NULL;
		LPWSTR dynBuffer = NULL;

		DWORD dwDynBuffer = 0L;

		while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
		{
			// safe operation:
			// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

			wcscpy(wcProductCode, m_pRequest->Package(i));

			if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

				//Open our database
				try
				{
					if ( GetView ( &hView, wcProductCode, wcQuery, L"CreateFolder", TRUE, FALSE ) )
					{
						uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
							CheckMSI(uiStatus);

							if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

							//----------------------------------------------------
							dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

							if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize,wcBuf, dwDynBuffer, dynBuffer, Buffer );

								PutProperty(m_pObj, pDirectoryName, Buffer);
								PutProperty(m_pObj, pCaption, Buffer);
								PutProperty(m_pObj, pDescription, Buffer);

								PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

							//====================================================
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

								if(bActionID) bMatch = true;

								if((atAction != ACTIONTYPE_GET)  || bMatch){

									hr = pHandler->Indicate(1, &m_pObj);
								}
							}
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}

							m_pObj->Release();
							m_pObj = NULL;

							g_fpMsiCloseHandle(hRecord);

							uiStatus = g_fpMsiViewFetch(hView, &hRecord);
						}
					}
				}
				catch(...)
				{
					if ( dynBuffer )
					{
						delete dynBuffer;
						dynBuffer = NULL;
					}

					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
			}
		}

		if ( dynBuffer )
		{
			delete [] dynBuffer;
			dynBuffer = NULL;
		}
	}
	catch ( ... )
	{
		if ( wcBuf )
		{
			delete [] wcBuf;
			wcBuf = NULL;
		}

		if ( wcProductCode )
		{
			delete [] wcProductCode;
			wcProductCode = NULL;
		}

		throw;
	}

	if ( wcBuf )
	{
		delete [] wcBuf;
		wcBuf = NULL;
	}

	if ( wcProductCode )
	{
		delete [] wcProductCode;
		wcProductCode = NULL;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\duplicatefile.h ===
// DuplicateFile.h: interface for the CDuplicateFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DUPLICATEFILE_H__DB614F30_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_DUPLICATEFILE_H__DB614F30_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CDuplicateFile : public CGenericClass  
{
public:
	CDuplicateFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CDuplicateFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_DUPLICATEFILE_H__DB614F30_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\createfolder.h ===
// CreateFolder.h: interface for the CCreateFolder class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CREATEFOLDER_H__DB614F2F_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_CREATEFOLDER_H__DB614F2F_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CCreateFolder : public CGenericClass  
{
public:
	CCreateFolder(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CCreateFolder();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_CREATEFOLDER_H__DB614F2F_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\duplicatefile.cpp ===
// DuplicateFile.cpp: implementation of the CDuplicateFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "DuplicateFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDuplicateFile::CDuplicateFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CDuplicateFile::~CDuplicateFile()
{

}

HRESULT CDuplicateFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `File_`, `DestName` from DuplicateFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `FileKey`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"DuplicateFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pFileKey, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
							
							dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSource, FALSE );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDestination, FALSE );

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\directoryspecification.cpp ===
// DirectorySpecification.cpp: implementation of the CDirectorySpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "DirectorySpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDirectorySpecification::CDirectorySpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CDirectorySpecification::~CDirectorySpecification()
{

}

HRESULT CDirectorySpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hDView	= NULL;
	MSIHANDLE hDRecord	= NULL;

    int i = -1;
    WCHAR * wcBuf = NULL;
    WCHAR * wcDir = NULL;
    WCHAR * wcPath = NULL;
    WCHAR * wcProductCode = NULL;
    WCHAR * wcCompID = NULL;
    WCHAR * wcDirectory = NULL;
    WCHAR * wcTestCode = NULL;

    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    bool bDoneFirst = false;

	try
	{
		if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcDir = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcPath = new WCHAR [ BUFF_SIZE * 4 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcProductCode = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( (  wcCompID = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcDirectory = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		if ( ( wcTestCode = new WCHAR [ 39 ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}


		DWORD dwBufSizeDir = BUFF_SIZE;
		DWORD dwBufSizeBuf = BUFF_SIZE;

		//These will change from class to class
		bool bCheck, bValidated;
		INSTALLSTATE piInstalled;
		int iState;

		SetSinglePropertyPath(L"CheckID");

		//improve getobject performance by optimizing the query
		if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

			BSTR bstrCompare;

			int iPos = -1;
			bstrCompare = SysAllocString ( L"CheckID" );

			if ( bstrCompare )
			{
				if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							SysFreeString ( bstrCompare );
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(m_pRequest->m_Value[iPos], wcDirectory);

						// safe because lenght is going to be at least 39
						//we have a componentized directory... do a little more work
						if	(	(wcDirectory[wcslen(wcDirectory) - 1] == L'}') &&
								(wcDirectory[wcslen(wcDirectory) - 38] == L'{')
							)
						{
							RemoveFinalGUID(wcDirectory, wcDirectory);
						}

						bGotID = true;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

				}

				SysFreeString ( bstrCompare );
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

		CStringExt wcID;

		Query wcQuery;
		wcQuery.Append ( 1, L"select distinct `Directory`, `DefaultDir` from Directory" );

		//optimize for GetObject
		if ( bGotID )
		{
			wcQuery.Append ( 3, L" where `Directory`=\'", wcDirectory, L"\'" );
		}

		QueryExt wcQuery1 ( L"select distinct `ComponentId`, `Component` from Component where `Directory_`=\'" );

		LPWSTR Buffer = NULL;
		LPWSTR dynBuffer = NULL;

		DWORD dwDynBuffer = 0L;

		while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
		{
			// safe operation:
			// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

			wcscpy(wcProductCode, m_pRequest->Package(i));

			if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

				//Open our database
				try
				{
					if ( GetView ( &hView, wcProductCode, wcQuery, L"Directory", FALSE, FALSE ) )
					{
						uiStatus = g_fpMsiViewFetch(hView, &hRecord);

						while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
							CheckMSI(uiStatus);
							bDoneFirst = false;

							UINT uiStatusTemp = ERROR_SUCCESS;

							//create different instances for each software element
							dwBufSize = dwBufSizeDir;;
							if ( ( uiStatusTemp = g_fpMsiRecordGetStringW(hRecord, 1, wcDir, &dwBufSize) )== ERROR_MORE_DATA )
							{
								delete [] wcDir;
								wcDir = NULL;

								if ( ( wcDir = new WCHAR [ dwBufSize + 1 ] ) != NULL )
								{
									CheckMSI ( g_fpMsiRecordGetStringW(hRecord, 1, wcDir, &dwBufSize) );
									dwBufSizeDir = dwBufSize;
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								if ( uiStatusTemp != ERROR_SUCCESS )
								{
									CheckMSI ( uiStatusTemp );
								}
							}

							// make query on fly
							wcQuery1.Append ( 2, wcDir, L"\'" );

							if ( ( ( uiStatus = g_fpMsiDatabaseOpenViewW (	msidata.GetDatabase (),
																			wcQuery1,
																			&hDView
																		 )
								   ) == ERROR_SUCCESS 
								 )

								|| !bDoneFirst
							   )
							{
								if((g_fpMsiViewExecute(hDView, 0) == ERROR_SUCCESS) || !bDoneFirst){

									try{

										uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);

										while(!bMatch && (!bDoneFirst || (uiStatus == ERROR_SUCCESS)) && (hr != WBEM_E_CALL_CANCELLED)){
                                    
											bValidated = false;

											if(uiStatus == ERROR_SUCCESS){

												dwBufSize = 39;
												CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 1, wcCompID, &dwBufSize));
												bValidated = ValidateComponentID(wcCompID, wcProductCode);
											}

											if(((uiStatus != ERROR_SUCCESS) && !bDoneFirst) || (bValidated && (uiStatus != ERROR_NO_MORE_ITEMS))){

												if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

											//----------------------------------------------------
												PutProperty(m_pObj, pDirectory, wcDir);

												wcID.Copy ( wcDir );

												DWORD dwCompID = 0L;
												LPWSTR wszTemp = NULL;

												if(uiStatus == ERROR_SUCCESS)
												{
													dwCompID = wcslen ( wcCompID );

													try
													{
														if ( ( wszTemp = new WCHAR [ dwCompID + 1 ] ) == NULL )
														{
															throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
														}
													}
													catch ( ... )
													{
														if ( wszTemp )
														{
															delete [] wszTemp;
															wszTemp = NULL;
														}

														throw;
													}

													wcscpy(wszTemp, wcCompID);
													PutProperty(m_pObj, pSoftwareElementID, wcCompID);
												}

												if ( dwCompID )
												{
													wcID.Append ( 1, wszTemp );

													if ( wszTemp )
													{
														delete [] wszTemp;
														wszTemp = NULL;
													}
												}

												wcID.Append ( 1, wcProductCode );
												PutKeyProperty(m_pObj, pCheckID, wcID, &bCheck, m_pRequest);

											//====================================================

												dwBufSize = BUFF_SIZE * 4;

												BOOL	bContinue = TRUE;
												DWORD	dwContinue= 2;

												DWORD dwStatus = ERROR_SUCCESS;

												do
												{
													if ( ( dwStatus = CreateDirectoryPath (	msidata.GetProduct (),
																							msidata.GetDatabase (),
																							wcDir,
																							wcPath,
																							&dwBufSize
																						  )
														 ) == ERROR_MORE_DATA
													   )
													{
														delete [] wcPath;
														wcPath = NULL;

														if ( ( wcPath = new WCHAR [ dwBufSize + 1 ] ) == NULL )
														{
															throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
														}
													}
													else
													{
														bContinue = FALSE;
													}
												}
												while ( bContinue && dwContinue-- );

												if ( dwStatus == ERROR_SUCCESS )
												{
													PutProperty(m_pObj, pDirectoryPath, wcPath);
												}

												dwBufSize = dwBufSizeBuf;
												PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 3, pDefaultDir, pCaption, pDescription );

												if(uiStatus == ERROR_SUCCESS){
        
													dwBufSize = dwBufSizeBuf;

													if ( ( uiStatusTemp = g_fpMsiRecordGetStringW(hDRecord, 2, wcBuf, &dwBufSize) ) == ERROR_MORE_DATA )
													{
														delete [] wcBuf;
														wcBuf = NULL;

														if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) != NULL )
														{
															CheckMSI(g_fpMsiRecordGetStringW(hDRecord, 2, wcBuf, &dwBufSize));
															dwBufSizeBuf = dwBufSize;
														}
														else
														{
															throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
														}
													}
													else
													{
														if ( uiStatusTemp != ERROR_SUCCESS )
														{
															CheckMSI ( uiStatusTemp );
														}
													}

													PutProperty(m_pObj, pName, wcBuf);
                                            
													dwBufSize = dwBufSizeBuf;
													piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcCompID, wcBuf, &dwBufSize);
													SoftwareElementState(piInstalled, &iState);
													PutProperty(m_pObj, pSoftwareElementState, iState);

													PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

													dwBufSize = dwBufSizeBuf;
													CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
													PutProperty(m_pObj, pVersion, wcBuf);
												}

											//----------------------------------------------------

												if(bCheck) bMatch = true;

												if((atAction != ACTIONTYPE_GET) || bMatch){

													hr = pHandler->Indicate(1, &m_pObj);
												}

												m_pObj->Release();
												m_pObj = NULL;

												if(!bDoneFirst) bDoneFirst = true;
											}

											g_fpMsiCloseHandle(hDRecord);

											uiStatus = g_fpMsiViewFetch(hDView, &hDRecord);
										}

									}catch(...){

										g_fpMsiCloseHandle(hDRecord);
										g_fpMsiViewClose(hDView);
										g_fpMsiCloseHandle(hDView);
										throw;
									}


									g_fpMsiCloseHandle(hDRecord);
									g_fpMsiViewClose(hDView);
									g_fpMsiCloseHandle(hDView);
								}
							}

							g_fpMsiCloseHandle(hRecord);

							uiStatus = g_fpMsiViewFetch(hView, &hRecord);
						}
					}
				}
				catch(...)
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();
					msidata.CloseProduct ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
				msidata.CloseProduct ();
			}
		}

		if ( dynBuffer ) 
		{
			delete [] dynBuffer;
			dynBuffer = NULL;
		}
	}
	catch ( ... )
	{
		if (wcBuf)
		{
			delete [] wcBuf;
			wcBuf = NULL;
		}

		if (wcDir)
		{
			delete [] wcDir;
			wcDir = NULL;
		}

		if (wcPath)
		{
			delete [] wcPath;
			wcPath = NULL;
		}

		if (wcProductCode)
		{
			delete [] wcProductCode;
			wcProductCode = NULL;
		}

		if (wcCompID)
		{
			delete [] wcCompID;
			wcCompID = NULL;
		}

		if (wcDirectory)
		{
			delete [] wcDirectory;
			wcDirectory = NULL;
		}

		if (wcTestCode)
		{
			delete [] wcTestCode;
			wcTestCode = NULL;
		}

		throw;
	}

	if (wcBuf)
	{
		delete [] wcBuf;
		wcBuf = NULL;
	}

	if (wcDir)
	{
		delete [] wcDir;
		wcDir = NULL;
	}

	if (wcPath)
	{
		delete [] wcPath;
		wcPath = NULL;
	}

	if (wcProductCode)
	{
		delete [] wcProductCode;
		wcProductCode = NULL;
	}

	if (wcCompID)
	{
		delete [] wcCompID;
		wcCompID = NULL;
	}

	if (wcDirectory)
	{
		delete [] wcDirectory;
		wcDirectory = NULL;
	}

	if (wcTestCode)
	{
		delete [] wcTestCode;
		wcTestCode = NULL;
	}

    return hr;
}

DWORD CDirectorySpecification::CreateDirectoryPath	(	MSIHANDLE hProduct,
														MSIHANDLE hDatabase,
														WCHAR *wcDir,
														WCHAR *wcPath,
														DWORD *dwPath
													)
{
	DWORD dwResult = static_cast < DWORD > ( E_INVALIDARG );

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

	LPWSTR	wcQuery = NULL;
	LPWSTR	wcBuf	= NULL;

	if ( wcDir )
	{
		DWORD	dwQuery	= 0L;
		LPWSTR	wszQuery= L"select distinct `Directory_Parent`, `DefaultDir` from Directory where `Directory`=\'";

		dwQuery = lstrlenW ( wszQuery ) + lstrlenW ( wcDir ) + 1 + 1;

		try
		{
			if ( ( wcQuery = new WCHAR [ dwQuery ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}

			wcscpy(wcQuery, wszQuery);
			wcscat(wcQuery, wcDir);
			wcscat(wcQuery, L"\'");
		}
		catch ( ... )
		{
			if ( wcQuery )
			{
				delete [] wcQuery;
				wcQuery = NULL;
			}

			throw;
		}

		try
		{
			if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch ( ... )
		{
			if ( wcQuery )
			{
				delete [] wcQuery;
				wcQuery = NULL;
			}

			if ( wcBuf )
			{
				delete [] wcBuf;
				wcBuf = NULL;
			}

			throw;
		}

		DWORD dwPathSize = 0;
		dwPathSize = * dwPath;

		DWORD dwUsed	= 1; // last null
		DWORD dwBufSize	= BUFF_SIZE;

		//Do all this to open a view on the directory we want
		if ( ( dwResult = g_fpMsiDatabaseOpenViewW ( hDatabase, wcQuery, &hView ) ) == ERROR_SUCCESS )
		{
			delete [] wcQuery;
			wcQuery = NULL;

			if(g_fpMsiViewExecute(hView, 0) == ERROR_SUCCESS)
			{
				if ( ( dwResult = g_fpMsiViewFetch ( hView, &hRecord ) ) == ERROR_SUCCESS )
				{
					BOOL	bContinue = TRUE;
					DWORD	dwContinue= 2;

					dwBufSize = BUFF_SIZE;

					do
					{
						if ( ( dwResult = g_fpMsiRecordGetStringW ( hRecord, 1, wcBuf, &dwBufSize ) ) == ERROR_MORE_DATA )
						{
							delete [] wcBuf;
							wcBuf = NULL;

							try
							{
								if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) == NULL )
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							catch ( ... )
							{
								if ( wcBuf )
								{
									delete [] wcBuf;
									wcBuf = NULL;
								}

								throw;
							}

							dwBufSize++;
						}
						else
						{
							if ( dwContinue == 2 )
							{
								dwBufSize = BUFF_SIZE;
							}

							bContinue = FALSE;
						}
					}
					while ( bContinue && dwContinue-- );

					if( dwResult == ERROR_SUCCESS )
					{
						//For TARGETDIR
						if(wcscmp(L"TARGETDIR", wcBuf) == 0)
						{
							bContinue = TRUE;
							dwContinue= 2;

							DWORD dwBufSizeOld = dwBufSize;

							do 
							{
								if ( ( dwResult = g_fpMsiGetProductPropertyW (
																				hProduct,
																				L"TARGETDIR",
																				wcBuf,
																				&dwBufSize
																			 )
									 ) == ERROR_MORE_DATA
								   )
								{
									delete [] wcBuf;
									wcBuf = NULL;

									try
									{
										if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize ++;
									}
									catch ( ... )
									{
										if ( wcBuf )
										{
											delete [] wcBuf;
											wcBuf = NULL;
										}

										throw;
									}
								}
								else
								{
									if ( dwContinue == 2 )
									{
										dwBufSize = dwBufSizeOld;
									}

									bContinue = FALSE;
								}
							}
							while ( bContinue && dwContinue-- );

							if ( dwResult == ERROR_SUCCESS )
							{
								dwUsed =	dwUsed +
											lstrlenW ( wcBuf );

								if ( dwUsed > dwPathSize )
								{
									( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
									dwResult = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, wcBuf);
								}
							}
						}
						//For WindowsFolder
						else if(wcscmp(L"WindowsFolder", wcBuf) == 0)
						{
							DWORD dwSize = 0;

							bContinue = TRUE;
							dwContinue= 2;

							do
							{
								dwSize = GetEnvironmentVariableW ( L"WINDIR", wcBuf, dwBufSize );

								if ( dwSize == 0 )
								{
									dwResult = static_cast < DWORD > ( E_FAIL );
									bContinue = FALSE;
								}
								else if ( dwSize > dwBufSize )
								{
									delete [] wcBuf;
									wcBuf = NULL;

									try
									{
										if ( ( wcBuf = new WCHAR [ dwSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize = dwSize + 1;
									}
									catch ( ... )
									{
										if ( wcBuf )
										{
											delete [] wcBuf;
											wcBuf = NULL;
										}

										throw;
									}
								}
								else
								{
									bContinue = FALSE;
									dwResult = ERROR_SUCCESS;
								}
							}
							while ( bContinue && dwContinue-- );

							if ( dwResult == ERROR_SUCCESS )
							{
								dwUsed =	dwUsed +
											lstrlenW ( wcBuf );

								if ( dwUsed > dwPathSize )
								{
									( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
									dwResult = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, wcBuf);
								}
							}
						}
						//For DesktopFolder
						else if(wcscmp(L"DesktopFolder", wcBuf) == 0)
						{
							WCHAR wcVar[15];

							if(AreWeOnNT())
							{
								wcscpy(wcVar, L"USERPROFILE");
							}
							else
							{
								wcscpy(wcVar, L"WINDIR");
							}

							DWORD dwSize = 0;

							bContinue = TRUE;
							dwContinue= 2;

							do
							{
								dwSize = GetEnvironmentVariableW ( wcVar, wcBuf, dwBufSize );

								if ( dwSize == 0 )
								{
									dwResult = static_cast < DWORD > ( E_FAIL );
									bContinue = FALSE;
								}
								else if ( dwSize > dwBufSize )
								{
									delete [] wcBuf;
									wcBuf = NULL;

									try
									{
										if ( ( wcBuf = new WCHAR [ dwSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize = dwSize + 1;
									}
									catch ( ... )
									{
										if ( wcBuf )
										{
											delete [] wcBuf;
											wcBuf = NULL;
										}

										throw;
									}
								}
								else
								{
									bContinue = FALSE;
									dwResult = ERROR_SUCCESS;
								}
							}
							while ( bContinue && dwContinue-- );

							if ( dwResult == ERROR_SUCCESS )
							{
								dwUsed =	dwUsed +
											lstrlenW ( wcBuf ) +
											lstrlenW ( L"\\Desktop" );

								if ( dwUsed > dwPathSize )
								{
									( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
									dwResult = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, wcBuf);
									wcscat(wcPath, L"\\Desktop");
								}
							}
						}
						//For same parent/directory
						else if(wcscmp(wcDir, wcBuf) == 0)
						{
							dwResult = ERROR_SUCCESS;
						}
						//Continue recursion
						else
						{
							dwResult = CreateDirectoryPath ( hProduct, hDatabase, wcBuf, wcPath, dwPath );

							if ( dwResult == ERROR_MORE_DATA )
							{
								dwUsed = dwUsed + ( * dwPath );
							}
						}
					}

					if ( dwResult == ERROR_SUCCESS  || dwResult == ERROR_MORE_DATA )
					{
						bContinue = TRUE;
						dwContinue= 2;

						DWORD dwResultHelp = ERROR_SUCCESS;

						do 
						{
							if ( ( dwResultHelp = g_fpMsiRecordGetStringW (	hRecord,
																			2,
																			wcBuf,
																			&dwBufSize
																		  )
								 ) == ERROR_MORE_DATA
							   )
							{
								delete [] wcBuf;
								wcBuf = NULL;

								try
								{
									if ( ( wcBuf = new WCHAR [ dwBufSize ] ) == NULL )
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcBuf )
									{
										delete [] wcBuf;
										wcBuf = NULL;
									}

									throw;
								}
							}
							else
							{
								bContinue = FALSE;
							}
						}
						while ( bContinue && dwContinue-- );

						if ( dwResultHelp == ERROR_MORE_DATA )
						{
							dwResult = static_cast < DWORD > ( E_FAIL );
						}

						if ( dwResult == ERROR_SUCCESS || dwResult == ERROR_MORE_DATA )
						{
							LPWSTR wcBufHelp = NULL;
							try
							{
								wcBufHelp = ParseDefDir ( wcBuf );
							}
							catch ( ... )
							{
								delete [] wcBuf;
								wcBuf = NULL;

								throw;
							}

							dwUsed =	dwUsed +
										lstrlenW ( wcBufHelp );

							if ( dwUsed > dwPathSize )
							{
								( *dwPath ) = ( *dwPath ) + ( dwUsed - dwPathSize );
								dwResult = ERROR_MORE_DATA;
							}
							else
							{
								wcscat(wcPath, wcBufHelp);
							}
						}
					}

					g_fpMsiCloseHandle(hRecord);

				}
				else if ( dwResult == E_OUTOFMEMORY )
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					delete [] wcBuf;
					wcBuf = NULL;

					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}

			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			delete [] wcBuf;
			wcBuf = NULL;
		}
		else
		{
			delete [] wcBuf;
			wcBuf = NULL;

			delete [] wcQuery;
			wcQuery = NULL;

			if(dwResult == E_OUTOFMEMORY)
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
	}

	if ( dwResult == ERROR_MORE_DATA )
	{
		wcPath [ 0 ] = 0;
	}

	return dwResult;
}

WCHAR * CDirectorySpecification::ParseDefDir(WCHAR *wcDefaultDir)
{
    WCHAR * wcTmp;
    WCHAR * wcBuf = NULL;
	
	if ( ( wcBuf = (WCHAR *)malloc( ( wcslen ( wcDefaultDir ) + 1 + 1 ) * sizeof(WCHAR)) ) != NULL )
	{
		wcscpy(wcBuf, L"\\");
		wcscat(wcBuf, wcDefaultDir);

		for(wcTmp = wcBuf; *wcTmp; wcTmp++) if(*wcTmp == L':') *wcTmp = NULL;
		for(wcTmp = wcBuf; *wcTmp; wcTmp++) if(*wcTmp == L'.') wcscpy(wcBuf, L"");

		wcscpy(wcDefaultDir, wcBuf);

		free((void *)wcBuf);
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    return wcDefaultDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\environment.h ===
// Environment.h: interface for the CEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENVIRONMENT_H__EAA368A2_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_ENVIRONMENT_H__EAA368A2_DEA4_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CEnvironment : public CGenericClass  
{
public:
	CEnvironment(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CEnvironment();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ENVIRONMENT_H__EAA368A2_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\environment.cpp ===
// Environment.cpp: implementation of the CEnvironment class.

//

// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Environment.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnvironment::CEnvironment(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CEnvironment::~CEnvironment()
{

}

HRESULT CEnvironment::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcEnvironment[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcEnvironment);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Environment`, `Component_`, `Name`, `Value` from Environment" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Environment`=\'", wcEnvironment, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Environment", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						
                        PutProperty(m_pObj, pEnvironment, Buffer);
						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

					//====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 3, pName, pCaption, pDescription );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pValue, FALSE );
                    //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);
						hRecord = NULL;

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}
				if( hRecord )
				{
					g_fpMsiCloseHandle(hRecord);
				}
				if( hView )
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

			if( hRecord )
			{
				g_fpMsiCloseHandle(hRecord);
			}
			if( hView )
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\extendquery.h ===
// Query.h: interface of the CQuery class.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#ifndef	___EXTEND_QUERY___
#define	___EXTEND_QUERY___

#if		_MSC_VER >= 1000
#pragma once
#endif	_MSC_VER >= 1000

#include "ExtendString.h"

// query 
class Query : public CStringExt
{
	public:

	Query ( DWORD dwSize = BUFF_SIZE_EXT );
	Query ( LPCTSTR wsz );
	~Query ( );
};

class QueryExt : public CStringExt
{
	public:

	QueryExt ( LPCTSTR wsz, DWORD dwSize = BUFF_SIZE_EXT );
	~QueryExt ( );

	// string manipulation
	HRESULT Append ( DWORD dwCount, ... );

	private:

	DWORD	m_dwSizeConstant;
	LPCTSTR	m_wszStringConstant;
};

#endif	___EXTEND_QUERY___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\extendquery.cpp ===
// Query.cpp: implementation of the CQuery class.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ExtendQuery.h"

/////////////////////////////////////////////////////////////////////////////////////////
// query implementation
/////////////////////////////////////////////////////////////////////////////////////////

Query::Query ( DWORD dwSize ) : CStringExt ( dwSize )
{
}

Query::Query ( LPCTSTR wsz ) : CStringExt ( wsz )
{
}

Query::~Query ()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
// query extend implementation
/////////////////////////////////////////////////////////////////////////////////////////

QueryExt::QueryExt ( LPCTSTR wsz, DWORD dwSize ) : CStringExt ( dwSize ),

m_dwSizeConstant ( 0 ),
m_wszStringConstant ( NULL )

{
	if ( wsz )
	{
		try
		{
			DWORD dw = 0L;
			dw = lstrlen ( wsz );

			if SUCCEEDED ( Append ( 1, wsz ) )
			{
				m_dwSizeConstant = dw;
				m_wszStringConstant = wsz;
			}
			else
			{
				throw  CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch ( ... )
		{
			m_dwSizeConstant = 0L;
			m_wszStringConstant = NULL;

			throw;
		}
	}
}

QueryExt::~QueryExt ()
{
	m_dwSizeConstant = 0L;
	m_wszStringConstant = NULL;
}

HRESULT QueryExt::Append ( DWORD dwCount, ... )
{
	HRESULT hr = E_FAIL;

	if ( dwCount )
	{
		va_list argList;
		va_start ( argList, dwCount );
		hr = AppendList ( m_dwSizeConstant, m_wszStringConstant, dwCount, argList );
		va_end ( argList );
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\extendstring.h ===
// ExtendString.h: interface of the CStringExt class.
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#ifndef	___EXTEND_STRING___
#define	___EXTEND_STRING___

#if		_MSC_VER >= 1000
#pragma once
#endif	_MSC_VER >= 1000

#ifndef	_INC_TCHAR
#include <tchar.h>
#endif	_INC_TCHAR

#define BUFF_SIZE_EXT 256

class CStringExt
{
	public:

	// constructor
	CStringExt ( DWORD dwSize = BUFF_SIZE_EXT );
	CStringExt ( LPCTSTR wsz );

	// destructor
	virtual ~CStringExt ();

	// string manipulation
	HRESULT Append ( DWORD dwCount, ... );

	HRESULT Copy ( LPCTSTR wsz );
	HRESULT Clear ( );

	// LPTSTR
	inline operator LPTSTR() const
	{
		return m_wszString;
	}

	// append strings into string
	HRESULT AppendList		( DWORD dwConstantSize, LPCWSTR wszConstant, DWORD dwCount, va_list & argList );

	protected:

	DWORD	m_dwSize;
	LPTSTR	m_wszString;
};

#endif	___EXTEND_STRING___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\extendstring.cpp ===
// ExtendString.cpp: implementation of the CStringExt class.
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ExtendString.h"

CStringExt::CStringExt ( DWORD dwSize ) :

m_dwSize ( 0 ),
m_wszString ( NULL )

{
	if ( !dwSize )
	{
		dwSize = BUFF_SIZE_EXT;
	}

	try
	{
		if ( ( m_wszString = new TCHAR [ dwSize ] ) != NULL )
		{
			* m_wszString = 0;
			m_dwSize = dwSize;
		}
		else
		{
			throw  CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( m_wszString )
		{
			delete [] m_wszString;
			m_wszString = NULL;
		}

		m_dwSize = 0L;

		throw;
	}
}

CStringExt::CStringExt ( LPCTSTR wsz ) :

m_dwSize ( 0 ),
m_wszString ( NULL )

{
	try
	{
		DWORD dwSize = 0L;

		if ( wsz )
		{
			dwSize = lstrlen ( wsz ) + 1;

			if (dwSize < BUFF_SIZE_EXT)
			{
				dwSize = BUFF_SIZE_EXT;
			}
		}
		else
		{
			dwSize = BUFF_SIZE_EXT;
		}

		if ( ( m_wszString = new TCHAR [ dwSize ] ) != NULL )
		{
			if ( wsz )
			{
				lstrcpy ( m_wszString, wsz );
			}
			else
			{
				* m_wszString = 0;
			}

			m_dwSize = dwSize;
		}
		else
		{
			throw  CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( m_wszString )
		{
			delete [] m_wszString;
			m_wszString = NULL;
		}

		m_dwSize = 0L;

		throw;
	}
}

CStringExt::~CStringExt ()
{
	if ( m_wszString )
	{
		delete [] m_wszString;
		m_wszString = NULL;
	}

	m_dwSize = 0L;
}

HRESULT	CStringExt::Clear ()
{
	HRESULT hr = S_FALSE;

	if ( m_wszString )
	{
		*m_wszString = 0;
		hr = S_OK;
	}

	return hr;
}

HRESULT CStringExt::Copy ( LPCTSTR wsz )
{
	HRESULT hr = E_FAIL;

	if ( wsz )
	{
		Clear ();

		hr = Append ( 1, wsz );
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}

HRESULT CStringExt::Append ( DWORD dwCount, ... )
{
	HRESULT hr = E_FAIL;

	if ( dwCount )
	{
		va_list argList;
		va_start ( argList, dwCount );
		hr = AppendList ( 0, NULL, dwCount, argList );
		va_end ( argList );
	}
	else
	{
		hr = S_FALSE;
	}

	return hr;
}

HRESULT CStringExt::AppendList ( DWORD dwConstantSize, LPCWSTR wszConstant, DWORD dwCount, va_list & argList )
{
	HRESULT hr = S_OK;
	DWORD	dwsz = 0L;

	va_list argListSave = argList;

	try
	{
		LPCTSTR wszc = NULL;

		for ( DWORD dw = 0; dw < dwCount; dw++ )
		{
			if ( ( wszc = va_arg ( argList, LPCTSTR ) ) != NULL )
			{
				dwsz += lstrlen ( wszc );
			}
		}

		//reuse dw for offset into buffer for start
		if ( dwConstantSize && wszConstant )
		{
			dw = dwConstantSize;
		}
		else
		{
			dw = _tcslen ( m_wszString );
		}

		if ( dw + dwsz + 1 < m_dwSize )
		{
			LPTSTR wsz = NULL;
			//reuse dw for start of append
			dw = 0L;

			if ( dwConstantSize && wszConstant )
			{
				wsz = & ( m_wszString [ dwConstantSize ] );
				wszc = va_arg ( argListSave, LPCTSTR );

				_tcscpy ( wsz, wszc );
				dw = 1;
			}
			else
			{
				wsz = m_wszString;
			}

			for ( DWORD dwLoop = dw; dwLoop < dwCount; dwLoop++ )
			{
				if ( ( wszc = va_arg ( argListSave, LPCTSTR ) ) != NULL )
				{
					_tcscat ( wsz, wszc );
				}
			}
		}
		else
		{
			LPTSTR wszHelp = NULL;

			try
			{
				if ( ( wszHelp = new TCHAR [ dw + dwsz + 1 ] ) != NULL )
				{
					if ( dwConstantSize && wszConstant )
					{
						_tcscpy ( wszHelp, wszConstant );
					}
					else
					{
						_tcscpy ( wszHelp, m_wszString );
					}

					for ( dw = 0; dw < dwCount; dw++ )
					{
						LPCTSTR wszc = NULL;
						wszc = va_arg ( argListSave, LPCTSTR );

						if ( wszc )
						{
							_tcscat ( wszHelp, wszc );
						}
					}
				}
				else
				{
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
			catch ( ... )
			{
				if ( wszHelp )
				{
					delete [] wszHelp;
					wszHelp = NULL;
				}

				throw;
			}

			if ( m_wszString )
			{
				delete [] m_wszString;
				m_wszString = NULL;
			}

			m_wszString = wszHelp;
			m_dwSize = dw + dwsz + 1;

		}
	}
	catch ( ... )
	{
		throw;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\extensioninfoaction.cpp ===
// ExtensionInfoAction.cpp: implementation of the CExtensionInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ExtensionInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExtensionInfoAction::CExtensionInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CExtensionInfoAction::~CExtensionInfoAction()
{

}

HRESULT CExtensionInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE	hView	= NULL;
	MSIHANDLE	hVView	= NULL;
	MSIHANDLE	hSView	= NULL;
	MSIHANDLE	hMView	= NULL;
	MSIHANDLE	hRecord	= NULL;
	MSIHANDLE	hVRecord= NULL;
	MSIHANDLE	hSRecord= NULL;
	MSIHANDLE	hMRecord= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcExtension[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;

    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Extension`, `Component_`, `ProgId_` from Extension" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Extension`=\'", wcAction, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `Verb`, `Command`, `Argument` from Verb where `Extension_`=\'" );
	QueryExt wcQuery2 ( L"select `ShellNew`, `ShellNewValue` from Extension where `Extension`=\'" );
	QueryExt wcQuery3 ( L"select `MIME_` from Extension where `Extension`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	LPWSTR BufExtension = NULL;
	LPWSTR dynBufExtension = NULL;

	DWORD dwdynBufExtension = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView (  &hView, wcProductCode, wcQuery, L"Extension", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcExtension, dwdynBufExtension, dynBufExtension, BufExtension );
                        PutProperty(m_pObj, pExtension, BufExtension);

						// make query on fly
						wcQuery1.Append ( 2, BufExtension, L"\'" );

						PutKeyProperty ( m_pObj, pActionID, BufExtension, &bActionID, m_pRequest, 1, wcProductCode );
                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName	(	msidata.GetDatabase (),
														wcProductCode,
														Buffer
													)
						   )
						{
                            if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 4, pProgID, pName, pCaption, pDescription );

							CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery1, &hVView));
                            CheckMSI(g_fpMsiViewExecute(hVView, 0));

                            try{

                                uiStatus = g_fpMsiViewFetch(hVView, &hVRecord);

                                if(uiStatus != ERROR_NO_MORE_ITEMS){
                                    CheckMSI(uiStatus);

                                    dwBufSize = BUFF_SIZE;
									PutPropertySpecial ( hVRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pVerb );

                                    dwBufSize = BUFF_SIZE;
									PutPropertySpecial ( hVRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pCommand );

                                    dwBufSize = BUFF_SIZE;
									PutPropertySpecial ( hVRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pArgument );
                                }

								// make query on fly
								wcQuery2.Append ( 2, BufExtension, L"\'" );

                                if((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery2, &hSView)) !=
                                    ERROR_BAD_QUERY_SYNTAX){
                                    CheckMSI(uiStatus);

                                    CheckMSI(g_fpMsiViewExecute(hSView, 0));

                                    try{

                                        uiStatus = g_fpMsiViewFetch(hSView, &hSRecord);

                                        if(uiStatus != ERROR_NO_MORE_ITEMS){
                                            CheckMSI(uiStatus);

                                            dwBufSize = BUFF_SIZE;
											PutPropertySpecial ( hSRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pShellNew );

                                            dwBufSize = BUFF_SIZE;
											PutPropertySpecial ( hSRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pShellNewValue );
                                        }

                                    }catch(...){

                                        g_fpMsiViewClose(hSView);
                                        g_fpMsiCloseHandle(hSView);
                                        g_fpMsiCloseHandle(hSRecord);
                                        throw;
                                    }

                                    g_fpMsiViewClose(hSView);
                                    g_fpMsiCloseHandle(hSView);
                                    g_fpMsiCloseHandle(hSRecord);
                                }
								else
								{
									// make query on fly
									wcQuery3.Append ( 2, BufExtension, L"\'" );

                                    if((uiStatus = g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery3, &hMView)) !=
                                        ERROR_BAD_QUERY_SYNTAX){
                                        CheckMSI(uiStatus);

                                        CheckMSI(g_fpMsiViewExecute(hMView, 0));

                                        try{

                                            uiStatus = g_fpMsiViewFetch(hMView, &hMRecord);

                                            
                                            if(uiStatus != ERROR_NO_MORE_ITEMS){
                                                CheckMSI(uiStatus);

                                                dwBufSize = BUFF_SIZE;
												PutPropertySpecial ( hMRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pMIME );
                                            }

                                        }catch(...){

                                            g_fpMsiViewClose(hMView);
                                            g_fpMsiCloseHandle(hMView);
                                            g_fpMsiCloseHandle(hMRecord);
                                            throw;
                                        }

                                        g_fpMsiViewClose(hMView);
                                        g_fpMsiCloseHandle(hMView);
                                        g_fpMsiCloseHandle(hMRecord);

                                    }
                                }

								if ( dynBufExtension && dynBufExtension [ 0 ] != 0 )
								{
									dynBufExtension [ 0 ] = 0;
								}

                            }catch(...){

                                g_fpMsiViewClose(hVView);
                                g_fpMsiCloseHandle(hVView);
                                g_fpMsiCloseHandle(hVRecord);
                                throw;
                            }

                            g_fpMsiViewClose(hVView);
                            g_fpMsiCloseHandle(hVView);
                            g_fpMsiCloseHandle(hVRecord);

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if ( dynBufExtension )
				{
					delete [] dynBufExtension;
					dynBufExtension = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	if ( dynBufExtension )
	{
		delete [] dynBufExtension;
		dynBufExtension = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\extensioninfoaction.h ===
// ExtensionInfoAction.h: interface for the CExtensionInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EXTENSIONINFOACTION_H__75F6BA2C_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_EXTENSIONINFOACTION_H__75F6BA2C_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CExtensionInfoAction : public CGenericClass  
{
public:
	CExtensionInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CExtensionInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst,
		IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_EXTENSIONINFOACTION_H__75F6BA2C_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\filespecification.h ===
// FileSpecification.h: interface for the CFileSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILESPECIFICATION_H__DB614F28_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_FILESPECIFICATION_H__DB614F28_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CFileSpecification : public CGenericClass  
{
public:
	CFileSpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CFileSpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_FILESPECIFICATION_H__DB614F28_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\filespecification.cpp ===
// FileSpecification.cpp: implementation of the CFileSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "FileSpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileSpecification::CFileSpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CFileSpecification::~CFileSpecification()
{

}

HRESULT CFileSpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcID[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcFile[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    INSTALLSTATE piInstalled;
    int iState;

    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcFile);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}
			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File`, `Component_`, `FileName`, `FileSize`, `Version`, `Language`, `Attributes`, `Sequence` from File" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File`=\'", wcFile, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

	while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"File", FALSE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );
						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                        PutProperty(m_pObj, pFileSize, g_fpMsiRecordGetInteger(hRecord, 4));

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pVersion );

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 6, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pLanguage );

                        PutProperty(m_pObj, pAttributes, g_fpMsiRecordGetInteger(hRecord, 7));

                        PutProperty(m_pObj, pSequence, g_fpMsiRecordGetInteger(hRecord, 8));

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );
                        PutProperty(m_pObj, pName, Buffer);

						// make query on fly
						wcQuery1.Append ( 2, Buffer, L"\'" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}
						
                        if(ERROR_SUCCESS == g_fpMsiDatabaseOpenViewW( msidata.GetDatabase (), wcQuery1, &hSEView)){

                            if(ERROR_SUCCESS == g_fpMsiViewExecute(hSEView, 0)){

                                try{
										if ( ERROR_SUCCESS == g_fpMsiViewFetch(hSEView, &hSERecord)){

											dwBufSize = BUFF_SIZE;
											GetBufferToPut ( hSERecord, 1, dwBufSize, wcID, dwDynBuffer, dynBuffer, Buffer );

											if ( ValidateComponentID ( Buffer, wcProductCode ) )
											{
												PutProperty(m_pObj, pSoftwareElementID, Buffer);

												dwBufSize = BUFF_SIZE;
												wcscpy(wcBuf, L"");
												piInstalled = g_fpMsiGetComponentPathW(wcProductCode, Buffer, wcBuf, &dwBufSize);

												if ( dynBuffer && dynBuffer [ 0 ] != 0 )
												{
													dynBuffer [ 0 ] = 0;
												}

												SoftwareElementState(piInstalled, &iState);
												PutProperty(m_pObj, pSoftwareElementState, iState);

												PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

												dwBufSize = BUFF_SIZE;
												CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct (), L"ProductVersion", wcBuf,
													&dwBufSize));
												PutProperty(m_pObj, pVersion, wcBuf);
											//----------------------------------------------------

												if(bCheck) bMatch = true;

												if((atAction != ACTIONTYPE_GET)  || bMatch){

													hr = pHandler->Indicate(1, &m_pObj);
												}
											}
										}

                                }catch(...){
                                
                                    g_fpMsiViewClose(hSEView);
                                    g_fpMsiCloseHandle(hSEView);
                                    g_fpMsiCloseHandle(hSERecord);
                                    throw;
                                }

                                g_fpMsiViewClose(hSEView);
                                g_fpMsiCloseHandle(hSEView);
                                g_fpMsiCloseHandle(hSERecord);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
				msidata.CloseProduct ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
			msidata.CloseProduct ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\fontinfoaction.h ===
// FontInfoAction.h: interface for the CFontInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FONTINFOACTION_H__75F6BA24_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_FONTINFOACTION_H__75F6BA24_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CFontInfoAction : public CGenericClass  
{
public:
	CFontInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CFontInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_FONTINFOACTION_H__75F6BA24_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\fontinfoaction.cpp ===
// FontInfoAction.cpp: implementation of the CFontInfoAction class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "FontInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFontInfoAction::CFontInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CFontInfoAction::~CFontInfoAction()
{

}

HRESULT CFontInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `FontTitle` from Font" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Font", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pFile, Buffer);
						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 4, pFontTitle, pName, pCaption, pDescription );

                    //----------------------------------------------------

                        if(bActionID) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\inifile.cpp ===
// IniFile.cpp: implementation of the CIniFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "IniFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIniFile::CIniFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CIniFile::~CIniFile()
{

}

HRESULT CIniFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcFile[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcFile);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `IniFile`, `Component_`, `Section`, `Key`, `Value`, `Action` from IniFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `IniFile`=\'", wcFile, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"IniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pIniFile, Buffer);
                        PutProperty(m_pObj, pName, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSection);

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pKey);

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pValue);

                            PutProperty(m_pObj, pAction, g_fpMsiRecordGetInteger(hRecord, 6));

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\genericclass.cpp ===
// GenericClass.cpp: implementation of the CGenericClass class.
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "GenericClass.h"
#include <wininet.h>

#define   READ_HANDLE 0
#define   WRITE_HANDLE 1

#include "ExtendString.h"
#include "ExtendQuery.h"

#include <scopeguard.h>

CRITICAL_SECTION CGenericClass::m_cs;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGenericClass::CGenericClass(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx)
{
    m_pRequest = pObj;
    m_pNamespace = pNamespace;
    m_pCtx = pCtx;
    m_pObj = NULL;
    m_pClassForSpawning = NULL;
}

CGenericClass::~CGenericClass()
{
}

void CGenericClass::CleanUp()
{
    if(m_pClassForSpawning){
    
        m_pClassForSpawning->Release();
        m_pClassForSpawning = NULL;
    }
}

void CGenericClass::CheckMSI(UINT uiStatus)
{
    if(uiStatus == E_OUTOFMEMORY){
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }else if(uiStatus != ERROR_SUCCESS){
        throw ConvertError(uiStatus);
    }
}

HRESULT CGenericClass::CheckOpen(UINT uiStatus)
{
    switch(uiStatus){
    case ERROR_SUCCESS:
        return WBEM_S_NO_ERROR;
    case ERROR_ACCESS_DENIED:
        return WBEM_E_PRIVILEGE_NOT_HELD;
    default:
        return WBEM_E_FAILED;
    }
}

HRESULT CGenericClass::SetSinglePropertyPath(WCHAR wcProperty[])
{

    if( m_pRequest->m_iPropCount >= MSI_KEY_LIST_SIZE) {
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    if(m_pRequest->m_iValCount > m_pRequest->m_iPropCount){

        m_pRequest->m_Property[m_pRequest->m_iPropCount] = SysAllocString(wcProperty);

        if(!m_pRequest->m_Property[(m_pRequest->m_iPropCount)++])
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    return S_OK;
}

WCHAR * CGenericClass::GetFirstGUID(WCHAR wcIn[], WCHAR wcOut[])
{
	// safe operation
	// tested outside of that call
    wcscpy(wcOut, wcIn);
    wcOut[38] = NULL;

    return wcOut;
}

WCHAR * CGenericClass::RemoveFinalGUID(WCHAR wcIn[], WCHAR wcOut[])
{
	// safe operation
	// tested outside of that call
    wcscpy(wcOut, wcIn);
    wcOut[wcslen(wcOut) - 38] = NULL;

    return wcOut;
}

HRESULT CGenericClass::SpawnAnInstance(IWbemServices *pNamespace, IWbemContext *pCtx,
                        IWbemClassObject **pObj, BSTR bstrName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if(!m_pClassForSpawning){

        //Get ourselves an instance
        if(FAILED(hr = m_pNamespace->GetObject(bstrName, 0, m_pCtx, &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return hr;
        }
    }

    hr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return hr;
}

HRESULT CGenericClass::SpawnAnInstance(IWbemClassObject **pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if(!m_pClassForSpawning){

        //Get ourselves an instance
        if(FAILED(hr = m_pNamespace->GetObject(m_pRequest->m_bstrClass, 0, m_pCtx,
            &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return hr;
        }
    }

    hr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp)
        throw he;

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw he;

    VARIANT vp;
    VariantInit(&vp);
    V_VT(&vp) = VT_BSTR;
    V_BSTR(&vp) = SysAllocString(wcValue);
    if(!V_BSTR(&vp)){

        SysFreeString(bstrName);
        throw he;
    }

    if((wcValue == NULL) || (0 != _wcsicmp(wcValue, L""))){

        hr = pObj->Put(bstrName, 0, &vp, NULL);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            VariantClear(&vp);
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(&vp);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, int iValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    if(iValue != MSI_NULL_INTEGER){

	    VARIANT pv;
        VariantInit(&pv);
        V_VT(&pv) = VT_I4;
        V_I4(&pv) = iValue;

        hr = pObj->Put(bstrName, 0, &pv, NULL);

        VariantClear(&pv);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, float dValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    VariantInit(&pv);
    V_VT(&pv) = VT_R4;
    V_R4(&pv) = dValue;

    hr = pObj->Put(bstrName, 0, &pv, NULL);

    SysFreeString(bstrName);
    VariantClear(&pv);

    if(FAILED(hr))
        throw hr;

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, bool bValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    VARIANT pv;
    VariantInit(&pv);
    V_VT(&pv) = VT_BOOL;
    if(bValue) V_BOOL(&pv) = VARIANT_TRUE;
    else V_BOOL(&pv) = VARIANT_FALSE;

    hr = pObj->Put(bstrName, 0, &pv, NULL);

    SysFreeString(bstrName);
    VariantClear(&pv);

    if(FAILED(hr))
        throw hr;

    return hr;
}

HRESULT CGenericClass::PutKeyProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue,
                                      bool *bKey, CRequestObject *pRequest)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    VariantInit(&pv);
    V_VT(&pv) = VT_BSTR;
#ifdef _STRIP_ESCAPED_CHARS
    V_BSTR(&pv) = SysAllocString(ConvertToASCII(wcValue));
#else
    V_BSTR(&pv) = SysAllocString(wcValue);
#endif //_STRIP_ESCAPED_CHARS

    if(!V_BSTR(&pv))
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    if((wcValue == NULL) || (0 != wcscmp(wcValue, L""))){

        hr = pObj->Put(bstrName, 0, &pv, NULL);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            VariantClear(&pv);
            throw hr;
        }

        // Find the keys
        *bKey = false;
        int iPos = -1;
        if(FindIn(pRequest->m_Property, bstrName, &iPos) &&
            FindIn(pRequest->m_Value, V_BSTR(&pv), &iPos)) *bKey = true;

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(&pv);

    return hr;
}

HRESULT CGenericClass::PutKeyProperty(IWbemClassObject *pObj, const char *wcProperty, int iValue,
                                      bool *bKey, CRequestObject *pRequest)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR * wcTmp = (WCHAR *)malloc((strlen(wcProperty) + 1) * sizeof(WCHAR));
    if(!wcTmp) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    mbstowcs(wcTmp, wcProperty, (strlen(wcProperty) + 1));
    BSTR bstrName = SysAllocString(wcTmp);
    free((void *)wcTmp);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT pv;
    WCHAR wcBuf[BUFF_SIZE];

    if(iValue != MSI_NULL_INTEGER){

        VariantInit(&pv);
        V_VT(&pv) = VT_I4;
        V_I4(&pv) = iValue;

        hr = pObj->Put(bstrName, 0, &pv, NULL);

        VariantClear(&pv);

        if(FAILED(hr))
		{
            SysFreeString(bstrName);
            throw hr;
        }

        // Find the keys
        _itow(iValue, wcBuf, 10);
        BSTR bstrValue = SysAllocString(wcBuf);
        if(!bstrValue)
		{
            SysFreeString(bstrName);
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        *bKey = false;
        int iPos = -1;
        if(FindIn(pRequest->m_Property, bstrName, &iPos) &&
            FindIn(pRequest->m_Value, bstrValue, &iPos)) *bKey = true;

        SysFreeString(bstrValue);

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);

    return hr;
}

bool CGenericClass::FindIn(BSTR bstrProp[], BSTR bstrSearch, int *iPos)
{
    int i = 0;

    if(*iPos == (-1))
	{
        while(bstrProp[i] != NULL)
		{
            if(0 == _wcsicmp(bstrProp[i], bstrSearch))
			{
                *iPos = i;
                return true;
            }

            i++;
        }
    }
	else
	{
        if(0 == _wcsicmp(bstrProp[*iPos], bstrSearch))
		{
			return true;
		}
    }

    return false;
}

bool CGenericClass::GetView (	MSIHANDLE *phProduct,
								WCHAR *wcPackage,
								WCHAR *wcQuery,
								WCHAR *wcTable,
								BOOL bCloseProduct,
								BOOL bCloseDatabase
							)
{
    return msidata.GetView ( phProduct, wcPackage, wcQuery, wcTable, bCloseProduct, bCloseDatabase );
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, BSTR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

	ON_BLOCK_EXIT ( SysFreeString, bstrProp ) ;

    VariantInit(&v);
	ON_BLOCK_EXIT ( VariantClear, &v ) ;

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if( V_VT( &v ) == VT_BSTR )
		{
			if ( wcslen ( V_BSTR ( &v ) ) > INTERNET_MAX_PATH_LENGTH )
			{
				return WBEM_E_INVALID_METHOD_PARAMETERS;
			}

			*wcValue = SysAllocString(V_BSTR(&v));
		}
		else
		{
			*wcValue = SysAllocString(L"");
		}

        if(!wcValue)
            throw he;
    }

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, int *piValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(V_VT(&v) == VT_I4) *piValue = V_I4(&v);
        else *piValue = 0;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const char *cProperty, bool *pbValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    WCHAR wcTmp[BUFF_SIZE];
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(TcharToWchar(cProperty, wcTmp));
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if((V_VT(&v) == VT_BOOL) & V_BOOL(&v)) *pbValue = true;
        else *pbValue = false;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

/****************************************************************************
 *
 *      CGenericClass::LaunchProcess()
 *
 *      In:
 *          wcCommandLine - the commandline to pass to msimeth
 *
 *      Out:
 *          uiStatus - The variable that will recieve the return value
 *                     from the method call
 *
 *
 *      this method will handle method execution on NT4, where security
 *      restrictions prevent calling another DCOM server with an impersonating
 *      thread token.  This method will launch another process to handle the
 *      opperation after setting up a pipe for passing status messages from the
 *      external process back to the provider.
 *
 *****************************************************************************/
HRESULT CGenericClass::LaunchProcess(WCHAR *wcAction, WCHAR *wcCommandLine, UINT *uiStatus) 
{
    HRESULT hr = WBEM_E_FAILED;

    //check to see if server already running
    HANDLE hMutex = CreateMutex(NULL, TRUE, TEXT("MSIPROV_METHODS_SERVER"));

    if(hMutex){

        IWbemClassObject *pObj = NULL;
        BSTR bstrProcess = SysAllocString(L"Win32_Process");

        SetFileApisToOEM();

        HANDLE hPipe = CreateNamedPipe(L"\\\\.\\pipe\\msimeth_pipe", PIPE_ACCESS_INBOUND,
            (PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT), PIPE_UNLIMITED_INSTANCES,
            10000, 10000, 50000, NULL);

        if(SUCCEEDED(hr = m_pNamespace->GetObject(bstrProcess, 0, m_pCtx, &pObj, NULL))){
        
            IWbemClassObject *pInParam = NULL;
            IWbemClassObject *pOutParam = NULL;
            BSTR bstrCreate = SysAllocString(L"Create");

            // get the method paramater objects
            if(SUCCEEDED(hr = pObj->GetMethod(bstrCreate, 0, &pInParam, &pOutParam))){
            
                VARIANT v;
                BSTR bstrCommandLine = SysAllocString(L"CommandLine");
                IWbemClassObject *pStartup = NULL;

                VariantInit(&v);
                V_VT(&v) = VT_BSTR;
 
                WCHAR wcCommand[BUFF_SIZE];
                WCHAR wcTmp[10];
                UINT uiSize = BUFF_SIZE;
                GetSystemDirectoryW(wcCommand, uiSize);
                wcscat(wcCommand, L"\\wbem\\msimeth.exe ");
                wcscat(wcCommand, wcAction);
                wcscat(wcCommand, L" ");
                wcscat(wcCommand, _itow(m_pRequest->m_iThreadID, wcTmp, 10));
                wcscat(wcCommand, L" ");
                wcscat(wcCommand, wcCommandLine);

                V_BSTR(&v) = SysAllocString(wcCommand);

                // populate the in parameters
                if(SUCCEEDED(hr = pInParam->Put(bstrCommandLine, 0, &v, NULL))){

                    VariantClear(&v);

                    BSTR bstrProcessStartup = SysAllocString(L"Win32_ProcessStartup");
                    IWbemClassObject *pStartupObj = NULL;

                    if(SUCCEEDED(hr = m_pNamespace->GetObject(bstrProcessStartup, 0, m_pCtx,
                        &pStartupObj, NULL))){

                        IWbemClassObject *pStartupInst = NULL;

                        if(SUCCEEDED(hr = pStartupObj->SpawnInstance(0, &pStartupInst))){

                            LPVOID pEnv = GetEnvironmentStrings();
                            WCHAR *pwcVar = (WCHAR *)pEnv;

                            SAFEARRAYBOUND sbArrayBounds ;

                            long lCount = GetVarCount(pEnv);
                            sbArrayBounds.cElements = lCount;
                            sbArrayBounds.lLbound = 0;

                            if(V_ARRAY(&v) = SafeArrayCreate(VT_BSTR, 1, &sbArrayBounds)){

                                V_VT(&v) = VT_BSTR | VT_ARRAY ; 

                                BSTR bstrVal;

                                //get the environment variables into a VARIANT
                                for(long j = 0; j < lCount; j++){

                                    bstrVal = SysAllocString(pwcVar);
                                    SafeArrayPutElement(V_ARRAY(&v), &j, bstrVal);
                                    SysFreeString(bstrVal);

                                    pwcVar = GetNextVar(pwcVar);
                                }
                                
                                BSTR bstrEnvironmentVariables = SysAllocString(L"EnvironmentVariables");

                                if(SUCCEEDED(hr = pStartupInst->Put(bstrEnvironmentVariables, 0,
                                    &v, NULL))){

                                    VariantClear(&v);

                                    V_VT(&v) = VT_UNKNOWN;
                                    V_UNKNOWN(&v) = (IDispatch *)pStartupInst;
                                    pStartupInst->AddRef();

                                    BSTR bstrProcessStartupInformation = SysAllocString(L"ProcessStartupInformation");

                                    hr = pInParam->Put(bstrProcessStartupInformation, 0, &v, NULL);

                                    SysFreeString(bstrProcessStartupInformation);
                                }

                                SysFreeString(bstrEnvironmentVariables);
                            }

                            FreeEnvironmentStrings((LPWSTR)pEnv);

                            pStartupInst->Release();
                        }
                    
                        pStartupObj->Release();
                    }

                    SysFreeString(bstrProcessStartup);
                            
                    //we've no created our input object, so let's make the call
                    if(SUCCEEDED(hr = m_pNamespace->ExecMethod(bstrProcess, bstrCreate, 0,
                        m_pCtx, pInParam, &pOutParam, NULL))){
                        
                        VariantClear(&v);
                        BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                        if(SUCCEEDED(hr = pOutParam->Get(bstrReturnValue, 0, &v, NULL, NULL))){
                            
                            hr = V_I4(&v);
                            VariantClear(&v);

                            if(hr == 0){

                                BSTR bstrProcessID = SysAllocString(L"ProcessID");

                                if(SUCCEEDED(hr = pOutParam->Get(bstrProcessID, 0, &v, NULL, NULL))){
                                    
                                    //open process handle to check for exit
                                    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                                        (DWORD)V_I4(&v));

                                    ReleaseMutex(hMutex);
                                    
                                    if(hProcess){

                                        BOOL bRead = FALSE;
                                        DWORD dwRead = 0;
                                        WCHAR wcBuf[BUFF_SIZE];
                                        int nExitCode = STILL_ACTIVE;

                                        if(!GetExitCodeProcess(hProcess, (unsigned long*)&nExitCode)){

                                            hr = GetLastError();
                                        }

                                        /////////////////////////////////////////////////
                                        // Handle status messages as they are recieved

                                        while(nExitCode == STILL_ACTIVE){

                                            //synchronized pipe access
    //                                      WaitForSingleObject(hMutex, INFINITE);

                                            bRead = ReadFile(hPipe, wcBuf, BUFF_SIZE, &dwRead, NULL);

    //                                      ReleaseMutex(hMutex);

                                            if(!bRead){

                                                switch(GetLastError()){
                                                case ERROR_MORE_DATA:
                                                    //deal with unable to read whole message
                                                    break;
                                                case ERROR_HANDLE_EOF:
                                                    break;
                                                }
                                                
                                            }

                                            if(bRead && dwRead){

                                                //do some parsing, then...
                                                int iContext = _wtoi(wcstok(wcBuf, L"~"));
                                                UINT uiMessageType = _wtoi(wcstok(NULL, L"~"));
                                                LPWSTR lpwMessage = wcstok(NULL, L"\n");

                                                //process the message
                                                MyEventHandler(m_pRequest, uiMessageType, lpwMessage);
                                            }

                                            if(!GetExitCodeProcess(hProcess, (unsigned long*)&nExitCode)){

                                                hr = GetLastError();
                                                break;
                                            }
                                         
                                        }

                                        *uiStatus = nExitCode;

                                        CloseHandle(hPipe);
                                    }

                                }

                                SysFreeString(bstrProcessID);
                            
                            }else{

                                hr = WBEM_E_FAILED;
                            }
                        }

                        SysFreeString(bstrReturnValue);
                    }

                }

                pInParam->Release();
                pOutParam->Release();
                VariantClear(&v);
            }

            SysFreeString(bstrCreate);
            pObj->Release();
        }

        SysFreeString(bstrProcess);
    }

    if(hMutex){

        CloseHandle(hMutex);
        hMutex = NULL;
    }

    return hr;
}

INSTALLUI_HANDLER CGenericClass::SetupExternalUI()
{
	g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

	INSTALLUI_HANDLER ui = NULL;
	ui = g_fpMsiSetExternalUIW	(	MyEventHandler,
									(
										INSTALLLOGMODE_PROGRESS |
										INSTALLLOGMODE_ACTIONDATA |
										INSTALLLOGMODE_INFO |
										INSTALLLOGMODE_WARNING |
										INSTALLLOGMODE_ACTIONSTART
									),
									m_pRequest
								);

	g_fpMsiEnableLogW	(
							(	INSTALLLOGMODE_ACTIONDATA |
								INSTALLLOGMODE_INFO |
								INSTALLLOGMODE_FATALEXIT |
								INSTALLLOGMODE_ERROR |
								INSTALLLOGMODE_WARNING |
								INSTALLLOGMODE_USER |
								INSTALLLOGMODE_VERBOSE |
								INSTALLLOGMODE_RESOLVESOURCE |
								INSTALLLOGMODE_OUTOFDISKSPACE |
								INSTALLLOGMODE_COMMONDATA |
								INSTALLLOGMODE_PROPERTYDUMP |
								INSTALLLOGMODE_ACTIONSTART
							),
							g_wcpLoggingDir,
							INSTALLLOGATTRIBUTES_APPEND
						);

    return ui;
}

void CGenericClass::RestoreExternalUI( INSTALLUI_HANDLER ui )
{
	g_fpMsiSetExternalUIW	(	ui, 0, NULL );
}

WCHAR * CGenericClass::GetNextVar(WCHAR *pwcStart)
{

    WCHAR *pwc = pwcStart;

    //get to end of variable
    while(*pwc){ pwc++; }

    return ++pwc;
}

long CGenericClass::GetVarCount(void * pEnv)
{

    long lRetVal = 0;
    WCHAR *pwc = (WCHAR *)pEnv;

    //count the variables
    while(*pwc){

        //get to end of variable
        while(*pwc){ pwc++; }

        pwc++;
        lRetVal++;
    }

    return lRetVal;
}

//Special Property Methods
HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue, DWORD dwCount, ... )
{
	if ( dwCount )
	{
		HRESULT hr = E_FAIL;

		CStringExt prop ( wcValue );

		va_list argList;
		va_start ( argList, dwCount );
		hr = prop.AppendList ( 0, NULL, dwCount, argList );
		va_end ( argList );

		if SUCCEEDED ( hr )
		{
			hr = PutProperty ( pObj, wcProperty, prop );
		}

		return hr;
	}
	else
	{
		return PutProperty ( pObj, wcProperty,  wcValue );
	}
}

//Special Key Property Methods
HRESULT CGenericClass::PutKeyProperty	(	IWbemClassObject *pObj,
											const char *wcProperty,
											WCHAR *wcValue,
											bool *bKey,
											CRequestObject *pRequest,
											DWORD dwCount,
											...
										)
{
	if ( dwCount )
	{
		HRESULT hr = E_FAIL;

		CStringExt prop ( wcValue );

		va_list argList;
		va_start ( argList, dwCount );
		hr = prop.AppendList ( 0, NULL, dwCount, argList );
		va_end ( argList );

		if SUCCEEDED ( hr )
		{
			hr = PutKeyProperty ( pObj, wcProperty,prop, bKey, pRequest );
		}

		return hr;
	}
	else
	{
		return PutKeyProperty ( pObj, wcProperty, wcValue, bKey, pRequest );
	}
}

HRESULT	CGenericClass::GetBufferNeccessary 	(	MSIHANDLE& handle,
												DWORD dwIndex,
												DWORD& dwSize,
												LPWSTR staticBuffer,
												BOOL bThrow
											)
{
	HRESULT hResult = WBEM_S_NO_ERROR;
	UINT	uiStatus = ERROR_SUCCESS;

	DWORD dwOldSize = dwSize;

	uiStatus = g_fpMsiRecordGetStringW ( handle, dwIndex, staticBuffer, &dwSize );
	if ( uiStatus != ERROR_SUCCESS )
	{
		if ( uiStatus == ERROR_MORE_DATA )
		{
			hResult = WBEM_S_FALSE;
		}
		else
		{
			if ( bThrow )
			{
				CheckMSI ( uiStatus );
			}
			else
			{
				hResult = ConvertError ( uiStatus );
			}
		}
	}
	else
	{
		if ( hResult == WBEM_S_NO_ERROR )
		{
			if ( dwOldSize < dwSize )
			{
				hResult = WBEM_S_FALSE;
			}
		}
	}

	return hResult;
}

HRESULT CGenericClass::GetBuffer	(	MSIHANDLE& handle,
										DWORD dwIndex,
										DWORD& dwSize,
										DWORD& dwdynSize,
										LPWSTR& dynBuffer,
										BOOL bThrow
									)
{
	HRESULT hResult = WBEM_S_NO_ERROR;
	UINT	uiStatus = ERROR_SUCCESS;

	if ( dwSize )
	{
		if ( dwdynSize < dwSize )
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			if ( ( dynBuffer = new WCHAR [ dwSize + 1 ] ) != NULL )
			{
				dynBuffer [ 0 ] = 0;
				dwdynSize = dwSize;
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

		DWORD dwOldSize = dwSize;

		try
		{
			uiStatus = g_fpMsiRecordGetStringW ( handle, dwIndex, dynBuffer, &dwSize );
		}
		catch ( ... )
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			dwdynSize = 0;

			throw;
		}

		if ( uiStatus != ERROR_SUCCESS )
		{
			BOOL bError = TRUE;

			if ( dynBuffer && dynBuffer [ 0 ] != 0 )
			{
				dynBuffer [ 0 ] = 0;
			}

			// strange MSI problem !
			//
			// allocated buffer with lenght as expected
			// buffer sent and ERROR_MORE_DATA was returned
			// unfortunately requested lenght is equal as previous !

			if ( uiStatus == ERROR_MORE_DATA )
			{
				if ( dwOldSize == dwSize )
				{
					bError = FALSE;
				}
			}

			if ( bError )
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				dwdynSize = 0L;

				if ( bThrow )
				{
					CheckMSI ( uiStatus );
				}
				else
				{
					hResult = ConvertError ( uiStatus );
				}
			}
		}
	}
	else
	{
		hResult = WBEM_E_INVALID_PARAMETER;
	}

	return hResult;
}

HRESULT CGenericClass::PutPropertySpecial	(	MSIHANDLE& handle,
												DWORD dwIndex,
												DWORD& dwSize,
												LPWSTR staticBuffer,
												DWORD& dwdynSize,
												LPWSTR& dynBuffer,
												LPCSTR tszPropName,
												BOOL bThrow
											)
{
	HRESULT hResult = WBEM_S_NO_ERROR;
	UINT	uiStatus = ERROR_SUCCESS;

	if ( handle )
	{
		hResult = GetBufferNeccessary ( handle, dwIndex, dwSize, staticBuffer, bThrow );
		if SUCCEEDED ( hResult )
		{
			if ( hResult == WBEM_S_NO_ERROR )
			{
				hResult = PutProperty ( m_pObj, tszPropName, staticBuffer );
			}
			else
			if ( hResult == WBEM_S_FALSE )
			{
				try
				{
					hResult = GetBuffer ( handle, dwIndex, dwSize, dwdynSize, dynBuffer, bThrow );
					if SUCCEEDED ( hResult )
					{
						hResult = PutProperty ( m_pObj, tszPropName, dynBuffer );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}
					}
				}
				catch ( ... )
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					dwdynSize = 0;

					throw;
				}
			}
		}
	}
	else
	{
		hResult = WBEM_E_INVALID_PARAMETER;
	}

	return hResult;
}

HRESULT CGenericClass::PutPropertySpecial	(	MSIHANDLE& handle,
												DWORD dwIndex,
												DWORD& dwSize,
												LPWSTR staticBuffer,
												DWORD& dwdynSize,
												LPWSTR& dynBuffer,
												BOOL bThrow,
												DWORD dwCount,
												...
											)
{
	HRESULT hResult = WBEM_S_NO_ERROR;
	UINT	uiStatus = ERROR_SUCCESS;

	if ( handle )
	{
		va_list argList;
		va_start ( argList, dwCount );

		LPCSTR	tszPropName	= NULL;

		try
		{
			hResult = GetBufferNeccessary ( handle, dwIndex, dwSize, staticBuffer, bThrow );
			if SUCCEEDED ( hResult )
			{
				if ( hResult == WBEM_S_NO_ERROR )
				{
					for ( DWORD dw = 0; (dw < dwCount) && (SUCCEEDED ( hResult )) ; dw++ )
					{
						if ( ( tszPropName = va_arg ( argList, LPCSTR ) ) != NULL )
						{
							hResult = PutProperty ( m_pObj, tszPropName, staticBuffer );
	;					}
					}
				}
				else
				if ( hResult == WBEM_S_FALSE )
				{
					try
					{
						hResult = GetBuffer ( handle, dwIndex, dwSize, dwdynSize, dynBuffer, bThrow );
						if SUCCEEDED ( hResult )
						{
							for ( DWORD dw = 0; (dw < dwCount) && (SUCCEEDED ( hResult )) ; dw++ )
							{
								if ( ( tszPropName = va_arg ( argList, LPCSTR ) ) != NULL )
								{
									hResult = PutProperty ( m_pObj, tszPropName, dynBuffer );
								}
							}

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}
					}
					catch ( ... )
					{
						if ( dynBuffer )
						{
							delete [] dynBuffer;
							dynBuffer = NULL;
						}

						dwdynSize = 0;

						throw;
					}
				}
			}
		}
		catch ( ... )
		{
			va_end ( argList );
			throw;
		}

		va_end ( argList );
	}
	else
	{
		hResult = WBEM_E_INVALID_PARAMETER;
	}

	return hResult;
}

HRESULT CGenericClass::GetBufferToPut	(	MSIHANDLE& handle,
											DWORD dwIndex,
											DWORD& dwSize,
											LPWSTR staticBuffer,
											DWORD& dwdynSize,
											LPWSTR& dynBuffer,
											LPWSTR& Buffer,
											BOOL bThrow
										)
{
	HRESULT hResult = WBEM_S_NO_ERROR;
	UINT	uiStatus = ERROR_SUCCESS;

	if ( handle )
	{
		hResult = GetBufferNeccessary ( handle, dwIndex, dwSize, staticBuffer, bThrow );
		if SUCCEEDED ( hResult )
		{
			if ( hResult == WBEM_S_NO_ERROR )
			{
				Buffer = staticBuffer;
			}
			else
			if ( hResult == WBEM_S_FALSE )
			{
				try
				{
					hResult = GetBuffer ( handle, dwIndex, dwSize, dwdynSize, dynBuffer, bThrow );
					if SUCCEEDED ( hResult )
					{
						Buffer = dynBuffer;
					}
				}
				catch ( ... )
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					dwdynSize = 0;
					Buffer = NULL;

					throw;
				}
			}
		}
	}
	else
	{
		hResult = WBEM_E_INVALID_PARAMETER;
	}

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\genericclass.h ===
// GenericClass.h: interface for the CGenericClass class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_

#include "requestobject.h"
#include "MSIDataLock.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGenericClass  
{
	friend BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID );

public:
    CGenericClass(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
    virtual ~CGenericClass();

    //The instance write class which can optionally be implemented
    virtual HRESULT PutInst	(	CRequestObject *pObj,
								IWbemClassObject *pInst,
								IWbemObjectSink *pHandler,
								IWbemContext *pCtx
							)	= 0;

    IWbemClassObject *m_pObj;

    //The instance creation class which must be implemented
    virtual HRESULT CreateObject	(	IWbemObjectSink *pHandler,
										ACTIONTYPE atAction
									)	= 0;

    void CleanUp();

    CRequestObject *m_pRequest;

protected:

	// is get buffer neccessary ?
	HRESULT	GetBufferNeccessary ( MSIHANDLE& handle, DWORD dwIndex, DWORD& dwSize, LPWSTR staticBuffer, BOOL bThrow = TRUE );
	// get buffer ( caller has to delete )
	HRESULT	GetBuffer ( MSIHANDLE& handle, DWORD dwIndex, DWORD& dwSize, DWORD& dwdynSize, LPWSTR & dynBuffer, BOOL bThrow = TRUE );

	// special get buffer whic hold pointer for buffer to be used
	HRESULT	GetBufferToPut	(	MSIHANDLE& handle,
								DWORD dwIndex,
								DWORD& dwSize,
								LPWSTR staticBuffer,
								DWORD& dwdynSize,
								LPWSTR& dynBuffer,
								LPWSTR& Buffer,
								BOOL bThrow = TRUE
							);

    //Property Methods
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, int iValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, float dValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, bool bValue);

	//Special Property Methods
    HRESULT PutProperty(IWbemClassObject *pObj, const char *wcProperty, WCHAR *wcValue, DWORD dwCount, ... );

    //Key Property Methods
    HRESULT PutKeyProperty	(	IWbemClassObject *pObj,
								const char *wcProperty,
								WCHAR *wcValue,
								bool *bKey,
								CRequestObject *pRequest
							);

    HRESULT PutKeyProperty	(	IWbemClassObject *pObj,
								const char *wcProperty,
								int iValue,
								bool *bKey,
								CRequestObject *pRequest
							);

    //Special Key Property Methods
    HRESULT PutKeyProperty	(	IWbemClassObject *pObj,
								const char *wcProperty,
								WCHAR *wcValue,
								bool *bKey,
								CRequestObject *pRequest,
								DWORD dwCount,
								...
							);

	HRESULT PutPropertySpecial (	MSIHANDLE& handle,
									DWORD dwIndex,
									DWORD& dwSize,
									LPWSTR staticBuffer,
									DWORD& dwdynSize,
									LPWSTR& dynBuffer,
									LPCSTR wszPropName,
									BOOL bThrow = TRUE
								);

	HRESULT PutPropertySpecial (	MSIHANDLE& handle,
									DWORD dwIndex,
									DWORD& dwSize,
									LPWSTR staticBuffer,
									DWORD& dwdynSize,
									LPWSTR& dynBuffer,
									BOOL bThrow,
									DWORD dwCount,
									...
								);

    //This handles initialization of views
    bool GetView	(	
						MSIHANDLE *phView,
						WCHAR *wcPackage,
						WCHAR *wcQuery,
						WCHAR *wcTable,
						BOOL bCloseProduct,
						BOOL bCloseDatabase
					);

    //Utility Methods
    void CheckMSI(UINT uiStatus);
    HRESULT CheckOpen(UINT uiStatus);
    bool FindIn(BSTR bstrProp[], BSTR bstrSearch, int *iPos);
    HRESULT SetSinglePropertyPath(WCHAR wcProperty[]);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, BSTR *wcValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, int *piValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const char *cProperty, bool *pbValue);

    WCHAR * GetFirstGUID(WCHAR wcIn[], WCHAR wcOut[]);
    WCHAR * RemoveFinalGUID(WCHAR wcIn[], WCHAR wcOut[]);

    HRESULT SpawnAnInstance	(	IWbemServices *pNamespace,
								IWbemContext *pCtx,
								IWbemClassObject **pObj,
								BSTR bstrName
							);

    HRESULT SpawnAnInstance	(	IWbemClassObject **pObj	);

    INSTALLUI_HANDLER	SetupExternalUI		();								//Requires a current CRequestObject
	void				RestoreExternalUI	( INSTALLUI_HANDLER ui );		//Restore UI handle

	MSIDataLock msidata;

    IWbemServices *m_pNamespace;
    IWbemClassObject *m_pClassForSpawning;
    IWbemContext *m_pCtx;

    //functions/members for NT4 install fix
    HRESULT LaunchProcess(WCHAR *wcAction, WCHAR *wcCommandLine, UINT *uiStatus);
    WCHAR * GetNextVar(WCHAR *pwcStart);
    long GetVarCount(void * pEnv);

    static CRITICAL_SECTION m_cs;
};

#endif // !defined(AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\inifile.h ===
// IniFile.h: interface for the CIniFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_INIFILE_H__02FF6C8C_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_INIFILE_H__02FF6C8C_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CIniFile : public CGenericClass  
{
public:
	CIniFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CIniFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_INIFILE_H__02FF6C8C_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\installedsoftwareelement.h ===
// InstalledSoftwareElement.h: interface for the CInstalledSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_INSTALLEDSOFTWAREELEMENT_H__EAA368A5_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_INSTALLEDSOFTWAREELEMENT_H__EAA368A5_DEA4_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CInstalledSoftwareElement : public CGenericClass  
{
public:
	CInstalledSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CInstalledSoftwareElement();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_INSTALLEDSOFTWAREELEMENT_H__EAA368A5_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\installedsoftwareelement.cpp ===
// InstalledSoftwareElement.cpp: implementation of the CInstalledSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <tchar.h>
#include "InstalledSoftwareElement.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CInstalledSoftwareElement::CInstalledSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CInstalledSoftwareElement::~CInstalledSoftwareElement()
{

}

HRESULT CInstalledSoftwareElement::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcSoftware[BUFF_SIZE];
    WCHAR wcSysName[BUFF_SIZE];
    WCHAR wcComponentID[BUFF_SIZE];
    WCHAR wcElmName[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    CRequestObject *pSysRObj = NULL;
    CRequestObject *pElmRObj = NULL;
    bool bGotID = false;
    bool bGotName = false;
    bool bSysName = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int j;
        //GetObject optimizations
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        for(j = 0; j < m_pRequest->m_iPropCount; j++){
            
            if(_wcsicmp(m_pRequest->m_Property[j], L"System") == 0){

                pSysRObj = new CRequestObject();
                if(!pSysRObj) throw he;

                pSysRObj->Initialize(m_pNamespace);

                pSysRObj->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pSysRObj){

            for(j = 0; j < pSysRObj->m_iPropCount; j++){

                if(_wcsicmp(pSysRObj->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen ( pSysRObj->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcSysName, pSysRObj->m_Value[j]);
						bSysName = true;
						break;
					}
                }
            }

            pSysRObj->Cleanup();
            delete pSysRObj;
            pSysRObj = NULL;
        }

        for(j = 0; j < m_pRequest->m_iPropCount; j++){
            
            if(_wcsicmp(m_pRequest->m_Property[j], L"Element") == 0){

                pElmRObj = new CRequestObject();
                if(!pElmRObj) throw he;

                pElmRObj->Initialize(m_pNamespace);

                pElmRObj->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pElmRObj){

            for(j = 0; j < pElmRObj->m_iPropCount; j++){
            
                if(_wcsicmp(pElmRObj->m_Property[j], L"SoftwareElementID") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen ( pElmRObj->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcComponentID, pElmRObj->m_Value[j]);
						bGotID = true;
					}
                }

                if(_wcsicmp(pElmRObj->m_Property[j], L"Name") == 0){

                    //Get the name we're looking for
					if ( ::SysStringLen ( pElmRObj->m_Value[j] ) < BUFF_SIZE )
					{
						wcscpy(wcElmName, pElmRObj->m_Value[j]);
						bGotName = true;
					}
                }
            }

            pElmRObj->Cleanup();
            delete pElmRObj;
            pElmRObj = NULL;
        }
    }

    //These will change from class to class
    bool bSoftware, bSystem;

    CStringExt wcComputer;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component` from Component" );

    //optimize for GetObject
    if ( bGotID || bGotName )
	{
		if ( bGotName )
		{
			wcQuery.Append ( 3, L" where `Component`=\'", wcElmName, L"\'" );
		}

		if ( bGotID )
		{
			if ( bGotName )
			{
				wcQuery.Append ( 3, L" or `ComponentId`=\'", wcComponentID, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `ComponentId`=\'", wcComponentID, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Component", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

					dwBufSize = BUFF_SIZE;
					uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																Buffer,
																wcProductCode,
																wcSoftware,
																&dwBufSize
														   );

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    if( uiStatus == ERROR_SUCCESS )
					{
                        PutKeyProperty(m_pObj, pSoftware, wcSoftware, &bSoftware, m_pRequest);

                        TCHAR cBuf[MAX_COMPUTERNAME_LENGTH + 1];
                        dwBufSize = MAX_COMPUTERNAME_LENGTH+1;

                        if(!GetComputerName(cBuf, &dwBufSize)) throw WBEM_E_FAILED;

						// safe operation
                        wcComputer.Copy ( L"Win32_ComputerSystem.Name=\"" );

						#ifndef	UNICODE
                        WCHAR wcTmp[MAX_COMPUTERNAME_LENGTH + 1];
                        mbstowcs(wcTmp, cBuf, MAX_COMPUTERNAME_LENGTH + 1);

                        wcComputer.Append ( 2, wcTmp, L"\"" );
						#else	UNICODE
                        wcComputer.Append ( 2, cBuf, L"\"" );
						#endif	UNICODE

                        PutKeyProperty(m_pObj, pSystem, wcComputer, &bSystem, m_pRequest);

                        if(bSoftware && bSystem) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\launchcondition.h ===
// LaunchCondition.h: interface for the CLaunchCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LAUNCHCONDITION_H__75F6BA1D_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_LAUNCHCONDITION_H__75F6BA1D_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CLaunchCondition : public CGenericClass  
{
public:
	CLaunchCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CLaunchCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_LAUNCHCONDITION_H__75F6BA1D_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\mimeinfoaction.cpp ===
// MIMEInfoAction.cpp: implementation of the CMIMEInfoAction class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "MIMEInfoAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMIMEInfoAction::CMIMEInfoAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CMIMEInfoAction::~CMIMEInfoAction()
{

}

HRESULT CMIMEInfoAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ContentType`, `Extension_`, `CLSID` from MIME" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ContentType`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"MIME", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pContentType, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pExtension );

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pCLSID, wcBuf);

                    //----------------------------------------------------

                        if(bActionID) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\mimeinfoaction.h ===
// MIMEInfoAction.h: interface for the CMIMEInfoAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MIMEINFOACTION_H__75F6BA23_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_MIMEINFOACTION_H__75F6BA23_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CMIMEInfoAction : public CGenericClass  
{
public:
	CMIMEInfoAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CMIMEInfoAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_MIMEINFOACTION_H__75F6BA23_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\launchcondition.cpp ===
// LaunchCondition.cpp: implementation of the CLaunchCondition class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "LaunchCondition.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLaunchCondition::CLaunchCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CLaunchCondition::~CLaunchCondition()
{

}

HRESULT CLaunchCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcCondition[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;

    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcCondition);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Condition`, `Description` from LaunchCondition" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Condition`=\'", wcCondition, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"LaunchCondition", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pCondition, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\movefile.cpp ===
// MoveFile.cpp: implementation of the CMoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "MoveFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMoveFile::CMoveFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CMoveFile::~CMoveFile()
{

}

HRESULT CMoveFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `SourceName`, `SourceFolder`, `DestName`, `DestFolder`, `Options` from MoveFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `FileKey`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"MoveFile", TRUE , FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pFileKey, Buffer);
                        PutProperty(m_pObj, pName, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSourceName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSourceFolder );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDestName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 6, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDestFolder );

                            PutProperty(m_pObj, pOptions, g_fpMsiRecordGetInteger(hRecord, 7));

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WBEM Instance provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <tchar.h>
#include <objbase.h>
#include <initguid.h>
#include <msiprov.h>
#include "classfac.h"

#include "genericclass.h"
#include "requestobject.h"

// Function pointer type used with LoadMofFiles entrypoint in wbemupgd.dll
typedef BOOL ( WINAPI *PFN_LOAD_MOF_FILES )(wchar_t* pComponentName, const char* rgpszMofFilename[]);

HMODULE ghModule;

DEFINE_GUID(CLSID_MSIprov,0xbe0a9830, 0x2b8b, 0x11d1, 0xa9, 0x49, 0x0, 0x60, 0x18, 0x1e, 0xbb, 0xad);
// {BE0A9830-2B8B-11D1-A949-0060181EBBAD}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
	BOOL retVal = TRUE;
    if(DLL_PROCESS_DETACH == ulReason){
        
        DeleteCriticalSection(&g_msi_prov_cs);
	    DeleteCriticalSection(&(CRequestObject::m_cs));
		DeleteCriticalSection(&(CGenericClass::m_cs));
    
    }else if(DLL_PROCESS_ATTACH == ulReason){
        
		InitializeCriticalSection(&(CRequestObject::m_cs));
		InitializeCriticalSection(&(CGenericClass::m_cs));
		DisableThreadLibraryCalls(hInstance);			// 158024 

		try
		{
			//for this one we can't afford to throw on lock failure.
			retVal = InitializeCriticalSectionAndSpinCount(&g_msi_prov_cs, 0x80000000);
		}
		catch(...)
		{
			retVal = FALSE;
		}
    }

    return retVal;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
    HRESULT hr = 0;
    CProvFactory *pObj;

    if(CLSID_MSIprov!=rclsid) return E_FAIL;

    pObj = new CProvFactory();

    if(NULL == pObj) return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppv);

    if(FAILED(hr)) delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = (0L == g_cObj && 0L == g_cLock) ? S_OK : S_FALSE;
	if ( sc == S_OK )
	{
        UnloadMsiDll();

		if ( g_wcpLoggingDir )
		{
			delete [] g_wcpLoggingDir;
			g_wcpLoggingDir = NULL;
		}
	}

    return sc;
}

BOOL IsLessThan4()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion < 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
	#ifndef	UNICODE
    TCHAR       szID[265];
	#else	UNICODE
	TCHAR*		szID = NULL;
	#endif	UNICODE

    WCHAR       wcID[265];
    TCHAR       szCLSID[265];
    TCHAR       szModule[MAX_PATH+1];
    TCHAR * pName = _T("WMI MSI Provider");
    TCHAR * pModel;
    HKEY hKey1, hKey2;

    ghModule = GetModuleHandle(_T("MSIPROV"));

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(IsLessThan4()) pModel = _T("Apartment");
    else pModel = _T("Both");

    // Create the path.

    StringFromGUID2(CLSID_MSIprov, wcID, 128);

	#ifndef	UNICODE
    WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);
	#else	UNICODE
	szID = wcID;
	#endif	UNICODE

    _tcscpy(szCLSID, _T("Software\\classes\\CLSID\\"));
    _tcscat(szCLSID, szID);

#ifdef LOCALSERVER

    HKEY hKey;

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID, _T("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID, szID);

    RegCreateKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID, &hKey);
    RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)pName, (_tcslen(pName)+1) * sizeof ( TCHAR ));

    CloseHandle(hKey);

#endif

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (_tcslen(pName)+1) * sizeof ( TCHAR ));

    // Create entries under CLSID

#ifdef LOCALSERVER
    RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
#else
    RegCreateKey(hKey1, _T("InprocServer32"), &hKey2);
#endif

    szModule[MAX_PATH] = 0;
    GetModuleFileName(ghModule, szModule, MAX_PATH/*length in TCHARS*/);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, (_tcslen(szModule)+1) * sizeof ( TCHAR ));
    RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ, (BYTE *)pModel, (_tcslen(pModel)+1) * sizeof ( TCHAR ));

    CloseHandle(hKey1);
    CloseHandle(hKey2);

    // load the MOF files for this component
    HRESULT hr = NOERROR;
    
    HINSTANCE hinstWbemupgd = LoadLibrary(L"wbemupgd.dll");
    if (hinstWbemupgd)
    {
        PFN_LOAD_MOF_FILES pfnLoadMofFiles = (PFN_LOAD_MOF_FILES) GetProcAddress(hinstWbemupgd, "LoadMofFiles"); // no wide version of GetProcAddress
        if (pfnLoadMofFiles)
        {
            wchar_t*    wszComponentName = L"MSI Provider";
            const char* rgpszMofFilename[] = 
            {
                "msi.mof",
                "msi.mfl",
                NULL
            };
        
            if (!pfnLoadMofFiles(wszComponentName, rgpszMofFilename))
            {
                hr = WBEM_E_FAILED;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    
        FreeLibrary(hinstWbemupgd);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
   
    return hr;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR wcID[256];

	#ifndef	UNICODE
    TCHAR       szID[265];
	#else	UNICODE
	TCHAR*		szID = NULL;
	#endif	UNICODE

    TCHAR wcCLSID[256];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_MSIprov, wcID, 128);

	#ifndef	UNICODE
    WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);
	#else	UNICODE
	szID = wcID;
	#endif	UNICODE

    _tcscpy(wcCLSID, _T("Software\\classes\\CLSID\\"));
    _tcscat(wcCLSID, szID);

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID, _T("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID,wcCLSID);

    //Delete entries under APPID

    RegDeleteKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

    TCHAR szTemp[128];
    _tcscpy(szTemp, wcCLSID);
    _tcscat(szTemp,_T("\\"));
    _tcscat(szTemp,_T("LocalServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#endif

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, wcCLSID, &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKey(hKey, _T("InprocServer32"));
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, _T("Software\\classes\\CLSID"), &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\movefile.h ===
// MoveFile.h: interface for the CMoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MOVEFILE_H__72CDD5D5_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_MOVEFILE_H__72CDD5D5_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CMoveFile : public CGenericClass  
{
public:
	CMoveFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CMoveFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_MOVEFILE_H__72CDD5D5_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\msidatalock.h ===
////////////////////////////////////////////////////////////////////////////////////

//
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  All rights reserved.
//
//	Module Name:
//
//					MSIDataLock.h
//
//	Abstract:
//
//					declaration of lock for msi handles
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MSIDATALOCK_H__
#define	__MSIDATALOCK_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//would need msi
#ifndef	_MSI_H_
#include <msi.h>
#endif	_MSI_H_

////////////////////////////////////////////////////////////////////////////////////
// base class for lock
////////////////////////////////////////////////////////////////////////////////////
class MSIDataLockBase
{
protected:
	static HANDLE		m_hOwn;			// event to mark owner

	static LPWSTR		m_wszProduct;

	static MSIHANDLE	m_hProduct;		// msi handle to product
	static LONG			m_lRefProduct;	// msi handle to product ref count
	static BOOL			m_bProductOwn;	// msi handle to product own ?

	static MSIHANDLE	m_hDatabase;	// msi handle to database
	static LONG			m_lRefDatabase;	// msi handle to database ref count
	static BOOL			m_bDatabaseOwn;	// msi handle to database own ?

	static DWORD		m_ThreadID;		// id of thread that has locked/unlocked

	static LONG			m_lRef;			// reference count

public:

	MSIDataLockBase ();
	virtual ~MSIDataLockBase ();

	BOOL	Lock ( void );
	void	Unlock ( void );

private:

	BOOL	Initialize ();
	void	Uninitialize ();
};

////////////////////////////////////////////////////////////////////////////////////
// class for lock
////////////////////////////////////////////////////////////////////////////////////
class MSIDataLock : public MSIDataLockBase
{
	public:

	MSIDataLock()
	{
	}

	~MSIDataLock()
	{
	}

	#ifdef	__SUPPORT_STATIC

	static const MSIHANDLE GetProduct ()
	{
		return static_cast < MSIHANDLE > ( m_hProduct );
	}

	static const MSIHANDLE GetDatabase ()
	{
		return static_cast < MSIHANDLE > ( m_hDatabase );
	}

	#else	__SUPPORT_STATIC

	const MSIHANDLE GetProduct ()
	{
		return static_cast < MSIHANDLE > ( m_hProduct );
	}

	const MSIHANDLE GetDatabase ()
	{
		return static_cast < MSIHANDLE > ( m_hDatabase );
	}

	#endif	__SUPPORT_STATIC

	bool GetView (	MSIHANDLE *phView,
					WCHAR *wcPackage,
					WCHAR *wcQuery,
					WCHAR *wcTable,
					BOOL bCloseProduct,
					BOOL bCloseDatabase
				 );

	HRESULT	CloseProduct	( void );
	HRESULT	CloseDatabase	( void );

	private:

	HRESULT	OpenProduct		( LPCWSTR wszProduct );
	HRESULT	OpenDatabase	( );
	HRESULT	OpenDatabase	( LPCWSTR wszProduct );

	HRESULT	Query			( MSIHANDLE* pView, LPCWSTR wszQuery, LPCWSTR wszTable = NULL );

	HRESULT	OpenProductAlloc		( LPCWSTR wszProduct );
	HRESULT	OpenProductInternal		( LPCWSTR wszProduct );
};

#endif	__MSIDATALOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\msidatalock.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  All rights reserved.
//
//	Module Name:
//
//					MSIDataLock.cpp
//
//	Abstract:
//
//					definitions of lock for msi handles
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "MSIDataLock.h"

////////////////////////////////////////////////////////////////////////////////////
// extern variables
////////////////////////////////////////////////////////////////////////////////////
extern CRITICAL_SECTION g_msi_prov_cs;

MSIHANDLE MSIDataLockBase::m_hProduct = NULL;
MSIHANDLE MSIDataLockBase::m_hDatabase = NULL;
HANDLE MSIDataLockBase::m_hOwn	= NULL;
LPWSTR	MSIDataLockBase::m_wszProduct = NULL;
DWORD	MSIDataLockBase::m_ThreadID = 0L;
LONG	MSIDataLockBase::m_lRefProduct	= 0L;
LONG	MSIDataLockBase::m_lRefDatabase	= 0L;
BOOL	MSIDataLockBase::m_bProductOwn	= FALSE;
BOOL	MSIDataLockBase::m_bDatabaseOwn	= FALSE;
LONG	MSIDataLockBase::m_lRef = 0L;

////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////////

MSIDataLockBase::MSIDataLockBase ()
{
	Initialize ();
}

MSIDataLockBase::~MSIDataLockBase ()
{
	Uninitialize ();
}

BOOL	MSIDataLockBase::Initialize ()
{
	BOOL	bResult	= TRUE;

	::EnterCriticalSection ( &g_msi_prov_cs );

	if ( ! m_hOwn && ( m_hOwn = ::CreateEvent ( NULL, TRUE, TRUE, NULL ) ) == NULL )
	{
		bResult = FALSE;
	}

	if ( bResult )
	{
		m_lRef++;
	}

	::LeaveCriticalSection ( &g_msi_prov_cs );

	return bResult;
}

void	MSIDataLockBase::Uninitialize ()
{
	::EnterCriticalSection ( &g_msi_prov_cs );

	if ( m_lRef && ( --m_lRef == 0 ) )
	{
		if ( m_hOwn )
		{
			::CloseHandle ( m_hOwn );
			m_hOwn = NULL;
		}
	}

	::LeaveCriticalSection ( &g_msi_prov_cs );

	return;
}

BOOL	MSIDataLockBase::Lock ( void )
{
	BOOL	bResult	= FALSE;
	BOOL	bWork	= TRUE;
	BOOL	bSect	= TRUE;

	while ( bWork )
	{
		::EnterCriticalSection ( &g_msi_prov_cs );

		// we have obtained critsec now
		bSect = TRUE;

		// are handles already allocated ?
		if ( m_hProduct != NULL || m_hDatabase != NULL )
		{
			if ( ::GetCurrentThreadId () != m_ThreadID )
			{
				DWORD dwWaitResult = 0L;

				// we have left crit sec
				::LeaveCriticalSection ( &g_msi_prov_cs );
				bSect = FALSE;

				// wait till resource gets free again
				dwWaitResult = ::WaitForSingleObject ( m_hOwn, INFINITE );

				if ( dwWaitResult == WAIT_OBJECT_0 )
				{
					bWork	= TRUE;
					bResult	= FALSE;
				}
				else
				{
					bWork	= FALSE;
					bResult	= FALSE;
				}
			}
			else
			{
				bWork	= FALSE;
				bResult = TRUE;
			}
		}
		else
		{
			m_ThreadID = ::GetCurrentThreadId ( );

			bWork	= FALSE;
			bResult = TRUE;
		}
	}

	if ( bSect && ! bResult )
	{
		::LeaveCriticalSection ( &g_msi_prov_cs );
	}

	return bResult;
}

void	MSIDataLockBase::Unlock ( void )
{
	try
	{
		if ( !m_bProductOwn && !m_bDatabaseOwn )
		{
			m_ThreadID = 0;
			::SetEvent ( m_hOwn );
		}
	}
	catch (...)
	{
		::LeaveCriticalSection ( &g_msi_prov_cs );
		throw ;
	}

	::LeaveCriticalSection ( &g_msi_prov_cs );
}

HRESULT	MSIDataLock::OpenProductAlloc ( LPCWSTR wszProduct )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( ( m_wszProduct = new WCHAR [ lstrlenW ( wszProduct ) + 1 ] ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
		}

		lstrcpyW ( m_wszProduct, wszProduct );
	}
	catch ( ... )
	{
		if ( m_wszProduct )
		{
			delete [] m_wszProduct;
			m_wszProduct = NULL;
		}

		throw;
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenProductInternal ( LPCWSTR wszProduct )
{
	HRESULT hRes	 = E_FAIL;
	UINT	uiStatus = ERROR_SUCCESS;

	BOOL	bAlloc	 = FALSE;

	try
	{
		if ( ( uiStatus = g_fpMsiOpenProductW ( wszProduct, &m_hProduct ) ) != ERROR_SUCCESS )
		{
			if ( uiStatus == static_cast < UINT > ( E_OUTOFMEMORY ) )
			{
				throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
			}
		}
	}
	catch ( ... )
	{
		if ( m_hProduct )
		{
			g_fpMsiCloseHandle ( m_hProduct );
			m_hProduct = NULL;
		}

		throw;
	}

	if ( uiStatus != ERROR_SUCCESS )
	{
		//and if that didn't work, yet another way
		WCHAR * wcBuf		= NULL;
		DWORD	dwBufsize	= BUFF_SIZE;

		if ( ( wcBuf = new WCHAR [ BUFF_SIZE ] ) == NULL )
		{
			throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
		}

		try
		{
			if ( ( uiStatus = g_fpMsiGetProductInfoW ( wszProduct, INSTALLPROPERTY_LOCALPACKAGE, wcBuf, &dwBufsize ) ) == ERROR_SUCCESS )
			{
				if ( dwBufsize > 0 )
				{
					uiStatus = g_fpMsiOpenPackageW ( wcBuf, &m_hProduct );
				}
			}
		}
		catch ( ... )
		{
			delete [] wcBuf;
			throw ;
		}

		delete [] wcBuf;

		if ( uiStatus == ERROR_SUCCESS && m_hProduct )
		{
			bAlloc = TRUE;
		}
	}
	else
	{
		if ( m_hProduct )
		{
			bAlloc = TRUE;
		}
	}

	if ( bAlloc )
	{
		try
		{
			hRes = OpenProductAlloc ( wszProduct );
		}
		catch ( ... )
		{
			if ( m_hProduct )
			{
				g_fpMsiCloseHandle ( m_hProduct );
				m_hProduct = NULL;
			}

			throw;
		}
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenProduct ( LPCWSTR wszProduct )
{
	HRESULT hRes = E_FAIL;

	if ( ! wszProduct )
	{
		hRes = E_INVALIDARG;
	}
	else
	{
		if ( Lock ( ) )
		{
			try
			{
				if ( ! m_hProduct && ! m_wszProduct )
				{
					hRes = OpenProductInternal ( wszProduct );

					if FAILED ( hRes )
					{
						if ( m_wszProduct )
						{
							delete [] m_wszProduct;
							m_wszProduct = NULL;
						}

						if ( m_hProduct )
						{
							g_fpMsiCloseHandle ( m_hProduct );
							m_hProduct = NULL;
						}
					}
				}
				else
				{
					if ( m_hProduct && m_wszProduct && lstrcmpW ( wszProduct, m_wszProduct ) == 0 )
					{
						hRes = S_OK;
					}
				}

				if SUCCEEDED ( hRes )
				{
					if ( m_lRefProduct == 0 )
					{
						m_bProductOwn	= TRUE;
						::ResetEvent ( m_hOwn );
					}

					m_lRefProduct++;
				}
			}
			catch ( ... )
			{
				Unlock ( );
				throw;
			}

			Unlock ( );
		}
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenDatabase ( )
{
	HRESULT hRes = E_FAIL;

	if ( Lock ( ) )
	{
		try
		{
			if ( m_hProduct )
			{
				if ( ! m_hDatabase )
				{
					m_hDatabase = g_fpMsiGetActiveDatabase ( m_hProduct );

					if ( m_hDatabase != NULL )
					{
						hRes = S_OK;
					}
				}
				else
				{
					MSIHANDLE hDatabase = NULL;
					hDatabase = g_fpMsiGetActiveDatabase ( m_hProduct );

					if ( hDatabase != NULL )
					{
						if ( hDatabase == m_hDatabase )
						{
							g_fpMsiCloseHandle ( hDatabase );
							hDatabase = NULL;

							hRes = S_OK;
						}
					}
				}

				if SUCCEEDED ( hRes )
				{
					if ( m_lRefDatabase == 0 )
					{
						m_bDatabaseOwn	= TRUE;
						::ResetEvent ( m_hOwn );
					}

					m_lRefDatabase++;
				}
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::OpenDatabase ( LPCWSTR wszProduct )
{
	HRESULT	hRes	= E_FAIL;

	if ( Lock ( ) )
	{
		try
		{
			if SUCCEEDED ( hRes = OpenProduct ( wszProduct ) )
			{
				hRes = OpenDatabase ();

				if FAILED ( hRes )
				{
					// we have to close product
					CloseProduct ();
				}
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::CloseProduct ()
{
	HRESULT	hRes	= S_FALSE;

	if ( Lock ( ) )
	{
		try
		{
			if ( m_hProduct && m_lRefProduct && ( --m_lRefProduct == 0 ) )
			{
				delete [] m_wszProduct;
				m_wszProduct = NULL;

				g_fpMsiCloseHandle ( m_hProduct );
				m_hProduct		= NULL;
				m_bProductOwn	= FALSE;
				hRes = S_OK;
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::CloseDatabase ( )
{
	HRESULT	hRes	= E_FAIL;

	if ( Lock ( ) )
	{
		try
		{
			if ( m_hDatabase && m_lRefDatabase && ( --m_lRefDatabase == 0 ) )
			{
				g_fpMsiCloseHandle ( m_hDatabase );
				m_hDatabase = NULL;
				m_bDatabaseOwn	= FALSE;
				hRes = S_OK;
			}
		}
		catch ( ... )
		{
			Unlock ( );
			throw;
		}

		Unlock ( );
	}

	return hRes;
}

HRESULT	MSIDataLock::Query ( MSIHANDLE* pView, LPCWSTR wszQuery, LPCWSTR wszTable )
{
	HRESULT	hRes	= S_OK;
	UINT	uiStatus= ERROR_SUCCESS;

	if ( ! pView )
	{
		hRes = E_POINTER;
	}
	else
	{
		( * pView ) = NULL;

		if ( ! wszQuery )
		{
			hRes = E_INVALIDARG;
		}
		else
		{
			if ( Lock ( ) )
			{
				if ( m_hDatabase )
				{
					try
					{
						if ( wszTable )
						{
							if ( g_fpMsiDatabaseIsTablePersistentW ( m_hDatabase, wszTable ) != MSICONDITION_TRUE )
							{
								hRes = E_FAIL;
							}
						}

						if SUCCEEDED ( hRes )
						{
							if ( ( uiStatus = g_fpMsiDatabaseOpenViewW ( m_hDatabase, wszQuery, pView ) ) == ERROR_SUCCESS )
							{
								if ( g_fpMsiViewExecute ( *pView, 0 ) != ERROR_SUCCESS )
								{
									if ( *pView )
									{
										g_fpMsiCloseHandle ( *pView );
										( * pView ) = NULL;
									}

									hRes = E_FAIL;
								}
							}
							else
							{
								if ( uiStatus == static_cast < UINT > ( E_OUTOFMEMORY ) )
								{
									throw CHeap_Exception ( CHeap_Exception::E_ALLOCATION_ERROR );
								}

								// what is the failure here ?
								hRes = HRESULT_FROM_WIN32 ( uiStatus );
							}
						}
					}
					catch ( ... )
					{
						Unlock ( );
						throw;
					}
				}
				else
				{
					hRes = E_UNEXPECTED;
				}

				Unlock ( );
			}
		}
	}

	return hRes;
}

bool MSIDataLock::GetView	(	MSIHANDLE *phView,
								WCHAR *wcPackage,
								WCHAR *wcQuery,
								WCHAR *wcTable,
								BOOL bCloseProduct,
								BOOL bCloseDatabase
							)
{
    bool bResult	= false;

	if ( wcPackage )
	{
		if ( Lock () )
		{
			try
			{
				if SUCCEEDED ( OpenDatabase ( wcPackage ) )
				{
					if ( phView && wcQuery )
					{
						if SUCCEEDED ( Query ( phView, wcQuery, wcTable ) )
						{
							bResult = true;
						}
					}
					else
					{
						bResult = true;
					}

					if ( bCloseDatabase )
					{
						CloseDatabase ();
					}
				}

				if ( bCloseProduct )
				{
					CloseProduct ();
				}
			}
			catch ( ... )
			{
				CloseProduct ();
				CloseDatabase ();

				Unlock ();

				throw;
			}

			Unlock ();
		}
	}

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcattribute.h ===
// ODBCAttribute.h: interface for the CODBCAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCATTRIBUTE_H__DB614F26_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_ODBCATTRIBUTE_H__DB614F26_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCAttribute : public CGenericClass  
{
public:
	CODBCAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCATTRIBUTE_H__DB614F26_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\msiprov.h ===
//***************************************************************************

//

//  MSIProv.h

//

//  Module: WBEM MSI instance provider code.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _MSIProv_H_
#define _MSIProv_H_

#define _WIN32_DCOM

#include <wbemidl.h>
#include <ProvExce.h>

#include <msi.h>
#include <msiQuery.h>
#include <objbase.h>

//#include "msimeth.h"

#define BUFF_SIZE 512
#define QUERY_SIZE 128
#define MSI_PACKAGE_LIST_SIZE 100
#define MSI_MAX_APPLICATIONS 1500
#define MSI_KEY_LIST_SIZE 10

typedef enum tagACTIONTYPE
{
	ACTIONTYPE_ENUM =	0,
	ACTIONTYPE_GET =	1,
	ACTIONTYPE_QUERY =	2

} ACTIONTYPE;

// The provider string is always in WCHAR format

#define DELIMETER L'|'

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
extern bool UnloadMsiDll();
class CMSIProv : public IWbemServices, public IWbemProviderInit
{
    protected:
        ULONG m_cRef;         //Object reference count
     public:

		 IWbemServices *m_pNamespace;

        CMSIProv(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CMSIProv(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink);
        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync(const BSTR ObjectPath, const BSTR Method,
												  long lFlags,
												  IWbemContext *pCtx,
												  IWbemClassObject *pInParams,
												  IWbemObjectSink *pResponse);

private:

	bool CheckForMsiDll();
	static CHeap_Exception m_he;
};

typedef CMSIProv *PCMSIProv;

// Some utility functions

char * WcharToTchar(WCHAR * wcPtr, char *wcTmp);
WCHAR * TcharToWchar(char * tcPtr, WCHAR *wcTmp);
WCHAR * TcharToWchar(const char * tcPtr, WCHAR *wcTmp);
HRESULT ConvertError(UINT uiStatus);
WCHAR * EscapeStringW(WCHAR * wcIn, WCHAR * wcOut);
bool SafeLeaveCriticalSection(CRITICAL_SECTION *pcs);

void SoftwareElementState(INSTALLSTATE piInstalled, int *iState);
bool CreateProductString(WCHAR *cProductCode, WCHAR *cProductPath);

DWORD CreateSoftwareElementString	(	MSIHANDLE hDatabase,
										WCHAR *wcComponent,
										WCHAR *wcProductCode,
										WCHAR *wcPath,
										DWORD * dwPath
									);

bool CreateSoftwareFeatureString(WCHAR *wcName, WCHAR *wcProductCode, WCHAR * wcString, bool bValidate);

int GetOS();
bool IsNT4();
bool IsNT5();
BOOL IsLessThan4();
bool AreWeOnNT();
HRESULT CheckImpersonationLevel();
bool ValidateComponentID(WCHAR *wcID, WCHAR *wcProductCode);
bool ValidateComponentName(MSIHANDLE hDatabase, WCHAR *wcProductCode, WCHAR *wcName);
bool ValidateFeatureName(WCHAR *wcName, WCHAR *wcProduct);

// These variables keep track of when the module can be unloaded
extern long       g_cObj;
extern long       g_cLock;

// These variables keep track of acces to the MSI databases
extern CRITICAL_SECTION g_msi_prov_cs;

extern WCHAR *g_wcpLoggingDir;

//These are the valiables used to track MSI.dll and it's exported functions
typedef UINT (CALLBACK* LPFNMSIVIEWFETCH)(MSIHANDLE, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIRECORDGETSTRINGW)(MSIHANDLE, unsigned int, LPWSTR, DWORD*);
typedef UINT (CALLBACK* LPFNMSICLOSEHANDLE)(MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIDATABASEOPENVIEWW)(MSIHANDLE, LPCWSTR, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIVIEWEXECUTE)(MSIHANDLE, MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIGETACTIVEDATABASE)(MSIHANDLE);
typedef INSTALLSTATE (CALLBACK* LPFNMSIGETCOMPONENTPATHW)(LPCWSTR, LPCWSTR, LPWSTR, DWORD*);
typedef UINT (CALLBACK* LPFNMSIGETCOMPONENTSTATEW)(MSIHANDLE, LPCWSTR, INSTALLSTATE*, INSTALLSTATE*);
typedef UINT (CALLBACK* LPFNMSIOPENPRODUCTW)(LPCWSTR, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIOPENPACKAGEW)(LPCWSTR, MSIHANDLE*);
typedef UINT (CALLBACK* LPFNMSIDATABASEISTABLEPERSITENTW)(MSIHANDLE, LPCWSTR);
typedef INSTALLUILEVEL (CALLBACK* LPFNMSISETINTERNALUI)(INSTALLUILEVEL, HWND);
typedef INSTALLUI_HANDLER (CALLBACK* LPFNMSISETEXTERNALUIW)(INSTALLUI_HANDLER, DWORD, LPVOID);
typedef UINT (CALLBACK* LPFNMSIENABLELOGW)(DWORD, LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIGETPRODUCTPROPERTYW)(MSIHANDLE, LPCWSTR, LPWSTR, DWORD*);
typedef INSTALLSTATE (CALLBACK* LPFNMSIQUERYPRODUCTSTATEW)(LPCWSTR);
typedef UINT (CALLBACK* LPFNMSIINSTALLPRODUCTW)(LPCWSTR, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSICONFIGUREPRODUCTW)(LPCWSTR, int, INSTALLSTATE);
typedef UINT (CALLBACK* LPFNMSIREINSTALLPRODUCTW)(LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIAPPLYPATCHW)(LPCWSTR, LPCWSTR, INSTALLTYPE, LPCWSTR);
typedef int (CALLBACK* LPFNMSIRECORDGETINTEGER)(MSIHANDLE, unsigned int);
typedef UINT (CALLBACK* LPFNMSIENUMFEATURESW)(LPCWSTR, DWORD, LPWSTR, LPWSTR);
typedef UINT (CALLBACK* LPFNMSIGETPRODUCTINFOW)(LPCWSTR, LPCWSTR, LPWSTR, DWORD*);
typedef INSTALLSTATE (CALLBACK* LPFNMSIQUERYFEATURESTATEW)(LPCWSTR, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSIGETFEATUREUSAGEW)(LPCWSTR, LPCWSTR, DWORD*, WORD*);
typedef UINT (CALLBACK* LPFNMSIGETFEATUREINFOW)(MSIHANDLE, LPCWSTR, DWORD*, LPWSTR, DWORD*, LPWSTR, DWORD*);
typedef UINT (CALLBACK* LPFNMSICONFIGUREFEATUREW)(LPCWSTR, LPCWSTR, INSTALLSTATE);
typedef UINT (CALLBACK* LPFNMSIREINSTALLFEATUREW)(LPCWSTR, LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIENUMPRODUCTSW)(DWORD, LPWSTR);
typedef UINT (CALLBACK* LPFNMSIGETDATABASESTATE)(MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIRECORDSETSTRINGW)(MSIHANDLE, unsigned int, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSIDATABASECOMMIT)(MSIHANDLE);
typedef UINT (CALLBACK* LPFNMSIENUMCOMPONENTSW)(DWORD, LPWSTR);
typedef UINT (CALLBACK* LPFNMSIVIEWCLOSE)(MSIHANDLE);

extern bool g_bMsiPresent;
extern bool g_bMsiLoaded;

extern LPFNMSIVIEWFETCH					g_fpMsiViewFetch;
extern LPFNMSIRECORDGETSTRINGW			g_fpMsiRecordGetStringW;
extern LPFNMSICLOSEHANDLE				g_fpMsiCloseHandle;
extern LPFNMSIDATABASEOPENVIEWW			g_fpMsiDatabaseOpenViewW;
extern LPFNMSIVIEWEXECUTE				g_fpMsiViewExecute;
extern LPFNMSIGETACTIVEDATABASE			g_fpMsiGetActiveDatabase;
extern LPFNMSIGETCOMPONENTPATHW			g_fpMsiGetComponentPathW;
extern LPFNMSIGETCOMPONENTSTATEW		g_fpMsiGetComponentStateW;
extern LPFNMSIOPENPRODUCTW				g_fpMsiOpenProductW;
extern LPFNMSIOPENPACKAGEW				g_fpMsiOpenPackageW;
extern LPFNMSIDATABASEISTABLEPERSITENTW	g_fpMsiDatabaseIsTablePersistentW;
extern LPFNMSISETINTERNALUI				g_fpMsiSetInternalUI;
extern LPFNMSISETEXTERNALUIW			g_fpMsiSetExternalUIW;
extern LPFNMSIENABLELOGW				g_fpMsiEnableLogW;
extern LPFNMSIGETPRODUCTPROPERTYW		g_fpMsiGetProductPropertyW;
extern LPFNMSIQUERYPRODUCTSTATEW		g_fpMsiQueryProductStateW;
extern LPFNMSIINSTALLPRODUCTW			g_fpMsiInstallProductW;
extern LPFNMSICONFIGUREPRODUCTW			g_fpMsiConfigureProductW;
extern LPFNMSIREINSTALLPRODUCTW			g_fpMsiReinstallProductW;
extern LPFNMSIAPPLYPATCHW				g_fpMsiApplyPatchW;
extern LPFNMSIRECORDGETINTEGER			g_fpMsiRecordGetInteger;
extern LPFNMSIENUMFEATURESW				g_fpMsiEnumFeaturesW;
extern LPFNMSIGETPRODUCTINFOW			g_fpMsiGetProductInfoW;
extern LPFNMSIQUERYFEATURESTATEW		g_fpMsiQueryFeatureStateW;
extern LPFNMSIGETFEATUREUSAGEW			g_fpMsiGetFeatureUsageW;
extern LPFNMSIGETFEATUREINFOW			g_fpMsiGetFeatureInfoW;
extern LPFNMSICONFIGUREFEATUREW			g_fpMsiConfigureFeatureW;
extern LPFNMSIREINSTALLFEATUREW			g_fpMsiReinstallFeatureW;
extern LPFNMSIENUMPRODUCTSW				g_fpMsiEnumProductsW;
extern LPFNMSIGETDATABASESTATE			g_fpMsiGetDatabaseState;
extern LPFNMSIRECORDSETSTRINGW			g_fpMsiRecordSetStringW;
extern LPFNMSIDATABASECOMMIT			g_fpMsiDatabaseCommit;
extern LPFNMSIENUMCOMPONENTSW			g_fpMsiEnumComponentsW;
extern LPFNMSIVIEWCLOSE					g_fpMsiViewClose;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasource.h ===
// ODBCDataSource.h: interface for the CODBCDataSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDATASOURCE_H__75F6BA13_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDATASOURCE_H__75F6BA13_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDataSource : public CGenericClass  
{
public:
	CODBCDataSource(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDataSource();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDATASOURCE_H__75F6BA13_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\msiprov.cpp ===
//***************************************************************************

//

//  MSIProv.CPP

//

//  Module: WBEM Instance provider for MSI

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <wbemcli_i.c>
#include <wbemprov_i.c>
#include "requestobject.h"
//#define _MT
#include <process.h>
#include <Polarity.h>

#include <tchar.h>

CRITICAL_SECTION g_msi_prov_cs;

WCHAR *g_wcpLoggingDir = NULL;

bool g_bMsiPresent = true;
bool g_bMsiLoaded = false;

CHeap_Exception CMSIProv::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

LPFNMSIVIEWFETCH                    g_fpMsiViewFetch = NULL;
LPFNMSIRECORDGETSTRINGW             g_fpMsiRecordGetStringW = NULL;
LPFNMSICLOSEHANDLE                  g_fpMsiCloseHandle = NULL;
LPFNMSIDATABASEOPENVIEWW            g_fpMsiDatabaseOpenViewW = NULL;
LPFNMSIVIEWEXECUTE                  g_fpMsiViewExecute = NULL;
LPFNMSIGETACTIVEDATABASE            g_fpMsiGetActiveDatabase = NULL;
LPFNMSIGETCOMPONENTPATHW            g_fpMsiGetComponentPathW = NULL;
LPFNMSIGETCOMPONENTSTATEW           g_fpMsiGetComponentStateW = NULL;
LPFNMSIOPENPRODUCTW                 g_fpMsiOpenProductW = NULL;
LPFNMSIOPENPACKAGEW                 g_fpMsiOpenPackageW = NULL;
LPFNMSIDATABASEISTABLEPERSITENTW    g_fpMsiDatabaseIsTablePersistentW = NULL;
LPFNMSISETINTERNALUI                g_fpMsiSetInternalUI = NULL;
LPFNMSISETEXTERNALUIW               g_fpMsiSetExternalUIW = NULL;
LPFNMSIENABLELOGW                   g_fpMsiEnableLogW = NULL;
LPFNMSIGETPRODUCTPROPERTYW          g_fpMsiGetProductPropertyW = NULL;
LPFNMSIQUERYPRODUCTSTATEW           g_fpMsiQueryProductStateW = NULL;
LPFNMSIINSTALLPRODUCTW              g_fpMsiInstallProductW = NULL;
LPFNMSICONFIGUREPRODUCTW            g_fpMsiConfigureProductW = NULL;
LPFNMSIREINSTALLPRODUCTW            g_fpMsiReinstallProductW = NULL;
LPFNMSIAPPLYPATCHW                  g_fpMsiApplyPatchW = NULL;
LPFNMSIRECORDGETINTEGER             g_fpMsiRecordGetInteger = NULL;
LPFNMSIENUMFEATURESW                g_fpMsiEnumFeaturesW = NULL;
LPFNMSIGETPRODUCTINFOW              g_fpMsiGetProductInfoW = NULL;
LPFNMSIQUERYFEATURESTATEW           g_fpMsiQueryFeatureStateW = NULL;
LPFNMSIGETFEATUREUSAGEW             g_fpMsiGetFeatureUsageW = NULL;
LPFNMSIGETFEATUREINFOW              g_fpMsiGetFeatureInfoW = NULL;
LPFNMSICONFIGUREFEATUREW            g_fpMsiConfigureFeatureW = NULL;
LPFNMSIREINSTALLFEATUREW            g_fpMsiReinstallFeatureW = NULL;
LPFNMSIENUMPRODUCTSW                g_fpMsiEnumProductsW = NULL;
LPFNMSIGETDATABASESTATE             g_fpMsiGetDatabaseState = NULL;
LPFNMSIRECORDSETSTRINGW             g_fpMsiRecordSetStringW = NULL;
LPFNMSIDATABASECOMMIT               g_fpMsiDatabaseCommit = NULL;
LPFNMSIENUMCOMPONENTSW              g_fpMsiEnumComponentsW = NULL;
LPFNMSIVIEWCLOSE                    g_fpMsiViewClose = NULL;

//***************************************************************************
//
// CMSIProv::CMSIProv
// CMSIProv::~CMSIProv
//
//***************************************************************************

CMSIProv::CMSIProv(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef = 0;

    InterlockedIncrement(&g_cObj);
    
    return;
}

CMSIProv::~CMSIProv(void)
{
    if(m_pNamespace) m_pNamespace->Release();

    InterlockedDecrement(&g_cObj) ;

    return;
}

//***************************************************************************
//
// CMSIProv::QueryInterface
// CMSIProv::AddRef
// CMSIProv::Release
//
// Purpose: IUnknown members for CMSIProv object.
//***************************************************************************


STDMETHODIMP CMSIProv::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid == IID_IWbemServices)
       *ppv = (IWbemServices*)this;

    if(IID_IUnknown == riid || riid == IID_IWbemProviderInit)
       *ppv = (IWbemProviderInit*)this;
    

    if(NULL!=*ppv){

        AddRef();
        return NOERROR;
    }

    else return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CMSIProv::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMSIProv::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

    if(0L == nNewCount){

        delete this;
    }

    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CMSIProv::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CMSIProv::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    try{

        if(pNamespace){
            m_pNamespace = pNamespace;
            m_pNamespace->AddRef();
        } 
        else 
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CheckForMsiDll();

#ifdef _PRIVATE_DEBUG

        //get the working directory for the log file
        HKEY hkeyLocalMachine;
        LONG lResult;

        if((lResult = RegConnectRegistryW(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine)) == ERROR_SUCCESS)
		{
            HKEY hkeyHmomCwd;

            if(	(lResult = RegOpenKeyExW	(	hkeyLocalMachine,
												L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
												0, 
												KEY_READ | KEY_QUERY_VALUE, 
												&hkeyHmomCwd
											)
				) == ERROR_SUCCESS)
			{

                unsigned long lcbValue = 0L;
                unsigned long lType = 0L;

                lResult = RegQueryValueExW	(	hkeyHmomCwd,
												L"Logging Directory",
												NULL,
												&lType,
												NULL,
												&lcbValue
											);

				if ( lResult == ERROR_MORE_DATA )
				{
					try
					{
						if ( ( g_wcpLoggingDir = new WCHAR [ lcbValue/sizeof ( WCHAR ) + wcslen ( L"\\msiprov.log" ) + 1 ] ) != NULL )
						{
							lResult = RegQueryValueExW	(	hkeyHmomCwd,
															L"Logging Directory",
															NULL,
															&lType,
															g_wcpLoggingDir,
															&lcbValue
														);

							if ( lResult == ERROR_SUCCESS )
							{
								wcscat(g_wcpLoggingDir, L"\\msiprov.log");
							}
							else
							{
								if ( g_wcpLoggingDir );
								{
									delete [] g_wcpLoggingDir;
									g_wcpLoggingDir = NULL;
								}
							}
						}
						else
						{
							throw m_he;
						}
					}
					catch ( ... )
					{
						if ( g_wcpLoggingDir );
						{
							delete [] g_wcpLoggingDir;
							g_wcpLoggingDir = NULL;
						}

						RegCloseKey(hkeyHmomCwd);
						RegCloseKey(hkeyLocalMachine);

						throw;
					}

					RegCloseKey(hkeyHmomCwd);
					RegCloseKey(hkeyLocalMachine);
				}
            }
			else
			{
                RegCloseKey(hkeyLocalMachine);
            }
        }

#endif

        //Register usage information with MSI
/*      WCHAR wcProduct[39];
        WCHAR wcFeature[BUFF_SIZE];
        WCHAR wcParent[BUFF_SIZE];
        int iPass = -1;

        MsiGetProductCodeW(L"{E705C42D-35ED-11D2-BFB7-00A0C9954921}", wcProduct);

        while(MsiEnumFeaturesW(wcProduct, ++iPass, wcFeature, wcParent) != ERROR_NO_MORE_ITEMS){

            if(wcscmp(wcFeature, L"Provider") == 0){

                MsiUseFeatureW(wcProduct, wcFeature);
                break;
            }
        }
*/

    }catch(...){

        //Let CIMOM know there was problem
        pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
        return WBEM_E_FAILED;
    }

    //Let CIMOM know you are initialized
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CMSIProv::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************
SCODE CMSIProv::CreateInstanceEnumAsync(const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(RefStr == NULL || pHandler == NULL)
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
				{
					throw m_he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Get the requested object(s)
						hr = pRObj->CreateObjectEnum(RefStr, pHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        }

        // Set status
        pHandler->SetStatus(0, hr, NULL, NULL);

    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
		pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{

            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}


//***************************************************************************
//
// CMSIProv::GetObjectAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************
SCODE CMSIProv::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(ObjectPath == NULL || pHandler == NULL )
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
				{
					throw m_he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Get the requested object
						hr = pRObj->CreateObject(ObjectPath, pHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        }

        // Set Status
        pHandler->SetStatus(0, hr , NULL, NULL);

    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pHandler->SetStatus(0, hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
        pHandler->SetStatus(0, hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}

//***************************************************************************
//
// CMSIProv::PutInstanceAsync
//
// Purpose: Writes an instance to the WBEM Repsoitory.
//
//***************************************************************************
SCODE CMSIProv::PutInstanceAsync(IWbemClassObject FAR *pInst, long lFlags, IWbemContext  *pCtx,
                                 IWbemObjectSink FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            // Do a check of arguments and make sure we have pointer to Namespace
            if(pInst == NULL || pResponseHandler == NULL )
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
                {
					throw m_he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Put the object
						hr = pRObj->PutObject(pInst, pResponseHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        
        }
		else
		{
			hr = WBEM_E_NOT_AVAILABLE;
        }

        // Set Status
        pResponseHandler->SetStatus(0 ,hr , NULL, NULL);
    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}

//***************************************************************************
//
// CMSIProv::ExecMethodAsync
//
// Purpose: Executes a method on an MSI class or instance.
//
//***************************************************************************
SCODE CMSIProv::ExecMethodAsync(const BSTR ObjectPath, const BSTR Method, long lFlags,
                                IWbemContext *pCtx, IWbemClassObject *pInParams,
                                IWbemObjectSink *pResponse)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{

        if(CheckForMsiDll()){

            // Do a check of arguments and make sure we have pointer to Namespace
            if(ObjectPath == NULL || Method == NULL || pResponse == NULL )
			{
                return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel())){

                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
                
                //Create the RequestObject
                pRObj = new CRequestObject();
                if(!pRObj) throw m_he;

                pRObj->Initialize(m_pNamespace);

                //Don't get package list
                if(SUCCEEDED(hr = pRObj->InitializeList(false))){

                    //Execute the method
                    hr = pRObj->ExecMethod(ObjectPath, Method, pInParams, pResponse, pCtx);
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        
        }else{
        
            hr = WBEM_E_NOT_AVAILABLE;
        }

        // Set Status
        pResponse->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){

        hr = WBEM_E_OUT_OF_MEMORY;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){

        hr = WBEM_E_CRITICAL_ERROR;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}

SCODE CMSIProv::DeleteInstanceAsync(const BSTR ObjectPath, long lFlags, IWbemContext *pCtx,
                                    IWbemObjectSink *pResponse)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{
        if(CheckForMsiDll()){

            // Do a check of arguments and make sure we have pointer to Namespace
            if(ObjectPath == NULL || pResponse == NULL )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel())){

                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                pRObj = new CRequestObject();
                if(!pRObj) throw m_he;

                pRObj->Initialize(m_pNamespace);

                //Don't get package list
                if(SUCCEEDED(hr = pRObj->InitializeList(false))){

                    //Delete the requested object
                    hr = pRObj->DeleteObject(ObjectPath, pResponse, pCtx);
                }

                pRObj->Cleanup();
                delete pRObj;
            }

        }else{
        
            hr = WBEM_E_NOT_AVAILABLE;
        }

        // Set Status
        pResponse->SetStatus(0 ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){
        hr = WBEM_E_OUT_OF_MEMORY;

        pResponse->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pResponse->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){
        hr = WBEM_E_CRITICAL_ERROR;

        pResponse->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}


HRESULT CMSIProv::ExecQueryAsync(const BSTR QueryLanguage, const BSTR Query, long lFlags,
                                 IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef _EXEC_QUERY_SUPPORT
    CRequestObject *pRObj = NULL;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    try
	{
        if(CheckForMsiDll())
		{
            // Do a check of arguments and make sure we have pointer to Namespace
            if(0 != _wcsicmp(QueryLanguage, L"WQL") || Query == NULL || pResponseHandler == NULL )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

            if(SUCCEEDED(hr = CheckImpersonationLevel()))
			{
                g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                //Create the RequestObject
                if ( ( pRObj = new CRequestObject() ) == NULL )
				{
					throw he;
				}

                pRObj->Initialize(m_pNamespace);

                //Get package list
				hr = pRObj->InitializeList(true);
				if SUCCEEDED ( hr )
				{
					if ( hr != WBEM_S_NO_MORE_DATA )
					{
						//Get the requested object(s)
						hr = pRObj->ExecQuery(Query, pResponseHandler, pCtx);
					}
					else
					{
						//return empty and success
						hr = WBEM_S_NO_ERROR;
					}
                }

                pRObj->Cleanup();
                delete pRObj;
            }
        }

        // Set Status
        pResponseHandler->SetStatus(0 ,hr , NULL, NULL);

    }
	catch(CHeap_Exception e_HE)
	{
        hr = WBEM_E_OUT_OF_MEMORY;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(HRESULT e_hr)
	{
        hr = e_hr;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }
	catch(...)
	{
        hr = WBEM_E_CRITICAL_ERROR;
        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj)
		{
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#else //_EXEC_QUERY_SUPPORT
    hr = WBEM_E_NOT_SUPPORTED;
#endif

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif //_PRIVATE_DEBUG

    return hr;
}


//Ensure msi.dll and functions are loaded if present on system
bool CMSIProv::CheckForMsiDll()
{
    EnterCriticalSection(&g_msi_prov_cs);

    if(!g_bMsiLoaded){

        HINSTANCE hiMsiDll = LoadLibraryW(L"msi.dll");

        if(!hiMsiDll){

            hiMsiDll = LoadLibrary(_T("msi.dll"));

            if(!hiMsiDll){

                TCHAR cBuf[MAX_PATH + 1];

                if (0 != GetSystemDirectory(cBuf, MAX_PATH/*Number of TCHARs*/)){
				
					_tcscat(cBuf, _T("\\msi.dll"));
					hiMsiDll = LoadLibrary(cBuf);
				}
            }
        }

        if(hiMsiDll){

            //Load the function pointers
            g_fpMsiViewFetch = (LPFNMSIVIEWFETCH)GetProcAddress(hiMsiDll, "MsiViewFetch");
            g_fpMsiRecordGetStringW = (LPFNMSIRECORDGETSTRINGW)GetProcAddress(hiMsiDll, "MsiRecordGetStringW");
            g_fpMsiCloseHandle = (LPFNMSICLOSEHANDLE)GetProcAddress(hiMsiDll, "MsiCloseHandle");
            g_fpMsiDatabaseOpenViewW = (LPFNMSIDATABASEOPENVIEWW)GetProcAddress(hiMsiDll, "MsiDatabaseOpenViewW");
            g_fpMsiViewExecute = (LPFNMSIVIEWEXECUTE)GetProcAddress(hiMsiDll, "MsiViewExecute");
            g_fpMsiGetActiveDatabase = (LPFNMSIGETACTIVEDATABASE)GetProcAddress(hiMsiDll, "MsiGetActiveDatabase");
            g_fpMsiGetComponentPathW = (LPFNMSIGETCOMPONENTPATHW)GetProcAddress(hiMsiDll, "MsiGetComponentPathW");
            g_fpMsiGetComponentStateW = (LPFNMSIGETCOMPONENTSTATEW)GetProcAddress(hiMsiDll, "MsiGetComponentStateW");
            g_fpMsiOpenProductW = (LPFNMSIOPENPRODUCTW)GetProcAddress(hiMsiDll, "MsiOpenProductW");
            g_fpMsiOpenPackageW = (LPFNMSIOPENPACKAGEW)GetProcAddress(hiMsiDll, "MsiOpenPackageW");
            g_fpMsiDatabaseIsTablePersistentW = (LPFNMSIDATABASEISTABLEPERSITENTW)GetProcAddress(hiMsiDll, "MsiDatabaseIsTablePersistentW");
            g_fpMsiSetInternalUI = (LPFNMSISETINTERNALUI)GetProcAddress(hiMsiDll, "MsiSetInternalUI");
            g_fpMsiSetExternalUIW = (LPFNMSISETEXTERNALUIW)GetProcAddress(hiMsiDll, "MsiSetExternalUIW");
            g_fpMsiEnableLogW = (LPFNMSIENABLELOGW)GetProcAddress(hiMsiDll, "MsiEnableLogW");
            g_fpMsiGetProductPropertyW = (LPFNMSIGETPRODUCTPROPERTYW)GetProcAddress(hiMsiDll, "MsiGetProductPropertyW");
            g_fpMsiQueryProductStateW = (LPFNMSIQUERYPRODUCTSTATEW)GetProcAddress(hiMsiDll, "MsiQueryProductStateW");
            g_fpMsiInstallProductW = (LPFNMSIINSTALLPRODUCTW)GetProcAddress(hiMsiDll, "MsiInstallProductW");
            g_fpMsiConfigureProductW = (LPFNMSICONFIGUREPRODUCTW)GetProcAddress(hiMsiDll, "MsiConfigureProductW");
            g_fpMsiReinstallProductW = (LPFNMSIREINSTALLPRODUCTW)GetProcAddress(hiMsiDll, "MsiReinstallProductW");
            g_fpMsiApplyPatchW = (LPFNMSIAPPLYPATCHW)GetProcAddress(hiMsiDll, "MsiApplyPatchW");
            g_fpMsiRecordGetInteger = (LPFNMSIRECORDGETINTEGER)GetProcAddress(hiMsiDll, "MsiRecordGetInteger");
            g_fpMsiEnumFeaturesW = (LPFNMSIENUMFEATURESW)GetProcAddress(hiMsiDll, "MsiEnumFeaturesW");
            g_fpMsiGetProductInfoW = (LPFNMSIGETPRODUCTINFOW)GetProcAddress(hiMsiDll, "MsiGetProductInfoW");
            g_fpMsiQueryFeatureStateW = (LPFNMSIQUERYFEATURESTATEW)GetProcAddress(hiMsiDll, "MsiQueryFeatureStateW");
            g_fpMsiGetFeatureUsageW = (LPFNMSIGETFEATUREUSAGEW)GetProcAddress(hiMsiDll, "MsiGetFeatureUsageW");
            g_fpMsiGetFeatureInfoW = (LPFNMSIGETFEATUREINFOW)GetProcAddress(hiMsiDll, "MsiGetFeatureInfoW");
            g_fpMsiConfigureFeatureW = (LPFNMSICONFIGUREFEATUREW)GetProcAddress(hiMsiDll, "MsiConfigureFeatureW");
            g_fpMsiReinstallFeatureW = (LPFNMSIREINSTALLFEATUREW)GetProcAddress(hiMsiDll, "MsiReinstallFeatureW");
            g_fpMsiEnumProductsW = (LPFNMSIENUMPRODUCTSW)GetProcAddress(hiMsiDll, "MsiEnumProductsW");
            g_fpMsiGetDatabaseState = (LPFNMSIGETDATABASESTATE)GetProcAddress(hiMsiDll, "MsiGetDatabaseState");
            g_fpMsiRecordSetStringW = (LPFNMSIRECORDSETSTRINGW)GetProcAddress(hiMsiDll, "MsiRecordSetStringW");
            g_fpMsiDatabaseCommit = (LPFNMSIDATABASECOMMIT)GetProcAddress(hiMsiDll, "MsiDatabaseCommit");
            g_fpMsiEnumComponentsW = (LPFNMSIENUMCOMPONENTSW)GetProcAddress(hiMsiDll, "MsiEnumComponentsW");
            g_fpMsiViewClose = (LPFNMSIVIEWCLOSE)GetProcAddress(hiMsiDll, "MsiViewClose");

            // Did we get all the pointers we need?
            if(g_fpMsiViewFetch && g_fpMsiRecordGetStringW && g_fpMsiCloseHandle &&
                g_fpMsiDatabaseOpenViewW && g_fpMsiViewExecute && g_fpMsiGetActiveDatabase &&
                g_fpMsiGetComponentPathW && g_fpMsiGetComponentStateW && g_fpMsiOpenProductW &&
                g_fpMsiOpenPackageW && g_fpMsiDatabaseIsTablePersistentW && g_fpMsiSetInternalUI &&
                g_fpMsiSetExternalUIW && g_fpMsiEnableLogW && g_fpMsiGetProductPropertyW &&
                g_fpMsiQueryProductStateW && g_fpMsiInstallProductW && g_fpMsiConfigureProductW &&
                g_fpMsiReinstallProductW && g_fpMsiApplyPatchW && g_fpMsiRecordGetInteger &&
                g_fpMsiEnumFeaturesW && g_fpMsiGetProductInfoW && g_fpMsiQueryFeatureStateW &&
                g_fpMsiGetFeatureUsageW && g_fpMsiGetFeatureInfoW && g_fpMsiConfigureFeatureW &&
                g_fpMsiReinstallFeatureW && g_fpMsiEnumProductsW && g_fpMsiGetDatabaseState &&
                g_fpMsiRecordSetStringW && g_fpMsiDatabaseCommit && g_fpMsiEnumComponentsW &&
                g_fpMsiViewClose){

                g_bMsiLoaded = true;
            
            }
        
        }else{

            g_bMsiPresent = false;
        }
    }

    LeaveCriticalSection(&g_msi_prov_cs);

    return g_bMsiLoaded;
}

bool UnloadMsiDll()
{
    bool bRetVal = true;

    EnterCriticalSection(&g_msi_prov_cs);

    if(g_bMsiLoaded){

        if(FreeLibrary(GetModuleHandle(L"msi.dll"))){

            g_bMsiLoaded = false;
            bRetVal = true;

        }else bRetVal = false;

    }

    LeaveCriticalSection(&g_msi_prov_cs);

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasource.cpp ===
// ODBCDataSource.cpp: implementation of the CODBCDataSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDataSource.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDataSource::CODBCDataSource(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDataSource::~CODBCDataSource()
{

}

HRESULT CODBCDataSource::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcDataSource[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcDataSource);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `DataSource`, `Component_`, `Description`, `DriverDescription`, `Registration` from ODBCDataSource" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDataSource", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pDataSource, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //=====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDriverDescription );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pRegistration );

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcattribute.cpp ===
// ODBCAttribute.cpp: implementation of the CODBCAttribute class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCAttribute.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCAttribute::CODBCAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                            IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCAttribute::~CODBCAttribute()
{

}

HRESULT CODBCAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bDriver, bAttribute;
    wcscpy(wcQuery, L"select distinct `Driver_`, `Attribute`, `Value` from ODBCAttribute");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{

		//Open our database
        try
		{
            if ( GetView ( &hView, m_pRequest->Package(i), wcQuery, L"ODBCAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );
                    PutKeyProperty(m_pObj, pDriver, Buffer, &bDriver, m_pRequest);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    PutKeyProperty(m_pObj, pAttribute, Buffer, &bAttribute, m_pRequest);
                    PutProperty(m_pObj, pCaption, Buffer);
                    PutProperty(m_pObj, pDescription, Buffer);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                //=====================================================

                    dwBufSize = BUFF_SIZE;
					PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pValue);

                //----------------------------------------------------

                    if(bDriver && bAttribute) bMatch = true;

                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                        hr = pHandler->Indicate(1, &m_pObj);
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		if (hRecord)
		g_fpMsiCloseHandle(hRecord);

		if (hView)
		{
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);
		}

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriver.h ===
// ODBCDriver.h: interface for the CODBCDriver class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDRIVER_H__75F6BA15_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDRIVER_H__75F6BA15_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDriver : public CGenericClass  
{
public:
	CODBCDriver(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDriver();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDRIVER_H__75F6BA15_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasourceattribute.h ===
// ODBCDataSourceAttribute.h: interface for the CODBCDataSourceAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDATASOURCEATTRIBUTE_H__75F6BA17_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDATASOURCEATTRIBUTE_H__75F6BA17_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDataSourceAttribute : public CGenericClass  
{
public:
	CODBCDataSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDataSourceAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDATASOURCEATTRIBUTE_H__75F6BA17_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdatasourceattribute.cpp ===
// ODBCDataSourceAttribute.cpp: implementation of the CODBCDataSourceAttribute class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDataSourceAttribute.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDataSourceAttribute::CODBCDataSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDataSourceAttribute::~CODBCDataSourceAttribute()
{

}

HRESULT CODBCDataSourceAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt wcProp;

    //These will change from class to class
    bool bDriver, bAttribute;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `DataSource_`, `Attribute` from ODBCSourceAttribute");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCSourceAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    if ( Buffer && Buffer [ 0 ] != 0 )
					{
						// safe operation
                        wcProp.Copy ( L"Win32_ODBCDataSourcespecification.CheckID=\"" );
						wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
						PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

						// safe operation
                        wcProp.Copy ( L"Win32_ODBCSourceAttribute.Attribute=\"" );
						wcProp.Append ( 2, Buffer, L"\",DataSource=\"" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if( Buffer && Buffer [ 0 ] != 0 )
						{
							wcProp.Append ( 2, Buffer, L"\"" );
							PutKeyProperty(m_pObj, pSetting, wcProp, &bAttribute, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		if (hRecord)
		g_fpMsiCloseHandle(hRecord);

		if (hView)
		{
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);
		}

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriver.cpp ===
// ODBCDriver.cpp: implementation of the CODBCDriver class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDriver.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDriver::CODBCDriver(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDriver::~CODBCDriver()
{

}

HRESULT CODBCDriver::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcDriver[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcDriver);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Driver`, `Component_`, `Description`, `File_`, `File_Setup` from ODBCDriver" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Driver`=\'", wcDriver, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDriver", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pDriver, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //=====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pFile );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSetupFile );

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriverattribute.cpp ===
// ODBCDriverAttribute.cpp: implementation of the CODBCDriverAttribute class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDriverAttribute.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDriverAttribute::CODBCDriverAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDriverAttribute::~CODBCDriverAttribute()
{

}

HRESULT CODBCDriverAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt wcProp;

    //These will change from class to class
    bool bDriver, bAttribute;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Driver_`, `Attribute` from ODBCAttribute");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    if ( Buffer && Buffer [ 0 ] != 0 )
					{
						// safe operation
                        wcProp.Copy ( L"Win32_ODBCDriverSpecification.CheckID=\"" );
						wcProp.Append ( 3, Buffer, wcProductCode, L"\"");
						PutKeyProperty(m_pObj, pCheck, wcProp, &bDriver, m_pRequest);

						// safe operation
                        wcProp.Copy ( L"Win32_ODBCAttribute.Attribute=\"" );
						wcProp.Append ( 2, Buffer, L"\",Driver=\"" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							wcProp.Append ( 2, Buffer, L"\"" );
							PutKeyProperty(m_pObj, pSetting, wcProp, &bAttribute, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                        //=====================================================

                        //----------------------------------------------------

                            if(bDriver && bAttribute) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		if (hRecord)
		g_fpMsiCloseHandle(hRecord);

		if (hView)
		{
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);
		}

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriversoftwareelement.h ===
// ODBCDriverSoftwareElement.h: interface for the CODBCDriverSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDRIVERSOFTWAREELEMENT_H__75F6BA19_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDRIVERSOFTWAREELEMENT_H__75F6BA19_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDriverSoftwareElement : public CGenericClass  
{
public:
	CODBCDriverSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDriverSoftwareElement();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDRIVERSOFTWAREELEMENT_H__75F6BA19_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriverattribute.h ===
// ODBCDriverAttribute.h: interface for the CODBCDriverAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCDRIVERATTRIBUTE_H__75F6BA16_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCDRIVERATTRIBUTE_H__75F6BA16_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCDriverAttribute : public CGenericClass  
{
public:
	CODBCDriverAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCDriverAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCDRIVERATTRIBUTE_H__75F6BA16_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcdriversoftwareelement.cpp ===
// ODBCDriverSoftwareElement.cpp: implementation of the CODBCDriverSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCDriverSoftwareElement.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCDriverSoftwareElement::CODBCDriverSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCDriverSoftwareElement::~CODBCDriverSoftwareElement()
{

}

HRESULT CODBCDriverSoftwareElement::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt str;

    //These will change from class to class
    bool bFeature, bElement;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Component_`, `Driver` from ODBCDriver");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));
        
		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDriver", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

					dwBufSize = BUFF_SIZE;
					uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																Buffer,
																wcProductCode,
																wcProp,
																&dwBufSize
														   );

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

					if ( uiStatus == ERROR_SUCCESS )
					{
                        PutKeyProperty(m_pObj, pElement, wcProp, &bElement, m_pRequest);

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							// safe operation
                            str.Copy ( L"Win32_ODBCDriverSpecification.CheckID=\"" );
							str.Append ( 3, Buffer, wcProductCode, L"\"" );
							PutKeyProperty(m_pObj, pCheck, str, &bFeature, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            if(bFeature && bElement) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;
                
                    g_fpMsiCloseHandle(hRecord);

					uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbctranslator.h ===
// ODBCTranslator.h: interface for the CODBCTranslator class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCTRANSLATOR_H__75F6BA14_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCTRANSLATOR_H__75F6BA14_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCTranslator : public CGenericClass  
{
public:
	CODBCTranslator(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCTranslator();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCTRANSLATOR_H__75F6BA14_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcsourceattribute.h ===
// ODBCSourceAttribute.h: interface for the CODBCSourceAttribute class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ODBCSOURCEATTRIBUTE_H__75F6BA18_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_ODBCSOURCEATTRIBUTE_H__75F6BA18_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CODBCSourceAttribute : public CGenericClass  
{
public:
	CODBCSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CODBCSourceAttribute();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_ODBCSOURCEATTRIBUTE_H__75F6BA18_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbcsourceattribute.cpp ===
// ODBCSourceAttribute.cpp: implementation of the CODBCSourceAttribute class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCSourceAttribute.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCSourceAttribute::CODBCSourceAttribute(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCSourceAttribute::~CODBCSourceAttribute()
{

}

HRESULT CODBCSourceAttribute::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bDriver, bAttribute;
    wcscpy(wcQuery, L"select distinct `DataSource_`, `Attribute`, `Value` from ODBCSourceAttribute");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		//Open our database
        try
		{
            if ( GetView ( &hView, m_pRequest->Package(i), wcQuery, L"ODBCSourceAttribute", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );
                    PutKeyProperty(m_pObj, pDataSource, Buffer, &bDriver, m_pRequest);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    PutKeyProperty(m_pObj, pAttribute, Buffer, &bAttribute, m_pRequest);
                    PutProperty(m_pObj, pCaption, Buffer);
                    PutProperty(m_pObj, pDescription, Buffer);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                //=====================================================

                    dwBufSize = BUFF_SIZE;
					PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pValue );

                //----------------------------------------------------

                    if(bDriver && bAttribute) bMatch = true;

                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                        hr = pHandler->Indicate(1, &m_pObj);
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		if (hRecord)
		g_fpMsiCloseHandle(hRecord);

		if (hView)
		{
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);
		}

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patch.h ===
// Patch.h: interface for the CPatch class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCH_H__DB614F2A_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_PATCH_H__DB614F2A_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatch : public CGenericClass  
{
public:
	CPatch(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatch();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCH_H__DB614F2A_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patch.cpp ===
// Patch.cpp: implementation of the CPatch class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Patch.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatch::CPatch(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatch::~CPatch()
{

}

HRESULT CPatch::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bFile, bSequence, bProduct;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"File" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Sequence`, `PatchSize`, `Attributes` from Patch" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcName, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Patch", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutKeyProperty(m_pObj, pFile, Buffer, &bFile, m_pRequest);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        PutKeyProperty(m_pObj, pSequence, g_fpMsiRecordGetInteger(hRecord, 2),
                            &bSequence, m_pRequest);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProduct, m_pRequest);
                    //====================================================

                        PutProperty(m_pObj, pPatchSize, g_fpMsiRecordGetInteger(hRecord, 3));

                        PutProperty(m_pObj, pAttributes, g_fpMsiRecordGetInteger(hRecord, 4));
                    //----------------------------------------------------

                        if(bFile && bSequence && bProduct) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\odbctranslator.cpp ===
// ODBCTranslator.cpp: implementation of the CODBCTranslator class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ODBCTranslator.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CODBCTranslator::CODBCTranslator(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CODBCTranslator::~CODBCTranslator()
{

}

HRESULT CODBCTranslator::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTranslator[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcTranslator);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Translator`, `Component_`, `Description`, `File_`, `File_Setup` from ODBCTranslator" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Translator`=\'", wcTranslator, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCTranslator", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pTranslator, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //=====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pFile);

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSetupFile );

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patchfile.h ===
// PatchFile.h: interface for the CPatchFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCHFILE_H__02FF6C8A_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PATCHFILE_H__02FF6C8A_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatchFile : public CGenericClass  
{
public:
	CPatchFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatchFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCHFILE_H__02FF6C8A_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patchfile.cpp ===
// PatchFile.cpp: implementation of the CPatchFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PatchFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatchFile::CPatchFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatchFile::~CPatchFile()
{

}

HRESULT CPatchFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hFView	= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hFRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery1[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;

	CStringExt wcPatch;
	CStringExt wcFile;

    bool bResource, bProduct;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery1, L"select distinct `File_`, `Sequence` from Patch");

	QueryExt wcQuery ( L"select distinct `File`, `Component_` from File where File=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery1, L"Patch", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

					// safe operation
                    wcPatch.Copy ( L"Win32_Patch.File=\"" );

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    if ( Buffer && Buffer [ 0 ] != 0 )
					{
						wcPatch.Append ( 2, Buffer, L"\",Sequence=\"" );

						// make query on fly
						wcQuery.Append ( 2, Buffer, L"\'" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							wcPatch.Append ( 2, Buffer, L"\"" );
							PutKeyProperty(m_pObj, pSetting, wcPatch, &bResource, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            CheckMSI(g_fpMsiDatabaseOpenViewW(msidata.GetDatabase (), wcQuery, &hFView));
                            CheckMSI(g_fpMsiViewExecute(hFView, 0));

                            uiStatus = g_fpMsiViewFetch(hFView, &hFRecord);

                            if(uiStatus != ERROR_NO_MORE_ITEMS){

                                CheckMSI(uiStatus);

								// safe operation
                                wcFile.Copy ( L"Win32_FileSpecification.CheckID=\"" );

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hFRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								wcFile.Append ( 3, wcProductCode, Buffer, L"\"");
		                        PutKeyProperty(m_pObj, pCheck, wcFile, &bProduct, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}

                            g_fpMsiViewClose(hFView);
                            g_fpMsiCloseHandle(hFView);
                            g_fpMsiCloseHandle(hFRecord);

                        //----------------------------------------------------

                            if(bResource && bProduct) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;
                    
                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include "msiprov.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackagesource.h ===
// PatchPackageSource.h: interface for the CPatchPackageSource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCHPACKAGESOURCE_H__02FF6C8B_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PATCHPACKAGESOURCE_H__02FF6C8B_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatchPackageSource : public CGenericClass  
{
public:
	CPatchPackageSource(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatchPackageSource();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCHPACKAGESOURCE_H__02FF6C8B_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackage.cpp ===
// PatchPackAge.cpp: implementation of the CPatchPackAge class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PatchPackAge.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatchPackAge::CPatchPackAge(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatchPackAge::~CPatchPackAge()
{

}

HRESULT CPatchPackAge::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[39];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bPatchID, bProductCode;

        //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"PatchID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `PatchId` from PatchPackage" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `PatchId`=\'", wcName, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PatchPackage", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = 39;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pPatchID, wcBuf, &bPatchID, m_pRequest);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProductCode, m_pRequest);

                    //----------------------------------------------------

                        if(bPatchID && bProductCode) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackagesource.cpp ===
// PatchPackageSource.cpp: implementation of the CPatchPackageSource class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PatchPackageSource.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatchPackageSource::CPatchPackageSource(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPatchPackageSource::~CPatchPackageSource()
{

}

HRESULT CPatchPackageSource::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
	MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[39];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

	CStringExt wcPatch;
	CStringExt wcMedia;

    //These will change from class to class
    bool bPatch, bMedia;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `PatchId`, `Media_` from PatchPackage");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"PatchPackage", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                    dwBufSize = 39;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    if(wcscmp(wcBuf, L"") != 0)
					{
						// safe operation
                        wcPatch.Copy ( L"Win32_PatchPackage.PatchID=\"" );
						wcPatch.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );

						PutKeyProperty(m_pObj, pPatch, wcPatch, &bPatch, m_pRequest);

                        dwBufSize = 39;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        if(wcscmp(wcBuf, L"") != 0)
						{
							// safe operation
                            wcMedia.Copy ( L"Win32_MSILogicalDisk.DiskID=\"" );
							wcMedia.Append ( 2, wcBuf, L"\"" );

							PutKeyProperty(m_pObj, pSource, wcMedia, &bMedia, m_pRequest);

                        //----------------------------------------------------

                            if(bPatch && bMedia) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		if (hRecord)
		g_fpMsiCloseHandle(hRecord);

		if (hView)
		{
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);
		}

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\patchpackage.h ===
// PatchPackAge.h: interface for the CPatchPackAge class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PATCHPACKAGE_H__DB614F2E_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_PATCHPACKAGE_H__DB614F2E_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPatchPackAge : public CGenericClass  
{
public:
	CPatchPackAge(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPatchPackAge();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PATCHPACKAGE_H__DB614F2E_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\product.h ===
// Product.h: interface for the CProduct class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCT_H__AA9CA854_D9EE_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_PRODUCT_H__AA9CA854_D9EE_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"
#include "requestobject.h"

class CProduct : public CGenericClass  
{
public:
    CProduct(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
    virtual ~CProduct();

    virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
        {return WBEM_E_NOT_SUPPORTED;}

    //WBEM Methods
    HRESULT Admin(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                  IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Advertise(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Install(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                    IWbemObjectSink *pHandler, IWbemContext *pCtx);

    HRESULT Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Uninstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                      IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT Upgrade(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                    IWbemObjectSink *pHandler, IWbemContext *pCtx);

    virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PRODUCT_H__AA9CA854_D9EE_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\product.cpp ===
// Product.cpp: implementation of the CProduct class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Product.h"
#include <wininet.h>
#include <ocidl.h>
#include "CRegCls.h"

#include <WbemTime.h>

#include <helper.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProduct::CProduct(CRequestObject *pObj, IWbemServices *pNamespace,
                IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProduct::~CProduct()
{

}

HRESULT CProduct::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufsize;
    bool bMatch = false;
    bool bTestCode = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int iPos = -1;
        BSTR bstrIdentifyingNumber = SysAllocString(L"IdentifyingNumber");

		if ( bstrIdentifyingNumber )
		{
			if(FindIn(m_pRequest->m_Property, bstrIdentifyingNumber, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bTestCode = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrIdentifyingNumber );
					throw hr;
				}

			}

			SysFreeString(bstrIdentifyingNumber);
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    bool bName, bVersion = false, bIDNum, bProductHandle;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0)))
		{
			//Open our database

            try
			{
				if ( GetView ( NULL, wcProductCode, NULL, NULL, FALSE, TRUE ) )
				{
					bProductHandle = true;
				}
				else
				{
					bProductHandle = false;
				}

				if(FAILED(hr = SpawnAnInstance(&m_pObj)))
				{
					throw hr;
				}

                dwBufsize = BUFF_SIZE;
                CheckMSI(g_fpMsiGetProductInfoW(wcProductCode, INSTALLPROPERTY_PRODUCTNAME, wcBuf, &dwBufsize));
                PutKeyProperty(m_pObj, pName, wcBuf, &bName, m_pRequest);

                PutProperty(m_pObj, pCaption, wcBuf);
                PutProperty(m_pObj, pDescription, wcBuf);

                if(bProductHandle)
				{
					dwBufsize = BUFF_SIZE;
					CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"Manufacturer", wcBuf, &dwBufsize));
					PutProperty(m_pObj, pVendor, wcBuf);

					dwBufsize = BUFF_SIZE;
					CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufsize));
					PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                }

                PutKeyProperty(m_pObj, pIdentifyingNumber, wcProductCode, &bIDNum, m_pRequest);

                INSTALLSTATE isState = g_fpMsiQueryProductStateW(wcProductCode);

                switch(isState)
				{
	                case INSTALLSTATE_ABSENT:
                    break;

		            case INSTALLSTATE_ADVERTISED:
						dwBufsize = BUFF_SIZE;
						if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_VERSIONSTRING, wcBuf, &dwBufsize))
						{
							PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
							dwBufsize = BUFF_SIZE;
						}
                    break;

	                case INSTALLSTATE_BADCONFIG:
                    break;

			        case INSTALLSTATE_DEFAULT:
				        dwBufsize = BUFF_SIZE;
					    if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_VERSIONSTRING, wcBuf, &dwBufsize))
						{
	                        PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
		                }

			            dwBufsize = BUFF_SIZE;
				        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_LOCALPACKAGE, wcBuf, &dwBufsize))
						{
	                        PutProperty(m_pObj, pPackageCache, wcBuf);
		                }

			            dwBufsize = BUFF_SIZE;
				        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_INSTALLDATE, wcBuf, &dwBufsize))
						{
	                        PutProperty(m_pObj, pInstallDate, wcBuf);

							if ( ( lstrlenW ( wcBuf ) + lstrlenW ( L"000000.000000+000" ) + 1 ) < BUFF_SIZE )
							{
								lstrcatW ( wcBuf, L"000000.000000+000" );

								BSTR	bstrWbemTime;
								if ( ( bstrWbemTime	= ::SysAllocString ( wcBuf ) ) != NULL )
								{
									WBEMTime	time ( bstrWbemTime );
									::SysFreeString ( bstrWbemTime );

									if ( time.IsOk () )
									{
										bstrWbemTime= time.GetDMTF ( );

										try
										{
											PutProperty( m_pObj, pInstallDate2, bstrWbemTime );
										}
										catch ( ... )
										{
											::SysFreeString ( bstrWbemTime );
											throw;
										}

										::SysFreeString ( bstrWbemTime );
									}
									else
									{
										hr = E_INVALIDARG;
									}
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								hr = E_FAIL;
							}
		                }

			            dwBufsize = BUFF_SIZE;
				        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_INSTALLLOCATION, wcBuf, &dwBufsize))
						{
							PutProperty(m_pObj, pInstallLocation, wcBuf);
						}
                    break;

	                case INSTALLSTATE_INVALIDARG:
                    break;

			        case INSTALLSTATE_UNKNOWN:
                    break;

					default:
					break;
                }

                PutProperty(m_pObj, pInstallState, (int)isState);

                if(bName && bVersion && bIDNum)
				{
					bMatch = true;
				}

                if((atAction != ACTIONTYPE_GET)  || bMatch)
				{
                    hr = pHandler->Indicate(1, &m_pObj);
                }

                m_pObj->Release();
                m_pObj = NULL;
			}
			catch(...)
			{
				msidata.CloseProduct ();

                if(m_pObj)
				{
                    m_pObj->Release();
                    m_pObj = NULL;
                }

                throw;
            }

			msidata.CloseProduct ();
        }
    }

    return hr;
}

HRESULT CProduct::Admin(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                        IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
    BSTR bstrTarget = NULL;
    BSTR bstrOptions = NULL;
    UINT uiStatus = 1603;
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrInstall = SysAllocString(L"Install");
    if(!bstrInstall)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrInstall, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "PackageLocation", &bstrPackage))){

					OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_bstrPackage ( bstrPackage ) ;

                    if((wcscmp(bstrPackage, L"") != 0) && (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){

                        //Get Options
                        if(SUCCEEDED(GetProperty(pInParams, "TargetLocation", &bstrTarget))){

							OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_bstrTarget ( bstrTarget ) ;

                            //Get Options
                            if(SUCCEEDED(GetProperty(pInParams, "Options", &bstrOptions)))
							{
								OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_bstrOptions ( bstrOptions ) ;

								// safe operation
                                wcscpy(wcOptions, L"ACTION=ADMIN");

                                if((wcscmp(bstrTarget, L"") != 0))
								{
									if ( wcslen ( wcOptions ) + wcslen ( L" TARGETDIR=") + wcslen ( bstrTarget ) + 1 < dwOptions )
									{
										wcscat(wcOptions, L" TARGETDIR=");
										wcscat(wcOptions, bstrTarget);
									}
									else
									{
										LPWSTR wsz = NULL;

										try
										{
											if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" TARGETDIR=") + wcslen ( bstrTarget ) + 1 ] ) != NULL )
											{
												wcscpy(wsz, wcOptions);
												wcscat(wsz, L" TARGETDIR=");
												wcscat(wsz, bstrTarget);

												if ( wcOptions )
												{
													delete [] wcOptions;
													wcOptions = NULL;
												}

												wcOptions = wsz;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wsz )
											{
												delete [] wsz;
												wsz = NULL;
											}

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}
									}
                                }

                                if((wcscmp(bstrOptions, L"") != 0))
								{
									if ( wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( bstrOptions ) + 1 < dwOptions )
									{
										wcscat(wcOptions, L" ");
										wcscat(wcOptions, bstrOptions);
									}
									else
									{
										LPWSTR wsz = NULL;

										try
										{
											if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" ") + wcslen ( bstrOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wsz, wcOptions);
												wcscat(wsz, L" ");
												wcscat(wsz, bstrOptions);

												if ( wcOptions )
												{
													delete [] wcOptions;
													wcOptions = NULL;
												}

												wcOptions = wsz;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wsz )
											{
												delete [] wsz;
												wsz = NULL;
											}

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}
									}
                                }

                                if(hrReturn == WBEM_S_NO_ERROR){

                                    if(!IsNT4()){

										if ( msidata.Lock () )
										{
											INSTALLUI_HANDLER ui = NULL;

											//Set UI Level w/ event callback
											ui = SetupExternalUI ( );

											try
											{
												//Call Installer
												uiStatus = g_fpMsiInstallProductW(bstrPackage, wcOptions);
											}
											catch(...)
											{
												uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
											}

											//Restore UI Level w/ event callback
											RestoreExternalUI ( ui );

											msidata. Unlock();
										}

                                    }else{

                                    /////////////////
                                    // NT4 fix code....

                                        try{

                                            WCHAR wcAction[20];
                                            wcscpy(wcAction, L"/admin");

											LPWSTR wcCommandLine = NULL;

											try
											{
												if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
												{
													wcscpy(wcCommandLine, bstrPackage);
													wcscat(wcCommandLine, L" ");
													wcscat(wcCommandLine, wcOptions);

													hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

													delete [] wcCommandLine;
												}
												else
												{
													throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
												}
											}
											catch ( ... )
											{
												if ( wcCommandLine )
												{
													delete [] wcCommandLine;
													wcCommandLine = NULL;
												}

												hrReturn = E_OUTOFMEMORY;
											}

                                        }catch(...){

                                            hrReturn = WBEM_E_FAILED;
                                        }

                                        ////////////////////

                                    }

                                    if(SUCCEEDED(hrReturn)){

                                        //Set up ReturnValue
                                        VariantInit(&v);
                                        V_VT(&v) = VT_I4;
                                        V_I4(&v) = uiStatus;

                                        BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                        if(!bstrReturnValue)
										{
											delete [] wcOptions;
                                            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

                                        if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                            &v, NULL)))
                                            pHandler->Indicate(1, &pOutParams);

                                        SysFreeString(bstrReturnValue);
                                    }
                                }

                            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                        }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                    }else hrReturn = WBEM_E_INVALID_PARAMETER;

                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
                
                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrInstall);

    return hrReturn;
}

HRESULT CProduct::Advertise(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
    BSTR wcBuf = NULL;
    UINT uiStatus = 1603;
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrAdvertise = SysAllocString(L"Advertise");
    if(!bstrAdvertise)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

    LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

	if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrAdvertise, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "PackageLocation", &bstrPackage))){

					OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_bstrPackage ( bstrPackage ) ;

                    if((wcscmp(bstrPackage, L"") != 0) && (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){

                        //Get Options
                        if ( SUCCEEDED ( GetProperty ( pInParams, "Options", &wcBuf ) ) )
						{
							OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_wcBuf ( wcBuf ) ;

							//Make sure we perform an advertisement
                            wcscpy(wcOptions, L"ACTION=ADVERTISE ALLUSERS=1");

                            if( wcBuf && wcscmp ( wcBuf, L"" ) != 0 )
							{
								if ( wcslen ( wcOptions ) + wcslen ( L" ") + SysStringLen ( wcBuf ) + 1 < dwOptions )
								{
									wcscat(wcOptions, L" ");
									wcscat(wcOptions, wcBuf);
								}
								else
								{
									LPWSTR wsz = NULL;

									try
									{
										if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" ") + SysStringLen ( wcBuf ) + 1 ] ) != NULL )
										{
											wcscpy(wsz, wcOptions);
											wcscat(wsz, L" ");
											wcscat(wsz, wcBuf);

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											wcOptions = wsz;
										}
										else
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}
									}
									catch ( ... )
									{
										if ( wsz )
										{
											delete [] wsz;
											wsz = NULL;
										}

										if ( wcOptions )
										{
											delete [] wcOptions;
											wcOptions = NULL;
										}

										hrReturn = E_OUTOFMEMORY;
									}
								}
                            }

                            if(hrReturn == WBEM_S_NO_ERROR){

                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											uiStatus = g_fpMsiInstallProductW(bstrPackage, wcOptions);
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/advertise");

										LPWSTR wcCommandLine = NULL;

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wcCommandLine, bstrPackage);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcOptions);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                    ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
									{
										delete [] wcOptions;
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }
                            }

                        }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                    }else hrReturn = WBEM_E_INVALID_PARAMETER;

                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }
    
	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrAdvertise);

    return hrReturn;
}

HRESULT CProduct::Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iState, iLevel;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrConfigure = SysAllocString(L"Configure");
    if(!bstrConfigure)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    INSTALLSTATE isState;
    int i = -1;
    bool bFoundCode = false;

    m_pRequest = pReqObj;

    LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

	if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrConfigure, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "InstallState", &iState))){

                    //Get Options
                    if(SUCCEEDED(GetProperty(pInParams, "InstallLevel", &iLevel))){

                        //Get the Product Code
                        while(pReqObj->m_Property[++i]){

                            if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
							{
								if ( wcslen ( pReqObj->m_Value[i] ) < BUFF_SIZE )
								{
									wcscpy(wcCode, pReqObj->m_Value[i]);
									bFoundCode = true;
								}
                            }   
                        }

                        if(bFoundCode){

                            //Get the appropriate State
                            switch(iState){
                            case 1:
                                isState = INSTALLSTATE_DEFAULT;
                                break;
                            case 2:
                                isState = INSTALLSTATE_LOCAL;
                                break;
                            case 3:
                                isState = INSTALLSTATE_SOURCE;
                                break;
                            default:
                                isState = INSTALLSTATE_NOTUSED;
                                break;
                            }

                            //Get the appropriate Level
                            switch(iLevel){
                            case 1:
                                iLevel = INSTALLLEVEL_DEFAULT;
                                break;
                            case 2:
                                iLevel = INSTALLLEVEL_MINIMUM;
                                break;
                            case 3:
                                iLevel = INSTALLLEVEL_MAXIMUM;
                                break;
                            default:
                                iLevel = -123;
                                break;
                            }

                            //If everything is valid, proceed
                            if((isState != INSTALLSTATE_NOTUSED) && (iLevel != -123) &&
                                (hrReturn == WBEM_S_NO_ERROR)){

                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											uiStatus = g_fpMsiConfigureProductW(wcCode, iLevel, isState);
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/configure");

										LPWSTR wcCommandLine = NULL;

                                        WCHAR wcTmp1[100];
                                        WCHAR wcTmp2[100];

										_itow((int)iLevel, wcTmp1, 10);
										_itow((int)isState, wcTmp2, 10);

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) +  wcslen ( wcTmp1 ) + wcslen ( wcTmp2 ) + 3 ] ) != NULL )
											{
												wcscpy(wcCommandLine, wcCode);
												wcscat(wcCommandLine, L" ");
												wcscpy(wcCommandLine, wcTmp1);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcTmp2);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
									{
										delete [] wcOptions;
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }

                            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                        }else hrReturn = WBEM_E_FAILED;

                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                pOutParams->Release();

            }else return WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrConfigure);

    return hrReturn;
}

HRESULT CProduct::Install(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                          IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
    BSTR wcBuf = NULL;
    UINT uiStatus = 1603;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass, 
        0, pCtx, &pClass, NULL))){

        BSTR bstrInstall = SysAllocString(L"Install");
        if(!bstrInstall)
		{
			if ( wcOptions )
			{
				delete [] wcOptions;
				wcOptions = NULL;
			}

			throw he;
		}

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrInstall, 0, NULL, &pOutClass))){

            pClass->Release();
            SysFreeString(bstrInstall);

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                pOutClass->Release();

                //Get PackageLocation
                if(SUCCEEDED(hrReturn = GetProperty(pInParams, "PackageLocation", &bstrPackage))){

					OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_bstrPackage ( bstrPackage ) ;

                    if((wcscmp(bstrPackage, L"") != 0) &&
                        (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){

                        //Get Options
                        if ( SUCCEEDED ( hrReturn = GetProperty ( pInParams, "Options", &wcBuf ) ) )
						{
							OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_wcBuf ( wcBuf ) ;

                            //Make sure we perform an advertisement
                            wcscpy(wcOptions, L"ACTION=INSTALL ALLUSERS=1");

                            if( wcBuf && wcscmp ( wcBuf, L"" ) != 0 )
							{
								if ( wcslen ( wcOptions ) + wcslen ( L" ") + SysStringLen ( wcBuf ) + 1 < dwOptions )
								{
									wcscat(wcOptions, L" ");
									wcscat(wcOptions, wcBuf);
								}
								else
								{
									LPWSTR wsz = NULL;

									try
									{
										if ( ( wsz = new WCHAR [ wcslen ( wcOptions ) + wcslen ( L" ") + SysStringLen ( wcBuf ) + 1 ] ) != NULL )
										{
											wcscpy(wsz, wcOptions);
											wcscat(wsz, L" ");
											wcscat(wsz, wcBuf);

											if ( wcOptions )
											{
												delete [] wcOptions;
												wcOptions = NULL;
											}

											wcOptions = wsz;
										}
										else
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}
									}
									catch ( ... )
									{
										if ( wsz )
										{
											delete [] wsz;
											wsz = NULL;
										}

										if ( wcOptions )
										{
											delete [] wcOptions;
											wcOptions = NULL;
										}

										hrReturn = E_OUTOFMEMORY;
									}
								}
                            }

                            if(hrReturn == WBEM_S_NO_ERROR){

                                //We want to call MSI ourselves unless we are on NT4
                                // and dealing with a user install.
                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											uiStatus = g_fpMsiInstallProductW(bstrPackage, wcOptions);
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/install");
										LPWSTR wcCommandLine = NULL;

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wcCommandLine, bstrPackage);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcOptions);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                    ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
									{
										delete [] wcOptions;
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }
                            }
                        }
                    }else
                        hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
				}

                pOutParams->Release();

            }else
                pOutClass->Release();

        }else{

            pClass->Release();
            SysFreeString(bstrInstall);
        }
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    return hrReturn;
}

HRESULT CProduct::Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iMode;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrReinstall = SysAllocString(L"Reinstall");
    if(!bstrReinstall)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    DWORD dwMode;
    int i = -1;
    bool bFoundCode = false;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){
        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrReinstall, 0, NULL, &pOutClass))){
            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){
                //Get Reinstall Mode
                if(SUCCEEDED(GetProperty(pInParams, "ReinstallMode", &iMode))){

                    //Get the Product Code
                    while(pReqObj->m_Property[++i])
					{
                        if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
						{
							if ( wcslen ( pReqObj->m_Value[i] ) < BUFF_SIZE )
							{
								wcscpy(wcCode, pReqObj->m_Value[i]);
								bFoundCode = true;
							}
                        }   
                    }

                    if(bFoundCode){
                        //Get the appropriate ReinstallMode
                        switch(iMode){
                        case 1:
                            dwMode = REINSTALLMODE_FILEMISSING;
                            break;
                        case 2:
                            dwMode = REINSTALLMODE_FILEOLDERVERSION;
                            break;
                        case 3:
                            dwMode = REINSTALLMODE_FILEEQUALVERSION;
                            break;
                        case 4:
                            dwMode = REINSTALLMODE_FILEEXACT;
                            break;
                        case 5:
                            dwMode = REINSTALLMODE_FILEVERIFY;
                            break;
                        case 6:
                            dwMode = REINSTALLMODE_FILEREPLACE;
                            break;
                        case 7:
                            dwMode = REINSTALLMODE_USERDATA;
                            break;
                        case 8:
                            dwMode = REINSTALLMODE_MACHINEDATA;
                            break;
                        case 9:
                            dwMode = REINSTALLMODE_SHORTCUT;
                            break;
                        case 10:
                            dwMode = REINSTALLMODE_PACKAGE;
                            break;
                        default:
                            dwMode = NULL;
                            break;
                        }

                        //If everything is valid, proceed
                        if ( dwMode && hrReturn == WBEM_S_NO_ERROR )
						{
                            if(!IsNT4()){

								if ( msidata.Lock () )
								{
									INSTALLUI_HANDLER ui = NULL;

									//Set UI Level w/ event callback
									ui = SetupExternalUI ( );

									try
									{
										//Call Installer
										uiStatus = g_fpMsiReinstallProductW(wcCode, dwMode);
									}
									catch(...)
									{
										uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
									}

									//Restore UI Level w/ event callback
									RestoreExternalUI ( ui );

									msidata. Unlock();
								}

                            }else{

                            /////////////////
                            // NT4 fix code....

                                try{

                                    WCHAR wcAction[20];
                                    wcscpy(wcAction, L"/reinstall");

                                    WCHAR wcTmp[100];
									_itow((int)dwMode, wcTmp, 10);

									LPWSTR wcCommandLine = NULL;

									try
									{
										if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + 1 + wcslen ( wcTmp ) + 1 ] ) != NULL )
										{
											wcscpy(wcCommandLine, wcCode);
											wcscat(wcCommandLine, L" ");
											wcscat(wcCommandLine, wcTmp);

											hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

											delete [] wcCommandLine;
										}
										else
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}
									}
									catch ( ... )
									{
										if ( wcCommandLine )
										{
											delete [] wcCommandLine;
											wcCommandLine = NULL;
										}

										hrReturn = E_OUTOFMEMORY;
									}

                                }catch(...){

                                    hrReturn = WBEM_E_FAILED;
                                }

                                ////////////////////

                            }

                            if(SUCCEEDED(hrReturn)){

                                //Set up ReturnValue
                                VariantInit(&v);
                                V_VT(&v) = VT_I4;
                                V_I4(&v) = uiStatus;

                                BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                if(!bstrReturnValue)
								{
									delete [] wcOptions;
                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}

                                if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                    &v, NULL)))
                                    pHandler->Indicate(1, &pOutParams);

                                SysFreeString(bstrReturnValue);
                            }

                        }else return WBEM_E_INVALID_METHOD_PARAMETERS;

                    }else hrReturn = WBEM_E_FAILED;

                    pOutParams->Release();
                
                }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrReinstall);

    return hrReturn;
}

HRESULT CProduct::Uninstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                            IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrConfigure = SysAllocString(L"Configure");
    if(!bstrConfigure)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    int i = -1;
    bool bFoundCode = false;

    m_pRequest = pReqObj;

	LPWSTR wcOptions = NULL;
	DWORD dwOptions = BUFF_SIZE;

	try
	{
		if ( ( wcOptions = new WCHAR [ dwOptions ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
	}
	catch ( ... )
	{
		if ( wcOptions )
		{
			delete [] wcOptions;
			wcOptions = NULL;
		}

		throw;
	}

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrConfigure, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get the Product Code
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
					{
						if ( wcslen ( pReqObj->m_Value[i] ) < BUFF_SIZE )
						{
							wcscpy(wcCode, pReqObj->m_Value[i]);
							bFoundCode = true;
						}
                    }   
                }

                if(bFoundCode){
                    //If everything is valid, proceed
                    if(hrReturn == WBEM_S_NO_ERROR){
                        
                        if(!IsNT4()){

							if ( msidata.Lock () )
							{
								INSTALLUI_HANDLER ui = NULL;

								//Set UI Level w/ event callback
								ui = SetupExternalUI ( );

								try
								{
									//Call Installer
									uiStatus = g_fpMsiConfigureProductW(wcCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT);
								}
								catch(...)
								{
									uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
								}

								//Restore UI Level w/ event callback
								RestoreExternalUI ( ui );

								msidata. Unlock();
							}

                        }else{

                        /////////////////
                        // NT4 fix code....

                            try{

                                WCHAR wcAction[20];
                                wcscpy(wcAction, L"/uninstall");

								LPWSTR wcCommandLine = NULL;

								try
								{
									if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + 1 ] ) != NULL )
									{
										wcscpy(wcCommandLine, wcCode);
										hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

										delete [] wcCommandLine;
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcCommandLine )
									{
										delete [] wcCommandLine;
										wcCommandLine = NULL;
									}

									hrReturn = E_OUTOFMEMORY;
								}

                            }catch(...){

                                hrReturn = WBEM_E_FAILED;
                            }

                            ////////////////////

                        }

                        if(SUCCEEDED(hrReturn)){

                            //Set up ReturnValue
                            VariantInit(&v);
                            V_VT(&v) = VT_I4;
                            V_I4(&v) = uiStatus;

                            BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                            if(!bstrReturnValue)
							{
								delete [] wcOptions;
                                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}

                            if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                &v, NULL)))
                                pHandler->Indicate(1, &pOutParams);

                            SysFreeString(bstrReturnValue);
                        }
                        
                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
                }else hrReturn = WBEM_E_FAILED;

                pOutParams->Release();
            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

	if ( wcOptions )
	{
		delete [] wcOptions;
		wcOptions = NULL;
	}

    SysFreeString(bstrConfigure);

    return hrReturn;
}

HRESULT CProduct::Upgrade(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                          IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    BSTR bstrPackage = NULL;
	BSTR wcOptions = NULL;
    UINT uiStatus = 1603;
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrUpgrade = SysAllocString(L"Upgrade");
    if(!bstrUpgrade)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    m_pRequest = pReqObj;

    if(SUCCEEDED(hrReturn = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hrReturn = pClass->GetMethod(bstrUpgrade, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hrReturn = pOutClass->SpawnInstance(0, &pOutParams))){
                //Get PackageLocation
                if(SUCCEEDED(GetProperty(pInParams, "PackageLocation", &bstrPackage))){

					OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_bstrPackage ( bstrPackage ) ;

                    if((wcscmp(bstrPackage, L"") != 0) && (wcslen(bstrPackage) <= INTERNET_MAX_PATH_LENGTH)){
                    
                    //Get Options
                        if ( SUCCEEDED ( GetProperty ( pInParams, "Options", &wcOptions ) ) )
						{
							OnDelete < BSTR, void ( * ) ( BSTR ), SysFreeString > del_wcOptions ( wcOptions ) ;

                            if(hrReturn == WBEM_S_NO_ERROR){
                                
                                if(!IsNT4()){

									if ( msidata.Lock () )
									{
										INSTALLUI_HANDLER ui = NULL;

										//Set UI Level w/ event callback
										ui = SetupExternalUI ( );

										try
										{
											//Call Installer
											if ( wcOptions && wcscmp ( wcOptions, L"" ) != 0 )
											{
												uiStatus = g_fpMsiApplyPatchW(bstrPackage, NULL, INSTALLTYPE_DEFAULT, wcOptions);
											}
											else
											{
												uiStatus = g_fpMsiApplyPatchW(bstrPackage, NULL, INSTALLTYPE_DEFAULT, NULL);
											}
										}
										catch(...)
										{
											uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
										}

										//Restore UI Level w/ event callback
										RestoreExternalUI ( ui );

										msidata. Unlock();
									}

                                }else{

                                /////////////////
                                // NT4 fix code....

                                    try{

                                        WCHAR wcAction[20];
                                        wcscpy(wcAction, L"/upgrade");

										LPWSTR wcCommandLine = NULL;

										try
										{
											if ( ( wcCommandLine = new WCHAR [ wcslen ( bstrPackage ) + 1 + wcslen ( wcOptions ) + 1 ] ) != NULL )
											{
												wcscpy(wcCommandLine, bstrPackage);
												wcscat(wcCommandLine, L" ");
												wcscat(wcCommandLine, wcOptions);

												hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

												delete [] wcCommandLine;
											}
											else
											{
												throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
											}
										}
										catch ( ... )
										{
											if ( wcCommandLine )
											{
												delete [] wcCommandLine;
												wcCommandLine = NULL;
											}

											hrReturn = E_OUTOFMEMORY;
										}

                                    }catch(...){

                                        hrReturn = WBEM_E_FAILED;
                                    }

                                    ////////////////////

                                }

                                if(SUCCEEDED(hrReturn)){

                                    //Set up ReturnValue
                                    VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                                    if(!bstrReturnValue)
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

                                    if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                        &v, NULL)))
                                        pHandler->Indicate(1, &pOutParams);

                                    SysFreeString(bstrReturnValue);
                                }
                            }
                        }else
                            hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
                    }else
                        hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;
				}else
                    hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }
    
    SysFreeString(bstrUpgrade);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\productenvironment.cpp ===
// ProductEnvironment.cpp: implementation of the CProductEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProductEnvironment.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProductEnvironment::CProductEnvironment(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProductEnvironment::~CProductEnvironment()
{

}

HRESULT CProductEnvironment::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;

    bool bResource, bProduct;

	CStringExt wcResource;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Environment`, `Component_` from Environment");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if(CreateProductString(wcProductCode, wcProduct)){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Environment", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

						// safe operation
                        wcResource.Copy ( L"Win32_EnvironmentSpecification.CheckID=\"" );

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							wcResource.Append ( 3, Buffer, wcProductCode, L"\"" );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pCheck, wcResource, &bResource, m_pRequest);
                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                            //====================================================

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\productenvironment.h ===
// ProductEnvironment.h: interface for the CProductEnvironment class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCTENVIRONMENT_H__EAA368A4_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PRODUCTENVIRONMENT_H__EAA368A4_DEA4_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProductEnvironment : public CGenericClass  
{
public:
	CProductEnvironment(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProductEnvironment();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PRODUCTENVIRONMENT_H__EAA368A4_DEA4_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\productresource1.h ===
// ProductResource1.h: interface for the CProductResource class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCTRESOURCE1_H__9374E720_D709_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_PRODUCTRESOURCE1_H__9374E720_D709_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CProductResource : public CGenericClass  
{
public:
	CProductResource(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProductResource();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT ProductPatch(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
	HRESULT ProductProperty(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
	HRESULT ProductPatchPackage(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
	HRESULT ProductUpgradeInformation(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									   CRequestObject *pResRObj, CRequestObject *pProductRObj);
};

#endif // !defined(AFX_PRODUCTRESOURCE1_H__9374E720_D709_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\productsoftwarefeatures.cpp ===
// ProductSoftwareFeatures.cpp: implementation of the CProductSoftwareFeatures class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProductSoftwareFeatures.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProductSoftwareFeatures::CProductSoftwareFeatures(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProductSoftwareFeatures::~CProductSoftwareFeatures()
{

}

HRESULT CProductSoftwareFeatures::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE] = { L'\0' };
    WCHAR wcTmp[BUFF_SIZE] = { L'\0' };
    WCHAR wcProductCode[39] = { L'\0' };
    WCHAR wcProduct[BUFF_SIZE] = { L'\0' };
    WCHAR wcFeature[BUFF_SIZE] = { L'\0' };
    UINT uiStatus;
    bool bMatch = false;

    bool bFeature, bProduct;
    int iEnum;

    try{

        while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED)){

			LPWSTR wszProductCode = NULL;
			wszProductCode = m_pRequest->Package(i);

			if ( wszProductCode != NULL )
			{
				wcscpy(wcProductCode, wszProductCode);

				if(CreateProductString(wcProductCode, wcProduct)){

					iEnum = 0;

					// try to get available feature
					do
					{
						uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcBuf, wcTmp);
					}
					while ( uiStatus == ERROR_MORE_DATA );

					while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED))
					{
						CheckMSI(uiStatus);

						if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

						if(CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, false)){

							PutKeyProperty(m_pObj, pComponent, wcFeature, &bFeature, m_pRequest);
							PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);

							if(bFeature && bProduct) bMatch = true;

							if((atAction != ACTIONTYPE_GET)  || bMatch) hr = pHandler->Indicate(1, &m_pObj);
						}

						m_pObj->Release();
						m_pObj = NULL;

						// try to get available feature
						do
						{
							uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcBuf, wcTmp);
						}
						while ( uiStatus == ERROR_MORE_DATA );
					}
				}
			}
        }

    }catch(...){
        
        if(m_pObj){
                
            m_pObj->Release();
            m_pObj = NULL;
        }

        throw;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\productresource1.cpp ===
// ProductResource1.cpp: implementation of the CProductResource class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProductResource1.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProductResource::CProductResource(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProductResource::~CProductResource()
{

}

HRESULT CProductResource::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pProductRObj = NULL;
    CRequestObject *pResRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
            int i;

            for(i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"Resource") == 0){

                    pResRObj = new CRequestObject();
                    if(!pResRObj) throw he;

                    pResRObj->Initialize(m_pNamespace);

                    pResRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"Product") == 0){

                    pProductRObj = new CRequestObject();
                    if(!pProductRObj) throw he;

                    pProductRObj->Initialize(m_pNamespace);

                    pProductRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_Patch") == 0)))
            if(FAILED(hr = ProductPatch(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_Property") == 0)))
            if(FAILED(hr = ProductProperty(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_PatchPackage") == 0)))
            if(FAILED(hr = ProductPatchPackage(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pProductRObj ||
            (pResRObj && pResRObj->m_bstrClass && (_wcsicmp(pResRObj->m_bstrClass, L"Win32_Upgrade") == 0)))
            if(FAILED(hr = ProductUpgradeInformation(pHandler, atAction, pResRObj, pProductRObj))){

                if(pResRObj){

                    pResRObj->Cleanup();
                    delete pResRObj;
                    pResRObj = NULL;
                }
                if(pProductRObj){

                    pProductRObj->Cleanup();
                    delete pProductRObj;
                    pProductRObj = NULL;
                }
                return hr;
            }

        if(pResRObj){

            pResRObj->Cleanup();
            delete pResRObj;
            pResRObj = NULL;
        }
        if(pProductRObj){

            pProductRObj->Cleanup();
            delete pProductRObj;
            pProductRObj = NULL;
        }

    }catch(...){

        if(pResRObj){

            pResRObj->Cleanup();
            delete pResRObj;
            pResRObj = NULL;
        }
        if(pProductRObj){

            pProductRObj->Cleanup();
            delete pProductRObj;
            pProductRObj = NULL;
        }
    }

    return hr;
}

HRESULT CProductResource::ProductUpgradeInformation(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcUpgradeCode[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bUpgradeCode = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"UpgradeCode") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcUpgradeCode, pResRObj->m_Value[j]);
						bUpgradeCode = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `UpgradeCode`, `ProductVersion`, `Operator` from Upgrade" );

    //optimize for GetObject
    if ( bUpgradeCode && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `UpgradeCode`=\'", wcUpgradeCode, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){

				//Open our database
                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Upgrade", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_Upgrade.UpgradeCode=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcResource.Append ( 2, wcBuf, L"\",ProductVersion=\"" );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								wcResource.Append ( 2, wcBuf, L"\",Operator=\"" );

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								wcResource.Append ( 4, Buffer, L"\",ProductCode=\"", wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					if (hRecord)
					g_fpMsiCloseHandle(hRecord);

					if (hView)
					{
						g_fpMsiViewClose(hView);
						g_fpMsiCloseHandle(hView);
					}

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();
            }
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}

HRESULT CProductResource::ProductPatchPackage(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[39];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcPatchID[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bPatchID = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"PatchID") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcPatchID, pResRObj->m_Value[j]);
						bPatchID = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `PatchId` from PatchPackage" );

    //optimize for GetObject
    if ( bPatchID && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `PatchId`=\'", wcPatchID, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){

				//Open our database

                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"PatchPackage", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_PatchPackage.PatchID=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = 39;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                            if(wcscmp(wcBuf, L"") != 0)
							{
								wcResource.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);

                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                            //====================================================

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;
                            
                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					if (hRecord)
					g_fpMsiCloseHandle(hRecord);

					if (hView)
					{
						g_fpMsiViewClose(hView);
						g_fpMsiCloseHandle(hView);
					}

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();
            }
        }
    }

    return hr;
}

HRESULT CProductResource::ProductProperty(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcProperty[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bProperty = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"PatchID") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcProperty, pResRObj->m_Value[j]);
						bProperty = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Property` from Property" );

    //optimize for GetObject
    if ( bProperty && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `Property`=\'", wcProperty, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct))
			{
				//Open our database
                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Property", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_Property.Property=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								wcResource.Append ( 4, Buffer, L"\",ProductCode=\"", wcProductCode, L"\"" );

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

								PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);
                                PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                            //====================================================

                            //----------------------------------------------------

                                if(bResource && bProduct) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					if (hRecord)
					g_fpMsiCloseHandle(hRecord);

					if (hView)
					{
						g_fpMsiViewClose(hView);
						g_fpMsiCloseHandle(hView);
					}

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();
            }
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}

HRESULT CProductResource::ProductPatch(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                       CRequestObject *pResRObj, CRequestObject *pProductRObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProduct[BUFF_SIZE];
    WCHAR wcPatch[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    DWORD dwBufSize;
    UINT uiStatus;
    bool bMatch = false;
    bool bTestCode = false;
    bool bPatch = false;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pProductRObj){

            for(j = 0; j < pProductRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pProductRObj->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pProductRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pProductRObj->m_Value[j]);
						bTestCode = true;
	                    break;
					}
                }
            }
        }

        if(pResRObj){

            for(j = 0; j < pResRObj->m_iPropCount; j++){
                
                if(_wcsicmp(pResRObj->m_Property[j], L"File") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pResRObj->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcPatch, pResRObj->m_Value[j]);
						bPatch = true;
	                    break;
					}
                }
            }
        }
    }

    bool bResource, bProduct;

	CStringExt wcResource;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Sequence` from Patch" );

    //optimize for GetObject
    if ( bPatch && (atAction != ACTIONTYPE_ENUM) )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcPatch, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            if(CreateProductString(wcProductCode, wcProduct)){

				//Open our database
                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Patch", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            wcResource.Copy ( L"Win32_Patch.File=\"" );

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if( Buffer && Buffer[ 0 ] != 0 )
							{
								wcResource.Append ( 2, Buffer, L"\",Sequence=\"" );

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									wcResource.Append ( 4, wcBuf, L"\",ProductCode=\"", wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pResource, wcResource, &bResource, m_pRequest);

                                    PutKeyProperty(m_pObj, pProduct, wcProduct, &bProduct, m_pRequest);
                                //====================================================

                                //----------------------------------------------------

                                    if(bResource && bProduct) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					if (hRecord)
					g_fpMsiCloseHandle(hRecord);

					if (hView)
					{
						g_fpMsiViewClose(hView);
						g_fpMsiCloseHandle(hView);
					}

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();
            }
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\progidspecification.h ===
// ProgIDSpecification.h: interface for the CProgIDSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROGIDSPECIFICATION_H__72CDD5D7_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_PROGIDSPECIFICATION_H__72CDD5D7_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProgIDSpecification : public CGenericClass  
{
public:
	CProgIDSpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProgIDSpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PROGIDSPECIFICATION_H__72CDD5D7_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\productsoftwarefeatures.h ===
// ProductSoftwareFeatures.h: interface for the CProductSoftwareFeatures class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRODUCTSOFTWAREFEATURES_H__02FF6C84_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_PRODUCTSOFTWAREFEATURES_H__02FF6C84_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProductSoftwareFeatures : public CGenericClass  
{
public:
	CProductSoftwareFeatures(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProductSoftwareFeatures();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PRODUCTSOFTWAREFEATURES_H__02FF6C84_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\progidspecification.cpp ===
// ProgIDSpecification.cpp: implementation of the CProgIDSpecification class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProgIDSpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProgIDSpecification::CProgIDSpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProgIDSpecification::~CProgIDSpecification()
{

}

HRESULT CProgIDSpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcProgId[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcProgId);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ProgId`, `ProgId_Parent`, `Description` from ProgId" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ProgId`=\'", wcProgId, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            bMatch = false;
			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ProgId", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pProgID, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pParent);

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\property.cpp ===
// Property.cpp: implementation of the CProperty class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Property.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProperty::CProperty(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CProperty::~CProperty()
{

}

HRESULT CProperty::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bProperty, bProduct;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"Property" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Property`, `Value` from Property" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `Property`=\'", wcName, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && (m_pRequest->Package(++i)) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Property", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutKeyProperty(m_pObj, pProperty, Buffer, &bProperty, m_pRequest);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProduct, m_pRequest);
                    //====================================================

                        dwBufSize = BUFF_SIZE;
                        uiStatus = g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize);

                        //check if we overflowed the buffer.. if so try to compensate
                        if ( uiStatus == ERROR_MORE_DATA)
						{
							LPWSTR wcBigBuf = NULL;

							try
							{
								if ( ( wcBigBuf = new WCHAR [ ++dwBufSize ] ) != NULL )
								{
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBigBuf, &dwBufSize));
									PutProperty(m_pObj, pValue, wcBigBuf);
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							catch ( ... )
							{
								if ( wcBigBuf )
								{
									delete [] wcBigBuf;
									wcBigBuf = NULL;
								}

								throw;
							}

							if ( wcBigBuf )
							{
								delete [] wcBigBuf;
								wcBigBuf = NULL;
							}

                        }else{
                        
                            CheckMSI(uiStatus);
                            PutProperty(m_pObj, pValue, wcBuf);
                        }
                    //----------------------------------------------------

                        if(bProperty && bProduct) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\property.h ===
// Property.h: interface for the CProperty class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROPERTY_H__DB614F2C_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_PROPERTY_H__DB614F2C_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CProperty : public CGenericClass  
{
public:
	CProperty(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CProperty();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
	{
		return WBEM_E_NOT_SUPPORTED;
	}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PROPERTY_H__DB614F2C_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\publishcomponent.h ===
// PublishComponent.h: interface for the CPublishComponent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PUBLISHCOMPONENT_H__75F6BA29_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_PUBLISHCOMPONENT_H__75F6BA29_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPublishComponent : public CGenericClass  
{
public:
	CPublishComponent(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CPublishComponent();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_PUBLISHCOMPONENT_H__75F6BA29_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\removeinivalue.h ===
// RemoveIniValue.h: interface for the CRemoveIniValue class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REMOVEINIVALUE_H__DB614F34_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_REMOVEINIVALUE_H__DB614F34_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CRemoveIniValue : public CGenericClass  
{
public:
	CRemoveIniValue(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CRemoveIniValue();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_REMOVEINIVALUE_H__DB614F34_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\removefile.h ===
// RemoveFile.h: interface for the CRemoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REMOVEFILE_H__F4A87828_E037_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_REMOVEFILE_H__F4A87828_E037_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CRemoveFile : public CGenericClass  
{
public:
	CRemoveFile(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CRemoveFile();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_REMOVEFILE_H__F4A87828_E037_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\removeinivalue.cpp ===
// RemoveIniValue.cpp: implementation of the CRemoveIniValue class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "RemoveIniValue.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRemoveIniValue::CRemoveIniValue(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CRemoveIniValue::~CRemoveIniValue()
{

}

HRESULT CRemoveIniValue::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `RemoveIniFile`, `Component_`, `FileName`, `Section`, `Key`, `Value`, `Action` from RemoveIniFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `RemoveIniFile`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveIniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pSection );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pKey );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 6, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pValue );

                            PutProperty(m_pObj, pAction, g_fpMsiRecordGetInteger(hRecord, 7));

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\removefile.cpp ===
// RemoveFile.cpp: implementation of the CRemoveFile class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "RemoveFile.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRemoveFile::CRemoveFile(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CRemoveFile::~CRemoveFile()
{

}

HRESULT CRemoveFile::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `FileKey`, `Component_`, `FileName`, `DirProperty`, `InstallMode` from RemoveFile" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `FileKey`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcProp, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pFileKey, Buffer);
                        PutProperty(m_pObj, pName, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pFileName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDirProperty );

                            PutProperty(m_pObj, pInstallMode, g_fpMsiRecordGetInteger(hRecord, 5));

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                            
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\publishcomponent.cpp ===
// PublishComponent.cpp: implementation of the CPublishComponent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PublishComponent.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPublishComponent::CPublishComponent(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPublishComponent::~CPublishComponent()
{

}

HRESULT CPublishComponent::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					GetFirstGUID(m_pRequest->m_Value[iPos], wcAction);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ComponentId`, `Component_`, `Qualifier`, `AppData` from PublishComponent" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ComponentId`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PublishComponent", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = 39;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcProp, &dwBufSize));
                        PutProperty(m_pObj, pComponentID, wcProp);
                        PutProperty(m_pObj, pName, wcProp);
                        PutProperty(m_pObj, pCaption, wcProp);
                        PutProperty(m_pObj, pDescription, wcProp);

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            PutProperty(m_pObj, pQual, Buffer);
							PutKeyProperty ( m_pObj, pActionID, wcProp, &bCheck, m_pRequest, 2, Buffer, wcProductCode );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

						//====================================================

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pAppData );

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\reservecost.h ===
// ReserveCost.h: interface for the CReserveCost class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RESERVECOST_H__02FF6C8E_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_RESERVECOST_H__02FF6C8E_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CReserveCost : public CGenericClass  
{
public:
	CReserveCost(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CReserveCost();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_RESERVECOST_H__02FF6C8E_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\reservecost.cpp ===
// ReserveCost.cpp: implementation of the CReserveCost class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ReserveCost.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CReserveCost::CReserveCost(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CReserveCost::~CReserveCost()
{

}

HRESULT CReserveCost::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcReserveKey[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheckID;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcReserveKey);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ReserveKey`, `Component_`, `ReserveLocal`, `ReserveSource` from ReserveCost" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ReserveKey`=\'", wcReserveKey, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ReserveCost", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pReserveKey, Buffer);
                        PutProperty(m_pObj, pName, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bCheckID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pReserveLocal, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pReserveSource, wcBuf);
                        //----------------------------------------------------

                            if(bCheckID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\selfregmodule.h ===
// SelfRegModule.h: interface for the CSelfRegModule class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SELFREGMODULE_H__75F6BA28_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SELFREGMODULE_H__75F6BA28_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSelfRegModule : public CGenericClass  
{
public:
	CSelfRegModule(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSelfRegModule();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SELFREGMODULE_H__75F6BA28_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\selfregmodule.cpp ===
// SelfRegModule.cpp: implementation of the CSelfRegModule class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SelfRegModule.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSelfRegModule::CSelfRegModule(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSelfRegModule::~CSelfRegModule()
{

}

HRESULT CSelfRegModule::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `File_`, `Cost` from SelfReg" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `File_`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"SelfReg", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pFile, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);
                        PutProperty(m_pObj, pName, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bCheck, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                   //====================================================

                        PutProperty(m_pObj, pCost, g_fpMsiRecordGetInteger(hRecord, 2));

                    //----------------------------------------------------

                        if(bCheck) bMatch = true;

                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\requestobject.h ===
// RequestObject.h: interface for the CRequestObject class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REQUESTOBJECT_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_REQUESTOBJECT_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define EVENT_THREADS   50
#define THREAD_NO_PROGRESS  -9

class CGenericClass;

//Used to house progress message information
typedef struct ProgressStruct
{
    long field1;
    long field2;
    long field3;
    long field4;
} ProgressStruct;

//Used to house progress message information
typedef struct ProListNode
{
    //Link
    ProListNode *pNext;
    //Data
    int iThread;
    IWbemObjectSink *pSink;
    WORD wTotal;
    __int64 lTotal;
    WORD wComplete;
    __int64 lComplete;
    __int64 lActionData;
} ProListNode;

//Used to house package codes
class PackageListNode
{
public:
    PackageListNode() { pNext = NULL; wcscpy(wcCode, L""); }
    virtual ~PackageListNode() {}

    //Link
    PackageListNode *pNext;
    //Data
    WCHAR wcCode[39];
};

//UI Handler
int WINAPI MyEventHandler(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage);

class CRequestObject
{
	friend BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID );

public:
    CRequestObject();
    virtual ~CRequestObject();

    void Initialize(IWbemServices *pNamespace);

    HRESULT CreateObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT CreateObjectEnum(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT PutObject(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT ExecMethod(BSTR bstrPath, BSTR bstrMethod, IWbemClassObject *pInParams,
                   IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT DeleteObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);

#ifdef _EXEC_QUERY_SUPPORT
    HRESULT ExecQuery(BSTR bstrQuery, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    bool ParseQuery(BSTR bstrQuery);
#endif

    bool ParsePath(BSTR bstrPath);
    HRESULT InitializeList(bool bGetList);
    bool DestroyList();
    bool Cleanup();
    void FinalRelease();

    //Registry Hive stuff
    DWORD GetAccount(HANDLE TokenHandle, WCHAR *wcDomain, WCHAR *wcUser);
    DWORD GetSid(HANDLE TokenHandle, WCHAR *wcSID, DWORD dwSID = BUFF_SIZE );
    DWORD LoadHive();
    DWORD UnloadHive();
    DWORD AcquirePrivilege();
    void RestorePrivilege();

    TOKEN_PRIVILEGES* m_pOriginalPriv;
    HKEY m_hKey;
    DWORD m_dwSize;
    DWORD m_dwCheckKeyPresentStatus;
    WCHAR m_wcAccount[BUFF_SIZE];
    WCHAR m_wcKeyName[1024];
    WCHAR m_wcDomain[BUFF_SIZE];
    WCHAR m_wcUser[BUFF_SIZE];

    BSTR Package(int iPos);

    BSTR m_bstrClass;
    BSTR m_bstrPath;
    BSTR m_Property[MSI_KEY_LIST_SIZE];
    BSTR m_Value[MSI_KEY_LIST_SIZE];
    int m_iPropCount;
    int m_iValCount;
    int m_iThreadID;

    IWbemServices *m_pNamespace;
    IWbemObjectSink *m_pHandler;

    bool ParseProgress			(WCHAR *wcMessage, ProgressStruct *ps);
    bool ActionDataProgress		(HRESULT *hr, int iThread);
    bool ActionStartProgress	(HRESULT *hr, int iThread);
    bool CreateProgress			(ProgressStruct *ps, HRESULT *hr, int iThread);

    ProListNode *	GetNode		(int iThread);

private:
    HRESULT CreateClass(CGenericClass **pClass, IWbemContext *pCtx);

#ifdef _EXEC_QUERY_SUPPORT
    //Query Parsing Functions
    WCHAR * GetNextProperty(WCHAR **pwcString, WCHAR wcProp[]);
    WCHAR * GetNextValue(WCHAR **pwcString, WCHAR wcVal[]);
    bool ExpectedToken(WCHAR **pwcString, WCHAR *pwcExpected);
    WCHAR * GetNextToken(WCHAR **pwcString, WCHAR wcToken[]);
    WCHAR * GetStringValue(WCHAR **pwcString, WCHAR wcToken[]);
    bool EOL(WCHAR **pwcString);
#endif // _EXEC_QUERY_SUPPORT

    bool IsInstance();

    ProListNode * InitializeProgress(IWbemObjectSink *pHandler);

    //Package list head
    PackageListNode *m_pPackageHead;

    //Thread List for progress messages
    ProListNode *	m_pHead;

    ProListNode *	RemoveNode	(int iThread);
    int				InsertNode	(ProListNode *pNode);

    //Critical section for event handling and thread ID assignement
    static CRITICAL_SECTION m_cs;

    static CHeap_Exception m_he;

protected:
    ULONG m_cRef;         //Object reference count
};

//Properties
//////////////////
extern const char * pAccesses;
extern const char * pAction;
extern const char * pActionID;
extern const char * pAntecedent;
extern const char * pAppData;
extern const char * pAppID;
extern const char * pArgument;
extern const char * pArguments;
extern const char * pAttribute;
extern const char * pAttributes;
extern const char * pCabinet;
extern const char * pCaption;
extern const char * pCheck;
extern const char * pCheckID;
extern const char * pCLSID;
extern const char * pCommand;
extern const char * pCommandLine;
extern const char * pComponent;
extern const char * pComponentID;
extern const char * pCondition;
extern const char * pContentType;
extern const char * pContext;
extern const char * pCost;
extern const char * pCreationClassName;
extern const char * pDataSource;
extern const char * pDefaultDir;
extern const char * pDefInprocHandler;
extern const char * pDependencies;
extern const char * pDependent;
extern const char * pDescription;
extern const char * pDestination;
extern const char * pDestFolder;
extern const char * pDestName;
extern const char * pDirectory;
extern const char * pDirectoryName;
extern const char * pDirectoryPath;
extern const char * pDirProperty;
extern const char * pDiskID;
extern const char * pDiskPrompt;
extern const char * pDisplay;
extern const char * pDisplayName;
extern const char * pDomain;
extern const char * pDriver;
extern const char * pDriverDescription;
extern const char * pElement;
extern const char * pEntryName;
extern const char * pEntryValue;
extern const char * pEnvironment;
extern const char * pError;
extern const char * pErrorControl;
extern const char * pEvent;
extern const char * pExpression;
extern const char * pExpressionType;
extern const char * pExtension;
extern const char * pFeature;
extern const char * pFeatures;
extern const char * pField;
extern const char * pFile;
extern const char * pFileKey;
extern const char * pFileName;
extern const char * pFileSize;
extern const char * pFileTypeMask;
extern const char * pFontTitle;
extern const char * pGroupComponent;
extern const char * pHotKey;
extern const char * pID;
extern const char * pIdentificationCode;
extern const char * pIdentifyingNumber;
extern const char * pIniFile;
extern const char * pInsertable;
extern const char * pInstallDate;
extern const char * pInstallDate2;
extern const char * pInstallLocation;
extern const char * pInstallMode;
extern const char * pInstallState;
extern const char * pKey;
extern const char * pLanguage;
extern const char * pLastSequence;
extern const char * pLastUse;
extern const char * pLevel;
extern const char * pLibID;
extern const char * pLoadOrderGroup;
extern const char * pLocation;
extern const char * pManufacturer;
extern const char * pMaxDate;
extern const char * pMaxSize;
extern const char * pMaxVersion;
extern const char * pMessage;
extern const char * pMIME;
extern const char * pMinDate;
extern const char * pMinSize;
extern const char * pMinVersion;
extern const char * pName;
extern const char * pNext;
extern const char * pOperator;
extern const char * pOptions;
extern const char * pPackageCache;
extern const char * pParent;
extern const char * pPartComponent;
extern const char * pPassword;
extern const char * pPatch;
extern const char * pPatchID;
extern const char * pPatchSize;
extern const char * pPath;
extern const char * pPermission;
extern const char * pPrior;
extern const char * pProduct;
extern const char * pProductCode;
extern const char * pProductName;
extern const char * pProductVersion;
extern const char * pProgID;
extern const char * pProperty;
extern const char * pQual;
extern const char * pRegistration;
extern const char * pRegistry;
extern const char * pRemoteName;
extern const char * pReserveKey;
extern const char * pReserveLocal;
extern const char * pReserveSource;
extern const char * pResource;
extern const char * pRoot;
extern const char * pSection;
extern const char * pSequence;
extern const char * pServiceType;
extern const char * pSetting;
extern const char * pSetupFile;
extern const char * pShellNew;
extern const char * pShellNewValue;
extern const char * pSignature;
extern const char * pShortcut;
extern const char * pShowCmd;
extern const char * pSoftware;
extern const char * pSoftwareElementID;
extern const char * pSoftwareElementState;
extern const char * pSource;
extern const char * pSourceFolder;
extern const char * pSourceName;
extern const char * pStartMode;
extern const char * pStartName;
extern const char * pStartType;
extern const char * pStatus;
extern const char * pSystem;
extern const char * pSystemCreationClassName;
extern const char * pSystemName;
extern const char * pTable;
extern const char * pTarget;
extern const char * pTargetOperatingSystem;
extern const char * pTranslator;
extern const char * pType;
extern const char * pUpgradeCode;
extern const char * pUser;
extern const char * pValue;
extern const char * pVendor;
extern const char * pVerb;
extern const char * pVersion;
extern const char * pVolumeLabel;
extern const char * pWait;
extern const char * pWkDir;

#endif // !defined(AFX_REQUESTOBJECT_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\servicecontrol.h ===
// ServiceControl.h: interface for the CServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICECONTROL_H__72CDD5D9_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_SERVICECONTROL_H__72CDD5D9_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CServiceControl : public CGenericClass  
{
public:
	CServiceControl(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CServiceControl();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SERVICECONTROL_H__72CDD5D9_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\requestobject.cpp ===
// RequestObject.cpp: implementation of the CRequestObject class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "requestobject.h"
#include <stdio.h>
#include <CRegCls.h>
#include <wininet.h>

//Classes
#include "ApplicationService.h"
#include "Binary.h"
#include "BindImage.h"
#include "ClassInfoAction.h"
#include "CommandLineAccess.h"
#include "Condition.h"
#include "CreateFolder.h"
#include "DirectorySpecification.h"
#include "DuplicateFile.h"
#include "Environment.h"
#include "ExtensionInfoAction.h"
#include "FileSpecification.h"
#include "FontInfoAction.h"
#include "IniFile.h"
#include "LaunchCondition.h"
#include "MIMEInfoAction.h"
#include "MoveFile.h"
#include "ODBCAttribute.h"
#include "ODBCDataSource.h"
#include "ODBCDriver.h"
#include "ODBCSourceAttribute.h"
#include "ODBCTranslator.h"
#include "Patch.h"
#include "PatchPackAge.h"
#include "ProgIDSpecification.h"
#include "Product.h"
#include "Property.h"
#include "PublishComponent.h"
#include "RemoveFile.h"
#include "RemoveIniValue.h"
#include "ReserveCost.h"
#include "SelfRegModule.h"
#include "ServiceControl.h"
#include "ServiceSpecification.h"
#include "ShortcutAction.h"
#include "SoftwareElement.h"
#include "SoftwareElementCondition.h"
#include "SoftwareFeature.h"
#include "TypeLibraryAction.h"
//#include "Upgrade.h"
#include "WriteRegistry.h"

//Associations
#include "ActionCheck.h"
#include "ApplicationCommandLine.h"
#include "CheckCheck.h"
#include "InstalledSoftwareElement.h"
#include "ODBCDataSourceAttribute.h"
#include "ODBCDriverAttribute.h"
#include "ODBCDriverSoftwareElement.h"
#include "PatchFile.h"
#include "ProductResource1.h"
#include "ProductEnvironment.h"
#include "ProductSoftwareFeatures.h"
#include "ServiceSpecificationService.h"
#include "ShortcutSAP.h"
#include "SoftwareElementAction.h"
#include "SoftwareElementCheck.h"
#include "SoftwareElementServiceControl.h"
#include "SoftwareFeatureAction.h"
#include "SoftwareFeatureCondition.h"
#include "SoftwareFeatureParent.h"
#include "SoftwareFeatureSoftwareElements.h"

CRITICAL_SECTION CRequestObject::m_cs;
CHeap_Exception CRequestObject::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

//////////////////////////////////////////////////////////////////////
// event handler for methods
//////////////////////////////////////////////////////////////////////

int WINAPI MyEventHandler ( LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage )
{
	// request object
	CRequestObject* pObj = NULL;
	pObj = reinterpret_cast < CRequestObject* > ( pvContext );

    BSTR bstrMsg	= NULL;

    try
	{
        if ( pObj && pObj->m_iThreadID != THREAD_NO_PROGRESS )
		{
			ProListNode *pNode = NULL;
			
			if ( ( pNode = pObj->GetNode ( pObj->m_iThreadID ) ) != NULL )
			{
				if ( pNode->pSink != NULL)
				{
					//Get the values we need from the MessageType
					UINT uiMsg = iMessageType & 0x0F000000L;

					if(szMessage)
					{
						bstrMsg = SysAllocString(szMessage);
					}
					else
					{
						bstrMsg = SysAllocString(L"");
					}

					HRESULT hr  = WBEM_S_NO_ERROR;
					HRESULT hrProgress = WBEM_STATUS_PROGRESS;
					bool bSuccess = true;

					switch(uiMsg)
					{
						case INSTALLMESSAGE_FATALEXIT:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_ERROR:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_WARNING:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_USER:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_INFO:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_FILESINUSE:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_RESOLVESOURCE:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_OUTOFDISKSPACE:
						if(!pObj->CreateProgress(NULL, &hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_ACTIONSTART:
						if(!pObj->ActionStartProgress(&hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_ACTIONDATA:
						if(!pObj->ActionDataProgress(&hr, pObj->m_iThreadID)) bSuccess = false;
						break;

						case INSTALLMESSAGE_PROGRESS:
						ProgressStruct ps;
						if(pObj->ParseProgress(bstrMsg, &ps))
						{
							if(!pObj->CreateProgress(&ps, &hr, pObj->m_iThreadID)) bSuccess = false;
						}

						break;

						case INSTALLMESSAGE_INITIALIZE:
						break;

						case INSTALLMESSAGE_TERMINATE:
						break;

						default:
						bSuccess = false;
						break;
					}

					//Send the message
					if(bSuccess)
					{
						pNode->pSink->SetStatus(hrProgress, hr, bstrMsg, NULL);
					}
				}
			}
		}
    }
	catch(...)
	{
    }

	if ( bstrMsg )
	{
		::SysFreeString(bstrMsg);
	}

    return 0;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRequestObject::CRequestObject()
{
    m_cRef = 0;
    m_bstrPath = NULL;
    m_bstrClass = NULL;
    m_pPackageHead = NULL;
    m_hKey = NULL;
}

CRequestObject::~CRequestObject()
{
}

//***************************************************************************
//
// CRequestObject::QueryInterface
// CRequestObject::AddRef
// CRequestObject::Release
//
// Purpose: IUnknown members for CRequestObject object.
//***************************************************************************
/*
STDMETHODIMP CRequestObject::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv = NULL;

    if(riid == IID_IMsiMethodStatusSink)
       *ppv = (IMsiMethodStatusSink *)this;

    if(riid == IID_IUnknown)
       *ppv = (IMsiMethodStatusSink *)this;

    if(NULL != *ppv){

        AddRef();
        return NOERROR;

    }else return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CRequestObject::AddRef(void)
{
    InterlockedIncrement((long *)&m_cRef);

    return m_cRef;
}

STDMETHODIMP_(ULONG) CRequestObject::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

//    if(0L == nNewCount) delete this;
    
    return nNewCount;
}
*/
void CRequestObject::Initialize(IWbemServices *pNamespace)
{
    m_pNamespace = pNamespace;
    m_pHandler = NULL;
    m_bstrClass = NULL;
    m_bstrPath = NULL;
    m_iPropCount = m_iValCount = 0;
    m_iThreadID = THREAD_NO_PROGRESS;
    m_pHead = NULL;
    m_dwCheckKeyPresentStatus = ERROR_SUCCESS;

    for(int i = 0; i < MSI_KEY_LIST_SIZE; i++) m_Property[i] = m_Value[i] = NULL;

    HANDLE hTokenImpersonationHandle;
    DWORD dwStatus;

    if(OpenThreadToken(GetCurrentThread(), (TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY),
        TRUE ,& hTokenImpersonationHandle)){

        dwStatus = GetAccount(hTokenImpersonationHandle, m_wcDomain, m_wcUser );
        
        if(dwStatus == 0)
		{
			if ( wcslen ( m_wcDomain ) + wcslen ( m_wcUser ) + 1 + 1 < BUFF_SIZE )
			{
				wcscpy(m_wcAccount, m_wcDomain);
				wcscat(m_wcAccount, L"\\");
				wcscat(m_wcAccount, m_wcUser);

				WCHAR wcSID[BUFF_SIZE];

				if((dwStatus = GetSid(hTokenImpersonationHandle, wcSID)) == S_OK ){

					CRegistry *pReg = new CRegistry();
					if(!pReg) throw m_he;
                
					//check if SID already present under HKEY_USER ...
					m_dwCheckKeyPresentStatus = pReg->Open(HKEY_USERS, wcSID, KEY_READ) ;
                
					if(m_dwCheckKeyPresentStatus == ERROR_NOT_ENOUGH_MEMORY)
						throw m_he;

					pReg->Close();
					delete pReg;
				}
			}
        }

        CloseHandle(hTokenImpersonationHandle);
    }
}

void CRequestObject::FinalRelease()
{
}

HRESULT CRequestObject::CreateObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath)
        throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass)
                    throw m_he;

                //get the requested object
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_GET);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            
            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::CreateClass(CGenericClass **pClass, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

        //Create the appropriate class
/////////////
// Classes //
/////////////
    if(0 == _wcsicmp(m_bstrClass, L"WIN32_APPLICATIONSERVICE")){
        *pClass = new CApplicationService(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_BINARY")){
        *pClass = new CBinary(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_BINDIMAGEACTION")){
        *pClass = new CBindImage(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CLASSINFOACTION")){
        *pClass = new CClassInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_COMMANDLINEACCESS")){
        *pClass = new CCommandLineAccess(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CONDITION")){
        *pClass = new CCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CREATEFOLDERACTION")){
        *pClass = new CCreateFolder(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_DIRECTORYSPECIFICATION")){
        *pClass = new CDirectorySpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_DUPLICATEFILEACTION")){
        *pClass = new CDuplicateFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ENVIRONMENTSPECIFICATION")){
        *pClass = new CEnvironment(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_EXTENSIONINFOACTION")){
        *pClass = new CExtensionInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_FILESPECIFICATION")){
        *pClass = new CFileSpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_FONTINFOACTION")){
        *pClass = new CFontInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_INIFILESPECIFICATION")){
        *pClass = new CIniFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_LAUNCHCONDITION")){
        *pClass = new CLaunchCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_MIMEINFOACTION")){
        *pClass = new CMIMEInfoAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_MOVEFILEACTION")){
        *pClass = new CMoveFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCATTRIBUTE")){
        *pClass = new CODBCAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDATASOURCESPECIFICATION")){
        *pClass = new CODBCDataSource(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDRIVERSPECIFICATION")){
        *pClass = new CODBCDriver(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCSOURCEATTRIBUTE")){
        *pClass = new CODBCSourceAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCTRANSLATORSPECIFICATION")){
        *pClass = new CODBCTranslator(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PATCH")){
        *pClass = new CPatch(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PATCHPACKAGE")){
        *pClass = new CPatchPackAge(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PROGIDSPECIFICATION")){
        *pClass = new CProgIDSpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCT")){
        *pClass = new CProduct(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PROPERTY")){
        *pClass = new CProperty(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PUBLISHCOMPONENTACTION")){
        *pClass = new CPublishComponent(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_REMOVEFILEACTION")){
        *pClass = new CRemoveFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_REMOVEINIACTION")){
        *pClass = new CRemoveIniValue(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_RESERVECOST")){
        *pClass = new CReserveCost(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SELFREGMODULEACTION")){
        *pClass = new CSelfRegModule(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SERVICECONTROL")){
        *pClass = new CServiceControl(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SERVICESPECIFICATION")){
        *pClass = new CServiceSpecification(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SHORTCUTACTION")){
        *pClass = new CShortcutAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENT")){
        *pClass = new CSoftwareElement(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTCONDITION")){
        *pClass = new CSoftwareElementCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURE")){
        *pClass = new CSoftwareFeature(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_TYPELIBRARYACTION")){
        *pClass = new CTypeLibraryAction(this, m_pNamespace, pCtx);

//  }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_UPGRADE")){
//      *pClass = new CUpgrade(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_REGISTRYACTION")){
        *pClass = new CRegistryAction(this, m_pNamespace, pCtx);

//////////////////
// Associations //
//////////////////

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ACTIONCHECK")){
        *pClass = new CActionCheck(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_APPLICATIONCOMMANDLINE")){
        *pClass = new CApplicationCommandLine(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_CHECKCHECK")){
        *pClass = new CCheckCheck(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_INSTALLEDSOFTWAREELEMENT")){
        *pClass = new CInstalledSoftwareElement(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDATASOURCEATTRIBUTE")){
        *pClass = new CODBCDataSourceAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDRIVERATTRIBUTE")){
        *pClass = new CODBCDriverAttribute(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_ODBCDRIVERSOFTWAREELEMENT")){
        *pClass = new CODBCDriverSoftwareElement(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PATCHFILE")){
        *pClass = new CPatchFile(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCTCHECK")){
        *pClass = new CProductEnvironment(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCTRESOURCE")){
        *pClass = new CProductResource(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCTSOFTWAREFEATURES")){
        *pClass = new CProductSoftwareFeatures(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SERVICESPECIFICATIONSERVICE")){
        *pClass = new CServiceSpecificationService(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SHORTCUTSAP")){
        *pClass = new CShortcutSAP(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTACTION")){
        *pClass = new CSoftwareElementAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTCHECK")){
        *pClass = new CSoftwareElementCheck(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREELEMENTRESOURCE")){
        *pClass = new CSoftwareElementServiceControl(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATUREACTION")){
        *pClass = new CSoftwareFeatureAction(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURECHECK")){
        *pClass = new CSoftwareFeatureCondition(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATUREPARENT")){
        *pClass = new CSoftwareFeatureParent(this, m_pNamespace, pCtx);

    }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURESOFTWAREELEMENTS")){
        *pClass = new CSoftwareFeatureSofwareElements(this, m_pNamespace, pCtx);
    }else return WBEM_E_NOT_FOUND;

    if(!(*pClass)) throw m_he;

    return hr;
};

HRESULT CRequestObject::CreateObjectEnum(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //Enumerate the objects
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_ENUM);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::PutObject(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    return WBEM_E_NOT_SUPPORTED;
}

HRESULT CRequestObject::ExecMethod(BSTR bstrPath, BSTR bstrMethod, IWbemClassObject *pInParams,
                   IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
//  WCHAR wcTmp[BUFF_SIZE];

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    //Initialize Eventing system
    if(!InitializeProgress(pHandler)) return WBEM_E_FAILED;

    if(ParsePath(bstrPath)){

        if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCT")){

            CProduct *pClass = new CProduct(this, m_pNamespace, pCtx);
            if(!pClass) throw m_he;

        //Static Methods
            if(0 == _wcsicmp(bstrMethod, L"ADMIN"))

                if(!IsInstance()){

                    try{

						if ( pInParams )
						{
	                        hr = pClass->Admin(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }

                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"ADVERTISE"))

                if(!IsInstance()){

                    try{

						if ( pInParams )
						{
	                        hr = pClass->Advertise(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }

                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"INSTALL"))

                if(!IsInstance()){

                    try{

						if ( pInParams )
						{
	                        hr = pClass->Install(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

        //Non-Static Methods
            else if(0 == _wcsicmp(bstrMethod, L"CONFIGURE"))

                if(IsInstance()){

                    try{

						if ( pInParams )
						{
							hr = pClass->Configure(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"REINSTALL"))

                if(IsInstance()){

                    try{

						if ( pInParams )
						{
							hr = pClass->Reinstall(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"UNINSTALL"))

                if(IsInstance()){

                    try{

						// doesn't matter as we do not expect pInParams
                        hr = pClass->Uninstall(this, pInParams, pHandler, pCtx);

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"UPGRADE"))

                if(IsInstance()){

                    try{

						if ( pInParams )
						{
							hr = pClass->Upgrade(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else hr = WBEM_E_NOT_SUPPORTED;

            pClass->CleanUp();
            delete pClass;
        
        }else if(0 == _wcsicmp(m_bstrClass, L"WIN32_SOFTWAREFEATURE")){

            CSoftwareFeature *pClass = new CSoftwareFeature(this, m_pNamespace, pCtx);
            if(!pClass) throw m_he;

            if(0 == _wcsicmp(bstrMethod, L"CONFIGURE"))

                if(IsInstance()){

                    try{

						if ( pInParams )
						{
							hr = pClass->Configure(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else if(0 == _wcsicmp(bstrMethod, L"REINSTALL"))

                if(IsInstance()){

                    try{

						if ( pInParams )
						{
							hr = pClass->Reinstall(this, pInParams, pHandler, pCtx);
						}
						else
						{
							hr = WBEM_E_INVALID_PARAMETER;
						}

                    }catch(...){

                        pClass->CleanUp();
                        delete pClass;
                        throw;
                    }
                
                }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            else hr = WBEM_E_NOT_SUPPORTED;

            pClass->CleanUp();
            delete pClass;

        }else hr = WBEM_E_NOT_SUPPORTED;

    }else
        return WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::DeleteObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
//  WCHAR wcTmp[BUFF_SIZE];

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    //Initialize Eventing system
    if(!InitializeProgress(pHandler)) return WBEM_E_FAILED;

    if(ParsePath(bstrPath)){

        if(0 == _wcsicmp(m_bstrClass, L"WIN32_PRODUCT")){

            CProduct *pClass = new CProduct(this, m_pNamespace, pCtx);
            if(!pClass) throw m_he;

            if(IsInstance()){

                try{

                    hr = pClass->Uninstall(this, NULL, pHandler, pCtx);

                }catch(...){

                    pClass->CleanUp();
                    delete pClass;
                    throw;
                }
            
            }else hr = WBEM_E_INVALID_METHOD_PARAMETERS;

            pClass->CleanUp();
            delete pClass;

        }else hr = WBEM_E_NOT_SUPPORTED;

    }else hr = WBEM_E_FAILED;

    return hr;
}

#ifdef _EXEC_QUERY_SUPPORT

HRESULT CRequestObject::ExecQuery(BSTR bstrQuery, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    if(ParseQuery(bstrQuery)){
    
        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //Enumerate the objects
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_QUERY);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }
    
    }else
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    return hr;
}

bool CRequestObject::ParseQuery(BSTR bstrQuery)
{
    LPWSTR wcTest = NULL;

	try
	{
		if ( ( wcTest = new WCHAR [ ::SysStringLen ( bstrQuery ) + 1 ] ) != NULL )
		{
			wcscpy ( wcTest, bstrQuery );
		}
		else
		{
			throw m_he;
		}
	}
	catch ( ... )
	{
		if ( wcTest )
		{
			delete [] wcTest;
			wcTest = NULL;
		}

		throw;
	}

    WCHAR *pwcTest = wcTest;
    WCHAR wcProp[BUFF_SIZE];
    WCHAR wcClass[BUFF_SIZE];
    WCHAR wcTmp[BUFF_SIZE];

	bool bResult = false;

    if ( ExpectedToken ( &pwcTest, L"SELECT" ) )
	{
		//Get the requested property list
		GetNextToken(&pwcTest, wcProp);
		if(*wcProp != L'*'){

			while(ExpectedToken(&pwcTest, L",")){
				//not doing anything here yet
				GetNextToken(&pwcTest, wcProp);
			}
		}

		if ( ExpectedToken ( &pwcTest, L"FROM" ) )
		{
			//Get the class name
			if ( GetNextToken ( &pwcTest, wcClass ) != NULL )
			{
				m_bstrClass = SysAllocString(wcClass);

				if ( !EOL ( &pwcTest ) )
				{
					if ( ExpectedToken ( &pwcTest, L"WHERE" ) )
					{
						m_iPropCount = -1;
						int iParens = 0;

						bool bContinue = true;

						//Get the "where" clause
						while ( bContinue && !EOL ( &pwcTest ) )
						{
							GetNextToken(&pwcTest, wcTmp);

							if(_wcsicmp(wcTmp, L"(") == 0){

								iParens++;

							}else if(_wcsicmp(wcTmp, L")") == 0){

								iParens--;

							}else if(!((_wcsicmp(wcTmp, L"or") == 0) || (_wcsicmp(wcTmp, L"and") == 0))){

								//if we have "or" or "and" skip over it... (treat all as or)

								if( m_iPropCount >= MSI_KEY_LIST_SIZE) {

									throw m_he;
								}

								m_Property[++m_iPropCount] = SysAllocString(wcTmp);

								//Syntax checking
								if ( ExpectedToken ( &pwcTest, L"=" ) )
								{
									if(wcscmp(GetNextToken(&pwcTest, wcTmp), L"\"") == 0){

										if( m_iPropCount >= MSI_KEY_LIST_SIZE) {
											throw m_he;
										}

										//Deal with quoted strings
										m_Value[m_iPropCount] = SysAllocString(GetStringValue(&pwcTest, wcTmp));

										if ( !ExpectedToken ( &pwcTest, L"\"" ) )
										{
											bContinue = false;
											bResult = false;
										}

									}else{

										if( m_iPropCount >= MSI_KEY_LIST_SIZE) {
												throw m_he;
										}
										m_Value[m_iPropCount] = SysAllocString(wcTmp);
									}

									m_iValCount++;
								}
								else
								{
									bContinue = false;
									bResult = false;
								}
							}
						}

						m_iPropCount++;

						if(iParens == 0)
						{
							bResult = true;
						}
					}
				}
				else
				{
					bResult = true;
				}
			}
		}
	}

	if ( wcTest )
	{
		delete [] wcTest;
		wcTest = NULL;
	}

    return bResult;
}

WCHAR * CRequestObject::GetStringValue(WCHAR **pwcString, WCHAR wcToken[])
{
    //eat white space
    while(**pwcString == L' '){ (*pwcString)++; }

    wcscpy(wcToken, *pwcString);
    WCHAR *pwcStart = wcToken;
    WCHAR *pwcToken = wcToken;
    WCHAR *pwcPrev;

    //deal with eol
    if(*pwcToken == NULL) return NULL;

    //deal with strings
    while((*pwcToken != NULL) && ((*pwcToken != L'\"') || (*pwcPrev == L'\\'))){
        
        if((*pwcToken == L'\"') && (*pwcPrev == L'\\')){

            WCHAR *pwcTmp = pwcPrev;

            while(*pwcPrev){

                *pwcPrev = *pwcToken;
                pwcPrev = (pwcToken++);
            }

            pwcToken = pwcTmp;
        }

        pwcPrev = (pwcToken++);
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

bool CRequestObject::ExpectedToken(WCHAR **pwcString, WCHAR *pwcExpected)
{
    WCHAR wcTmp[BUFF_SIZE];

    GetNextToken(pwcString, wcTmp);

    if(_wcsicmp(wcTmp, pwcExpected) == 0)   return true;
    else return false;
}

WCHAR *  CRequestObject::GetNextProperty(WCHAR **pwcString, WCHAR wcProp[])
{
    //eat white space
    while(**pwcString == L' '){ (*pwcString)++; }

    wcscpy(wcProp, *pwcString);
    WCHAR *pwcStart = wcProp;
    WCHAR *pwcToken = wcProp;

    //deal with strings
    while(*pwcToken != L'='){
        pwcToken++;
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

WCHAR *  CRequestObject::GetNextValue(WCHAR **pwcString, WCHAR wcVal[])
{
    wcscpy(wcVal, *pwcString);
    WCHAR *pwcStart = wcVal;
    WCHAR *pwcToken = wcVal;
    WCHAR *pwcPrev;

    //deal with strings
    while((*pwcToken != L' ') || ((*pwcToken != L'\"') || (*pwcPrev == L'\\'))){
        pwcPrev = (pwcToken++);
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

bool CRequestObject::EOL(WCHAR **pwcString)
{
    while(**pwcString == L' ') (*pwcString)++;

    if(wcscmp(*pwcString, L"") == 0)    return true;
    else return false;
}

WCHAR * CRequestObject::GetNextToken(WCHAR **pwcString, WCHAR wcToken[])
{
    //eat white space
    while(**pwcString == L' '){ (*pwcString)++; }

    wcscpy(wcToken, *pwcString);
    WCHAR *pwcStart = wcToken;
    WCHAR *pwcToken = wcToken;
    WCHAR *pwcPrev;

    //deal with special chars
    if((*pwcToken == L'(') || (*pwcToken == L')') || (*pwcToken == L',') || (*pwcToken == L'=') || (*pwcToken == L'"')){
        *(++pwcToken) = NULL;
        (*pwcString)++;
        return pwcStart;
    }

    //deal with eol
    if(*pwcToken == NULL) return NULL;

    //deal with strings
    while((*pwcToken != NULL) && (*pwcToken != L' ') && (*pwcToken != L',') &&
        (*pwcToken != L'=') && ((*pwcToken != L'\"') || (*pwcPrev == L'\\'))){
        
        pwcPrev = (pwcToken++);
        (*pwcString)++;
    }
    *pwcToken = NULL;

    return pwcStart;
}

#endif //_EXEC_QUERY_SUPPORT

bool CRequestObject::ParsePath(BSTR bstrPath)
{
    if(wcslen(bstrPath) < 1) return false;

    LPWSTR wcTest = NULL;

	try
	{
		if ( ( wcTest = new WCHAR [ ::SysStringLen ( bstrPath ) + 1 ] ) != NULL )
		{
			wcscpy ( wcTest, bstrPath );
		}
		else
		{
			throw m_he;
		}
	}
	catch ( ... )
	{
		if ( wcTest )
		{
			delete [] wcTest;
			wcTest = NULL;
		}

		throw;
	}

    WCHAR *pwcTest = NULL;
    WCHAR *pwcClassStart = wcTest;
    WCHAR *pwcNamespace = NULL;
    WCHAR *pwcStart = NULL;
    WCHAR *pwcStrip = NULL;
    WCHAR wcPrevious = NULL;
    int iNumQuotes = 0;
    bool bClass = false;
    bool bDoubles = false;

	try
	{
		//Main Parsing Loop
		for(pwcTest = wcTest; *pwcTest; pwcTest++){

			if((*pwcTest == L'\\') && !bClass){

				for(pwcNamespace = pwcTest; *pwcNamespace != L':'; pwcNamespace++){}
				pwcClassStart = pwcNamespace + 1;
				pwcTest = pwcNamespace;

			}else if(*pwcTest == L'.'){

				if(iNumQuotes == 0){

					// issolate the class name.
					*pwcTest = NULL;
					if(m_bstrClass){

						SysFreeString(m_bstrClass);
						m_bstrClass = NULL;
					}
					m_bstrClass = SysAllocString(pwcClassStart);
					if(!m_bstrClass) throw m_he;

					bClass = true;
					pwcStart = (pwcTest + 1);
				}

			}else if(*pwcTest == L'='){

				if(iNumQuotes == 0){

					if(!bClass){

						// issolate the class name.
						*pwcTest = NULL;
						if(m_bstrClass){

							SysFreeString(m_bstrClass);
							m_bstrClass = NULL;
						}
						m_bstrClass = SysAllocString(pwcClassStart);
						if(!m_bstrClass) throw m_he;

						bClass = true;
						pwcStart = (pwcTest + 1);
            
					}else{

						// issolate the property name.
						*pwcTest = NULL;
						if(pwcStart != NULL){

							if( m_iPropCount >= MSI_KEY_LIST_SIZE) {
								throw m_he;
							}

							m_Property[m_iPropCount] = SysAllocString(pwcStart);
							if(!m_Property[m_iPropCount++]) throw m_he;
							pwcStart = (pwcTest + 1);

						}else pwcStart = (pwcTest + 1);
					}
				}
			}else if(*pwcTest == L','){

				if(iNumQuotes != 1){

					// issolate the property value.
					*pwcTest = NULL;
					if(pwcStart != NULL){

						if( m_iValCount >= MSI_KEY_LIST_SIZE) {
							throw m_he;
						}

						m_Value[m_iValCount] = SysAllocString(pwcStart);
						if(!m_Value[m_iValCount++]) throw m_he;
						pwcStart = (pwcTest + 1);

					}else return false;
				}

			}else if(*pwcTest == L'\"'){

				if(wcPrevious != L'\\'){

					// deal with quotes in path.
					iNumQuotes++;
					if(iNumQuotes == 1) pwcStart = (pwcTest + 1);
					else if(iNumQuotes == 2){

						*pwcTest = NULL;
						iNumQuotes = 0;
					}

				}else if(iNumQuotes == 1){

					//deal with embedded quotes
					for(pwcStrip = (--pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

					*pwcStrip = NULL;
				}

			}else if((*pwcTest == L'\\') && (wcPrevious == L'\\') && bClass && !bDoubles){

				for(pwcStrip = (--pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

				*pwcStrip = NULL;
			}

	#ifdef _STRIP_ESCAPED_CHARS
			else if(*pwcTest == L'%'){

				//deal with escaped URL characters
				if(*(pwcTest + 1) == L'0'){

					if(*(pwcTest + 2) == L'7'){
						//bell
						*pwcTest = L'\\';
						*(++pwcTest) = L'a';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if(*(pwcTest + 2) == L'8'){
						//backspace
						*pwcTest = L'\\';
						*(++pwcTest) = L'b';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if(*(pwcTest + 2) == L'9'){
						//horizontal tab
						*pwcTest = L'\\';
						*(++pwcTest) = L't';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'A') || (*(pwcTest + 2) == L'a')){
						//newline
						*pwcTest = L'\\';
						*(++pwcTest) = L'n';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'B') || (*(pwcTest + 2) == L'b')){
						//vertical tab
						*pwcTest = L'\\';
						*(++pwcTest) = L'v';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'C') || (*(pwcTest + 2) == L'c')){
						//formfeed
						*pwcTest = L'\\';
						*(++pwcTest) = L'f';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else if((*(pwcTest + 2) == L'D') || (*(pwcTest + 2) == L'd')){
						//carriage return
						*pwcTest = L'\\';
						*(++pwcTest) = L'r';

						for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else return false;

				}else if(*(pwcTest + 1) == L'1'){

					return false;

				}else if(*(pwcTest + 1) == L'2'){

					if(*(pwcTest + 2) == L'0'){

						//space
						*pwcTest++ = L' ';

						for(int ip = 0; ip < 2; ip++)
							for(pwcStrip = (pwcTest); *pwcStrip; pwcStrip++)
								*pwcStrip = *(pwcStrip + 1);

						*pwcStrip = NULL;

					}else return false;
				}
			}
	#endif //_STRIP_ESCAPED_CHARS

			if((wcPrevious == *pwcTest) && !bDoubles) bDoubles = true;
			else bDoubles = false;

			wcPrevious = *pwcTest;
		}

		// if we still have values to add, do so now
		if(pwcStart != NULL){

			if( m_iValCount >= MSI_KEY_LIST_SIZE) {
				throw m_he;
			}

			m_Value[m_iValCount] = SysAllocString(pwcStart);
			if(!m_Value[m_iValCount++]) throw m_he;

		}else if((m_iPropCount < 1) && (m_iValCount < 1)){

			if(m_bstrClass){

				SysFreeString(m_bstrClass);
				m_bstrClass = NULL;
			}
			m_bstrClass = SysAllocString(pwcClassStart);
			if(!m_bstrClass) throw m_he;
		}

		if(iNumQuotes != 0) return false;

		if(m_iValCount != m_iPropCount){
			if(m_iValCount > m_iPropCount){ if(m_iValCount != 1) return false;  }
			else return false;
		}
	}
	catch ( ... )
	{
		if ( wcTest )
		{
			delete [] wcTest;
			wcTest = NULL;
		}

		throw;
	}

	if ( wcTest )
	{
		delete [] wcTest;
		wcTest = NULL;
	}

    if(!m_bstrClass) return false;

    return true;
}

HRESULT CRequestObject::InitializeList(bool bGetList)
{
    int i = 0;
    WCHAR wcGUIDBuf[39];
    UINT uiStatus;
    bool bHaveItems = false;
    PackageListNode *pLast = NULL;

    try
	{
        if(bGetList)
		{
            m_pPackageHead = new PackageListNode();
            if(!m_pPackageHead) throw m_he;

            PackageListNode *pPos = m_pPackageHead;

            try
			{
                if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
                    LoadHive();
                }

                while((uiStatus = g_fpMsiEnumProductsW(i++, wcGUIDBuf)) != ERROR_NO_MORE_ITEMS)
				{
                    if(uiStatus != S_OK)
					{
						throw ConvertError(uiStatus);
					}

                    bHaveItems = true;

					// ok ( products return string representation of GUID )
                    wcscpy(pPos->wcCode, wcGUIDBuf);
                    pLast = pPos;

                    pPos = pPos->pNext = new PackageListNode();
                    if(!pPos)
					{
						throw m_he;
					}
                }
            }
			catch(...)
			{
                //remove the key if it wasn't there b4....
                if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
                    UnloadHive();
                }

				if ( pPos != m_pPackageHead )
				{
					delete pPos;
					pPos = NULL;
				}

                throw;
            }

            //remove the key if it wasn't there b4....
            if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
                UnloadHive();
            }

            delete pPos;
			pPos = NULL;

            if( !bHaveItems )
			{
				m_pPackageHead = NULL;
				return WBEM_S_NO_MORE_DATA;
			}
			else
			{
				if(pLast)
				{
					pLast->pNext = NULL;
				}
				else
				{
					return WBEM_E_FAILED;
				}
			}
        }
		else
		{
			m_pPackageHead = NULL;
		}
    }
	catch(HRESULT e_hr)
	{
        if(pLast)
		{
			pLast->pNext = NULL;
		}

        return e_hr;
    }
	catch(...)
	{
        if(pLast)
		{
			pLast->pNext = NULL;
		}

        throw;
    }

    return WBEM_S_NO_ERROR;
}

bool CRequestObject::DestroyList()
{
    PackageListNode *pPos = m_pPackageHead;
    PackageListNode *pLast;

    while(pPos){

        pLast = pPos;
        pPos = pPos->pNext;
        delete pLast;
    }

    m_pPackageHead = NULL;

    return true;
}

WCHAR * CRequestObject::Package(int iPos)
{
    PackageListNode *pPos = m_pPackageHead;

    while(iPos-- > 0){

        if(!pPos) return NULL;

        pPos = pPos->pNext;
    }

    if(!pPos) return NULL;
    else return pPos->wcCode;
}

bool CRequestObject::Cleanup()
{
    //Let's destroy our list and clear up some space
    if(m_bstrClass != NULL) SysFreeString(m_bstrClass);
    if(m_bstrPath != NULL) SysFreeString(m_bstrPath);

    for(int i = 0; i < MSI_KEY_LIST_SIZE; i++){

        if(m_Property[i] != NULL) SysFreeString(m_Property[i]);
        if(m_Value[i] != NULL) SysFreeString(m_Value[i]);
    }

    DestroyList();

    if(m_iThreadID != THREAD_NO_PROGRESS){

        ProListNode * pNode = RemoveNode(m_iThreadID);
        delete pNode;
    }

    return true;
}

bool CRequestObject::IsInstance()
{
    if((m_iPropCount > 0) || (m_iValCount > 0)) return true;
    return false;
}

ProListNode * CRequestObject::InitializeProgress(IWbemObjectSink *pHandler)
{
	try
	{
		if(!m_pHead)
		{
			m_pHead = new ProListNode();
			if(!m_pHead) throw m_he;

			m_pHead->pNext = NULL;
			m_pHead->pSink = NULL;
			m_pHead->iThread = 0;
			m_pHead->wTotal = m_pHead->wComplete = 0;
			m_pHead->lTotal = m_pHead->lComplete = m_pHead->lActionData = 0;
		}
	}
	catch(...)
	{
		if ( m_pHead )
		{
			delete m_pHead;
			m_pHead = NULL;
		}

		throw;
	}

    ProListNode *pNode = new ProListNode;
    if(!pNode) throw m_he;

    pNode->pNext = NULL;
    pNode->wTotal = pNode->wComplete = 0;
    pNode->lTotal = pNode->lComplete = pNode->lActionData = 0;
    pNode->pSink = pHandler;

    try
	{
        m_iThreadID = InsertNode(pNode);
    }
	catch(...)
	{
        throw;
    }

    if(m_iThreadID == THREAD_NO_PROGRESS)
	{
    	delete pNode;
		pNode = NULL;
	}

    return pNode;
}

bool CRequestObject::ParseProgress(WCHAR *wcMessage, ProgressStruct *ps)
{
    WCHAR *wcp = wcMessage;
    WCHAR *wcpStart = wcMessage;
    WCHAR *wcpVal;

    while(*wcp){

        if(*wcp == L':'){

            *wcp++ = NULL;
            wcpVal = wcp;
            while(*wcp == ' ') wcp++;
            while(*wcp && (*wcp != ' ')) wcp++;
            *wcp = NULL;

            switch(_wtoi(wcpStart)){

            case 1:
                ps->field1 = _wtoi(wcpVal);
                break;

            case 2:
                ps->field2 = _wtoi(wcpVal);
                break;

            case 3:
                ps->field3 = _wtoi(wcpVal);
                break;

            case 4:
                ps->field4 = _wtoi(wcpVal);
                break;

            default:
                return false;
            }

            wcpStart = (wcp + 1);
        }

        wcp++;
    }
    
    return true;
}

bool CRequestObject::ActionDataProgress(HRESULT *hr, int iThread)
{
    ProListNode *pNode = GetNode(iThread);

	if ( pNode )
	{
		//add the actiondata increment
		if((pNode->lTotal != 0) && (pNode->lActionData != 0)){

			pNode->lComplete += pNode->lActionData;
			pNode->wComplete = (WORD)((10000 * pNode->lComplete) / pNode->lTotal);
		}

		*hr = (pNode->wTotal << 16) + pNode->wComplete; 
		return true;
	}
	else
	{
		*hr = WBEM_E_UNEXPECTED; 
		return false;
	}
}

bool CRequestObject::ActionStartProgress(HRESULT *hr, int iThread)
{
    ProListNode *pNode = GetNode(iThread);

	if ( pNode )
	{
		//reset the actiondata increment
		pNode->lActionData = 0;

		*hr = (pNode->wTotal << 16) + pNode->wComplete; 
		return true;
	}
	else
	{
		*hr = WBEM_E_UNEXPECTED; 
		return false;
	}
}

bool CRequestObject::CreateProgress(ProgressStruct *ps, HRESULT *hr, int iThread)
{
    bool bResult = true;
    ProListNode *pNode = GetNode(iThread);

    //parse the progress information we get from MSI
    if(ps){

        switch(ps->field1){

        //1:0 2:x 3:x 4:x
        case 0:
			if ( pNode )
			{
				pNode->wTotal = 10000;
				pNode->lTotal = ps->field2;
				pNode->wComplete = 0;
				pNode->lComplete = 0;
			}

            break;

        //1:1 2:x 3:x 4:x
        case 1:

            //1:1 2:x 3:1 4:x
            if(ps->field3 == 1)
			{
				if ( pNode )
				{
					pNode->lActionData = ps->field2;
				}
			}
            break;

        //1:2 2:x 3:x 4:x
        case 2:
			if ( pNode )
			{
				pNode->lComplete += ps->field2;
				if(pNode->lTotal != 0)
				{
					pNode->wComplete = (WORD)((10000 * pNode->lComplete)/pNode->lTotal);
				}
			}
            break;

        //1:3 2:x 3:x 4:x
        case 3:
			if ( pNode )
			{
				pNode->lTotal += ps->field2;
				if(pNode->lTotal != 0)
				{
					pNode->wComplete = (WORD)((10000 * pNode->lComplete)/pNode->lTotal);
				}
			}
            break;


        default:
            bResult = false;
            break;
        }
    }

	if ( pNode )
	{
		*hr = (pNode->wTotal << 16) + pNode->wComplete; 
	}
	else
	{
		*hr = WBEM_E_UNEXPECTED;
		bResult = false;
	}

    return bResult;
}

ProListNode * CRequestObject::GetNode(int iThread)
{
    //initial sanity code
    if(!m_pHead) return NULL;

    ProListNode *ptr = m_pHead;

    while( ptr && (ptr->pNext) && (ptr->iThread < iThread) )
	{
		ptr = ptr->pNext;
	}

    if( ptr && ptr->iThread == iThread )
	{
		return ptr;
	}
    else
	{
		return NULL;
	}
}

// Note - does not delete, simply removes from list
ProListNode * CRequestObject::RemoveNode(int iThread)
{
	ProListNode *ptr = m_pHead;
	if ( ptr != NULL )
	{
		while((ptr->pNext) && (ptr->pNext->iThread < iThread)) {ptr = ptr->pNext;}

		if(ptr->pNext){

			if(ptr->pNext->iThread == iThread){

			ProListNode *pTmp = ptr->pNext;
			ptr->pNext = ptr->pNext->pNext;
			return pTmp;

			}else return NULL;

		}else return NULL;
	}

	return NULL;
}

int CRequestObject::InsertNode(ProListNode *pNode)
{
    int iID = 0;
    ProListNode *ptr = m_pHead;

    while(ptr->pNext){
        if(ptr->iThread > iID){
            pNode->iThread = iID;
            
            //If it's already here, fail
            if((ptr->pNext) && (ptr->pNext->iThread == pNode->iThread)) return THREAD_NO_PROGRESS;

            pNode->pNext = ptr->pNext;
            ptr->pNext = pNode;

            return iID;
        }
        iID++;
    }
    pNode->iThread = ++iID;

    //If it's already here, fail
    if((ptr->pNext) && (ptr->pNext->iThread == pNode->iThread)) return THREAD_NO_PROGRESS;

    pNode->pNext = ptr->pNext;
    ptr->pNext = pNode;

    return iID;
}

DWORD CRequestObject::GetAccount(HANDLE TokenHandle, WCHAR *wcDomain, WCHAR *wcUser)
{
    DWORD dwStatus = S_OK;

    TOKEN_USER *tTokenUser = NULL;
    DWORD dwReturnLength = 0;
    TOKEN_INFORMATION_CLASS tTokenInformationClass = TokenUser;

    if(!GetTokenInformation(TokenHandle, tTokenInformationClass, NULL, 0, &dwReturnLength) &&
        GetLastError () == ERROR_INSUFFICIENT_BUFFER){

        tTokenUser = (TOKEN_USER*) new UCHAR[dwReturnLength];

        if(tTokenUser){

            try{

                if(GetTokenInformation(TokenHandle, tTokenInformationClass,
                    (void *)tTokenUser, dwReturnLength, &dwReturnLength)){

                    DWORD dwUserSize = BUFF_SIZE;
                    DWORD dwDomainSize = BUFF_SIZE;
                    SID_NAME_USE Use;

                    if(!LookupAccountSidW(NULL, tTokenUser->User.Sid, wcUser, &dwUserSize,
                        wcDomain, &dwDomainSize, &Use)){

                        dwStatus = GetLastError();
                    }

                }else dwStatus = GetLastError();


            }catch(...){

                delete [] (UCHAR *)tTokenUser;
                throw;
            }

            delete [] (UCHAR *)tTokenUser;

        }else{

            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }else dwStatus = GetLastError();

    return dwStatus ;
}

DWORD CRequestObject::GetSid(HANDLE TokenHandle, WCHAR *wcSID, DWORD dwSID)
{
    DWORD dwStatus = S_OK ;

    TOKEN_USER *tTokenUser = NULL ;
    DWORD dwReturnLength = 0 ;
    TOKEN_INFORMATION_CLASS tTokenInformationClass = TokenUser ;

    if(!GetTokenInformation(TokenHandle, tTokenInformationClass, NULL, 0, &dwReturnLength) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER){

        tTokenUser = (TOKEN_USER *) new UCHAR[dwReturnLength] ;
        
        if(tTokenUser){

            try{

                if(GetTokenInformation(TokenHandle, tTokenInformationClass, (void *)tTokenUser,
                    dwReturnLength, &dwReturnLength)){

                    // Initialize m_strSid - human readable form of our SID
                    SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority(tTokenUser->User.Sid);
                    
                    // We assume that only last byte is used (authorities between 0 and 15).
                    // Correct this if needed.
//                  ASSERT(psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3]
//                      == psia->Value[4] == 0);
                    DWORD dwTopAuthority = psia->Value[5];

                    LPWSTR bstrtTempSid = NULL;

					try
					{
						if ( ( bstrtTempSid = new WCHAR [ BUFF_SIZE ] ) == NULL )
						{
							throw m_he;
						}
					}
					catch ( ... )
					{
						if ( bstrtTempSid )
						{
							delete [] bstrtTempSid;
							bstrtTempSid = NULL;
						}

						throw;
					}

                    wcscpy(bstrtTempSid, L"S-1-");

                    WCHAR wstrAuth[32] = { L'\0' };
                    _itow(dwTopAuthority, wstrAuth, 10);

                    wcscat(bstrtTempSid, wstrAuth);
                    int iSubAuthorityCount = *(GetSidSubAuthorityCount(tTokenUser->User.Sid));

					DWORD dwTempSidCur = BUFF_SIZE;
					DWORD dwTempSid = 0L;
					dwTempSid = wcslen ( bstrtTempSid );

                    for(int i = 0; i < iSubAuthorityCount; i++){

                        DWORD dwSubAuthority = *(GetSidSubAuthority( tTokenUser->User.Sid, i ));

						wstrAuth[ 0 ] = L'\0';
                        _itow(dwSubAuthority, wstrAuth,10);

						DWORD dwAuth = 0L;
						dwAuth = wcslen ( wstrAuth );

						if ( dwTempSid + dwAuth + 1 + 1 < dwTempSidCur )
						{
							wcscat(bstrtTempSid, L"-");
							wcscat(bstrtTempSid, wstrAuth);

							dwTempSid = dwTempSid + dwAuth + 1;
						}
						else
						{
							LPWSTR wsz = NULL;

							try
							{
								if ( ( wsz = new WCHAR [ ( dwTempSid + dwAuth + 1 ) * 2 + 1 ] ) != NULL )
								{
									wcscpy ( wsz, bstrtTempSid );
									wcscat ( wsz, L"-" );
									wcscat ( wsz, wstrAuth );

									dwTempSid = wcslen ( wsz );
									dwTempSidCur = dwTempSid * 2;
								}
								else
								{
									throw m_he;
								}

								if ( bstrtTempSid )
								{
									delete [] bstrtTempSid;
									bstrtTempSid = NULL;
								}

								bstrtTempSid = wsz;
							}
							catch ( ... )
							{
								if ( wsz )
								{
									delete [] wsz;
									wsz = NULL;
								}

								if ( bstrtTempSid )
								{
									delete [] bstrtTempSid;
									bstrtTempSid = NULL;
								}

								throw;
							}
						}
                    }

					if ( wcslen ( bstrtTempSid ) + 1 < dwSID )
					{
                        wcscpy(wcSID, bstrtTempSid);
					}
					else
					{
						dwStatus = ERROR_OUTOFMEMORY;
					}

					if ( bstrtTempSid )
					{
						delete [] bstrtTempSid;
						bstrtTempSid = NULL;
					}

                }else dwStatus = GetLastError();

            }catch(...){

                delete [] (UCHAR *)tTokenUser;

                throw ;         
            }

            delete [] (UCHAR *)tTokenUser;

        }else throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    }else dwStatus = GetLastError();

    return dwStatus ;
}


DWORD CRequestObject::LoadHive(/*LPWSTR pszUserName, LPWSTR pszKeyName*/)
{
    DWORD i, dwSIDSize, dwDomainNameSize, dwSubAuthorities ;
	char SIDBuffer [ _MAX_PATH ];
    WCHAR szDomainName[_MAX_PATH], szSID[_MAX_PATH], szTemp[_MAX_PATH];
    SID *pSID = (SID *) SIDBuffer ;
    PSID_IDENTIFIER_AUTHORITY pSIA ;
    SID_NAME_USE AccountType ;
    CRegistry Reg;

	DWORD dwRetCode = ERROR_INVALID_PARAMETER;

    // Set the necessary privs
    //========================

	if ( ( dwRetCode = AcquirePrivilege() ) == ERROR_SUCCESS )
	{
		// Look up the user's account info
		//================================
		dwSIDSize = _MAX_PATH * sizeof ( char ) ;
		dwDomainNameSize = _MAX_PATH;

		BOOL bLookup = FALSE;
		bLookup = LookupAccountNameW	(	NULL,
											m_wcAccount,
											pSID,
											&dwSIDSize, 
											szDomainName,
											&dwDomainNameSize,
											&AccountType
										);

		if(bLookup)
		{
			// Translate the SID into text (a la PSS article Q131320)
			//=======================================================

			pSIA = GetSidIdentifierAuthority(pSID) ;
			dwSubAuthorities = *GetSidSubAuthorityCount(pSID) ;
			dwSIDSize = swprintf(szSID, _T("S-%lu-"), (DWORD) SID_REVISION) ;

			if((pSIA->Value[0] != 0) || (pSIA->Value[1] != 0)){

				dwSIDSize += swprintf(szSID + wcslen(szSID), L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
									 (USHORT) pSIA->Value[0],
									 (USHORT) pSIA->Value[1],
									 (USHORT) pSIA->Value[2],
									 (USHORT) pSIA->Value[3],
									 (USHORT) pSIA->Value[4],
									 (USHORT) pSIA->Value[5]) ;
			}else{

				dwSIDSize += swprintf(szSID + wcslen(szSID), L"%lu",
									 (ULONG)(pSIA->Value[5]      ) +
									 (ULONG)(pSIA->Value[4] <<  8) +
									 (ULONG)(pSIA->Value[3] << 16) +
									 (ULONG)(pSIA->Value[2] << 24));
			}

			for(i = 0 ; i < dwSubAuthorities && dwRetCode == ERROR_SUCCESS; i++)
			{
				if ( dwSIDSize > _MAX_PATH * sizeof ( char ) )
				{
					dwRetCode = ERROR_INSUFFICIENT_BUFFER;
				}
				else
				{
					try
					{
						dwSIDSize += swprintf(szSID + dwSIDSize, L"-%lu", *GetSidSubAuthority(pSID, i)) ;
					}
					catch ( ... )
					{
						dwRetCode = ERROR_INVALID_PARAMETER;
					}
				}
			}

			if ( dwRetCode == ERROR_SUCCESS )
			{
				// See if the key already exists
				//==============================
				dwRetCode = Reg.Open(HKEY_USERS, szSID, KEY_READ) ;

				// We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
				// Reg.vClose();

				if(dwRetCode != ERROR_SUCCESS)
				{
    				// Try to locate user's registry hive
					//===================================

					swprintf(szTemp, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", szSID) ;
					dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ);

					if(dwRetCode == ERROR_SUCCESS)
					{
						CHString chsTemp;

						dwRetCode = Reg.GetCurrentKeyValue ( L"ProfileImagePath", chsTemp );
						Reg.Close();

						if(dwRetCode == ERROR_SUCCESS)
						{
            				// NT 4 doesn't include the file name in the registry
							//===================================================

							if(!IsLessThan4())
							{
                				chsTemp += L"\\NTUSER.DAT";
							}

							ExpandEnvironmentStrings ( (LPCTSTR) chsTemp, szTemp, _MAX_PATH ) ;

							// Try it three times, another process may have the file open
							bool bTryTryAgain = false;
							int  nTries = 0;

							do{
								// need to serialize access, using "write" because RegLoadKey wants exclusive access
								// even though it is a read operation

								try
								{
									EnterCriticalSection(&m_cs);
								}
								catch ( ... )
								{
									throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
								}

								try
								{
									dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, szSID, szTemp) ;
								}
								catch(...)
								{
									SafeLeaveCriticalSection(&m_cs);
									throw;
								}

								SafeLeaveCriticalSection(&m_cs);
        
								if((dwRetCode == ERROR_SHARING_VIOLATION) && (++nTries < 11))
								{
                    				Sleep(20 * nTries); 
									bTryTryAgain = true;
								}
								else
								{
									bTryTryAgain = false;
								}
            
							}while (bTryTryAgain);
						}
					}
				}
			}

			if(dwRetCode == ERROR_SUCCESS)
			{
				DWORD dwLen = 0L;
				dwLen = wcslen ( szSID );

				if ( dwLen < 1024 )
				{
    				wcscpy(m_wcKeyName, szSID) ;

					WCHAR wcKey[BUFF_SIZE];

					if ( dwLen + wcslen(L"\\Software") < BUFF_SIZE )
					{
						wcscpy(wcKey, szSID);
						wcscat(wcKey, L"\\Software");

						LONG lRetVal = 0L;
						lRetVal = RegOpenKeyExW(HKEY_USERS, wcKey, 0, KEY_QUERY_VALUE, &m_hKey);

						if ( lRetVal != ERROR_SUCCESS )
						{
							dwRetCode = lRetVal;
						}
					}
					else
					{
						dwRetCode = ERROR_OUTOFMEMORY ;
					}
				}
				else
				{
					dwRetCode = ERROR_OUTOFMEMORY ;
				}
			}
		}
		else
		{
			dwRetCode = ERROR_BAD_USERNAME ;
		}

		// Restore original privilege level
		//=================================
		RestorePrivilege() ;
	}
	

    return dwRetCode ;    
}

DWORD CRequestObject::UnloadHive(/*LPCWSTR pszKeyName*/) 
{
    DWORD dwRetCode = ( DWORD ) E_FAIL;
    
    if(m_hKey != NULL){

        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

	if ( ( dwRetCode = AcquirePrivilege() ) == ERROR_SUCCESS )
	{
		try
		{
			EnterCriticalSection(&m_cs);
		}
		catch ( ... )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		try
		{
			dwRetCode = RegUnLoadKey(HKEY_USERS, m_wcKeyName);
		}
		catch(...)
		{
			SafeLeaveCriticalSection(&m_cs);
			throw;
		}

		SafeLeaveCriticalSection(&m_cs);
		RestorePrivilege() ;
	}

	DWORD dwRetCodeHelp = ERROR_SUCCESS;
	if ( FAILED ( dwRetCodeHelp = ( DWORD ) CoImpersonateClient() ) && SUCCEEDED ( dwRetCode ) )
	{
		// return failure in the case ofimpersonation failed
		dwRetCode = dwRetCodeHelp;
	}

    return dwRetCode ;
}

DWORD CRequestObject::AcquirePrivilege() 
{
    BOOL bRetCode = FALSE;
    HANDLE hToken = INVALID_HANDLE_VALUE ;
    TOKEN_PRIVILEGES TPriv ;
    LUID LUID ;

    // Validate the platform
    //======================

    // Try getting the thread token.  If it fails the first time it's 
    // because we're a system thread and we don't yet have a thread 
    // token, so just impersonate self and try again.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken))
	{

        try{

            GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &m_dwSize);

            if (m_dwSize > 0){

                // This is cleaned in the destructor, so no try/catch required
                m_pOriginalPriv = (TOKEN_PRIVILEGES*) new BYTE[m_dwSize];

                if (m_pOriginalPriv == NULL){

                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }

            if(m_pOriginalPriv && GetTokenInformation(hToken, TokenPrivileges, m_pOriginalPriv, m_dwSize, &m_dwSize)){ 

                bRetCode = LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &LUID);

                if(bRetCode){

                    TPriv.PrivilegeCount = 1 ;
                    TPriv.Privileges[0].Luid = LUID ;
                    TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv,
                        sizeof(TOKEN_PRIVILEGES), NULL, NULL);
                }
                bRetCode = LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &LUID);

                if(bRetCode){

                    TPriv.PrivilegeCount = 1 ;
                    TPriv.Privileges[0].Luid = LUID ;
                    TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv,
                        sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
                }
            }

        }catch(...){

            CloseHandle(hToken);
            throw ;
        }

        CloseHandle(hToken);
    }

    if(!bRetCode){
        
        return GetLastError();
    }

    return ERROR_SUCCESS ;    
}

void CRequestObject::RestorePrivilege() 
{
    if (m_pOriginalPriv != NULL){

        HANDLE hToken;

        try{
            if(OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                TRUE, &hToken)){

                AdjustTokenPrivileges(hToken, FALSE, m_pOriginalPriv, m_dwSize, NULL, NULL);
                CloseHandle(hToken) ;
            }

        }catch(...){

            delete m_pOriginalPriv;
            m_pOriginalPriv = NULL;
            m_dwSize = 0;

            throw;
        }

        delete m_pOriginalPriv;
        m_pOriginalPriv = NULL;
        m_dwSize = 0;
    }
}

//Properties
/////////////////////
const char * pAccesses = "Accesses";
const char * pAction = "Action";
const char * pActionID = "ActionID";
const char * pAntecedent = "Antecedent";
const char * pAppData = "AppData";
const char * pAppID = "AppID";
const char * pArgument = "Argument";
const char * pArguments = "Arguments";
const char * pAttribute = "Attribute";
const char * pAttributes = "Attributes";
const char * pCaption = "Caption";
const char * pCabinet = "Cabinet";
const char * pCheck = "Check";
const char * pCheckID = "CheckID";
const char * pCLSID = "CLSID";
const char * pCommand = "Command";
const char * pCommandLine = "CommandLine";
const char * pComponent = "Component";
const char * pComponentID = "ComponentID";
const char * pCondition = "Condition";
const char * pContext = "Context";
const char * pContentType = "ContentType";
const char * pCost = "Cost";
const char * pCreationClassName = "CreationClassName";
const char * pDataSource = "DataSource";
const char * pDefaultDir = "DefaultDir";
const char * pDefInprocHandler = "DefInprocHandler";
const char * pDependencies = "Dependencies";
const char * pDependent = "Dependent";
const char * pDescription = "Description";
const char * pDestination = "Destination";
const char * pDestFolder = "DestFolder";
const char * pDestName = "DestName";
const char * pDirectory = "Directory";
const char * pDirectoryName = "DirectoryName";
const char * pDirectoryPath = "DirectoryPath";
const char * pDirProperty = "DirProperty";
const char * pDiskID = "DiskID";
const char * pDiskPrompt = "DiskPrompt";
const char * pDisplay = "Display";
const char * pDisplayName = "DisplayName";
const char * pDomain = "Domain";
const char * pDriver = "Driver";
const char * pDriverDescription = "DriverDescription";
const char * pElement = "Element";
const char * pEntryName = "EntryName";
const char * pEntryValue = "EntryValue";
const char * pEnvironment = "Environment";
const char * pError = "Error";
const char * pErrorControl = "ErrorControl";
const char * pEvent = "Event";
const char * pExpression = "Expression";
const char * pExpressionType = "ExpressionType";
const char * pExtension = "Extension";
const char * pFeature = "Feature";
const char * pFeatures = "Features";
const char * pField = "Field";
const char * pFile = "File";
const char * pFileKey = "FileKey";
const char * pFileName = "FileName";
const char * pFileSize = "FileSize";
const char * pFileTypeMask = "FileTypeMask";
const char * pFontTitle = "FontTitle";
const char * pGroupComponent = "GroupComponent";
const char * pHotKey = "HotKey";
const char * pID = "ID";
const char * pIdentificationCode = "IdentificationCode";
const char * pIdentifyingNumber = "IdentifyingNumber";
const char * pIniFile = "IniFile";
const char * pInsertable = "Insertable";
const char * pInstallDate = "InstallDate";
const char * pInstallDate2 = "InstallDate2";
const char * pInstallLocation = "InstallLocation";
const char * pInstallMode = "InstallMode";
const char * pInstallState = "InstallState";
const char * pKey = "Key";
const char * pLanguage = "Language";
const char * pLastSequence = "LastSequence";
const char * pLastUse = "LastUse";
const char * pLevel = "Level";
const char * pLibID = "LibID";
const char * pLoadOrderGroup = "LoadOrderGroup";
const char * pLocation = "Location";
const char * pManufacturer = "Manufacturer";
const char * pMaxDate = "MaxDate";
const char * pMaxSize = "MaxSize";
const char * pMaxVersion = "MaxVersion";
const char * pMessage = "Message";
const char * pMIME = "MIME";
const char * pMinDate = "MinDate";
const char * pMinSize = "MinSize";
const char * pMinVersion = "MinVersion";
const char * pName = "Name";
const char * pNext = "Next";
const char * pOperator = "Operator";
const char * pOptions = "Options";
const char * pPackageCache = "PackageCache";
const char * pParent = "Parent";
const char * pPartComponent = "PartComponent";
const char * pPassword = "Password";
const char * pPatch = "Patch";
const char * pPatchID = "PatchID";
const char * pPatchSize = "PatchSize";
const char * pPath = "Path";
const char * pPermission = "Permission";
const char * pPrior = "Prior";
const char * pProduct = "Product";
const char * pProductCode = "ProductCode";
const char * pProductName = "ProductName";
const char * pProductVersion = "ProductVersion";
const char * pProgID = "ProgID";
const char * pProperty = "Property";
const char * pQual = "Qual";
const char * pRegistration = "Registration";
const char * pRegistry = "Registry";
const char * pRemoteName = "RemoteName";
const char * pReserveKey = "ReserveKey";
const char * pReserveLocal = "ReserveLocal";
const char * pReserveSource = "ReserveSource";
const char * pResource = "Resource";
const char * pRoot = "Root";
const char * pSection = "Section";
const char * pSequence = "Sequence";
const char * pServiceType = "ServiceType";
const char * pSetting = "Setting";
const char * pSetupFile = "SetupFile";
const char * pShellNew = "ShellNew";
const char * pShellNewValue = "ShellNewValue";
const char * pSignature = "Signature";
const char * pShortcut = "Shortcut";
const char * pShowCmd = "ShowCmd";
const char * pSoftware = "Software";
const char * pSoftwareElementID = "SoftwareElementID";
const char * pSoftwareElementState = "SoftwareElementState";
const char * pSource = "Source";
const char * pSourceFolder = "SourceFolder";
const char * pSourceName = "SourceName";
const char * pStartMode = "StartMode";
const char * pStartName = "StartName";
const char * pStartType = "StartType";
const char * pStatus = "Status";
const char * pSystem = "System";
const char * pSystemCreationClassName = "SystemCreationClassName";
const char * pSystemName = "SystemName";
const char * pTable = "Table";
const char * pTarget = "Target";
const char * pTargetOperatingSystem = "TargetOperatingSystem";
const char * pTranslator = "Translator";
const char * pType = "Type";
const char * pUpgradeCode = "UpgradeCode";
const char * pUser = "User";
const char * pValue = "Value";
const char * pVendor = "Vendor";
const char * pVerb = "Verb";
const char * pVersion = "Version";
const char * pVolumeLabel = "VolumeLabel";
const char * pWait = "Wait";
const char * pWkDir = "WkDir";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\servicecontrol.cpp ===
// ServiceControl.cpp: implementation of the CServiceControl class.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ServiceControl.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceControl::CServiceControl(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CServiceControl::~CServiceControl()
{

}

HRESULT CServiceControl::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    MSIHANDLE hView = NULL, hRecord = NULL;
    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcTestCode[39];
    bool bGotName = false;
    WCHAR wcName[BUFF_SIZE];

    //These will change from class to class
    bool bID, bProductCode;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ProductCode" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) == 38 )
				{
		            //Get the product code we're looking for
					wcscpy(wcTestCode, m_pRequest->m_Value[iPos]);
					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrCompare = SysAllocString ( L"ID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the name we're looking for
					wcscpy(wcName, m_pRequest->m_Value[iPos]);
					bGotName = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ServiceControl`, `Name`, `Event`, `Arguments`, `Wait` from ServiceControl" );

    //optimize for GetObject
    if ( bGotName )
	{
		wcQuery.Append ( 3, L" where `ServiceControl`=\'", wcName, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceControl", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutKeyProperty(m_pObj, pID, Buffer, &bID, m_pRequest);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProductCode, m_pRequest);
                    //====================================================

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pName );

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pEvent, wcBuf);

                        dwBufSize = BUFF_SIZE;
						PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pArguments );

                        PutProperty(m_pObj, pWait, g_fpMsiRecordGetInteger(hRecord, 5));
                    //----------------------------------------------------

                        if(bID && bProductCode) bMatch = true;

                        if((atAction != ACTIONTYPE_GET) || bMatch){

                            hr = pHandler->Indicate(1, &m_pObj);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				if (hRecord)
				g_fpMsiCloseHandle(hRecord);

				if (hView)
				{
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);
				}

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

				throw;
			}

			if (hRecord)
			g_fpMsiCloseHandle(hRecord);

			if (hView)
			{
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);
			}

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecification.h ===
// ServiceSpecification.h: interface for the CServiceSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICESPECIFICATION_H__72CDD5DB_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_SERVICESPECIFICATION_H__72CDD5DB_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CServiceSpecification : public CGenericClass  
{
public:
	CServiceSpecification(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CServiceSpecification();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SERVICESPECIFICATION_H__72CDD5DB_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecificationservice.cpp ===
// ServiceSpecificationService.cpp: implementation of the CServiceSpecificationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ServiceSpecificationService.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceSpecificationService::CServiceSpecificationService(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CServiceSpecificationService::~CServiceSpecificationService()
{

}

HRESULT CServiceSpecificationService::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bService, bCheck;
    IWbemClassObject *pObj = NULL;
    VARIANT v;

    VariantInit(&v);

	CStringExt wcKey;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `ServiceInstall`, `Component_`, `Name` from ServiceInstall");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceInstall", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

					// safe operation

                    wcKey.Copy ( L"Win32_ServiceSpecification.CheckID=\"" );

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

					wcKey.Append ( 3, Buffer, wcProductCode, L"\"" );
					PutKeyProperty(m_pObj, pCheck, wcKey, &bCheck, m_pRequest);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                //====================================================

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
					{
						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        wcKey.Copy ( L"Win32_Service.Name=\"" );
                        wcKey.Append ( 2, Buffer, L"\"" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						BSTR bstrObj;
						if ( ( bstrObj = ::SysAllocString ( wcKey ) ) == NULL )
						{
							throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
						}

                        if SUCCEEDED ( hr = m_pNamespace->GetObject ( bstrObj, 0, m_pCtx, &pObj, NULL ) )
						{
                            PutKeyProperty ( m_pObj, pElement, wcKey, &bService, m_pRequest );
                            pObj->Release();
							pObj = NULL;

                        //----------------------------------------------------

                            if(bService && bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

						::SysFreeString ( bstrObj );
                    }
					else
					{
						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}
					}
                    
                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecification.cpp ===
// ServiceSpecification.cpp: implementation of the CServiceSpecification class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ServiceSpecification.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServiceSpecification::CServiceSpecification(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CServiceSpecification::~CServiceSpecification()
{

}

HRESULT CServiceSpecification::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcServiceInstall[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bDiskID;
    
    SetSinglePropertyPath(L"CheckID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcServiceInstall);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `ServiceInstall`, `Component_`, `Name`, `DisplayName`, `ServiceType`, `StartType`, `ErrorControl`, `LoadOrderGroup`, `Dependencies`, `StartName`, `Password` from ServiceInstall" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `ServiceInstall`=\'", wcServiceInstall, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceInstall", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pID, Buffer);
						PutKeyProperty ( m_pObj, pCheckID, Buffer, &bDiskID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 3, pDisplayName, pCaption, pDescription );

                            PutProperty(m_pObj, pServiceType, g_fpMsiRecordGetInteger(hRecord, 5));

                            PutProperty(m_pObj, pStartType, g_fpMsiRecordGetInteger(hRecord, 6));
                            
                            PutProperty(m_pObj, pErrorControl, g_fpMsiRecordGetInteger(hRecord, 7));
                            
                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 8, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pLoadOrderGroup );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 9, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pDependencies );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 10, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pStartName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 11, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pPassword );

                        //----------------------------------------------------

                            if(bDiskID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\servicespecificationservice.h ===
// ServiceSpecificationService.h: interface for the CServiceSpecificationService class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICESPECIFICATIONSERVICE_H__7387F6D5_33AE_11D2_BFB1_00A0C9954921__INCLUDED_)
#define AFX_SERVICESPECIFICATIONSERVICE_H__7387F6D5_33AE_11D2_BFB1_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CServiceSpecificationService : public CGenericClass  
{
public:
	CServiceSpecificationService(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CServiceSpecificationService();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SERVICESPECIFICATIONSERVICE_H__7387F6D5_33AE_11D2_BFB1_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutaction.cpp ===
// ShortcutAction.cpp: implementation of the CShortcutAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ShortcutAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CShortcutAction::CShortcutAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CShortcutAction::~CShortcutAction()
{

}

HRESULT CShortcutAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_`, `Name`, `Target`, `Arguments`, `Description`, `Hotkey`, `ShowCmd`, `WkDir` from Shortcut" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Shortcut`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pShortcut, Buffer);
						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        //====================================================

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pName );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pTarget );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pArguments );

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 6, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 2, pCaption, pDescription );

                            PutProperty(m_pObj, pHotKey, g_fpMsiRecordGetInteger(hRecord, 7));

                            PutProperty(m_pObj, pShowCmd, g_fpMsiRecordGetInteger(hRecord, 8));

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 9, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pWkDir );

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutaction.h ===
// ShortcutAction.h: interface for the CShortcutAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SHORTCUTACTION_H__75F6BA26_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SHORTCUTACTION_H__75F6BA26_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CShortcutAction : public CGenericClass  
{
public:
	CShortcutAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CShortcutAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SHORTCUTACTION_H__75F6BA26_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutsap.h ===
// ShortcutSAP.h: interface for the CShortcutSAP class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SHORTCUTSAP_H__F4A87822_E037_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SHORTCUTSAP_H__F4A87822_E037_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CShortcutSAP : public CGenericClass  
{
public:
	CShortcutSAP(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CShortcutSAP();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SHORTCUTSAP_H__F4A87822_E037_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\shortcutsap.cpp ===
// ShortcutSAP.cpp: implementation of the CShortcutSAP class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ShortcutSAP.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CShortcutSAP::CShortcutSAP(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CShortcutSAP::~CShortcutSAP()
{

}

HRESULT CShortcutSAP::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcCommand[BUFF_SIZE];
    WCHAR wcProductCode[39];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    WCHAR wcShortcut[BUFF_SIZE];
    WCHAR wcTestCode[39];
    bool bShortcut = false;
    CRequestObject *pActionData = NULL;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int j;
        //GetObject optimizations
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        for(j = 0; j < m_pRequest->m_iPropCount; j++){
            
            if(_wcsicmp(m_pRequest->m_Property[j], L"Action") == 0){

                pActionData = new CRequestObject();
                if(!pActionData) throw he;

                pActionData->Initialize(m_pNamespace);

                pActionData->ParsePath(m_pRequest->m_Value[j]);
                break;
            }
        }

        if(pActionData){

            for(j = 0; j < pActionData->m_iPropCount; j++){
            
                if(_wcsicmp(pActionData->m_Property[j], L"ActionID") == 0){

					if ( ::SysStringLen ( pActionData->m_Value[j] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[j]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[j], wcShortcut);

						bShortcut = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }

            pActionData->Cleanup();
            delete pActionData;
            pActionData = NULL;
        }

    }

    //These will change from class to class
    bool bDriver, bAttribute;

    CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_` from Shortcut" );

    //optimize for GetObject
    if ( bShortcut )
	{
		wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
                (bShortcut && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							// safe operation
                            wcProp.Copy ( L"Win32_ShortcutAction.ActionID=\"" );
							wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							PutKeyProperty(m_pObj, pAction, wcProp, &bDriver, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

							// make query on fly
							wcQuery1.Append ( 2, Buffer, L"\'" );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            CheckMSI(g_fpMsiDatabaseOpenViewW( msidata.GetDatabase (), wcQuery1, &hSEView));
                            CheckMSI(g_fpMsiViewExecute(hSEView, 0));

                            try{

                                uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                                if(uiStatus != ERROR_NO_MORE_ITEMS){

                                    dwBufSize = BUFF_SIZE;
									GetBufferToPut ( hSERecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                    if ( ValidateComponentID ( Buffer, wcProductCode ) )
									{
										if ( dynBuffer && dynBuffer [ 0 ] != 0 )
										{
											dynBuffer [ 0 ] = 0;
										}
										
										INSTALLSTATE piInstalled;

                                        dwBufSize = BUFF_SIZE;
                                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf, wcCommand, &dwBufSize);
                                        
                                        if ( ( wcscmp(wcCommand, L"") != 0 ) &&
											 (piInstalled != INSTALLSTATE_UNKNOWN) &&
											 (piInstalled != INSTALLSTATE_ABSENT) )
										{
											if ( wcCommand [ dwBufSize-1 ] == L'\\' )
											{
												wcCommand [ dwBufSize-1 ] = L'\0';
											}

											wcBuf [ 0 ] = L'\0';
											EscapeStringW ( wcCommand, wcBuf );

											if ( wcBuf [ 0 ] != L'\0' )
											{
												// safe operation
												wcProp.Copy ( L"Win32_CommandLineAccess.Name=\"" );
												wcProp.Append ( 2, wcBuf, L"\"" );

												PutKeyProperty(m_pObj, pElement, wcProp, &bAttribute, m_pRequest);

												if(bDriver && bAttribute)
												{
													bMatch = true;
												}

												if((atAction != ACTIONTYPE_GET)  || bMatch)
												{
													hr = pHandler->Indicate(1, &m_pObj);
												}
											}
                                        }
                                    }
									else
									{
										if ( dynBuffer && dynBuffer [ 0 ] != 0 )
										{
											dynBuffer [ 0 ] = 0;
										}
									}
                                }

                            }catch(...){

                                g_fpMsiViewClose(hSEView);
                                g_fpMsiCloseHandle(hSEView);
                                g_fpMsiCloseHandle(hSERecord);
                                throw;
                            }

                            g_fpMsiViewClose(hSEView);
                            g_fpMsiCloseHandle(hSEView);
                            g_fpMsiCloseHandle(hSERecord);
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelement.h ===
// SoftwareElement.h: interface for the CSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENT_H__CFD828E4_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENT_H__CFD828E4_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareElement : public CGenericClass  
{
public:
	CSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElement();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREELEMENT_H__CFD828E4_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelement.cpp ===
// SoftwareElement.cpp: implementation of the CSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElement.h"

#include <CRegCls.h>

#include <WBEMTime.h>

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElement::CSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElement::~CSoftwareElement()
{

}

HRESULT CSoftwareElement::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    int iState;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcID[BUFF_SIZE];
    WCHAR wcName[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bName, bSEID, bSES, bTOS, bVersion;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component`, `ComponentId`, `Attributes` from Component" );

    INSTALLSTATE piInstalled;

	bool bGotID = false;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"Name" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				bGotID = true;
				wcQuery.Append ( 3, L" where `Component`=\'", m_pRequest->m_Value[iPos], L"\'" );
			}
			else
			{
				int iPos = -1;

				::SysFreeString ( bstrCompare );
				bstrCompare = SysAllocString ( L"SoftwareElementID" );

				if ( bstrCompare )
				{
					if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
					{
						bGotID = true;
						wcQuery.Append ( 3, L" where `ComponentId`=\'", m_pRequest->m_Value[iPos], L"\'" );
					}

					SysFreeString ( bstrCompare );
				}
				else
				{
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if(m_pRequest->m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
                m_pRequest->LoadHive();
            }
        
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Component", FALSE, TRUE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED))
				{
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj)))
					{
						throw hr;
					}

                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                    PutKeyProperty(m_pObj, pName, Buffer, &bName, m_pRequest);

                    PutProperty(m_pObj, pCaption, Buffer);
                    PutProperty(m_pObj, pDescription, Buffer);

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                    wcscpy(wcName, wcBuf);

                    //Check that this component exists on this system
                    if(ValidateComponentID(wcBuf, wcProductCode))
					{
                        wcscpy(wcID, wcBuf);
                        PutKeyProperty(m_pObj, pSoftwareElementID, wcID, &bSEID, m_pRequest);
                        PutProperty(m_pObj, pIdentificationCode, wcID);

                        dwBufSize = BUFF_SIZE;
                        wcscpy(wcBuf, L"");
                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcID, wcBuf, &dwBufSize);
                        PutProperty(m_pObj, pPath, wcBuf);

                        SoftwareElementState(piInstalled, &iState);
                        PutKeyProperty(m_pObj, pSoftwareElementState, iState, &bSES, m_pRequest);

                        PutProperty(m_pObj, pInstallState, (int)piInstalled);

                        PutKeyProperty(m_pObj, pTargetOperatingSystem, GetOS(), &bTOS, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);

                        PutProperty(m_pObj, pAttributes, g_fpMsiRecordGetInteger(hRecord, 3));

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"Manufacturer", wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pManufacturer, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_INSTALLDATE, wcBuf, &dwBufSize))
						{
							if ( ( lstrlenW ( wcBuf ) + lstrlenW ( L"000000.000000+000" ) + 1 ) < BUFF_SIZE )
							{
								lstrcatW ( wcBuf, L"000000.000000+000" );

								BSTR	bstrWbemTime;
								if ( ( bstrWbemTime	= ::SysAllocString ( wcBuf ) ) != NULL )
								{
									WBEMTime	time ( bstrWbemTime );
									::SysFreeString ( bstrWbemTime );

									if ( time.IsOk () )
									{
										bstrWbemTime= time.GetDMTF ( );

										try
										{
											PutProperty( m_pObj, pInstallDate, bstrWbemTime );
										}
										catch ( ... )
										{
											::SysFreeString ( bstrWbemTime );
											throw;
										}

										::SysFreeString ( bstrWbemTime );
									}
									else
									{
										hr = E_INVALIDARG;
									}
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								hr = E_FAIL;
							}
						}

                        if(bName && bSEID && bSES && bTOS && bVersion)
						{
							bMatch = true;
						}

                        if((atAction != ACTIONTYPE_GET)  || bMatch)
						{
                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            //remove the key if it wasn't there b4....
            if(m_pRequest->m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
                m_pRequest->UnloadHive();
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseProduct ();

            if(m_pObj)
			{
                m_pObj->Release();
                m_pObj = NULL;
            }

            throw;
        }

        //remove the key if it wasn't there b4....
        if(m_pRequest->m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
		{
            m_pRequest->UnloadHive();
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseProduct ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementaction.cpp ===
// SoftwareElementAction.cpp: implementation of the CSoftwareElementAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementAction::CSoftwareElementAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementAction::~CSoftwareElementAction()
{

}

HRESULT CSoftwareElementAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_E_FAILED;
    CRequestObject *pActionRObj = NULL;
    CRequestObject *pElementRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(int i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"ACTION") == 0){

                    pActionRObj = new CRequestObject();
                    if(!pActionRObj) throw he;

                    pActionRObj->Initialize(m_pNamespace);

                    pActionRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }

                if(_wcsicmp(m_pRequest->m_Property[i], L"Element") == 0){

                    pElementRObj = new CRequestObject();
                    if(!pElementRObj) throw he;

                    pElementRObj->Initialize(m_pNamespace);

                    pElementRObj->ParsePath(m_pRequest->m_Value[i]);
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ClassInfoAction") == 0)))
            if(FAILED(hr = SoftwareElementClass(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_CreateFolderAction") == 0)))
            if(FAILED(hr = SoftwareElementCreateFolder(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_DuplicateFileAction") == 0)))
            if(FAILED(hr = SoftwareElementDuplicateFile(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ExtensionInfoAction") == 0)))
            if(FAILED(hr = SoftwareElementExtension(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_MoveFileAction") == 0)))
            if(FAILED(hr = SoftwareElementMoveFile(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RemoveFileAction") == 0)))
            if(FAILED(hr = SoftwareElementRemoveFile(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RegistryAction") == 0)))
            if(FAILED(hr = SoftwareElementRegistry(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_PublishComponentAction") == 0)))
            if(FAILED(hr = SoftwareElementPublish(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RemoveIniAction") == 0)))
            if(FAILED(hr = SoftwareElementRemoveIniValue(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ShortcutAction") == 0)))
            if(FAILED(hr = SoftwareElementShortcut(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_TypeLibraryAction") == 0)))
            if(FAILED(hr = SoftwareElementTypeLibrary(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }

    }catch(...){
            
        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                           , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcLibID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcLibID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData)
		{
            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `LibID`, `Language` from TypeLib" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `LibID`=\'", wcLibID, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) ) 
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = 39;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_TypeLibraryAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                        , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcShortcut[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen (pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcShortcut);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Shortcut` from Shortcut" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								// safe operation
                                wcProp.Copy(L"Win32_ShortcutAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementRemoveIniValue(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                              , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcIniFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `RemoveIniFile` from RemoveIniFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `RemoveIniFile`=\'", wcIniFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveIniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 ) 
							{
								// safe operation
                                wcProp.Copy(L"Win32_RemoveIniAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementPublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                       , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCompID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcCompID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `ComponentId`, `Qualifier` from PublishComponent" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `ComponentId`=\'", wcCompID, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PublishComponent", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_PublishComponentAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementRegistry(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                        , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcRegistry[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcRegistry);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Registry` from Registry" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Registry`=\'", wcRegistry, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Registry", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								// safe operation
                                wcProp.Copy(L"Win32_RegistryAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementRemoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                          , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `FileKey` from RemoveFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								// safe operation
                                wcProp.Copy(L"Win32_RemoveFileAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementMoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                        , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){

				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
                	if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `FileKey` from MoveFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"MoveFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								// safe operation
                                wcProp.Copy(L"Win32_MoveFileAction.ActionID=\"");
								wcProp.Append ( 1, Buffer );

                                dwBufSize = BUFF_SIZE;
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                         , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcExtension[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcExtension);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Extension` from Extension" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Extension`=\'", wcExtension, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Extension", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 ) 
							{
								// safe operation
                                wcProp.Copy(L"Win32_ExtensionInfoAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
            
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                             , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `FileKey` from DuplicateFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"DuplicateFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								// safe operation
                                wcProp.Copy(L"Win32_DuplicateFileAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementCreateFolder(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                            , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFolder[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFolder);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Directory_` from CreateFolder" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Directory_`=\'", wcFolder, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            bMatch = false;
			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"CreateFolder", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( Buffer && Buffer [ 0 ] != 0 )
							{
								// safe operation
                                wcProp.Copy(L"Win32_CreateFolderAction.ActionID=\"");
								wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                            //====================================================

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                            //----------------------------------------------------

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                     , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCLSID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcCLSID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){

                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `CLSID`, `Context` from Class" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `CLSID`=\'", wcCLSID, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Class", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_ClassInfoAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);
 
                            //====================================================

								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                            //----------------------------------------------------

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcheck.h ===
// SoftwareElementCheck.h: interface for the CSoftwareElementCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTCHECK_H__067CD9F0_D70D_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTCHECK_H__067CD9F0_D70D_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CSoftwareElementCheck : public CGenericClass  
{
public:
	CSoftwareElementCheck(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementCheck();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT SoftwareElementFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT SoftwareElementIniFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT SoftwareElementReserveCost(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT SoftwareElementEnvironment(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT ODBCTranslatorSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT ODBCDataSourceSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
};

#endif // !defined(AFX_SOFTWAREELEMENTCHECK_H__067CD9F0_D70D_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcondition.cpp ===
// SoftwareElementCondition.cpp: implementation of the CSoftwareElementCondition class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementCondition.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementCondition::CSoftwareElementCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementCondition::~CSoftwareElementCondition()
{

}

HRESULT CSoftwareElementCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcTmp[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    int iState;

	CStringExt wcProp;

    //These will change from class to class
    bool bCheck, bNull;
    INSTALLSTATE piInstalled;

    SetSinglePropertyPath(L"CheckID");

    WCHAR wcTestCode[39];

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Component`, `ComponentId`, `Condition` from Component");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (_wcsicmp(wcTestCode, wcProductCode) == 0))
		{
			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Component", FALSE, TRUE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pName, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);

                        wcProp.Copy ( Buffer );      

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        dwBufSize = BUFF_SIZE;
                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf, wcTmp, &dwBufSize);

                        SoftwareElementState(piInstalled, &iState);
                        PutProperty(m_pObj, pSoftwareElementState, iState);

                        if(ValidateComponentID(wcBuf, wcProductCode)){

                            PutProperty(m_pObj, pSoftwareElementID, wcBuf);

                            PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pVersion, wcBuf);
                        //====================================================

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if( !Buffer || ( Buffer && 0 == Buffer [ 0 ] ) )
							{
								bNull = true;
							}
                            else
							{
								bNull = false;
							}

                            PutProperty(m_pObj, pCondition, Buffer);

							wcProp.Append ( 2, Buffer, wcProductCode );
							PutKeyProperty(m_pObj, pCheckID, wcProp, &bCheck, m_pRequest);

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer = NULL;
							}

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if(((atAction != ACTIONTYPE_GET) || bMatch) && !bNull){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseProduct ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseProduct ();
		}
	}

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcondition.h ===
// SoftwareElementCondition.h: interface for the CSoftwareElementCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTCONDITION_H__02FF6C8D_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTCONDITION_H__02FF6C8D_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareElementCondition : public CGenericClass  
{
public:
	CSoftwareElementCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREELEMENTCONDITION_H__02FF6C8D_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementaction.h ===
// SoftwareElementAction.h: interface for the CSoftwareElementAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTACTION_H__52002680_D70A_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTACTION_H__52002680_D70A_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CSoftwareElementAction : public CGenericClass  
{
public:
	CSoftwareElementAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT SoftwareElementClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementCreateFolder(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementMoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementRemoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementRegistry(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementPublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementRemoveIniValue(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
};

#endif // !defined(AFX_SOFTWAREELEMENTACTION_H__52002680_D70A_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcheck.cpp ===
// SoftwareElementCheck.cpp: implementation of the CSoftwareElementCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementCheck.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementCheck::CSoftwareElementCheck(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementCheck::~CSoftwareElementCheck()
{

}

HRESULT CSoftwareElementCheck::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_E_FAILED;
    CRequestObject *pCheckRObj = NULL;
    CRequestObject *pElementRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(int i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"CHECK") == 0){

                    pCheckRObj = new CRequestObject();
                    if(!pCheckRObj) throw he;

                    pCheckRObj->Initialize(m_pNamespace);

                    pCheckRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }

                if(_wcsicmp(m_pRequest->m_Property[i], L"Element") == 0){

                    pElementRObj = new CRequestObject();
                    if(!pElementRObj) throw he;

                    pElementRObj->Initialize(m_pNamespace);

                    pElementRObj->ParsePath(m_pRequest->m_Value[i]);
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))
            if(FAILED(hr = SoftwareElementFile(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_IniFileSpecification") == 0)))
            if(FAILED(hr = SoftwareElementIniFile(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ReserveCost") == 0)))
            if(FAILED(hr = SoftwareElementReserveCost(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_EnvironmentSpecification") == 0)))
            if(FAILED(hr = SoftwareElementEnvironment(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ODBCTranslatorSpecification") == 0)))
            if(FAILED(hr = ODBCTranslatorSoftwareElement(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ODBCDataSourceSpecification") == 0)))
            if(FAILED(hr = ODBCDataSourceSoftwareElement(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }

    }catch(...){
            
        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::ODBCDataSourceSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcDataSource[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcDataSource);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `DataSource` from ODBCDataSource" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `DataSource`=\'", wcDataSource, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDataSource", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
									wcProp.Copy(L"Win32_ODBCDataSourceSpecification.CheckID=\"");
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bFeature, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									if(bFeature && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementCheck::ODBCTranslatorSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcTestCode[39];
    WCHAR wcProductCode[39];
    WCHAR wcTranslator[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcTranslator);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Translator` from ODBCTranslator" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `Translator`=\'", wcTranslator, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCTranslator", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
							
							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
									wcProp.Copy(L"Win32_ODBCTranslatorSpecification.CheckID=\"");
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bFeature, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									if(bFeature && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementEnvironment(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcEnvironment[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcEnvironment);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Environment` from Environment" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `Environment`=\'", wcEnvironment, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Environment", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
									wcProp.Copy(L"Win32_EnvironmentSpecification.CheckID=\"");
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									//====================================================
									/*
									dwBufSize = BUFF_SIZE;
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
									PutProperty(m_pObj, pName, wcBuf);

									dwBufSize = BUFF_SIZE;
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
									PutProperty(m_pObj, pValue, wcBuf);
									*/
									//----------------------------------------------------

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementReserveCost(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcReserve[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcReserve);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `ReserveKey` from ReserveCost" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `ReserveKey`=\'", wcReserve, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));
        
        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ReserveCost", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
									wcProp.Copy(L"Win32_ReserveCost.CheckID=\"");
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementIniFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcIniFile);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `IniFile` from IniFile" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `IniFile`=\'", wcIniFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"IniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
									wcProp.Copy(L"Win32_IniFileSpecification.CheckID=\"");
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( pCheckData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFile);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `File` from File" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `File`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"File", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, Buffer ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

								if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
									wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementservicecontrol.h ===
// SoftwareElementServiceControl.h: interface for the CSoftwareElementServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTSERVICECONTROL_H__72CDD5DA_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTSERVICECONTROL_H__72CDD5DA_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareElementServiceControl : public CGenericClass  
{
public:
	CSoftwareElementServiceControl(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementServiceControl();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREELEMENTSERVICECONTROL_H__72CDD5DA_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementservicecontrol.cpp ===
// SoftwareElementServiceControl.cpp: implementation of the CSoftwareElementServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementServiceControl.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementServiceControl::CSoftwareElementServiceControl(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementServiceControl::~CSoftwareElementServiceControl()
{

}

HRESULT CSoftwareElementServiceControl::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bEnvironment, bElement;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Component_`, `ServiceControl` from ServiceControl");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceControl", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

					dwBufSize = BUFF_SIZE;
					uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																Buffer,
																wcProductCode,
																wcProp,
																&dwBufSize
														   );

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    if( uiStatus == ERROR_SUCCESS )
					{
                        PutKeyProperty(m_pObj, pElement, wcProp, &bElement, m_pRequest);

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							DWORD dwConstant = 0L;
							DWORD dwBuf = 0L;
							DWORD dwProductCode = 0L;

							dwBuf = wcslen ( Buffer );
							dwProductCode = wcslen ( wcProductCode );

							dwConstant = wcslen ( L"Win32_ServiceControl.ID=\"" ) + wcslen ( L"\",ProductCode=\"" ) + wcslen ( L"\"" );

							if ( dwConstant + dwBuf + dwProductCode + 1 < BUFF_SIZE )
							{
								wcscpy(wcProp, L"Win32_ServiceControl.ID=\"");
								wcscat(wcProp, Buffer);
								wcscat(wcProp, L"\",ProductCode=\"");
								wcscat(wcProp, wcProductCode);
								wcscat(wcProp, L"\"");

								PutKeyProperty(m_pObj, pSetting, wcProp, &bEnvironment, m_pRequest);
							}
							else
							{
								LPWSTR wsz = NULL;

								try
								{
									if ( ( wsz = new WCHAR [ dwConstant + dwBuf + dwProductCode + 1 ] ) != NULL )
									{
										wcscpy ( wsz, L"Win32_ServiceControl.ID=\"" );
										wcscat ( wsz, Buffer );
										wcscat ( wsz, L"\",ProductCode=\"" );
										wcscat ( wsz, wcProductCode );
										wcscat ( wsz, L"\"" );

										PutKeyProperty ( m_pObj, pSetting, wsz, &bEnvironment, m_pRequest );
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wsz )
									{
										delete [] wsz;
										wsz = NULL;
									}

									throw;
								}

								if ( wsz )
								{
									delete [] wsz;
									wsz = NULL;
								}
							}

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            if(bEnvironment && bElement) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeature.h ===
// SoftwareFeature.h: interface for the CSoftwareFeature class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATURE_H__CFD828E3_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATURE_H__CFD828E3_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeature : public CGenericClass  
{
public:
	CSoftwareFeature(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeature();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	//WBEM Methods
	HRESULT Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
					  IWbemObjectSink *pHandler, IWbemContext *pCtx);
	HRESULT Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
					  IWbemObjectSink *pHandler, IWbemContext *pCtx);

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	bool CheckUsage(UINT uiStatus);
};

#endif // !defined(AFX_SOFTWAREFEATURE_H__CFD828E3_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeature.cpp ===
// SoftwareFeature.cpp: implementation of the CSoftwareFeature class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeature.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeature::CSoftwareFeature(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeature::~CSoftwareFeature()
{

}

HRESULT CSoftwareFeature::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i = -1;
    int iEnum;
    long lDate;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcName[BUFF_SIZE];
    WCHAR wcParent[BUFF_SIZE];
    WCHAR wcDesc[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    DWORD dwBufSize2;
    DWORD dwCount;
    DWORD dwAttrib;
    WORD wDate;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bFeature, bName, bVersion = false , bIDNum, bProductHandle;
    INSTALLSTATE piInstalled;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED)){

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        
        try
		{
            if ( GetView ( NULL, wcProductCode, NULL, NULL, FALSE, TRUE ) )
			{
				bProductHandle = true;
			}
            else
			{
				bProductHandle = false;
			}

            iEnum = 0;

			// try to get available feature
			do
			{
				uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcName, wcParent);
			}
			while ( uiStatus == ERROR_MORE_DATA );

            while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){

                CheckMSI(uiStatus);

                if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    
                dwBufSize = BUFF_SIZE;
                CheckMSI(g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
                    INSTALLPROPERTY_PRODUCTNAME
#else
                    TcharToWchar(INSTALLPROPERTY_PRODUCTNAME, wcTmp)
#endif
                    , wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pProductName, wcBuf, &bName, m_pRequest);

                dwBufSize = BUFF_SIZE;
                if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
                    INSTALLPROPERTY_VERSIONSTRING
#else
                    TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp)
#endif
                    , wcBuf, &dwBufSize))
                    PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                else{
                    dwBufSize = BUFF_SIZE;
                    if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
                        INSTALLPROPERTY_VERSION
#else
                        TcharToWchar(INSTALLPROPERTY_VERSION, wcTmp)
#endif
                        , wcBuf, &dwBufSize))
                        PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                }

                if ( bProductHandle )
				{
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"Manufacturer", wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pVendor, wcBuf);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                }

                PutKeyProperty(m_pObj, pIdentifyingNumber, wcProductCode, &bIDNum, m_pRequest);

                dwBufSize = BUFF_SIZE;
                PutKeyProperty(m_pObj, pName, wcName, &bFeature, m_pRequest);

            //====================================================

                piInstalled = g_fpMsiQueryFeatureStateW(m_pRequest->Package(i), wcName);

                PutProperty(m_pObj, pInstallState, (int)piInstalled);

                if(ERROR_SUCCESS == g_fpMsiGetFeatureUsageW(wcProductCode, wcName, &dwCount, &wDate)){

                    PutProperty(m_pObj, pAccesses, (int)dwCount);

                    lDate = (1980 + ((wDate & 65024) >> 9)) * 10000;
                    lDate += ((wDate & 480) >> 5) * 100;
                    lDate += (wDate & 31 );

					//safe operation
                    _ltow(lDate, wcBuf, 10);
                    wcscat(wcBuf, L"******.000000+***");
                    PutProperty(m_pObj, pLastUse, wcBuf);
                }

				if ( bProductHandle )
				{
					dwBufSize = dwBufSize2 = BUFF_SIZE;
					if ( ERROR_SUCCESS == g_fpMsiGetFeatureInfoW (	msidata.GetProduct (),
																	wcName,
																	&dwAttrib,
																	wcBuf,
																	&dwBufSize,
																	wcDesc,
																	&dwBufSize2
																 )
					   )
					{
						PutProperty(m_pObj, pDescription, wcDesc);
						PutProperty(m_pObj, pCaption, wcBuf);
						PutProperty(m_pObj, pAttributes, (int)dwAttrib);
					}
					else
					{
						PutProperty(m_pObj, pDescription, wcName);
						PutProperty(m_pObj, pCaption, wcName);
					}
				}
				else
				{
					PutProperty(m_pObj, pDescription, wcName);
					PutProperty(m_pObj, pCaption, wcName);
				}

            //----------------------------------------------------

                if(bFeature && bName && bVersion && bIDNum) bMatch = true;

                if((atAction != ACTIONTYPE_GET)  || bMatch){

                    hr = pHandler->Indicate(1, &m_pObj);
                }

                m_pObj->Release();
                m_pObj = NULL;

				// try to get available feature
				do
				{
					uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcName, wcParent);
				}
				while ( uiStatus == ERROR_MORE_DATA );
            }
        }
		catch(...)
		{
			msidata.CloseProduct ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}
            
            throw;
        }

		msidata.CloseProduct ();
    }

    return hr;
}

bool CSoftwareFeature::CheckUsage(UINT uiStatus)
{
    switch(uiStatus){

    case ERROR_BAD_CONFIGURATION:
        throw WBEM_E_FAILED;

    case ERROR_INSTALL_FAILURE:
        return false;

    case ERROR_SUCCESS:
        return true;

    default:
        return false;
    }

    return false;
}

HRESULT CSoftwareFeature::Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                                    IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iState;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrConfigure = SysAllocString(L"Configure");
    if(!bstrConfigure)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    INSTALLSTATE isState;
    int i = -1;
    bool bFoundCode = false;
    bool bFoundFeature = false;

    if(SUCCEEDED(hr = pReqObj->m_pNamespace->GetObject(pReqObj->m_bstrClass, 0, pCtx, &pClass, NULL)))
    {
        if(SUCCEEDED(hr = pClass->GetMethod(bstrConfigure, 0, NULL, &pOutClass)))
        {
            if(SUCCEEDED(hr = pOutClass->SpawnInstance(0, &pOutParams)))
            {
                //Get PackageLocation
                if(!SUCCEEDED(GetProperty(pInParams, "InstallState", &iState)))
                    hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                //Get the Product Code
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcCode, pReqObj->m_Value[i]);
							bFoundCode = true;
							break;
						}
                    }   
                }

                //Get the Feature Name
                i = -1;
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"Name") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcFeature, pReqObj->m_Value[i]);
							bFoundFeature = true;
							break;
						}
                    }   
                }

                if(bFoundCode && bFoundFeature){
                    //Get the appropriate State
                    switch(iState){
                    case 1:
                        isState = INSTALLSTATE_DEFAULT;
                        break;
                    case 2:
                        isState = INSTALLSTATE_ADVERTISED;
                        break;
                    case 3:
                        isState = INSTALLSTATE_LOCAL;
                        break;
                    case 4:
                        isState = INSTALLSTATE_ABSENT;
                        break;
                    case 5:
                        isState = INSTALLSTATE_SOURCE;
                        break;
                    default:
                        isState = INSTALLSTATE_NOTUSED;
                        break;
                    }

                    //If everything is valid, proceed
                    if((isState != INSTALLSTATE_NOTUSED) && (hrReturn == WBEM_S_NO_ERROR)){

                        if(!IsNT4()){

							if ( msidata.Lock () )
							{
								INSTALLUI_HANDLER ui = NULL;

								//Set UI Level w/ event callback
								ui = SetupExternalUI ( );

								try
								{
									//Call Installer
									uiStatus = g_fpMsiConfigureFeatureW(wcCode, wcFeature, isState);
								}
								catch(...)
								{
									uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
								}

								//Restore UI Level w/ event callback
								RestoreExternalUI ( ui );

								msidata. Unlock();
							}

                        }else{

                        /////////////////
                        // NT4 fix code....

                            try{

                                WCHAR wcAction[20];
                                wcscpy(wcAction, L"/sfconfigure");

                                WCHAR wcTmp[100];
								_itow((int)isState, wcTmp, 10);

								LPWSTR wcCommandLine = NULL;

								try
								{
									if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + wcslen ( wcFeature ) + 3 + wcslen ( wcTmp ) ] ) != NULL )
									{
										wcscpy(wcCommandLine, wcCode);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcFeature);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcTmp);

										hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

										delete [] wcCommandLine;
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcCommandLine )
									{
										delete [] wcCommandLine;
										wcCommandLine = NULL;
									}

									hrReturn = E_OUTOFMEMORY;
								}

                            }catch(...){

                                hrReturn = WBEM_E_FAILED;
                            }

                            ////////////////////

                        }

                        if(SUCCEEDED(hrReturn)){

                            //Set up ReturnValue
                            VariantInit(&v);
                            V_VT(&v) = VT_I4;
                            V_I4(&v) = uiStatus;

                            BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                            if(!bstrReturnValue)
                                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

                            if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                &v, NULL)))
                                pHandler->Indicate(1, &pOutParams);

                            SysFreeString(bstrReturnValue);
                        }

                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                }else hr = WBEM_E_FAILED;

                pOutParams->Release();

            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrConfigure);

    return hrReturn;
}

HRESULT CSoftwareFeature::Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                                    IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iMode;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrReinstall = SysAllocString(L"Reinstall");
    if(!bstrReinstall)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    DWORD dwMode;
    int i = -1;
    bool bFoundCode = false;
    bool bFoundFeature = false;

    if(SUCCEEDED(hr = pReqObj->m_pNamespace->GetObject(pReqObj->m_bstrClass, 0, pCtx, &pClass, NULL))){
        if(SUCCEEDED(hr = pClass->GetMethod(bstrReinstall, 0, NULL, &pOutClass))){
            if(SUCCEEDED(hr = pOutClass->SpawnInstance(0, &pOutParams))){
                //Get Reinstall Mode
                if(!SUCCEEDED(GetProperty(pInParams, "ReinstallMode", &iMode)))
                    hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                //Get the Product Code
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcCode, pReqObj->m_Value[i]);
							bFoundCode = true;
							break;
						}
                    }   
                }

                //Get the Feature Name
                i = -1;
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"Name") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcFeature, pReqObj->m_Value[i]);
							bFoundFeature = true;
							break;
						}
                    }   
                }

                if(bFoundCode && bFoundFeature){
                    //Get the appropriate ReinstallMode
                    switch(iMode){
                    case 1:
                        dwMode = REINSTALLMODE_FILEMISSING;
                        break;
                    case 2:
                        dwMode = REINSTALLMODE_FILEOLDERVERSION;
                        break;
                    case 3:
                        dwMode = REINSTALLMODE_FILEEQUALVERSION;
                        break;
                    case 4:
                        dwMode = REINSTALLMODE_FILEEXACT;
                        break;
                    case 5:
                        dwMode = REINSTALLMODE_FILEVERIFY;
                        break;
                    case 6:
                        dwMode = REINSTALLMODE_FILEREPLACE;
                        break;
                    case 7:
                        dwMode = REINSTALLMODE_USERDATA;
                        break;
                    case 8:
                        dwMode = REINSTALLMODE_MACHINEDATA;
                        break;
                    case 9:
                        dwMode = REINSTALLMODE_SHORTCUT;
                        break;
                    case 10:
                        dwMode = REINSTALLMODE_PACKAGE;
                        break;
                    default:
                        dwMode = NULL;
                        break;
                    }

                    //If everything is valid, proceed
                    if ( dwMode && hrReturn == WBEM_S_NO_ERROR )
					{
                        if(!IsNT4()){

							if ( msidata.Lock () )
							{
								INSTALLUI_HANDLER ui = NULL;

								//Set UI Level w/ event callback
								ui = SetupExternalUI ( );

								try
								{
									//Call Installer
									uiStatus = g_fpMsiReinstallFeatureW(wcCode, wcFeature, dwMode);
								}
								catch(...)
								{
									uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
								}

								//Restore UI Level w/ event callback
								RestoreExternalUI ( ui );

								msidata. Unlock();
							}

                        }else{

                        /////////////////
                        // NT4 fix code....

                            try{

                                WCHAR wcAction[20];
                                wcscpy(wcAction, L"/sfreinstall");

                                WCHAR wcTmp[100];
								_itow((int)dwMode, wcTmp, 10);

								LPWSTR wcCommandLine = NULL;

								try
								{
									if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + wcslen ( wcFeature ) + 3 + wcslen ( wcTmp ) ] ) != NULL )
									{
										wcscpy(wcCommandLine, wcCode);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcFeature);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcTmp);

										hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

										delete [] wcCommandLine;
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcCommandLine )
									{
										delete [] wcCommandLine;
										wcCommandLine = NULL;
									}

									hrReturn = E_OUTOFMEMORY;
								}

                            }catch(...){

                                hrReturn = WBEM_E_FAILED;
                            }

                            ////////////////////

                        }

                        if(SUCCEEDED(hrReturn)){

                            //Set up ReturnValue
                            VariantInit(&v);
                            V_VT(&v) = VT_I4;
                            V_I4(&v) = uiStatus;

                            BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                            if(!bstrReturnValue)
                                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

                            if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                &v, NULL)))
                                pHandler->Indicate(1, &pOutParams);

                            SysFreeString(bstrReturnValue);
                        }

                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                }else hr = WBEM_E_FAILED;

                pOutParams->Release();

            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrReinstall);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureaction.h ===
// SoftwareFeatureAction.h: interface for the CSoftwareFeatureAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATUREACTION_H__01FCD010_D70E_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATUREACTION_H__01FCD010_D70E_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CSoftwareFeatureAction : public CGenericClass  
{
public:
	CSoftwareFeatureAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT SoftwareFeatureClassInfo(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeatureExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeaturePublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeatureShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeatureTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
};

#endif // !defined(AFX_SOFTWAREFEATUREACTION_H__01FCD010_D70E_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureaction.cpp ===
// SoftwareFeatureAction.cpp: implementation of the CSoftwareFeatureAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureAction::CSoftwareFeatureAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureAction::~CSoftwareFeatureAction()
{

}

HRESULT CSoftwareFeatureAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pActionRObj = NULL;
    CRequestObject *pFeatureRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(int i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"ACTION") == 0){

                    pActionRObj = new CRequestObject();
                    if(!pActionRObj) throw he;

                    pActionRObj->Initialize(m_pNamespace);

                    pActionRObj->ParsePath(m_pRequest->m_Value[i]);
                }

                if(_wcsicmp(m_pRequest->m_Property[i], L"Element") == 0){

                    pFeatureRObj = new CRequestObject();
                    if(!pFeatureRObj) throw he;

                    pFeatureRObj->Initialize(m_pNamespace);

                    pFeatureRObj->ParsePath(m_pRequest->m_Value[i]);
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ClassInfoAction") == 0)))
            if(FAILED(hr = SoftwareFeatureClassInfo(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ExtensionInfoAction") == 0)))
            if(FAILED(hr = SoftwareFeatureExtension(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_PublishComponentAction") == 0)))
            if(FAILED(hr = SoftwareFeaturePublish(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ShortcutAction") == 0)))
            if(FAILED(hr = SoftwareFeatureShortcut(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_TypeLibraryAction") == 0)))
            if(FAILED(hr = SoftwareFeatureTypeLibrary(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pFeatureRObj){

            pFeatureRObj->Cleanup();
            delete pFeatureRObj;
            pFeatureRObj = NULL;
        }

    }catch(...){
            
        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pFeatureRObj){

            pFeatureRObj->Cleanup();
            delete pFeatureRObj;
            pFeatureRObj = NULL;
        }
    }

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcLibID[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bTypeLib = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcLibID);

						bTypeLib = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `LibID`, `Language`, `Component_` from TypeLib" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bTypeLib || bGotFeature)
		{
			if ( bTypeLib )
			{
				wcQuery.Append ( 3, L" where `LibID`=\'", wcLibID, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bTypeLib )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) )
				{

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString(Buffer, wcProductCode, wcFeature, true) )
							{
                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_TypeLibraryAction.ActionID=\"" );
									wcProp.Append ( 1, wcBuf );

                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                //----------------------------------------------------

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }

							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

	if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcShortcut[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bShortcut = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcShortcut);

						bShortcut = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
 					}
               }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
 					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Target`, `Shortcut`, `Component_` from Shortcut" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bShortcut || bGotFeature)
		{
			if ( bShortcut )
			{
				wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bShortcut )
				{
					wcQuery.Append ( 3, L" or `Target`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Target`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString(Buffer, wcProductCode, wcFeature, true) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                if ( Buffer && Buffer [ 0 ] != 0 ) 
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_ShortcutAction.ActionID=\"" );
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeaturePublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCompID[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bPublish = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcCompID);

						bPublish = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `ComponentId`, `Qualifier`, `Component_` from PublishComponent" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bPublish || bGotFeature)
		{
			if ( bPublish )
			{
				wcQuery.Append ( 3, L" where `ComponentId`=\'", wcCompID, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bPublish )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PublishComponent", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString(Buffer, wcProductCode, wcFeature, true) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_PublishComponentAction.ActionID=\"" );
									wcProp.Append ( 1, Buffer );

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                    dwBufSize = BUFF_SIZE;
									GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcExtension[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bExtension = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( pActionData->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcExtension);

						bExtension = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `Extension`, `Component_` from Extension" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bExtension || bGotFeature)
		{
			if ( bExtension )
			{
				wcQuery.Append ( 3, L" where `Extension`=\'", wcExtension, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bExtension )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Extension", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj)))throw hr;

                        //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString(Buffer, wcProductCode, wcFeature, true) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_ExtensionInfoAction.ActionID=\"" );
									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                //====================================================

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                //----------------------------------------------------

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureClassInfo(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCLSID[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bCLSID = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pActionData){

            for(j = 0; j < pActionData->m_iPropCount; j++){
                
                if(_wcsicmp(pActionData->m_Property[j], L"ActionID") == 0)
				{
					if ( ::SysStringLen (  pActionData->m_Value[j] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[j]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[j], wcCLSID);

						bCLSID = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `CLSID`, `Context`, `Component_` from Class" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bCLSID || bGotFeature)
		{
			if ( bCLSID )
			{
				wcQuery.Append ( 3, L" where `CLSID`=\'", wcCLSID, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bCLSID )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Class", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, Buffer ) )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString(Buffer, wcProductCode, wcFeature, true) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                if ( Buffer && Buffer [ 0 ] != 0 )
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_ClassInfoAction.ActionID=\"" );
                                    wcProp.Append ( 1, Buffer );

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                    dwBufSize = BUFF_SIZE;
									GetBufferToPut ( hRecord, 3, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

									wcProp.Append ( 3, Buffer, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                //====================================================

									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                //----------------------------------------------------

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturecondition.cpp ===
// SoftwareFeatureCondition.cpp: implementation of the CSoftwareFeatureCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureCondition.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureCondition::CSoftwareFeatureCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureCondition::~CSoftwareFeatureCondition()
{

}

HRESULT CSoftwareFeatureCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcBuf2[BUFF_SIZE];

    LPWSTR wcCondition = NULL;

    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bFeature, bParent;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Feature_`, `Level` from Condition");

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Condition", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
					GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

					if ( ( wcCondition = new WCHAR [ dwBufSize + 1 ] ) != NULL )
					{
						wcscpy(wcCondition, Buffer);
					}
					else
					{
						throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR);
					}

                    if ( CreateSoftwareFeatureString ( Buffer, wcProductCode, wcProp, true ) )
					{
						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        PutKeyProperty(m_pObj, pElement, wcProp, &bFeature, m_pRequest);

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf2, dwDynBuffer, dynBuffer, Buffer );

                        if ( Buffer && Buffer [ 0 ] != 0 )
						{
							DWORD dwConstant = 0L;
							DWORD dwCondition = 0L;
							DWORD dwBuf = 0L;
							DWORD dwProductCode = 0L;

							dwCondition = wcslen ( wcCondition );
							dwBuf = dwBufSize;
							dwProductCode = wcslen ( wcProductCode );

							dwConstant = wcslen ( L"Win32_Condition.CheckID=\"" ) + wcslen ( L"\"" );

							if ( dwConstant + dwCondition + dwBuf + dwProductCode + 1 < BUFF_SIZE )
							{
								wcscpy(wcProp, L"Win32_Condition.CheckID=\"");
								wcscat(wcProp, wcCondition);
								wcscat(wcProp, Buffer);
								wcscat(wcProp, wcProductCode);
								wcscat(wcProp, L"\"");

								PutKeyProperty(m_pObj, pCheck, wcProp, &bParent, m_pRequest);
							}
							else
							{
								LPWSTR wsz = NULL;

								try
								{
									if ( ( wsz = new WCHAR [ dwConstant + dwCondition + dwBuf + dwProductCode + 1 ] ) != NULL )
									{
										wcscpy ( wsz, L"Win32_Condition.CheckID=\"" );
										wcscat ( wsz, wcCondition );
										wcscat ( wsz, Buffer
											);
										wcscat ( wsz, wcProductCode );
										wcscat ( wsz, L"\"" );

										PutKeyProperty ( m_pObj, pCheck, wsz, &bParent, m_pRequest );
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wsz )
									{
										delete [] wsz;
										wsz = NULL;
									}

									throw;
								}

								if ( wsz )
								{
									delete [] wsz;
									wsz = NULL;
								}
							}

						//====================================================

                        //----------------------------------------------------

                            if(bFeature && bParent) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

					if ( dynBuffer && dynBuffer [ 0 ] != 0 )
					{
						dynBuffer [ 0 ] = 0;
					}

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

					if ( wcCondition )
					{
						delete [] wcCondition;
						wcCondition = NULL;
					}
                }
            }
		}
		catch(...)
		{
			if ( dynBuffer )
			{
				delete [] dynBuffer;
				dynBuffer = NULL;
			}

			if ( wcCondition )
			{
				delete [] wcCondition;
				wcCondition = NULL;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturecondition.h ===
// SoftwareFeatureCondition.h: interface for the CSoftwareFeatureCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATURECONDITION_H__F4A87812_E037_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATURECONDITION_H__F4A87812_E037_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeatureCondition : public CGenericClass  
{
public:
	CSoftwareFeatureCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREFEATURECONDITION_H__F4A87812_E037_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureparent.cpp ===
// SoftwareFeatureParent.cpp: implementation of the CSoftwareFeatureParent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureParent.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureParent::CSoftwareFeatureParent(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureParent::~CSoftwareFeatureParent()
{

}

HRESULT CSoftwareFeatureParent::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcProp[BUFF_SIZE];
    WCHAR wcAntFeature[BUFF_SIZE];
    WCHAR wcDepFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;;
    bool bAnt = false;
    bool bDep = false;
    bool bTestCode = false;
    UINT uiStatus;
    CRequestObject *pDepRObj = NULL;
    CRequestObject *pAntRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            int j;
            //GetObject optimizations
            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(j = 0; j < m_pRequest->m_iPropCount; j++){
                
                if(_wcsicmp(m_pRequest->m_Property[j], L"Dependent") == 0){

                    pDepRObj = new CRequestObject();
                    if(!pDepRObj) throw he;

                    pDepRObj->Initialize(m_pNamespace);

                    pDepRObj->ParsePath(m_pRequest->m_Value[j]);
                    break;
                }
            }

            if(pDepRObj){

                for(j = 0; j < pDepRObj->m_iPropCount; j++){
                
                    if(_wcsicmp(pDepRObj->m_Property[j], L"IdentifyingNumber") == 0){

						//Get the product code we're looking for
						if ( ::SysStringLen ( pDepRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcTestCode, pDepRObj->m_Value[j]);
							bTestCode = true;
						}
                    }

                    if(_wcsicmp(pDepRObj->m_Property[j], L"Name") == 0){

                        //Get the product code we're looking for
						if ( ::SysStringLen ( pDepRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcDepFeature, pDepRObj->m_Value[j]);
							bDep = true;
						}
                    }
                }

                pDepRObj->Cleanup();
                delete pDepRObj;
                pDepRObj = NULL;
            }

            for(j = 0; j < m_pRequest->m_iPropCount; j++){
                
                if(_wcsicmp(m_pRequest->m_Property[j], L"Antecedent") == 0){

                    pAntRObj = new CRequestObject();
                    if(!pAntRObj) throw he;

                    pAntRObj->Initialize(m_pNamespace);

                    pAntRObj->ParsePath(m_pRequest->m_Value[j]);
                    break;
                }
            }

            if(pAntRObj){

                for(j = 0; j < pAntRObj->m_iPropCount; j++){
                
                    if(_wcsicmp(pAntRObj->m_Property[j], L"IdentifyingNumber") == 0){

                        //Get the product code we're looking for
						if ( ::SysStringLen ( pAntRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcTestCode, pAntRObj->m_Value[j]);
						}
                    }

                    if(_wcsicmp(pAntRObj->m_Property[j], L"Name") == 0){

                        //Get the product code we're looking for
						if ( ::SysStringLen ( pAntRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcAntFeature, pAntRObj->m_Value[j]);
	                        bAnt = true;
						}
                    }
                }

                pAntRObj->Cleanup();
                delete pAntRObj;
                pAntRObj = NULL;
            }
        }

        //These will change from class to class
        bool bFeature, bParent;

		Query wcQuery;
		wcQuery.Append ( 1, L"select distinct `Feature_Parent`, `Feature` from Feature" );

		//optimize for GetObject
		if ( bAnt || bDep )
		{
			if ( bDep )
			{
				wcQuery.Append ( 3, L" where `Feature`=\'", wcDepFeature, L"\'" );
			}

			if ( bAnt )
			{
				if ( bDep )
				{
					wcQuery.Append ( 3, L" or `Feature_Parent`=\'", wcAntFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_Parent`=\'", wcAntFeature, L"\'" );
				}
			}
		}

		LPWSTR Buffer = NULL;
		LPWSTR dynBuffer = NULL;

		DWORD dwDynBuffer = 0L;

        while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
		{
			// safe operation:
			// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

            wcscpy(wcProductCode, m_pRequest->Package(i));

            if((atAction == ACTIONTYPE_ENUM) ||
                (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

				//Open our database
                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Feature", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString ( Buffer, wcProductCode, wcProp, true ) )
							{
                                if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

								PutKeyProperty(m_pObj, pAntecedent, wcProp, &bParent, m_pRequest);

                                dwBufSize = BUFF_SIZE;
								GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                                if ( CreateSoftwareFeatureString ( Buffer, wcProductCode, wcProp, true ) )
								{
									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}

                                    PutKeyProperty(m_pObj, pDependent, wcProp, &bFeature, m_pRequest);

                                    if(bFeature && bParent) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
								else
								{
									if ( dynBuffer && dynBuffer [ 0 ] != 0 )
									{
										dynBuffer [ 0 ] = 0;
									}
								}
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					if ( dynBuffer )
					{
						delete [] dynBuffer;
						dynBuffer = NULL;
					}

					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
            }
        }

		if ( dynBuffer )
		{
			delete [] dynBuffer;
			dynBuffer = NULL;
		}
	}
	catch(...)
	{
            
        if(pDepRObj){

            pDepRObj->Cleanup();
            delete pDepRObj;
            pDepRObj = NULL;
        }

        if(pAntRObj){

            pAntRObj->Cleanup();
            delete pAntRObj;
            pAntRObj = NULL;
        }

		throw;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureparent.h ===
// SoftwareFeatureParent.h: interface for the CSoftwareFeatureParent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATUREPARENT_H__02FF6C83_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATUREPARENT_H__02FF6C83_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeatureParent : public CGenericClass  
{
public:
	CSoftwareFeatureParent(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureParent();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREFEATUREPARENT_H__02FF6C83_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturesoftwareelements.h ===
// SoftwareFeatureSofwareElements.h: interface for the CSoftwareFeatureSofwareElements class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATURESOFWAREELEMENTS_H__CFD828E5_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATURESOFWAREELEMENTS_H__CFD828E5_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeatureSofwareElements : public CGenericClass  
{
public:
	CSoftwareFeatureSofwareElements(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureSofwareElements();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREFEATURESOFWAREELEMENTS_H__CFD828E5_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturesoftwareelements.cpp ===
// SoftwareFeatureSofwareElements.cpp: implementation of the CSoftwareFeatureSofwareElements class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureSoftwareElements.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureSofwareElements::CSoftwareFeatureSofwareElements(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureSofwareElements::~CSoftwareFeatureSofwareElements()
{

}

HRESULT CSoftwareFeatureSofwareElements::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];

    WCHAR wcProductCode[39];
    WCHAR wcID[39];
    WCHAR wcProp[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    WCHAR wcElement[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bFeature, bElement;
    bool bFeatureRestrict = false;
    bool bElementRestrict = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int iPos = -1;
        BSTR bstrName = SysAllocString(L"GroupComponent");

		if ( bstrName )
		{
			if(FindIn(m_pRequest->m_Property, bstrName, &iPos))
			{
				CRequestObject *pFeature = new CRequestObject();
				if(!pFeature) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

				pFeature->Initialize(m_pNamespace);
            
				if(pFeature->ParsePath(m_pRequest->m_Value[iPos]))
				{
					iPos = -1;

					SysFreeString(bstrName);
					bstrName = SysAllocString(L"IdentifyingNumber");

					if ( bstrName )
					{
						if(FindIn(pFeature->m_Property, bstrName, &iPos))
						{
							if ( ::SysStringLen ( pFeature->m_Value[iPos] ) == 38 )
							{
								//Get the product code we're looking for
								wcscpy(wcID, pFeature->m_Value[iPos]);
							}
							else
							{
								// we are not good to go, they have sent us longer string
								SysFreeString ( bstrName );
								throw hr;
							}
                
							iPos = -1;

							SysFreeString(bstrName);
							bstrName = SysAllocString(L"Name");

							if ( bstrName )
							{
								if(FindIn(pFeature->m_Property, bstrName, &iPos))
								{
									if ( ::SysStringLen ( pFeature->m_Value[iPos] ) <= BUFF_SIZE )
									{
										//Get the product code we're looking for
										wcscpy(wcFeature, pFeature->m_Value[iPos]);
										bFeatureRestrict = true;
									}
									else
									{
										// we are not good to go, they have sent us longer string
										SysFreeString ( bstrName );
										throw hr;
									}
								}
							}
							else
							{
								throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}
						}
					}
					else
					{
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
					}
				}

				pFeature->Cleanup();
				delete pFeature;
				pFeature = NULL;
			}

			SysFreeString(bstrName);
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrName = SysAllocString(L"PartComponent");

		if ( bstrName )
		{
			if(FindIn(m_pRequest->m_Property, bstrName, &iPos))
			{
				CRequestObject *pElement = new CRequestObject();
				if(!pElement) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

				pElement->Initialize(m_pNamespace);
            
				if(pElement->ParsePath(m_pRequest->m_Value[iPos]))
				{
					iPos = -1;

					SysFreeString(bstrName);
					bstrName = SysAllocString(L"Name");

					if ( bstrName )
					{
						if(FindIn(pElement->m_Property, bstrName, &iPos))
						{
							if ( ::SysStringLen ( pElement->m_Value[iPos] ) <= BUFF_SIZE )
							{
								//Get the product code we're looking for
								wcscpy(wcElement, pElement->m_Value[iPos]);
								bElementRestrict = true;
							}
							else
							{
								// we are not good to go, they have sent us longer string
								SysFreeString ( bstrName );
								throw hr;
							}
						}
					}
					else
					{
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
					}
				}

				pElement->Cleanup();
				delete pElement;
				pElement = NULL;
			}

			SysFreeString(bstrName);
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

   
    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Feature_` from FeatureComponents" );

    //optimize for GetObject
    if ( bElementRestrict || bFeatureRestrict )
	{
		if ( bFeatureRestrict )
		{
			wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
		}

		if ( bElementRestrict )
		{
			if ( bFeatureRestrict )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        //This trims the number of times we itterate on getobject calls
        if((atAction == ACTIONTYPE_ENUM) || !bFeatureRestrict ||
            (0 == _wcsicmp(m_pRequest->Package(i), wcID))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"FeatureComponents", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	Buffer,
																	wcProductCode,
																	wcProp,
																	&dwBufSize
															   );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pPartComponent, wcProp, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
							GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                            if ( CreateSoftwareFeatureString ( Buffer, wcProductCode, wcProp, true ) )
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}

                                PutKeyProperty(m_pObj, pGroupComponent, wcProp, &bFeature, m_pRequest);
                        //----------------------------------------------------

                                if(bFeature && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
							else
							{
								if ( dynBuffer && dynBuffer [ 0 ] != 0 )
								{
									dynBuffer [ 0 ] = 0;
								}
							}
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    }//while
                
                }//if
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

        }//if
    }//while

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\typelibraryaction.cpp ===
// TypeLibraryAction.cpp: implementation of the CTypeLibraryAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "TypeLibraryAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTypeLibraryAction::CTypeLibraryAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CTypeLibraryAction::~CTypeLibraryAction()
{

}

HRESULT CTypeLibraryAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					GetFirstGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `LibID`, `Component_`, `Language`, `Version`, `Description`, `Cost` from TypeLib" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `LibID`=\'", wcAction, L"\'" );
	}

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcProp, &dwBufSize));
                        PutProperty(m_pObj, pLibID, wcProp);

                        dwBufSize = BUFF_SIZE;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        if ( ValidateComponentName	(	msidata.GetDatabase (),
														wcProductCode,
														Buffer
													)
						   )
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pLanguage, wcBuf);

							PutKeyProperty ( m_pObj, pActionID, wcProp, &bCheck, m_pRequest, 2, wcBuf, wcProductCode );

						//====================================================

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pVersion, wcBuf);

                            dwBufSize = BUFF_SIZE;
							PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, FALSE, 3, pName, pCaption, pDescription );

                            PutProperty(m_pObj, pCost, g_fpMsiRecordGetInteger(hRecord, 6));

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
						else
						{
							if ( dynBuffer && dynBuffer [ 0 ] != 0 )
							{
								dynBuffer [ 0 ] = 0;
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }

            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\upgrade.cpp ===
// Upgrade.cpp: implementation of the CUpgrade class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Upgrade.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUpgrade::CUpgrade(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CUpgrade::~CUpgrade()
{

}

HRESULT CUpgrade::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcQuery[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch;
    UINT uiStatus;

    //These will change from class to class
    bool bUpgradeCode, bProductVersion, bOperator, bProductCode;
    wcscpy(wcQuery, L"select distinct `UpgradeCode`, `ProductVersion`, `Operator`, `Features`, `Property` from Upgrade");

    while(m_pRequest->Package(++i)){
        wcscpy(wcProductCode, m_pRequest->Package(i));

        bMatch = false;
    //Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Upgrade", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(uiStatus != ERROR_NO_MORE_ITEMS){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(m_pNamespace, m_pCtx,
                        &m_pObj, m_pRequest->m_bstrClass))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pUpgradeCode, wcBuf, &bUpgradeCode, m_pRequest);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pProductVersion, wcBuf, &bProductVersion, m_pRequest);

                    PutKeyProperty(m_pObj, pOperator, g_fpMsiRecordGetInteger(hRecord, 3),
                        &bOperator, m_pRequest);

                    PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProductCode, m_pRequest);
                //====================================================

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pFeatures, wcBuf);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pProperty, wcBuf);
                //----------------------------------------------------

                    if(bUpgradeCode && bProductVersion && bOperator && bProductCode) bMatch = true;

                    if((atAction != ACTIONTYPE_GET)  || bMatch) hr = pHandler->Indicate(1, &m_pObj);

                    m_pObj->Release();
                    m_pObj = NULL;

                    if(bMatch){
                        g_fpMsiViewClose(hView);
                        g_fpMsiCloseHandle(hView);
                        g_fpMsiCloseHandle(hRecord);
                        return hr;
                    }

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\upgrade.h ===
// Upgrade.h: interface for the CUpgrade class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UPGRADE_H__DB614F2D_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_UPGRADE_H__DB614F2D_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CUpgrade : public CGenericClass  
{
public:
	CUpgrade(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CUpgrade();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_UPGRADE_H__DB614F2D_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\typelibraryaction.h ===
// TypeLibraryAction.h: interface for the CTypeLibraryAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TYPELIBRARYACTION_H__75F6BA27_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_TYPELIBRARYACTION_H__75F6BA27_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CTypeLibraryAction : public CGenericClass  
{
public:
	CTypeLibraryAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CTypeLibraryAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_TYPELIBRARYACTION_H__75F6BA27_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\utils.cpp ===
// Utils.cpp: implementation of the CGenericClass class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"

char * WcharToTchar(WCHAR * wcPtr, char * tcTmp)
{
    WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcPtr, (-1), tcTmp, BUFF_SIZE, NULL, NULL);
    return tcTmp;
}

WCHAR * TcharToWchar(char * tcPtr, WCHAR * wcTmp)
{
    MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, tcPtr, (-1), wcTmp, BUFF_SIZE);
    return wcTmp;
}

WCHAR * TcharToWchar(const char * tcPtr, WCHAR * wcTmp)
{
    MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, tcPtr, (-1), wcTmp, BUFF_SIZE);
    return wcTmp;
}

HRESULT ConvertError(UINT uiStatus)
{
    switch(uiStatus){

    case ERROR_INSTALL_ALREADY_RUNNING:
        return WBEM_E_ACCESS_DENIED;

    case ERROR_ACCESS_DENIED:
        return WBEM_E_PRIVILEGE_NOT_HELD;

    case E_OUTOFMEMORY:
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
        return WBEM_E_OUT_OF_MEMORY;

    default:
        return WBEM_E_FAILED;
    }
}

WCHAR * EscapeStringW(WCHAR * wcIn, WCHAR * wcOut)
{
	wcOut [ 0 ] = 0;

	DWORD dwLenghtIn = 0L;
	dwLenghtIn = lstrlenW ( wcIn );

    WCHAR wcTmp[BUFF_SIZE] = { L'\0' };
    wcscpy(wcTmp, wcIn);
    WCHAR * wcp = wcTmp;

	DWORD dwNumber = 0L;

	while ( *wcp )
	{
		if ( *wcp == L'\\' || *wcp == L'\"' )
		{
			dwNumber++;
		}

		wcp++;
	}

	if ( BUFF_SIZE > ( dwLenghtIn + dwNumber * 2 ) )
	{
		wcp = wcTmp;

		while ( *wcp )
		{
			switch ( *wcp )
			{
				case L'\\':
				*wcp = NULL;
				wcscpy(wcOut, wcTmp);
				wcscat(wcOut, L"\\\\");
				wcscat(wcOut, (wcp + 1));
				wcscpy(wcTmp, wcOut);
				wcp++;
				break;

				case L'\"':
				*wcp = NULL;
				wcscpy(wcOut, wcTmp);
				wcscat(wcOut, L"\\\"");
				wcscat(wcOut, (wcp + 1));
				wcscpy(wcTmp, wcOut);
				wcp++;
				break;

				default:
				break;
			}

			wcp++;
		}
	}

    return wcOut;
}

void SoftwareElementState(INSTALLSTATE piInstalled, int *iState)
{
    switch(piInstalled){

		case INSTALLSTATE_ABSENT:
		*iState = 0;
		break;
		case INSTALLSTATE_BADCONFIG:
		*iState = 0;
		break;
		case INSTALLSTATE_INVALIDARG:
		*iState = 0;
		break;
		case INSTALLSTATE_LOCAL:
		*iState = 2;
		break;
		case INSTALLSTATE_SOURCE:
		*iState = 1;
		break;
		case INSTALLSTATE_SOURCEABSENT:
		*iState = 0;
		break;
		case INSTALLSTATE_UNKNOWN:
		*iState = 0;
		break;
		default:
		*iState = 0;
	}
}

// string am getting is BUF_SIZE ( statically allocated )
bool CreateProductString(WCHAR *wcProductCode, WCHAR *wcProductPath)
{
    DWORD dwBufSize;
    WCHAR wcBuf[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    bool bResult = false;

	// safe operation
    wcscpy(wcProductPath, L"Win32_Product.IdentifyingNumber=\"");

	if (	wcslen ( wcProductPath ) + 
			wcslen ( L"\",Name=\"" )

			< BUFF_SIZE
	   )
	{
		wcscat(wcProductPath, wcProductCode);
		wcscat(wcProductPath, L"\",Name=\"");

		dwBufSize = BUFF_SIZE;
#if defined(_UNICODE)
		if(g_fpMsiGetProductInfoW(wcProductCode, INSTALLPROPERTY_PRODUCTNAME,
#else
		if(g_fpMsiGetProductInfoW(wcProductCode, TcharToWchar(INSTALLPROPERTY_PRODUCTNAME, wcTmp),
#endif
			wcBuf, &dwBufSize) == ERROR_SUCCESS)
		{

			if (	wcslen (wcProductPath) +
					wcslen (wcBuf) +
					wcslen (L"\",Version=\"") 

					< BUFF_SIZE
			   )
			{
				wcscat(wcProductPath, wcBuf);
				wcscat(wcProductPath, L"\",Version=\"");

				dwBufSize = BUFF_SIZE;
#if defined(_UNICODE)
				if(g_fpMsiGetProductInfoW(wcProductCode, INSTALLPROPERTY_VERSIONSTRING,
#else
				if(g_fpMsiGetProductInfoW(wcProductCode, TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp),
#endif
					wcBuf, &dwBufSize) == ERROR_SUCCESS)
				{
					if (	wcslen (wcProductPath) +
							wcslen (wcBuf) +
							1 

							< BUFF_SIZE
					   )
					{
						wcscat(wcProductPath, wcBuf);
						wcscat(wcProductPath, L"\"");
						bResult = true;
					}
				}
				else
				{
					dwBufSize = BUFF_SIZE;
					if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
						INSTALLPROPERTY_VERSION, wcBuf, &dwBufSize))
					{

#else
						TcharToWchar(INSTALLPROPERTY_VERSION, wcTmp), wcBuf, &dwBufSize))
					{
#endif
						if (	wcslen (wcProductPath) +
								wcslen (wcBuf) +
								1 

								< BUFF_SIZE
						   )
						{
							wcscat(wcProductPath, wcBuf);
							wcscat(wcProductPath, L"\"");
							bResult = true;
						}
					}
				}
			}
		}
	}

    return bResult;
    
}

DWORD CreateSoftwareElementString ( MSIHANDLE hDatabase, WCHAR *wcComponent, WCHAR *wcProductCode, WCHAR *wcPath, DWORD * dwPath )
{
    DWORD dwResult		= static_cast < DWORD > ( E_INVALIDARG );
    DWORD dwResultHelp	= static_cast < DWORD > ( S_FALSE );

	#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
	#endif

	if ( wcComponent != NULL && wcComponent [ 0 ] != 0 )
	{
		MSIHANDLE hView		= NULL;
		MSIHANDLE hRecord	= NULL;

		DWORD dwBufSize	= BUFF_SIZE;

		LPWSTR wcBuf	= NULL;
		LPWSTR wcID		= NULL;
		LPWSTR wcQuery	= NULL;

		int iState = 0L;

		DWORD dwPathSize = 0;
		dwPathSize = * dwPath;

		DWORD dwUsed = 1; // last null

		try
		{
			if ( ( wcBuf = new WCHAR [ dwBufSize ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
			if ( ( wcID = new WCHAR [ dwBufSize ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}

			LPCWSTR	wszQuery = L"select distinct `ComponentId` from Component where `Component`=\'";

			DWORD dwQuery = 0L;
			dwQuery = lstrlenW ( wszQuery ) + lstrlenW ( wcComponent ) + 1 + 1;

			if ( ( wcQuery = new WCHAR [ dwQuery ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}

			wcscpy ( wcQuery, wszQuery );
			wcscat ( wcQuery, wcComponent );
			wcscat ( wcQuery, L"\'" );

			if ( ( dwResult = g_fpMsiDatabaseOpenViewW ( hDatabase, wcQuery, &hView ) ) == ERROR_SUCCESS )
			{
				if ( g_fpMsiViewExecute ( hView, 0 ) == ERROR_SUCCESS )
				{
					if ( g_fpMsiViewFetch ( hView, &hRecord ) != ERROR_NO_MORE_ITEMS )
					{
						dwBufSize = BUFF_SIZE;

						BOOL	bContinue = TRUE;
						DWORD	dwContinue= 2;
						do
						{
							if ( ( dwResult = g_fpMsiRecordGetStringW ( hRecord, 1, wcID, &dwBufSize ) ) == ERROR_MORE_DATA )
							{
								delete [] wcID;
								wcID = NULL;

								if ( ( wcID = new WCHAR [ dwBufSize ] ) == NULL )
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								bContinue = FALSE;
							}
						}
						while ( bContinue && dwContinue-- );

						if ( dwResult == ERROR_MORE_DATA )
						{
							dwResult = static_cast < DWORD > ( E_FAIL );
						}

						if ( dwResult == ERROR_SUCCESS && wcProductCode != NULL && wcProductCode [ 0 ] != 0 )
						{
							//Check to make sure it's on the system
							if ( ValidateComponentID ( wcID, wcProductCode ) )
							{
								dwUsed =	dwUsed +
											lstrlenW ( L"Win32_SoftwareElement.Name=\"" ) +
											lstrlenW ( wcComponent ) + 
											lstrlenW ( L"\",SoftwareElementID=\"" ) +
											lstrlenW ( wcID ) +
											lstrlenW ( L"\",SoftwareElementState=" );

								if ( dwUsed > dwPathSize )
								{
									dwResultHelp = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, L"Win32_SoftwareElement.Name=\"");
									wcscat(wcPath, wcComponent);
									wcscat(wcPath, L"\",SoftwareElementID=\"");
									wcscat(wcPath, wcID);
									wcscat(wcPath, L"\",SoftwareElementState=");
								}

								SoftwareElementState (	g_fpMsiGetComponentPathW ( 
																					wcProductCode,
																					wcID,
																					NULL,
																					NULL
																				 ),
														&iState
													 );

								_itow(iState, wcBuf, 10);

								dwUsed =	dwUsed +
											lstrlenW ( wcBuf ) +
											lstrlenW ( L"\",SoftwareElementState=\"" );

								if ( dwUsed > dwPathSize )
								{
									dwResultHelp = ERROR_MORE_DATA;
								}
								else
								{
									wcscat(wcPath, wcBuf);
									wcscat(wcPath, L",TargetOperatingSystem=");
								}

								_itow(GetOS(), wcBuf, 10);

								dwUsed =	dwUsed +
											lstrlenW ( wcBuf ) +
											lstrlenW ( L"\",SoftwareElementState=\"" );

								if ( dwUsed > dwPathSize )
								{
									dwResultHelp = ERROR_MORE_DATA;
								}
								else
								{
									wcscat(wcPath, wcBuf);
									wcscat(wcPath, L",Version=\"");
								}

								dwBufSize = BUFF_SIZE;
								wcBuf [0] = 0;

								bContinue	= TRUE;
								dwContinue	= 2;

								do 
								{
									if ( ( dwResult = g_fpMsiGetProductInfoW	(	wcProductCode,
																					#ifdef	_UNICODE
																					INSTALLPROPERTY_VERSIONSTRING,
																					#else	_UNICODE
																					TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp),
																					#endif	_UNICODE
																					wcBuf,
																					&dwBufSize
																				) 
										 ) == ERROR_MORE_DATA
									   )
									{
										delete [] wcBuf;
										wcBuf = NULL;

										if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize = dwBufSize + 1;
									}
									else
									{
										bContinue = FALSE;
									}
								}
								while ( bContinue && dwContinue-- );

								if ( dwResult == ERROR_MORE_DATA )
								{
									dwResult = static_cast < DWORD > ( E_FAIL );
								}

								if ( dwResult == ERROR_SUCCESS )
								{
									dwUsed =	dwUsed +
												lstrlenW ( wcBuf ) +
												lstrlenW ( L"\"" );

									if ( dwUsed > dwPathSize )
									{
										dwResultHelp = ERROR_MORE_DATA;
									}
									else
									{
										wcscat(wcPath, wcBuf);
										wcscat(wcPath, L"\"");

										dwResult = ERROR_SUCCESS;
									}
								}
							}
							else
							{
								dwResult = static_cast < DWORD > ( E_FAIL );
							}
						}
					}
				}
			}
			else
			{
				if ( dwResult == E_OUTOFMEMORY )
				{
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
		}
		catch ( ... )
		{
			if ( wcBuf )
			{
				delete [] wcBuf;
				wcBuf = NULL;
			}

			if ( wcID )
			{
				delete [] wcID;
				wcID = NULL;
			}

			if ( wcQuery )
			{
				delete [] wcQuery;
				wcQuery = NULL;
			}

			throw;
		}

		if ( wcBuf )
		{
			delete [] wcBuf;
			wcBuf = NULL;
		}

		if ( wcID )
		{
			delete [] wcID;
			wcID = NULL;
		}

		if ( wcQuery )
		{
			delete [] wcQuery;
			wcQuery = NULL;
		}

		g_fpMsiCloseHandle(hRecord);

		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		if ( dwResult == ERROR_SUCCESS && dwResultHelp == ERROR_MORE_DATA )
		{
			( * dwPath ) = ( * dwPath ) + ( dwUsed - dwPathSize );
			wcPath [ 0 ] = 0;

			dwResult = dwResultHelp;
		}
    }

    return dwResult;
}

// string am getting is BUF_SIZE ( statically allocated )
bool CreateSoftwareFeatureString(WCHAR *wcName, WCHAR *wcProductCode, WCHAR * wcString, bool bValidate)
{
    bool bResult = false;
    DWORD dwBufSize;
    WCHAR wcBuf[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif

    if((bValidate) && (!ValidateFeatureName(wcName, wcProductCode))) return bResult;

	// safe operation
    wcscpy(wcString, L"Win32_SoftwareFeature.IdentifyingNumber=\"");

	if (	wcslen ( wcString ) + 
			wcslen ( L"\",Name=\"" ) +
			wcslen ( wcName ) +
			wcslen ( L"\",ProductName=\"" ) 

			< BUFF_SIZE
	   )
	{
		wcscat(wcString, wcProductCode);
		wcscat(wcString, L"\",Name=\"");
		wcscat(wcString, wcName);
		wcscat(wcString, L"\",ProductName=\"");

		dwBufSize = BUFF_SIZE;
		if(g_fpMsiGetProductInfoW(wcProductCode, 
#if defined(_UNICODE)
			INSTALLPROPERTY_PRODUCTNAME,
#else
			TcharToWchar(INSTALLPROPERTY_PRODUCTNAME, wcTmp),
#endif
			wcBuf, &dwBufSize) == ERROR_SUCCESS)
		{
			if (	wcslen (wcString) +
					wcslen (wcBuf) +
					wcslen (L"\",Version=\"") 

					< BUFF_SIZE
			   )
			{
				wcscat(wcString, wcBuf);
				wcscat(wcString, L"\",Version=\"");

				dwBufSize = BUFF_SIZE;
				if(g_fpMsiGetProductInfoW(wcProductCode, 
#if defined(_UNICODE)
					INSTALLPROPERTY_VERSIONSTRING,
#else
					TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp),
#endif
					wcBuf, &dwBufSize) == ERROR_SUCCESS)
				{
					if (	wcslen (wcString) +
							wcslen (wcBuf) +
							1 

							< BUFF_SIZE
					   )
					{
						wcscat(wcString, wcBuf);
						wcscat(wcString, L"\"");
						bResult = true;
					}
				}
				else
				{
					dwBufSize = BUFF_SIZE;
					if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
						INSTALLPROPERTY_VERSION
#else
						TcharToWchar(INSTALLPROPERTY_VERSION, wcTmp)
#endif
						, wcBuf, &dwBufSize))
					{
						if (	wcslen (wcString) +
								wcslen (wcBuf) +
								1 

								< BUFF_SIZE
						   )
						{
							wcscat(wcString, wcBuf);
							wcscat(wcString, L"\"");
							bResult = true;
						}
					}
				}
			}
		}
	}

    return bResult;
}
                        

// simple helper to ask the age old question
// of what OS are we running on, anyway?
bool AreWeOnNT()
{
    OSVERSIONINFO osversion;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    return (osversion.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

int GetOS()
{
    OSVERSIONINFO osversion;
    int iOS = 19;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    if(osversion.dwPlatformId == VER_PLATFORM_WIN32s) iOS = 16;
    else if(osversion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS){

        if(osversion.dwMinorVersion == 0) iOS = 17;
        else iOS = 18;
    }

    return iOS;
}

bool IsNT4()
{
    OSVERSIONINFO osversion;
    int iOS = 19;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    return osversion.dwMajorVersion == 4;
}

bool IsNT5()
{
    OSVERSIONINFO osversion;
    int iOS = 19;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    return osversion.dwMajorVersion == 5;
}

// checks impersonation level
// impersonates client if allowed
HRESULT CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if(AreWeOnNT()){

        if(SUCCEEDED(CoImpersonateClient())){

            // Now, let's check the impersonation level.  First, get the thread token
            HANDLE hThreadTok;
            DWORD dwImp, dwBytesReturned;

            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok )){

                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN){

                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                
				}else{
                
					// If we failed to get the thread token for any other reason, an error.
                    hr = WBEM_E_ACCESS_DENIED;
                }

            }else{

                if(GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwImp,
                    sizeof(DWORD), &dwBytesReturned)){

                    // Is the impersonation level Impersonate?
                    if (dwImp >= SecurityImpersonation) hr = WBEM_S_NO_ERROR;
                    else hr = WBEM_E_ACCESS_DENIED;

            }else hr = WBEM_E_FAILED;

                CloseHandle(hThreadTok);
            }

			if (FAILED(hr))
			{
				CoRevertToSelf();
			}
        }

    }else
        // let win9X in...
        hr = WBEM_S_NO_ERROR;

    return hr;
}

bool ValidateComponentID(WCHAR *wcID, WCHAR *wcProductCode)
{
    int i = 0;

    WCHAR * wcBuf = (WCHAR *)malloc(BUFF_SIZE * sizeof(WCHAR));
    if(!wcBuf)
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    DWORD dwBufSize;
    UINT uiStatus;
    INSTALLSTATE isInstalled;
    bool bRetVal = false;

	dwBufSize = BUFF_SIZE;
	isInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcID, wcBuf, &dwBufSize);

	// this lines are added for backward compatability ( ! INSTALLSTATE_NOTUSED )

	if( isInstalled == INSTALLSTATE_LOCAL ||
		isInstalled == INSTALLSTATE_SOURCE ||
		isInstalled == INSTALLSTATE_SOURCEABSENT ||
		isInstalled == INSTALLSTATE_UNKNOWN ||
		isInstalled == INSTALLSTATE_ABSENT 
	  )
	{
		bRetVal = true;
	}

    free((void *)wcBuf);

    return bRetVal;
}

bool ValidateComponentName ( MSIHANDLE hDatabase, WCHAR *wcProductCode, WCHAR *wcName )
{
    bool bResult = false;

	if ( wcName != NULL )
	{
		MSIHANDLE hView		= NULL;
		MSIHANDLE hRecord	= NULL;

		LPWSTR	wcQuery	= NULL;
		LPWSTR	wcBuf	= NULL;

		LPCWSTR wszQuery = L"select distinct `ComponentId` from Component where `Component`=\'";

		DWORD	dwBuf	= BUFF_SIZE;
		DWORD	dwQuery = 0L;
		dwQuery = wcslen ( wszQuery ) + wcslen ( wcName ) + 1 + 1;

		if ( ( wcQuery = new WCHAR [ dwQuery ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		try
		{
			wcscpy ( wcQuery, wszQuery );
			wcscat ( wcQuery, wcName );
			wcscat ( wcQuery, L"\'" );
		}
		catch ( ... )
		{
			delete [] wcQuery;
			wcQuery = NULL;

			throw;
		}

		try
		{
			if ( ( wcBuf = new WCHAR [ dwBuf ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch ( ... )
		{
			delete [] wcQuery;
			wcQuery = NULL;

			throw;
		}

		HRESULT hRes = S_OK;

        if ( ERROR_SUCCESS == ( hRes = g_fpMsiDatabaseOpenViewW ( hDatabase, wcQuery, &hView ) ) )
		{
            if ( ERROR_SUCCESS == g_fpMsiViewExecute ( hView, 0 ) )
			{
                if ( ERROR_NO_MORE_ITEMS != ( hRes = g_fpMsiViewFetch ( hView, &hRecord ) ) )
				{
                    if ( E_OUTOFMEMORY == hRes )
					{
                        g_fpMsiCloseHandle(hRecord);

                        g_fpMsiViewClose(hView);
                        g_fpMsiCloseHandle(hView);

                        delete [] wcBuf;
                        delete [] wcQuery;

                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                    }

                    if ( ERROR_SUCCESS == g_fpMsiRecordGetStringW ( hRecord, 1, wcBuf, &dwBuf ) )
					{
						//Check to make sure it's on the system
						bResult = ValidateComponentID ( wcBuf, wcProductCode );
					}

                    g_fpMsiCloseHandle(hRecord);
                }
            }

            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

        }
		else
		{
			if ( E_OUTOFMEMORY == hRes )
			{
				delete [] wcBuf;
				delete [] wcQuery;

				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
        }

		delete [] wcBuf;
		delete [] wcQuery;
    }

    return bResult;
}

bool ValidateFeatureName(WCHAR *wcName, WCHAR *wcProduct)
{
    int i = 0;
    bool bRetVal = false;
    WCHAR * wcBuf = (WCHAR *)malloc(BUFF_SIZE * sizeof(WCHAR));
    if(!wcBuf)
	{
		wcBuf = NULL;
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    WCHAR * wcParent = (WCHAR *)malloc(BUFF_SIZE * sizeof(WCHAR));
    if(!wcParent)
	{
		free ( wcBuf );
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    UINT uiStatus;

    while((uiStatus = g_fpMsiEnumFeaturesW(wcProduct, i++, wcBuf, wcParent)) != ERROR_NO_MORE_ITEMS){

        if(uiStatus != S_OK){
            bRetVal = false;
            break;
        }

        if(wcscmp(wcName, wcBuf) == 0){
            bRetVal = true;
            break;
        }
    }

    free((void *)wcBuf);
    free((void *)wcParent);

    return bRetVal;
}

bool SafeLeaveCriticalSection(CRITICAL_SECTION *pcs)
{
    void * vpOwner = pcs->OwningThread;
    DWORD dwOwner = PtrToUlong(vpOwner);

    if((pcs->LockCount > -1) && (dwOwner == GetCurrentThreadId()))
        LeaveCriticalSection(pcs);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\writeregistry.cpp ===
// WriteRegistry.cpp: implementation of the CWriteRegistry class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WriteRegistry.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegistryAction::CRegistryAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CRegistryAction::~CRegistryAction()
{

}

HRESULT CRegistryAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE * 4];
    WCHAR wcProductCode[39];
    WCHAR wcID[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    INSTALLSTATE piInstalled;
    int iState;

    SetSinglePropertyPath(L"ActionID");

	//improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Registry`, `Component_`, `Root`, `Key`, `Name`, `Value` from Registry" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Registry`=\'", wcAction, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

	LPWSTR Buffer = NULL;
	LPWSTR dynBuffer = NULL;

	DWORD dwDynBuffer = 0L;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database
            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Registry", FALSE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE * 4;
						GetBufferToPut ( hRecord, 1, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pRegistry, Buffer);
                        PutProperty(m_pObj, pDescription, Buffer);
                        PutProperty(m_pObj, pCaption, Buffer);

						PutKeyProperty ( m_pObj, pActionID, Buffer, &bActionID, m_pRequest, 1, wcProductCode );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                    //====================================================

                        PutProperty(m_pObj, pRoot, g_fpMsiRecordGetInteger(hRecord, 3));

                        dwBufSize = BUFF_SIZE * 4;
						PutPropertySpecial ( hRecord, 4, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pKey );

                        dwBufSize = BUFF_SIZE * 4;
						PutPropertySpecial ( hRecord, 5, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pEntryName );

                        dwBufSize = BUFF_SIZE * 4;
						PutPropertySpecial ( hRecord, 6, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, pEntryValue );

                        dwBufSize = BUFF_SIZE * 4;
						GetBufferToPut ( hRecord, 2, dwBufSize, wcBuf, dwDynBuffer, dynBuffer, Buffer );

                        PutProperty(m_pObj, pName, Buffer);

						// make query on fly
						wcQuery1.Append ( 2, Buffer, L"\'" );

						if ( dynBuffer && dynBuffer [ 0 ] != 0 )
						{
							dynBuffer [ 0 ] = 0;
						}

                        if(ERROR_SUCCESS == g_fpMsiDatabaseOpenViewW( msidata.GetDatabase (), wcQuery1, &hSEView ))
						{
                            if(ERROR_SUCCESS == g_fpMsiViewExecute(hSEView, 0)){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                                    dwBufSize = BUFF_SIZE * 4;
									GetBufferToPut ( hSERecord, 1, dwBufSize, wcID, dwDynBuffer, dynBuffer, Buffer );

                                    if ( ValidateComponentID ( Buffer, wcProductCode ) )
									{
                                        PutProperty(m_pObj, pSoftwareElementID, Buffer);

                                        dwBufSize = BUFF_SIZE * 4;
                                        wcBuf [ 0 ] = 0;
                                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, Buffer, wcBuf, &dwBufSize);

										if ( dynBuffer && dynBuffer [ 0 ] != 0 )
										{
											dynBuffer [ 0 ] = 0;
										}

                                        SoftwareElementState(piInstalled, &iState);
                                        PutProperty(m_pObj, pSoftwareElementState, iState);
                                        PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

                                        dwBufSize = BUFF_SIZE * 4;
                                        CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct (), L"ProductVersion", wcBuf, &dwBufSize));
                                        PutProperty(m_pObj, pVersion, wcBuf);
                                    //----------------------------------------------------

                                        if(bActionID) bMatch = true;

                                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                                            hr = pHandler->Indicate(1, &m_pObj);
                                        }
                                    }
									else
									{
										if ( dynBuffer && dynBuffer [ 0 ] != 0 )
										{
											dynBuffer [ 0 ] = 0;
										}
									}
                                
                                }catch(...){

                                    g_fpMsiViewClose(hSEView);
                                    g_fpMsiCloseHandle(hSEView);
                                    g_fpMsiCloseHandle(hSERecord);
                                    throw;
                                }

                                g_fpMsiViewClose(hSEView);
                                g_fpMsiCloseHandle(hSEView);
                                g_fpMsiCloseHandle(hSERecord);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
				if ( dynBuffer )
				{
					delete [] dynBuffer;
					dynBuffer = NULL;
				}

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
				msidata.CloseProduct ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
			msidata.CloseProduct ();
        }
    }

    if ( dynBuffer )
	{
		delete [] dynBuffer;
		dynBuffer = NULL;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\msiprovider\dll\writeregistry.h ===
// WriteRegistry.h: interface for the CWriteRegistry class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WRITEREGISTRY_H__DB614F31_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_WRITEREGISTRY_H__DB614F31_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CRegistryAction : public CGenericClass  
{
public:
	CRegistryAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CRegistryAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_WRITEREGISTRY_H__DB614F31_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\analyser.cpp ===
//******************************************************************************

//

//  ANALYSER.CPP

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "analyser.h"

HRESULT CQueryAnalyser::GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*> ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutProperty(Token, PropName))
            {
                pNew->AddToken(Token);
            }
            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;
        
        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;            
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }
        
    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();
    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName)
{
    CPropertyName& TokenPropName = Token.PropertyName;

    if(PropName.GetNumElements() != TokenPropName.GetNumElements())
        return FALSE;

    for(int i = 0; i < PropName.GetNumElements(); i++)
    {
        LPCWSTR wszPropElement = PropName.GetStringAt(i);
        LPCWSTR wszTokenElement = TokenPropName.GetStringAt(i);

        if(wszPropElement == NULL || wszTokenElement == NULL)
            return FALSE;

        if(_wcsicmp(wszPropElement, wszTokenElement))
            return FALSE;
    }

    return TRUE;
}

void CQueryAnalyser::AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        pDest->AddToken(pSource->pArrayOfTokens[i]);
    }
}

HRESULT CQueryAnalyser::AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If either one is NULL (false), the result is NULL
    // =================================================

    if(pFirst == NULL || pSecond == NULL)
        return WBEM_S_FALSE;
        
    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_AND;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If both are NULL (false) so is the result
    // =========================================

    if(pFirst == NULL && pSecond == NULL)
        return WBEM_S_FALSE;

    // If one is NULL (false) return the other
    // =======================================

    if(pFirst == NULL)
    { 
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond == NULL)
    { 
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // If either one is empty, so is the result
    // ========================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- or together
    // ==============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_OR;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}
    
HRESULT CQueryAnalyser::GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CStringArray& awsVals)
{
    awsVals.RemoveAll();

    // Get the necessary query
    // =======================

    QL_LEVEL_1_RPN_EXPRESSION* pPropExpr;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, 
                            PropName, pPropExpr);
    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        if(Token.nTokenType == QL1_NOT)
        {
            delete pPropExpr;
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
        else if(Token.nTokenType == QL1_AND || Token.nTokenType == QL1_OR)
        {
            // We treat them all as ORs
            // ========================
        }
        else    
        {
            // This is a token
            // ===============

            if(Token.nOperator != QL1_OPERATOR_EQUALS)
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }

            if(V_VT(&Token.vConstValue) != VT_BSTR)
            {
                delete pPropExpr;
                return WBEM_E_INVALID_QUERY;
            }

            // This token is a string equality. Add the string to the list
            // ===========================================================

            awsVals.Add(V_BSTR(&Token.vConstValue));
        }
    }

    delete pPropExpr;
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#include <stack>
#include <provtempl.h>

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\analyser.h ===
//******************************************************************************

//

//  ANALYSER.H

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//******************************************************************************
#ifndef __WBEM_ANALYSER__H_
#define __WBEM_ANALYSER__H_

#include <wbemidl.h>
#include <ql.h>

typedef CArray<CString, LPCWSTR> CStringArray;

class CQueryAnalyser
{
public:
    static HRESULT GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
	static HRESULT GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CStringArray& awsVals);

protected:
    static BOOL IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName);
    static void AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource);
    static HRESULT AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT NegateQueryExpression(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            OUT QL_LEVEL_1_RPN_EXPRESSION* pNewExpr);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\qllex.h ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QLLEX.CH

Abstract:

	QL Level 1 DFA Table & Tokens

History:

	raymcc    24-Jun-95       Created.

--*/

#ifndef _QLLEX_H_

#include <genlex.h>
#define QL_1_TOK_EOF       0
#define QL_1_TOK_ERROR     1
#define QL_1_TOK_IDENT     100
#define QL_1_TOK_QSTRING   101
#define QL_1_TOK_INT       102
#define QL_1_TOK_REAL      103
#define QL_1_TOK_CHAR      104

#define QL_1_TOK_LE        105
#define QL_1_TOK_LT        106
#define QL_1_TOK_GE        107
#define QL_1_TOK_GT        108
#define QL_1_TOK_EQ        109
#define QL_1_TOK_NE        110

#define QL_1_TOK_DOT           111
#define QL_1_TOK_OPEN_PAREN    112
#define QL_1_TOK_CLOSE_PAREN   113
#define QL_1_TOK_ASTERISK      114
#define QL_1_TOK_COMMA         115

#define QL_1_TOK_SELECT        120
#define QL_1_TOK_WHERE         121
#define QL_1_TOK_FROM          122
#define QL_1_TOK_LIKE          123
#define QL_1_TOK_OR            124
#define QL_1_TOK_AND           125
#define QL_1_TOK_NOT           126
#define QL_1_TOK_IS            127
#define QL_1_TOK_NULL          128
#define QL_1_TOK_WITHIN        129
#define QL_1_TOK_ISA           130
#define QL_1_TOK_GROUP         131
#define QL_1_TOK_BY            132
#define QL_1_TOK_HAVING        133

#define QL_1_TOK_TRUE        140
#define QL_1_TOK_FALSE        141

extern LexEl Ql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\ql.h ===
/*++



Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QL.H

Abstract:

	Level 1 Syntax QL Parser

	Implements the syntax described in QL.BNF.  This translates the input
	into an RPN stream of tokens.

History:

	a-raymcc, a-tomasp    21-Jun-96       Created.

--*/

#ifndef _QL__H_
#define _QL__H_
#include <wbemidl.h>
#include <wbemint.h>
#include <qllex.h>

#define DELETE_ME

class CPropertyName : public WBEM_PROPERTY_NAME
{
protected:
    long m_lAllocated;

    void EnsureAllocated(long lElements);
public:
    void Init();
    CPropertyName() {Init();}
    CPropertyName(const CPropertyName& Other);
    void operator=(const CPropertyName& Other);
    void operator=(const WBEM_PROPERTY_NAME& Other);
    BOOL operator==(const WBEM_PROPERTY_NAME& Other);

    void Empty();
    ~CPropertyName() {Empty();}

    long GetNumElements() const {return m_lNumElements;}
    LPCWSTR GetStringAt(long lIndex) const;
    void AddElement(LPCWSTR wszElement);
    DELETE_ME LPWSTR GetText();
};

class  CQl1ParseSink
{
public:
    virtual void SetClassName(LPCWSTR wszClass) = 0;
    virtual void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance) = 0;
    virtual void AddToken(const WBEM_QL1_TOKEN& Token) = 0;
    virtual void AddProperty(const CPropertyName& Property) = 0;
    virtual void AddAllProperties() = 0;

    virtual void SetAggregated() = 0;
    virtual void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance)= 0;
    virtual void AddAggregationProperty(const CPropertyName& Property) = 0;
    virtual void AddAllAggregationProperties() = 0;
    virtual void AddHavingToken(const WBEM_QL1_TOKEN& Token) = 0;

    virtual void InOrder(long lOp){}
};

class CAbstractQl1Parser
{
protected:
    // Controls keyword parsing in Next().
    // ===================================
    enum { 
        NO_KEYWORDS = 0,
        ALL_KEYWORDS,
        EXCLUDE_GROUP_KEYWORD,
        EXCLUDE_EXPRESSION_KEYWORDS
        };

    CQl1ParseSink* m_pSink;
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    BOOL       m_bQuoted;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    CPropertyName m_PropertyName;
    BOOL       m_bInAggregation;
    CPropertyName m_PropertyName2;
    BOOL       m_bPropComp;
        
    // Parsing functions.
    // ==================
    virtual BOOL Next(int nFlags = ALL_KEYWORDS);
    LPCWSTR GetSinglePropertyName();
    void DeletePropertyName();
    int FlipOperator(int nOp);
    void AddAppropriateToken(const WBEM_QL1_TOKEN& Token);

    int parse_property_name(CPropertyName& Prop);
    
    int parse(int nFlags);

    int prop_list();
    int class_name();
    int tolerance();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int trailing_ident_expr();
    int unknown_func_expr();
    int typed_constant();
    int opt_aggregation();
    int aggregation_params();
    int aggregate_by();
    int aggregate_within();
    int opt_having();

    static DWORD TranslateIntrinsic(LPCWSTR pFuncName);
    static void InitToken(WBEM_QL1_TOKEN* pToken);
public:
    enum { 
        SUCCESS = 0,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    enum {
        FULL_PARSE = 0,
        NO_WHERE,
        JUST_WHERE
    };

    CAbstractQl1Parser(CGenLexSource *pSrc);
    virtual ~CAbstractQl1Parser();

    int Parse(CQl1ParseSink* pSink, int nFlags);
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
};



struct QL_LEVEL_1_TOKEN
{
    enum 
    { 
        OP_EXPRESSION = QL1_OP_EXPRESSION, 
        TOKEN_AND = QL1_AND, 
        TOKEN_OR = QL1_OR, 
        TOKEN_NOT = QL1_NOT
    };
    enum 
    { 
        IFUNC_NONE = QL1_FUNCTION_NONE, 
        IFUNC_UPPER = QL1_FUNCTION_UPPER, 
        IFUNC_LOWER = QL1_FUNCTION_LOWER 
    };    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum 
    { 
        OP_EQUAL = QL1_OPERATOR_EQUALS, 
        OP_NOT_EQUAL = QL1_OPERATOR_NOTEQUALS, 
        OP_EQUALorGREATERTHAN = QL1_OPERATOR_GREATEROREQUALS,
		OP_EQUALorLESSTHAN = QL1_OPERATOR_LESSOREQUALS, 
        OP_LESSTHAN = QL1_OPERATOR_LESS, 
        OP_GREATERTHAN = QL1_OPERATOR_GREATER, 
        OP_LIKE  = QL1_OPERATOR_LIKE
    };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    CPropertyName PropertyName;  
                   // Name of the property on which the operator is applied
    int     nOperator;      // Operator that is applied on property
    VARIANT vConstValue;    // Value applied by operator
    BOOL bQuoted; // FALSE if the string should not have quotes around it.

    CPropertyName PropertyName2; // Property to compare, if applicable.
    BOOL m_bPropComp;        // TRUE if this is a property-to-property compare.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "

    QL_LEVEL_1_TOKEN();
    QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN&);
   ~QL_LEVEL_1_TOKEN(); 
    QL_LEVEL_1_TOKEN& operator=(const QL_LEVEL_1_TOKEN &Src);
    QL_LEVEL_1_TOKEN& operator=(const WBEM_QL1_TOKEN &Src);
    
    DELETE_ME LPWSTR GetText();
};


// Contains RPN version of expression.
// ===================================

struct QL_LEVEL_1_RPN_EXPRESSION : public CQl1ParseSink
{
    int nNumTokens;
    int nCurSize;
    QL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;
    WBEM_QL1_TOLERANCE Tolerance;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
    BOOL bStar;
	CPropertyName *pRequestedPropertyNames;  
                // Array of property names which values are to be returned if
    
    BOOL bAggregated;
    WBEM_QL1_TOLERANCE AggregationTolerance;
    BOOL bAggregateAll;
    int nNumAggregatedProperties;   
    int nCurAggPropSize;
	CPropertyName *pAggregatedPropertyNames;  

    int nNumHavingTokens;
    int nCurHavingSize;
    QL_LEVEL_1_TOKEN *pArrayOfHavingTokens;
    
    long lRefCount;

    QL_LEVEL_1_RPN_EXPRESSION();
    QL_LEVEL_1_RPN_EXPRESSION(const QL_LEVEL_1_RPN_EXPRESSION& Other);
   ~QL_LEVEL_1_RPN_EXPRESSION();    
    void AddRef();
    void Release();

    void SetClassName(LPCWSTR wszName);
    void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddToken(const WBEM_QL1_TOKEN& Tok);
    void AddToken(const QL_LEVEL_1_TOKEN& Tok);
    void AddProperty(const CPropertyName& Prop);
    void AddAllProperties();

    void SetAggregated();
    void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddAggregationProperty(const CPropertyName& Property);
    void AddAllAggregationProperties();
    void AddHavingToken(const WBEM_QL1_TOKEN& Tok);

    DELETE_ME LPWSTR GetText();
};


class QL1_Parser : public CAbstractQl1Parser
{
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpression;
    BOOL m_bPartiallyParsed;

public:
    QL1_Parser(CGenLexSource *pSrc);
   ~QL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput);
    static LPWSTR ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
        LPCWSTR wszClassName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the gloabal dll functions

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "precomp.h"

#include <olectl.h>

//OK we need these globals
HINSTANCE   g_hInst = NULL;
CEventProviderManager* g_pMgr = NULL;
CCriticalSection g_ProvLock;
ProvDebugLog* CNTEventProvider::g_NTEvtDebugLog = ProvDebugLog::GetProvDebugLog(LOG_EVTPROV);
CDllMap CEventlogRecord::sm_dllMap;
CSIDMap CEventlogRecord::sm_usersMap;
CMutex* CNTEventProvider::g_secMutex = NULL;
PSID CNTEventProvider::s_NetworkServiceSid = NULL;
PSID CNTEventProvider::s_LocalServiceSid = NULL;
PSID CNTEventProvider::s_AliasBackupOpsSid = NULL;
PSID CNTEventProvider::s_AliasSystemOpsSid = NULL;
PSID CNTEventProvider::s_AliasGuestsSid = NULL;
PSID CNTEventProvider::s_LocalSystemSid = NULL;
PSID CNTEventProvider::s_AliasAdminsSid = NULL;
PSID CNTEventProvider::s_AnonymousLogonSid = NULL;
PSID CNTEventProvider::s_WorldSid = NULL;
IWbemClassObject *WbemTaskObject::g_ClassArray[] = { NULL, NULL, NULL, NULL, NULL };

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

    HINSTANCE hInstance, 
    ULONG ulReason , 
    LPVOID pvReserved
)
{
    SetStructuredExceptionHandler seh;
    BOOL status = TRUE ;

    try
    {

        if ( DLL_PROCESS_DETACH == ulReason )
        {
        }
        else if ( DLL_PROCESS_ATTACH == ulReason )
        {
            g_hInst=hInstance;
            DisableThreadLibraryCalls(hInstance);
        }
        else if ( DLL_THREAD_DETACH == ulReason )
        {
        }
        else if ( DLL_THREAD_ATTACH == ulReason )
        {
        }

    }
    catch(Structured_Exception e_SE)
    {
        status = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        status = FALSE;
    }
    catch(...)
    {
        status = FALSE;
    }

    return status;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

    REFCLSID rclsid , 
    REFIID riid, 
    void **ppv 
)
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        if (g_ProvLock.Lock())
        {
            if ( rclsid == CLSID_CNTEventProviderClassFactory ) 
            {
                CNTEventlogEventProviderClassFactory *lpunk = new CNTEventlogEventProviderClassFactory;

                if ( lpunk == NULL )
                {
                    status = E_OUTOFMEMORY ;
                }
                else
                {
                    status = lpunk->QueryInterface ( riid , ppv ) ;

                    if ( FAILED ( status ) )
                    {
                        delete lpunk ;              
                    }
                }
            }
            else if ( rclsid == CLSID_CNTEventInstanceProviderClassFactory ) 
            {
                CNTEventlogInstanceProviderClassFactory *lpunk = new CNTEventlogInstanceProviderClassFactory;

                if ( lpunk == NULL )
                {
                    status = E_OUTOFMEMORY ;
                }
                else
                {
                    status = lpunk->QueryInterface ( riid , ppv ) ;

                    if ( FAILED ( status ) )
                    {
                        delete lpunk ;              
                    }
                }
            }
            else
            {
                status = CLASS_E_CLASSNOTAVAILABLE ;
            }

            g_ProvLock.Unlock();
        }
        else
        {
            status = E_UNEXPECTED ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

    return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
    BOOL unload = FALSE;
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        if (g_ProvLock.Lock())
        {
            unload = (0 == CNTEventProviderClassFactory :: locksInProgress)
                            && (0 == CNTEventProviderClassFactory :: objectsInProgress);

            if (unload)
            {
				for (DWORD i = 0; i < NT_EVTLOG_MAX_CLASSES; i++)
				{
					if (WbemTaskObject::g_ClassArray[i])
					{
						WbemTaskObject::g_ClassArray[i]->Release();
						WbemTaskObject::g_ClassArray[i] = NULL;
					}
				}

                CEventlogRecord::EmptyDllMap();
                CEventlogRecord::EmptyUsersMap();
                delete g_pMgr;
                g_pMgr = NULL;
				CNTEventProvider::FreeGlobalSIDs();


                if (CNTEventProvider::g_secMutex != NULL)
                {
                    delete CNTEventProvider::g_secMutex;
                    CNTEventProvider::g_secMutex = NULL;
                }

            }

            g_ProvLock.Unlock();
        }
    }
    catch(Structured_Exception e_SE)
    {
        unload = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        unload = FALSE;
    }
    catch(...)
    {
        unload = FALSE;
    }

    return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

//Strings used during self registeration

#define REG_FORMAT2_STR         L"%s%s"
#define REG_FORMAT3_STR         L"%s%s\\%s"
#define VER_IND_STR             L"VersionIndependentProgID"
#define NOT_INTERT_STR          L"NotInsertable"
#define INPROC32_STR            L"InprocServer32"
#define PROGID_STR              L"ProgID"
#define THREADING_MODULE_STR    L"ThreadingModel"
#define APARTMENT_STR           L"Both"

#define CLSID_STR               L"CLSID\\"

#define PROVIDER_NAME_STR       L"Microsoft WBEM NT Eventlog Event Provider"
#define PROVIDER_STR            L"WBEM.NT.EVENTLOG.EVENT.PROVIDER"
#define H_PROVIDER_STR          L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.EVENT.PROVIDER"
#define PROVIDER_CVER_STR       L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.EVENT.PROVIDER\\CurVer"
#define PROVIDER_CLSID_STR      L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.EVENT.PROVIDER\\CLSID"
#define PROVIDER_VER_CLSID_STR  L"WBEM.NT.EVENTLOG.EVENT.PROVIDER.0\\CLSID"
#define PROVIDER_VER_STR        L"WBEM.NT.EVENTLOG.EVENT.PROVIDER.0"
#define H_PROVIDER_VER_STR      L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.EVENT.PROVIDER.0"

#define INST_PROVIDER_NAME_STR      L"Microsoft WBEM NT Eventlog Instance Provider"
#define INST_PROVIDER_STR           L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER"
#define H_INST_PROVIDER_STR         L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.INSTANCE.PROVIDER"
#define INST_PROVIDER_CVER_STR      L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.INSTANCE.PROVIDER\\CurVer"
#define INST_PROVIDER_CLSID_STR     L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.INSTANCE.PROVIDER\\CLSID"
#define INST_PROVIDER_VER_CLSID_STR L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0\\CLSID"
#define INST_PROVIDER_VER_STR       L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0"
#define H_INST_PROVIDER_VER_STR     L"SOFTWARE\\Classes\\WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0"


/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

    StringCchCopyW ( szKey, 256, HKEYCLASSES );
    if ( FAILED ( StringCchCatW ( szKey, 256, pszKey ) ) )
	{
		return FALSE;
	}

    if (NULL!=pszSubkey)
    {
        if ( FAILED ( StringCchCatW ( szKey, 256, L"\\") ) )
		{
			return FALSE;
		}

        if ( FAILED ( StringCchCatW ( szKey, 256, pszSubkey ) ) )
		{
			return FALSE;
		}
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
            return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer()
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        wchar_t szModule[MAX_PATH + 1];
        DWORD t_Status = GetModuleFileName(g_hInst,(wchar_t*)szModule, MAX_PATH + 1);
		if ( t_Status == 0 )
		{
			return E_UNEXPECTED ;
		}

        wchar_t szProviderClassID[128];
        wchar_t szProviderCLSIDClassID[128];
        StringFromGUID2(CLSID_CNTEventProviderClassFactory,szProviderClassID, 128);

        StringCchCopyW ( szProviderCLSIDClassID, 128, CLSID_STR );
        if ( FAILED ( StringCchCatW ( szProviderCLSIDClassID, 128, szProviderClassID ) ) )
		{
			return SELFREG_E_CLASS;
		}

            //Create entries under CLSID
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
            return SELFREG_E_CLASS;

        wchar_t szInstProviderClassID[128];
        wchar_t szInstProviderCLSIDClassID[128];
        StringFromGUID2(CLSID_CNTEventInstanceProviderClassFactory,szInstProviderClassID, 128);

        StringCchCopyW ( szInstProviderCLSIDClassID, 128, CLSID_STR );
        if ( FAILED ( StringCchCatW ( szInstProviderCLSIDClassID, 128, szInstProviderClassID ) ) )
		{
			return SELFREG_E_CLASS;
		}

            //Create entries under CLSID
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, NULL, NULL, INST_PROVIDER_NAME_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, PROGID_STR, NULL, INST_PROVIDER_VER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, VER_IND_STR, NULL, INST_PROVIDER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
            return SELFREG_E_CLASS;
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

    return status ;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        wchar_t szTemp[128];
        wchar_t szProviderClassID[128];
        wchar_t szProviderCLSIDClassID[128];

        //event provider
        StringFromGUID2(CLSID_CNTEventProviderClassFactory,szProviderClassID, 128);

        StringCchCopyW ( szProviderCLSIDClassID, 128, CLSID_STR );
        if ( FAILED ( StringCchCatW ( szProviderCLSIDClassID, 128, szProviderClassID ) ) )
		{
			return SELFREG_E_CLASS ;
		}

        //Delete ProgID keys
        RegDeleteKey(HKEY_LOCAL_MACHINE, PROVIDER_CVER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, PROVIDER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, H_PROVIDER_STR);

        //Delete VersionIndependentProgID keys
        RegDeleteKey(HKEY_LOCAL_MACHINE, PROVIDER_VER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, H_PROVIDER_VER_STR);

        //Delete entries under CLSID

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, PROGID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, VER_IND_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, NOT_INTERT_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, INPROC32_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT2_STR, HKEYCLASSES, szProviderCLSIDClassID);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wchar_t szInstProviderClassID[128];
        wchar_t szInstProviderCLSIDClassID[128];

        //instance provider
        StringFromGUID2(CLSID_CNTEventInstanceProviderClassFactory, szInstProviderClassID, 128);

        StringCchCopyW ( szInstProviderCLSIDClassID, 128, CLSID_STR );
        if ( FAILED ( StringCchCatW ( szInstProviderCLSIDClassID, 128, szInstProviderClassID ) ) )
		{
			return SELFREG_E_CLASS ;
		}

        //Delete ProgID keys
        RegDeleteKey(HKEY_LOCAL_MACHINE, INST_PROVIDER_CVER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, INST_PROVIDER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, H_INST_PROVIDER_STR);

        //Delete VersionIndependentProgID keys
        RegDeleteKey(HKEY_LOCAL_MACHINE, INST_PROVIDER_VER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, H_INST_PROVIDER_VER_STR);

        //Delete entries under CLSID

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, PROGID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, VER_IND_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, NOT_INTERT_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, INPROC32_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        StringCchPrintf(szTemp, 128, REG_FORMAT2_STR, HKEYCLASSES, szInstProviderCLSIDClassID);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

    return status ;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\ql.cpp ===
/*++



Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QL.CPP

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL_1.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    a-raymcc    21-Jun-96       Created.
    mdavis      23-Apr-99       Changed to allow 'group' as a property name
                              for Raid 47767.  Also fixed GetText() for
                              property comparisons and improved Dump().

--*/

#include "precomp.h"
#include <stdio.h>
#include <errno.h>

#include <math.h>

#include <strutils.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <ASSERT.H >

LPWSTR WbemStringCopy(LPCWSTR wsz)
{
    if(wsz == NULL)
        return NULL;

	DWORD cchSize = wcslen(wsz)+1;
    LPWSTR wszNew = new WCHAR[cchSize];
    if(wszNew == NULL)
        return NULL;

    StringCchCopyW(wszNew, cchSize,wsz);
    return wszNew;
}

void WbemStringFree(LPWSTR wsz)
{
	if ( wsz )
	{
		delete [] wsz;
		wsz = NULL;
	}
}


#define trace(x)

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadI64(LPCWSTR wsz, __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }
        
        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}

//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadUI64(LPCWSTR wsz, unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}


//***************************************************************************
//
//  WCHARToDOUBLE
//
//  Converts a wchar to a double, but does it using the english locale rather
//  than whatever local the process is running in.  This allows us to support
//  all english queries even on German machines.
//
//***************************************************************************

DOUBLE WCHARToDOUBLE(WCHAR * pConv, bool & bSuccess)
{
    bSuccess = false;
    if(pConv == NULL)
        return 0.0;

    VARIANT varTo, varFrom;
    VariantInit(&varTo);
    varFrom.vt = VT_BSTR;
    varFrom.bstrVal = SysAllocString(pConv);
    if(varFrom.bstrVal == NULL)
        return 0.0;
    SCODE sc = VariantChangeTypeEx(&varTo, &varFrom, 0x409, 0, VT_R8);
    VariantClear(&varFrom);
    if(sc == S_OK)
        bSuccess = true;
    return varTo.dblVal;
}

CPropertyName::CPropertyName(const CPropertyName& Other)
{
    Init();
    *this = Other;
}

void CPropertyName::Init()
{
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_aElements = NULL;
}

void CPropertyName::operator=(const CPropertyName& Other)
{
    *this = (const WBEM_PROPERTY_NAME&)Other;
}

void CPropertyName::operator=(const WBEM_PROPERTY_NAME& Other)
{
    Empty();

	if(Other.m_lNumElements > 0)
	{
        m_aElements = new WBEM_NAME_ELEMENT[Other.m_lNumElements];
	}

	// init property name to be NULL before real work
	for ( long l = 0; l < Other.m_lNumElements; l++ )
	{
		if ( Other.m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY )
		{
			m_aElements[l].Element.m_wszPropertyName = NULL;
		}
	}

    m_lNumElements = Other.m_lNumElements;
    m_lAllocated = m_lNumElements;

	for ( l = 0; l < m_lNumElements; l++ )
	{
		m_aElements[l].m_nType = Other.m_aElements[l].m_nType;
		if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
		{
			m_aElements[l].Element.m_wszPropertyName =
				WbemStringCopy(Other.m_aElements[l].Element.m_wszPropertyName);
		}
		else
		{
			m_aElements[l].Element.m_lArrayIndex =
				Other.m_aElements[l].Element.m_lArrayIndex;
		}
	}
}

BOOL CPropertyName::operator==(const WBEM_PROPERTY_NAME& Other)
{
    if(m_lNumElements != Other.m_lNumElements)
        return FALSE;

    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType != Other.m_aElements[l].m_nType)
            return FALSE;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            if(wbem_wcsicmp(m_aElements[l].Element.m_wszPropertyName,
                        Other.m_aElements[l].Element.m_wszPropertyName))
            {
                return FALSE;
            }
        }
        else
        {
            if(m_aElements[l].Element.m_lArrayIndex !=
                Other.m_aElements[l].Element.m_lArrayIndex)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

void CPropertyName::Empty()
{
	if ( m_aElements )
	{
		for(long l = 0; l < m_lNumElements; l++)
		{
			if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
			{
				WbemStringFree(m_aElements[l].Element.m_wszPropertyName);
			}
		}

		delete [] m_aElements;
		m_aElements = NULL;
	}

    m_lNumElements = 0;
    m_lAllocated = 0;
}

LPCWSTR CPropertyName::GetStringAt(long lIndex) const
{
    if(m_aElements[lIndex].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return m_aElements[lIndex].Element.m_wszPropertyName;
    }
    else return NULL;
}

void CPropertyName::AddElement(LPCWSTR wszElement)
{
    EnsureAllocated(m_lNumElements+1);
    m_aElements[m_lNumElements].m_nType = WBEM_NAME_ELEMENT_TYPE_PROPERTY;
    m_aElements[m_lNumElements].Element.m_wszPropertyName =
		WbemStringCopy(wszElement);

    m_lNumElements++;
}

void CPropertyName::EnsureAllocated(long lElements)
{
    if(m_lAllocated < lElements)
    {
        WBEM_NAME_ELEMENT* pTemp = new WBEM_NAME_ELEMENT[ lElements + 5 ];
        memset(pTemp, 0, sizeof(WBEM_NAME_ELEMENT) * m_lNumElements);
        memcpy(pTemp, m_aElements, sizeof(WBEM_NAME_ELEMENT) * m_lNumElements);
        delete [] m_aElements;
        m_aElements = pTemp;
        m_lAllocated = lElements + 5;
    }
}

DELETE_ME LPWSTR CPropertyName::GetText()
{
    /*
    WString wsText;
    for(int i = 0; i < m_lNumElements; i++)
    {
        if(m_aElements[i].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return NULL;
        if(i > 0)
            wsText += L".";
        wsText += m_aElements[i].Element.m_wszPropertyName;
    }
    return wsText.UnbindPtr();
    */

    assert(FALSE);
    return NULL;
}




//***************************************************************************
//***************************************************************************


DWORD CAbstractQl1Parser::TranslateIntrinsic(LPCWSTR pFuncName)
{
    if (wbem_wcsicmp(pFuncName, L"UPPER") == 0)
        return QL1_FUNCTION_UPPER;
    if (wbem_wcsicmp(pFuncName, L"LOWER") == 0)
        return QL1_FUNCTION_LOWER;
    return QL1_FUNCTION_NONE;
}

void CAbstractQl1Parser::InitToken(WBEM_QL1_TOKEN* pToken)
{
    pToken->m_lTokenType = QL1_NONE;
    pToken->m_PropertyName.m_lNumElements = 0;
    pToken->m_PropertyName.m_aElements = NULL;

    pToken->m_PropertyName2.m_lNumElements = 0;
    pToken->m_PropertyName2.m_aElements = NULL;

    VariantInit(&pToken->m_vConstValue);
}


CAbstractQl1Parser::CAbstractQl1Parser(CGenLexSource *pSrc)
{
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
    m_PropertyName2.m_lNumElements = 0;
    m_PropertyName2.m_aElements = NULL;
    m_bPropComp = FALSE;

    m_pLexer = new CGenLexer(Ql_1_LexTable, pSrc);
}

CAbstractQl1Parser::~CAbstractQl1Parser()
{
    VariantClear(&m_vTypedConst);
    DeletePropertyName();
    delete m_pLexer;
}


int CAbstractQl1Parser::Parse(CQl1ParseSink* pSink, int nFlags)
{
    m_pSink = pSink;
    int nRes = parse(nFlags);
    m_pSink = NULL;
    return nRes;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL CAbstractQl1Parser::Next(int nFlags)
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == QL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == QL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == QL_1_TOK_IDENT && nFlags != NO_KEYWORDS)
    {
        if (wbem_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = QL_1_TOK_SELECT;
        else if (wbem_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = QL_1_TOK_FROM;
        else if (wbem_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = QL_1_TOK_WHERE;
/*
        else if (wbem_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = QL_1_TOK_LIKE;
*/
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = QL_1_TOK_OR;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = QL_1_TOK_AND;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = QL_1_TOK_NOT;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = QL_1_TOK_IS;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = QL_1_TOK_NULL;
        else if (wbem_wcsicmp(m_pTokenText, L"WITHIN") == 0)
            m_nCurrentToken = QL_1_TOK_WITHIN;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"ISA") == 0)
            m_nCurrentToken = QL_1_TOK_ISA;
        else if (nFlags != EXCLUDE_GROUP_KEYWORD && wbem_wcsicmp(m_pTokenText, L"GROUP") == 0)
            m_nCurrentToken = QL_1_TOK_GROUP;
        else if (wbem_wcsicmp(m_pTokenText, L"BY") == 0)
            m_nCurrentToken = QL_1_TOK_BY;
        else if (wbem_wcsicmp(m_pTokenText, L"HAVING") == 0)
            m_nCurrentToken = QL_1_TOK_HAVING;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"TRUE") == 0)
            m_nCurrentToken = QL_1_TOK_TRUE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"FALSE") == 0)
            m_nCurrentToken = QL_1_TOK_FALSE;
    }

    return TRUE;
}

LPCWSTR CAbstractQl1Parser::GetSinglePropertyName()
{
    if(m_PropertyName.m_lNumElements < 1)
        return NULL;

    if(m_PropertyName.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        return NULL;

    return m_PropertyName.m_aElements[0].Element.m_wszPropertyName;
}

void CAbstractQl1Parser::DeletePropertyName()
{
    for(long l = 0; l < m_PropertyName.m_lNumElements; l++)
    {
        if(m_PropertyName.m_aElements[l].m_nType ==
                                             WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_PropertyName.m_aElements[l].
                                Element.m_wszPropertyName);
        }
    }
    delete [] m_PropertyName.m_aElements;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
}

int CAbstractQl1Parser::FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

void CAbstractQl1Parser::AddAppropriateToken(const WBEM_QL1_TOKEN& Token)
{
    if(m_bInAggregation)
        m_pSink->AddHavingToken(Token);
    else
        m_pSink->AddToken(Token);
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int CAbstractQl1Parser::parse(int nFlags)
{
    int nRes;

    m_bInAggregation = FALSE;
    if(nFlags != JUST_WHERE)
    {
        m_pLexer->Reset();

        // SELECT
        // ======
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != QL_1_TOK_SELECT)
            return SYNTAX_ERROR;
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        // <prop_list>
        // ===========
        if (nRes = prop_list())
            return nRes;

        // FROM
        // ====
        if (m_nCurrentToken != QL_1_TOK_FROM)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;

        // <classname>
        // ===========
        if (nRes = class_name())
            return nRes;

        // <tolerance>
        // ===========

        if(nRes = tolerance())
            return nRes;
    }

    if(nFlags != NO_WHERE)
    {
        // WHERE clause.
        // =============
        if(nRes = opt_where())
            return nRes;

        // GROUP BY clause
        // ===============
        if(nRes = opt_aggregation())
            return nRes;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int CAbstractQl1Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == QL_1_TOK_EOF || m_nCurrentToken == QL_1_TOK_GROUP)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != QL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is QL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != QL_1_TOK_EOF && m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != QL_1_TOK_ASTERISK &&
        m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list_2()
{
    if (m_nCurrentToken == QL_1_TOK_COMMA)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


int CAbstractQl1Parser::parse_property_name(CPropertyName& Prop)
{
    Prop.Empty();

    int nCount = 0;
    while(m_nCurrentToken == QL_1_TOK_IDENT)
    {
        Prop.AddElement(m_pTokenText);
        nCount++;

        if(!Next())
            return LEXICAL_ERROR;

        if(m_nCurrentToken != QL_1_TOK_DOT)
            break;

        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
    }
    if (nCount)
        return SUCCESS;
    else
        return SYNTAX_ERROR;
}

//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int CAbstractQl1Parser::property_name()
{
    if (m_nCurrentToken == QL_1_TOK_ASTERISK)
    {
        trace(("Asterisk\n"));

        if(m_bInAggregation)
            m_pSink->AddAllAggregationProperties();
        else
            m_pSink->AddAllProperties();

        if(!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // Else a list of property names
    // =============================

    CPropertyName Prop;
    int nRes = parse_property_name(Prop);
    if(nRes != SUCCESS)
        return nRes;

    if(m_bInAggregation)
        m_pSink->AddAggregationProperty(Prop);
    else
        m_pSink->AddProperty(Prop);

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int CAbstractQl1Parser::class_name()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pSink->SetClassName(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <tolerance> ::= <>;
//  <tolerance> ::= WITHIN duration;
//
//***************************************************************************

int CAbstractQl1Parser::tolerance()
{
    LPWSTR wszGarbage;
    WBEM_QL1_TOLERANCE Tolerance;
    if(m_nCurrentToken != QL_1_TOK_WITHIN)
    {
        Tolerance.m_bExact = TRUE;
        m_pSink->SetTolerance(Tolerance);
        return SUCCESS;
    }

    if(!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        Tolerance.m_bExact = FALSE;
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(Tolerance.m_fTolerance <= 0 || bSuccess == false)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_bExact = FALSE;
        Tolerance.m_fTolerance = wcstol(m_pTokenText, &wszGarbage, 10);
        if(Tolerance.m_fTolerance < 0)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int CAbstractQl1Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int CAbstractQl1Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_OR)
        {
            trace(("Token OR\n"));
            m_pSink->InOrder(QL1_OR);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_OR;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int CAbstractQl1Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_AND)
        {
            trace(("Token AND\n"));
            m_pSink->InOrder(QL1_AND);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_AND;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        WBEM_QL1_TOKEN NewTok;
        InitToken(&NewTok);
        NewTok.m_lTokenType = QL1_NOT;
        AddAppropriateToken(NewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        if(nRes = parse_property_name(m_PropertyName))
            return nRes;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == QL_1_TOK_INT ||
             m_nCurrentToken == QL_1_TOK_REAL ||
             m_nCurrentToken == QL_1_TOK_TRUE ||
             m_nCurrentToken == QL_1_TOK_FALSE ||
             m_nCurrentToken == QL_1_TOK_NULL ||
             m_nCurrentToken == QL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        // dont allow const followed by isa!

        if(m_nRelOp == QL1_OPERATOR_ISA)
            return SYNTAX_ERROR;

        // Since we always view the token as IDENT <rel> constant, we need
        // to invert this operator, e.g. replace > with <
        // ================================================================

        m_nRelOp = FlipOperator(m_nRelOp);

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    int nRes = parse_property_name(m_PropertyName);
    return nRes;
}

//***************************************************************************
//
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::leading_ident_expr()
{
    int nRes;
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != QL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int CAbstractQl1Parser::trailing_or_null()
{
    if (m_nCurrentToken == QL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//  <trailing_const_expr> ::= <trailing_ident_expr>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_const_expr()
{
    int nRes;
    nRes = typed_constant();
    if (nRes != SUCCESS)
        nRes = trailing_ident_expr();
    return nRes;
}

//***************************************************************************
//
//  <trailing_ident_expr> ::= <property_name>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_ident_expr()
{
    int nRes = parse_property_name(m_PropertyName2) ;
    if (nRes == SUCCESS)
        m_bPropComp = TRUE;
    return nRes;
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the QL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int CAbstractQl1Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================
    int retval = SUCCESS;
    WBEM_QL1_TOKEN NewTok;
    InitToken(&NewTok);

    NewTok.m_lTokenType = QL1_OP_EXPRESSION;
    VariantInit(&NewTok.m_vConstValue);

	//can do a memcpy since NewTok.m_PropertyName isa WBEM_PROPERTY_NAME
	//and m_PropertyName is derived from WBEM_PROPERTY_NAME so copying
	//the contents up to the sizeof(WBEM_PROPERTY_NAME) is OK...
    memcpy((void*)&NewTok.m_PropertyName,
           (void*)&m_PropertyName,
           sizeof (WBEM_PROPERTY_NAME));

    if (m_bPropComp)
    {
        NewTok.m_bPropComp = true;

		//can do a memcpy since NewTok.m_PropertyName2 isa WBEM_PROPERTY_NAME
		//and m_PropertyName2 is derived from WBEM_PROPERTY_NAME so copying
		//the contents up to the sizeof(WBEM_PROPERTY_NAME) is OK...
        memcpy((void*)&NewTok.m_PropertyName2,
               (void*)&m_PropertyName2,
               sizeof (WBEM_PROPERTY_NAME));
    }
    else
    {
        NewTok.m_bPropComp = false;

        if (FAILED(VariantCopy(&NewTok.m_vConstValue, &m_vTypedConst)))
        {
            VariantInit(&NewTok.m_vConstValue);
            retval = FAILED;
        }
    }

    if (retval == SUCCESS)
    {
        NewTok.m_lOperator = m_nRelOp;
        NewTok.m_lPropertyFunction = m_dwPropFunction;
        NewTok.m_lConstFunction = m_dwConstFunction;
        NewTok.m_bQuoted = m_bQuoted;

        AddAppropriateToken(NewTok);

    //    m_PropertyName.m_lNumElements = 0;
    //    m_PropertyName.m_aElements = NULL;
        m_PropertyName.Empty();
        m_PropertyName2.Empty();
    }

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    VariantClear(&NewTok.m_vConstValue);
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bPropComp = FALSE;

    return retval;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int CAbstractQl1Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bQuoted = FALSE;

    if (m_nCurrentToken == QL_1_TOK_INT)
    {
        trace((" Integer\n"));

        // Read it in as a 64-bit one
        // ==========================

        __int64 i64;
        unsigned __int64 ui64;
        BOOL b32bits = FALSE;
        if(ReadI64(m_pTokenText, i64))
        {
            // Check if it is within range of I4
            // =================================

            if(i64 >= - (__int64)0x80000000 && i64 <= 0x7FFFFFFF)
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = (long)i64;
                b32bits = TRUE;
            }
        }
        else if(!ReadUI64(m_pTokenText, ui64))
        {
            // Not a valid number
            // ==================

            return LEXICAL_ERROR;
        }

        if(!b32bits)
        {
            // Valid 64-bit number but not 32-bit
            // ==================================

            V_VT(&m_vTypedConst) = VT_BSTR;
            V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
            m_bQuoted = FALSE;
        }
    }
    else if (m_nCurrentToken == QL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
        m_bQuoted = TRUE;
    }
    else if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        bool bSuccess;
        V_R8(&m_vTypedConst) = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(bSuccess == false)
            return LEXICAL_ERROR;
    }
    else if(m_nCurrentToken == QL_1_TOK_TRUE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
    }
    else if(m_nCurrentToken == QL_1_TOK_FALSE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    else if (m_nCurrentToken == QL_1_TOK_NULL)
        V_VT(&m_vTypedConst) = VT_NULL;

    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int CAbstractQl1Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == QL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != QL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_GREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else if (m_nCurrentToken == QL_1_TOK_ISA)
    {
        trace(("    REL OP 'isa' \n"));
        m_nRelOp = QL1_OPERATOR_ISA;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::opt_aggregation()
{
    if(m_nCurrentToken == QL_1_TOK_EOF)
        return SUCCESS;

    if(m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    m_pSink->SetAggregated();

    int nRes = aggregation_params();
    if(nRes)
        return nRes;

    if(nRes = opt_having())
        return nRes;

    // Make sure we've reached the end
    // ===============================

    if(m_nCurrentToken != QL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::aggregation_params()
{
    int nRes;
    WBEM_QL1_TOLERANCE Exact;
    Exact.m_bExact = TRUE;

    if(m_nCurrentToken == QL_1_TOK_BY)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        if(nRes = aggregate_by())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_WITHIN)
        {
            if (!Next())
                return LEXICAL_ERROR;

            if(nRes = aggregate_within())
                return nRes;
        }
        else
        {
            m_pSink->SetAggregationTolerance(Exact);
        }
    }
    else if(m_nCurrentToken == QL_1_TOK_WITHIN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        if(nRes = aggregate_within())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_BY)
        {
            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if(nRes = aggregate_by())
                return nRes;
        }
    }
    else
    {
        return SYNTAX_ERROR;
    }

    return SUCCESS;
}

int CAbstractQl1Parser::aggregate_within()
{
    WBEM_QL1_TOLERANCE Tolerance;
    Tolerance.m_bExact = FALSE;
    LPWSTR wszGarbage;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(!bSuccess)
            return SYNTAX_ERROR;
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_fTolerance = (double)wcstol(m_pTokenText, &wszGarbage, 10);
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

int CAbstractQl1Parser::aggregate_by()
{
    m_bInAggregation = TRUE;
    int nRes = prop_list();
    m_bInAggregation = FALSE;
    return nRes;
}

int CAbstractQl1Parser::opt_having()
{
    if(m_nCurrentToken == QL_1_TOK_HAVING)
    {
        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        m_bInAggregation = TRUE;
        int nRes = expr();
        m_bInAggregation = FALSE;
        return nRes;
    }
    else return SUCCESS;
}


//***************************************************************************
//***************************************************************************
//
//  class QL1_Parser
//
//  A derivative of CAbstractQlParser for backward compatibility
//
//***************************************************************************
//
//

QL1_Parser::QL1_Parser(CGenLexSource *pSrc)
    : m_pExpression(NULL), CAbstractQl1Parser(pSrc), m_bPartiallyParsed(FALSE)
{
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;
}

QL1_Parser::~QL1_Parser()
{
    delete m_pExpression;
}

int QL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Get the underlying parser to parse the first part of the query
    // ==============================================================

    if(!m_bPartiallyParsed)
    {
        int nRes = CAbstractQl1Parser::Parse(m_pExpression, NO_WHERE);
        if(nRes != SUCCESS) return nRes;
    }

    if (!m_pExpression->bsClassName)
        return SYNTAX_ERROR;

    m_bPartiallyParsed = TRUE;
    if(wcslen(m_pExpression->bsClassName) >= (unsigned int)nBufLen)
        return BUFFER_TOO_SMALL;

    StringCchCopyW(pDestBuf, nBufLen, m_pExpression->bsClassName);
    return WBEM_S_NO_ERROR;
}

int QL1_Parser::Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    // Get the underying parser to completely parse the query. If
    // GetQueryClass was called in the past, no sense in duplcating
    // the work
    // ============================================================

    int nRes = CAbstractQl1Parser::Parse(m_pExpression,
        m_bPartiallyParsed?JUST_WHERE:FULL_PARSE);
    *pOutput = m_pExpression;
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;
    m_bPartiallyParsed = FALSE;

    return nRes;
}

DELETE_ME LPWSTR QL1_Parser::ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                                LPCWSTR wszClassName)
{
    QL_LEVEL_1_RPN_EXPRESSION NewExpr(*pExpr);

    if (NewExpr.bsClassName)
        SysFreeString(NewExpr.bsClassName);
    NewExpr.bsClassName = SysAllocString(wszClassName);

    LPWSTR wszNewQuery = NewExpr.GetText();
    return wszNewQuery;
}


//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    bStar = FALSE;
    pRequestedPropertyNames = 0;
    nCurSize = 1;
    nCurPropSize = 1;

    bAggregated = FALSE;
    bAggregateAll = FALSE;
    nNumAggregatedProperties = 0;
    nCurAggPropSize = 1;

    nNumHavingTokens = 0;
    nCurHavingSize = 1;

    lRefCount = 0;

    pAggregatedPropertyNames = NULL;
    pArrayOfHavingTokens = NULL;
    pArrayOfTokens = NULL;
    pRequestedPropertyNames = NULL;

    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
}

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION(
                                const QL_LEVEL_1_RPN_EXPRESSION& Other)
{
    nNumTokens = Other.nNumTokens;
    bsClassName = SysAllocString(Other.bsClassName);
    nNumberOfProperties = Other.nNumberOfProperties;
    bStar = Other.bStar;
    pRequestedPropertyNames = 0;
    nCurSize = Other.nCurSize;
    nCurPropSize = Other.nCurPropSize;

    pAggregatedPropertyNames = NULL;
    pArrayOfHavingTokens = NULL;
    pArrayOfTokens = NULL;
    pRequestedPropertyNames = NULL;

    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    int i;
    for(i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i] = Other.pArrayOfTokens[i];

    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
    for(i = 0; i < nNumberOfProperties; i++)
        pRequestedPropertyNames[i] = Other.pRequestedPropertyNames[i];

    bAggregated = Other.bAggregated;
    bAggregateAll = Other.bAggregateAll;
    nNumAggregatedProperties = Other.nNumAggregatedProperties;
    nCurAggPropSize = Other.nCurAggPropSize;

    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    for(i = 0; i < nNumAggregatedProperties; i++)
        pAggregatedPropertyNames[i] = Other.pAggregatedPropertyNames[i];

    nNumHavingTokens = Other.nNumHavingTokens;
    nCurHavingSize = Other.nCurHavingSize;

    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];
    for(i = 0; i < nNumHavingTokens; i++)
        pArrayOfHavingTokens[i] = Other.pArrayOfHavingTokens[i];

    lRefCount = 0;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddRef()
{
    InterlockedIncrement(&lRefCount);
}

void QL_LEVEL_1_RPN_EXPRESSION::Release()
{
    if(InterlockedDecrement(&lRefCount) == 0)
        delete this;
}


QL_LEVEL_1_RPN_EXPRESSION::~QL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    delete [] pAggregatedPropertyNames;
    delete [] pArrayOfHavingTokens;
    delete [] pRequestedPropertyNames;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetClassName(LPCWSTR wszClassName)
{
    bsClassName = SysAllocString(wszClassName);
}

void QL_LEVEL_1_RPN_EXPRESSION::SetTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    Tolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregationTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    AggregationTolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(
                                  const QL_LEVEL_1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddHavingToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurHavingSize == nNumHavingTokens)
    {
        nCurHavingSize += 1;
        nCurHavingSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurHavingSize];
        for (int i = 0; i < nNumHavingTokens; i++)
            pTemp[i] = pArrayOfHavingTokens[i];
        delete [] pArrayOfHavingTokens;
        pArrayOfHavingTokens = pTemp;
    }

    pArrayOfHavingTokens[nNumHavingTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddProperty(const CPropertyName& Prop)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 1;
        nCurPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurPropSize];
        for(int i = 0; i < nNumberOfProperties; i++)
            pTemp[i] = pRequestedPropertyNames[i];
        delete [] pRequestedPropertyNames;
        pRequestedPropertyNames = pTemp;
    }

    pRequestedPropertyNames[nNumberOfProperties++] = Prop;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllProperties()
{
    bStar = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregated()
{
    bAggregated = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAggregationProperty(
                                    const CPropertyName& Property)
{
    if(pAggregatedPropertyNames == NULL)
    {
        // '*' requested
        return;
    }
    if (nCurAggPropSize == nNumAggregatedProperties)
    {
        nCurAggPropSize += 1;
        nCurAggPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurAggPropSize];
        for(int i = 0; i < nNumAggregatedProperties; i++)
            pTemp[i] = pAggregatedPropertyNames[i];
        delete [] pAggregatedPropertyNames;
        pAggregatedPropertyNames = pTemp;
    }

    pAggregatedPropertyNames[nNumAggregatedProperties++] = Property;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllAggregationProperties()
{
    bAggregateAll = TRUE;
}

DELETE_ME LPWSTR QL_LEVEL_1_RPN_EXPRESSION::GetText()
{
    assert(FALSE);
    return NULL;
    /*
    WString wsText;

    wsText += L"select ";
    for(int i = 0; i < nNumberOfProperties; i++)
    {
        if(i != 0) wsText += L", ";
        wsText += (LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
    }
    if(bStar)
    {
        if(nNumberOfProperties > 0)
            wsText += L", ";
        wsText += L"*";
    }

    wsText += L" from ";
    if (bsClassName)
        wsText += bsClassName;

    if(nNumTokens > 0)
    {
        wsText += L" where ";

        CWStringArray awsStack;
        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }
        }

        if(awsStack.Size() != 1) return NULL;
        wsText += awsStack[0];
    }

    return wsText.UnbindPtr();
    */
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;

    *this = Src;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = Src.nTokenType;
    PropertyName = Src.PropertyName;
    
    if (Src.m_bPropComp)
        PropertyName2 = Src.PropertyName2;

    nOperator = Src.nOperator;
    
    if (FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.vConstValue)))
        VariantInit(&vConstValue);

    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bQuoted = Src.bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const WBEM_QL1_TOKEN &Src)
{
    nTokenType = Src.m_lTokenType;
    PropertyName = Src.m_PropertyName;
    
    if (Src.m_bPropComp)
        PropertyName2 = Src.m_PropertyName2;

    nOperator = Src.m_lOperator;
    
    if (FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.m_vConstValue)))
        VariantInit(&vConstValue);
    
    dwPropertyFunction = Src.m_lPropertyFunction;
    dwConstFunction = Src.m_lConstFunction;
    bQuoted = Src.m_bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN::~QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantClear(&vConstValue);
}

DELETE_ME LPWSTR QL_LEVEL_1_TOKEN::GetText()
{
    assert(FALSE);
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of QL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\core\qllex.cpp ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QLLEX.CPP

Abstract:

    QL Level 1 DFA Table

History:

    raymcc    24-Jun-95       Created.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>             

#define ST_STRING       24
#define ST_IDENT        29
#define ST_GE           35
#define ST_LE           37
#define ST_NE           40
#define ST_NUMERIC      42
#define ST_REAL         47
#define ST_STRING2      53
#define ST_STRING_ESC   58
#define ST_STRING2_ESC  61   
#define ST_DOT          64
#define ST_NEGATIVE_NUM 66
#define ST_POSITIVE_NUM 69

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  QL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA, GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,               GLEX_CONSUME,

    // Unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 24 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 26 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 27 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 28 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 29 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 35 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 37 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 38 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 40 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 41 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 42 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 43 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 44 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 45 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 49 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 50 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 53 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 54 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 55 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 56 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 57 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 58 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 61 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 62 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 63 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 64 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 65 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 66 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 67 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 68 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 69 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 70 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 71 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtget.cpp ===
//***************************************************************************

//

//  NTEVTGET.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the GetObject implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

extern BOOL GenerateAssocInstance (WbemProvErrorObject &a_ErrorObject,
                                     const wchar_t* objPath1,
                                     const wchar_t* objPath2,
                                     wchar_t* prop1,
                                     wchar_t* prop2,
                                     IWbemClassObject* pClassObject,
                                     IWbemObjectSink* pNtfcnHandler,
									 BOOL *pbIndicated);

BOOL GetObjectAsyncEventObject :: GetObject ( WbemProvErrorObject &a_ErrorObject )
{

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject\r\n"
        ) ;
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

    if ( t_Status )
    {
        BOOL bClass = TRUE;

        if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , NTEVT_CLASS) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
			if ( bstCls )
			{
				t_Status = GetClassObject ( bstCls ) ;
				SysFreeString ( bstCls ) ;

				if ( t_Status )
				{
					t_Status =  Dispatch_Record ( a_ErrorObject ) ;
	                
					if ( t_Status )
					{
						m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
					}
				}
				else
				{
					bClass = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetMessage ( L"Unable to allocate class string" ) ;
			}
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , NTEVTLOG_CLASS ) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
			if ( bstCls )
			{
				t_Status = GetClassObject ( bstCls ) ;
				SysFreeString ( bstCls ) ;

				if ( t_Status )
				{
					t_Status =  Dispatch_EventLog ( a_ErrorObject ) ;
	                
					if ( t_Status )
					{
						m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
					}
				}
				else
				{
					bClass = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetMessage ( L"Unable to allocate class string" ) ;
			}
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , ASSOC_LOGRECORD ) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
			if ( bstCls )
			{
				t_Status = GetClassObject ( bstCls ) ;
				SysFreeString ( bstCls ) ;

				if ( t_Status )
				{
					t_Status =  Dispatch_LogRecord ( a_ErrorObject ) ;
	                
					if ( t_Status )
					{
						m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
					}
				}
				else
				{
					bClass = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetMessage ( L"Unable to allocate class string" ) ;
			}
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , ASSOC_USERRECORD ) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
			if ( bstCls )
			{
				t_Status = GetClassObject ( bstCls ) ;
				SysFreeString ( bstCls ) ;

				if ( t_Status )
				{
					t_Status =  Dispatch_UserRecord ( a_ErrorObject ) ;
	                
					if ( t_Status )
					{
						m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
					}
				}
				else
				{
					bClass = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_OUT_OF_MEMORY ) ;
				a_ErrorObject.SetMessage ( L"Unable to allocate class string" ) ;
			}
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , ASSOC_COMPRECORD ) == 0 )
        {
            t_Status = GetClassObject ( m_ParsedObjectPath->m_pClass ) ;

            if ( t_Status )
            {
                t_Status =  Dispatch_ComputerRecord ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
                bClass = FALSE ;
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not support this class" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject:Dynamic NT Eventlog Provider does not support this class %s\r\n",
        m_ParsedObjectPath->m_pClass
        ) ;
)

        }

        if (!bClass)
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject:Class definition not found\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject:Dynamic NT Eventlog Provider does not support this class %s\r\n",
        m_ObjectPath
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving GetObjectAsyncEventObject :: GetObject with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_Record ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , LOGFILE_PROP ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , RECORD_PROP ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_I4 ) )
                {
                    t_Status = Get_Record ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect type\r\n"
        ) ;
)

                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , LOGFILE_PROP ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , RECORD_PROP ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_I4 ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_Record ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect type\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Failed to get key values\r\n"
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving GetObjectAsyncEventObject :: Dispatch_Record with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 1)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    if ( t_Key1 )
    {
        if ((t_Key1->m_pName == NULL) || _wcsicmp ( t_Key1->m_pName , PROP_NAME ) == 0 )
        {
            if ( t_Key1->m_vValue.vt == VT_BSTR )
            {
                t_Status = Get_EventLog ( a_ErrorObject , t_Key1 ) ;
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value has incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:Key value has incorrect type\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value has incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:Key value has incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key value" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:Failed to get key value\r\n"
        ) ;
)
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:return %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_LogRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }


    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , REF_LOG ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_LogRecord ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect type\r\n"
        ) ;
)

                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , REF_LOG ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_LogRecord ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect type\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Failed to get key values\r\n"
        ) ;
)
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:returning with %lx\r\n",
        t_Status
        ) ;
)
    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_UserRecord ( WbemProvErrorObject &a_ErrorObject )
{
    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_UserRecord: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , REF_USER ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_UserRecord ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , REF_USER ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_UserRecord ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_ComputerRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord\r\n"
        ) ;
)

    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , REF_COMP ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_ComputerRecord ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect type\r\n"
        ) ;
)

                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , REF_COMP ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_ComputerRecord ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect type\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Failed to get key values\r\n"
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}


BOOL GetObjectAsyncEventObject :: Get_LogRecord ( WbemProvErrorObject &a_ErrorObject ,
                                                 KeyRef *a_LogKey , KeyRef *a_RecordKey )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord\r\n"
        ) ;
)

    BOOL retVal = TRUE;
    GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                m_Provider , a_RecordKey->m_vValue.bstrVal ,
                                                0 , m_NotificationHandler , m_Ctx, FALSE ) ;

	try
	{
		if (!t_getRec->GetObject(t_getRec->m_ErrorObject))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"Failed to verify given eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to verify given eventlog record object\r\n"
        ) ;
)

		}
		else
		{
			GetObjectAsyncEventObject *t_getLog = new GetObjectAsyncEventObject (
													m_Provider , a_LogKey->m_vValue.bstrVal ,
													0 , m_NotificationHandler , m_Ctx, FALSE ) ;
			try
			{
				if (!t_getLog->GetObject(t_getLog->m_ErrorObject))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_ErrorObject.SetMessage ( L"Failed to verify given eventlog file object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to verify given eventlog file object\r\n"
        ) ;
)
				}
				else 
				{
					//check the association
					VARIANT vLog;
					VariantInit(&vLog);
					HRESULT result = t_getLog->m_Out->Get(PROP_LOGNAME, 0, &vLog, NULL, NULL);

					if ((FAILED(result)) || (vLog.vt != VT_BSTR))
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to get logfile property from eventlog file object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to get logfile property from eventlog file object\r\n"
        ) ;
)
					}
					else
					{
						VARIANT vRec;
						VariantInit(&vRec);
						result = t_getRec->m_Out->Get(LOGFILE_PROP, 0, &vRec, NULL, NULL);

						if ((FAILED(result)) || (vRec.vt != VT_BSTR))
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to get logfile property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to get logfile property from eventlog record object\r\n"
        ) ;
)
						}
						else if (_wcsicmp(vRec.bstrVal, vLog.bstrVal) == 0)
						{
							retVal = GenerateAssocInstance(a_ErrorObject, a_RecordKey->m_vValue.bstrVal,
											a_LogKey->m_vValue.bstrVal, REF_REC, REF_LOG,
											m_ClassObject, m_NotificationHandler, NULL);
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
							a_ErrorObject.SetMessage ( L"Both objects exist but are not associated" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Both objects exist but are not associated\r\n"
        ) ;
)
						}

						VariantClear(&vRec);
					}

					VariantClear(&vLog);
				}
			}
			catch(...)
			{
				delete t_getLog;
				throw;
			}

			delete t_getLog;
		}
	}
	catch (...)
	{
		delete t_getRec;
		throw;
	}

    delete t_getRec;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:returning with %lx\r\n",
        retVal
        ) ;
)

    return retVal;
}

BOOL GetObjectAsyncEventObject :: Get_UserRecord ( WbemProvErrorObject &a_ErrorObject ,
                                                  KeyRef *a_UserKey , KeyRef *a_RecordKey )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord\r\n"
        ) ;
)

    BOOL retVal = TRUE;
    GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                m_Provider , a_RecordKey->m_vValue.bstrVal ,
                                                0 , m_NotificationHandler , m_Ctx, FALSE) ;

	try
	{
		if (!t_getRec->GetObject(t_getRec->m_ErrorObject))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"Failed to verify given eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to verify given eventlog record object\r\n"
        ) ;
)
		}
		else
		{
			IWbemClassObject* userObj = NULL;
			IWbemServices *t_Server = m_Provider->GetServer() ;
			HRESULT result = t_Server->GetObject(a_UserKey->m_vValue.bstrVal, 0, m_Ctx, &userObj, NULL);
			t_Server->Release();

			if (FAILED(result))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_ErrorObject.SetMessage ( L"Failed to verify given user object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to verify given user object\r\n"
        ) ;
)
			}
			else 
			{
				//check the association
				VARIANT vUserN;
				VariantInit(&vUserN);
				result = userObj->Get(PROP_NAME, 0, &vUserN, NULL, NULL);

				if ((FAILED(result)) || (vUserN.vt != VT_BSTR))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get name property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to get name property from eventlog record object\r\n"
        ) ;
)
				}
				else
				{
					VARIANT vUserD;
					VariantInit(&vUserD);
					result = userObj->Get(PROP_DOMAIN, 0, &vUserD, NULL, NULL);

					if ((FAILED(result)) || (vUserD.vt != VT_BSTR))
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to get name property from user object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to get name property from user object\r\n"
        ) ;
)
					}
					else
					{
						wchar_t userStr[1024];
						if ( SUCCEEDED ( result = StringCchCopyW ( userStr, 1024, vUserD.bstrVal ) ) )
						{
							if ( SUCCEEDED ( result = StringCchCatW ( userStr, 1024, L"\\" ) ) )
							{
								if ( SUCCEEDED ( result = StringCchCatW ( userStr, 1024, vUserN.bstrVal ) ) )
								{
									VARIANT vRec;
									VariantInit(&vRec);
									result = t_getRec->m_Out->Get(USER_PROP, 0, &vRec, NULL, NULL);

									if ((FAILED(result)) || (vRec.vt != VT_BSTR))
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Failed to get user property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to get user property from eventlog record object\r\n"
        ) ;
)
									}
									else if (_wcsicmp(vRec.bstrVal, userStr) == 0)
									{
										retVal = GenerateAssocInstance(a_ErrorObject, a_RecordKey->m_vValue.bstrVal,
														a_UserKey->m_vValue.bstrVal, REF_REC, REF_USER,
														m_ClassObject, m_NotificationHandler, NULL);
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
										a_ErrorObject.SetMessage ( L"Both objects exist but are not associated" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Both objects exist but are not associated\r\n"
        ) ;
)
									}

									VariantClear(&vRec);
								}
							}
						}
					}

					VariantClear(&vUserD);
				}

				VariantClear(&vUserN);
				userObj->Release();
			}
		}
	}
	catch(...)
	{
		delete t_getRec;
		throw;
	}

    delete t_getRec;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:returning with %lx\r\n",
        retVal
        ) ;
)

    return retVal;
}

BOOL GetObjectAsyncEventObject :: Get_ComputerRecord ( WbemProvErrorObject &a_ErrorObject ,
                                                      KeyRef *a_CompKey , KeyRef *a_RecordKey )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord\r\n"
        ) ;
)
    
    BOOL retVal = TRUE;
    GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                m_Provider , a_RecordKey->m_vValue.bstrVal ,
                                                0 , m_NotificationHandler , m_Ctx, FALSE ) ;

	try
	{
		if (!t_getRec->GetObject(t_getRec->m_ErrorObject))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"Failed to verify given eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to verify given eventlog record object\r\n"
        ) ;
)
		}
		else
		{
			IWbemClassObject* compObj = NULL;
			IWbemServices *t_Server = m_Provider->GetServer() ;
			HRESULT result = t_Server->GetObject(a_CompKey->m_vValue.bstrVal, 0, m_Ctx, &compObj, NULL);
			t_Server->Release();

			if (FAILED(result))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_ErrorObject.SetMessage ( L"Failed to verify given computer object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to verify given computer object\r\n"
        ) ;
)
			}
			else 
			{
				//check the association
				VARIANT vComp;
				VariantInit(&vComp);
				result = compObj->Get(PROP_NAME, 0, &vComp, NULL, NULL);

				if ((FAILED(result)) || (vComp.vt != VT_BSTR))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get Name property from computer object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to get Name property from computer object\r\n"
        ) ;
)
				}
				else
				{
					VARIANT vRec;
					VariantInit(&vRec);
					result = t_getRec->m_Out->Get(COMPUTER_PROP, 0, &vRec, NULL, NULL);

					if ((FAILED(result)) || (vRec.vt != VT_BSTR))
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to get computer property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to get computer property from eventlog record object\r\n"
        ) ;
)
					}
					else if (_wcsicmp(vRec.bstrVal, vComp.bstrVal) == 0)
					{
						retVal = GenerateAssocInstance(a_ErrorObject, a_RecordKey->m_vValue.bstrVal,
										a_CompKey->m_vValue.bstrVal, REF_REC, REF_COMP,
										m_ClassObject, m_NotificationHandler, NULL);
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_ErrorObject.SetMessage ( L"Both objects exist but are not associated" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Both objects exist but are not associated\r\n"
        ) ;
)
					}

					VariantClear(&vRec);
				}

				VariantClear(&vComp);
				compObj->Release();
			}
		}
	}
	catch (...)
	{
		delete t_getRec;
		throw;
	}

	delete t_getRec;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:returning with %lx\r\n",
        retVal
        ) ;
)
    return retVal;
}

BOOL GetObjectAsyncEventObject :: Get_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey) 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog\r\n"
        ) ;
)

    BOOL retVal = FALSE;
    CStringW log = CEventLogFile::GetLogName((const wchar_t*)a_FileKey->m_vValue.bstrVal);

    if (log.IsEmpty())
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
        a_ErrorObject.SetMessage ( L"Failed to translate key to instance of logfile." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog: Failed to get instance of logfile named %s\r\n",
        (const wchar_t*)a_FileKey->m_vValue.bstrVal
        ) ;
)
    }
    else
    {
        CEventlogFileAttributes evtlog(log);

        IWbemClassObject* pInst = NULL;
            
        if (evtlog.GenerateInstance(m_ClassObject, m_AClassObject, &pInst))
        {
            if (m_bIndicate)
            {
                m_NotificationHandler->Indicate ( 1 , & pInst ) ;
                pInst->Release();
            }
            else
            {
                m_Out = pInst;
            }

            retVal = TRUE;
        }
        else
        {
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Failed while generating instance of logfile." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog: Failed to generate instance of logfile named %s\r\n",
        log
        ) ;
)
        }
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog:returning with %lx\r\n",
        retVal
        ) ;
)
    return retVal;
}


BOOL GetObjectAsyncEventObject :: Get_Record ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey , KeyRef *a_RecordKey ) 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record\r\n"
        ) ;
)

    BOOL retVal = TRUE;
    CEventLogFile evtlog(a_FileKey->m_vValue.bstrVal, TRUE);

    if (!evtlog.IsValid())
    {
        //failed to find log i.e. no such record??
        retVal = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;

        if ((evtlog.GetReason() == ERROR_ACCESS_DENIED) || (evtlog.GetReason() == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_ACCESS_DENIED ) ;
            a_ErrorObject.SetPrivilegeFailed();
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
        }

        a_ErrorObject.SetMessage ( L"Failed to find the logfile" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:Failed to find the logfile %s\r\n",
        a_FileKey->m_vValue.bstrVal
        ) ;
)
    }
    else
    {
        if (0 == evtlog.ReadRecord(a_RecordKey->m_vValue.lVal))
        {
            EVENTLOGRECORD* pEvt = (EVENTLOGRECORD*) evtlog.GetBuffer();
            CEventlogRecord evtRec(a_FileKey->m_vValue.bstrVal, pEvt, NULL, m_ClassObject, m_AClassObject);
            IWbemClassObject* pInst = NULL;
                
            if (evtRec.GenerateInstance(&pInst))
            {
                if (m_bIndicate)
                {
                    m_NotificationHandler->Indicate ( 1 , & pInst ) ;
                    pInst->Release();
                }
                else
                {
                    m_Out = pInst;
                }
            }
            else
            {
                //failed to create record
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                a_ErrorObject.SetMessage ( L"Failed to create instance from Eventlog data" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:Failed to create instance from Eventlog data\r\n"
        ) ;
)

            }

        }
        else
        {
            //record not found i.e. no such record??
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
            a_ErrorObject.SetMessage ( L"Failed to find the record in the logfile" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:Failed to find the record in the logfile\r\n"
        ) ;
)
        }
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:returning with %lx\r\n",
        retVal
        ) ;
)
    return retVal;
}

GetObjectAsyncEventObject :: GetObjectAsyncEventObject (

    CImpNTEvtProv *a_Provider , 
    wchar_t* a_ObjectPath ,
    ULONG a_OperationFlag ,
    IWbemObjectSink *a_NotificationHandler ,
    IWbemContext *a_Ctx ,
    BOOL a_bIndicate

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
    m_Class ( NULL ) , m_bIndicate ( a_bIndicate ) , m_Out ( NULL ) ,
    m_ParsedObjectPath ( NULL )
{
    m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject () 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Object path (%s) SetStatus with %lx\r\n",
        m_ObjectPath, m_ErrorObject.GetWbemStatus ()
        ) ;
)

    delete [] m_ObjectPath ;
    delete m_ParsedObjectPath ;

    // Get Status object
    if (m_bIndicate)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Indicating Object path (%s) SetStatus with %lx\r\n",
        m_ObjectPath, m_ErrorObject.GetWbemStatus ()
        ) ;
)
        IWbemClassObject *t_NotifyStatus = NULL ;
        BOOL t_Status = TRUE;
        
        if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
        {
            t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
        }

        if ( t_Status )
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Really Indicating Object path (%s) SetStatus with %lx\r\n",
        m_ObjectPath, m_ErrorObject.GetWbemStatus ()
        ) ;
)
            HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
            
            if (t_NotifyStatus)
            {
                t_NotifyStatus->Release () ;
            }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject:Indicated status, released objectsink\r\n"
        ) ;
)

        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Failed to get Status object Object path (%s)\r\n",
        m_ObjectPath
        ) ;
)
            HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject:Released object without indicating it\r\n"
        ) ;
)

        if (m_Out != NULL)
        {
            m_Out->Release();
        }
    }
}


void GetObjectAsyncEventObject :: Process () 
{
    GetObject ( m_ErrorObject ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtlogf.cpp ===
//***************************************************************************

//

//  NTEVTLOGF.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the Eventlog classes

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include <time.h>
#include <io.h>
#include <wbemtime.h>

CEventlogFileAttributes::CEventlogFileAttributes(const wchar_t* log):
	m_logname(log),
	m_retention (0),
	m_fileSz (15000*1024)
{
    m_sources.SetSize(0, 10);
}


CEventlogFileAttributes::~CEventlogFileAttributes()
{
    LONG count = m_sources.GetSize();

    if (count > 0)
    {
        for (LONG x = 0; x < count; x++)
        {
            delete m_sources[x];
        }
        
        m_sources.RemoveAll();
    }
}

DWORD CEventlogFileAttributes::EventLogOperation (const wchar_t* archive, BOOL bClear,
                                                  WbemProvErrorObject &a_ErrorObject, BOOL &bSuccess)
{
    DWORD retVal = ERROR_SUCCESS;
    HANDLE hEventLog = OpenEventLog(NULL, m_logname);

    if (hEventLog == NULL)
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            CEventLogFile::SetSecurityLogPrivilege();
            hEventLog = OpenEventLog(NULL, m_logname);
        }
    }

    if (hEventLog == NULL)
    {
        retVal = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed to OpenEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
        if (retVal == ERROR_PRIVILEGE_NOT_HELD)
        {
            retVal = 0;
            bSuccess = FALSE;
            a_ErrorObject.SetWbemStatus ( WBEM_E_ACCESS_DENIED ) ;
            a_ErrorObject.SetMessage ( L"Failed to open the logfile" ) ;
            a_ErrorObject.SetPrivilegeFailed();
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();

            if (!bClear)
            {
                a_ErrorObject.SetBackupPrivRequired();
            }
        }
    }
    else
    {
        if (bClear)
        {
            if (!ClearEventLog(hEventLog, archive))
            {
                retVal = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed to ClearEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
            }
        }
        else
        {
            if (archive == NULL)
            {
                retVal = ERROR_INVALID_PARAMETER;
            }
            else if (!BackupEventLog(hEventLog, archive))
            {
                retVal = GetLastError();

                if (retVal == ERROR_PRIVILEGE_NOT_HELD)
                {
                    retVal = 0;
                    CEventLogFile::SetSecurityLogPrivilege(FALSE, SE_BACKUP_NAME);

                    if (!BackupEventLog(hEventLog, archive))
                    {
                        retVal = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed even after privilege set to BackupEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
                        if (retVal == ERROR_PRIVILEGE_NOT_HELD)
                        {
                            retVal = 0;
                            bSuccess = FALSE;
                            a_ErrorObject.SetWbemStatus ( WBEM_E_ACCESS_DENIED ) ;
                            a_ErrorObject.SetMessage ( L"Opened the logfile but failed to back it up, privilege error" ) ;
                            a_ErrorObject.SetPrivilegeFailed();
                            a_ErrorObject.SetBackupPrivRequired();
                            a_ErrorObject.SetBackupPrivFailed();
                        }

                    }
                    else
                    {
                    DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:After privilege set, BackupEventLog %s succeeded.\r\n",
        m_logname
        ) ;
)
                    }
                }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed to BackupEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
            }
        }

        CloseEventLog(hEventLog);
    }

    return retVal;
}

BOOL CEventlogFileAttributes::GenerateInstance(IWbemClassObject* pClassObj, IWbemClassObject* pAClassObj, IWbemClassObject** ppInst)
{
    if (pClassObj == NULL)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Invalid parameter - Return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    if (ReadRegistry() != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Failed to read registry values - Return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    HRESULT hr = pClassObj->SpawnInstance(0, ppInst);

    if (FAILED(hr))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Failed to spawn instance - Return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    //set the key properties, they are all in the super class
    if (!SetSuperClassProperties(*ppInst))
    {
        //can't set the key, just return
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Failed to set key values - Return FALSE\r\n"
        ) ;
)
        
        (*ppInst)->Release();
        return FALSE;
    }

    //set the evtlog properties...
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = m_logname.AllocSysString();
    hr = (*ppInst)->Put(PROP_LOGNAME, 0, &v, 0);
    VariantClear(&v); // will call free v.bstrVal

    VariantInit(&v);
    v.vt = VT_I4;
    v.lVal = m_fileSz;
    hr = (*ppInst)->Put(PROP_MAXSZ, 0, &v, 0);
    VariantClear(&v);

    VariantInit(&v);
    v.vt = VT_I4;

    if ((m_retention > 0) && (m_retention < EVT_NEVER_AGE))
    {
        //turn into days
        v.lVal = m_retention/EVT_UNITS_FROM_DAYS;

        if (v.lVal > MAX_EVT_AGE)
        {
            v.lVal = MAX_EVT_AGE;
        }
    }
    else
    {
        v.lVal = m_retention;
    }

    hr = (*ppInst)->Put(PROP_RETENTION, 0, &v, 0);

	if (pAClassObj)
	{
		SetRetentionStr(pAClassObj, *ppInst, (DWORD)v.lVal);
	}

    VariantClear(&v);

    HANDLE hEventLog = OpenEventLog(NULL, m_logname);

    if (hEventLog == NULL)
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            CEventLogFile::SetSecurityLogPrivilege();
            hEventLog = OpenEventLog(NULL, m_logname);
        }
    }

    if (hEventLog != NULL)
    {
        DWORD num_recs = 0;
        
        if (GetNumberOfEventLogRecords(hEventLog, &num_recs))
        {
            VariantInit(&v);
            v.vt = VT_I4;
            v.lVal = num_recs;
            hr = (*ppInst)->Put(PROP_NUMRECS, 0, &v, 0);
            VariantClear(&v);
        }
        
        CloseEventLog(hEventLog);
    }

    LONG count = m_sources.GetSize();

    if (count > 0)
    {
        SAFEARRAYBOUND rgsabound[1];
        SAFEARRAY* psa = NULL;
        BSTR* pBstr = NULL;
        rgsabound[0].lLbound = 0;
        VariantInit(&v);
        rgsabound[0].cElements = count;
        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);

        if (NULL != psa)
        {
            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
            {
                for (LONG x = 0; x < count; x++)
                {
                    pBstr[x] = m_sources[x]->AllocSysString();
                    delete m_sources[x];
					m_sources[x] = NULL;
                }
                
                m_sources.RemoveAll();
                SafeArrayUnaccessData(psa);
                v.vt = VT_ARRAY|VT_BSTR;
                v.parray = psa;
                hr = (*ppInst)->Put(PROP_SOURCES, 0, &v, 0);
            }
        }

        VariantClear(&v);
    }

    return TRUE;
}

ULONG CEventlogFileAttributes::GetIndex(wchar_t* indexStr, BOOL* bError)
{
#if 0
    __int64 val = _wtoi64(indexStr);
#else
    int val = _wtoi(indexStr);
#endif
    *bError = FALSE;
    ULONG index = 0;

    switch (val)
    {
        case 0:     //Always overwrite
        {
            index = 0;
            break;
        }
        case 1:     //1-365
        {
            index = 1;
            break;
        }
        case EVT_NEVER_AGE: //0xffffffff
        {
            index = 2;
            break;
        }
        default:
        {
            *bError = TRUE;
        }
    }

    return index;
}

void CEventlogFileAttributes::SetRetentionStr(IWbemClassObject* pClassObj, IWbemClassObject* pInstObj, DWORD dwVal)
{
    CStringW strRetentionArray[RETENTION_ARRAY_LEN];

    if (CEventlogRecord::SetEnumArray(pClassObj, PROP_RETENTION_STR,(CStringW*) strRetentionArray,
                                    RETENTION_ARRAY_LEN, (GetIndexFunc)GetIndex))
    {
        BSTR retStr = NULL;

        if (dwVal == 0)
        {
            retStr = strRetentionArray[0].AllocSysString();
        }
        else if (dwVal == EVT_NEVER_AGE)
        {
            retStr = strRetentionArray[2].AllocSysString();
        }
        else
        {
            retStr = strRetentionArray[1].AllocSysString();
        }

        if (retStr != NULL)
        {
            VARIANT v;
            VariantInit (&v);
            v.vt = VT_BSTR;
            v.bstrVal = retStr;
            HRESULT hr = pInstObj->Put(PROP_RETENTION_STR, 0, &v, 0);
            VariantClear(&v);
        }
    }
}

BOOL CEventlogFileAttributes::SetSuperClassProperties(IWbemClassObject* pInst)
{
    //failure to set any key property
    //is an error, return FALSE!!

    VARIANT v;

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = m_logpath.AllocSysString();
    HRESULT hr = pInst->Put(PROP_NAME, 0, &v, 0);
    VariantClear(&v);

    if (FAILED(hr))
    {
        return FALSE;
    }

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(VAL_FS_CRE_CLASS);
    hr = pInst->Put(PROP_FS_CRE_CLASS, 0, &v, 0);
    VariantClear(&v);

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(NTEVTLOG_CLASS);
    hr = pInst->Put(PROP_CRE_CLASS, 0, &v, 0);
    VariantClear(&v);

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(COMP_CLASS);
    hr = pInst->Put(PROP_CS_CRE_CLASS, 0, &v, 0);
    VariantClear(&v);

    return TRUE;
}

DWORD CEventlogFileAttributes::UpdateRegistry(IWbemClassObject* pInst)
{
    if (NULL == pInst)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //get the data to be written
    VARIANT v;
    HRESULT hr = pInst->Get(PROP_RETENTION, 0, &v,NULL, NULL);

    if (SUCCEEDED(hr))
    {
        m_retention = (DWORD)v.lVal;
        VariantClear(&v);

        if ((m_retention > MAX_EVT_AGE) && (m_retention < EVT_NEVER_AGE))
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Retention Data not in range\r\n"
        ) ;
)
            return ERROR_INVALID_DATA;
        }

        if ((m_retention > 0) && (m_retention < EVT_NEVER_AGE))
        {
            m_retention = m_retention * EVT_UNITS_FROM_DAYS;
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to get retention value from instance\r\n"
        ) ;
)

        return (DWORD)hr;
    }

    hr = pInst->Get(PROP_MAXSZ, 0, &v,NULL, NULL);

    if (SUCCEEDED(hr))
    {
        m_fileSz = (DWORD)v.lVal;
        VariantClear(&v);

        if (m_fileSz < FILE_CHUNK_SZ)
        {
            m_fileSz = FILE_CHUNK_SZ;
        }
        else if (m_fileSz > MAX_EVT_LOG_SZ)
        {
            m_fileSz = MAX_EVT_LOG_SZ;
        }
        else
        {
            DWORD rem = m_fileSz % FILE_CHUNK_SZ;

            if (rem != 0)
            {
                //need to round up to nearest file chunk size
                DWORD x = m_fileSz / FILE_CHUNK_SZ;
                m_fileSz = (++x) * FILE_CHUNK_SZ;
            }
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to get MaxFileSize value from instance\r\n"
        ) ;
)
        return (DWORD)hr;
    }

    DWORD retVal;
    CStringW strKey(EVENTLOG_BASE);
    strKey += CStringW(L'\\');
    strKey += m_logname;

    HKEY hkResult;
    //open the logfile's key for setting values
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            strKey, 0,
                            KEY_SET_VALUE,
                            &hkResult);
    
    if (status != ERROR_SUCCESS)
    {
        // indicate error
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Open registry to set new values. Error %lx\r\n",
        status
        ) ;
)
        return status;
    }

    //set the values we read in...
    status = RegSetValueEx(hkResult,
                            EVTLOG_REG_MAXSZ_VALUE, 0, REG_DWORD,
                            (CONST BYTE *) &m_fileSz, sizeof(DWORD));

    if (status != ERROR_SUCCESS)
    {
        // indicate error
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to set new size. Error %lx\r\n",
        status
        ) ;
)
        retVal = status;
    }
    else
    {
        retVal =(DWORD) RegSetValueEx(hkResult,
                                EVTLOG_REG_RETENTION_VALUE, 0, REG_DWORD,
                                (CONST BYTE *) &m_retention, sizeof(DWORD));
        
        if (retVal != ERROR_SUCCESS)
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to set new retention policy. Error %lx\r\n",
        retVal
        ) ;
)
        }
    }

    RegCloseKey(hkResult);
    return retVal;
}


DWORD CEventlogFileAttributes::ReadRegistry()
{
    DWORD retVal;
    CStringW strKey(EVENTLOG_BASE);
    strKey += CStringW(L'\\');
    strKey += m_logname;
    HKEY hkResult;

    //open the logfile's key for read
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            strKey, 0,
                            KEY_QUERY_VALUE,
                            &hkResult);
    
    if (status != ERROR_SUCCESS)
    {
        // indicate error
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to open registry. Error %lx\r\n",
        status
        ) ;
)

        retVal = status;
    }
    else
    {
        //first get the file value
        m_logpath = CEventLogFile::GetFileName(hkResult);
        DWORD datalen;
        DWORD dwType;
        wchar_t* data;

        if (m_logpath.IsEmpty())
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to resolve log file name\r\n"
        ) ;
)
            retVal = ERROR_INVALID_DATA;
        }
        else
        {
            datalen = sizeof(m_fileSz);
            status = RegQueryValueEx(hkResult, EVTLOG_REG_MAXSZ_VALUE,
                        0, &dwType, (LPBYTE) &m_fileSz, &datalen);

			if ( ERROR_SUCCESS == status )
			{
				retVal = 0;
			}
			else if ( ERROR_FILE_NOT_FOUND == status )
			{
				//
				// we assume 512KB (same story with nt event viewer)
				// was set in constructor
				//

				retVal = 0;
			}
			else if( REG_DWORD != dwType )
            {
                retVal = ERROR_INVALID_DATA;
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read size. Error %lx\r\n",
        status
        ) ;
)
                retVal = status;
            }

			if ( 0 == retVal )
            {
                datalen = sizeof(m_retention);
                status = RegQueryValueEx(hkResult, EVTLOG_REG_RETENTION_VALUE,
                            0, &dwType, (LPBYTE) &m_retention, &datalen);

				if ( ERROR_SUCCESS == status )
				{
					retVal = 0;
				}
				else if ( ERROR_FILE_NOT_FOUND == status )
				{
					//
					// we assume 7 dyas (same story with nt event viewer)
					// was set in constructor
					//

					retVal = 0;
				}
				else if( REG_DWORD != dwType )
				{
					retVal = ERROR_INVALID_DATA;
				}
				else
				{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read retention. Error %lx\r\n",
        status
        ) ;
)
                    retVal = status;
                }
            }
        }

        if (retVal == 0)
        {
            data = new wchar_t[MAX_PATH + 1];
            datalen = (MAX_PATH + 1) * sizeof(wchar_t);
            status = RegQueryValueEx(hkResult, EVTLOG_REG_SOURCES_VALUE,
                        0, &dwType, (LPBYTE) data, &datalen);
            
            if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) &&
                (dwType == REG_MULTI_SZ))
            {
                if (status == ERROR_MORE_DATA)
                {
                    delete [] data;
                    data = new wchar_t[datalen];
                    status = RegQueryValueEx(hkResult, EVTLOG_REG_SOURCES_VALUE,
                                0, &dwType, (LPBYTE) data, &datalen);
                }

                if (status == ERROR_SUCCESS)
                {
                    wchar_t* tmp = data;
                    int x = 0;

                    while (*tmp != L'\0')
                    {
                        CStringW* tmpstr = new CStringW(tmp);
                        m_sources.SetAtGrow(x++, tmpstr);
                        tmp += wcslen(tmp) + 1;
                    }
                }
                else
                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read sources. Error %lx\r\n",
        status
        ) ;
)
                }
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read sources. Error %lx\r\n",
        status
        ) ;
)

            }

            delete [] data;
        }
        
        RegCloseKey(hkResult);
    }

    return retVal;
}

CEventLogFile::CEventLogFile(const WCHAR* logname, BOOL bVerify) : m_hEvtLog(NULL), m_BuffLen (0)
{
    m_Reason = ERROR_SUCCESS;
    m_EvtLogName = logname;
    m_bValid = FALSE;
    m_bBuffer = FALSE;
    m_hEvtLog = NULL;
    m_Buffer = NULL;

	if (bVerify)
	{
		if (logname != NULL)
		{
			DWORD cchBase = wcslen(EVENTLOG_BASE);
			DWORD cchSize = cchBase + 1 + wcslen(logname) + 1;
			wchar_t* buff = new wchar_t[ cchSize ];
			StringCchCopyW ( buff, cchBase + 1, EVENTLOG_BASE );
			StringCchCatW ( buff, cchSize, L"\\" );
			StringCchCatW ( buff, cchSize, logname);

			HKEY hkResult = NULL;
			m_Reason = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
									buff, 0,
									KEY_READ,
									&hkResult);

			if (m_Reason == ERROR_SUCCESS)
			{
				if (hkResult != NULL)
				{
					RegCloseKey(hkResult);
					hkResult = NULL;
				}
				else
				{
					m_Reason = ERROR_FILE_NOT_FOUND;
				}
			}

			delete [] buff;
			buff = NULL;
		}
		else
		{
			m_Reason = ERROR_FILE_NOT_FOUND;
		}
	}

	if (m_Reason == ERROR_SUCCESS)
	{
		m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);

		if (m_hEvtLog == NULL)
		{
			if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
			{
				SetSecurityLogPrivilege();
				m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);
			}
		}

		m_bValid = (NULL != m_hEvtLog);

		if (!m_bValid)
		{
			m_Reason = GetLastError();
		}
	}
}

CEventLogFile::~CEventLogFile()
{
    if (0 != m_BuffLen)
    {
        delete [] m_Buffer;
    }

    if (NULL != m_hEvtLog)
    {
        CloseEventLog(m_hEvtLog);
    }
}

BOOL CEventLogFile::QueryRegForFileName(HKEY hk_Log, const wchar_t* valname, wchar_t** res, DWORD* dwType)
{
    BOOL retVal = FALSE;
    *res = new wchar_t[MAX_PATH + 1];
    DWORD datalen = (MAX_PATH + 1) * sizeof(wchar_t);
    LONG status = RegQueryValueEx(hk_Log, valname,
                        0, dwType, (LPBYTE)(*res), &datalen);

    if (status != ERROR_SUCCESS)
    {
        if (status == ERROR_MORE_DATA)
        {
            delete [] *res;
            *res = new wchar_t[datalen];
            status = RegQueryValueEx(hk_Log, valname,
                        0, dwType, (LPBYTE)(*res), &datalen);
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::QueryRegForFileName:Failed to get %s value\r\n",
        valname
        ) ;
)
        }
    }

    if ((status == ERROR_SUCCESS) && ((*dwType == REG_EXPAND_SZ) || (*dwType == REG_SZ)))
    {
        retVal = TRUE;
    }
    else
    {
        delete [] *res;
        *res = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::QueryRegForFileName:Failed\r\n"
        ) ;
)

    }

    return retVal;
}

CStringW CEventLogFile :: ExpandFileName ( const wchar_t* filepath )
{
	CStringW retVal ;
    DWORD cbExpand = ExpandEnvironmentStrings(filepath, NULL, 0);
    DWORD datalen = cbExpand ;
	wchar_t *fullpath = new wchar_t[datalen];
    cbExpand = ExpandEnvironmentStrings(filepath, fullpath, datalen);
    if (cbExpand == 0)
    {
        delete [] fullpath;
    }
    else
    {
		if ( cbExpand == datalen )
		{
			retVal = fullpath;
			delete [] fullpath;
		}
		else
		{
			delete [] fullpath;
		}
    }
    
    return retVal ;
}

DWORD CEventLogFile::GetFileNames(HKEY hk_Log, CStringW** names, const wchar_t* valname)
{
    DWORD retVal = 0;
    wchar_t* path = NULL;
    DWORD dwType;

    if (QueryRegForFileName(hk_Log, valname, &path, &dwType) && (path != NULL))
    {
        //got the comma or semi-colon separated list
        //need to separate it into
        retVal = 1;
        wchar_t* tmp = wcspbrk(path, L",;");

        while (tmp != NULL)
        {
            //don't count chars at start of string!
            if (tmp != path)
            {
                retVal++;
            }

            while ((*tmp == L',') || (*tmp == L';'))
            {
                *tmp = L'\0';
                tmp++;
            }

            tmp = wcspbrk(tmp, L",;");
        }

        *names = new CStringW[retVal];
        tmp = path;

        for (int x = 0; x < retVal; x++)
        {
            while (*tmp == L'\0')
            {
                tmp++;
            }

            (*names)[x] = ExpandFileName(tmp);
            tmp += wcslen(tmp);
        }

        delete [] path;
    }

    return retVal;
}

CStringW CEventLogFile::GetFileName(HKEY hk_Log, const wchar_t* valname)
{
    CStringW retVal;
    wchar_t* path = NULL;
    DWORD dwType;

    if (QueryRegForFileName(hk_Log, valname, &path, &dwType) && (path != NULL))
    {
        if (dwType == REG_EXPAND_SZ)
        {
            retVal = ExpandFileName( path );
        }
        else
        {
            retVal =  path;
        }

        delete [] path;
    }

    return retVal;
}

BOOL CEventLogFile::SetSecurityLogPrivilege(BOOL bProcess, LPCWSTR privName)
{
    BOOL bResult = TRUE;

    //only need the security mutex if not NT5
    DWORD dwVersion = GetVersion();

    if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
    {
        bResult = ObtainedSerialAccess(CNTEventProvider::g_secMutex);
    }

    if (bResult)
    {
        HANDLE hToken = NULL;

        if (bProcess)
        {
            bResult = OpenProcessToken(GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hToken);

            if ( ! bResult )
            {
                DWORD t_LastError = GetLastError () ;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::SetSecurityLogPrivilege:Failed to open process token: Error %lx\r\n",
        t_LastError 
        ) ;
)
            }

            HANDLE hThreadToken = 0 ;
            bResult = OpenThreadToken(GetCurrentThread(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE |TOKEN_QUERY,
                                TRUE, &hToken);


            if ( bResult)
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::SetSecurityLogPrivilege:Thread Token Present\r\n"
        ) ;
)

            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::SetSecurityLogPrivilege:Thread Token Missing\r\n"
        ) ;
)

            }
            
            CloseHandle ( hThreadToken ) ;
        }
        else
        {
            bResult = OpenThreadToken(GetCurrentThread(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE |TOKEN_QUERY,
                                TRUE, &hToken);
        }

        if (bResult)
        {
            // Enable Security Privilege...
            LUID Luid;
            bResult = LookupPrivilegeValue(NULL, privName, &Luid);
         
            if (bResult)
            {   
                TOKEN_PRIVILEGES newPriv;
                newPriv.PrivilegeCount = 1;
                newPriv.Privileges[0].Luid = Luid;
                newPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                bResult = AdjustTokenPrivileges(hToken,     // TokenHandle
                                                FALSE,      // DisableAllPrivileges
                                                &newPriv,   // NewState (OPTIONAL)
                                                NULL,   // BufferLength
                                                NULL,       // PreviousState
                                                NULL);  // ReturnLength

                DWORD dwErr = GetLastError();

                if (dwErr != ERROR_SUCCESS)
                {
                    bResult = FALSE;
                }
            }       
                    
            if (hToken != NULL)
            {
                CloseHandle( hToken );
            }
        }
    
        if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
        {
            ReleaseSerialAccess(CNTEventProvider::g_secMutex);
        }
    }

    return bResult;
}

CStringW CEventLogFile::GetLogName(const WCHAR* file_name)
{
    // open registry for log names
    CStringW retVal;

    if (file_name == NULL)
    {
        return retVal;
    }

    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::GetLogName:Failed to open registry: Error %lx\r\n",
        status
        ) ;
)
        return retVal;
    }

    DWORD iValue = 0;
    WCHAR t_logname[MAX_PATH+1];
    DWORD t_lognameSize = MAX_PATH;

    // read all entries under this key to find all logfiles...
    while ((status = RegEnumKey(hkResult, iValue, t_logname, t_lognameSize)) != ERROR_NO_MORE_ITEMS)
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::GetLogName:Failed while enumerating registry: Error %lx\r\n",
        status
        ) ;
)
            // indicate error
            break;
        }

        //open logfile key
        HKEY hkLog;

        if (ERROR_SUCCESS == RegOpenKeyEx(hkResult, t_logname, 0, KEY_QUERY_VALUE, &hkLog))
        {
            CStringW fname = GetFileName(hkLog);
            RegCloseKey(hkLog);

            if (!fname.IsEmpty() && (0 == _wcsicmp(fname, file_name)))
            {
                retVal = t_logname;
                break;
            }
        }

        // read next parameter
        iValue++;

    } // end while

    RegCloseKey(hkResult);
    return retVal;
}

void CEventLogFile::RefreshHandle()
{
    m_LogLock.Lock();

    if (NULL != m_hEvtLog)
    {
        CloseEventLog(m_hEvtLog);
    }
    
    m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);

    if (m_hEvtLog == NULL)
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            SetSecurityLogPrivilege();
            m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);
        }
    }

    m_LogLock.Unlock();
     
    if (NULL != m_hEvtLog)
    {
        m_bValid = TRUE;
        m_Reason = 0;
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::RefreshHandle:Invalid log\r\n"
        ) ;
)
        m_bValid = FALSE;
        m_Reason = GetLastError();
    }
}

DWORD CEventLogFile::FindOldEvent(DWORD evtID, const wchar_t* source, DWORD* recID, time_t offset)
{
    DWORD dwRet = 0;
    time_t timeVal;

    if (offset > 0)
    {
        time(&timeVal);
        timeVal -= offset;
    }

    DWORD dwEventSize = 0;
    DWORD lastErr = ReadRecord(0, &dwEventSize, TRUE);

    if (0 != lastErr)
    {
        if (lastErr != ERROR_HANDLE_EOF)
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::FindOldEvent:Log no longer valid\r\n"
        ) ;
)

            m_bValid = FALSE;
        }
    }
    else
    {
        while (TRUE)
        {
            if (lastErr != 0)
            {
                if (lastErr != ERROR_HANDLE_EOF)
                {
                    m_bValid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::FindOldEvent:Log no longer valid\r\n"
        ) ;
)
                }

                break;
            }
            else
            {
                PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)m_Buffer;
                BOOL bDone = FALSE;

                while (dwEventSize != 0)
                {
                    //eventid and sourcename identify event
                    if ((source != NULL) && (evtID == EventBuffer->EventID) && 
                        (0 == _wcsicmp(source,
                                (const wchar_t*)((UCHAR*)EventBuffer + sizeof(EVENTLOGRECORD))
                                )
                        )
                    )
                    {
                        if (offset > 0)
                        {
                            if (EventBuffer->TimeWritten < timeVal)
                            {
                                bDone = TRUE;
                                break;
                            }
                            
                        }

                        dwRet = EventBuffer->TimeWritten;

                        if (recID != NULL)
                        {
                            *recID = EventBuffer->RecordNumber;
                        }

                        bDone = TRUE;
                        break;
                    }
                    else
                    {
                        if (offset > 0)
                        {
                            if (EventBuffer->TimeWritten < timeVal)
                            {
                                bDone = TRUE;
                                break;
                            }
                            else
                            {
                                if (recID != NULL)
                                {
                                    *recID = EventBuffer->RecordNumber;
                                }
                            }
                        }
                    }
                    
                    // drop by length of this record and point to next record
                    dwEventSize -= EventBuffer->Length;
                    EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
                }

                if (bDone)
                {
                    break;
                }
                else
                {
                    lastErr = ReadRecord(0, &dwEventSize, TRUE);
                }
            }
        }
    }
    
    return dwRet;
}

BOOL CEventLogFile::GetLastRecordID(DWORD& rec, DWORD& numrecs)
{
    rec = 0;
    numrecs = 0;
    m_LogLock.Lock();

    if (!GetNumberOfEventLogRecords(m_hEvtLog, &numrecs))
    {
        m_LogLock.Unlock();
        return FALSE;
    }

    if (numrecs != 0)
    {
        DWORD last_rec = 0;

        if (!GetOldestEventLogRecord(m_hEvtLog, &last_rec))
        {
            m_LogLock.Unlock();
            return FALSE;
        }
		
		if (0xFFFFFFFF - last_rec >= numrecs)
		{
			rec = numrecs + last_rec - 1;
		}
		else
		{
			//we have to guard the overflow...
			rec = numrecs - (0xFFFFFFFF - last_rec) - 1;
		}
    }
    
    m_LogLock.Unlock();
    return TRUE;
}

DWORD CEventLogFile::ReadRecord(DWORD recID, DWORD* dwBytesRead, BOOL b_Back)
{
    if (NULL != dwBytesRead)
    {
        *dwBytesRead = 0;
    }

    DWORD dwFlags;

    if (recID == 0)
    {
        dwFlags = EVENTLOG_SEQUENTIAL_READ;
    }
    else
    {
        dwFlags = EVENTLOG_SEEK_READ;
    }

    if (b_Back)
    {
        dwFlags = dwFlags | EVENTLOG_BACKWARDS_READ;
    }
    else
    {
        dwFlags = dwFlags | EVENTLOG_FORWARDS_READ;
    }

    m_bBuffer = TRUE;

    if (0 == m_BuffLen)
    {
        m_BuffLen = 2048;
        m_Buffer = new BYTE[m_BuffLen];
    }

    DWORD dwRead = 0;
    DWORD dwNext = 0;
    m_LogLock.Lock();

    if ( !ReadEventLog(m_hEvtLog,
                dwFlags,
                recID,
                m_Buffer,
                m_BuffLen,
                &dwRead,
                &dwNext))
    {
        DWORD err = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == err)
        {
            delete [] m_Buffer;
            m_Buffer = NULL;
            m_BuffLen = 5*dwNext;
            m_Buffer = new BYTE[m_BuffLen];

            if ( !ReadEventLog(m_hEvtLog,
                dwFlags,
                recID,
                m_Buffer,
                m_BuffLen,
                &dwRead,
                &dwNext))
            {
                m_LogLock.Unlock();
                return GetLastError();
            }
        }
        else
        {
            m_LogLock.Unlock();
            return err;
        }
    }

    if (NULL != dwBytesRead)
    {
        *dwBytesRead = dwRead;
    }

    m_bBuffer = TRUE;
    m_LogLock.Unlock();
    return 0;
}

DWORD CEventLogFile::ReadFirstRecord()
{
    DWORD last_rec = 0;
    DWORD dwRead = 0;
    m_bValid = FALSE;
    m_LogLock.Lock();
    BOOL bTest = GetOldestEventLogRecord(m_hEvtLog, &last_rec);
    m_LogLock.Unlock();

    if (bTest)
    {
        DWORD lastErr = ReadRecord(last_rec, &dwRead);

        if (0 != lastErr)
        {
            if (lastErr == ERROR_HANDLE_EOF)
            {
                m_bValid = TRUE;
            }
        }
        else
        {
            m_bValid = TRUE;
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadFirstRecord:Failed to get oldest record\r\n"
        ) ;
)

    }

    return dwRead;
}

void CEventLogFile::ReadLastRecord()
{
    DWORD recID = 0;
    DWORD numRecs = 0;
    m_bValid = FALSE;


    if (GetLastRecordID(recID, numRecs))
    {
        DWORD lastErr = ReadRecord(recID);

        if (0 != lastErr)
        {
            if (lastErr == ERROR_HANDLE_EOF)
            {
                m_bValid = TRUE;
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadLastRecord:Failed to read last record\r\n"
        ) ;
)

            }
        }
        else
        {
            while (0 == (lastErr = ReadRecord(0)));

            if (lastErr == ERROR_HANDLE_EOF)
            {
                m_bValid = TRUE;
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadLastRecord:Failed to read last record\r\n"
        ) ;
)

            }
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadLastRecord:Failed to read last record\r\n"
        ) ;
)

    }
}


HANDLE CEventLogFile::OpenLocalEventLog(LPCWSTR a_log, DWORD *a_Reason)
{
    HANDLE retVal = NULL;

    if (a_Reason)
    {
        *a_Reason = 0;
    }

    HKEY hkLog;
    CStringW log(EVENTLOG_BASE);
    log += L"\\";
    log += a_log;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, log, 0, KEY_READ, &hkLog))
    {
        *a_Reason  = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        RegCloseKey(hkLog);
        retVal = OpenEventLog(NULL, a_log);
        DWORD t_dwErr = GetLastError();

        if (retVal == NULL)
        {
            if (t_dwErr == ERROR_PRIVILEGE_NOT_HELD)
            {
                SetSecurityLogPrivilege();
                retVal = OpenEventLog(NULL, a_log);
                t_dwErr = GetLastError();
            }
            else if (a_Reason)
            {
                *a_Reason = t_dwErr;
            }
        }

        if ((NULL == retVal) && a_Reason && (*a_Reason == 0))
        {
            *a_Reason = t_dwErr;
        }
    }

    return retVal;
}


CMonitoredEventLogFile::CMonitoredEventLogFile(CEventProviderManager* parent, const WCHAR* logname)
: ProvTaskObject(), CEventLogFile(logname, FALSE), m_Class (NULL)
{
    InterlockedIncrement(&(CNTEventProviderClassFactory::objectsInProgress));
	VariantInit(&m_VpsdSelfRel);
    m_RecID = 0;

    if (parent != NULL)
    {
        m_parent = parent;
    }
    else
    {
        m_bValid = FALSE;
    }

    if (IsValid())
    {
        ReadLastRecord();

        if (IsValid())
        {
            m_LogLock.Lock();
            m_bValid = NotifyChangeEventLog(m_hEvtLog, GetHandle());
			m_bValid = m_bValid && SetEventDescriptor();
            m_LogLock.Unlock();
        }
    }

    if (!m_bValid)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::CMonitoredEventLogFile:Invalid log created\r\n"
        ) ;
)

    }
}

CMonitoredEventLogFile::~CMonitoredEventLogFile()
{
    if (m_Class != NULL)
    {
        m_Class->Release();
    }

	VariantClear(&m_VpsdSelfRel);

    InterlockedDecrement(&(CNTEventProviderClassFactory::objectsInProgress));
}

void CMonitoredEventLogFile::RefreshHandle()
{
    CEventLogFile::RefreshHandle();

    if (IsValid())
    {
        m_LogLock.Lock();
        m_bValid = NotifyChangeEventLog(m_hEvtLog, GetHandle());
        m_LogLock.Unlock();
    }

    if (!m_bValid)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::RefreshHandle:Invalid log\r\n"
        ) ;
)

    }

}

BOOL CMonitoredEventLogFile::GenerateInstance(IWbemClassObject** ppEvtInst,
                                              IWbemClassObject* pEmbedObj)
{
    HRESULT hr;

    if ((ppEvtInst == NULL) || (pEmbedObj == NULL))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Invalid parameter\r\n"
        ) ;
)
        return FALSE;
    }
    else
    {
        *ppEvtInst = NULL;
    }

    if (m_Class == NULL)
    {
        BSTR path = SysAllocString(EVENT_CLASS);
        IWbemServices* ns = m_parent->GetNamespacePtr();

        if (ns == NULL)
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
            hr = ns->GetObject(path, 0, NULL, &m_Class, NULL);
            SysFreeString(path);
            ns->Release();
        }

        if (FAILED(hr))
        {
            m_Class = NULL;         
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to get class object\r\n"
        ) ;
)
            
            return FALSE;
        }
    }

    hr = m_Class->SpawnInstance(0, ppEvtInst);

    if (FAILED(hr))
    {
        m_Class->Release();
        m_Class = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to spawn instance\r\n"
        ) ;
)
        
        return FALSE;
    }

    hr = (*ppEvtInst)->Put(SD_PROP, 0, &m_VpsdSelfRel, 0);

    if (FAILED(hr))
    {
        (*ppEvtInst)->Release();
        *ppEvtInst = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to set security descriptor into event\r\n"
        ) ;
)
        return FALSE;
    }

    VARIANT v;
    VariantInit(&v);
#ifdef STILL_DISPATCH
    v.vt = VT_DISPATCH;
    v.pdispVal = pEmbedObj;
#else
    v.vt = VT_UNKNOWN;
    v.punkVal = pEmbedObj;
#endif
    pEmbedObj->AddRef();
    hr = (*ppEvtInst)->Put(TARGET_PROP, 0, &v, 0);
    VariantClear(&v); // will call release on value stored in variant

    if (FAILED(hr))
    {
        (*ppEvtInst)->Release();
        *ppEvtInst = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to embed target instance into event\r\n"
        ) ;
)
        return FALSE;
    }

    return TRUE;
}


void CMonitoredEventLogFile::Process()
{
    SetStructuredExceptionHandler seh;

    try
    {
        //Read and process the eventlog
        DWORD dwEventSize = 0;
        DWORD err = ReadRecord(m_RecID, &dwEventSize);
        m_RecID = 0;

        while (TRUE)
        {
            if (err != 0)
            {
                if (err == ERROR_HANDLE_EOF)
                {
                    break;
                }
                else
                {
                    RefreshHandle();

                    if (!m_bValid)
                    {
                        //log cannot be monitored
                        Complete();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::Process:log cannot be read\r\n"
        ) ;
)

                        break;
                    }

                    if (err == ERROR_EVENTLOG_FILE_CHANGED)
                    {
                        err = 0;
                        continue;
                    }
                    else
                    {
                        ReadLastRecord();

                        if (!m_bValid)
                        {
                            //log cannot be monitored
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::Process:log cannot be read\r\n"
        ) ;
)
                            Complete();
                            break;
                        }
                    }
                }

                break;

            }
            else
            {
                PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)m_Buffer;
            
                while (dwEventSize != 0)
                {
                    //generate records...
                    IWbemServices* ns = m_parent->GetNamespacePtr();
                    
                    if (ns == NULL)
                    {
                        //no control objects!
                        return;
                    }

                    CEventlogRecord evtrec(m_EvtLogName, EventBuffer, ns);
                    ns->Release();
                    IWbemClassObject* pEmbedInst = NULL;
                    
                    if (evtrec.GenerateInstance(&pEmbedInst))
                    {
                        IWbemClassObject* pEvtInst;

                        if (GenerateInstance(&pEvtInst, pEmbedInst))
                        {
                            m_parent->SendEvent(pEvtInst);
                            pEvtInst->Release();
                        }

                        pEmbedInst->Release();
                    }

                    // drop by length of this record and point to next record
                    dwEventSize -= EventBuffer->Length;
                    EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
                }
            }

            dwEventSize = 0;
            err = ReadRecord(0, &dwEventSize);
        }
    }
    catch(Structured_Exception e_SE)
    {
        try
        {
            Complete();
        }
		catch(...)
		{
			return;
		}
    }
    catch(Heap_Exception e_HE)
    {
        try
        {
            Complete();
        }
		catch(...)
		{
			return;
		}
    }
    catch(...)
    {
        try
        {
            Complete();
        }
		catch(...)
		{
			return;
		}
    }

}

static GENERIC_MAPPING LogFileObjectMapping = {

    STANDARD_RIGHTS_READ           |       // Generic read
        ELF_LOGFILE_READ           |
		WBEM_RIGHT_SUBSCRIBE,

    STANDARD_RIGHTS_WRITE          |       // Generic write
        ELF_LOGFILE_WRITE          |
		WBEM_RIGHT_SUBSCRIBE,

    STANDARD_RIGHTS_EXECUTE        |       // Generic execute
        ELF_LOGFILE_START          |
        ELF_LOGFILE_STOP           |
        ELF_LOGFILE_CONFIGURE      |
		WBEM_RIGHT_SUBSCRIBE,

    ELF_LOGFILE_ALL_ACCESS         |       // Generic all
		WBEM_RIGHT_SUBSCRIBE
    };

BOOL CMonitoredEventLogFile::SetEventDescriptor()
{
	BOOL retVal = FALSE;
    DWORD NumberOfAcesToUse = 0;
//
// Logfile object specific access type
//
    RTL_ACE_DATA AceData[ELF_LOGFILE_OBJECT_ACES] = {

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
			ELF_LOGFILE_ALL_ACCESS | WBEM_RIGHT_SUBSCRIBE,               &CNTEventProvider::s_AnonymousLogonSid},

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS | WBEM_RIGHT_SUBSCRIBE,               &CNTEventProvider::s_AliasGuestsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS | WBEM_RIGHT_SUBSCRIBE,               &CNTEventProvider::s_LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR | WBEM_RIGHT_SUBSCRIBE, &CNTEventProvider::s_AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_BACKUP,                   &CNTEventProvider::s_AliasBackupOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR | WBEM_RIGHT_SUBSCRIBE, &CNTEventProvider::s_AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | WBEM_RIGHT_SUBSCRIBE,                     &CNTEventProvider::s_WorldSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_LocalServiceSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_NetworkServiceSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_WorldSid}
        };

    PRTL_ACE_DATA pAceData = NULL;

    //
    // NON_SECURE logfiles let anyone read/write to them, secure ones
    // only let admins/local system do this.  so for secure files we just
    // don't use the last ACE
    //
    // Adjust the ACL start based on the passed GuestAccessRestriction flag.
    // The first two aces deny all log access to guests and/or anonymous
    // logons. The flag, GuestAccessRestriction, indicates that these two
    // deny access aces should be applied. Note that the deny aces and the
    // GuestAccessRestriction flag are not applicable to the security log,
    // since users and anonymous logons, by default, do not have access.
    //

	DWORD cchBase = wcslen(EVENTLOG_BASE);
	DWORD cchSize = cchBase + 1 + m_EvtLogName.GetLength() + 1;
	wchar_t* buff = new wchar_t[ cchSize ];
	StringCchCopyW ( buff, cchBase + 1, EVENTLOG_BASE );
	StringCchCatW ( buff, cchSize, L"\\" );
	StringCchCatW ( buff, cchSize, m_EvtLogName );

	HKEY hkResult = NULL;
	BOOL GuestAccessRestriction = TRUE;

	DWORD dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							buff, 0,
							KEY_READ,
							&hkResult);

	if (dwErr == ERROR_SUCCESS)
	{
		DWORD datalen = sizeof(DWORD);
		DWORD dwType = 0;
		DWORD dwVal = 0;

		dwErr = RegQueryValueEx(hkResult, GUEST_ACCESS,
					0, &dwType, (LPBYTE) &dwVal, &datalen);

		if ((dwErr == ERROR_SUCCESS) && (dwType == REG_DWORD))
		{
			if (dwVal == 0)
			{
				GuestAccessRestriction = FALSE;
			}
		}

		RegCloseKey(hkResult);
	}

	DWORD Type = 0;

    if (m_EvtLogName.CompareNoCase(SYSTEM_LOG) == 0)
    {
        Type = 1;
    }
    else if (m_EvtLogName.CompareNoCase(SECURITY_LOG) == 0)
    {
        Type = 2;
    }

    switch (Type)
    {
        case 2:
		{
            pAceData = AceData + 2;         // Deny ACEs *not* applicable
            NumberOfAcesToUse = 3;
		}
        break;

        case 1:
		{
            if (GuestAccessRestriction)
            {
                pAceData = AceData;         // Deny ACEs *applicable*
                NumberOfAcesToUse = 10;
            }
            else
            {
                pAceData = AceData + 2;     // Deny ACEs *not* applicable
                NumberOfAcesToUse = 8;
            }
		}
        break;

        case 0:
		default:
		{
            if (GuestAccessRestriction)
            {
                pAceData = AceData;         // Deny ACEs *applicable*
                NumberOfAcesToUse = 12;
            }
            else
            {
                pAceData = AceData + 2;     // Deny ACEs *not* applicable
                NumberOfAcesToUse = 10;
            }
		}
        break;
    }
	
	PSECURITY_DESCRIPTOR psdSelfRel = NULL;
	NTSTATUS Status = RtlCreateUserSecurityObject(
					   pAceData,
					   NumberOfAcesToUse,
					   CNTEventProvider::s_LocalSystemSid,	// Owner
					   CNTEventProvider::s_LocalSystemSid,	// Group
					   TRUE,								// IsDirectoryObject
					   &LogFileObjectMapping,
					   &psdSelfRel);

	if (NT_SUCCESS(Status) && psdSelfRel)	
	{
		try
		{
			DWORD sdlen = GetSecurityDescriptorLength(psdSelfRel);

			if (sdlen > 0)
			{
				SAFEARRAYBOUND rgsabound[1];
				SAFEARRAY* psa = NULL;
				UCHAR* pdata = NULL;
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = sdlen;
				psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

				if (NULL != psa)
				{
					try
					{
						if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pdata)))
						{
							memcpy((void *)pdata, (void *)psdSelfRel, sdlen);
							SafeArrayUnaccessData(psa);
							m_VpsdSelfRel.vt = VT_ARRAY|VT_UI1;
							m_VpsdSelfRel.parray = psa;
							retVal = TRUE;
						}
						else
						{
							SafeArrayDestroy(psa);
							psa = NULL;
						}
					}
					catch(...)
					{
						SafeArrayDestroy(psa);
						psa = NULL;
						throw;
					}
				}
			}
		}
		catch(...)
		{
			RtlDeleteSecurityObject(&psdSelfRel);
			psdSelfRel = NULL;
		}

		RtlDeleteSecurityObject(&psdSelfRel);
		psdSelfRel = NULL;
	}

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtcfac.cpp ===
//***************************************************************************

//

//  NTEVTCFAC.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


LONG CNTEventProviderClassFactory :: objectsInProgress = 0 ;
LONG CNTEventProviderClassFactory :: locksInProgress = 0 ;
BOOL CEventLogFile :: ms_bSetPrivilege = FALSE ;
extern CEventProviderManager* g_pMgr;
extern CCriticalSection g_ProvLock;


//***************************************************************************
//
// CNTEventProviderClassFactory::CNTEventProviderClassFactory
// CNTEventProviderClassFactory::~CNTEventProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CNTEventProviderClassFactory::CNTEventProviderClassFactory ()
{
    m_referenceCount = 0 ;
}

CNTEventProviderClassFactory::~CNTEventProviderClassFactory ()
{
}

//***************************************************************************
//
// CNTEventProviderClassFactory::QueryInterface
// CNTEventProviderClassFactory::AddRef
// CNTEventProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CNTEventProviderClassFactory::QueryInterface (

    REFIID iid , 
    LPVOID FAR *iplpv 
) 
{
    *iplpv = NULL ;

    if ( iid == IID_IUnknown )
    {
        *iplpv = ( LPVOID ) this ;
    }
    else if ( iid == IID_IClassFactory )
    {
        *iplpv = ( LPVOID ) this ;      
    }   

    if ( *iplpv )
    {
        ( ( LPUNKNOWN ) *iplpv )->AddRef () ;

        return ResultFromScode ( S_OK ) ;
    }
    else
    {
        return ResultFromScode ( E_NOINTERFACE ) ;
    }
}


STDMETHODIMP_( ULONG ) CNTEventProviderClassFactory :: AddRef ()
{
    InterlockedIncrement(&objectsInProgress);
    return InterlockedIncrement ( &m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CNTEventProviderClassFactory :: Release ()
{   
    LONG ref ;

    if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
    {
        delete this ;
    }

    InterlockedDecrement(&objectsInProgress);
    return ref ;
}

//***************************************************************************
//
// CNTEventProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CNTEventProviderClassFactory :: LockServer ( BOOL fLock )
{
    if ( fLock )
    {
        InterlockedIncrement ( & locksInProgress ) ;
    }
    else
    {
        InterlockedDecrement ( & locksInProgress ) ;
    }

    return S_OK ;
}

//***************************************************************************
//
// CNTEventlogEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CNTEventlogEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
                                                                REFIID riid,
                                                                LPVOID FAR * ppvObject
)
{
    HRESULT status = E_FAIL;

    if ( pUnkOuter )
    {
        status = CLASS_E_NOAGGREGATION;
    }
    else 
    {
		BOOL bAllocateMgr = FALSE;
		BOOL bLocked = FALSE;

		try
		{
			if (g_ProvLock.Lock())
			{
				bLocked = TRUE;

				if (NULL == CNTEventProvider::g_secMutex)
				{
					//only need the security mutex if not NT5
					DWORD dwVersion = GetVersion();

					if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
					{
						CNTEventProvider::g_secMutex = new CMutex(FALSE, SECURITY_MUTEX_NAME, NULL);
					}

				}

				if (!CEventLogFile::ms_bSetPrivilege)
				{
					if (!CEventLogFile::SetSecurityLogPrivilege(TRUE))
					{
DebugOut( 
		CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
			L"CNTEventlogEventProviderClassFactory :: CreateInstance, CEventLogFile::SetSecurityLogPrivilege failed \r\n");
)
					}
					else
					{
						CEventLogFile::ms_bSetPrivilege = TRUE;
					}
				}

				if (NULL == g_pMgr)
				{
					bAllocateMgr = TRUE;

					g_pMgr = new CEventProviderManager;
					CNTEventProvider::AllocateGlobalSIDs();
				}

				CNTEventProvider* prov =  new CNTEventProvider(g_pMgr);
				status = prov->QueryInterface (riid, ppvObject);

				if (NOERROR != status)
				{
					delete prov;
				}

				g_ProvLock.Unlock();
				bLocked = FALSE;
			}
		}
		catch ( ... )
		{
			if ( bLocked )
			{
				if ( bAllocateMgr )
				{
					if ( g_pMgr )
					{
						delete g_pMgr;
						g_pMgr = NULL;
					}
				}

				g_ProvLock.Unlock();
				bLocked = FALSE;
			}

			if ( SUCCEEDED ( status ) )
			{
				status = E_UNEXPECTED;
			}
		}
    }

    return status ;
}


//***************************************************************************
//
// CNTEventlogInstanceProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CNTEventlogInstanceProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
                                                                REFIID riid,
                                                                LPVOID FAR * ppvObject
)
{
    HRESULT status = E_FAIL;

    if ( pUnkOuter )
    {
        status = CLASS_E_NOAGGREGATION;
    }
    else 
    {

		BOOL bLocked = FALSE;

		try
		{
			if (g_ProvLock.Lock())
			{
				bLocked = TRUE;

				if (NULL == CNTEventProvider::g_secMutex)
				{

					//only need the security mutex if not NT5
					DWORD dwVersion = GetVersion();

					if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
					{
						CNTEventProvider::g_secMutex = new CMutex(FALSE, SECURITY_MUTEX_NAME, NULL);
					}
				}

				IWbemServices *lpunk = ( IWbemServices * ) new CImpNTEvtProv ;
				if ( lpunk == NULL )
				{
					status = E_OUTOFMEMORY ;
				}
				else
				{
					status = lpunk->QueryInterface ( riid , ppvObject ) ;
					if ( FAILED ( status ) )
					{
						delete lpunk ;
					}
					else
					{
					}
				}

				g_ProvLock.Unlock();
				bLocked = FALSE;
			}
		}
		catch ( ... )
		{
			if ( bLocked )
			{
				g_ProvLock.Unlock();
				bLocked = FALSE;
			}

			if ( SUCCEEDED ( status ) )
			{
				status = E_UNEXPECTED;
			}
		}
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtlogr.cpp ===
//***************************************************************************
//
//  NTEVTLOGR.CPP
//
//  Module: WBEM NT EVENT PROVIDER
//
//  Purpose: Contains the Eventlog record classes
//
// Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include <time.h>
#include <wbemtime.h>
#include <Ntdsapi.h>
#include <Sddl.h>

#include <autoptr.h>
#include <scopeguard.h>

#define MAX_INSERT_OPS                  100

CEventlogRecord::CEventlogRecord(const wchar_t* logfile, const EVENTLOGRECORD* pEvt, IWbemServices* ns,
								 IWbemClassObject* pClass, IWbemClassObject* pAClass)
 :  m_nspace(NULL), m_pClass(NULL), m_pAClass(NULL)
{
    m_EvtType = 0;
	m_Data = NULL;
    m_Obj = NULL;
    m_NumStrs = 0;
    m_DataLen = 0;
    m_nspace = ns;

    if (m_nspace != NULL)
    {
        m_nspace->AddRef();
    }
	else
	{
		m_pClass = pClass;

		if (m_pClass != NULL)
		{
			m_pClass->AddRef();
		}

		m_pAClass = pAClass;

		if (m_pAClass != NULL)
		{
			m_pAClass->AddRef();
		}
	}
    if ((NULL == logfile) || ((m_pClass == NULL) && (m_nspace == NULL)))
    {
        m_Valid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::CEventlogRecord:Created INVALID Record\r\n"
        ) ;
)
    }
    else
    {
        m_Logfile = logfile;
        m_Valid = Init(pEvt);
    }


}

CEventlogRecord::~CEventlogRecord()
{
    if (m_pClass != NULL)
    {
        m_pClass->Release();
    }

    if (m_pAClass != NULL)
    {
        m_pAClass->Release();
    }
    
    if (m_nspace != NULL)
    {
        m_nspace->Release();
    }

    for (LONG x = 0; x < m_NumStrs; x++)
    {
        delete [] m_InsStrs[x];
    }

    if (m_Data != NULL)
    {
        delete [] m_Data;
    }

    if (m_Obj != NULL)
    {
        m_Obj->Release();
    }
}

BOOL CEventlogRecord::Init(const EVENTLOGRECORD* pEvt)
{
    if (NULL == pEvt)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::Init:No DATA return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    if (!GetInstance())
    {
        return FALSE;
    }

    m_Record = pEvt->RecordNumber;
    m_EvtID = pEvt->EventID;
    m_SourceName = (const wchar_t*)((UCHAR*)pEvt + sizeof(EVENTLOGRECORD));
    m_CompName = (const wchar_t*)((UCHAR*)pEvt + sizeof(EVENTLOGRECORD)) + wcslen(m_SourceName) + 1;
    SetType(pEvt->EventType);
    m_Category = pEvt->EventCategory;
    SetTimeStr(m_TimeGen, pEvt->TimeGenerated);
    SetTimeStr(m_TimeWritten, pEvt->TimeWritten);

    if (pEvt->UserSidLength > 0)
    {
		PSID pSid = NULL;
		pSid = (PSID)((UCHAR*)pEvt + pEvt->UserSidOffset);

		if ( pSid && IsValidSid ( pSid ) )
		{
			SetUser( pSid );
		}
    }
    
    if (pEvt->NumStrings)
    {
        //Must have an element for every expected insertion string
        //don't know how many that is so create max size array and
        //intitialize all to NULL
        memset(m_InsStrs, 0, MAX_NUM_OF_INS_STRS * sizeof(wchar_t*));

        const wchar_t* pstr = (const wchar_t*)((UCHAR*)pEvt + pEvt->StringOffset);

        for (WORD x = 0; x < pEvt->NumStrings; x++)
        {
            LONG len = wcslen(pstr) + 1;
            m_InsStrs[x] = new wchar_t[len];
            m_NumStrs++;
            StringCchCopyW ( m_InsStrs[x], len, pstr );
            pstr += len;
        }
    }

    SetMessage();

    if (pEvt->DataLength)
    {
        m_Data = new UCHAR[pEvt->DataLength];
        m_DataLen = pEvt->DataLength;
        memcpy((void*)m_Data, (void*)((UCHAR*)pEvt + pEvt->DataOffset), pEvt->DataLength);
    }

    return TRUE;
}


BOOL CEventlogRecord::GenerateInstance(IWbemClassObject** ppInst)
{
    if (ppInst == NULL)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Invalid parameter\r\n"
        ) ;
)
        return FALSE;
    }

    *ppInst = NULL;

    if (!m_Valid)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Invalid record\r\n"
        ) ;
)
        return FALSE;
    }

    if (!SetProperty(LOGFILE_PROP, m_Logfile))
    {
        m_Valid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Failed to set key\r\n"
        ) ;
)
        return FALSE;
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Log: %s\r\n", m_Logfile
        ) ;
)
    }

    if (!SetProperty(RECORD_PROP, m_Record))
    {
        m_Valid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Failed to set key\r\n"
        ) ;
)
        return FALSE;
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Record: %d\r\n", m_Record
        ) ;
)
    }

    SetProperty(TYPE_PROP, m_Type);
    SetProperty(EVTTYPE_PROP, (DWORD)m_EvtType);

    if (!m_SourceName.IsEmpty())
    {
        SetProperty(SOURCE_PROP, m_SourceName);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Source: %s\r\n", m_SourceName
        ) ;
)
    }

    SetProperty(EVTID_PROP, m_EvtID);
    SetProperty(EVTID2_PROP, (m_EvtID & 0xFFFF));

    if (!m_TimeGen.IsEmpty())
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:TimeGenerated: %s\r\n", m_TimeGen
        ) ;
)
        SetProperty(GENERATED_PROP, m_TimeGen);
    }

    if (!m_TimeWritten.IsEmpty())
    {
        SetProperty(WRITTEN_PROP, m_TimeWritten);
    }

    if (!m_CompName.IsEmpty())
    {
        SetProperty(COMPUTER_PROP, m_CompName);
    }

    if (!m_User.IsEmpty())
    {
        SetProperty(USER_PROP, m_User);
    }

    if (!m_Message.IsEmpty())
    {
        SetProperty(MESSAGE_PROP, m_Message);
    }

    if (!m_CategoryString.IsEmpty())
    {
        SetProperty(CATSTR_PROP, m_CategoryString);
    }

    SetProperty(CATEGORY_PROP, (DWORD)m_Category);

    VARIANT v;

    if (m_Data != NULL)
    {
        SAFEARRAYBOUND rgsabound[1];
        SAFEARRAY* psa = NULL;
        UCHAR* pdata = NULL;
        rgsabound[0].lLbound = 0;
        VariantInit(&v);
        rgsabound[0].cElements = m_DataLen;
        psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
        if (NULL != psa)
        {
            v.vt = VT_ARRAY|VT_UI1;
            v.parray = psa;

            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pdata)))
            {
                memcpy((void *)pdata, (void *)m_Data, m_DataLen);
                SafeArrayUnaccessData(psa);
                m_Obj->Put(DATA_PROP, 0, &v, 0);
            }
	    else
	    {
		VariantClear (&v) ;
		return FALSE ;
	    }
        }
	else
	{
		VariantClear(&v);
		return FALSE ;
	}

        VariantClear(&v);
    }

    if (0 != m_NumStrs)
    {
        SAFEARRAYBOUND rgsabound[1];
        SAFEARRAY* psa = NULL;
        BSTR* pBstr = NULL;
        rgsabound[0].lLbound = 0;
        VariantInit(&v);
        rgsabound[0].cElements = m_NumStrs;

        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
        if (NULL != psa)
        {
            v.vt = VT_ARRAY|VT_BSTR;
            v.parray = psa;

            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
            {
                for (LONG x = 0; x < m_NumStrs; x++)
                {
                    pBstr[x] = SysAllocString(m_InsStrs[x]);
					if ( NULL == pBstr[x] )
					{
						SafeArrayUnaccessData(psa);
						VariantClear (&v) ;
						return FALSE ;
					}
                }

                SafeArrayUnaccessData(psa);
                m_Obj->Put(INSSTRS_PROP, 0, &v, 0);
            }
			else
			{
				VariantClear (&v) ;
				return FALSE ;
			}
        }
		else
		{
			VariantClear(&v);
			return FALSE ;
		}

        VariantClear(&v);
    }

    *ppInst = m_Obj;
    m_Obj->AddRef();
    return TRUE;
}

BOOL CEventlogRecord::SetProperty(wchar_t* prop, CStringW val)
{
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = val.AllocSysString();

    HRESULT hr = m_Obj->Put(prop, 0, &v, 0);
    VariantClear(&v);

    if (FAILED(hr))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetProperty:Failed to set %s with %s\r\n",
        prop, val
        ) ;
)

        return FALSE;
    }
    
    return TRUE;
}

BOOL CEventlogRecord::SetProperty(wchar_t* prop, DWORD val)
{
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_I4;
    v.lVal = val;

    HRESULT hr = m_Obj->Put(prop, 0, &v, 0);
    VariantClear(&v);

    if (FAILED(hr))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetProperty:Failed to set %s with %lx\r\n",
        prop, val
        ) ;
)
        return FALSE;
    }
    
    return TRUE;
}

void CEventlogRecord::SetUser(PSID psidUserSid)
{
    m_User = GetUser(psidUserSid);
}

ULONG CEventlogRecord::CheckInsertionStrings(HKEY hk, HKEY hkPrimary)
{
    //
    // If the message doesn't have any percent signs, it can't have any
    // insertions.
    //

    if (!m_Message.IsEmpty() && !wcschr(m_Message, L'%'))
    {
        return 0;
    }

    HINSTANCE hParamModule = NULL;

    CStringW paramModule = CEventLogFile::GetFileName(hk, PARAM_MODULE);
	if (paramModule.IsEmpty())
	{
		if ( hkPrimary )
		{
			paramModule = CEventLogFile::GetFileName(hkPrimary, PARAM_MODULE);
		}
	}

	if (!paramModule.IsEmpty())
	{
        hParamModule = GetDll(paramModule);
    }

    ULONG size = 0;

	LPWSTR Message = NULL;
	Message = new WCHAR [ ( m_Message.GetLength() + 1 ) ];

	StringCchCopy ( Message, m_Message.GetLength() + 1, m_Message );
    wchar_t* lpszString = Message;		// set initial pointer

	UINT nInsertions = 0;				// limit number of recursions

	while ( lpszString && *lpszString )
	{
		wchar_t* lpStartDigit = wcschr(lpszString, L'%');

        //
        // If there are no more insertion markers in the source string,
        // we're done.
        //

		if (lpStartDigit == NULL)
		{
			break;
		}

		//
		// get the offset of %string from the beggining of buffer for future replacement
		//

		UINT nOffset = (DWORD) ( lpStartDigit - Message );
		UINT nStrSize = wcslen ( lpStartDigit );

        //
        // Found a possible insertion marker.  If it's followed by a
        // number, it's an insert string.  If it's followed by another
        // percent, it could be a parameter insert.
        //

		if ( nStrSize > 1 && lpStartDigit[1] >= L'0' && lpStartDigit[1] <= L'9' )
		{
            // Object with percent-sign in name messes up object access audit
            // This might fail because an inserted string itself contained
            // text which looks like an insertion parameter, such as "%20".
            // Ignore the return value and continue with further replacements.

            (void) ReplaceStringInsert	(
											&Message,
											nOffset,
											&lpStartDigit,
											&size
										);

			// set pointer to the beginning of replacement
			lpszString = lpStartDigit;

            //
            // If we've reached the limit of insertion operations, quit.
            // This shouldn't normally happen and could indicate that
            // the insert strings or parameter strings are self referencing
            // and would create an infinite loop.
            //

            if (++nInsertions >= MAX_INSERT_OPS)
            {
                break;
            }
		}
		else if ( nStrSize > 2 && lpStartDigit[1] == '%' )
		{
			//
            // Found %%.  If that is followed by a digit, it's a parameter string.
            //

            if (lpStartDigit[2] >= L'0' && lpStartDigit[2] <= L'9')
            {
                if ( SUCCEEDED ( ReplaceParameterInsert	(
															hParamModule,
															paramModule,
															&Message,
															nOffset,
															&lpStartDigit,
															&size
														)
							   )
				   )
				{
					// set pointer to the beginning of replacement
					lpszString = lpStartDigit;

					//
					// If we've reached the limit of insertion operations, quit.
					// This shouldn't normally happen and could indicate that
					// the insert strings or parameter strings are self referencing
					// and would create an infinite loop.
					//

					if (++nInsertions >= MAX_INSERT_OPS)
					{
						break;
					}
				}
				else
				{
					//
					// unable to replace (error). Just keep moving.
					//

					lpszString++;
				}
			}
			else if ( nStrSize > 3 && lpStartDigit[2] == '%' )
			{
				//
				// Found %%%.  If that is followed by a digit, it's a insertion string.
				//

				if (lpStartDigit[3] >= L'0' && lpStartDigit[3] <= L'9')
				{
					//
					// Got %%%n, where n is a number.  For compatibility with
					// old event viewer, must replace this with %%x, where x
					// is insertion string n.  If insertion string n is itself
					// a number m, this becomes %%m, which is treated as parameter
					// message number m.
					//

					lpStartDigit += 2; // point at %n

					//
					// nOffset shows offset from the beginning of the buffer where
					// replacement is going to happen to first % character lpStartDigit
					//
					// as we are chaging %%%n to be be %%x where x = %n, implementation
					// needs to move offset to point to the x here to get correct replacement
					// 

					if ( SUCCEEDED ( ReplaceStringInsert	(
																&Message,
																nOffset+2,
																&lpStartDigit,
																&size
															)
								   )
					   )
					{
						//
						// set pointer to the beginning of %%x (x=%n)
						//
						// this operation is done by substract as lpStartDigit pointer could
						// possibly change when original buffer gets reallocated
						//

						lpszString = lpStartDigit-2;

						//
						// If we've reached the limit of insertion operations, quit.
						// This shouldn't normally happen and could indicate that
						// the insert strings or parameter strings are self referencing
						// and would create an infinite loop.
						//

						if (++nInsertions >= MAX_INSERT_OPS)
						{
							break;
						}
					}
					else
					{
						//
						// unable to replace (error). Just keep moving.
						//

						lpszString++;
					}
				}
				else
				{
					//
					// Got %%%x, where x is non-digit. skip first percent;
					// maybe x is % and is followed by digit.
					//

					lpszString++;
				}
			}
            else
            {
                //
                // Got %%x, where x is non-digit. skip first percent;
                // maybe x is % and is followed by digit.
                //

                lpszString++;
            }
		}
		else if (nStrSize >= 3 && (lpStartDigit[1] == L'{') && (lpStartDigit[2] != L'S'))
		{
            // Parameters of form %{guid}, where {guid} is a string of
            // hex digits in the form returned by ::StringFromGUID2 (e.g.
            // {c200e360-38c5-11ce-ae62-08002b2b79ef}), and represents a
            // unique object in the Active Directory.
            //
            // These parameters are only found in the security event logs
            // of NT5 domain controllers.  We will attempt to map the guid
            // to the human-legible name of the DS object.  Failing to find
            // a mapping, we will leave the parameter untouched.

            // look for closing }
			wchar_t *strEnd = wcschr(lpStartDigit + 2, L'}');
			if (!strEnd)
			{
				//ignore this %{?
				lpszString++;
			}
			else
			{
				//guid string braces but no percent sign...
				CStringW strGUID((LPWSTR)(lpStartDigit+1), (int)(strEnd - lpStartDigit));
				strEnd++;   // now points past '}'

				wchar_t t_csbuf[MAX_COMPUTERNAME_LENGTH + 1];
				DWORD t_csbuflen = MAX_COMPUTERNAME_LENGTH + 1;

				if (GetComputerName(t_csbuf, &t_csbuflen))
				{
					CStringW temp = GetMappedGUID(t_csbuf, strGUID);
					if (temp.GetLength())
					{
						DWORD nParmSize = strEnd - lpStartDigit;
						if ( SUCCEEDED ( ReplaceSubStr	(
															temp,
															&Message,
															nOffset,
															nParmSize,
															&lpStartDigit,
															&size
														)
									   )
						   )
						{
							// set pointer to the beginning of replacement
							lpszString = lpStartDigit;

							//
							// If we've reached the limit of insertion operations, quit.
							// This shouldn't normally happen and could indicate that
							// the insert strings or parameter strings are self referencing
							// and would create an infinite loop.
							//

							if (++nInsertions >= MAX_INSERT_OPS)
							{
								break;
							}
						}
						else
						{
							//
							// unable to replace (error). Just keep moving.
							//

							lpszString = strEnd;
						}
					}
					else
					{
						// couldn't get a replacement, so skip it.
						lpszString = strEnd;
					}
				}
				else
				{
					// couldn't get a replacement, so skip it.
					lpszString = strEnd;
				}
			}
		}
		else if (nStrSize >= 3 && (lpStartDigit[1] == L'{') && (lpStartDigit[2] == L'S'))
		{
            //
            // Parameters of form %{S}, where S is a string-ized SID returned
            // by ConvertSidToStringSid, are converted to an object name if
            // possible.
            //

            // look for closing }
			wchar_t *strEnd = wcschr(lpStartDigit + 2, L'}');
			if (!strEnd)
			{
				//ignore this %{?
				lpszString++;
			}
			else
			{
				//sid string no braces or percent sign...
				CStringW strSID((LPWSTR)(lpStartDigit+2), (int)(strEnd - lpStartDigit - 2));
				strEnd++;   // now points past '}'
				PSID t_pSid = NULL;

				if (ConvertStringSidToSid((LPCWSTR) strSID, &t_pSid))
				{
					CStringW temp = GetUser(t_pSid);
					LocalFree(t_pSid);

					if (temp.GetLength())
					{
						DWORD nParmSize = strEnd - lpStartDigit;
						if ( SUCCEEDED ( ReplaceSubStr	(
															temp,
															&Message,
															nOffset,
															nParmSize,
															&lpStartDigit,
															&size
														)
									   )
						   )
						{
							// set pointer to the beginning of replacement
							lpszString = lpStartDigit;

							//
							// If we've reached the limit of insertion operations, quit.
							// This shouldn't normally happen and could indicate that
							// the insert strings or parameter strings are self referencing
							// and would create an infinite loop.
							//

							if (++nInsertions >= MAX_INSERT_OPS)
							{
								break;
							}
						}
						else
						{
							//
							// unable to replace (error). Just keep moving.
							//

							lpszString = strEnd;
						}
					}
					else
					{
						// couldn't get a replacement, so skip it.
						lpszString = strEnd;
					}
				}
				else
				{
					// couldn't get a replacement, so skip it.
					lpszString = strEnd;
				}
			}
		}
		else
		{
            //
            // Found %x where x is neither a % nor a digit.  Just keep moving.
            //

			lpszString++;
		}
	}

	m_Message.Empty();
	m_Message = Message;

	delete [] Message;
	Message = NULL;

    return size;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReplaceStringInsert
//
//  Synopsis:   Replace the string insert (%n, where n is a number) at
//              [Message + nOffset] with insert string number n from the
//              event log record [lpParmBuffer].
//
//  Modifies:   lpStartDigit to point to replacement
//
//---------------------------------------------------------------------------

HRESULT	CEventlogRecord::ReplaceStringInsert	(
													LPWSTR* ppwszBuf,
													ULONG	nOffset,
													LPWSTR*	ppwszReplacement,
													ULONG*	pulSize
												)
{
    HRESULT hr = E_INVALIDARG;

	*ppwszReplacement += 1;					// point to start of potential digit
	if (**ppwszReplacement != 0)			// check to see there is 
	{
		LPWSTR  pwszEnd = NULL;
		ULONG   idxInsertStr = wcstoul(*ppwszReplacement, &pwszEnd, 10);
		if ( idxInsertStr && idxInsertStr <= m_NumStrs )
		{
			DWORD nParmSize = pwszEnd - *ppwszReplacement + 1;
			hr = ReplaceSubStr	(
									m_InsStrs [ idxInsertStr-1 ],
									ppwszBuf,
									nOffset,
									nParmSize,
									ppwszReplacement,
									pulSize
								);
		}

		//
		// else
		// {
		//		we fail as we didn't recognize replacement
		//		and/or insertion string
		//
		//		see comment in CheckInsertionString
		// }
	}

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReplaceParameterInsert
//
//  Synopsis:   Replace the parameter insert (double percent sign number) at
//              [ppwszReplacement] with a string loaded from a parameter message
//              file module.
//
//---------------------------------------------------------------------------

HRESULT	CEventlogRecord::ReplaceParameterInsert	(
													HINSTANCE&	hParamModule,
													CStringW&	paramModule,
													LPWSTR* ppwszBuf,
													ULONG	nOffset,
													LPWSTR*	ppwszReplacement,
													ULONG*	pulSize
												)
{
	DWORD nChars = 0;
	wchar_t* lpParmBuffer = NULL;
	ULONG nParmSize = 0;

	ULONG  flFmtMsgFlags = 
							   FORMAT_MESSAGE_IGNORE_INSERTS    |
							   FORMAT_MESSAGE_ALLOCATE_BUFFER   |
							   FORMAT_MESSAGE_MAX_WIDTH_MASK;

    LPWSTR pwszEnd = NULL;
    ULONG idxParameterStr = wcstoul(*ppwszReplacement + 2, &pwszEnd, 10);

	HRESULT hr = E_FAIL;

    // Allow "%%0"
	if ( idxParameterStr || (L'0' == *(*ppwszReplacement + 2)))
	{
		if (hParamModule != NULL)
		{
			nChars = FormatMessage	(
										flFmtMsgFlags |
										FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
										(LPVOID) hParamModule,              // use parameter file
										idxParameterStr,                    // parameter number to get
										(ULONG) NULL,                       // specify no language
										(LPWSTR) &lpParmBuffer,             // address for buffer pointer
										256,								// minimum space to allocate
										NULL								// no inserted strings
									);                              
		}

		if (nChars == 0)
		{
			if (hParamModule != NULL)
			{
				LocalFree(lpParmBuffer);
				lpParmBuffer = NULL;
			}

			//
			// It is common practice to write events with an insertion string whose
			// value is %%n, where n is a win32 error code, and to specify a
			// parameter message file of kernel32.dll.  Unfortunately, kernel32.dll
			// doesn't contain messages for all win32 error codes.
			//
			// So if the parameter wasn't found, and the parameter message file was
			// kernel32.dll, attempt a format message from system.
			//

			paramModule.MakeLower();
			if ( wcsstr( paramModule, L"kernel32.dll") )
			{
				nChars = FormatMessage	(
											flFmtMsgFlags |
											FORMAT_MESSAGE_FROM_SYSTEM,		  // look thru system
											NULL,							  // no module
											idxParameterStr,                  // parameter number to get
											(ULONG) NULL,                     // specify no language
											(LPWSTR) &lpParmBuffer,           // address for buffer pointer
											256,			                  // minimum space to allocate
											NULL                              // no inserted strings
										);

				if (nChars == 0)
				{
					LocalFree(lpParmBuffer);
					lpParmBuffer = NULL;
				}
			}
		}

		if ( lpParmBuffer )
		{
			try
			{
				DWORD nParmSize = pwszEnd - *ppwszReplacement;
				hr = ReplaceSubStr	(
										lpParmBuffer,
										ppwszBuf,
										nOffset,
										nParmSize,
										ppwszReplacement,
										pulSize
									);
			}
			catch ( ... )
			{
				if ( lpParmBuffer )
				{
					LocalFree(lpParmBuffer);
					lpParmBuffer = NULL;
				}

				throw;
			}

			LocalFree(lpParmBuffer);
			lpParmBuffer = NULL;
		}
		else
		{
			hr = E_INVALIDARG;

			// move past whole parameter
			*ppwszReplacement = pwszEnd;
		}
	}

	return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReplaceSubStr
//
//  Synopsis:   Replace the characters from *[ppwszInsertPoint] to just
//              before [pwszSubStrEnd] with the string [pwszToInsert].
//
//  Arguments:  [pwszToInsert]	- string to insert; may be L"" but not NULL.
//              [ppwszBuf]		- buffer in which insertion occurs
//              [ulOffset]		- point in *[ppwszBuf] to insert
//              [ulCharsOld]	- number of chars to replace
//				[pulSize]		- number of chars replaced
//
//  Returns:    S_OK
//				E_INVALIDARG
//
//  Modifies:   [ppwszBuf], [pptrReplacement]
//
//  Notes:      The substring to be replaced must be > 0 chars in length.
//
//              The replacement string can be >= 0 chars.
//
//              Therefore if the substring to replace is "%%12" and the
//              string to insert is "C:", on exit *[pcchRemain] will have
//              been incremented by 2.
//
//              If there are insufficient characters remaining to replace
//              the substring with the insert string, reallocates the
//              buffer.
//
//---------------------------------------------------------------------------

HRESULT	CEventlogRecord::ReplaceSubStr	(
											LPCWSTR pwszToInsert,
											LPWSTR *ppwszBuf,
											ULONG  nOffset,
											ULONG  nCharsOld,
											LPWSTR *pptrReplacement,
											ULONG  *pulSize
										)
{
	HRESULT hr = E_INVALIDARG;

	try
	{
		if ( pwszToInsert )
		{
			ULONG nChars = wcslen(pwszToInsert);

			UINT nStrSize = wcslen(*ppwszBuf)+1;		// calculate original length
			UINT nNewSize = nStrSize+nChars-nCharsOld;	// calculate new length

			wchar_t* tmp = *ppwszBuf;

			//
			// do we need to reallocate?
			//

			if (nNewSize > nStrSize)
			{
				tmp = new wchar_t[nNewSize];		// allocate new buffer
				if ( tmp == NULL )					// there is exception raisen in current implementation
				{
					hr = E_OUTOFMEMORY;
					*pptrReplacement -= 1;			// get back to % as memory could get back
				}
				else
				{
					StringCchCopyW ( tmp, nNewSize, *ppwszBuf );
					delete [] *ppwszBuf;
					*ppwszBuf = tmp;

					hr = S_FALSE;
				}
			}
			else
			{
				hr = S_FALSE;
			}

			if ( SUCCEEDED ( hr ) )
			{
				*pptrReplacement = *ppwszBuf + nOffset;				// point to start of current % (we are replacing)
				nStrSize = wcslen(*pptrReplacement)-nCharsOld+1;	// calculate length of remainder of string

				//
				// perform move
				//
				memmove((void *)(*pptrReplacement+nChars),			// destination address
					(void *)(*pptrReplacement+nCharsOld),			// source address
					nStrSize*sizeof(wchar_t));						// amount of data to move

				memmove((void *)*pptrReplacement,				// destination address
					(void *)pwszToInsert,						// source address
					nChars*sizeof(wchar_t));					// amount of data to move

				*pulSize += ( nChars + 1 );

				hr = S_OK;
			}
		}
	}
	catch ( ... )
	{
		if (*ppwszBuf)
		{
			delete [] *ppwszBuf;
			*ppwszBuf = NULL;
		}

		throw;
	}

	return hr;
}

CStringW CEventlogRecord::GetUser(PSID userSid)
{
    CStringW retVal;
    BOOL bFound = FALSE;

    MyPSID usrSID(userSid);

    {
        ScopeLock<CSIDMap> sl(sm_usersMap);
        if (!sm_usersMap.IsEmpty() && sm_usersMap.Lookup(usrSID, retVal))
        {
            bFound = TRUE;
        }
    }

    if (!bFound)
    {
        DWORD dwVersion = GetVersion();

        if ( (4 < (DWORD)(LOBYTE(LOWORD(dwVersion))))
            || ObtainedSerialAccess(CNTEventProvider::g_secMutex) )
        {

        wchar_t szDomBuff[MAX_PATH];
        wchar_t szUsrBuff[MAX_PATH];
        DWORD domBuffLen = MAX_PATH;
        DWORD usrBuffLen = MAX_PATH;
        SID_NAME_USE snu;

        if (LookupAccountSid(           // lookup account name
                        NULL,           // system to lookup account on
                        userSid,        // pointer to SID for this account
                        szUsrBuff,      // return account name in this buffer
                        &usrBuffLen,    // pointer to size of account name returned
                        szDomBuff,      // domain where account was found
                        &domBuffLen,    //pointer to size of domain name
                        &snu))          // sid name use field pointer
        {
            retVal = szDomBuff;
            retVal += L'\\';
            retVal += szUsrBuff;
        }
        else
        {
            LONG lasterr = GetLastError();
DebugOut( 
CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

_T(__FILE__),__LINE__,
L"CEventlogRecord::GetUser:API (LookupAccountSid) failed with %lx\r\n",
lasterr
) ;
)       
        }

            if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
            {
                ReleaseSerialAccess(CNTEventProvider::g_secMutex);
            }
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetUser:Failed to get serial access to security APIs\r\n"
        ) ;
)       
        }



        //regardless of error enter this into map so we
        //don't look up this PSID again
        {
            ScopeLock<CSIDMap> sl(sm_usersMap);
            CStringW LookretVal;

            if (!sm_usersMap.IsEmpty() && sm_usersMap.Lookup(usrSID, LookretVal))
            {
                return LookretVal; 
            }
            else 
            {
                DWORD sidlen = GetLengthSid(userSid);
                MyPSID key;  
                key.m_SID = (PSID) new UCHAR[sidlen];
                CopySid(sidlen, key.m_SID, userSid);
                sm_usersMap[key] = retVal;
            }
        }
    }

    return retVal;
}

void CEventlogRecord::EmptyUsersMap()
{
    if (sm_usersMap.Lock())
    {
        sm_usersMap.RemoveAll();
        sm_usersMap.Unlock();
    }
}


HINSTANCE CEventlogRecord::GetDll(CStringW path)
{
    HINSTANCE retVal = NULL;
    CStringW key(path);
    key.MakeUpper();
    BOOL bFound = FALSE;

    {
        ScopeLock<CDllMap> sl(sm_dllMap);
        
        if (!sm_dllMap.IsEmpty() && sm_dllMap.Lookup(key, retVal))
        {
            bFound = TRUE;
        }
    }

    if (!bFound)
    {
        retVal = LoadLibraryEx(path, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE);
        
        if (retVal == NULL)
        {
DebugOut( 
DWORD lasterr = GetLastError();
CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

    _T(__FILE__),__LINE__,
    L"CEventlogRecord::GetDll:API (LoadLibraryEx) failed with %lx for %s\r\n",
    lasterr, path
    ) ;
)
        }
        else
        {
            HINSTANCE LookretVal = NULL;
            ScopeLock<CDllMap> sl(sm_dllMap);
            
            if (!sm_dllMap.IsEmpty() && sm_dllMap.Lookup(key, LookretVal))
            {
                FreeLibrary(retVal); //release the ref count as we increased it by one as above.
                return LookretVal;

            } else {

                sm_dllMap[key] = retVal;

            }
        }
    }
    return retVal;
}

void CEventlogRecord::EmptyDllMap()
{
    if (sm_dllMap.Lock())
    {
        sm_dllMap.RemoveAll();
        sm_dllMap.Unlock();
    }
}

void CEventlogRecord::SetMessage()
{
    HINSTANCE hMsgModule;
    wchar_t* lpBuffer = NULL;

    CStringW log(EVENTLOG_BASE);
    log += L"\\";
    log += m_Logfile;

    HKEY hkResult;

    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, log, 0, KEY_READ, &hkResult);
    if (status != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (RegOpenKeyEx) failed with %lx for %s\r\n",
        status, log
        ) ;
)

        return;
    }

	ON_BLOCK_EXIT ( RegCloseKey, hkResult ) ;

    DWORD dwType;
    wchar_t* prim = NULL;
	
	prim = new wchar_t[MAX_PATH];
	DWORD datalen = MAX_PATH * sizeof(wchar_t);

	status = RegQueryValueEx(hkResult, PRIM_MODULE, 0, &dwType, (LPBYTE)prim, &datalen);

	if (status != ERROR_SUCCESS)
	{
		if (status == ERROR_MORE_DATA)
		{
			delete [] prim;
			prim = new wchar_t[datalen];
			status = RegQueryValueEx(hkResult, PRIM_MODULE, 0, &dwType, (LPBYTE)prim, &datalen);
		}
	}

	HKEY hkPrimary = NULL;
	HKEY hkSource  = NULL;

	wmilib::auto_buffer < wchar_t > Smartprim ( prim ) ;
	if ( ERROR_SUCCESS == status && dwType == REG_SZ )
	{
		// this is path to primary log
		CStringW primLog = log + L"\\";
		primLog += prim;

		// open a registry for primary event log key
		if ((_wcsicmp(m_SourceName, prim)) != 0)
		{
			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, primLog, 0, KEY_READ, &hkPrimary);
		}
	}

	ON_BLOCK_EXIT ( RegCloseKey, hkPrimary ) ;

	// this is path to source log
    CStringW sourceLog = log + L"\\";
    sourceLog += m_SourceName;

	// check to see there is a registry for source
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sourceLog, 0, KEY_READ, &hkSource);
    if (status != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (RegOpenKeyEx) failed with %lx for %s\r\n",
        status, log
        ) ;
)
        return;
    }

	ON_BLOCK_EXIT ( RegCloseKey, hkSource ) ;

	// get category file
    CStringW cat_modname = CEventLogFile::GetFileName(hkSource, CAT_MODULE);
    if (cat_modname.IsEmpty())
    {
		if ( hkPrimary )
		{
			// try primary event log key as source doesn't have category
			cat_modname = CEventLogFile::GetFileName(hkPrimary, CAT_MODULE);
		}
	}

	// workout category and category string if possible
    if (!cat_modname.IsEmpty())
	{
        hMsgModule = GetDll(cat_modname);
        if (hMsgModule != NULL)
        {
            if (0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                    FORMAT_MESSAGE_IGNORE_INSERTS |     // indicate no string inserts
                    FORMAT_MESSAGE_FROM_HMODULE |        // look thru message DLL
					FORMAT_MESSAGE_MAX_WIDTH_MASK ,
                    (LPVOID) hMsgModule,                // handle to message module
                    m_Category,                         // message number to get
                    (ULONG) NULL,                       // specify no language
                    (LPWSTR) &lpBuffer,                 // address for buffer pointer
                    80,                  // minimum space to allocate
                    NULL))
            {
                m_CategoryString = lpBuffer;
				m_CategoryString.TrimRight();
                LocalFree(lpBuffer);
            }
            else
            {
                DWORD lasterr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (FormatMessage) failed with %lx\r\n",
        lasterr
        ) ;
)
            }
        }
    }

	// get event message file
    CStringW* names;
    DWORD count = CEventLogFile::GetFileNames(hkSource, &names);
	if ( !count )
	{
		if ( hkPrimary )
		{
			// try primary event log key as source doesn't have event message file
			count = CEventLogFile::GetFileNames(hkPrimary, &names);
		}
	}

	// work out event messages
    if (count != 0)
    {
        for (int x = 0; x < count; x++)
        {
            hMsgModule = GetDll(names[x]);
            if (hMsgModule != NULL)
            {
                if (0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |     // indicate an array of string inserts
						FORMAT_MESSAGE_IGNORE_INSERTS |     // indicate no string inserts
                        FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                        (LPVOID) hMsgModule,                // handle to message module
                        m_EvtID,                            // message number to get
                        (ULONG) NULL,                       // specify no language
                        (LPWSTR) &lpBuffer,                 // address for buffer pointer
                        80,                  // minimum space to allocate
                        NULL))
                {
                    m_Message = lpBuffer;
                    LocalFree(lpBuffer);
                    break;
                }
                else
                {
                    DWORD lasterr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (FormatMessage) failed with %lx\r\n",
        lasterr
        ) ;
)
                }
            }
        }

        delete [] names;
    }

    if (m_NumStrs != 0)
    {
        CheckInsertionStrings(hkSource, hkPrimary);
    }
}

void CEventlogRecord::SetTimeStr(CStringW& str, DWORD timeVal)
{
    WBEMTime tmpTime((time_t)timeVal);
    BSTR tStr = tmpTime.GetDMTF(TRUE);
    str = tStr;
    SysFreeString(tStr);
}

void CEventlogRecord::SetType(WORD type)
{
    switch (type)
    {
        case 0:
        {
            m_Type = m_TypeArray[0];
			m_EvtType = 0;
            break;
        }
        case 1:
        {
            m_Type = m_TypeArray[1];
			m_EvtType = 1;
            break;
        }
        case 2:
        {
            m_Type = m_TypeArray[2];
			m_EvtType = 2;
            break;
        }
        case 4:
        {
            m_Type = m_TypeArray[3];
            m_EvtType = 3;
			break;
        }
        case 8:
        {
            m_Type = m_TypeArray[4];
			m_EvtType = 4;
            break;
        }
        case 16:
        {
            m_Type = m_TypeArray[5];
			m_EvtType = 5;
            break;
        }
        default:
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetType:Unknown type %lx\r\n",
        (long)type
        ) ;
)
            break;
        }
    }

#if 0
    if (m_Type.IsEmpty())
    {
        wchar_t* buff = m_Type.GetBuffer(20);
        _ultow((ULONG)type, buff, 10);
        m_Type.ReleaseBuffer();
    }
#endif
}

ULONG CEventlogRecord::GetIndex(wchar_t* indexStr, BOOL* bError)
{
    int val = _wtoi(indexStr);
    *bError = FALSE;
    ULONG index = 0;

    switch (val)
    {
        case EVENTLOG_SUCCESS:			//0
        {
            index = 0;
            break;
        }
        case EVENTLOG_ERROR_TYPE:       //1
        {
            index = 1;
            break;
        }
        case EVENTLOG_WARNING_TYPE:     //2
        {
            index = 2;
            break;
        }
        case EVENTLOG_INFORMATION_TYPE: //4
        {
            index = 3;
            break;
        }
        case EVENTLOG_AUDIT_SUCCESS:    //8
        {
            index = 4;
            break;
        }
        case EVENTLOG_AUDIT_FAILURE:    //16
        {
            index = 5;
            break;
        }
        default:
        {
            *bError = TRUE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::Index:Unknown index %lx\r\n",
        val
        ) ;
)

        }
    }

    return index;
}

BOOL CEventlogRecord::SetEnumArray(IWbemClassObject* pClass, wchar_t* propname, CStringW* strArray, ULONG strArrayLen, GetIndexFunc IndexFunc)
{
    BOOL retVal = FALSE;
    IWbemQualifierSet* pQuals = NULL;

    if (SUCCEEDED(pClass->GetPropertyQualifierSet(propname, &pQuals)))
    {
        VARIANT vVals;

        if (SUCCEEDED(pQuals->Get(EVT_ENUM_QUAL, 0, &vVals, NULL)))
        {
            VARIANT vInds;

            if (SUCCEEDED(pQuals->Get(EVT_MAP_QUAL, 0, &vInds, NULL)))
            {
                if ((vInds.vt == vVals.vt) && (vInds.vt == (VT_BSTR | VT_ARRAY)) && 
                    (SafeArrayGetDim(vInds.parray) == SafeArrayGetDim(vVals.parray)) &&
                    (SafeArrayGetDim(vVals.parray) == 1) && (vInds.parray->rgsabound[0].cElements == strArrayLen) &&
                    (vInds.parray->rgsabound[0].cElements == vVals.parray->rgsabound[0].cElements) )
                {
                    BSTR *strInds = NULL;

                    if (SUCCEEDED(SafeArrayAccessData(vInds.parray, (void **)&strInds)) )
                    {
                        BSTR *strVals = NULL;

                        if (SUCCEEDED(SafeArrayAccessData(vVals.parray, (void **)&strVals)) )
                        {
                            BOOL bErr = FALSE;
                            retVal = TRUE;

                            for (ULONG x = 0; x < strArrayLen; x++)
                            {
                                ULONG index = IndexFunc(strInds[x], &bErr);

                                if (!bErr)
                                {
                                    if (strArray[index].IsEmpty())
                                    {
                                        strArray[index] = strVals[x];
                                    }
                                }
                                else
                                {
                                    retVal = FALSE;
                                    break;
                                }
                            }
                        
                            SafeArrayUnaccessData(vVals.parray);
                        }

                        SafeArrayUnaccessData(vInds.parray);
                    }
                }

                VariantClear(&vInds);
            }

            VariantClear(&vVals);
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetEnumArray:Failed to get enumeration qualifier.\r\n"
        ) ;
)

        }

        pQuals->Release();
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetEnumArray:Failed to get qualifier set for enumeration.\r\n"
        ) ;
)

    }
    
    return retVal;
}

BOOL CEventlogRecord::GetInstance()
{
    BSTR path = SysAllocString(NTEVT_CLASS);
	if ( NULL == path )
	{
		return FALSE ;
	}

    if (m_nspace != NULL)
    {
        if (!WbemTaskObject::GetClassObject(path, FALSE, m_nspace, NULL, &m_pClass ))
        {
            m_pClass = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetInstance:Failed to get Class object\r\n"
        ) ;
)

        }

        if (!WbemTaskObject::GetClassObject(path, TRUE, m_nspace, NULL, &m_pAClass ))
        {
            m_pAClass = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetInstance:Failed to get Amended Class object\r\n"
        ) ;
)

        }

        m_nspace->Release();
        m_nspace = NULL;
    }

    
    if (m_pClass != NULL)
    {
        m_pClass->SpawnInstance(0, &m_Obj);

		if (m_pAClass)
		{
			SetEnumArray(m_pAClass, TYPE_PROP,(CStringW*)m_TypeArray, TYPE_ARRAY_LEN, (GetIndexFunc)GetIndex);
	        m_pAClass->Release();
			m_pAClass = NULL;
		}

        m_pClass->Release();
        m_pClass = NULL;
    }

    SysFreeString(path);

    if (m_Obj != NULL)
    {
        return TRUE;
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetInstance:Failed to spawn instance\r\n"
        ) ;
)

    return FALSE;
}

class CDsBindingHandle
{
   public:

   // initally unbound

   CDsBindingHandle()
      :
      m_hDS(0)
   {
   }

   ~CDsBindingHandle()
   {
		if ( m_hDS )
		{
			DsUnBind(&m_hDS);
		}
   }

   // only re-binds if the dc name differs...

   DWORD Bind(LPCWSTR strDcName);

   // don't call DsUnBind on an instance of this class: you'll only regret
   // it later.  Let the dtor do the unbind.

   operator HANDLE()
   {
      return m_hDS;
   }

   DWORD CrackGuid(LPCWSTR pwzGuid, CStringW  &strResult);

   private:

   HANDLE   m_hDS;
};

DWORD CDsBindingHandle::Bind(LPCWSTR strDcName)
{
	DWORD err = NO_ERROR;

    if (m_hDS)
    {
        DsUnBind(&m_hDS);
        m_hDS = NULL;
    }

	//
	// NULL is used for connecting GC
	//
	LPCWSTR szDcName = NULL ;
	if ( NULL != *strDcName )
	{
		szDcName = strDcName ;
	}

    err = DsBind ( szDcName, 0, &m_hDS ) ;

    if (err != NO_ERROR)
    {
        m_hDS = NULL;
    }

    return err;
}

DWORD CDsBindingHandle::CrackGuid(LPCWSTR pwzGuid, CStringW  &strResult)
{
	DWORD err = ERROR;

	if( NULL == m_hDS ) return err;

    strResult.Empty();

    DS_NAME_RESULT* name_result = 0;
    err = DsCrackNames(
                      m_hDS,
                      DS_NAME_NO_FLAGS,
                      DS_UNIQUE_ID_NAME,
                      DS_FQDN_1779_NAME,
                      1,                   // only 1 name to crack
                      &pwzGuid,
                      &name_result);

    if (err == NO_ERROR && name_result)
    {
        DS_NAME_RESULT_ITEM* item = name_result->rItems;

        if (item)
        {
            // the API may return success, but each cracked name also carries
            // an error code, which we effectively check by checking the name
            // field for a value.

            if (item->pName)
            {
                strResult = item->pName;
            }
        }

        DsFreeNameResult(name_result);
    }

    return err;
}

CStringW CEventlogRecord::GetMappedGUID(LPCWSTR strDcName, LPCWSTR strGuid)
{
	GUID guid;
	CDsBindingHandle s_hDS;

    if (RPC_S_OK == UuidFromString((LPWSTR)strGuid, &guid))
    {
        return CStringW();
    }

    CStringW strResult;
    ULONG ulError = NO_ERROR;

    do
    {
        ulError = s_hDS.Bind(strDcName);

        if (ulError != NO_ERROR)
        {
            break;
        }

        DS_SCHEMA_GUID_MAP* guidmap = 0;
        ulError = DsMapSchemaGuids(s_hDS, 1, &guid, &guidmap);
        if (ulError != NO_ERROR)
        {
            break;
        }

        if (guidmap->pName)
        {
            strResult = guidmap->pName;
        }

        DsFreeSchemaGuidMap(guidmap);

        if (strResult.GetLength())
        {
            // the guid mapped as a schema guid: we're done
            break;
        }

        // the guid is not a schema guid.  Proabably an object guid.
        ulError = s_hDS.CrackGuid(strGuid, strResult);
    }
    while (0);

    do
    {
        //
        // If we've got a string from the guid already, we're done.
        //

        if (strResult.GetLength())
        {
            break;
        }

        //
        // one last try.  in this case, we bind to a GC to try to crack the
        // name.

        // empty string implies GC
        if (s_hDS.Bind(L"") != NO_ERROR)
        {
            break;
        }

        ulError = s_hDS.CrackGuid(strGuid, strResult);
    }
    while (0);

    return strResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtprov.cpp ===
//***************************************************************************

//

//  NTEVTPROV.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the WBEM interface for event provider classes

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include "ql.h"
#include "analyser.h"

BOOL ObtainedSerialAccess(CMutex* pLock)
{
    BOOL bResult = FALSE;

    if (pLock != NULL)
    {
        if (pLock->Lock())
        {
            bResult = TRUE;
        }
    }

    return bResult;
}

void ReleaseSerialAccess(CMutex* pLock)
{
    if (pLock != NULL)
    {
        pLock->Unlock();
    }
}

void CNTEventProvider::AllocateGlobalSIDs()
{
	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(
							&t_WorldAuthoritySid,
							1,
							SECURITY_WORLD_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&s_WorldSid))
	{
		s_WorldSid = NULL;
	}

	SID_IDENTIFIER_AUTHORITY t_NTAuthoritySid = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							1,
							SECURITY_ANONYMOUS_LOGON_RID,
							0, 0, 0, 0, 0, 0, 0,
							&s_AnonymousLogonSid))
	{
		s_AnonymousLogonSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							 2,
							 SECURITY_BUILTIN_DOMAIN_RID,
							 DOMAIN_ALIAS_RID_ADMINS,
							 0, 0, 0, 0, 0, 0,
							 &s_AliasAdminsSid))
	{
		s_AliasAdminsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							 &t_NTAuthoritySid,
							 1,
							 SECURITY_LOCAL_SYSTEM_RID,
							 0, 0, 0, 0, 0, 0, 0,
							 &s_LocalSystemSid
							 ))
	{
		s_LocalSystemSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_GUESTS,
							0,0,0,0,0,0,
							&s_AliasGuestsSid
							))
	{
		s_AliasGuestsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_SYSTEM_OPS,
							0,0,0,0,0,0,
							&s_AliasSystemOpsSid
							))
	{
		s_AliasSystemOpsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_BACKUP_OPS,
							0,0,0,0,0,0,
							&s_AliasBackupOpsSid
							))
	{
		s_AliasBackupOpsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							1,
							SECURITY_LOCAL_SERVICE_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&s_LocalServiceSid
							))
	{
		s_LocalServiceSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							1,
							SECURITY_NETWORK_SERVICE_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&s_NetworkServiceSid
							))
	{
		s_NetworkServiceSid = NULL;
	}
}

void CNTEventProvider::FreeGlobalSIDs()
{
	if (s_NetworkServiceSid)
	{
		FreeSid(s_NetworkServiceSid);
		s_NetworkServiceSid = NULL;
	}

	if (s_LocalServiceSid)
	{
		FreeSid(s_LocalServiceSid);
		s_LocalServiceSid = NULL;
	}

	if (s_AliasBackupOpsSid)
	{
		FreeSid(s_AliasBackupOpsSid);
		s_AliasBackupOpsSid = NULL;
	}

	if (s_AliasSystemOpsSid)
	{
		FreeSid(s_AliasSystemOpsSid);
		s_AliasSystemOpsSid = NULL;
	}

	if (s_AliasGuestsSid)
	{
		FreeSid(s_AliasGuestsSid);
		s_AliasGuestsSid = NULL;
	}

	if (s_LocalSystemSid)
	{
		FreeSid(s_LocalSystemSid);
		s_LocalSystemSid = NULL;
	}

	if (s_AliasAdminsSid)
	{
		FreeSid(s_AliasAdminsSid);
		s_AliasAdminsSid = NULL;
	}

	if (s_AnonymousLogonSid)
	{
		FreeSid(s_AnonymousLogonSid);
		s_AnonymousLogonSid = NULL;
	}

	if (s_WorldSid)
	{
		FreeSid(s_WorldSid);
		s_WorldSid = NULL;
	}
}

BOOL CNTEventProvider::GlobalSIDsOK()
{
	return (s_NetworkServiceSid 
		&& s_LocalServiceSid
		&& s_AliasBackupOpsSid
		&& s_AliasSystemOpsSid
		&& s_AliasGuestsSid
		&& s_LocalSystemSid
		&& s_AliasAdminsSid
		&& s_AnonymousLogonSid
		&& s_WorldSid);
}


STDMETHODIMP CNTEventProvider::AccessCheck (
                LPCWSTR wszQueryLanguage,
                LPCWSTR wszQuery,
                LONG lSidLength,
                const BYTE __RPC_FAR *pSid
                )
{
    HRESULT t_Status = WBEM_E_ACCESS_DENIED;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck\r\n");
)


        if (lSidLength  > 0)
        {
            if (pSid != NULL)
            {
                // permanent consumer: hope core did its job
                return WBEM_S_SUBJECT_TO_SDS;
            }
            else
            {
                return WBEM_E_ACCESS_DENIED;
            }
        }

        if (FAILED(CImpNTEvtProv::GetImpersonation()))
        {
            return WBEM_E_ACCESS_DENIED;
        }

        QL_LEVEL_1_RPN_EXPRESSION* pExpr;
        CTextLexSource Source(wszQuery);
        QL1_Parser Parser(&Source);

		int iError = CAbstractQl1Parser::SUCCESS;
        if( ( iError = Parser.Parse(&pExpr) ) == 0)
        {
            // Analyze this

            QL_LEVEL_1_RPN_EXPRESSION* pNewExpr;
            CPropertyName MyProp;
            MyProp.AddElement(TARGET_PROP);
            MyProp.AddElement(LOGFILE_PROP);

            if(SUCCEEDED(CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, MyProp, pNewExpr)))
            {
                CStringArray t_wsVals;
                HRESULT t_hres = CQueryAnalyser::GetValuesForProp(pNewExpr, MyProp, t_wsVals);

                if(SUCCEEDED(t_hres))
                {
                    //grant access and set false if a failure occurs...
                    t_Status = S_OK;

                    // awsVals contains the list of files
                    for (int x = 0; x < t_wsVals.GetSize(); x++)
                    {
                        DWORD t_dwReason = 0;
                        HANDLE t_hEvtlog = CEventLogFile::OpenLocalEventLog(t_wsVals[x], &t_dwReason);

                        if (t_hEvtlog == NULL)
                        {
                            if (t_dwReason != ERROR_FILE_NOT_FOUND)
                            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Failed to verify logfile access\r\n");
)
                                t_Status = WBEM_E_ACCESS_DENIED;
                                break;
                            }
                            else
                            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Logfile not found assuming access allowed for log\r\n");
)
                            }
                        }
                        else
                        {
                            CloseEventLog(t_hEvtlog);
                        }
                    }
                }
                else if(t_hres == WBEMESS_E_REGISTRATION_TOO_BROAD)
                {
                    // user asked for all, check all logs....
                    HKEY hkResult = NULL;
                    LONG t_lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            EVENTLOG_BASE, 0,
                                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                            &hkResult);

                    if (t_lErr == ERROR_SUCCESS)
                    {
                        DWORD iValue = 0;
                        WCHAR t_logname[MAX_PATH+1];
                        DWORD t_lognameSize = MAX_PATH+1;
                        //grant access and set false if a failure occurs...
                        t_Status = S_OK;

                        // read all entries under this key to find all logfiles...
                        while ((t_lErr = RegEnumKey(hkResult, iValue, t_logname, t_lognameSize)) != ERROR_NO_MORE_ITEMS)
                        {
                            // if error during read
                            if (t_lErr != ERROR_SUCCESS)
                            {
                                // indicate error
                                t_Status = WBEM_E_ACCESS_DENIED;
                                break;
                            }

                            //open logfile
                            DWORD t_dwReason = 0;
                            HANDLE t_hEvtlog = CEventLogFile::OpenLocalEventLog(t_logname, &t_dwReason);

                            if (t_hEvtlog == NULL)
                            {
                                if (t_dwReason != ERROR_FILE_NOT_FOUND)
                                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Failed to verify logfile access\r\n");
)
                                    t_Status = WBEM_E_ACCESS_DENIED;
                                    break;
                                }
                                else
                                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Logfile not found assuming access allowed for log\r\n");
)
                                }
                            }
                            else
                            {
                                CloseEventLog(t_hEvtlog);
                            }

                            // read next parameter
                            iValue++;

                        } // end while

                        RegCloseKey(hkResult);
                    }
                }

                t_wsVals.RemoveAll();
                delete pNewExpr;
            }

            delete pExpr;
        }
		else
		{
			if ( iError == CAbstractQl1Parser::SYNTAX_ERROR )
			{
				t_Status = WBEM_E_INVALID_QUERY;
			}
			else if ( iError == CAbstractQl1Parser::LEXICAL_ERROR )
			{
				t_Status = WBEM_E_UNPARSABLE_QUERY;
			}
			else if ( iError == CAbstractQl1Parser::FAILED )
			{
				t_Status = WBEM_E_FAILED;
			}
			else if ( iError == CAbstractQl1Parser::BUFFER_TOO_SMALL )
			{
				// as this is unexpected to happen
				t_Status = WBEM_E_UNEXPECTED;
			}
		}

        WbemCoRevertToSelf();

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Leaving CNTEventProvider::AccessCheck\r\n");
)
    }
    catch(Structured_Exception e_SE)
    {
        WbemCoRevertToSelf();
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        WbemCoRevertToSelf();
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        WbemCoRevertToSelf();
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

STDMETHODIMP CNTEventProvider::Initialize (
                LPWSTR pszUser,
                LONG lFlags,
                LPWSTR pszNamespace,
                LPWSTR pszLocale,
                IWbemServices *pCIMOM,         // For anybody
                IWbemContext *pCtx,
                IWbemProviderInitSink *pInitSink     // For init signals
                )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::Initialize\r\n");
)
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
		if (GlobalSIDsOK())
		{
			m_pNamespace = pCIMOM;
			m_pNamespace->AddRef();
			m_Mgr->SetFirstSinceLogon(pCIMOM, pCtx);
			pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 );
		}
		else
		{
			pInitSink->SetStatus ( WBEM_E_UNEXPECTED , 0 );
		}
    

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"Leaving CNTEventProvider::Initialize with SUCCEEDED\r\n");
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

STDMETHODIMP CNTEventProvider::ProvideEvents(IWbemObjectSink* pSink, LONG lFlags)
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::ProvideEvents\r\n");
)

        m_pEventSink = pSink;
        m_pEventSink->AddRef();
        
        if (!m_Mgr->Register(this))
        {

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"Leaving CNTEventProvider::ProvideEvents with FAILED\r\n");
)

            return WBEM_E_FAILED;
        }

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"Leaving CNTEventProvider::ProvideEvents with SUCCEEDED\r\n");
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}


CNTEventProvider::~CNTEventProvider()
{
    if (m_pNamespace != NULL)
    {
        m_pNamespace->Release();
    }

    if (m_pEventSink != NULL)
    {
        m_pEventSink->Release();    
    }
}


CNTEventProvider::CNTEventProvider(CEventProviderManager* mgr) : m_pNamespace(NULL), m_pEventSink(NULL)
{
    m_Mgr = mgr;
    m_ref = 0;
}


IWbemServices* CNTEventProvider::GetNamespace()
{
    m_pNamespace->AddRef();
    return m_pNamespace;
}

IWbemObjectSink* CNTEventProvider::GetEventSink()
{
    m_pEventSink->AddRef();
    return m_pEventSink;
}
void CNTEventProvider::ReleaseAll()
{
    //release dependencies
    m_pNamespace->Release();
    m_pEventSink->Release();
    Release();
}

void  CNTEventProvider::AddRefAll()
{
    //addref dependencies
    m_pNamespace->AddRef();
    m_pEventSink->AddRef();
    AddRef();
}

STDMETHODIMP_( ULONG ) CNTEventProvider::AddRef()
{
    SetStructuredExceptionHandler seh;

    try
    {
        InterlockedIncrement(&(CNTEventProviderClassFactory::objectsInProgress));
        return InterlockedIncrement ( &m_ref ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }

}

STDMETHODIMP_(ULONG) CNTEventProvider::Release()
{
    SetStructuredExceptionHandler seh;

    try
    {
        long ret;

        if ( 0 == (ret = InterlockedDecrement(&m_ref)) )
        {
            delete this;
        }
        else if ( 1 == ret )
        {
            m_Mgr->UnRegister(this);
        }

        InterlockedDecrement(&(CNTEventProviderClassFactory::objectsInProgress));
        return ret;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP CNTEventProvider::QueryInterface(REFIID riid, PVOID* ppv)
{
    SetStructuredExceptionHandler seh;

    try
    {
        *ppv = NULL;

        if (IID_IUnknown == riid)
        {
            *ppv=(IWbemEventProvider*)this;
        }
        else if (IID_IWbemEventProvider == riid)
        {
            *ppv=(IWbemEventProvider*)this;
        }
        else if (IID_IWbemProviderInit == riid)
        {
            *ppv= (IWbemProviderInit*)this;
        }
        else if (IID_IWbemEventProviderSecurity == riid)
        {
            *ppv= (IWbemEventProviderSecurity*)this;
        }

        if (NULL==*ppv)
        {
            return E_NOINTERFACE;
        }

        //AddRef any interface we'll return.
        ((LPUNKNOWN)*ppv)->AddRef();    
        return NOERROR;
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtmthd.cpp ===
//***************************************************************************

//

//  NTEVTMTHD.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the ExecMethod implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


BOOL ExecMethodAsyncEventObject :: ExecMethod ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod\r\n"
        ) ;
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

    if ( t_Status )
    {
        if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , NTEVTLOG_CLASS ) == 0 )
        {
            t_Status = GetClassObject ( m_ParsedObjectPath->m_pClass ) ;

            if ( t_Status )
            {
                IWbemClassObject * tmp = NULL;
                IWbemClassObject * outclass = NULL;
                t_Status = SUCCEEDED(m_ClassObject->GetMethod(m_Method, 0, &tmp, &outclass));

                if (tmp != NULL)
                {
                    tmp->Release();
                }

                if ((t_Status) && (outclass != NULL))
                {
                    t_Status = SUCCEEDED(outclass->SpawnInstance(0, &m_pOutClass));
                    
                    if (!t_Status)
                    {
                        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                        a_ErrorObject.SetMessage ( L"Unable to spawn result object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Unable to spawn result object\r\n"
        ) ;
)
                    }
                    else
                    {
                        t_Status =  Dispatch_EventLog ( a_ErrorObject ) ;
                        
                        if ( t_Status )
                        {
                            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                        }
                    }
                    
                    outclass->Release();
                }
                else
                {
                    t_Status = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    a_ErrorObject.SetMessage ( L"Unable to get result class object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Unable to get result class object\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                a_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Class definition not found\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS ) ;
            a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not methods support on this class" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Dynamic NT Eventlog Provider does not methods support on this class\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Unable to parse object path %s\r\n",
        m_ObjectPath
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}


BOOL ExecMethodAsyncEventObject :: Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 1)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;
    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;

    if ( t_Key1 )
    {
        if ((t_Key1->m_pName == NULL) || _wcsicmp ( t_Key1->m_pName , PROP_NAME ) == 0 )
        {
            if ( t_Key1->m_vValue.vt == VT_BSTR )
            {
                t_Status = ExecMethod_EventLog ( a_ErrorObject , t_Key1 ) ;
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog: Key value has incorrect type\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value has incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog: Key value has incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key value" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog:Failed to get key value\r\n"
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL ExecMethodAsyncEventObject :: ExecMethod_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey) 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog\r\n"
        ) ;
)
    BOOL retVal = TRUE;
    
    VARIANT v;
    VariantInit(&v);
    CIMTYPE cT = VT_NULL;

    if (m_InParamObject != NULL)
    {
        HRESULT hr =  m_InParamObject->Get(METHOD_PARAM, 0, &v, &cT, NULL);

        if (SUCCEEDED(hr))
        {
            if (cT != CIM_STRING)
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"ArchiveFileName parameter should be a string" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter should be a string\r\n"
        ) ;
)
            }
        }
        else
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"ArchiveFileName parameter not found in supplied InParam object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter not found in supplied InParam object\r\n"
        ) ;
)
        }
    }

    DWORD x = ERROR_SUCCESS;

    if (retVal)
    {
        if (_wcsicmp(m_Method, L"ClearEventlog") == 0)
        {
            wchar_t* param = NULL;

            if ((v.vt != VT_BSTR) && (v.vt != VT_NULL))
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"ArchiveFileName parameter not found in supplied InParam object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter not found in supplied InParam object\r\n"
        ) ;
)
            }
            else if (v.vt == VT_BSTR)
            {
                param =  v.bstrVal;
            }

            if (retVal)
            {
                CStringW log = CEventLogFile::GetLogName((const wchar_t*)a_FileKey->m_vValue.bstrVal);

                if (log.IsEmpty())
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    a_ErrorObject.SetMessage ( L"Could not find specified Eventlog" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Could not find specified Eventlog\r\n"
        ) ;
)
                }
                else
                {
                    CEventlogFileAttributes evtLog(log);
                    x = evtLog.EventLogOperation(param, TRUE, a_ErrorObject, retVal);
                }
            }
        }
        else if (_wcsicmp(m_Method, L"BackupEventlog") == 0)
        {
            if (v.vt != VT_BSTR)
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"ArchiveFileName parameter not found in supplied InParam object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter not found in supplied InParam object\r\n"
        ) ;
)
            }
            else
            {
                CStringW log = CEventLogFile::GetLogName((const wchar_t*)a_FileKey->m_vValue.bstrVal);

                if (log.IsEmpty())
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    a_ErrorObject.SetMessage ( L"Could not find specified Eventlog" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Could not find specified Eventlog\r\n"
        ) ;
)
                }
                else
                {
                    CEventlogFileAttributes evtLog(log);
                    x = evtLog.EventLogOperation(v.bstrVal, FALSE, a_ErrorObject, retVal);
                }
            }
        }
        else
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Unknown method name supplied." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Unknown method name supplied.\r\n"
        ) ;
)
        }
    }

    if (x != ERROR_SUCCESS)
    {
        wchar_t* buff = NULL;

        if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, x, 0, (LPWSTR) &buff, 80, NULL))
        {
            DWORD dwErr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Calling underlying Eventlog API failed.\r\n"
        ) ;
)
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:%s\r\n",
        buff
        ) ;
)
            LocalFree(buff);
        }
    }

    VariantClear(&v);

    if (retVal)
    {
        // set out-param
        VariantInit(&v);
        v.vt = VT_I4;
        v.lVal = x;
        HRESULT hr = m_pOutClass->Put(METHOD_RESULT_PARAM, 0, &v, 0);

        if (FAILED(hr))
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Unable to put OutParam value." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Unable to put OutParam value.\r\n"
        ) ;
)
            m_pOutClass->Release();
            m_pOutClass = NULL;
        }
        else
        {
            m_bIndicateOutParam = TRUE;
        }

        VariantClear(&v);
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:returning with %lx\r\n",
        retVal
        ) ;
)

    return retVal;
}

ExecMethodAsyncEventObject :: ExecMethodAsyncEventObject (

        CImpNTEvtProv *a_Provider , 
        wchar_t *a_ObjectPath ,
        wchar_t *a_MethodName,
        ULONG a_Flag ,
        IWbemClassObject *a_InParams ,      
        IWbemObjectSink *a_NotificationHandler ,
        IWbemContext *pCtx

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_Flag , pCtx ) ,
    m_Class ( NULL ), m_InParamObject( NULL ), m_bIndicateOutParam ( FALSE ),
    m_pOutClass ( NULL ), m_ParsedObjectPath ( NULL )
{
    m_InParamObject = a_InParams ;

    if (m_InParamObject != NULL)
    {
        m_InParamObject->AddRef();
    }

    m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
    m_Method = UnicodeStringDuplicate ( a_MethodName ) ;
}

ExecMethodAsyncEventObject :: ~ExecMethodAsyncEventObject () 
{
    if (m_pOutClass != NULL)
    {
        if ( m_bIndicateOutParam && (SUCCEEDED(m_ErrorObject.GetWbemStatus ())) )
        {
            HRESULT t_Result = m_NotificationHandler->Indicate(1, &m_pOutClass);
        }

        m_pOutClass->Release();
    }

    if (m_InParamObject != NULL)
    {
        m_InParamObject->Release();
    }

    delete [] m_ObjectPath ;
    delete [] m_Method ;
    delete m_ParsedObjectPath;

    // Get Status object
    IWbemClassObject *t_NotifyStatus = NULL ;
    BOOL t_Status = TRUE;
    
    if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
    {
        t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
    }

    if ( t_Status )
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
        
        if (t_NotifyStatus)
        {
            t_NotifyStatus->Release () ;
        }
    }
    else
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
    }

}


void ExecMethodAsyncEventObject :: Process () 
{
    ExecMethod ( m_ErrorObject ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtput.cpp ===
//***************************************************************************

//

//  NTEVTPUT.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the PutObject implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


BOOL PutInstanceAsyncEventObject :: PutInstance ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance\r\n"
        ) ;
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    VARIANT v;
    VariantInit (&v);
    BOOL t_Status = SUCCEEDED(m_InstObject->Get(CLASS_PROP, 0, &v, NULL, NULL));

    if (( t_Status ) && (VT_BSTR == v.vt))
    {
        if ( _wcsicmp ( v.bstrVal , NTEVTLOG_CLASS) == 0 )
        {
            if ( t_Status )
            {
                t_Status =  Dispatch_EventLog ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
            }
        }
        /*
        else if ( _wcsicmp ( v.bstrVal , some_other_class) == 0 )
        {
            if ( t_Status )
            {
                t_Status =  Dispatch_some_other_class ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
            }
        }
        */
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
            a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not support WRITE for this class" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Dynamic NT Eventlog Provider does not support WRITE for this class\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_OBJECT ) ;
        a_ErrorObject.SetMessage ( L"Unable to obtain class name from object." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Unable to obtain class name from object.\r\n"
        ) ;
)
    }

    VariantClear(&v);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:returning %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}


BOOL PutInstanceAsyncEventObject :: Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
    if (WBEM_FLAG_CREATE_ONLY == (m_OperationFlag & WBEM_FLAG_CREATE_ONLY))
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OPERATION ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
        a_ErrorObject.SetMessage ( L"WBEM_FLAG_CREATE_ONLY is unsupported, modify only!" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:WBEM_FLAG_CREATE_ONLY is unsupported, modify only!\r\n"
        ) ;
)

        return FALSE ;
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance\r\n"
        ) ;
)

    VARIANT v;
    VariantInit(&v);
    BOOL t_Status = SUCCEEDED(m_InstObject->Get(PROP_NAME, 0, &v, NULL, NULL));
    
    if (( t_Status ) && (VT_BSTR == v.vt))
    {
        CStringW log = CEventLogFile::GetLogName(v.bstrVal);

        if (log.IsEmpty())
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus (WBEM_E_INVALID_OBJECT ) ;
            a_ErrorObject.SetMessage (L"Unable to find log file specified.");
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Unable to find log file specified.\r\n"
        ) ;
)
        }
        else
        {
            VariantClear(&v);
            VariantInit(&v);
            t_Status = SUCCEEDED(m_InstObject->Get(PROP_LOGNAME, 0, &v, NULL, NULL));
                
            if (( t_Status ) && (VT_BSTR == v.vt) && (0 == _wcsicmp(log, v.bstrVal)))
            {
                CEventlogFileAttributes evtLog(log);
                DWORD dwR = evtLog.UpdateRegistry(m_InstObject);

                if (ERROR_SUCCESS != dwR)
                {
                    t_Status = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    wchar_t* buff = NULL;

                    if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                            NULL, dwR, 0, (LPWSTR) &buff, 80, NULL))
                    {
                        DWORD x = GetLastError();
                        a_ErrorObject.SetMessage (L"Failed to write some (maybe all) data.");
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Failed to write some (maybe all) data.\r\n"
        ) ;
)
                    }
                    else
                    {
                        a_ErrorObject.SetMessage (buff) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:%s.\r\n",
        buff
        ) ;
)
                        LocalFree(buff);
                    }
                }
            }
            else
            {
                t_Status = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                a_ErrorObject.SetMessage (L"Logfilename doesn't match name property (key)") ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Logfilename doesn't match name property (key)\r\n"
        ) ;
)
            }
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_OBJECT ) ;
        a_ErrorObject.SetMessage ( L"Unable to obtain key property from object." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Unable to obtain key property from object.\r\n"
        ) ;
)
    }

    VariantClear(&v);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:returning %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

PutInstanceAsyncEventObject :: PutInstanceAsyncEventObject (

    CImpNTEvtProv *a_Provider , 
    IWbemClassObject* a_Inst ,
    ULONG a_OperationFlag ,
    IWbemObjectSink *a_NotificationHandler ,
    IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
    m_InstObject ( NULL ) 
{
    m_InstObject = a_Inst ;

    if (m_InstObject != NULL)
    {
        m_InstObject->AddRef();
    }
}

PutInstanceAsyncEventObject :: ~PutInstanceAsyncEventObject () 
{
// Get Status object
    IWbemClassObject *t_NotifyStatus = NULL ;
    BOOL t_Status = TRUE;
    
    if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
    {
        t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
    }

    if ( t_Status )
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;

        if (t_NotifyStatus)
        {
            t_NotifyStatus->Release () ;
        }
    }
    else
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
    }

    if (m_InstObject != NULL)
    {
        m_InstObject->Release();
    }

}


void PutInstanceAsyncEventObject :: Process () 
{
    PutInstance ( m_ErrorObject ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtquery.cpp ===
//***************************************************************************

//

//  NTEVTQUERY.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the ExecQuery implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <wbemtime.h>

#define NTEVT_DECPOS	14
#define NTEVT_SGNPOS	21
#define NTEVT_DMTFLEN	25

wchar_t* CheckForSpecialCharacters(const wchar_t* wstr)
{
    if (wstr == NULL)
    {
        return NULL;
    }

    int wstrlen = wcslen(wstr) * 2;
    wchar_t* ret = new wchar_t[wstrlen + 1];
    const wchar_t* tmp = wstr;
    int x = 0;

    while ((*tmp != L'\0') && (x < wstrlen))
    {
        if (*tmp == L'\\')
        {
            ret[x++] = L'\\';
        }
        
        ret[x++] = *tmp;
        tmp++;
    }

    ret[x] = L'\0';
    return ret;
}


BOOL GenerateAssocInstance ( WbemProvErrorObject &a_ErrorObject,
                                                         const wchar_t* objPath1,
                                                         const wchar_t* objPath2,
                                                         wchar_t* prop1,
                                                         wchar_t* prop2,
                                                         IWbemClassObject* pClassObject,
                                                         IWbemObjectSink* pNtfcnHandler,
														 BOOL *pbIndicated)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance\r\n"
        );
)

    IWbemClassObject* pInst = NULL;
    HRESULT result = pClassObject->SpawnInstance(0, &pInst);
    BOOL retVal = TRUE;

	if (pbIndicated)
	{
		*pbIndicated = FALSE;
	}

    if (FAILED(result))
    {
        retVal = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        a_ErrorObject.SetMessage ( L"Failed to spawn association instance." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:Failed to spawn association instance.\r\n"
        );
)
    }
    else
    {
        VARIANT v;
        VariantInit (&v);
        v.vt = VT_BSTR;

		HRESULT result = WBEM_E_OUT_OF_MEMORY ;

        v.bstrVal = SysAllocString(objPath1);
		if ( v.bstrVal )
		{
			result = pInst->Put(prop1, 0, &v, 0);
		}

        VariantClear(&v);

        if (FAILED(result))
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            a_ErrorObject.SetMessage ( L"Failed to set association key property." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:Failed to set association key property\r\n"
        );
)
        }
        else
        {
            VariantInit (&v);
            v.vt = VT_BSTR;

			HRESULT result = WBEM_E_OUT_OF_MEMORY ;

            v.bstrVal = SysAllocString(objPath2);
			if ( v.bstrVal )
			{
				result = pInst->Put(prop2, 0, &v, 0);
			}

            VariantClear(&v);

            if (FAILED(result))
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                a_ErrorObject.SetMessage ( L"Failed to set association key property." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:Failed to set association key property\r\n"
        );
)
            }
            else
            {
                result = pNtfcnHandler->Indicate ( 1, & pInst );
				
				if (FAILED(result))
				{
					retVal = FALSE;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
					a_ErrorObject.SetMessage ( L"Failed to indicate association instance." );
				}
				else
				{
					if (pbIndicated)
					{
						*pbIndicated = TRUE;
					}
				}
            }
        }

        pInst->Release();
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:returning %lx\r\n",
        retVal
        );
)
    return retVal;
}




BOOL ExecQueryAsyncEventObject :: OptimizeAssocQuery ( 
                                                      
    WbemProvErrorObject &a_ErrorObject, 
    BSTR *a_ObjectPath 
)
{
    *a_ObjectPath = NULL;

    BOOL t_Status = FALSE;
    
    SQL_LEVEL_1_TOKEN *pArrayOfTokens = m_RPNExpression->pArrayOfTokens;
    int nNumTokens = m_RPNExpression->nNumTokens;

    if ( ! pArrayOfTokens )
    {
        return t_Status;
    }

    if (( nNumTokens != 3 ) && ( nNumTokens != 1 ))
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].dwPropertyFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].dwConstFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].nTokenType != SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].vConstValue.vt != VT_BSTR )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].vConstValue.bstrVal == NULL )
    {
        return t_Status;
    }

    if ( nNumTokens == 3 )
    {
        if ( pArrayOfTokens [ 1 ].dwPropertyFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].dwConstFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].nTokenType != SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].vConstValue.vt != VT_BSTR )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].vConstValue.bstrVal == NULL )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 2 ].nTokenType != SQL_LEVEL_1_TOKEN :: TOKEN_OR )
        {
            return t_Status;
        }

        if (_wcsicmp(pArrayOfTokens[0].vConstValue.bstrVal, pArrayOfTokens[1].vConstValue.bstrVal) != 0)
        {
            return t_Status;
        }
    
        *a_ObjectPath = SysAllocString ( pArrayOfTokens [ 0 ].vConstValue.bstrVal );
		if ( *a_ObjectPath )
		{
			t_Status = TRUE;
		}
    }
    else
    {
        *a_ObjectPath = SysAllocString ( pArrayOfTokens [ 0 ].vConstValue.bstrVal );
		if ( *a_ObjectPath )
		{
			t_Status = TRUE;
		}
    }

    return t_Status;
}

wchar_t* ExecQueryAsyncEventObject :: GetClassFromPath(wchar_t* path)
{
    wchar_t* retVal = NULL;
    CObjectPathParser pathParser;
    ParsedObjectPath *parsedObjectPath = NULL;

    if (!pathParser.Parse(path, &parsedObjectPath))
    {
        retVal = UnicodeStringDuplicate(parsedObjectPath->m_pClass);
    }
    
    delete parsedObjectPath;
    return retVal;
}

BOOL ExecQueryAsyncEventObject :: Query_LogRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord\r\n"
        );
)

    BSTR t_ObjectPath = NULL;
    BOOL retVal = TRUE;
    BOOL bGenAll = FALSE;

    if (OptimizeAssocQuery (a_ErrorObject, &t_ObjectPath))
    {
        GetObjectAsyncEventObject *t_getObj = new GetObjectAsyncEventObject (
                                                    m_Provider, t_ObjectPath,
                                                    0, m_NotificationHandler, m_Ctx, FALSE);

		BOOL t_Status = t_getObj->GetObject(t_getObj->m_ErrorObject);
        if (! t_Status )
        {
            bGenAll = TRUE;
            //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to verify object given in query\r\n"
        );
)
        }
        else
        {
            VARIANT v;
            VariantInit(&v);
            HRESULT result = t_getObj->m_Out->Get(CLASS_PROP, 0, &v, NULL, NULL);

            if ((FAILED(result)) || (v.vt != VT_BSTR))
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                a_ErrorObject.SetMessage ( L"Failed to get class name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get class name of object given in query\r\n"
        );
)
            }
            else
            {
                if (_wcsicmp(v.bstrVal, NTEVTLOG_CLASS) == 0)
                {
                    VARIANT vLog;
                    VariantInit(&vLog);
                    result = t_getObj->m_Out->Get(PROP_LOGNAME, 0, &vLog, NULL, NULL);

                    if ((FAILED(result)) || (vLog.vt != VT_BSTR))
                    {
                        retVal = FALSE;
                        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                        a_ErrorObject.SetMessage ( L"Failed to get log file name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get log file name of object given in query\r\n"
        );
)
                    }
                    else
                    {
                        //get all records for this log
                        retVal = GenerateLogAssocs(a_ErrorObject, t_ObjectPath, vLog.bstrVal, TRUE, NULL);
                    }

                    VariantClear(&vLog);
                }
                else if (_wcsicmp(v.bstrVal, NTEVT_CLASS) == 0)
                {
                    VARIANT vLog;
                    VariantInit(&vLog);
                    result = t_getObj->m_Out->Get(LOGFILE_PROP, 0, &vLog, NULL, NULL);

                    if ((FAILED(result)) || (vLog.vt != VT_BSTR))
                    {
                        retVal = FALSE;
                        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                        a_ErrorObject.SetMessage ( L"Failed to get log file name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get log file name of object given in query\r\n"
        );
)
                    }
                    else
                    {
                        //get log for this record
                        CStringW logNameVal(EVENTLOG_BASE);
                        logNameVal += L"\\";
                        logNameVal += CStringW(vLog.bstrVal);
                        HKEY hkResult;
                        LONG res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, logNameVal, 0,
                                KEY_READ, &hkResult);

                        if (res != ERROR_SUCCESS)
                        {
                            retVal = FALSE;
                            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                            if ((res == ERROR_ACCESS_DENIED) || (res == ERROR_PRIVILEGE_NOT_HELD))
                            {
                                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                                a_ErrorObject.SetPrivilegeFailed();
                                a_ErrorObject.SetSecurityPrivRequired();
                                a_ErrorObject.SetSecurityPrivFailed();
                            }
                            else
                            {
                                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                            }

                            a_ErrorObject.SetMessage ( L"Failed to get log file associated to object given in query");
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get log file associated to object given in query\r\n"
        );
)
                        }
                        else
                        {
                            CStringW logPath(PROP_START_LOG);
                            wchar_t* spchrs = CheckForSpecialCharacters(CEventLogFile::GetFileName(hkResult));
                            RegCloseKey(hkResult);
                            logPath += CStringW(spchrs);
                            delete [] spchrs;
                            logPath += PROP_END_QUOTE;
                            retVal = GenerateAssocInstance(a_ErrorObject, t_ObjectPath, logPath, REF_REC, REF_LOG,
                                                            m_ClassObject, m_NotificationHandler, NULL);
                        }
                    }

                    VariantClear(&vLog);
                }
                else
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                    a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE );
                    a_ErrorObject.SetMessage ( L"Class name of object given in query is not a property of Association class" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Class name of object given in query is not a property of Association class\r\n"
        );
)
                }
            }

            VariantClear(&v);
        }

        SysFreeString (t_ObjectPath);
        delete t_getObj;

		if ( FAILED ( WbemCoImpersonateClient() ) )
		{
			m_ErrorObject.SetStatus (WBEM_PROV_E_ACCESS_DENIED);
			m_ErrorObject.SetWbemStatus (WBEM_E_ACCESS_DENIED);
			m_ErrorObject.SetMessage (L"Access denied, impersonation level too low");
			return FALSE ;
		}
    }
    else
    {
        bGenAll = TRUE;
    }

    if (bGenAll)
    {
        //get all instances...
        // open registry for log names
        HKEY hkResult;
        LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                EVENTLOG_BASE, 0,
                                KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                &hkResult);

        if (status != ERROR_SUCCESS)
        {
            // indicate error
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

            if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
            {
                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                a_ErrorObject.SetPrivilegeFailed();
                a_ErrorObject.SetSecurityPrivRequired();
                a_ErrorObject.SetSecurityPrivFailed();
            }
            else
            {
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            }

            a_ErrorObject.SetMessage ( L"Failed to open the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to open the Eventlog registry for logfiles - Returning FALSE.\r\n"
        );
)

            retVal = FALSE;
            return retVal;
        }

        DWORD iValue = 0;
        WCHAR t_logname[MAX_PATH+1];
        DWORD t_lognameSize = MAX_PATH+1;
		BOOL bContinue = TRUE;

        // read all entries under this key to find all logfiles...
        while (bContinue && ((status = RegEnumKey(hkResult, iValue, t_logname, t_lognameSize)) != ERROR_NO_MORE_ITEMS))
        {
            // if error during read
            if (status != ERROR_SUCCESS)
            {
                // indicate error
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                    a_ErrorObject.SetPrivilegeFailed();
                    a_ErrorObject.SetSecurityPrivRequired();
                    a_ErrorObject.SetSecurityPrivFailed();
                }
                else
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                }

                a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
                retVal = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed while enumerating the Eventlog registry for logfiles.\r\n"
        );
)
                break;
            }

            //create the associations for this logfile...
            HKEY hkLog;

            if (ERROR_SUCCESS == RegOpenKeyEx(hkResult, t_logname, 0, KEY_QUERY_VALUE, &hkLog))
            {
                CStringW t_logPath(PROP_START_LOG);
                CStringW t_evtlognamestr = CEventLogFile::GetFileName(hkLog);

                if (!t_evtlognamestr.IsEmpty())
                {
                    wchar_t* spchrs = CheckForSpecialCharacters(t_evtlognamestr);
                    t_logPath += CStringW(spchrs);
                    delete [] spchrs;
                    t_logPath += PROP_END_QUOTE;

                    if (!GenerateLogAssocs(a_ErrorObject, t_logPath, t_logname, FALSE, &bContinue))
                    {
                        retVal = FALSE;
                    }
                }
                else
                {
                    retVal = FALSE;
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get file for the %s logfile.\r\n",
                t_logname
                );
)

                }

                RegCloseKey(hkLog);
            }

            // read next parameter
            iValue++;

        } // end while

        RegCloseKey(hkResult);
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:returning %lx\r\n",
        retVal
        );
)
    
    return retVal;
}

BOOL ExecQueryAsyncEventObject :: GenerateLogAssocs( WbemProvErrorObject &a_ErrorObject,
                                                    const wchar_t* logPath,
                                                    const wchar_t* logName,
													BOOL bVerifyLogname,
													BOOL *pbContinue)
{
    BOOL retVal = TRUE;

	if (pbContinue)
	{
		*pbContinue = TRUE;
	}

    CEventLogFile evtLog(logName, bVerifyLogname);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs\r\n"
        );
)

    if (!evtLog.IsValid())
    {
        retVal = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((evtLog.GetReason() == ERROR_ACCESS_DENIED) || (evtLog.GetReason() == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
            a_ErrorObject.SetPrivilegeFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to open eventlog to enumerate records for Log Association." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs:Failed to open eventlog to enumerate records for Log Association\r\n"
        );
)
    }
    else
    {
        DWORD recId;
        DWORD numRecs;
        
        if (evtLog.GetLastRecordID(recId, numRecs))
        {
            for (DWORD x = recId; (x > (recId - numRecs)); x--)
            {
                CStringW recPath(PROP_START_REC);
                recPath += CStringW(logName);
                recPath += PROP_MID_REC;
                wchar_t buff[40];
                recPath += CStringW(_ultow((ULONG)x, buff, 10));
                
				if (!GenerateAssocInstance(a_ErrorObject, recPath,
                                        logPath, REF_REC, REF_LOG,
                                        m_ClassObject, m_NotificationHandler, pbContinue))
                {
                    retVal = FALSE;
                }
				
				if (pbContinue && !(*pbContinue))
				{
					break;
				}
            }
        }
        else
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            a_ErrorObject.SetMessage ( L"Failed to determine number of records in eventlog for log associations" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs:Failed to determine number of records in eventlog for log associations\r\n"
        );
)
        }
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}


BOOL ExecQueryAsyncEventObject :: Query_UserRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord\r\n"
        );
)

    BSTR t_ObjectPath = NULL;
    BOOL retVal = TRUE;
    BOOL bGenAll = FALSE;

    if (OptimizeAssocQuery (a_ErrorObject, &t_ObjectPath))
    {
        wchar_t* str_classname = GetClassFromPath(t_ObjectPath);

        if (str_classname == NULL)
        {
            bGenAll = TRUE;
            //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to verify object given in query\r\n"
        );
)

        }
        else if (_wcsicmp(str_classname, USER_CLASS) == 0)
        {
            IWbemClassObject* pObj = NULL;
            IWbemServices *t_Server = m_Provider->GetServer();
            HRESULT result = t_Server->GetObject(t_ObjectPath, 0, m_Ctx, &pObj, NULL);

            t_Server->Release();

            if (FAILED(result))
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to verify object given in query\r\n"
        );
)
            }
            else
            {
                pObj->Release ();

                //get all records...
                retVal = GenerateCompUserAssocs(a_ErrorObject, FALSE);
            }
            
            delete [] str_classname;
        }
        else if (_wcsicmp(str_classname, NTEVT_CLASS) == 0)
        {
            GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                        m_Provider, t_ObjectPath,
                                                        0, m_NotificationHandler,
                                                        m_Ctx, FALSE );

            if (t_getRec->GetObject(t_getRec->m_ErrorObject))
            {
                VARIANT vUser;
                CIMTYPE cT;
                VariantInit(&vUser);
                HRESULT result = t_getRec->m_Out->Get(USER_PROP, 0, &vUser, &cT, NULL);

                if ((FAILED(result)) || (cT != CIM_STRING))
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                    a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to get user name of object given in query\r\n"
        );
)
                }
                else
                {
                    if ((vUser.vt == VT_BSTR) && (vUser.bstrVal != NULL))
                    {
                        //get user for this record
                        CStringW userVal(vUser.bstrVal);
                        int pos = userVal.Find(L'\\');

                        if (pos != -1)
                        {
                            CStringW dom = userVal.Left(pos);
                            CStringW nm = userVal.Right(userVal.GetLength() - 1 - pos);

                            if (!nm.IsEmpty() && !dom.IsEmpty())
                            {
                                wchar_t userPath[1024];
                                if ( SUCCEEDED ( StringCchCopyW ( userPath, 1024, PROP_START_USER ) ) )
								{
									if ( SUCCEEDED ( StringCchCatW ( userPath, 1024, dom ) ) )
									{
										if ( SUCCEEDED ( StringCchCatW ( userPath, 1024, PROP_MID_USER ) ) )
										{
			                                if ( SUCCEEDED ( StringCchCatW ( userPath, 1024, nm ) ) )
											{
				                                if ( SUCCEEDED ( StringCchCatW ( userPath, 1024, PROP_END_QUOTE ) ) )
												{
													IWbemClassObject* pUObj = NULL;
													IWbemServices *t_Server = m_Provider->GetServer();
													HRESULT result = WBEM_E_OUT_OF_MEMORY ;
													BSTR userStr = SysAllocString(userPath);
													if ( userStr )
													{
														result = t_Server->GetObject(userStr, 0, m_Ctx, &pUObj, NULL);
														SysFreeString(userStr);
													}

													t_Server->Release();

													if (SUCCEEDED(result))
													{
														retVal = GenerateAssocInstance(a_ErrorObject, t_ObjectPath,
																			userPath, REF_REC, REF_USER,
																			m_ClassObject, m_NotificationHandler, NULL);
														pUObj->Release();
													}
													else
													{
														retVal = FALSE;
														a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
														a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
														a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
													}
												}
												else
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
													a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
													a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
												}
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
												a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
											}
										}
										else
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
											a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
											a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
										}
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
										a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
									}
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
									a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
								}
							}
                        }
                    }
                }

                VariantClear(&vUser);
            }
            else
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to verify object given in query\r\n"
        );
)
            }

            delete t_getRec;
            delete [] str_classname;

			if ( FAILED ( WbemCoImpersonateClient() ) )
			{
				m_ErrorObject.SetStatus (WBEM_PROV_E_ACCESS_DENIED);
				m_ErrorObject.SetWbemStatus (WBEM_E_ACCESS_DENIED);
				m_ErrorObject.SetMessage (L"Access denied, impersonation level too low");

				SysFreeString (t_ObjectPath);

				return FALSE ;
			}
        }
        else
        {
            bGenAll = TRUE;
            delete [] str_classname;
        }

        SysFreeString (t_ObjectPath);
    }
    else
    {
        bGenAll = TRUE;
    }

    if (bGenAll)
    {
        //get all instances...
        retVal = GenerateCompUserAssocs(a_ErrorObject, FALSE);
    }
    
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}

BOOL ExecQueryAsyncEventObject :: Query_ComputerRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord\r\n"
        );
)

    BSTR t_ObjectPath = NULL;
    BOOL retVal = TRUE;
    BOOL bGenAll = FALSE;

    if (OptimizeAssocQuery (a_ErrorObject, &t_ObjectPath))
    {
        wchar_t* str_classname = GetClassFromPath(t_ObjectPath);

        if (str_classname == NULL)
        {
            bGenAll = TRUE;
            //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to verify object given in query\r\n"
        );
)
        }
        else if (_wcsicmp(str_classname, COMP_CLASS) == 0)
        {
            IWbemClassObject* pObj = NULL;
            IWbemServices *t_Server = m_Provider->GetServer();
            HRESULT result = t_Server->GetObject(t_ObjectPath, 0, m_Ctx, &pObj, NULL);
            t_Server->Release();

            if (FAILED(result))
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to verify object given in query\r\n"
        );
)
            }
            else
            {
                pObj->Release ();

                //get all records...
                retVal = GenerateCompUserAssocs(a_ErrorObject, TRUE);
            }

            delete [] str_classname;
        }
        else if (_wcsicmp(str_classname, NTEVT_CLASS) == 0)
        {
            GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                        m_Provider, t_ObjectPath,
                                                        0, m_NotificationHandler,
                                                        m_Ctx, FALSE);

            if (t_getRec->GetObject(t_getRec->m_ErrorObject))
            {
                VARIANT vComp;
                CIMTYPE cT;
                VariantInit(&vComp);
                HRESULT result = t_getRec->m_Out->Get(COMPUTER_PROP, 0, &vComp, &cT, NULL);

                if ((FAILED(result)) || (cT != CIM_STRING))
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                    a_ErrorObject.SetMessage ( L"Failed to get computer name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to get computer name of object given in query\r\n"
        );
)
                }
                else
                {
                    if ((vComp.vt == VT_BSTR) && (vComp.bstrVal != NULL))
                    {
                        //get computer for this record
                        wchar_t compPath[1024];
                        if ( SUCCEEDED ( StringCchCopyW ( compPath, 1024, PROP_START_COMP ) ) )
						{
							if ( SUCCEEDED ( StringCchCatW ( compPath, 1024, vComp.bstrVal ) ) )
							{
								if ( SUCCEEDED ( StringCchCatW ( compPath, 1024, PROP_END_QUOTE ) ) )
								{
									IWbemClassObject* pCObj = NULL;
									IWbemServices *t_Server = m_Provider->GetServer();

									HRESULT result = WBEM_E_OUT_OF_MEMORY ;
									BSTR compStr = SysAllocString(compPath);
									if ( compStr )
									{
										result = t_Server->GetObject(compStr, 0, m_Ctx, &pCObj, NULL);
										SysFreeString(compStr);
									}

									t_Server->Release();

									if (SUCCEEDED(result))
									{
										retVal = GenerateAssocInstance(a_ErrorObject, t_ObjectPath,
															compPath, REF_REC, REF_COMP,
															m_ClassObject, m_NotificationHandler, NULL);
										pCObj->Release();
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
										a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
									}
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
									a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
								}
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
								a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
							}
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
							a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
						}
                    }
                }

                VariantClear(&vComp);
            }
            else
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to verify object given in query\r\n"
        );
)
            }

            delete t_getRec;
            delete [] str_classname;

			if ( FAILED ( WbemCoImpersonateClient() ) )
			{
				m_ErrorObject.SetStatus (WBEM_PROV_E_ACCESS_DENIED);
				m_ErrorObject.SetWbemStatus (WBEM_E_ACCESS_DENIED);
				m_ErrorObject.SetMessage (L"Access denied, impersonation level too low");

			        SysFreeString (t_ObjectPath);

				return FALSE ;
			}
        }
        else
        {
            bGenAll = TRUE;
            delete [] str_classname;
        }

        SysFreeString (t_ObjectPath);
    }
    else
    {
        bGenAll = TRUE;
    }

    if (bGenAll)
    {
        //get all instances...
        retVal = GenerateCompUserAssocs(a_ErrorObject, TRUE);
    }
    
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}


BOOL ExecQueryAsyncEventObject :: GenerateCompUserAssocs ( WbemProvErrorObject &a_ErrorObject, BOOL bComp )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs\r\n"
        );
)

    BOOL retVal = TRUE;
    //just enumerate all logs and let cimom post filter...
    // open registry for log names
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        // indicate error
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
            a_ErrorObject.SetPrivilegeFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to enumerate the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Failed to enumerate the Eventlog registry for logfiles- Returning FALSE\r\n"
        );
)

        return FALSE;
    }

    DWORD iValue = 0;
    WCHAR logname[MAX_PATH+1];
    DWORD lognameSize = MAX_PATH+1;
    CMap<CStringW, LPCWSTR, HRESULT, HRESULT> pathMap;
	BOOL bContinue = TRUE;

    // read all entries under this key to find all logfiles...
    while (bContinue && ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS))
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
            RegCloseKey(hkResult);

            // indicate error
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

            if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
            {
                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                a_ErrorObject.SetSecurityPrivRequired();
                a_ErrorObject.SetSecurityPrivFailed();
                a_ErrorObject.SetPrivilegeFailed();
            }
            else
            {
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            }

            a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Failed while enumerating the Eventlog registry for logfiles - Returning FALSE\r\n"
        );
)
            return FALSE;
        }

        //process this logfile
        CEventLogFile evtLog(logname, FALSE);

        if (evtLog.IsValid())
        {
            evtLog.ReadLastRecord();
        }

        while (bContinue && evtLog.IsValid())
        {
            DWORD dwEventSize = 0;
            DWORD err = evtLog.ReadRecord(0, &dwEventSize, TRUE);

            if (0 != err)
            {
                if (retVal && (err != ERROR_HANDLE_EOF))
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                    if ((err == ERROR_ACCESS_DENIED) || (err == ERROR_PRIVILEGE_NOT_HELD))
                    {
                        a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                        a_ErrorObject.SetSecurityPrivRequired();
                        a_ErrorObject.SetSecurityPrivFailed();
                        a_ErrorObject.SetPrivilegeFailed();
                    }
                    else
                    {
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                    }

                    a_ErrorObject.SetMessage ( L"Failed while enumerating one of the logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Failed while enumerating one of the logfiles.\r\n"
        );
)
                }

                break;
            }

            PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)evtLog.GetBuffer();

            while (bContinue && (dwEventSize != 0))
            {
                CStringW compPath;
                BOOL bGenAssoc = FALSE;

                if (bComp)
                {
                    const wchar_t* src = (const wchar_t*)((UCHAR*)EventBuffer + sizeof(EVENTLOGRECORD));
                    const wchar_t* compName = (const wchar_t*)((UCHAR*)EventBuffer + sizeof(EVENTLOGRECORD))
                                                                        + wcslen(src) + 1;

                    if (compName != NULL)
                    {
                        //get computer for this record
                        compPath = PROP_START_COMP;
                        compPath += compName;
                        compPath += PROP_END_QUOTE;
                        bGenAssoc = TRUE;
                    }
                }
                else
                {
                    if (EventBuffer->UserSidLength > 0)
                    {
						PSID t_Sid = (PSID)((UCHAR*)EventBuffer + EventBuffer->UserSidOffset) ;
						if ( IsValidSid ( t_Sid ) )
						{
							CStringW user = CEventlogRecord::GetUser(
								(PSID)((UCHAR*)EventBuffer + EventBuffer->UserSidOffset));

							if (!user.IsEmpty())
							{
								int index = user.Find(L'\\');

								if (index > 0)
								{
									compPath = PROP_START_USER;
									compPath += user.Left(index++);
									compPath += PROP_MID_USER;
									compPath += user.Right(user.GetLength() - index);
									compPath += PROP_END_QUOTE;
									bGenAssoc = TRUE;
								}
							}
						}
						else
						{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Invalid Sid.\r\n"
        );
)
						}
                    }
                }

                if (bGenAssoc)
                {
                    HRESULT result;

                    if (pathMap.IsEmpty() || !pathMap.Lookup(compPath, result))
                    {
                        IWbemClassObject* pCObj = NULL;
                        IWbemServices *t_Server = m_Provider->GetServer();
						BSTR compPathStr = compPath.AllocSysString();
                        result = t_Server->GetObject(compPathStr, 0, m_Ctx, &pCObj, NULL);
                        SysFreeString(compPathStr);
                        t_Server->Release();
                        pathMap[compPath] = result;

                        if (SUCCEEDED(result))
                        {
                            pCObj->Release();
                        }
                    }

                    if (SUCCEEDED(result))
                    {
                        CStringW recPath(PROP_START_REC);
                        recPath += CStringW(logname);
                        recPath += PROP_MID_REC;
                        wchar_t buff[40];
                        recPath += CStringW(_ultow((ULONG)EventBuffer->RecordNumber, buff, 10));
                        
                        if (!GenerateAssocInstance(a_ErrorObject, recPath, compPath, REF_REC,
                            bComp ? REF_COMP : REF_USER,
                            m_ClassObject, m_NotificationHandler, &bContinue))
                        {
                            retVal = FALSE;
                        }
                    }
                }

                // drop by length of this record and point to next record
                dwEventSize -= EventBuffer->Length;
                EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
            }
        }

        // read next parameter
        iValue++;

    } // end while

    pathMap.RemoveAll();
    RegCloseKey(hkResult);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Returning %lx\r\n",
        retVal
        );
)
    
    return retVal;
}

BOOL ExecQueryAsyncEventObject :: ExecQuery ( WbemProvErrorObject &a_ErrorObject )
{
    BOOL t_Status;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery\r\n"
        );
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    if ( _wcsicmp ( m_QueryFormat, WBEM_QUERY_LANGUAGE_SQL1 ) == 0 )
    {
        CTextLexSource querySource ( m_Query );
        SQL1_Parser sqlParser ( &querySource );

        t_Status = ! sqlParser.Parse ( & m_RPNExpression );

        if ( t_Status )
        {
            t_Status = GetClassObject ( m_RPNExpression->bsClassName );
            
            if ( t_Status )
            {
                t_Status = DispatchQuery ( a_ErrorObject );            
            }
            else
            {
                t_Status = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS );
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS );
                a_ErrorObject.SetMessage ( L"Unknown Class" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:Unknown Class\r\n"
        );
)
            }
        }
        else
        {
            t_Status = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY );
            a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE );
            a_ErrorObject.SetMessage ( L"WQL query was invalid for this provider" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:WQL query was invalid for this provider\r\n"
        );
)
        }
    }
    else
    {
        t_Status = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY_TYPE );
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE );
        a_ErrorObject.SetMessage ( L"Query Language not supported" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:Query Language not supported\r\n"
        );
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:Returning %lx\r\n",
        t_Status
        );
)

    return t_Status;
}

ExecQueryAsyncEventObject :: ExecQueryAsyncEventObject (

    CImpNTEvtProv *a_Provider, 
    BSTR a_QueryFormat, 
    BSTR a_Query, 
    ULONG a_OperationFlag,
    IWbemObjectSink *a_NotificationHandler,
    IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider, a_NotificationHandler, a_OperationFlag, a_Ctx ),
    m_Query ( NULL ),
    m_QueryFormat ( NULL ),
    m_RPNExpression ( NULL ) 
{
    m_Query = UnicodeStringDuplicate ( a_Query );
    m_QueryFormat = UnicodeStringDuplicate ( a_QueryFormat );
}

ExecQueryAsyncEventObject :: ~ExecQueryAsyncEventObject () 
{
// Get Status object

    delete [] m_Query;
    delete [] m_QueryFormat;
    delete m_RPNExpression;

    IWbemClassObject *t_NotifyStatus = NULL;
    BOOL t_Status = TRUE;
    
    if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
    {
        t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus );
    }

    if ( t_Status )
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0, m_ErrorObject.GetWbemStatus (), 0, t_NotifyStatus );
        
        if (t_NotifyStatus)
        {
            t_NotifyStatus->Release ();
        }
    }
    else
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0, m_ErrorObject.GetWbemStatus (), 0, NULL );
    }
}


void ExecQueryAsyncEventObject :: Process () 
{
    ExecQuery ( m_ErrorObject );
}

BOOL ExecQueryAsyncEventObject :: DispatchQuery ( WbemProvErrorObject &a_ErrorObject )
{
    BOOL t_Status;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: DispatchQuery\r\n"
        );
)

    if ( _wcsicmp ( m_RPNExpression->bsClassName, NTEVT_CLASS ) == 0 )
    {
        t_Status = Query_Record ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, NTEVTLOG_CLASS ) == 0 )
    {
        t_Status = Query_EventLog ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, ASSOC_LOGRECORD) == 0 )
    {
        t_Status = Query_LogRecord ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, ASSOC_USERRECORD) == 0 )
    {
        t_Status = Query_UserRecord ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, ASSOC_COMPRECORD) == 0 )
    {
        t_Status = Query_ComputerRecord ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else
    {
        //just complete!
        t_Status = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS );
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS );
        a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not support this class" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: DispatchQuery:Dynamic NT Eventlog Provider does not support this class:%s\r\n",
        m_RPNExpression->bsClassName
        );
)
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: DispatchQuery:Returning %lx\r\n",
        t_Status
        );
)

    return t_Status;
}

BOOL ExecQueryAsyncEventObject :: Query_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
    // open registry for log names
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        // indicate error
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
            a_ErrorObject.SetPrivilegeFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to open the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed to open the Eventlog registry for logfiles - Returning FALSE.\r\n"
        );
)

        return FALSE;
    }

    BOOL retVal = TRUE;
    DWORD iValue = 0;
    WCHAR logname[MAX_PATH+1];
    DWORD lognameSize = MAX_PATH+1;

    // read all entries under this key to find all logfiles...
    while ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS)
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
            // indicate error
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

            if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
            {
                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                a_ErrorObject.SetPrivilegeFailed();
                a_ErrorObject.SetSecurityPrivRequired();
                a_ErrorObject.SetSecurityPrivFailed();
            }
            else
            {
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            }

            a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
            retVal = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed while enumerating the Eventlog registry for logfiles.\r\n"
        );
)
            break;
        }

        //create the instance logfilename
        CEventlogFileAttributes evtlog(logname);
        IWbemClassObject* pInst = NULL;
            
        if (evtlog.GenerateInstance(m_ClassObject, m_AClassObject, &pInst))
        {
            HRESULT t_hr = m_NotificationHandler->Indicate ( 1, & pInst );                               
            pInst->Release();

			if (FAILED(t_hr))
			{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed while indicating instance(s) of %s Eventlog file\r\n",
        logname
        );
)
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
				a_ErrorObject.SetMessage ( L"Failed while indicating instance of logfile." );
				retVal = FALSE;
				break;
			}
        }
        else if (retVal) //only do this once!
        {
            //an error, just log an error, don't report it via the interface
            //it is a bad registry entry which the eventlog service allows
            //so we should let it pass...
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed to create instance(s) of %s Eventlog file\r\n",
        logname
        );
)

        }

        // read next parameter
        iValue++;

    } // end while

    RegCloseKey(hkResult);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}

BOOL ExecQueryAsyncEventObject :: Query_Record ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record\r\n"
        );
)

    BOOL retVal = TRUE;
    //just enumerate all logs and let cimom post filter...
    // open registry for log names
    HKEY hkResult = NULL;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        // indicate error
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetPrivilegeFailed();
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to enumerate the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record:Failed to enumerate the Eventlog registry for logfiles - Return FALSE\r\n"
        );
)
        retVal = FALSE;
    }

	if (retVal)
	{
		//Analyze the query...
		SQL_LEVEL_1_RPN_EXPRESSION *t_RpnExpression = NULL;
		PartitionSet *t_PartitionSet = NULL;
		QueryPreprocessor :: QuadState t_State =  Query (m_Query, t_RpnExpression);

		if ( t_State == QueryPreprocessor :: QuadState :: State_True )
		{
			WmiTreeNode *t_Root = NULL;

			t_State = PreProcess (NULL, t_RpnExpression, t_Root);

			try
			{
				switch ( t_State )
				{
					case QueryPreprocessor :: QuadState :: State_True:
					{

						BSTR t_PropertyContainer [ 4 ];
						memset ( t_PropertyContainer, 0, sizeof ( BSTR ) * 4 );

						try
						{
							t_PropertyContainer [ 0 ] = SysAllocString ( LOGFILE_PROP );
							t_PropertyContainer [ 1 ] = SysAllocString ( RECORD_PROP ); 
							t_PropertyContainer [ 2 ] = SysAllocString ( GENERATED_PROP ); 
							t_PropertyContainer [ 3 ] = SysAllocString ( WRITTEN_PROP );

						
							if ((t_PropertyContainer [ 0 ] == NULL) ||
								(t_PropertyContainer [ 1 ] == NULL) ||
								(t_PropertyContainer [ 2 ] == NULL) ||
								(t_PropertyContainer [ 3 ] == NULL) )
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
							}

							t_State = PreProcess (	

								NULL,
								t_RpnExpression,
								t_Root,
								4, 
								t_PropertyContainer,
								t_PartitionSet
							);
						}
						catch ( ... )
						{
							for (DWORD x = 0; x < 4; x++)
							{
								if ( t_PropertyContainer [ x ] )
								{
									SysFreeString ( t_PropertyContainer [ x ] );
									t_PropertyContainer [ x ] = NULL;
								}
							}

							throw;
						}

						for (DWORD x = 0; x < 4; x++)
						{
							if ( t_PropertyContainer [ x ] )
							{
								SysFreeString ( t_PropertyContainer [ x ] );
								t_PropertyContainer [ x ] = NULL;
							}
						}

						switch ( t_State )
						{
							case QueryPreprocessor :: QuadState :: State_True :	
							{
								/*
								* Full set, enumerate
								*/
								t_PartitionSet = NULL;
							}
							break;

							case QueryPreprocessor :: QuadState :: State_False :
							{
								/*
								* Empty set, no work to do
								*/
								RegCloseKey(hkResult);
								hkResult = NULL;

								return TRUE;
							}
							break;

							case QueryPreprocessor :: QuadState :: State_Undefined :
							{
								//we have should now have a non-null partition set
							}
							break;

							default:
							{
								/*
								* Didn't understand the query send back everything
								*/
								t_PartitionSet = NULL;
							}
							break;
						}

						delete t_Root;
						t_Root = NULL;
					}
					break;
				
					default:
					{
						/*
						* Didn't understand the query send back everything
						*/
						t_PartitionSet = NULL;
					}
					break;
				}

				delete t_RpnExpression;
				t_RpnExpression = NULL;
			}
			catch (...)
			{
				if (t_PartitionSet)
				{
					delete t_PartitionSet;
					t_PartitionSet = NULL;
				}

				if ( t_Root )
				{
					delete t_Root;
					t_Root = NULL;
				}

				if ( t_RpnExpression )
				{
					delete t_RpnExpression;
					t_RpnExpression = NULL;
				}

				if ( hkResult )
				{
					RegCloseKey(hkResult);
					hkResult = NULL;
				}

				throw;
			}
		}
		else
		{
			/*
			* Didn't understand the query send back everything
			*/
			t_PartitionSet = NULL;
		}

		DWORD iValue = 0;
		WCHAR logname[MAX_PATH+1];
		DWORD lognameSize = MAX_PATH+1;
		retVal = FALSE;

		// read all entries under this key to find all logfiles...
		while ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS)
		{
			// if error during read
			if (status != ERROR_SUCCESS)
			{
				// indicate error
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

				if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
				{
					a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
					a_ErrorObject.SetSecurityPrivRequired();
					a_ErrorObject.SetSecurityPrivFailed();
					a_ErrorObject.SetPrivilegeFailed();
				}
				else
				{
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
				}

				a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record:Failed while enumerating the Eventlog registry for logfiles - Return FALSE\r\n"
        );
)
				break;
			}

			if (t_PartitionSet)
			{
				//process this logfile for query
				if (SUCCEEDED (RecurseLogFile (a_ErrorObject, t_PartitionSet, logname)))
				{
					retVal = TRUE;
				}
			}
			else
			{
				//process this logfile
				if ( SUCCEEDED( DoAllInLogfile(a_ErrorObject, logname, 0, 0) ) )
				{
					retVal = TRUE;
				}
				else
				{
					break;
				}
			}

			// read next parameter
			iValue++;

		} // end while

		if (t_PartitionSet)
		{
			delete t_PartitionSet;
		}

		RegCloseKey(hkResult);
	}


DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}

HRESULT ExecQueryAsyncEventObject :: RecurseLogFile (
	WbemProvErrorObject &a_ErrorObject, 
	PartitionSet *a_PartitionSet,
	LPCWSTR a_logname
)
{
	HRESULT t_Result = WBEM_E_FAILED;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount ();

	if (t_PartitionCount == 0)
	{
		t_Result = S_OK;
	}

	for ( DWORD t_Partition = 0; t_Partition < t_PartitionCount; t_Partition++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition );

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange ();

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( _wcsicmp ( t_Node->LowerBound (), t_Node->UpperBound () ) == 0 );

		if (!t_Unique)
		{
			//not naming logfiles therefore do this logfile only if it meets bounds...
			//if even one call succeeds return success
			BOOL t_bProcess = TRUE;

			if (!t_Node->InfiniteLowerBound())
			{
				int t_iCmp = _wcsicmp(a_logname, t_Node->LowerBound());

				if (t_Node->ClosedLowerBound())
				{
					if (t_iCmp < 0)
					{
						t_bProcess = FALSE;				
					}
				}
				else
				{
					if (t_iCmp <= 0)
					{
						t_bProcess = FALSE;				
					}
				}
			}

			if (!t_Node->InfiniteUpperBound())
			{
				int t_iCmp = _wcsicmp(a_logname, t_Node->UpperBound());

				if (t_Node->ClosedUpperBound())
				{
					if (t_iCmp > 0)
					{
						t_bProcess = FALSE;				
					}
				}
				else
				{
					if (t_iCmp >= 0)
					{
						t_bProcess = FALSE;				
					}
				}
			}

			if (t_bProcess)
			{
				if ( SUCCEEDED(RecurseRecord(a_ErrorObject, t_PropertyPartition, a_logname)) && FAILED(t_Result) )
				{
					t_Result = S_OK;
				}

				//we've processed this logfile no need to do anymore...
				break;
			}
		}
		else 
		{
			//are naming logfiles
			if (_wcsicmp(t_Node->LowerBound(), a_logname) == 0)
			{
				//logfile matched let's do records
				if (SUCCEEDED(RecurseRecord(a_ErrorObject, t_PropertyPartition, a_logname)) && FAILED(t_Result) )
				{
					t_Result = S_OK;
				}

				break;
			}
			else
			{
				//not this logfile let's try some other...
				continue;
			}
		}
	}

	return t_Result;
}

HRESULT ExecQueryAsyncEventObject :: RecurseRecord (
	WbemProvErrorObject &a_ErrorObject, 
	PartitionSet *a_PartitionSet,
	LPCWSTR a_logname
)
{
	HRESULT t_Result = S_OK;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount ();

	for ( DWORD t_Partition = 0; t_Partition < t_PartitionCount; t_Partition++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition );
		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = !t_Node->InfiniteLowerBound () && 
						!t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						(t_Node->LowerBound() == t_Node->UpperBound());

		if (!t_Unique)
		{
			if (t_Node->InfiniteLowerBound() && t_Node->InfiniteUpperBound())
			{
				//no limits on record therefore check time generated...
				t_Result = RecurseTime(a_ErrorObject, t_PropertyPartition, a_logname, TRUE);
				
				//there should be only one partition entry for this case but we'll break anyway...
				break;
			}
			else
			{
				DWORD t_dwLower = 0;
				DWORD t_dwUpper = 0xFFFFFFFF;
				BOOL t_bProcess = TRUE;

				if (!t_Node->InfiniteLowerBound())
				{
					if (t_Node->ClosedLowerBound())
					{
						t_dwLower = t_Node->LowerBound();
					}
					else
					{
						if (t_Node->LowerBound() != 0xFFFFFFFF)
						{
							t_dwLower = t_Node->LowerBound() + 1;
						}
						else
						{
							t_bProcess = FALSE; 
						}
					}
				}

				if (!t_Node->InfiniteUpperBound())
				{
					if (t_Node->ClosedUpperBound())
					{
						t_dwUpper = t_Node->UpperBound();
					}
					else
					{
						if (t_Node->UpperBound() != 0)
						{
							t_dwUpper = t_Node->UpperBound() - 1;
						}
						else
						{
							t_bProcess = FALSE; 
						}
					}
				}

				if (t_dwUpper < t_dwLower)
				{
					t_bProcess = FALSE;
				}

				//now return all records including the bounds
				if (t_bProcess)
				{
					CEventLogFile evtLog(a_logname, FALSE);
					
					if (evtLog.IsValid())
					{
						DWORD t_dwEventSize = 0;
						DWORD t_dwErr = evtLog.ReadRecord(t_dwUpper, &t_dwEventSize, TRUE);

						if (0 == t_dwErr)
						{
							DWORD t_dwState = 0;

							while (0 == t_dwState)
							{
								PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)evtLog.GetBuffer();

								while (t_dwEventSize != 0)
								{
									if (EventBuffer->RecordNumber >= t_dwLower)
									{
										CEventlogRecord evtrec(a_logname, EventBuffer, NULL, m_ClassObject, m_AClassObject);
										IWbemClassObject* pInst = NULL;
            
										if (evtrec.GenerateInstance(&pInst))
										{
											t_Result = m_NotificationHandler->Indicate ( 1, & pInst );
											
											//upper limit is decreased with this indicate!
											t_dwUpper--; 
											pInst->Release();

											if (FAILED(t_Result))
											{
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
												a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
												t_dwState = 2;
												break;
											}
										}

										// drop by length of this record and point to next record
										t_dwEventSize -= EventBuffer->Length;
										EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
									}
									else
									{
										t_dwState = 2;
										break;
									}
								}

								if (t_dwState == 0)
								{
									t_dwErr = evtLog.ReadRecord(0, &t_dwEventSize, TRUE);

									if (0 != t_dwErr)
									{
										if (SUCCEEDED(t_Result) && (t_dwErr != ERROR_HANDLE_EOF))
										{
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
											t_Result = WBEM_E_FAILED;

											if ((t_dwErr == ERROR_ACCESS_DENIED) || (t_dwErr == ERROR_PRIVILEGE_NOT_HELD))
											{
												a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
												a_ErrorObject.SetSecurityPrivRequired();
												a_ErrorObject.SetSecurityPrivFailed();
												a_ErrorObject.SetPrivilegeFailed();
											}
											else
											{
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
											}

											a_ErrorObject.SetMessage ( L"Failed while enumerating one of the logfiles." );
										}

										t_dwState = 1;
									}
								}
							}

							if ((t_dwState == 1) && (t_dwErr == ERROR_HANDLE_EOF) && (t_dwUpper > t_dwLower))
							{
								//got all the records til the start of the log see if there are any at the top
								t_Result = DoAllInLogfile(a_ErrorObject, a_logname, t_dwUpper, t_dwLower);

								if (FAILED(t_Result))
								{
									break;
								}
							}
						}
						else
						{
							if (t_dwLower != t_dwUpper)
							{
								//the upper bound does not exist, try from the top down...
								t_Result = DoAllInLogfile(a_ErrorObject, a_logname, t_dwUpper, t_dwLower);

								if (FAILED(t_Result))
								{
									break;
								}

							}
						}
					}
				}
			}
		}
		else 
		{
			//are naming records
			CEventLogFile evtLog(a_logname, FALSE);
        
			if (evtLog.IsValid())
			{
				DWORD err = evtLog.ReadRecord(t_Node->LowerBound());

				if (0 == err)
				{
					EVENTLOGRECORD* EventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
					CEventlogRecord evtRec(a_logname, EventBuffer, NULL, m_ClassObject, m_AClassObject);
					IWbemClassObject* pInst = NULL;
    
					if (evtRec.GenerateInstance(&pInst))
					{
						t_Result = m_NotificationHandler->Indicate ( 1 , & pInst ) ;
						pInst->Release();

						if (FAILED(t_Result))
						{
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
							a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
							break;
						}
					}
					else
					{
						//failed to create record
						t_Result = WBEM_E_FAILED;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to create instance from Eventlog data" ) ;
					}
				}
			}
		}
	}

	return t_Result;
}

HRESULT ExecQueryAsyncEventObject::RecurseTime(WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet,
													LPCWSTR a_logname, BOOL a_Generated)
{
	HRESULT t_Result = S_OK;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount ();

	for ( DWORD t_Partition = 0; t_Partition < t_PartitionCount; t_Partition++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition );

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange ();

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( _wcsicmp ( t_Node->LowerBound (), t_Node->UpperBound () ) == 0 );

		if (!t_Unique)
		{
			if (t_Node->InfiniteLowerBound() && t_Node->InfiniteUpperBound())
			{
				//no limits on record therefore check time written...
				if (a_Generated)
				{
					t_Result = RecurseTime(a_ErrorObject, t_PropertyPartition, a_logname, FALSE);
				}
				else
				{
					//do all in the logfile...
					t_Result = DoAllInLogfile(a_ErrorObject, a_logname, 0, 0);
				}
				
				//there should be only one partition entry for this case but we'll break anyway...
				break;
			}
			else
			{
				//we have bounds (at least one anyway!)
				DWORD t_tmLower = 0;
				DWORD t_tmUpper = 0xFFFFFFFF;
				BOOL t_bProcess = TRUE;

				if (!t_Node->InfiniteLowerBound())
				{
					WBEMTime t_Time(t_Node->LowerBound());
					time_t t_temp = 0;
					
					if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					{
						t_tmLower = (DWORD)t_temp;

						if (!t_Node->ClosedLowerBound())
						{
							if (t_tmLower != 0xFFFFFFFF)
							{
								t_tmLower++;
							}
							else
							{
								t_bProcess = FALSE; 
							}
						}

					}
					else
					{
						DWORD t_len =  wcslen(t_Node->LowerBound());

						if (t_len == NTEVT_DMTFLEN)
						{
							BOOL t_bIsLo = FALSE;
							BOOL t_bIsHi = TRUE;

							if (CheckTime(t_Node->LowerBound(), t_bIsLo, t_bIsHi))
							{
								if (t_bIsHi)
								{
									t_bProcess = FALSE;
								}
							}
							else
							{
								t_bProcess = FALSE;
							}
						}
						else
						{
							t_bProcess = FALSE;
						}
					}
				}

				if (!t_Node->InfiniteUpperBound())
				{
					WBEMTime t_Time(t_Node->UpperBound());
					time_t t_temp = 0;
					
					if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					{
						t_tmUpper = (DWORD)t_temp;

						if (!t_Node->ClosedUpperBound())
						{
							if (t_tmUpper != 0)
							{
								t_tmUpper--;
							}
							else
							{
								t_bProcess = FALSE; 
							}
						}

					}
					else
					{
						DWORD t_len =  wcslen(t_Node->UpperBound());

						if (t_len == NTEVT_DMTFLEN)
						{
							BOOL t_bIsLo = FALSE;
							BOOL t_bIsHi = TRUE;

							if (CheckTime(t_Node->LowerBound(), t_bIsLo, t_bIsHi))
							{
								if (t_bIsLo)
								{
									t_bProcess = FALSE;
								}
							}
							else
							{
								t_bProcess = FALSE;
							}
						}
						else
						{
							t_bProcess = FALSE;
						}
					}
				}

				if (t_tmUpper < t_tmLower)
				{
					t_bProcess = FALSE;
				}

				//now return all records including the bounds
				if (t_bProcess)
				{
					t_Result = GetRecordsBetweenTimes(a_ErrorObject, a_logname, a_Generated, t_tmUpper, t_tmLower);

					if (FAILED(t_Result))
					{
						break;
					}
				}
			}
		}
		else 
		{
			//want records with exactly the right time...
			WBEMTime t_Time(t_Node->LowerBound());
			time_t t_temp = 0;
			
			if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
			{
				t_Result = GetRecordsBetweenTimes(a_ErrorObject, a_logname, a_Generated, (DWORD)t_temp, (DWORD)t_temp);

				if (FAILED(t_Result))
				{
					break;
				}
			}
		}
	}

	return t_Result;
}

HRESULT ExecQueryAsyncEventObject::GetRecordsBetweenTimes(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname,
														  BOOL a_Generated, DWORD a_dwUpper, DWORD a_dwLower)
{
	HRESULT retVal = WBEM_E_FAILED;
	CEventLogFile evtLog(a_logname, FALSE);

	if (evtLog.IsValid())
	{
		DWORD t_NewRec = 0;
		DWORD t_NumRecs = 0;

		if (evtLog.GetLastRecordID(t_NewRec, t_NumRecs))
		{
			retVal = WBEM_S_NO_ERROR;

			while (t_NumRecs > 0)
			{
				DWORD t_RecId = t_NumRecs/2;
				
				if (t_NumRecs%2)
				{
					t_RecId++;
				}

				//adjust for the record number offset
				if (t_RecId > t_NewRec)
				{
					//recordnumber has wrapped around...
					t_RecId = 0xFFFFFFFF - t_RecId + t_NewRec + 1;
				}
				else
				{
					t_RecId = t_NewRec - t_RecId + 1;
				}

				DWORD t_dwEventSize = 0;
				DWORD t_dwErr = evtLog.ReadRecord(t_RecId, &t_dwEventSize, TRUE);

				if (0 == t_dwErr)
				{
					EVENTLOGRECORD* t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
					DWORD t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;

					if (a_dwUpper >= t_Time)
					{
						if (a_dwLower <= t_Time)
						{
							//generate all above and below this that match...
							t_NumRecs = 0;
							
							//below...
							while((a_dwUpper >= t_Time) && (a_dwLower <= t_Time) && (t_dwEventSize != 0))
							{
								CEventlogRecord evtrec(a_logname, t_pEventBuffer, NULL, m_ClassObject, m_AClassObject);
								IWbemClassObject* pInst = NULL;
            
								if (evtrec.GenerateInstance(&pInst))
								{
									retVal = m_NotificationHandler->Indicate ( 1, & pInst );
									pInst->Release();

									if (FAILED(retVal))
									{
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
										a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
										break;
									}
								}

								// drop by length of this record and point to next record
								t_dwEventSize -= t_pEventBuffer->Length;

								if (t_dwEventSize == 0)
								{
									t_dwErr = evtLog.ReadRecord(0, &t_dwEventSize, TRUE);

									if (t_dwErr == ERROR_SUCCESS)
									{
										t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
									}
								}
								else
								{
									t_pEventBuffer = (PEVENTLOGRECORD) ((UCHAR*) t_pEventBuffer + t_pEventBuffer->Length);
								}

								t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;
							}

							if (SUCCEEDED(retVal))
							{
								//above...
								evtLog.ReadRecord(t_RecId, &t_dwEventSize, FALSE);
								
								//skip the record we've done already...
								t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
								t_dwEventSize -= t_pEventBuffer->Length;

								if (t_dwEventSize != 0)
								{
									t_pEventBuffer = (PEVENTLOGRECORD) ((UCHAR*) t_pEventBuffer + t_pEventBuffer->Length);
									t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;

									while((a_dwUpper >= t_Time) && (a_dwLower <= t_Time) && (t_dwEventSize != 0))
									{
										CEventlogRecord evtrec(a_logname, t_pEventBuffer, NULL, m_ClassObject, m_AClassObject);
										IWbemClassObject* pInst = NULL;
            
										if (evtrec.GenerateInstance(&pInst))
										{
											retVal = m_NotificationHandler->Indicate ( 1, & pInst );
											pInst->Release();

											if (FAILED(retVal))
											{
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
												a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
												break;
											}

										}

										// drop by length of this record and point to next record
										t_dwEventSize -= t_pEventBuffer->Length;

										if (t_dwEventSize == 0)
										{
											t_dwErr = evtLog.ReadRecord(0, &t_dwEventSize, FALSE);

											if (t_dwErr == ERROR_SUCCESS)
											{
												t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
											}
										}
										else
										{
											t_pEventBuffer = (PEVENTLOGRECORD) ((UCHAR*) t_pEventBuffer + t_pEventBuffer->Length);
										}

										t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;
									}
								}
							}
						}
						else
						{
							//too old, go higher done automatically by halving t_NumRecs
							if (t_NumRecs > 1)
							{
								if ((t_NumRecs%2) || (t_NumRecs == 2))
								{
									t_NumRecs = t_NumRecs/2;
								}
								else
								{
									t_NumRecs = t_NumRecs/2 - 1;
								}
							}
							else
							{
								t_NumRecs = 0;
							}
						}
					}
					else
					{
						//too recent, setup the number of records left and go lower by 
						//setting the upper limit to one less than we've checked... 
						if (t_NumRecs > 1)
						{
							t_NumRecs = t_NumRecs/2;

							if (t_RecId == 1)
							{
								//we've wrapped...
								t_NewRec = 0xFFFFFFFF;
							}
							else
							{
								t_NewRec = t_RecId - 1;
							}
						}
						else
						{
							t_NumRecs = 0;
						}
					}

				}
				else
				{
					t_NumRecs = 0;

					if (t_dwErr != ERROR_HANDLE_EOF)
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

						if ((t_dwErr == ERROR_ACCESS_DENIED) || (t_dwErr == ERROR_PRIVILEGE_NOT_HELD))
						{
							a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
							a_ErrorObject.SetSecurityPrivRequired();
							a_ErrorObject.SetSecurityPrivFailed();
							a_ErrorObject.SetPrivilegeFailed();
						}
						else
						{
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
						}

						a_ErrorObject.SetMessage ( L"Failed while searching one of the logfiles." );
					}

					break;
				}
			}
		}
	}

	return retVal;
}

HRESULT ExecQueryAsyncEventObject::DoAllInLogfile(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname, DWORD a_dwUpper, DWORD a_dwLower)
{
    //process this logfile
	HRESULT retVal = S_OK;
    CEventLogFile evtLog(a_logname, FALSE);
	BOOL bContinue = TRUE;
    
    if (evtLog.IsValid())
    {
        evtLog.ReadLastRecord();
    }

    while (evtLog.IsValid() && SUCCEEDED(retVal) && bContinue)
    {
        DWORD dwEventSize = 0;
        DWORD err = evtLog.ReadRecord(0, &dwEventSize, TRUE);

        if (0 != err)
        {
            if (err != ERROR_HANDLE_EOF)
            {
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                if ((err == ERROR_ACCESS_DENIED) || (err == ERROR_PRIVILEGE_NOT_HELD))
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                    a_ErrorObject.SetSecurityPrivRequired();
                    a_ErrorObject.SetSecurityPrivFailed();
                    a_ErrorObject.SetPrivilegeFailed();
                }
                else
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                }

                a_ErrorObject.SetMessage ( L"Failed while enumerating one of the logfiles." );
DebugOut( 
CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

    _T(__FILE__),__LINE__,
    L"ExecQueryAsyncEventObject :: Query_Record:Failed while enumerating one of the logfiles.\r\n"
    );
)
            }

            break;
        }

        PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)evtLog.GetBuffer();

		if (a_dwUpper != a_dwLower)
		{
			if ((EventBuffer->RecordNumber > a_dwUpper) || (EventBuffer->RecordNumber < a_dwLower))
			{
				break;
			}
		}

        while (dwEventSize != 0)
        {
			if (a_dwUpper != a_dwLower)
			{
				if ((EventBuffer->RecordNumber > a_dwUpper) || (EventBuffer->RecordNumber < a_dwLower))
				{
					bContinue = FALSE;
					break;
				}
			}

            CEventlogRecord evtrec(a_logname, EventBuffer, NULL, m_ClassObject, m_AClassObject);
            IWbemClassObject* pInst = NULL;
            
            if (evtrec.GenerateInstance(&pInst))
            {
                retVal = m_NotificationHandler->Indicate ( 1, & pInst );
                pInst->Release();

				if (FAILED(retVal))
				{
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
					a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
				}
            }

            // drop by length of this record and point to next record
            dwEventSize -= EventBuffer->Length;
            EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
        }
    }

	return retVal;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: Compare ( 

	LONG a_Operand1, 
	LONG a_Operand2, 
	ULONG a_Operand1Func,
	ULONG a_Operand2Func,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		default:
		{
		}
		break;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		default:
		{
		}
		break;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: Compare ( 

	wchar_t *a_Operand1, 
	wchar_t *a_Operand2, 
	ULONG a_Operand1Func,
	ULONG a_Operand2Func,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	wchar_t *a_Operand1AfterFunc = NULL;
	wchar_t *a_Operand2AfterFunc = NULL; 

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand1 );
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towupper ( a_Operand1 [ index ] );
			}
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand1 );
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towlower ( a_Operand1 [ index ] );
			}
		}
		break;

		default:
		{
		}
		break;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand2 );
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towupper ( a_Operand2 [ index ] );
			}
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand2 );
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towlower ( a_Operand2 [ index ] );
			}
		}
		break;

		default:
		{
		}
		break;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc;
	delete [] a_Operand2AfterFunc;

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: CompareDateTime ( 

	IWbemClassObject *a_ClassObject,
	BSTR a_PropertyName, 
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
/*
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 */
	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand;

	if ( t_StringNode == NULL || t_StringNode->GetValue() == NULL)
	{
		return QueryPreprocessor :: QuadState :: State_False;
	}

	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;
	WBEMTime t_Time((const BSTR)t_StringNode->GetValue());

	if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
	{
		time_t t_temp = 0;
		t_Status = (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					? QueryPreprocessor :: QuadState :: State_Undefined
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		time_t t_temp = 0;
		t_Status = (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					? QueryPreprocessor :: QuadState :: State_Undefined
					: QueryPreprocessor :: QuadState :: State_True;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		//to do: check t_time >= val this will always be true if t_time >= max time_t
		//will always be false if t_time is < 1970.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		//to do: check t_time <= val this will always be true if t_time <= 1970
		//will always be false if t_time is > max time_t.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
	{
		//to do: check t_time < val this will always be true if t_time < 1970
		//will always be false if t_time is > max time_t.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
	{
		//to do: check t_time > val this will always be true if t_time > max time_t
		//will always be false if t_time is < 1970.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: CompareString ( 

	IWbemClassObject *a_ClassObject,
	BSTR a_PropertyName, 
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand; 

	VARIANT t_Variant;
	VariantInit ( & t_Variant );

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName, 0, &t_Variant, NULL, NULL );
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_StringNode->GetValue (),
			t_Variant.bstrVal,
			t_StringNode->GetPropertyFunction (),
			t_StringNode->GetConstantFunction (),
			*a_Operator 
		);
	}

	VariantClear ( & t_Variant );

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: CompareInteger ( 

	IWbemClassObject *a_ClassObject,
	BSTR a_PropertyName, 
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand; 

	VARIANT t_Variant;
	VariantInit ( & t_Variant );

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName, 0, &t_Variant, NULL, NULL );
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_IntegerNode->GetValue (),
			t_Variant.lVal,
			t_IntegerNode->GetPropertyFunction (),
			t_IntegerNode->GetConstantFunction (),
			*a_Operator 
		);
	}

	VariantClear ( & t_Variant );

	return t_Status;
}

WmiTreeNode *ExecQueryAsyncEventObject :: AllocTypeNode ( 

	void *a_Context,
	BSTR a_PropertyName, 
	VARIANT &a_Variant, 
	WmiValueNode :: WmiValueFunction a_PropertyFunction,
	WmiValueNode :: WmiValueFunction a_ConstantFunction,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL;

	VARTYPE t_VarType = VT_NULL;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_CLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_SUPERCLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_GENUS ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName, 
				a_Variant.lVal, 
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_SERVER ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_NAMESPACE ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName, 
				a_Variant.lVal, 
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_DYNASTY ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_RELPATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_PATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		CIMTYPE t_VarType;
		long t_Flavour;
		VARIANT t_Variant;
		VariantInit ( & t_Variant );

		HRESULT t_Result = m_ClassObject->Get (

			a_PropertyName,
			0,
			& t_Variant,
			& t_VarType,
			& t_Flavour
		);

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_VarType & CIM_FLAG_ARRAY )
			{
			}
			else
			{
				switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
				{
					case CIM_BOOLEAN:
					{
						if(V_VT(&a_Variant) == VT_I4)
                        {
                            t_Node = new WmiSignedIntegerNode ( 

								a_PropertyName, 
								a_Variant.lVal, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
						else if (V_VT(&a_Variant) == VT_BOOL)
						{
                            t_Node = new WmiSignedIntegerNode ( 

								a_PropertyName, 
								(a_Variant.lVal == VARIANT_FALSE) ? 0 : 1, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
						}
					}
					break;

					case CIM_SINT8:
					case CIM_SINT16:
					case CIM_CHAR16:
					case CIM_SINT32:
					{
						if(V_VT(&a_Variant) == VT_I4)
                        {
                            t_Node = new WmiSignedIntegerNode ( 

								a_PropertyName, 
								a_Variant.lVal, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
					}
					break;

					case CIM_UINT8:
					case CIM_UINT16:
					case CIM_UINT32:
					{
						if(V_VT(&a_Variant) == VT_I4)
                        {
                            t_Node = new WmiUnsignedIntegerNode ( 

								a_PropertyName, 
								a_Variant.lVal, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
					}
					break;

					case CIM_SINT64:
					case CIM_UINT64:
					{
						if(V_VT(&a_Variant) == VT_BSTR)
                        {
                            t_Node = new WmiStringNode ( 

								a_PropertyName, 
								a_Variant.bstrVal, 
								a_PropertyFunction,
								a_ConstantFunction,
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
						else if(V_VT(&a_Variant) == VT_I4)
						{
							_variant_t t_uintBuff (&a_Variant);

                            t_Node = new WmiStringNode ( 

								a_PropertyName, 
								(BSTR)((_bstr_t) t_uintBuff), 
								a_PropertyFunction,
								a_ConstantFunction,
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
						}
					}
					break;

					case CIM_STRING:
					case CIM_DATETIME:
					case CIM_REFERENCE:
					{
						if(V_VT(&a_Variant) == VT_BSTR)
                        {
                            t_Node = new WmiStringNode ( 

								a_PropertyName, 
								a_Variant.bstrVal, 
								a_PropertyFunction,
								a_ConstantFunction,
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
					}
					break;

					case CIM_REAL32:
					case CIM_REAL64:
					{
					}
					break;

					case CIM_OBJECT:
					case CIM_EMPTY:
					{
					}
					break;

					default:
					{
					}
					break;
				}
			}
		}

		VariantClear ( & t_Variant );
	}

	return t_Node;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: InvariantEvaluate ( 

	void *a_Context,
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Error;

	WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand;
	BSTR t_PropertyName = t_Node->GetPropertyName ();

	if ( t_PropertyName != NULL )
	{
		if ( *t_PropertyName == L'_' )
		{
			// System property, must check values

			if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_CLASS ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_CLASS,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_SUPERCLASS,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_GENUS ) == 0 )
			{
				t_State = CompareInteger ( 

					m_ClassObject,
					SYSTEM_PROPERTY_GENUS,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_SERVER ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_SERVER,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_NAMESPACE ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_NAMESPACE,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
			{
				t_State = CompareInteger ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PROPERTY_COUNT,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_DYNASTY ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_DYNASTY,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_RELPATH ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_RELPATH,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_PATH ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PATH,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_DERIVATION ) == 0 )
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined;
			}
			else
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined;
			}
		}
		else
		{
			//if it is time generated or time written check the max and min are ok
			if ( _wcsicmp ( t_PropertyName, GENERATED_PROP ) == 0 )
			{
				t_State = CompareDateTime ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PATH,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, WRITTEN_PROP ) == 0 )
			{
				t_State = CompareDateTime ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PATH,
					a_Operator,
					a_Operand
				);
			}
			else
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined;
			}
		}
	}
	else
	{
		t_State = QueryPreprocessor :: QuadState :: State_Undefined;
	}

	return t_State;
}

WmiRangeNode *ExecQueryAsyncEventObject :: AllocInfiniteRangeNode (

	void *a_Context,
	BSTR a_PropertyName 
)
{
	WmiRangeNode *t_RangeNode = NULL;

	CIMTYPE t_VarType;
	long t_Flavour;
	VARIANT t_Variant;
	VariantInit ( & t_Variant );

	HRESULT t_Result = m_ClassObject->Get (

		a_PropertyName,
		0,
		& t_Variant,
		& t_VarType,
		& t_Flavour
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_VarType & CIM_FLAG_ARRAY )
		{
		}
		else
		{
			switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
			{
				case CIM_BOOLEAN:
				case CIM_SINT8:
				case CIM_SINT16:
				case CIM_CHAR16:
				case CIM_SINT32:
				{
					t_RangeNode = new WmiSignedIntegerRangeNode ( 

						a_PropertyName, 
						0xFFFFFFFF, 
						TRUE,
						TRUE,
						FALSE,
						FALSE,
						0,
						0,
						NULL, 
						NULL 
					);
				}
				break;

				case CIM_UINT8:
				case CIM_UINT16:
				case CIM_UINT32:
				{
					t_RangeNode = new WmiUnsignedIntegerRangeNode ( 

						a_PropertyName, 
						0xFFFFFFFF, 
						TRUE,
						TRUE,
						FALSE,
						FALSE,
						0,
						0,
						NULL, 
						NULL 
					);
				}
				break;

				case CIM_SINT64:
				case CIM_UINT64:
				case CIM_STRING:
				case CIM_DATETIME:
				case CIM_REFERENCE:
				{
					t_RangeNode = new WmiStringRangeNode ( 

						a_PropertyName, 
						0x0, 
						TRUE,
						TRUE,
						FALSE,
						FALSE,
						NULL,
						NULL,
						NULL, 
						NULL 
					);
				}
				break;

				case CIM_REAL32:
				case CIM_REAL64:
				{
				}
				break;

				case CIM_OBJECT:
				case CIM_EMPTY:
				{
				}
				break;

				default:
				{
				}
				break;
			}
		}

	}

	VariantClear ( & t_Variant );

	return t_RangeNode;
}

ULONG ExecQueryAsyncEventObject :: GetPriority ( BSTR a_PropertyName )
{
	if ( _wcsicmp ( a_PropertyName, LOGFILE_PROP ) == 0 )
	{
		return 0;
	}

	if ( _wcsicmp ( a_PropertyName, RECORD_PROP ) == 0 )
	{
		return 1;
	}

	if ( _wcsicmp ( a_PropertyName, GENERATED_PROP ) == 0 )
	{
		return 2;
	}

	if ( _wcsicmp ( a_PropertyName, WRITTEN_PROP ) == 0 )
	{
		return 3;
	}

	return 0xFFFFFFFF;
}

BOOL ExecQueryAsyncEventObject::CheckTime( const BSTR a_wszText, BOOL &a_IsLow, BOOL &a_IsHigh )
{
	a_IsLow = FALSE;
	a_IsHigh = FALSE;

	if (a_wszText == NULL)
	{
		return FALSE;
	}

    wchar_t t_DefaultBuffer[] = {L"16010101000000.000000+000"} ;
    wchar_t t_DateBuffer[ NTEVT_DMTFLEN + 1 ] ;
            t_DateBuffer[ NTEVT_DMTFLEN ] = NULL ;

    // wildcard cleanup and validation
    // ===============================

    if( NTEVT_DMTFLEN != wcslen(a_wszText) )
    {
        return FALSE ;  
    }
    
    const wchar_t *t_pwBuffer = (const wchar_t*)a_wszText ;
    
    for( int t_i = 0; t_i < NTEVT_DMTFLEN; t_i++ )
    {
        switch( a_wszText[ t_i ] )
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                // stepping on separator or sign
                if( NTEVT_DECPOS == t_i || NTEVT_SGNPOS == t_i )
                {
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = a_wszText[ t_i ] ;
                
                break ;
            }           
            case '*':
            {               
                // stepping on separator or sign
                if( NTEVT_DECPOS == t_i || NTEVT_SGNPOS == t_i )
                {
                    return FALSE ;  
                }
                else
                {
                    // replace with default stamp
                    t_DateBuffer[ t_i ] = t_DefaultBuffer[ t_i ] ; 
                }   
                break ;
            }           
            case '.':
            {
                if( NTEVT_DECPOS != t_i )
                {
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = a_wszText[ t_i ] ;

                break ;
            }           
            case '+':
            case '-':
            {
                if( NTEVT_SGNPOS != t_i )
                {
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = a_wszText[ t_i ] ;
                break ;
            }           
            default:
            {
                return FALSE ;
            }           
        }
    }

    // Parse it
    // ========

    int nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf (

        (LPCWSTR)&t_DateBuffer, 
        L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
        &nYear, 
        &nMonth, 
        &nDay, 
        &nHour, 
        &nMinute, 
        &nSecond, 
        &nMicro, 
        &wchSep, 
        &nOffset
    );

    if ( ( 9 != nRes ) )    
    {
        return FALSE;
    }

	if (nYear < 1970)
	{
		a_IsLow = TRUE;
		return TRUE;
	}

	BOOL retVal = FALSE;
	WBEMTime t_max ((time_t)0xFFFFFFFF);
	BSTR t_temp = t_max.GetBSTR();

	if (t_temp)
	{
		if (_wcsicmp(a_wszText, t_temp) >= 0)
		{
			a_IsHigh = TRUE;
			retVal = TRUE;
		}

		SysFreeString(t_temp);
	}

	// if we got here, the earlier WBEMTIME should have been OK so return FALSE.
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtthrd.cpp ===
//***************************************************************************

//

//  NTEVTTHRD.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the thread which listens for events and processes

//              them.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include <winperf.h>
#include <time.h>
#include <wbemtime.h>

#define NUM_THREADS 1
const DWORD CEventLogMonitor::m_PollTimeOut = 60000;    // 10 minute poll period
extern CCriticalSection g_ProvLock;

CEventProviderManager::CEventProviderManager() : m_IsFirstSinceLogon (FALSE), m_monitorArray (NULL)
{
    ProvThreadObject::Startup();
}

CEventProviderManager::~CEventProviderManager()
{
    ProvThreadObject::Closedown();
}

BOOL CEventProviderManager::Register(CNTEventProvider* prov)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::Register\r\n");
)

    BOOL retVal = FALSE;
    BOOL bUnReg = FALSE;

    {
        ScopeLock<CCriticalSection> sl(m_MonitorLock);
        {
            ScopeLock<CCriticalSection> sl(m_ControlObjects.m_Lock);
            prov->AddRefAll();
            m_ControlObjects.SetAt((UINT_PTR)prov, prov);
        }
        
        bUnReg = TRUE;

        if (NULL == m_monitorArray)
        {
            InitialiseMonitorArray();
        }
    
        if (NULL != m_monitorArray)
        {
            for (int x=0; x < NUM_THREADS; x++)
            {
                if ( m_monitorArray[x]->IsMonitoring() )
                {
                    //at least one monitor is working
                    retVal = TRUE;

DebugOut( 
CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

    _T(__FILE__),__LINE__,
    L"CEventProviderManager::Register:Successfully monitoring monitor %lx : \r\n" ,
    x
) ;
)

                    break;
                }
                else
                {
DebugOut( 
CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

    _T(__FILE__),__LINE__,
    L"CEventProviderManager::Register:Not monitoring monitor %lx : \r\n" ,
    x
) ;
)

                }
            }
        }
    }

    if ((!retVal) && (bUnReg))
    {
        UnRegister(prov);
    }
    
    return retVal;
}

void CEventProviderManager::UnRegister(CNTEventProvider* prov)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::UnRegister\r\n");
)

    BOOL bDestroyMonitorArray = FALSE;

    {
        ScopeLock<CCriticalSection> sl(m_MonitorLock);
        {
	    {
                ScopeLock<CCriticalSection> sl(m_ControlObjects.m_Lock);
                if (m_ControlObjects.RemoveKey((UINT_PTR)prov))
                {
                    prov->ReleaseAll();
                
                    if (m_ControlObjects.IsEmpty() && (NULL != m_monitorArray))
                    {
                        bDestroyMonitorArray = TRUE;
                    }
                }
	    }

            if (bDestroyMonitorArray)
            {
                DestroyMonitorArray();
                m_monitorArray = NULL;
            }   
        }
    }
}

IWbemServices* CEventProviderManager::GetNamespacePtr()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::GetNamespacePtr\r\n");
)

    IWbemServices* retVal = NULL;
    {
        ScopeLock<CCriticalSection> sl(m_ControlObjects.m_Lock);
        POSITION pos = m_ControlObjects.GetStartPosition();

        if (pos)
        {
            CNTEventProvider* pCntrl;
            UINT_PTR key;
            m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
            retVal = pCntrl->GetNamespace();
        }
    }

    return retVal;
}

void CEventProviderManager::SendEvent(IWbemClassObject* evtObj)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::SendEvent\r\n");
)

    if (evtObj == NULL) 
    {
        return;
    }

    //copy the list of control objects to minimize amount of work
    //done in locked section of code. also cannot call into webm
    //in blocked code may cause deadlock if webnm calls back.
    CList<CNTEventProvider*, CNTEventProvider*> controlObjects;


    {
        ScopeLock<CCriticalSection> sl(m_ControlObjects.m_Lock);
        POSITION pos = m_ControlObjects.GetStartPosition();

        while (NULL != pos)
        {
            CNTEventProvider* pCntrl;
            UINT_PTR key;
            m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
            pCntrl->AddRefAll();
            controlObjects.AddTail(pCntrl);
        }
    }

    //loop through the different control objects and send the event to each
    while (!controlObjects.IsEmpty())
    {
        CNTEventProvider* pCntrl = controlObjects.RemoveTail();
        IWbemServices* ns = pCntrl->GetNamespace();
        IWbemObjectSink* es = pCntrl->GetEventSink();
        es->Indicate(1, &evtObj);
        es->Release();
        ns->Release();
        pCntrl->ReleaseAll();
    }
}

BOOL CEventProviderManager::InitialiseMonitorArray()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::InitialiseMonitorArray\r\n");
)

    // open registry for log names
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        DWORD t_LastError = GetLastError () ;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::InitialiseMonitorArray:Failed to open registry key %s , %lx: \r\n" ,
        EVENTLOG_BASE ,
        status
    ) ;
)

        // indicate error
        return FALSE;
    }

    DWORD iValue = 0;
    WCHAR logname[MAX_PATH+1];
    DWORD lognameSize = MAX_PATH+1;
    CArray<CStringW*, CStringW*> logfiles;

    //usually three logfiles, grow in 10s!
    logfiles.SetSize(3, 10); 

    // read all entries under this key to find all logfiles...
    while ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS)
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
            RegCloseKey(hkResult);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::InitialiseMonitorArray:Failed to enumerate registry subkeys %s : \r\n" ,
        EVENTLOG_BASE
    ) ;
)
            // indicate error
            return FALSE;
        }

        //store the logfilename
        CStringW* logfile = new CStringW(logname);
        logfiles.SetAtGrow(iValue, logfile);
        
        // read next parameter
        iValue++;

    } // end while

    RegCloseKey(hkResult);
    m_monitorArray = new CEventLogMonitor*[NUM_THREADS];
	memset(m_monitorArray, 0, NUM_THREADS * sizeof(CEventLogMonitor*));

    //use the array
#if NUM_THREADS > 1
//multi-threaded monitor
    
    //TO DO: Partition the eventlogs to the monitors
    //and start each monitor

#else
//single threaded monitor
	try
	{
		m_monitorArray[0] = new CEventLogMonitor(this, logfiles);
		m_monitorArray[0]->AddRef();
		(*m_monitorArray)->BeginThread();
		(*m_monitorArray)->WaitForStartup();
		(*m_monitorArray)->StartMonitoring();
	}
	catch (...)
	{
		if (m_monitorArray[0])
		{
			m_monitorArray[0]->Release();
		}

		delete [] m_monitorArray;
		m_monitorArray = NULL;
		throw;
	}
#endif

    //delete array contents AFTER threads startup!
    LONG count = logfiles.GetSize();

    if (count > 0)
    {
        for (LONG x = 0; x < count; x++)
        {
            delete logfiles[x];
        }
        
        logfiles.RemoveAll();
    }

    return TRUE;
}

void CEventProviderManager::DestroyMonitorArray()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::DestroyMonitorArray\r\n");
)

    if (NULL != m_monitorArray)
    {
        for (int x=0; x < NUM_THREADS; x++)
        {
			m_monitorArray[x]->PostSignalThreadShutdown();
			m_monitorArray[x]->Release();
			m_monitorArray[x] = NULL;
        }
        
        delete [] m_monitorArray;
        m_monitorArray = NULL;
    }
}

BSTR CEventProviderManager::GetLastBootTime()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::GetLastBootTime\r\n");
)
    if (!m_BootTimeString.IsEmpty())
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::GetLastBootTime returning %s\r\n",
        m_BootTimeString
        );
)

        return m_BootTimeString.AllocSysString();
    }

    HKEY hKeyPerflib009;
    BSTR retStr = NULL;
	
	SYSTEM_TIMEOFDAY_INFORMATION t_TODInformation;

	if ( NT_SUCCESS(NtQuerySystemInformation(SystemTimeOfDayInformation,
								&t_TODInformation,
								sizeof(t_TODInformation),
								NULL)) )
	{
		FILETIME t_ft;
		memcpy(&t_ft, &t_TODInformation.BootTime, sizeof(t_TODInformation.BootTime));
		WBEMTime wbemboottime(t_ft);
		retStr = wbemboottime.GetDMTF(TRUE);
		m_BootTimeString = (LPCWSTR)(retStr);
	}

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"Returning from CEventProviderManager::GetLastBootTime with %s",
        (retStr == NULL ? L"NULL": retStr)
        ) ;
)

    return retStr;
}

void CEventProviderManager :: SetFirstSinceLogon(IWbemServices* ns, IWbemContext *pCtx)
{
    BSTR boottmStr = GetLastBootTime();

    if (boottmStr == NULL)
    {
        return;
    }

    IWbemClassObject* pObj = NULL; 
	HRESULT hr = WBEM_E_OUT_OF_MEMORY ;

	BSTR bstrPath = SysAllocString (CONFIG_INSTANCE);
	if ( bstrPath )
	{
		hr = ns->GetObject(bstrPath, 0, pCtx, &pObj, NULL);
		SysFreeString(bstrPath);
	}

    if ( hr == WBEM_E_NOT_FOUND )
    {
		hr = WBEM_E_OUT_OF_MEMORY ;

		bstrPath = SysAllocString (CONFIG_CLASS);
		if ( bstrPath )
		{
			hr = ns->GetObject(bstrPath, 0, pCtx, &pObj, NULL);
			SysFreeString(bstrPath);
		}

        if (FAILED(hr))
        {
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->Write (  

                L"\r\n"
            ) ;

            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"CEventProviderManager :: IsFirstSinceLogon: Failed to get config class" 
            ) ;
) 
        }
        else
        {
            IWbemClassObject* pInst = NULL;
            hr = pObj->SpawnInstance(0, &pInst);
            pObj->Release();

            if (FAILED(hr))
            {
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->Write (  

                L"\r\n"
            ) ;

            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"CEventProviderManager :: IsFirstSinceLogon: Failed to spawn config instance" 
            ) ;
) 
            }
            else
            {
                VARIANT v;
                VariantInit(&v);

				hr = WBEM_E_OUT_OF_MEMORY ;

                v.bstrVal = SysAllocString(boottmStr);;
				if ( v.bstrVal )
				{
					v.vt = VT_BSTR;
					hr = pInst->Put(LAST_BOOT_PROP, 0, &v, 0);
				}

                VariantClear(&v);

                if (FAILED(hr))
                {
DebugOut( 
                    CNTEventProvider::g_NTEvtDebugLog->Write (  

                        L"\r\n"
                    ) ;

                    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                        _T(__FILE__),__LINE__,
                        L"CEventProviderManager :: IsFirstSinceLogon: Failed to put config property" 
                    ) ;
) 

                }
                else
                {
                    hr = ns->PutInstance(pInst, WBEM_FLAG_CREATE_ONLY, pCtx, NULL);

                    if (FAILED(hr))
                    {
DebugOut( 
                        CNTEventProvider::g_NTEvtDebugLog->Write (  

                            L"\r\n"
                        ) ;

                        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                            _T(__FILE__),__LINE__,
                            L"CEventProviderManager :: IsFirstSinceLogon: Failed to put new config instance" 
                        ) ;
) 
                    }
                    else
                    {
                        m_IsFirstSinceLogon = TRUE;
                    }

                }

                pInst->Release();
            }
        }
    }
    else
    {
        VARIANT v;
        hr = pObj->Get(LAST_BOOT_PROP, 0, &v, NULL, NULL);

        if (FAILED(hr))
        {
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->Write (  

                L"\r\n"
            ) ;

            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"CEventProviderManager :: IsFirstSinceLogon: Failed to get config's last boot time from instance" 
            ) ;
) 
        }
        else
        {
            if (v.vt == VT_BSTR)
            {
                if (wcscmp(v.bstrVal, boottmStr) == 0)
                {
                }
                else
                {
                    VariantClear(&v);
                    VariantInit(&v);

					hr = WBEM_E_OUT_OF_MEMORY ;

                    v.bstrVal = SysAllocString(boottmStr);
					if ( v.bstrVal )
					{
						v.vt = VT_BSTR;
	                    hr = pObj->Put(LAST_BOOT_PROP, 0, &v, 0);
					}

					VariantClear (&v) ;

                    if (FAILED(hr))
                    {
DebugOut( 
                        CNTEventProvider::g_NTEvtDebugLog->Write (  

                            L"\r\n"
                        ) ;

                        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                            _T(__FILE__),__LINE__,
                            L"CEventProviderManager :: IsFirstSinceLogon: Failed to put config property in instance" 
                        ) ;
) 

                    }
                    else
                    {
                        hr = ns->PutInstance(pObj, WBEM_FLAG_UPDATE_ONLY, pCtx, NULL);

                        if (FAILED(hr))
                        {
DebugOut( 
                            CNTEventProvider::g_NTEvtDebugLog->Write (  

                                L"\r\n"
                            ) ;

                            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                                _T(__FILE__),__LINE__,
                                L"CEventProviderManager :: IsFirstSinceLogon: Failed to put config instance" 
                            ) ;
) 
                        }
                        else
                        {
                            m_IsFirstSinceLogon = TRUE;
                        }
                    }
                }
            }
            else
            {
DebugOut( 
                CNTEventProvider::g_NTEvtDebugLog->Write (  

                    L"\r\n"
                ) ;

                CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                    _T(__FILE__),__LINE__,
                    L"CEventProviderManager :: IsFirstSinceLogon: one (maybe both) boot times are of wrong type" 
                ) ;
) 
            }
            
            VariantClear(&v);
        }
        
        pObj->Release();
    }

    SysFreeString(boottmStr);
}


CEventLogMonitor::CEventLogMonitor(CEventProviderManager* parentptr, CArray<CStringW*, CStringW*>& logs)
: ProvThreadObject(EVENTTHREADNAME, m_PollTimeOut), m_LogCount(logs.GetSize()), m_Logs(NULL),
m_bMonitoring(FALSE), m_pParent(parentptr), m_Ref(0)
{
	InterlockedIncrement(&(CNTEventProviderClassFactory::objectsInProgress));

	// create array from argument
    if (m_LogCount > 0)
    {
		//usually three logfiles, grow in 10s!
		m_LogNames.SetSize(3, 10); 

        for (LONG x = 0; x < m_LogCount; x++)
        {
			CStringW* logfile = new CStringW( * logs.GetAt ( x ) );
            m_LogNames.SetAtGrow(x, logfile);
		}
	}
}

CEventLogMonitor::~CEventLogMonitor()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::~CEventLogMonitor\r\n");
)

	InterlockedDecrement(&(CNTEventProviderClassFactory::objectsInProgress));

    //delete array contents
	LONG count = m_LogNames.GetSize();

    if (count > 0)
    {
        for (LONG x = 0; x < count; x++)
        {
            delete m_LogNames[x];
        }
        
        m_LogNames.RemoveAll();
    }
}

void CEventLogMonitor::Poll()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::Poll\r\n");
)

    if (m_Logs != NULL)
    {
        for (ULONG x = 0; x < m_LogCount; x++)
        {
            if (m_Logs[x]->IsValid())
            {
                m_Logs[x]->Process();
            }
        }
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"leaving CEventLogMonitor::Poll\r\n");
)

}

void CEventLogMonitor::TimedOut()
{
    if (m_bMonitoring)
    {
        Poll();
    }
}

void CEventLogMonitor::StartMonitoring()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::StartMonitoring()"
        ) ;
)

    //single threaded monitor
    //cheat, check for logon event
    //if we go multi-threaded this will
    //have to be done by the manager

    if (m_Logs)
    {
        DWORD logtime = 0;
        
        if (m_pParent->IsFirstSinceLogon())
        {
            //find the System log
            for (ULONG x = 0; x < m_LogCount; x++)
            {
                if ((m_Logs[x]->IsValid()) && (0 == _wcsicmp(L"System", m_Logs[x]->GetLogName())))
                {
                    DWORD dwRecID;
                    logtime = m_Logs[x]->FindOldEvent(LOGON_EVTID, LOGON_SOURCE, &dwRecID, LOGON_TIME);
                    
                    if (0 != logtime)
                    {
                        m_Logs[x]->SetProcessRecord(dwRecID);
                        m_Logs[x]->Process();
                    }
                    else
                    {
                        if (!m_Logs[x]->IsValid())
                        {
                            m_Logs[x]->RefreshHandle();

                            if (m_Logs[x]->IsValid())
                            {
                                m_Logs[x]->ReadLastRecord();
                            }

                        }
                        else
                        {
                            m_Logs[x]->ReadLastRecord();
                        }
                    }

                    break;
                }
            }

            if (0 != logtime)
            {
                time_t tm;
                time(&tm);

                for (x = 0; x < m_LogCount; x++)
                {
                    if ((m_Logs[x]->IsValid()) && (0 != _wcsicmp(L"System", m_Logs[x]->GetLogName())))
                    {
                        DWORD dwRecID;
                        m_Logs[x]->FindOldEvent(0, NULL, &dwRecID, tm - logtime);

                        if (m_Logs[x]->IsValid())
                        {
                            m_Logs[x]->SetProcessRecord(dwRecID);
                            m_Logs[x]->Process();
                        }
                    }
                }
            }
        }
        
        //now start the monitors monitoring!
        for (ULONG x = 0; x < m_LogCount; x++)
        {
            if (m_Logs[x]->IsValid())
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::StartMonitoring() monitoring log %d of %d logs\r\n",
        x, m_LogCount
        ) ;
)

                ScheduleTask(*(m_Logs[x]));
            }
        }
    }
    
    m_bMonitoring = TRUE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving CEventLogMonitor::StartMonitoring()\r\n"
        ) ;
)

}

void CEventLogMonitor::Initialise()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise\r\n"
        ) ;
)
	AddRef();
    InitializeCom();

    //for each logfilename create a logfile
    if (m_LogCount != 0)
    {
        m_Logs = new CMonitoredEventLogFile*[m_LogCount];
        BOOL bValid = FALSE;

        for (ULONG x = 0; x < m_LogCount; x++)
        {
            CStringW* tmp = m_LogNames.GetAt(x);
            m_Logs[x] = new CMonitoredEventLogFile(m_pParent, *tmp);

            if ( !( (m_Logs[x])->IsValid() ) )
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise logfile %d named %s is invalid\r\n",
        x, *tmp
        ) ;
)
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise logfile %d named %s is valid\r\n",
        x, *tmp
        ) ;
)

                bValid = TRUE;
            }
        }

        if (!bValid)
        {
            delete [] m_Logs;
            m_Logs = NULL;
        }
    }
    else
    {
        //should never happen
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise() !!!NO LOGFILES TO MONITOR!!!\r\n"
        ) ;
)

    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving CEventLogMonitor::Initialise()\r\n"
        ) ;
)

}


void CEventLogMonitor::Uninitialise()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::Uninitialise\r\n");
)
    if (m_Logs != NULL)
    {
        for (ULONG x = 0; x < m_LogCount; x++)
        {
            delete m_Logs[x];
        }

        delete [] m_Logs;
    }

    CoUninitialize();
    Release();

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::Uninitialise: Leaving method\r\n");
)
}

LONG CEventLogMonitor ::AddRef(void)
{
	return InterlockedIncrement ( & m_Ref ) ;
}

LONG CEventLogMonitor ::Release(void)
{
    LONG t_Ref ;

    if ( ( t_Ref = InterlockedDecrement ( & m_Ref ) ) == 0 )
    {
        delete this ;
        return 0 ;
    }
    else
    {
        return t_Ref ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtserv.cpp ===
//***************************************************************************

//

//  NTEVTSERV.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the WBEM locator and services interfaces

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpNTEvtProv ::CImpNTEvtProv
// CImpNTEvtProv ::~CImpNTEvtProv
//
//***************************************************************************

CImpNTEvtProv ::CImpNTEvtProv () 
 :  m_localeId ( NULL ) ,
    m_Namespace ( NULL ) ,
    m_Server ( NULL ) ,
    m_NotificationClassObject ( NULL ) ,
    m_ExtendedNotificationClassObject ( NULL )
{
    m_ReferenceCount = 0 ;
     
    InterlockedIncrement ( & CNTEventProviderClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

    m_Initialised = FALSE ;
    m_GetNotifyCalled = FALSE ;
    m_GetExtendedNotifyCalled = FALSE ;

}

CImpNTEvtProv ::~CImpNTEvtProv(void)
{
    delete [] m_localeId ;
    delete [] m_Namespace ;

    if ( m_Server ) 
        m_Server->Release () ;

    if ( m_NotificationClassObject )
        m_NotificationClassObject->Release () ;

    if ( m_ExtendedNotificationClassObject )
        m_ExtendedNotificationClassObject->Release () ;

    InterlockedDecrement ( & CNTEventProviderClassFactory :: objectsInProgress ) ;
}

//***************************************************************************
//
// CImpNTEvtProv ::QueryInterface
// CImpNTEvtProv ::AddRef
// CImpNTEvtProv ::Release
//
// Purpose: IUnknown members for CImpNTEvtProv object.
//***************************************************************************

STDMETHODIMP CImpNTEvtProv ::QueryInterface (

    REFIID iid , 
    LPVOID FAR *iplpv 
) 
{
    SetStructuredExceptionHandler seh;

    try
    {
        *iplpv = NULL ;

        if ( iid == IID_IUnknown )
        {
            *iplpv = ( IWbemServices* ) this ;
        }
        else if ( iid == IID_IWbemServices )
        {
            *iplpv = ( IWbemServices* ) this ;      
        }
        else if ( iid == IID_IWbemProviderInit )
        {
            *iplpv = ( IWbemProviderInit* ) this ;      
        }
        

        if ( *iplpv )
        {
            ( ( LPUNKNOWN ) *iplpv )->AddRef () ;

            return S_OK ;
        }
        else
        {
            return E_NOINTERFACE ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP_(ULONG) CImpNTEvtProv ::AddRef(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
        return InterlockedIncrement ( & m_ReferenceCount ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP_(ULONG) CImpNTEvtProv ::Release(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
        LONG t_Ref ;
        if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
        {
            delete this ;
            return 0 ;
        }
        else
        {
            return t_Ref ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

IWbemServices *CImpNTEvtProv :: GetServer () 
{ 
    if ( m_Server )
        m_Server->AddRef () ; 

    return m_Server ; 
}

void CImpNTEvtProv :: SetLocaleId ( wchar_t *localeId )
{
    m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpNTEvtProv :: GetNamespace () 
{
    return m_Namespace ; 
}

void CImpNTEvtProv :: SetNamespace ( wchar_t *a_Namespace ) 
{
    m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

IWbemClassObject *CImpNTEvtProv :: GetNotificationObject (
                                        WbemProvErrorObject &a_errorObject,
                                        IWbemContext *pCtx
                                    ) 
{
    if ( m_NotificationClassObject )
    {
        m_NotificationClassObject->AddRef () ;
    }
    else
    {
        BOOL t_Status = CreateNotificationObject ( a_errorObject, pCtx ) ;
        if ( t_Status )
        {
/* 
 * Keep around until we close
 */
            m_NotificationClassObject->AddRef () ;
        }

    }

    return m_NotificationClassObject ; 
}

IWbemClassObject *CImpNTEvtProv :: GetExtendedNotificationObject (
                                        WbemProvErrorObject &a_errorObject,
                                        IWbemContext *pCtx
                                    ) 
{
    if ( m_ExtendedNotificationClassObject )
    {
        m_ExtendedNotificationClassObject->AddRef () ;
    }
    else
    {
        BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject, pCtx ) ;
        if ( t_Status )
        {
/* 
 * Keep around until we close
 */
            m_ExtendedNotificationClassObject->AddRef () ;
        }
    }

    return m_ExtendedNotificationClassObject ; 
}

BOOL CImpNTEvtProv :: CreateExtendedNotificationObject ( 

    WbemProvErrorObject &a_errorObject,
    IWbemContext *pCtx
)
{
    m_ExtendedNotifyLock.Lock();
    BOOL t_Status = TRUE ;

    if ( m_GetExtendedNotifyCalled )
    {
        if ( !m_ExtendedNotificationClassObject )
            t_Status = FALSE ;
    }
    else
    {
		HRESULT t_Result = WBEM_E_FAILED ;

        m_GetExtendedNotifyCalled = TRUE ;
		BSTR t_clsStr = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);
		if ( t_clsStr )
		{
			t_Result = m_Server->GetObject (

				t_clsStr ,
				0 ,
				pCtx,
				& m_ExtendedNotificationClassObject ,
				NULL 
			) ;

			SysFreeString(t_clsStr);

			DebugOut( 
				CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

					_T(__FILE__),__LINE__,
					L"CreateExtendedNotificationObject :: ~CreateExtendedNotificationObject:  GetObject for %s returned %lx\r\n",
					WBEM_CLASS_EXTENDEDSTATUS, t_Result
					) ;
			)
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

        if ( ! SUCCEEDED ( t_Result ) )
        {
            t_Status = FALSE ;
            a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
            a_errorObject.SetWbemStatus ( ( WBEMSTATUS ) t_Result ) ;
            a_errorObject.SetMessage ( L"Failed to get Win32_PrivilegesStatus" ) ;

            m_ExtendedNotificationClassObject = NULL ;
        }
    }

    m_ExtendedNotifyLock.Unlock();

    return t_Status ;
}

BOOL CImpNTEvtProv :: CreateNotificationObject ( 

    WbemProvErrorObject &a_errorObject,
    IWbemContext *pCtx
)
{
    m_NotifyLock.Lock();
    BOOL t_Status = TRUE ;

    if ( m_GetNotifyCalled )
    {
        if ( !m_NotificationClassObject )
            t_Status = FALSE ;
    }
    else
    {
        m_GetNotifyCalled = TRUE ;

		HRESULT t_Result = WBEM_E_FAILED ;

		BSTR t_clsStr = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);
		if ( t_clsStr )
		{
			t_Result = m_Server->GetObject (

				t_clsStr ,
				0 ,
				pCtx,
				& m_NotificationClassObject ,
				NULL
			) ;

			SysFreeString(t_clsStr);

DebugOut( 
	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		L"CreateNotificationObject :: ~CreateNotificationObject:  GetObject for %s returned %lx\r\n",
		WBEM_CLASS_EXTENDEDSTATUS, t_Result
		) ;
)
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

        if ( ! SUCCEEDED ( t_Result ) )
        {
            t_Status = FALSE ;
            a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
            a_errorObject.SetWbemStatus ( ( WBEMSTATUS ) t_Result ) ;
            a_errorObject.SetMessage ( L"Failed to get Win32_PrivilegesStatus" ) ;
			m_NotificationClassObject = NULL;
        }
    }
    m_NotifyLock.Unlock();

    return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpNTEvtProv :: CancelAsyncCall ( 
        
    IWbemObjectSink __RPC_FAR *pSink
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: QueryObjectSink ( 

    long lFlags,        
    IWbemObjectSink __RPC_FAR* __RPC_FAR* ppHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: GetObject ( 
        
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR* __RPC_FAR *ppObject,
    IWbemCallResult __RPC_FAR* __RPC_FAR *ppCallResult
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: GetObjectAsync ( 
        
    const BSTR ObjectPath, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::GetObjectAsync ()" 
        ) ;
) 

/*
 * Create Asynchronous GetObjectByPath object
 */

        GetObjectAsyncEventObject t_AsyncEvent ( this , ObjectPath , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process () ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
            ObjectPath ,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: PutClass ( 
        
    IWbemClassObject __RPC_FAR* pClass , 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: PutClassAsync ( 
        
    IWbemClassObject __RPC_FAR* pClass, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CImpNTEvtProv :: DeleteClass ( 
        
    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
     return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: DeleteClassAsync ( 
        
    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: CreateClassEnum ( 

    const BSTR Superclass, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpNTEvtProv :: CreateClassEnumAsync (

    const BSTR Superclass, 
    long lFlags, 
    IWbemContext __RPC_FAR* pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: PutInstance (

    IWbemClassObject __RPC_FAR *pInstance,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: PutInstanceAsync ( 
        
    IWbemClassObject __RPC_FAR* pInstance, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::PutInstanceAsync ()" 
        ) ;
) 

/*
 * Create Asynchronous GetObjectByPath object
 */

        PutInstanceAsyncEventObject t_AsyncEvent ( this , pInstance , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process();

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::PutInstanceAsync with Result = (%lx)" ,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: DeleteInstance ( 

    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
    return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpNTEvtProv :: DeleteInstanceAsync (
 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: CreateInstanceEnum ( 

    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx, 
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: CreateInstanceEnumAsync (

    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler 

) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;


        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::CreateInstanceEnumAsync ( (%s) )" ,
            Class
        ) ;
)

/*
 * Create Synchronous Enum Instance object
 */
        CStringW QueryStr(ENUM_INST_QUERY_START);
        QueryStr += CStringW(Class);
        QueryStr += ENUM_INST_QUERY_MID;
        QueryStr += CStringW(Class);
        QueryStr += PROP_END_QUOTE;
        BSTR Query = QueryStr.AllocSysString();

        ExecQueryAsyncEventObject t_AsyncEvent ( this , WBEM_QUERY_LANGUAGE_SQL1 , Query , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process() ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::CreateInstanceEnumAsync ( (%s),(%s) ) with Result = (%lx)" ,
            Class,
            Query,
            t_Status 
        ) ;
)
        SysFreeString(Query);
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: ExecQuery ( 

    const BSTR QueryLanguage, 
    const BSTR Query, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: ExecQueryAsync ( 
        
    const BSTR QueryFormat, 
    const BSTR Query, 
    long lFlags, 
    IWbemContext __RPC_FAR* pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;


        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::ExecQueryAsync ( (%s),(%s) )" ,
            QueryFormat ,
            Query 
        ) ;
)

/*
 * Create Synchronous Enum Instance object
 */
        pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);

        ExecQueryAsyncEventObject t_AsyncEvent ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process() ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
            QueryFormat,
            Query,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: ExecNotificationQuery ( 

    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
    return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpNTEvtProv :: ExecNotificationQueryAsync ( 
            
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
    return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpNTEvtProv :: ExecMethod( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpNTEvtProv :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemObjectSink __RPC_FAR *pResponseHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::ExecMethodAsync ()" 
        ) ;
) 

/*
 * Create Asynchronous GetObjectByPath object
 */
        ExecMethodAsyncEventObject t_AsyncEvent ( this , ObjectPath , MethodName ,
                                                                lFlags , pInParams , pResponseHandler , pCtx ) ;
        t_AsyncEvent.Process() ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::ExecMethodAsync ( (%s) ) with Result = (%lx)" ,
            ObjectPath ,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

        
HRESULT CImpNTEvtProv :: Initialize(

    LPWSTR pszUser,
    LONG lFlags,
    LPWSTR pszNamespace,
    LPWSTR pszLocale,
    IWbemServices *pCIMOM,         // For anybody
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink     // For init signals
)
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 

        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::Initialize "
        ) ;
)

        m_Server = pCIMOM ;
        m_Server->AddRef () ;

        m_NamespacePath.SetNamespacePath ( pszNamespace ) ;
    
DebugOut( 

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning From CImpPropProv::Initialize () "
        ) ;
)

        pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 ) ;   
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT STDMETHODCALLTYPE CImpNTEvtProv::OpenNamespace ( 

    const BSTR ObjectPath, 
    long lFlags, 
    IWbemContext FAR* pCtx,
    IWbemServices FAR* FAR* pNewContext, 
    IWbemCallResult FAR* FAR* ppErrorObject
)
{
    return WBEM_E_NOT_AVAILABLE ;
}


HRESULT CImpNTEvtProv::GetImpersonation()
{
    HRESULT hr = WBEM_E_FAILED;
    DWORD dwVersion = GetVersion();

    if ( (4 < (DWORD)(LOBYTE(LOWORD(dwVersion))))
        || ObtainedSerialAccess(CNTEventProvider::g_secMutex) )
    {
        if (SUCCEEDED(WbemCoImpersonateClient())) 
        {
            HANDLE hThreadTok;

            if ( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
            {
                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN)
                {
                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    // If we failed to get the thread token for any other reason, an error.
                    hr = WBEM_E_ACCESS_DENIED;
                }
            } 
            else 
            {         
                DWORD dwImp;
                DWORD dwBytesReturned;

                // We really do have a thread token, so let's retrieve its level
                if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwImp,
                                            sizeof(DWORD), &dwBytesReturned)) 
                {
                      
                    // Is the impersonation level Impersonate?
                    if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation)) 
                    {
                        hr = WBEM_S_NO_ERROR;
                    } 
                    else 
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                    }     
                } 
                  
                CloseHandle(hThreadTok);
            }

			if (FAILED(hr))
			{
				WbemCoRevertToSelf();
			}
        }

        if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
        {
            ReleaseSerialAccess(CNTEventProvider::g_secMutex);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ole2.h>
#include <windows.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <comdef.h>

// need safe functions
#define STRSAFE_LIB
#include <strsafe.h>

#include <ntevtdefs.h>

#include <ntevtserv.h>
#include <ntevtprov.h>
#include <ntevtthrd.h>
#include <ntevtinst.h>
#include <ntevtcfac.h>
#include <ntevtlogf.h>
#include <ntevtlogr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtcfac.h ===
//***************************************************************************

//

//  NTEVTCFAC.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTCFAC_H
#define _NT_EVT_PROV_NTEVTCFAC_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for the event provider.

class CNTEventProviderClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CNTEventProviderClassFactory () ;
    ~CNTEventProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) = 0;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CNTEventlogEventProviderClassFactory : public CNTEventProviderClassFactory
{
public:
	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );
};

class CNTEventlogInstanceProviderClassFactory : public CNTEventProviderClassFactory
{
public:
	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );
};

#endif //_NT_EVT_PROV_NTEVTCFAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevttask.cpp ===
//***************************************************************************

//

//  NTEVTQUERY.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the taskobject implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


WbemTaskObject :: WbemTaskObject (

    CImpNTEvtProv *a_Provider ,
    IWbemObjectSink *a_NotificationHandler ,
    ULONG a_OperationFlag ,
    IWbemContext *a_Ctx

) : m_State ( WBEM_TASKSTATE_START ) ,
    m_OperationFlag ( a_OperationFlag ) ,
    m_Provider ( a_Provider ) ,
    m_NotificationHandler ( a_NotificationHandler ) ,
    m_Ctx ( a_Ctx ) ,
    m_RequestHandle ( 0 ) ,
    m_ClassObject ( NULL ) ,
	m_AClassObject ( NULL )
{
//No need to AddRef these 'cos our lifetime is less than the the function creating us!!
//  m_Provider->AddRef () ;
//  m_NotificationHandler->AddRef () ;
//  m_Ctx->AddRef () ;

    HRESULT hr = CImpNTEvtProv::GetImpersonation();

    if (FAILED(hr))
    {
        //either FAILED or ACCESS_DENIED
        if (hr == WBEM_E_FAILED)
        {
            m_ErrorObject.SetStatus (WBEM_PROV_E_FAILED);
            m_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
            m_ErrorObject.SetMessage (L"Failed to impersonate client");
        }
        else
        {
            m_ErrorObject.SetStatus (WBEM_PROV_E_ACCESS_DENIED);
            m_ErrorObject.SetWbemStatus (WBEM_E_ACCESS_DENIED);
            m_ErrorObject.SetMessage (L"Access denied, impersonation level too low");
        }
    }

}

WbemTaskObject :: ~WbemTaskObject ()
{
//Didn't AddRef so don't Release
//  m_Provider->Release () ;
//  m_NotificationHandler->Release () ;
//  m_Ctx->Release () ;

    if ( m_ClassObject )
        m_ClassObject->Release () ;

	if ( m_AClassObject )
		m_AClassObject->Release () ;

    WbemCoRevertToSelf();
}

WbemProvErrorObject &WbemTaskObject :: GetErrorObject ()
{
    return m_ErrorObject ; 
}   

BOOL WbemTaskObject :: GetClassObject ( BSTR a_Class )
{
	BOOL retVal = FALSE;

	IWbemServices *t_Server = m_Provider->GetServer() ;

	if (t_Server)
	{
		retVal = GetClassObject(a_Class, FALSE, t_Server, m_Ctx, &m_ClassObject);

		if (retVal)
		{
			GetClassObject(a_Class, TRUE, t_Server, m_Ctx, &m_AClassObject);
		}

		t_Server->Release () ;
	}

	return retVal;
}

BOOL WbemTaskObject :: GetClassObject ( BSTR a_Class, BOOL a_bAmended, IWbemServices *a_Server, IWbemContext *a_Ctx, IWbemClassObject **a_ppClass )
{
	DWORD dwIndex = NT_EVTLOG_MAX_CLASSES;
	BOOL retVal = FALSE;

	if (a_Class && a_ppClass)
	{
		if (_wcsicmp(a_Class, NTEVT_CLASS) == 0)
		{
			dwIndex = a_bAmended ? 0 : 1;
		}
		else if (_wcsicmp(a_Class, NTEVTLOG_CLASS) == 0)
		{
			dwIndex = a_bAmended ? 2 : 3;
		}
		else if (_wcsicmp(a_Class, ASSOC_LOGRECORD) == 0)
		{
			dwIndex = 4;
		}
		else if (_wcsicmp(a_Class, ASSOC_USERRECORD) == 0)
		{
			dwIndex = 5;
		}
		else if (_wcsicmp(a_Class, ASSOC_COMPRECORD) == 0)
		{
			dwIndex = 6;
		}

		if (dwIndex < NT_EVTLOG_MAX_CLASSES)
		{
			if (g_ClassArray[dwIndex] == NULL)
			{
				if (SUCCEEDED(a_Server->GetObject (

					a_Class ,
					a_bAmended ? WBEM_FLAG_USE_AMENDED_QUALIFIERS : 0 ,
					a_Ctx,
					a_ppClass,
					NULL 
				) ))
				{
					g_ClassArray[dwIndex] = *a_ppClass ;
					g_ClassArray[dwIndex]->AddRef() ;
					retVal = TRUE;
				}
			}
			else
			{
				*a_ppClass = g_ClassArray[dwIndex];
				(*a_ppClass)->AddRef();
				retVal = TRUE;
			}
		}
	}

    return retVal;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
    IWbemClassObject *t_NotificationClassObject = NULL ;
    IWbemClassObject *t_ErrorObject = NULL ;

    BOOL t_Status = TRUE ;

    WbemProvErrorObject t_ErrorStatusObject ;
    if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
    {
        HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
        if ( SUCCEEDED ( t_Result ) )
        {
            VARIANT t_Variant ;
            VariantInit ( &t_Variant ) ;

            t_Variant.vt = VT_I4 ;
            t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

            t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
            VariantClear ( &t_Variant ) ;
#if 0
            if ( SUCCEEDED ( t_Result ) )
            {
                t_Variant.vt = VT_I4 ;
                t_Variant.lVal = m_ErrorObject.GetStatus () ;

                t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSCODE , 0 , & t_Variant , 0 ) ;
                VariantClear ( &t_Variant ) ;
#endif
                if ( SUCCEEDED ( t_Result ) )
                {
                    if ( m_ErrorObject.GetMessage () ) 
                    {
                        t_Variant.vt = VT_BSTR ;
                        t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;
						if ( NULL != t_Variant.bstrVal )
						{
							t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
							VariantClear ( &t_Variant ) ;

							if ( m_ErrorObject.GetPrivilegeFailed() )
							{
								if (m_ErrorObject.SetPrivRequiredVariant(t_Variant))
								{
									t_Result = (*a_NotifyObject)->Put(WBEM_PROPERTY_PRIVREQUIRED, 0, &t_Variant, 0);
									VariantClear ( &t_Variant ) ;

									if (SUCCEEDED(t_Result))
									{
										if (m_ErrorObject.SetPrivFailedVariant(t_Variant))
										{
											t_Result = (*a_NotifyObject)->Put(WBEM_PROPERTY_PRIVNOTHELD, 0, &t_Variant, 0);
											VariantClear ( &t_Variant ) ;
										}
										else
										{
											t_Result = WBEM_E_FAILED;
										}
									}
								}
								else
								{
									t_Result = WBEM_E_FAILED;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

                        if ( ! SUCCEEDED ( t_Result ) )
                        {
                            (*a_NotifyObject)->Release () ;
                            *a_NotifyObject = NULL;
                            t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
                        }
                    }
                }
                else
                {
                    (*a_NotifyObject)->Release () ;
                    t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
                }
#if 0
            }
            else
            {
                (*a_NotifyObject)->Release () ;
                t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
            }
#endif
            t_NotificationClassObject->Release () ;
        }
        else
        {
            t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
        }
    }
    else
    {
        t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
    }

    return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
    IWbemClassObject *t_NotificationClassObject = NULL ;

    BOOL t_Status = TRUE ;

    WbemProvErrorObject t_ErrorStatusObject ;
    if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
    {
        HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
        if ( SUCCEEDED ( t_Result ) )
        {
            VARIANT t_Variant ;
            VariantInit ( &t_Variant ) ;

            t_Variant.vt = VT_I4 ;
            t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

            t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
            if ( SUCCEEDED ( t_Result ) )
            {
                if ( m_ErrorObject.GetMessage () ) 
                {
                    t_Variant.vt = VT_BSTR ;
                    t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;
					if ( NULL != t_Variant.bstrVal )
					{
						t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( ! SUCCEEDED ( t_Result ) )
					{
						t_Status = FALSE ;
						(*a_NotifyObject)->Release () ;
						(*a_NotifyObject)=NULL ;
					}
                }
            }
            else
            {
                (*a_NotifyObject)->Release () ;
                (*a_NotifyObject)=NULL ;
                t_Status = FALSE ;
            }

            VariantClear ( &t_Variant ) ;

            t_NotificationClassObject->Release () ;
        }
        else
        {
            t_Status = FALSE ;
        }
    }
    else
    {
        t_Status = FALSE ;
    }

    return t_Status ;
}

BOOL WbemProvErrorObject::SetPrivVariant ( VARIANT &a_V, DWORD dwVal )
{
    BOOL retVal = FALSE;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY* psa = NULL;
    rgsabound[0].lLbound = 0;
    VariantInit(&a_V);
    rgsabound[0].cElements = 0;

    if (dwVal & PROV_PRIV_BACKUP)
    {
        rgsabound[0].cElements++;
    }

    if (dwVal & PROV_PRIV_SECURITY)
    {
        rgsabound[0].cElements++;
    }

    if (rgsabound[0].cElements != 0)
    {
        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
        BSTR* pBstr = NULL;

        if (NULL != psa)
        {
            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
            {
                DWORD indx = 0;

		retVal = TRUE ;

                if (dwVal & PROV_PRIV_SECURITY)
                {
					BSTR t_Str = SysAllocString(SE_SECURITY_NAME);
					pBstr[indx++] = t_Str ;

					if ( NULL == t_Str )
					{
						retVal = FALSE ;
					}
                }

		if ( retVal )
		{
                	if (dwVal & PROV_PRIV_BACKUP)
	                {
        	            	BSTR t_Str = SysAllocString(SE_BACKUP_NAME);
				pBstr[indx] = t_Str ;
				if ( NULL == t_Str )
				{
					retVal = FALSE ;
				}
			}
                }

                SafeArrayUnaccessData(psa);

				if ( retVal )
				{
					a_V.vt = VT_ARRAY|VT_BSTR;
					a_V.parray = psa;
				}
				else
				{
					SafeArrayDestroy ( psa ) ;
				}
            }
        }
    }

    if (!retVal)
    {
        VariantClear(&a_V);
    }

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\dll\provthrd.cpp ===
//***************************************************************************
//
//  PROVTHRD.CPP
//
//  Module: OLE MS PROVIDER FRAMEWORK
//
// Copyright (c) 1996-2003 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <strsafe.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <provcont.h>
#include "provevt.h"
#include "provthrd.h"
#include "provlog.h"
#include <Allocator.cpp>
#include <Algorithms.h>

CStaticCriticalSection ProvThreadObject :: s_Lock ;
LONG ProvThreadObject :: s_ReferenceCount = 0 ;
WmiAllocator g_Allocator ;
ThreadContainer ProvThreadObject :: s_ThreadContainer ( g_Allocator ) ;

typedef ProvOnDelete < CRITICAL_SECTION *, VOID ( * ) ( LPCRITICAL_SECTION ), LeaveCriticalSection >			LeaveCriticalSectionScope;

class ProvShutdownTaskObject : public ProvTaskObject
{
private:

	ProvThreadObject *m_ThreadToShutdown ;

protected:
public:

	ProvShutdownTaskObject (ProvThreadObject *threadToShutdown) ;

	void Process () ;

} ;

ProvShutdownTaskObject :: ProvShutdownTaskObject (

	ProvThreadObject *threadToShutdown

) : m_ThreadToShutdown ( threadToShutdown )
{
}

void ProvShutdownTaskObject ::Process()
{
	if ( m_ThreadToShutdown )
	{
		m_ThreadToShutdown->SignalThreadShutdown ();
	}

	Complete();
}


BOOL ProvThreadObject :: Startup ()
{
	InterlockedIncrement ( & s_ReferenceCount ) ;

	return TRUE ;
}

void ProvThreadObject :: Closedown()
{
#if DBG == 1

	if ( s_ReferenceCount == 0 )
	{
		DebugBreak ();
	}

#endif

	if ( InterlockedDecrement ( & s_ReferenceCount ) <= 0 )
		ProcessDetach () ;
}

void ProvThreadObject :: ProcessAttach () 
{ 
}

void ProvThreadObject :: ProcessDetach ( BOOL a_ProcessDetaching )
{

// delete all known thread objects 

	s_Lock.Lock();

	ThreadContainerIterator t_Iterator = s_ThreadContainer.Begin () ;

	while ( ! t_Iterator.Null () )
	{
		s_Lock.Unlock () ;

		t_Iterator.GetElement ()->SignalThreadShutdown () ;

		s_Lock.Lock();

		t_Iterator = s_ThreadContainer.Begin () ;
	}

	s_ThreadContainer.UnInitialize () ;

	s_Lock.Unlock () ;
}

void ProvThreadObject :: ThreadExecutionProcedure ( void *a_ThreadParameter )
{
	SetStructuredExceptionHandler seh;

	try
	{
		ProvThreadObject *t_ThreadObject = ( ProvThreadObject * ) a_ThreadParameter ;
		BOOL bInitialised = FALSE;

		try
		{
			if ( t_ThreadObject->RegisterThread () )
			{
				t_ThreadObject->Initialise () ;
				bInitialised = TRUE;

				SetEvent ( t_ThreadObject->m_ThreadInitialization ) ;

DebugMacro8(

		CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n [%s] Thread beginning dispatch") , t_ThreadObject->m_ThreadName ) ;
)

				if ( t_ThreadObject->Wait () )
				{
				}
				else 
				{
				}

DebugMacro8(

		CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n [%s] Thread completed dispatch") , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
				bInitialised = FALSE;

DebugMacro8(

		CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread terminating") ) ;
)
			}
		}
		catch(Structured_Exception e_SE)
		{
			t_ThreadObject->RemoveThread () ;

			if ( bInitialised )
			{
DebugMacro(

		CNTEventProvider::g_NTEvtDebugLog->Write ( _TEXT("\n *** [%s] Thread terminating -> structured exception *** ") , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
			}

			return;
		}
		catch(Heap_Exception e_HE)
		{
			t_ThreadObject->RemoveThread () ;

			if ( bInitialised )
			{
DebugMacro(

		CNTEventProvider::g_NTEvtDebugLog->Write ( _TEXT("\n *** [%s] Thread terminating -> heap exception *** ") , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
			}

			return;
		}
		catch(...)
		{
			t_ThreadObject->RemoveThread () ;

			if ( bInitialised )
			{
DebugMacro(

		CNTEventProvider::g_NTEvtDebugLog->Write ( _TEXT("\n *** [%s] Thread terminating -> exception *** ") , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
			}

			return;
		}
	}
	catch ( ... )
	{
DebugMacro(

		CNTEventProvider::g_NTEvtDebugLog->Write ( _TEXT("\n *** Thread terminating -> second chance exception *** ") ) ;
)
	}
}

void ProvThreadObject :: TerminateThread () 
{
	:: TerminateThread (m_ThreadHandle,0) ;
}

ProvThreadObject :: ProvThreadObject (

	const TCHAR *a_ThreadName,
	DWORD a_timeout
	
) :	m_EventContainer ( NULL ) , 
	m_EventContainerLength ( 0 ) , 
	m_ThreadId ( 0 ) , 
	m_ThreadHandle ( 0 ) ,
	m_ThreadName ( NULL ) ,
	m_timeout ( a_timeout ),
	m_pShutdownTask ( NULL ) ,
	m_ScheduleReapContainer ( g_Allocator ) ,
	m_TaskQueue ( g_Allocator ) ,
	m_ThreadInitialization ( NULL )
{
	if ( a_ThreadName )
	{
		m_ThreadName = _tcsdup ( a_ThreadName ) ;
        if( NULL == m_ThreadName) throw Heap_Exception(Heap_Exception::E_ALLOCATION_ERROR);
	}

	m_ThreadInitialization = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;

    if ( NULL == m_ThreadInitialization) throw Heap_Exception(Heap_Exception::E_ALLOCATION_ERROR);

	ConstructEventContainer () ;
}

void  ProvThreadObject :: BeginThread()
{
	UINT_PTR t_PseudoHandle = _beginthread ( 

		ProvThreadObject :: ThreadExecutionProcedure , 
		0 , 
		( void * ) this
	 ) ;

	s_Lock.Lock () ;
	LeaveCriticalSectionScope lcs ( s_Lock );

	if ( ( HANDLE ) t_PseudoHandle != INVALID_HANDLE_VALUE )
	{
		BOOL t_Status = DuplicateHandle ( 

			GetCurrentProcess () ,
			( HANDLE ) t_PseudoHandle ,
			GetCurrentProcess () ,
			GetThreadHandleReference () ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;

		if ( ! t_Status )
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}
	}
}

BOOL ProvThreadObject :: WaitForStartup ()
{
	DWORD	dwHandles	= 2;
	HANDLE	hHandles[]	=
	{
		m_ThreadInitialization,
		m_ThreadHandle
	};

	DWORD dwWaitResult = WAIT_TIMEOUT;
	dwWaitResult = WaitForMultipleObjects ( dwHandles, hHandles, FALSE, INFINITE ) ;

	return ( ( ( dwWaitResult - WAIT_OBJECT_0 ) == 0 ) && ( dwWaitResult != WAIT_FAILED ) );
}

ProvThreadObject :: ~ProvThreadObject ()
{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Enter Thread destructor") ) ;
)

	if ( ( m_ThreadId != GetCurrentThreadId () ) && ( m_ThreadId != 0 ))
	{
		SignalThreadShutdown () ;
	}

	free ( m_ThreadName ) ;

	ProvAbstractTaskObject *t_TaskObject = NULL ;

	WmiStatusCode t_StatusCode ;
	while ( ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success )
	{
		m_TaskQueue.DeQueue () ;

		t_TaskObject->DetachTaskFromThread ( *this ) ;
	}

	m_TaskQueue.UnInitialize () ;

	free ( m_EventContainer ) ;

	// we should have task already deleted by SignalThreadShutdown
	s_Lock.Lock();
	s_ThreadContainer.Delete ( m_ThreadId ) ;
	s_Lock.Unlock () ;

	if ( m_ThreadInitialization )
	{
		CloseHandle ( m_ThreadInitialization ) ;
	}

	if (m_pShutdownTask != NULL)
	{
		delete m_pShutdownTask;
	}

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Exit Thread destructor") ) ;
)

}

void ProvThreadObject :: PostSignalThreadShutdown ()
{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Posting thread shutdown") ) ;
)

	if (m_pShutdownTask != NULL)
	{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread shutdown previously posted") ) ;
)
	}
	else
	{
		m_pShutdownTask = new ProvShutdownTaskObject(this);
		ScheduleTask(*m_pShutdownTask);
		m_pShutdownTask->Exec();

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n Thread shutdown posted") ) ;
)
	}
}


void ProvThreadObject :: SignalThreadShutdown ()
{
	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock) ;
	WmiStatusCode t_StatusCode = s_ThreadContainer.Delete ( m_ThreadId ) ;
	lcs.Exec ();

	if ( t_StatusCode != e_StatusCode_NotFound )
	{
		// this should be safe now
		if ( m_ThreadId == GetCurrentThreadId () )
		{
			m_ThreadTerminateEvent.Set () ;
		}
		else
		{
			HANDLE t_Handle = m_ThreadHandle ;
			m_ThreadTerminateEvent.Set () ;

			DWORD t_Event = WaitForSingleObject (

				t_Handle ,
				INFINITE 
			) ;

			if ( t_Event != WAIT_OBJECT_0 )
			{
				DWORD dwError = ERROR_SUCCESS;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_NOT_ENOUGH_MEMORY )
				{
					#if DBG == 1
					// for testing purpose I will let process break
					::DebugBreak();
					#endif
				}

				while ( ERROR_SUCCESS != dwError )
				{
					// resources will eventually come back
					::Sleep ( 1000 );

					if ( WAIT_OBJECT_0 == WaitForSingleObject	(
																	t_Handle ,
																	INFINITE 
																) )
					{
						// terminate loop
						dwError = ERROR_SUCCESS;
					}
				}
			}

			CloseHandle ( t_Handle ) ;
		}
	}
}

void ProvThreadObject :: ConstructEventContainer ()
{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Constructing Container") , m_ThreadName ) ;
)

	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock ) ;

	BOOL bAllocated = FALSE;
	do
	{
		ULONG origEventContainerLength = m_EventContainerLength ;

		if ( ( m_TaskQueue.Size () + 2 ) <  MAXIMUM_WAIT_OBJECTS )
		{
			m_EventContainerLength = m_TaskQueue.Size () + 2;
		}
		else
		{
			m_EventContainerLength = MAXIMUM_WAIT_OBJECTS - 1;
		}

		HANDLE * tempArray = ( HANDLE * ) realloc ( m_EventContainer , sizeof ( HANDLE ) * m_EventContainerLength );

		if ( tempArray == NULL )
		{
			//
			// revert the size back
			//
			m_EventContainerLength = origEventContainerLength ;

			s_Lock.Unlock () ;
			// system will eventually come back !
			Sleep (60000);
			s_Lock.Lock();
		}
		else
		{
			m_EventContainer = tempArray;
			bAllocated = TRUE;
		}
	}
	while ( ! bAllocated );

	m_EventContainer [ 0 ] = GetHandle () ;
	m_EventContainer [ 1 ] = m_ThreadTerminateEvent.GetHandle () ;

	ULONG t_EventIndex = 2 ;

	WmiStatusCode t_StatusCode ;
	ProvAbstractTaskObject *t_TaskObject = NULL ;

	while ( ( t_EventIndex < m_EventContainerLength ) && ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success )
	{
		t_StatusCode = m_TaskQueue.DeQueue () ;
		t_StatusCode = m_TaskQueue.EnQueue ( t_TaskObject ) ;

		m_EventContainer [ t_EventIndex ] = t_TaskObject->GetHandle () ;
		t_EventIndex ++ ;
	}
}

ProvThreadObject *ProvThreadObject :: GetThreadObject () 
{
	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock );

	DWORD t_CurrentThreadId = GetCurrentThreadId () ;

	ProvThreadObject *t_ThreadObject ;

	ThreadContainerIterator t_Iterator ;

	if ( s_ThreadContainer.Find ( GetCurrentThreadId () , t_Iterator ) == e_StatusCode_Success )
	{
		t_ThreadObject = t_Iterator.GetElement () ;
	}
	else
	{
		t_ThreadObject = NULL ;
	}

	return t_ThreadObject ;
}

ProvAbstractTaskObject *ProvThreadObject :: GetTaskObject ( HANDLE &a_Handle )
{
	ProvAbstractTaskObject *t_TaskObject = NULL ;

	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock );

	ULONG t_QueueSize = m_TaskQueue.Size () ;

	WmiStatusCode t_StatusCode ;
	while ( t_QueueSize && ( ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success ) )
	{
		m_TaskQueue.DeQueue () ;
		m_TaskQueue.EnQueue ( t_TaskObject ) ;

		if ( t_TaskObject->GetHandle () == a_Handle ) 
		{
			break ;
		}

		t_QueueSize -- ;
	}

	return t_TaskObject ;
}

BOOL ProvThreadObject :: RegisterThread () 
{
	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock );

	BOOL t_Status = FALSE ;

	m_ThreadId = GetCurrentThreadId () ;

	ThreadContainerIterator t_Iterator ;
	if ( s_ThreadContainer.Insert ( m_ThreadId , this , t_Iterator ) == e_StatusCode_Success )
	{
		t_Status = TRUE;
	}

DebugMacro8(

	TCHAR buffer [ 1025 ] ;
	StringCchPrintf ( buffer , sizeof ( buffer ) / sizeof ( TCHAR ) , _TEXT("\nThread [%s] = %lx, with thread id = %lx") , m_ThreadName , (UINT_PTR)this , m_ThreadId ) ;
	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__, buffer ) ;
)
	return t_Status ;
}

BOOL ProvThreadObject :: RemoveThread () 
{
	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock );

	BOOL t_Status = s_ThreadContainer.Delete ( m_ThreadId ) ;
	if ( t_Status )
	{
DebugMacro8(

	TCHAR buffer [ 1025 ] ;
	StringCchPrintf ( buffer , sizeof ( buffer ) / sizeof ( TCHAR ) , _TEXT("\nThread [%s] = %lx, with thread id = %lx was removed from container") , m_ThreadName , (UINT_PTR)this , m_ThreadId ) ;
	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__, buffer ) ;
)
	}
	else
	{
DebugMacro8(

	TCHAR buffer [ 1025 ] ;
	StringCchPrintf ( buffer , sizeof ( buffer ) / sizeof ( TCHAR ) , _TEXT("\nThread [%s] = %lx, with thread id = %lx failed to remove from container") , m_ThreadName , (UINT_PTR)this , m_ThreadId ) ;
	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__, buffer ) ;
)
	}

	return t_Status ;
}

void ProvThreadObject :: Process () 
{
	s_Lock.Lock();
	LeaveCriticalSectionScope lcs ( s_Lock );

	ScheduleReapContainerIterator t_Iterator = m_ScheduleReapContainer.Begin () ;

	while ( ! t_Iterator.Null () )
	{


DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Thread Process [%lx]") , m_ThreadName , t_Iterator.GetKey () );
)
		t_Iterator.GetElement ()->Set () ;

		t_Iterator.Increment () ;
	}
}

BOOL ProvThreadObject :: WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated )
{
	BOOL t_Status = TRUE ;

	HANDLE t_Handle = m_EventContainer [ t_HandleIndex ] ;
	if ( t_Handle == GetHandle () )
	{
// Task has been scheduled so we must update arrays

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Thread Wait: Refreshing handles") , m_ThreadName );
)

		Process () ;
		ConstructEventContainer () ;
	}
	else if ( t_Handle == m_ThreadTerminateEvent.GetHandle () )
	{
// thread has been told to close down

		a_Terminated = TRUE ;
		m_ThreadTerminateEvent.Process () ;

DebugMacro8(

		CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Someone t_Terminated") , m_ThreadName )  ;
)
	}
	else
	{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Thread Wait: Processing Task") , m_ThreadName );
)

		ProvAbstractTaskObject *t_TaskObject = GetTaskObject ( t_Handle ) ;
		if ( t_TaskObject )
		{
			ConstructEventContainer () ;
			t_TaskObject->Process () ;
		}
		else
		{
DebugMacro8(

			CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Couldn't Find Task Object") , m_ThreadName ) ;
)
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

BOOL ProvThreadObject :: Wait ()
{
	BOOL t_Status = TRUE ;
	BOOL t_Terminated = FALSE ;

	while ( t_Status && ! t_Terminated )
	{
		DWORD t_Event = MsgWaitForMultipleObjects (

			m_EventContainerLength ,
			m_EventContainer ,
			FALSE ,
			m_timeout ,
			QS_ALLINPUT
		) ;

		ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

		if ( t_Event == 0xFFFFFFFF )
		{
			DWORD t_Error = GetLastError () ;

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Handle problem") , m_ThreadName ) ;
)

			t_Status = FALSE ;
		}
		else if ( t_Event == WAIT_TIMEOUT)
		{
			TimedOut();
		}
		else if ( t_HandleIndex <= m_EventContainerLength )
		{
// Go into dispatch loop

			if ( t_HandleIndex == m_EventContainerLength )
			{
				BOOL t_DispatchStatus ;
				MSG t_Msg ;

				while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					int t_Result = 0;
					t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

					if ( t_Result != 0 && t_Result != -1 )
					{
						TranslateMessage ( & t_Msg ) ;
						DispatchMessage ( & t_Msg ) ;
					}

					BOOL t_Timeout = FALSE ;

					while ( !t_Timeout && t_Status && !t_Terminated )
					{
						t_Event = WaitForMultipleObjects (

							m_EventContainerLength ,
							m_EventContainer ,
							FALSE ,
							0
						) ;

						t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

						if ( t_Event == 0xFFFFFFFF )
						{
							DWORD t_Error = GetLastError () ;
	
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Handle problem") , m_ThreadName ) ;
)
							t_Status = FALSE ;
						}
						else if ( t_Event == WAIT_TIMEOUT)
						{
							t_Timeout = TRUE ;
						}
						else if ( t_HandleIndex < m_EventContainerLength )
						{
							t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
						}
						else
						{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Unknown handle index") , m_ThreadName ) ;
)
							t_Status = FALSE ;
						}
					}
				}
			}
			else if ( t_HandleIndex < m_EventContainerLength )
			{
				t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
			}
			else
			{

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Unknown handle index") , m_ThreadName ) ;
)
				t_Status = FALSE ;
			}
		}
	}

	return t_Status ;
}

ULONG ProvThreadObject :: GetEventHandlesSize ()
{
	return m_EventContainerLength ;
}

HANDLE *ProvThreadObject :: GetEventHandles ()
{
	return m_EventContainer ;
}

BOOL ProvThreadObject :: ScheduleTask ( ProvAbstractTaskObject &a_TaskObject ) 
{
	BOOL t_Result = TRUE ;

	s_Lock.Lock();

/*
 * Add Synchronous object to worker thread container
 */
	a_TaskObject.m_ScheduledHandle = a_TaskObject.GetHandle ();
	WmiStatusCode t_StatusCode = m_TaskQueue.EnQueue ( &a_TaskObject ) ; 

	s_Lock.Unlock () ;

	a_TaskObject.AttachTaskToThread ( *this ) ;

	if ( GetCurrentThreadId () != m_ThreadId ) 
	{
		Set () ;
	}
	else
	{
		ConstructEventContainer () ;
	}

	return t_Result ;
}

BOOL ProvThreadObject :: ReapTask ( ProvAbstractTaskObject &a_TaskObject ) 
{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Entering ReapTask [%lx]") , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

	BOOL t_Result = TRUE ;

	s_Lock.Lock();

/*
 *	Remove worker object from worker thread container
 */

	ProvAbstractTaskObject *t_TaskObject = NULL ;

	ULONG t_QueueSize = m_TaskQueue.Size () ;

	WmiStatusCode t_StatusCode ;
	while ( t_QueueSize && ( ( t_StatusCode = m_TaskQueue.Top ( t_TaskObject ) ) == e_StatusCode_Success ) )
	{
		m_TaskQueue.DeQueue () ;

		if ( a_TaskObject.m_ScheduledHandle == t_TaskObject->m_ScheduledHandle )
		{
			break ;
		}

		m_TaskQueue.EnQueue ( t_TaskObject ) ;

		t_QueueSize -- ;
	}

	s_Lock.Unlock () ;

/*
 * Inform worker thread,thread container has been updated.
 */

	if ( GetCurrentThreadId () != m_ThreadId ) 
	{
		ProvEventObject t_ReapedEventObject ;

		s_Lock.Lock() ;

		ScheduleReapContainerIterator t_Iterator ;
		WmiStatusCode t_StatusCode = m_ScheduleReapContainer.Insert ( t_ReapedEventObject.GetHandle () , &t_ReapedEventObject , t_Iterator ) ;

		s_Lock.Unlock () ;

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] ReapTask: Setting update") , m_ThreadName );
)
		Set () ;

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] ReapTask: Beginning Wait on [%lx]") , m_ThreadName , t_ReapedEventObject.GetHandle () );
)

		if ( t_ReapedEventObject.Wait () )
		{
		}
		else
		{
			t_Result = FALSE ;
		}

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] ReapTask: Ended Wait") , m_ThreadName );
)

		s_Lock.Lock();

		t_StatusCode = m_ScheduleReapContainer.Delete ( t_ReapedEventObject.GetHandle () ) ;

		s_Lock.Unlock () ;

	}
	else
	{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] ReapTask: ConstructEventContainer") , m_ThreadName );
)
		ConstructEventContainer () ;
	}

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\n[%s] Returning from ReapTask [%lx]") , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

	a_TaskObject.DetachTaskFromThread ( *this ) ;

	return t_Result ;
}

ProvAbstractTaskObject :: ProvAbstractTaskObject ( 

	const TCHAR *a_GlobalTaskNameComplete,
	const TCHAR *a_GlobalTaskNameAcknowledgement,
	DWORD a_timeout

) : m_CompletionEvent ( a_GlobalTaskNameComplete ) , 
	m_AcknowledgementEvent ( a_GlobalTaskNameAcknowledgement ) , 
	m_timeout ( a_timeout ), 
	m_ScheduledHandle (NULL),
	m_ThreadContainer (g_Allocator)
{
} 

ProvAbstractTaskObject :: ~ProvAbstractTaskObject () 
{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: ~ProvAbstractTaskObject () [%lx]") , m_ScheduledHandle ) ;
)

	m_Lock.Lock();
	LeaveCriticalSectionScope lcs ( m_Lock );

	if (NULL != m_ScheduledHandle)
	{
		ThreadContainerIterator t_Iterator = m_ThreadContainer.Begin () ;

		while ( ! t_Iterator.Null () )
		{
			ProvThreadObject *t_Task = t_Iterator.GetElement () ;

			t_Task->ReapTask ( *this ) ;

			t_Iterator = m_ThreadContainer.Begin () ;
		}
	}

	m_ThreadContainer.UnInitialize () ;	
}

void ProvAbstractTaskObject :: DetachTaskFromThread ( ProvThreadObject &a_ThreadObject )
{
	m_Lock.Lock();
	LeaveCriticalSectionScope lcs ( m_Lock );

	WmiStatusCode t_StatusCode = m_ThreadContainer.Delete ( a_ThreadObject.GetThreadId () ) ;
}

void ProvAbstractTaskObject :: AttachTaskToThread ( ProvThreadObject &a_ThreadObject )
{
	m_Lock.Lock();
	LeaveCriticalSectionScope lcs ( m_Lock );

	ThreadContainerIterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_ThreadContainer.Insert ( a_ThreadObject.GetThreadId () , &a_ThreadObject , t_Iterator ) ;
}

BOOL ProvAbstractTaskObject :: Wait ( BOOL a_Dispatch )
{
	BOOL t_Status = TRUE ;
	BOOL t_Processed = FALSE ;

	while ( t_Status && ! t_Processed )
	{
		ProvThreadObject *t_ThreadObject = ProvThreadObject :: GetThreadObject () ;
		ULONG t_TaskEventArrayLength = 0 ;
		HANDLE *t_TaskEventArray = NULL ;

		if ( t_ThreadObject && a_Dispatch )
		{
			ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
			t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

			if ( t_TaskArrayLength )
			{
				memcpy ( 
 
					& ( t_TaskEventArray [ 1 ] ) , 
					t_ThreadObject->GetEventHandles () ,
					t_TaskArrayLength * sizeof ( HANDLE ) 
				) ;		
			}

			t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;			
		}
		else
		{
			t_TaskEventArrayLength = 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
			t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;
		}

		DWORD t_Event ;

		if ( a_Dispatch ) 
		{
			t_Event = MsgWaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout ,
				QS_ALLINPUT
			) ;
		}
		else
		{
			t_Event = WaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout 
			) ;
		}

		ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

		if ( t_Event == 0xFFFFFFFF )
		{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

			DWORD t_Error = GetLastError () ;
			t_Status = FALSE ;
		}
		else if ( t_Event == WAIT_TIMEOUT)
		{
			TimedOut();
		}
		else if ( t_HandleIndex == t_TaskEventArrayLength )
		{
			BOOL t_DispatchStatus ;
			MSG t_Msg ;

			while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
			{
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
				{
					TranslateMessage ( & t_Msg ) ;
					DispatchMessage ( & t_Msg ) ;
				}

				BOOL t_Timeout = FALSE ;

				while (!t_Timeout &&  t_Status &&  !t_Processed )
				{
					t_Event = WaitForMultipleObjects (

						t_TaskEventArrayLength ,
						t_TaskEventArray ,
						FALSE ,
						0
					) ;

					t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

					if ( t_Event == 0xFFFFFFFF )
					{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

						DWORD t_Error = GetLastError () ;
						t_Status = FALSE ;
					}
					else if ( t_Event == WAIT_TIMEOUT)
					{
						t_Timeout = TRUE ;
					}
					else if ( t_HandleIndex < t_TaskEventArrayLength )
					{
						HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
						t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
					}
					else
					{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)
						t_Status = FALSE ;
					}
				}
			}
		}
		else if ( t_HandleIndex < t_TaskEventArrayLength )
		{
			HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
			t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
		}
		else
		{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)

			t_Status = FALSE ;
		}

		delete [] t_TaskEventArray ;
	}

	return t_Status ;
}

BOOL ProvAbstractTaskObject :: WaitDispatch ( ProvThreadObject *a_ThreadObject, HANDLE a_Handle , BOOL &a_Processed )
{
	BOOL t_Status = TRUE ;

	if ( a_Handle == m_CompletionEvent.GetHandle () )
	{

DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nWait: Completed") );
)


		m_CompletionEvent.Process () ;
		a_Processed = TRUE ;
	}
	else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
	{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nTask Wait: Refreshing handles") );
)
		a_ThreadObject->Process () ;
		a_ThreadObject->ConstructEventContainer () ;
	}
	else
	{
		ProvAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
		if ( t_TaskObject )
		{
			a_ThreadObject->ConstructEventContainer () ;
			t_TaskObject->Process () ;
		}
		else
		{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Task") ) ;
)
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

BOOL ProvAbstractTaskObject :: WaitAcknowledgement ( BOOL a_Dispatch )
{
	BOOL t_Status = TRUE ;
	BOOL t_Processed = FALSE ;

	while ( t_Status && ! t_Processed )
	{
		ProvThreadObject *t_ThreadObject = ProvThreadObject :: GetThreadObject () ;
		ULONG t_TaskEventArrayLength = 0 ;
		HANDLE *t_TaskEventArray = NULL ;

		if ( t_ThreadObject && a_Dispatch )
		{
			ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
			t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

			if ( t_TaskArrayLength )
			{
				memcpy ( 
 
					& ( t_TaskEventArray [ 1 ] ) , 
					t_ThreadObject->GetEventHandles () ,
					t_TaskArrayLength * sizeof ( HANDLE ) 
				) ;		
			}

			t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;			
		}
		else
		{
			t_TaskEventArrayLength = 1 ;
			t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
			t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;
		}

		DWORD t_Event ;

		if ( a_Dispatch ) 
		{
			t_Event = MsgWaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout ,
				QS_ALLINPUT
			) ;
		}
		else
		{
			t_Event = WaitForMultipleObjects (

				t_TaskEventArrayLength ,
				t_TaskEventArray ,
				FALSE ,
				m_timeout 
			) ;
		}

		ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

		if ( t_Event == 0xFFFFFFFF )
		{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

			DWORD t_Error = GetLastError () ;
			t_Status = FALSE ;
		}
		else if ( t_Event == WAIT_TIMEOUT)
		{
			TimedOut();
		}
		if ( t_HandleIndex == t_TaskEventArrayLength )
		{
			BOOL t_DispatchStatus ;
			MSG t_Msg ;

			while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
			{
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
				{
					TranslateMessage ( & t_Msg ) ;
					DispatchMessage ( & t_Msg ) ;
				}

				BOOL t_Timeout = FALSE ;

				while ( !t_Timeout && t_Status && !t_Processed )
				{
					t_Event = WaitForMultipleObjects (

						t_TaskEventArrayLength ,
						t_TaskEventArray ,
						FALSE ,
						0
					) ;

					ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

					if ( t_Event == 0xFFFFFFFF )
					{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle") ) ;
)

						DWORD t_Error = GetLastError () ;
						t_Status = FALSE ;
					}
					else if ( t_Event == WAIT_TIMEOUT)
					{
						t_Timeout = TRUE ;
					}
					else if ( t_HandleIndex < t_TaskEventArrayLength )
					{
						HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
						t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
					}
					else
					{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)
						t_Status = FALSE ;
					}
				}
			}
		}
		else if ( t_HandleIndex < t_TaskEventArrayLength )
		{
			HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
			t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
		}
		else
		{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Handle index") ) ;
)

			t_Status = FALSE ;
		}

		delete [] t_TaskEventArray ;
	}

	return t_Status ;
}

BOOL ProvAbstractTaskObject :: WaitAcknowledgementDispatch ( ProvThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed )
{
	BOOL t_Status = TRUE ;

	if ( a_Handle == m_AcknowledgementEvent.GetHandle () )
	{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nWait: Completed") );
)

		m_AcknowledgementEvent.Process () ;
		a_Processed = TRUE ;
	}
	else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
	{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nTask Wait: Refreshing handles") );
)
		a_ThreadObject->Process () ;
		a_ThreadObject->ConstructEventContainer () ;
	}
	else
	{
		ProvAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
		if ( t_TaskObject )
		{
			a_ThreadObject->ConstructEventContainer () ;
			t_TaskObject->Process () ;
		}
		else
		{
DebugMacro8(

	CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine ( _TEXT(__FILE__),__LINE__,  _TEXT("\nProvAbstractTaskObject :: Illegal Task") ) ;
)
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

ProvTaskObject::ProvTaskObject ( 
	const TCHAR *a_GlobalTaskNameStart, 
	const TCHAR *a_GlobalTaskNameComplete ,
	const TCHAR *a_GlobalTaskNameAcknowledge,
	DWORD a_timeout

): ProvAbstractTaskObject(a_GlobalTaskNameComplete, a_GlobalTaskNameAcknowledge,a_timeout), m_Event(a_GlobalTaskNameStart)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtdefs.h ===
//***************************************************************************

//

//  NTEVTDEFS.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTDEFS_H
#define _NT_EVT_PROV_NTEVTDEFS_H

#define ELF_LOGFILE_READ             0x0001
#define ELF_LOGFILE_WRITE            0x0002
#define ELF_LOGFILE_CLEAR            0x0004
#define ELF_LOGFILE_START            0x0008
#define ELF_LOGFILE_STOP             0x000C
#define ELF_LOGFILE_CONFIGURE        0x0010
#define ELF_LOGFILE_BACKUP           0x0020

#define ELF_LOGFILE_ALL_ACCESS       (STANDARD_RIGHTS_REQUIRED       | \
                                         ELF_LOGFILE_READ            | \
                                         ELF_LOGFILE_WRITE           | \
                                         ELF_LOGFILE_CLEAR           | \
                                         ELF_LOGFILE_START           | \
                                         ELF_LOGFILE_STOP            | \
                                         ELF_LOGFILE_CONFIGURE)

#define ELF_LOGFILE_OBJECT_ACES		12            // Number of ACEs in this DACL
#define NT_EVTLOG_MAX_CLASSES		7	

#define SECURITY_MUTEX_NAME		L"Cimom NT Security API protector"
#define PERFORMANCE_MUTEX_NAME	L"WbemPerformanceDataMutex"

#define EVENTTHREADNAME			L"Eventlog Monitor"

BOOL ObtainedSerialAccess(CMutex* pLock);
void ReleaseSerialAccess(CMutex* pLock);

#define HKEYCLASSES		L"SOFTWARE\\Classes\\"

#define TYPE_ARRAY_LEN		6
#define RETENTION_ARRAY_LEN	3
typedef ULONG (*GetIndexFunc)(const wchar_t*, BOOL*);

#define WBEM_QUERY_LANGUAGE_SQL1 L"WQL"

#define LOGON_EVTID		2147489653
#define LOGON_SOURCE	L"eventlog"
#define LOGON_TIME		1800 //30 MINS

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define EVENT_CLASS		L"__InstanceCreationEvent"
#define SD_PROP			L"SECURITY_DESCRIPTOR"
#define TARGET_PROP		L"TargetInstance"
#define NTEVT_CLASS		L"Win32_NTLogEvent"
#define RECORD_PROP		L"RecordNumber"
#define	LOGFILE_PROP	L"Logfile"
#define EVTID_PROP		L"EventIdentifier"
#define EVTID2_PROP		L"EventCode"
#define SOURCE_PROP		L"SourceName"
#define TYPE_PROP		L"Type"
#define EVTTYPE_PROP	L"EventType"
#define CATEGORY_PROP	L"Category"
#define CATSTR_PROP		L"CategoryString"
#define GENERATED_PROP	L"TimeGenerated"
#define WRITTEN_PROP	L"TimeWritten"
#define COMPUTER_PROP	L"ComputerName"
#define USER_PROP		L"User"
#define MESSAGE_PROP	L"Message"
#define INSSTRS_PROP	L"InsertionStrings"
#define DATA_PROP		L"Data"
#define EVT_ENUM_QUAL	L"Values"
#define EVT_MAP_QUAL	L"ValueMap"

#define EVENTLOG_BASE	L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define	MSG_MODULE		L"EventMessageFile"
#define PARAM_MODULE	L"ParameterMessageFile"
#define PRIM_MODULE		L"PrimaryModule"
#define CAT_MODULE		L"CategoryMessageFile"
#define GUEST_ACCESS	L"RestrictGuestAccess"
#define SYSTEM_LOG		L"System"
#define SECURITY_LOG	L"Security"

// {F55C5B4C-517D-11d1-AB57-00C04FD9159E}
DEFINE_GUID(CLSID_CNTEventProviderClassFactory, 
0xf55c5b4c, 0x517d, 0x11d1, 0xab, 0x57, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);


#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_PROVSTATUSCODE   L"ProvStatusCode"
#define WBEM_PROPERTY_PROVSTATUSMESSAGE   L"Description"
#define WBEM_PROPERTY_PRIVNOTHELD   L"PrivilegesNotHeld"
#define WBEM_PROPERTY_PRIVREQUIRED   L"PrivilegesRequired"

#define CLASS_PROP		L"__CLASS"

#define EVTLOG_REG_FILE_VALUE		L"File"
#define EVTLOG_REG_RETENTION_VALUE	L"Retention"
#define EVTLOG_REG_MAXSZ_VALUE		L"MaxSize"
#define EVTLOG_REG_SOURCES_VALUE	L"Sources"

#define NTEVTLOG_CLASS				L"Win32_NTEventlogFile"
#define PROP_MAXSZ					L"MaxFileSize"
#define PROP_RETENTION				L"OverWriteOutDated"
#define PROP_LOGNAME				L"LogfileName"
#define PROP_NUMRECS				L"NumberOfRecords"
#define PROP_RETENTION_STR			L"OverWritePolicy"
#define PROP_SOURCES				L"Sources"

#define PROP_NAME					L"Name"

#define PROP_CS_CRE_CLASS			L"CSCreationClassName"
#define PROP_CRE_CLASS				L"CreationClassName"
#define PROP_FS_CRE_CLASS			L"FSCreationClassName"
#define PROP_FS_NAME				L"FSName"
#define VAL_FS_CRE_CLASS			L"Win32_FileSystem"

#ifdef VERSION_ISA_PROPERTY
#define PROP_VERSION				L"Version"
#endif

#define METHOD_RESOBJ				L"__Parameters"
#define METHOD_CLEAR				L"ClearEventlog"
#define METHOD_BACKUP				L"BackupEventlog"
#define METHOD_PARAM				L"ArchiveFileName"
#define METHOD_RESULT_PARAM			L"ReturnValue"

#define FILE_CHUNK_SZ				0x00010000
#define MAX_EVT_LOG_SZ				0xffff0000
#define MAX_EVT_AGE					365
#define EVT_NEVER_AGE				0xffffffff
#define EVT_UNITS_FROM_DAYS			(60*60*24)	//from days to seconds

#define CONFIG_CLASS		L"NTEventlogProviderConfig"
#define CONFIG_INSTANCE		L"NTEventlogProviderConfig=@"
#define COMP_CLASS			L"Win32_ComputerSystem"
#define LAST_BOOT_PROP		L"LastBootUpTime"
#define USER_CLASS			L"Win32_UserAccount"
#define ASSOC_LOGRECORD		L"Win32_NTLogEventLog"
#define ASSOC_USERRECORD	L"Win32_NTLogEventUser"
#define ASSOC_COMPRECORD	L"Win32_NTLogEventComputer"
#define REF_LOG				L"Log"
#define REF_REC				L"Record"
#define REF_USER			L"User"
#define REF_COMP			L"Computer"

#define PROP_DOMAIN			L"Domain"

#define PROP_START_LOG		CStringW(CStringW(NTEVTLOG_CLASS) + CStringW(L'.') + CStringW(PROP_NAME) + CStringW(L"=\""))
#define PROP_START_REC		CStringW(CStringW(NTEVT_CLASS) + CStringW(L'.') + CStringW(LOGFILE_PROP) + CStringW(L"=\""))
#define PROP_MID_REC		CStringW(CStringW(L"\",") + CStringW(RECORD_PROP) + CStringW(L'='))
#define PROP_START_COMP		CStringW(CStringW(COMP_CLASS) + CStringW(L".Name=\""))
#define PROP_START_USER		CStringW(CStringW(USER_CLASS) + CStringW(L".Domain=\""))
#define PROP_MID_USER		CStringW(L"\",Name=\"")

#define ENUM_INST_QUERY_START	CStringW(L"select * from ")
#define ENUM_INST_QUERY_MID		CStringW(L" where __CLASS = \"")

#define PROP_END_QUOTE		CStringW(L"\"")

// {D2E4F828-65E4-11d1-AB64-00C04FD9159E}
DEFINE_GUID(CLSID_CNTEventLocatorClassFactory, 
0xd2e4f828, 0x65e4, 0x11d1, 0xab, 0x64, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

// {FD4F53E0-65DC-11d1-AB64-00C04FD9159E}
DEFINE_GUID(CLSID_CNTEventInstanceProviderClassFactory, 
0xfd4f53e0, 0x65dc, 0x11d1, 0xab, 0x64, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

#endif //_NT_EVT_PROV_NTEVTDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtinst.h ===
//***************************************************************************

//

//  NTEVTINST.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTINST_H
#define _NT_EVT_PROV_NTEVTINST_H


#define WBEM_CLASS_EXTENDEDSTATUS	L"Win32_PrivilegesStatus" 

#define WBEM_TASKSTATE_START					0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT		0x100001

class WbemTaskObject
{
private:
protected:

	ULONG m_State ;
	WbemProvErrorObject m_ErrorObject ;

	ULONG m_RequestHandle ;
	ULONG m_OperationFlag ;
	IWbemClassObject *m_ClassObject ;
	IWbemClassObject *m_AClassObject ;
	IWbemObjectSink *m_NotificationHandler ;
	IWbemContext *m_Ctx ;
	CImpNTEvtProv *m_Provider ;

protected:

	void SetRequestHandle ( ULONG a_RequestHandle ) ;
	BOOL GetRequestHandle () ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetClassObject ( BSTR a_Class ) ;

public:

	static IWbemClassObject *g_ClassArray[NT_EVTLOG_MAX_CLASSES];
	static BOOL GetClassObject ( BSTR a_Class, BOOL a_bAmended, IWbemServices *a_Server,  IWbemContext *a_Ctx, IWbemClassObject **a_pClass ) ;

	WbemTaskObject ( 

		CImpNTEvtProv *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag ,
		IWbemContext *a_Ctx
	) ;

	virtual void Process() {}

	~WbemTaskObject () ;

	WbemProvErrorObject &GetErrorObject () ;

} ;

class ExecQueryAsyncEventObject;

class GetObjectAsyncEventObject : public WbemTaskObject
{
friend ExecQueryAsyncEventObject;
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	IWbemClassObject *m_Out;
	BOOL m_bIndicate;

	BOOL Dispatch_Record ( WbemProvErrorObject &a_ErrorObject );
	BOOL Get_Record ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey , KeyRef *a_RecordKey );
	BOOL Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject );
	BOOL Get_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey);
	BOOL Dispatch_LogRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Dispatch_UserRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Dispatch_ComputerRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Get_LogRecord ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_LogKey , KeyRef *a_RecordKey ) ;
	BOOL Get_UserRecord ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_UserKey , KeyRef *a_RecordKey ) ;
	BOOL Get_ComputerRecord ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_CompKey , KeyRef *a_RecordKey ) ;

protected:

	BOOL GetObject ( WbemProvErrorObject &a_ErrorObject ) ;


public:

	GetObjectAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx ,
		BOOL a_bIndicate = TRUE
	) ;

	~GetObjectAsyncEventObject () ;

	void Process () ;
} ;


class ExecMethodAsyncEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	wchar_t *m_Method ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	IWbemClassObject* m_InParamObject;
	BOOL m_bIndicateOutParam;
	IWbemClassObject* m_pOutClass;

	BOOL Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject );
	BOOL ExecMethod_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey);

protected:

	BOOL ExecMethod ( WbemProvErrorObject &a_ErrorObject ) ;

public:

	ExecMethodAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		wchar_t *a_ObjectPath ,
		wchar_t *a_MethodName,
		ULONG a_Flag ,
		IWbemClassObject *a_InParams ,		
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~ExecMethodAsyncEventObject () ;

	void Process () ;
} ;


class PutInstanceAsyncEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_InstObject ;

	BOOL Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject );

protected:

	BOOL PutInstance ( WbemProvErrorObject &a_ErrorObject ) ;


public:

	PutInstanceAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		IWbemClassObject *a_Inst , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~PutInstanceAsyncEventObject () ;

	void Process () ;
} ;

class ExecQueryAsyncEventObject : public WbemTaskObject, public QueryPreprocessor
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

	QueryPreprocessor::QuadState Compare(wchar_t *a_Operand1, wchar_t *a_Operand2, 
											DWORD a_Operand1Func, DWORD a_Operand2Func,
											WmiTreeNode &a_OperatorType);

	QueryPreprocessor::QuadState Compare(LONG a_Operand1, LONG a_Operand2 , 
											DWORD a_Operand1Func, DWORD a_Operand2Func,
											WmiTreeNode &a_OperatorType);

	QueryPreprocessor::QuadState CompareString(IWbemClassObject *a_ClassObject, BSTR a_PropertyName , 
												WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);

	QueryPreprocessor::QuadState CompareInteger(IWbemClassObject *a_ClassObject, BSTR a_PropertyName, 
												WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);

	QueryPreprocessor :: QuadState CompareDateTime (IWbemClassObject *a_ClassObject, BSTR a_PropertyName, 
												WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);

	HRESULT GetRecordsBetweenTimes(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname,
														  BOOL a_Generated, DWORD a_dwUpper, DWORD a_dwLower);

	HRESULT RecurseLogFile (WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet, LPCWSTR a_logname);
	HRESULT RecurseRecord (WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet, LPCWSTR a_logname);
	HRESULT DoAllInLogfile(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname, DWORD a_dwUpper, DWORD a_dwLower);
	HRESULT RecurseTime(WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet, LPCWSTR a_logname, BOOL a_Generated);
	BOOL CheckTime( const BSTR a_wszText, BOOL &a_IsLow, BOOL &a_IsHigh );

protected:

	BOOL ExecQuery ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL DispatchQuery ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_Record ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_EventLog ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_LogRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_UserRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_ComputerRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL OptimizeAssocQuery ( WbemProvErrorObject &a_ErrorObject , BSTR *a_ObjectPath);
	BOOL GenerateLogAssocs( WbemProvErrorObject &a_ErrorObject, const wchar_t* logPath,
								const wchar_t* logName, BOOL bVerifyLogname, BOOL *pbContinue = NULL);
	BOOL GenerateCompUserAssocs ( WbemProvErrorObject &a_ErrorObject, BOOL bComp );
	wchar_t* GetClassFromPath(wchar_t* path);

    // Query Processing Functions
    //============================
	QuadState InvariantEvaluate(void *a_Context, WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);
	WmiRangeNode *AllocInfiniteRangeNode(void *a_Context, BSTR a_PropertyName);
	virtual DWORD GetPriority ( BSTR a_PropertyName ) ;
	WmiTreeNode *AllocTypeNode (void *a_Context, BSTR a_PropertyName, 
								VARIANT &a_Variant,	WmiValueNode::WmiValueFunction a_PropertyFunction,
								WmiValueNode :: WmiValueFunction a_ConstantFunction, WmiTreeNode *a_Parent);

public:

	ExecQueryAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~ExecQueryAsyncEventObject () ;

	void Process () ;
} ;

#endif //_NT_EVT_PROV_NTEVTINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtprov.h ===
//***************************************************************************

//

//  NTEVTPROV.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTPROV_H
#define _NT_EVT_PROV_NTEVTPROV_H

class CEventProviderManager;

class CNTEventProvider : public IWbemEventProvider, public IWbemProviderInit, public IWbemEventProviderSecurity
{

private:

	IWbemServices*			m_pNamespace;
	IWbemObjectSink*		m_pEventSink;
	CEventProviderManager*	m_Mgr;
	LONG					m_ref;
	
	//copy constuctor not defined so not allowed!
	CNTEventProvider(CNTEventProvider&);
	void operator=(const CNTEventProvider&);


public:

		CNTEventProvider(CEventProviderManager* mgr);

	IWbemServices*		GetNamespace();
	IWbemObjectSink*	GetEventSink();
    void				AddRefAll();
    void				ReleaseAll();

		~CNTEventProvider();

	//globals
	//=======
	static ProvDebugLog* g_NTEvtDebugLog;
	static CMutex*		 g_secMutex;
	static PSID			 s_NetworkServiceSid;
	static PSID			 s_LocalServiceSid;
	static PSID			 s_AliasBackupOpsSid;
	static PSID			 s_AliasSystemOpsSid;
	static PSID			 s_AliasGuestsSid;
	static PSID			 s_LocalSystemSid;
	static PSID			 s_AliasAdminsSid;
	static PSID			 s_AnonymousLogonSid;
	static PSID			 s_WorldSid;

	static void AllocateGlobalSIDs();
	static void FreeGlobalSIDs();
	static BOOL GlobalSIDsOK();

	//interface methods
	//==================
    STDMETHODIMP ProvideEvents(
                IWbemObjectSink* pSink,
                LONG lFlags
            );

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);

	/* IWbemEventProviderSecurity methods */

	STDMETHODIMP AccessCheck( 
				LPCWSTR wszQueryLanguage,
				LPCWSTR wszQuery,
				LONG lSidLength,
				const BYTE __RPC_FAR *pSid);
};


#define DebugOut(a) { \
\
	if ( (NULL != CNTEventProvider::g_NTEvtDebugLog) && CNTEventProvider::g_NTEvtDebugLog->GetLogging () && ( CNTEventProvider::g_NTEvtDebugLog->GetLevel () > 0 ) ) \
	{ \
		{a ; } \
	} \
} 


#endif //_NT_EVT_PROV_NTEVTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtlogr.h ===
//***************************************************************************

//

//  NTEVTLOGR.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_EVTLOGR_H
#define _NT_EVT_PROV_EVTLOGR_H

template <typename T> 
class ScopeLock
{
private: 
	T & t_;
public:
	ScopeLock(T & t):t_(t){ t_.Lock(); }
	~ScopeLock(){ t_.Unlock(); }	
};

class MyPSID
{
public:

	PSID m_SID;
	MyPSID(PSID psid = NULL) { m_SID = psid; }
};

template <> inline void AFXAPI  DestructElements<HINSTANCE> (HINSTANCE* ptr_e, int x)
{
	//x is always one for a CMap!
	if (*ptr_e != NULL)
	{
		FreeLibrary(*ptr_e);
	}
}

template <> inline void AFXAPI  DestructElements<MyPSID> (MyPSID* ptr_e, int x)
{
	//x is always one for a CMap!
	if ((ptr_e != NULL) && (ptr_e->m_SID != NULL))
	{
		delete ptr_e->m_SID;
	}
}

template <> inline UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
{
	return HashKeyLPCWSTR(key);
}

template <> inline UINT AFXAPI HashKey<MyPSID> (MyPSID key)
{
	UINT ret = 0;
	UCHAR* tmp = (UCHAR*) key.m_SID;
	DWORD sidlen = GetLengthSid(key.m_SID);
	
	for (DWORD x = 0; x < sidlen; x++)
	{
		ret = (ret<<5) + ret + *tmp++;
	}

	return ret;
}

template <> inline BOOL AFXAPI CompareElements<MyPSID, MyPSID> (const MyPSID* p1, const MyPSID* p2)
{
	return EqualSid(p1->m_SID, p2->m_SID);
}

class CSIDMap : public CMap<MyPSID, MyPSID, CStringW, LPCWSTR>
{
private:

	CCriticalSection m_Lock;


public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }

};

class CDllMap : public CMap<CStringW, LPCWSTR, HINSTANCE, HINSTANCE>
{
private:

	CCriticalSection m_Lock;


public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

//taken from the NT eventlog private include (MAXLIST)
#define MAX_NUM_OF_INS_STRS 256

class CEventlogRecord
{
private:

	CStringW	m_Logfile;
	DWORD		m_Record;
	DWORD		m_EvtID;
	CStringW	m_SourceName;
	CStringW	m_Type;
	WORD		m_Category;
	CStringW	m_CategoryString;
	CStringW	m_TimeGen;
	CStringW	m_TimeWritten;
	CStringW	m_CompName;
	CStringW	m_User;
	CStringW	m_Message;
	wchar_t*	m_InsStrs[MAX_NUM_OF_INS_STRS];
	LONG		m_NumStrs;
	CStringW	m_TypeArray[TYPE_ARRAY_LEN];
	UCHAR*		m_Data;
	LONG		m_DataLen;
	BYTE		m_EvtType;
	
	IWbemClassObject* m_Obj;
	IWbemClassObject* m_pClass;
	IWbemClassObject *m_pAClass;
	IWbemServices* m_nspace;
	
	BOOL		m_Valid;

	static CDllMap sm_dllMap;
	static CSIDMap sm_usersMap;

	BOOL		Init(const EVENTLOGRECORD* pEvt);
	BOOL		SetProperty(wchar_t* prop, CStringW val);
	BOOL		SetProperty(wchar_t* prop, DWORD val);
	void		SetUser(PSID psidUserSid);
	void		SetMessage();
	void		SetTimeStr(CStringW& str, DWORD timeVal);
	void		SetType(WORD type);
	BOOL		GetInstance();
	ULONG		CheckInsertionStrings(HKEY hk, HKEY hkPrimary);
	CStringW	GetMappedGUID(LPCWSTR strDcName, LPCWSTR strGuid);
	
	static HINSTANCE	GetDll(CStringW path);
	static ULONG		GetIndex(wchar_t* indexStr, BOOL* bError);

	HRESULT	ReplaceStringInsert	(
									LPWSTR* ppwszBuf,
									ULONG	nOffset,
									LPWSTR*	ppwszReplacement,
									ULONG*	pulSize
								);

	HRESULT	ReplaceParameterInsert	(
										HINSTANCE&	hParamModule,
										CStringW&	paramModule,
										LPWSTR* ppwszBuf,
										ULONG	nOffset,
										LPWSTR*	ppwszReplacement,
										ULONG*	pulSize
									);

	HRESULT	ReplaceSubStr	(
								LPCWSTR pwszToInsert,
								LPWSTR *ppwszBuf,
								ULONG  nOffset,
								ULONG  nCharsOld,
								LPWSTR *pptrReplacement,
								ULONG  *pulSize
							);

public:

	static BOOL		SetEnumArray(IWbemClassObject* pClass, wchar_t* propname, CStringW* strArray, ULONG strArrayLen, GetIndexFunc IndexFunc);
	static void		EmptyDllMap();
	static void		EmptyUsersMap();
	static CStringW	GetUser(PSID userSid);

		CEventlogRecord(const wchar_t* logfile, const EVENTLOGRECORD* pEvt, IWbemServices* ns,
						IWbemClassObject* pClass = NULL, IWbemClassObject* pAClass = NULL);

	BOOL	GenerateInstance(IWbemClassObject** ppInst);
	BOOL	IsValid() { return m_Valid; }

		~CEventlogRecord();
};


#endif //_NT_EVT_PROV_EVTLOGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtlogf.h ===
//***************************************************************************

//

//  NTEVTLOGF.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_EVTLOGF_H
#define _NT_EVT_PROV_EVTLOGF_H

class CEventlogFileAttributes
{
protected:

	CStringW						m_logname;
	CStringW						m_logpath;
	DWORD						m_retention;
	DWORD						m_fileSz;
	CArray<CStringW*, CStringW*>	m_sources;

	DWORD	ReadRegistry();
	void	SetRetentionStr(IWbemClassObject *pClassObj, IWbemClassObject *pInstObj, DWORD dwVal);
	BOOL	SetSuperClassProperties(IWbemClassObject *pInst);

static	ULONG	GetIndex(wchar_t *indexStr, BOOL *bError);

public:

		CEventlogFileAttributes(const wchar_t *log);
	
	DWORD	UpdateRegistry(IWbemClassObject *pInst);
	DWORD	EventLogOperation(const wchar_t *archive, BOOL bClear,
								WbemProvErrorObject &a_ErrorObject, BOOL &bSuccess);
	BOOL	GenerateInstance(IWbemClassObject *pClassObj, IWbemClassObject* pAClassObj, IWbemClassObject **ppInst);

		~CEventlogFileAttributes();
	
};

class CEventLogFile
{
private:

	static CStringW	ExpandFileName ( const wchar_t *filepath ) ;
	static BOOL		QueryRegForFileName(HKEY hk_Log, const wchar_t *valname, wchar_t **res, DWORD *dwType);

protected:

	HANDLE	m_hEvtLog;
	CStringW	m_EvtLogName;
	BOOL	m_bValid;
	BOOL	m_bBuffer;
	DWORD	m_BuffLen;
	DWORD	m_Reason;
	BYTE	*m_Buffer;
	CCriticalSection m_LogLock;


public:


		CEventLogFile(const WCHAR *logname, BOOL bVerify);

	void	ReadLastRecord();
	BOOL	GetLastRecordID(DWORD &rec, DWORD &numrecs);
	DWORD	ReadRecord(DWORD recID, DWORD *dwBytesRead = NULL, BOOL b_Back = FALSE);
	BOOL	IsValid() {return m_bValid;}
	BOOL	IsValidBuffer() {return m_bBuffer;}
	DWORD	ReadFirstRecord();
	CStringW GetLogName() { return m_EvtLogName; }
	DWORD	FindOldEvent(DWORD evtID, const wchar_t *source, DWORD *recID,time_t offset = 0);
	BYTE*	GetBuffer() { return m_Buffer; }
	DWORD	GetBufferLen() { return m_BuffLen; }
	DWORD	GetReason() { return m_Reason; }

	virtual void	RefreshHandle();

	static CStringW	GetLogName(const wchar_t *file_name);
	static CStringW	GetFileName(HKEY hk_Log, const wchar_t *valname = EVTLOG_REG_FILE_VALUE);
	static DWORD	GetFileNames(HKEY hk_Log, CStringW **names, const wchar_t *valname = MSG_MODULE);
	static BOOL		ms_bSetPrivilege;
	static BOOL		SetSecurityLogPrivilege(BOOL bProcess = FALSE, LPCWSTR privName = SE_SECURITY_NAME);
	static HANDLE	OpenLocalEventLog(LPCWSTR a_log, DWORD *a_Reason);

	virtual ~CEventLogFile();

};


class CMonitoredEventLogFile : public CEventLogFile, public ProvTaskObject
{
private:
	
	CEventProviderManager	*m_parent; 
	IWbemClassObject		*m_Class;
	DWORD					m_RecID;
	VARIANT					m_VpsdSelfRel;


	BOOL SetEventDescriptor();

public:

		CMonitoredEventLogFile(CEventProviderManager *parent, const wchar_t *logname);

	void	SetProcessRecord(DWORD recID) { m_RecID = recID; }
	void	Process();
	void	RefreshHandle();
	BOOL	GenerateInstance(IWbemClassObject **ppEvtInst, IWbemClassObject *pEmbedObj);

		~CMonitoredEventLogFile();

};


#endif //_NT_EVT_PROV_EVTLOGF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtthrd.h ===
//***************************************************************************

//

//  NTEVTTHRD.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTTHRD_H
#define _NT_EVT_PROV_NTEVTTHRD_H

class CNTEventProvider;
class CEventLogMonitor;
class CEventProviderManager;
class CMonitoredEventLogFile;

class CControlObjectMap : public CMap< UINT_PTR, UINT_PTR, CNTEventProvider*, CNTEventProvider* >
{
private:

	UINT HashKey(UINT_PTR key) { return key; }

public:
	CCriticalSection m_Lock;
	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

					
class CEventLogMonitor : public ProvThreadObject
{
private:

	void					Initialise();
	void					Uninitialise();
	void					TimedOut();

	CEventProviderManager*	m_pParent;
	BOOL					m_bMonitoring;
	static const DWORD		m_PollTimeOut;
	CMonitoredEventLogFile** m_Logs;
	ULONG					m_LogCount;
	CArray<CStringW*, CStringW*> m_LogNames;
	LONG					m_Ref;

public:

		CEventLogMonitor(CEventProviderManager* parentptr, CArray<CStringW*, CStringW*>& logs);

	void	Poll();
	void	StartMonitoring();
	BOOL	IsMonitoring() { return m_bMonitoring; }
	LONG	AddRef();
	LONG	Release();

		~CEventLogMonitor();
};

class CEventProviderManager
{
private:

	CControlObjectMap	m_ControlObjects;
	CEventLogMonitor**	m_monitorArray;
	CCriticalSection	m_MonitorLock;
	CStringW			m_BootTimeString;
	BOOL				m_IsFirstSinceLogon;
	BOOL InitialiseMonitorArray();
	void DestroyMonitorArray();
	BSTR GetLastBootTime();

public:


		CEventProviderManager();

	void	SendEvent(IWbemClassObject* evtObj);
	BOOL	Register(CNTEventProvider* prov);
	void	UnRegister(CNTEventProvider* prov);
	BOOL	IsFirstSinceLogon() { return m_IsFirstSinceLogon; }
	void	SetFirstSinceLogon(IWbemServices *ns, IWbemContext *pCtx);

	IWbemServices* GetNamespacePtr();
		
		~CEventProviderManager();

};

#endif //_NT_EVT_PROV_NTEVTTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtserv.h ===
//***************************************************************************

//

//  NTEVTSERV.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTSERV_H
#define _NT_EVT_PROV_NTEVTSERV_H

typedef 
enum tag_WBEMPROVSTATUS
{

	WBEM_PROV_NO_ERROR							= 0,
	WBEM_PROV_S_NO_ERROR							= 0,
	WBEM_PROV_S_NO_MORE_DATA						= 0x40001,
	WBEM_PROV_S_ALREADY_EXISTS					= WBEM_PROV_S_NO_MORE_DATA + 1,
	WBEM_PROV_S_NOT_FOUND						= WBEM_PROV_S_ALREADY_EXISTS + 1,
	WBEM_PROV_S_RESET_TO_DEFAULT					= WBEM_PROV_S_NOT_FOUND + 1,
	WBEM_PROV_E_FAILED							= 0x80041001,
	WBEM_PROV_E_NOT_FOUND						= WBEM_PROV_E_FAILED + 1,
	WBEM_PROV_E_ACCESS_DENIED					= WBEM_PROV_E_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_FAILURE					= WBEM_PROV_E_ACCESS_DENIED + 1,
	WBEM_PROV_E_TYPE_MISMATCH					= WBEM_PROV_E_PROVIDER_FAILURE + 1,
	WBEM_PROV_E_OUT_OF_MEMORY					= WBEM_PROV_E_TYPE_MISMATCH + 1,
	WBEM_PROV_E_INVALID_CONTEXT					= WBEM_PROV_E_OUT_OF_MEMORY + 1,
	WBEM_PROV_E_INVALID_PARAMETER				= WBEM_PROV_E_INVALID_CONTEXT + 1,
	WBEM_PROV_E_NOT_AVAILABLE					= WBEM_PROV_E_INVALID_PARAMETER + 1,
	WBEM_PROV_E_CRITICAL_ERROR					= WBEM_PROV_E_NOT_AVAILABLE + 1,
	WBEM_PROV_E_INVALID_STREAM					= WBEM_PROV_E_CRITICAL_ERROR + 1,
	WBEM_PROV_E_NOT_SUPPORTED					= WBEM_PROV_E_INVALID_STREAM + 1,
	WBEM_PROV_E_INVALID_SUPERCLASS				= WBEM_PROV_E_NOT_SUPPORTED + 1,
	WBEM_PROV_E_INVALID_NAMESPACE				= WBEM_PROV_E_INVALID_SUPERCLASS + 1,
	WBEM_PROV_E_INVALID_OBJECT					= WBEM_PROV_E_INVALID_NAMESPACE + 1,
	WBEM_PROV_E_INVALID_CLASS					= WBEM_PROV_E_INVALID_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_FOUND				= WBEM_PROV_E_INVALID_CLASS + 1,
	WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION	= WBEM_PROV_E_PROVIDER_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_LOAD_FAILURE			= WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_PROV_E_INITIALIZATION_FAILURE			= WBEM_PROV_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_PROV_E_TRANSPORT_FAILURE				= WBEM_PROV_E_INITIALIZATION_FAILURE + 1,
	WBEM_PROV_E_INVALID_OPERATION				= WBEM_PROV_E_TRANSPORT_FAILURE + 1,
	WBEM_PROV_E_INVALID_QUERY					= WBEM_PROV_E_INVALID_OPERATION + 1,
	WBEM_PROV_E_INVALID_QUERY_TYPE				= WBEM_PROV_E_INVALID_QUERY + 1,
	WBEM_PROV_E_ALREADY_EXISTS					= WBEM_PROV_E_INVALID_QUERY_TYPE + 1,
	WBEM_PROV_E_OVERRIDE_NOT_ALLOWED				= WBEM_PROV_E_ALREADY_EXISTS + 1,
	WBEM_PROV_E_PROPAGATED_QUALIFIER				= WBEM_PROV_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_PROV_E_UNEXPECTED						= WBEM_PROV_E_PROPAGATED_QUALIFIER + 1,
	WBEM_PROV_E_ILLEGAL_OPERATION				= WBEM_PROV_E_UNEXPECTED + 1,
	WBEM_PROV_E_CANNOT_BE_KEY					= WBEM_PROV_E_ILLEGAL_OPERATION + 1,
	WBEM_PROV_E_INCOMPLETE_CLASS					= WBEM_PROV_E_CANNOT_BE_KEY + 1,
	WBEM_PROV_E_INVALID_SYNTAX					= WBEM_PROV_E_INCOMPLETE_CLASS + 1,
	WBEM_PROV_E_NONDECORATED_OBJECT				= WBEM_PROV_E_INVALID_SYNTAX + 1,
	WBEM_PROV_E_READ_ONLY						= WBEM_PROV_E_NONDECORATED_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_CAPABLE				= WBEM_PROV_E_READ_ONLY + 1,
	WBEM_PROV_E_CLASS_HAS_CHILDREN				= WBEM_PROV_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_PROV_E_CLASS_HAS_INSTANCES				= WBEM_PROV_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_PROV_E_INVALID_PROPERTY					= WBEM_PROV_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_PROV_E_INVALID_QUALIFIER				= WBEM_PROV_E_INVALID_PROPERTY + 1 ,
	WBEM_PROV_E_INVALID_PATH						= WBEM_PROV_E_INVALID_QUALIFIER + 1 ,
	WBEM_PROV_E_INVALID_PATHKEYPARAMETER			= WBEM_PROV_E_INVALID_PATH + 1 ,
	WBEM_PROV_E_MISSINGPATHKEYPARAMETER 			= WBEM_PROV_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_INVALID_KEYORDERING				= WBEM_PROV_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER		= WBEM_PROV_E_INVALID_KEYORDERING + 1 ,
	WBEM_PROV_E_MISSINGKEY						= WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORT				= WBEM_PROV_E_MISSINGKEY + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORTCONTEXT			= WBEM_PROV_E_INVALID_TRANSPORT + 1 ,
	WBEM_PROV_E_TRANSPORT_ERROR					= WBEM_PROV_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_PROV_E_TRANSPORT_NO_RESPONSE			= WBEM_PROV_E_TRANSPORT_ERROR + 1 ,
	WBEM_PROV_E_NOWRITABLEPROPERTIES				= WBEM_PROV_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_PROV_E_NOREADABLEPROPERTIES				= WBEM_PROV_E_NOWRITABLEPROPERTIES + 1 

} WBEMPROVSTATUS;


class WbemProvErrorObject 
{
private:

	enum tag_ProvPrivileges
	{
		PROV_PRIV_SECURITY = 1,
		PROV_PRIV_BACKUP = 2
	} PROVPRIVILEGES;

	wchar_t *m_provErrorMessage ;
	WBEMPROVSTATUS m_provErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;
	BOOL m_privilegeFailed;
	DWORD m_PrivsReqd;
	DWORD m_PrivsFailed;

	BOOL SetPrivVariant ( VARIANT &a_V, DWORD dwVal );

protected:
public:


	WbemProvErrorObject () : m_privilegeFailed ( FALSE ) ,
							m_provErrorMessage ( NULL ) ,
							m_wbemErrorStatus ( WBEM_NO_ERROR ) ,
							m_provErrorStatus ( WBEM_PROV_NO_ERROR ),
							m_PrivsReqd (0),
							m_PrivsFailed (0) {}
	virtual ~WbemProvErrorObject () { delete [] m_provErrorMessage ; }

	void SetStatus ( WBEMPROVSTATUS a_provErrorStatus )
	{
		m_provErrorStatus = a_provErrorStatus ;
	} 

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	}

	void SetMessage ( wchar_t *a_provErrorMessage )
	{
		delete [] m_provErrorMessage ;
		m_provErrorMessage = UnicodeStringDuplicate ( a_provErrorMessage ) ;
	}

	void SetPrivilegeFailed ( BOOL a_PrivilegeFailed = TRUE )
	{
		m_privilegeFailed = a_PrivilegeFailed;
	}

	void SetBackupPrivRequired () { m_PrivsReqd = m_PrivsReqd | PROV_PRIV_BACKUP; }
	void SetSecurityPrivRequired () { m_PrivsReqd = m_PrivsReqd | PROV_PRIV_SECURITY; }
	void SetBackupPrivFailed () { m_PrivsFailed = m_PrivsFailed | PROV_PRIV_BACKUP; }
	void SetSecurityPrivFailed () { m_PrivsFailed = m_PrivsFailed | PROV_PRIV_SECURITY; }

	BOOL SetPrivRequiredVariant ( VARIANT &a_V ) { return SetPrivVariant(a_V, m_PrivsReqd); }
	BOOL SetPrivFailedVariant ( VARIANT &a_V ) { return SetPrivVariant(a_V, m_PrivsFailed); }

	wchar_t *GetMessage () { return m_provErrorMessage ; } ;
	WBEMPROVSTATUS GetStatus () { return m_provErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
	BOOL GetPrivilegeFailed () { return m_privilegeFailed ; }
} ;

class CImpNTEvtProv : public IWbemServices, public IWbemProviderInit
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_NotifyLock ;
	CCriticalSection m_ExtendedNotifyLock ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;

	wchar_t *m_localeId ;

	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

protected:
public:

	CImpNTEvtProv () ;
    ~CImpNTEvtProv () ;

	// Implementation

	IWbemServices *GetServer () ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateExtendedNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	BOOL CreateNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetExtendedNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	static HRESULT GetImpersonation();

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);
        
} ;

#endif //_NT_EVT_PROV_NTEVTSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\nteventprovider\include\provthrd.h ===
//***************************************************************************

//

//  PROVTHRD.H

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROVTHREAD_PROVTHRD_H__
#define __PROVTHREAD_PROVTHRD_H__

#include <Allocator.h>
#include <Queue.h>
#include <BasicTree.h>

extern WmiAllocator g_Allocator ;

class ProvThreadObject ;
class ProvAbstractTaskObject ;
class ProvTaskObject ;

typedef WmiBasicTree <HANDLE,ProvEventObject *> ScheduleReapContainer ;
typedef WmiBasicTree <HANDLE,ProvEventObject *> :: Iterator ScheduleReapContainerIterator ;

typedef WmiBasicTree <DWORD,ProvThreadObject *> ThreadContainer ;
typedef WmiBasicTree <DWORD,ProvThreadObject *> :: Iterator ThreadContainerIterator ;

typedef WmiQueue <ProvAbstractTaskObject *,8> TaskQueue ;

class ProvThreadObject : private ProvEventObject
{
friend ProvAbstractTaskObject ;
friend BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
) ;

public:

	static LONG s_ReferenceCount ;

private:

// Mutual exclusion mechanism

	static CStaticCriticalSection s_Lock ;

	ScheduleReapContainer m_ScheduleReapContainer ;

// Thread Name

	TCHAR *m_ThreadName ;

// Terminate thread event

	ProvEventObject m_ThreadTerminateEvent ;

// TaskObject created if a PostSignalThreadShutdown is called

	ProvAbstractTaskObject *m_pShutdownTask ;

// Thread Initialization Event

	HANDLE m_ThreadInitialization ;

// thread information

	ULONG m_ThreadId ;
	HANDLE m_ThreadHandle ;
	DWORD m_timeout;

// list of task objects associated with thread object

	TaskQueue m_TaskQueue ;

// Evict thread from process

	void TerminateThread () ;

// Attach thread to global list of threads

	BOOL RegisterThread () ;

// Remove thread from global list of threads

	BOOL RemoveThread () ;

private:

// global list of thread objects keyed on thread identifier

	static ThreadContainer s_ThreadContainer ;

	HANDLE *m_EventContainer ;
	ULONG m_EventContainerLength ;

	HANDLE *GetEventHandles () ;
	ULONG GetEventHandlesSize () ;

	void ConstructEventContainer () ;

	void Process () ;
	BOOL Wait () ;

	ProvAbstractTaskObject *GetTaskObject ( HANDLE &eventHandle ) ;

	BOOL WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated ) ;

private:

// Thread entry point

	static void _cdecl ThreadExecutionProcedure ( void *threadParameter ) ;

// Attach Process

	static void ProcessAttach () ;

// Detach Process

	static void ProcessDetach ( BOOL a_ProcessDetaching = FALSE ) ;

	HANDLE *GetThreadHandleReference () { return &m_ThreadHandle ; }

protected:
public:

	ProvThreadObject ( const TCHAR *a_ThreadName = NULL, DWORD a_timeout = INFINITE ) ;

	void BeginThread();

	virtual ~ProvThreadObject () ;

	BOOL WaitForStartup () ;

	void SignalThreadShutdown () ;
	void PostSignalThreadShutdown () ;

// Get thread information

	ULONG GetThreadId () { return m_ThreadId ; }
	HANDLE GetThreadHandle () { return m_ThreadHandle ; }

	BOOL ScheduleTask ( ProvAbstractTaskObject &a_TaskObject ) ;
	BOOL ReapTask ( ProvAbstractTaskObject &a_TaskObject ) ;

	virtual void Initialise () {} ;
	virtual void Uninitialise () {} ;
	virtual void TimedOut() {} ;

// Get Thread object associated with current thread

	static ProvThreadObject *GetThreadObject () ;

	static BOOL Startup () ;
	static void Closedown() ;

} ;

class ProvAbstractTaskObject 
{
friend ProvThreadObject ;
private:

// list of thread objects keyed on thread identifier

	ThreadContainer m_ThreadContainer ;

	CCriticalSection m_Lock ;

	ProvEventObject m_CompletionEvent ;
	ProvEventObject m_AcknowledgementEvent ;
	HANDLE m_ScheduledHandle;
	DWORD m_timeout;

	BOOL WaitDispatch ( ProvThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;
	BOOL WaitAcknowledgementDispatch ( ProvThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;

	void AttachTaskToThread ( ProvThreadObject &a_ThreadObject ) ;
	void DetachTaskFromThread ( ProvThreadObject &a_ThreadObject ) ;

protected:

	ProvAbstractTaskObject ( 

		const TCHAR *a_GlobalTaskNameComplete = NULL, 
		const TCHAR *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	virtual HANDLE GetHandle() = 0;

public:

	virtual ~ProvAbstractTaskObject () ;

	virtual void Process () { Complete () ; }
	virtual void Exec () {} ;
	virtual void Complete () { m_CompletionEvent.Set () ; }
	virtual BOOL Wait ( BOOL a_Dispatch = FALSE ) ;
	virtual void Acknowledge () { m_AcknowledgementEvent.Set () ; } 
	virtual BOOL WaitAcknowledgement ( BOOL a_Dispatch = FALSE ) ;
	virtual void TimedOut() {} ;
} ;


class ProvTaskObject : public ProvAbstractTaskObject 
{
private:
	ProvEventObject m_Event;
protected:
public:

	ProvTaskObject ( 

		const TCHAR *a_GlobalTaskNameStart = NULL , 
		const TCHAR *a_GlobalTaskNameComplete = NULL,
		const TCHAR *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	~ProvTaskObject () {} ;
	void Exec () { m_Event.Set(); }
	HANDLE GetHandle () { return m_Event.GetHandle() ; }
} ;

template <typename FT, FT F, BOOL Condition_> class VoidOnDeleteIf 
{
	private:
	BOOL	Condition_;
	BOOL	bExec;

	public:
	VoidOnDeleteIf ( ): bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		if ( Condition_ )
		{
			F ( );
			bExec = TRUE;
		}
	}

	~VoidOnDeleteIf ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template <typename FT, FT F, BOOL const &Condition_> class VoidOnDeleteIfNot 
{
	private:
	BOOL	bExec;

	public:
	VoidOnDeleteIfNot ( ): bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		if ( !Condition_ )
		{
			F ( );
			bExec = TRUE;
		}
	}

	~VoidOnDeleteIfNot ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template <typename T, typename FT, FT F> class ProvOnDelete
{
	private:
	T		Val_;
	BOOL	bExec;

	public:
	ProvOnDelete ( T Val ): Val_ ( Val ), bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		F(Val_);
		bExec = TRUE;
	}

	~ProvOnDelete ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template<class T> class CProvFreeMe
{
	protected:
    T* m_p;

	public:
    CProvFreeMe(T* p) : m_p(p){}
    ~CProvFreeMe() {free ( m_p );}
};

template<class T> class CProvDeleteMe
{
	protected:
    T* m_p;

	public:
    CProvDeleteMe(T* p) : m_p(p){}
    ~CProvDeleteMe() {delete m_p;}
};

template<class T> class CProvDeleteMeArray
{
	protected:
    T* m_p;

	public:
    CProvDeleteMeArray(T* p) : m_p(p){}
    ~CProvDeleteMeArray() {delete [] m_p;}
};

#ifndef	__WAITEX__
#define	__WAITEX__

template < typename T, typename FT, FT F, int iTime >
class WaitException
{
	public:
	WaitException ( T Val_ )
	{
		BOOL bResult = FALSE;
		while ( ! bResult )
		{
			try
			{
				F ( Val_ );
				bResult = TRUE;
			}
			catch ( ... )
			{
			}

			if ( ! bResult )
			{
				::Sleep ( iTime );
			}
		}
	}
};

#endif	__WAITEX__

#endif //__PROVTHREAD_PROVTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\globals.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <corepol.h>

#include <Allocator.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <HashTable.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Framework Instance provider 

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingfac.h>
#include <dllunreg.h>
 
HMODULE ghModule ;

//============

// {734AC5AE-68E1-4fb5-B8DA-1D92F7FC6661}
DEFINE_GUID(CLSID_CPINGPROVIDER, 
0x734ac5ae, 0x68e1, 0x4fb5, 0xb8, 0xda, 0x1d, 0x92, 0xf7, 0xfc, 0x66, 0x61);


//Count number of objects and number of locks.
long g_cLock = 0 ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid, 
	REFIID riid, 
	PPVOID ppv
)
{
	HRESULT hr = E_FAIL;
    SetStructuredExceptionHandler seh;

    try
    {
		CPingProviderClassFactory *pObj = NULL;

		if ( CLSID_CPINGPROVIDER == rclsid )
		{
			pObj = new CPingProviderClassFactory () ;
			hr = pObj->QueryInterface(riid, ppv);

			if (FAILED(hr))
			{
				delete pObj;
			}
		}
    }
    catch(Structured_Exception e_SE)
    {
        hr = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        hr = E_OUTOFMEMORY;
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
    }

    return hr ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    // It is OK to unload if there are no objects or locks on the 
    // class factory.
    SCODE sc = S_FALSE;
    SetStructuredExceptionHandler seh;

    try
    {
		CCritSecAutoUnlock t_lock( & CPingProvider::s_CS ) ;

		if ( ( 0 == CPingProviderClassFactory::s_LocksInProgress ) &&
			( 0 == CPingProviderClassFactory::s_ObjectsInProgress ) 
		)
		{
			CPingProvider::Global_Shutdown();
			sc = S_OK;
		}
    }
    catch(Structured_Exception e_SE)
    {
        sc = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        sc = E_OUTOFMEMORY;
    }
    catch(...)
    {
        sc = E_UNEXPECTED;
    }

    return sc;
}

STDAPI DllRegisterServer(void)
{   
    SetStructuredExceptionHandler seh;

    try
    {
		HRESULT t_status;

		t_status = RegisterServer( _T("WBEM Ping Provider"), CLSID_CPINGPROVIDER ) ;
		if( NOERROR != t_status )
		{
			return t_status ;  
		}
		
		return NOERROR;
	}
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
 		HRESULT t_status;

		t_status = UnregisterServer( CLSID_CPINGPROVIDER ) ;
		if( NOERROR != t_status )
		{
			return t_status ;  
		}
		
		return NOERROR;
	}
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstDLL,		// handle to dll module
    DWORD fdwReason,		// reason for calling function
    LPVOID lpReserved		// reserved
)
{
    BOOL bRet = TRUE;
    SetStructuredExceptionHandler seh;

    try
    {
		// Perform actions based on the reason for calling.
		switch( fdwReason ) 
		{ 
			case DLL_PROCESS_ATTACH:
			{
		// TO DO: Consider adding DisableThreadLibraryCalls().

			 // Initialize once for each new process.
			 // Return FALSE to fail DLL load.
				DisableThreadLibraryCalls(hInstDLL);
				ghModule = hInstDLL ;
				InitializeCriticalSection(& CPingProvider::s_CS);
	/*
	 *	Use the global process heap for this particular boot operation
	 */

				WmiAllocator t_Allocator ;
				WmiStatusCode t_StatusCode = t_Allocator.New (

					( void ** ) & CPingProvider::s_Allocator ,
					sizeof ( WmiAllocator ) 
				) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					:: new ( ( void * ) CPingProvider::s_Allocator ) WmiAllocator ;

					t_StatusCode = CPingProvider::s_Allocator->Initialize () ;

					if ( t_StatusCode != e_StatusCode_Success )
					{
						t_Allocator.Delete ( ( void * ) CPingProvider::s_Allocator	) ;
						CPingProvider::s_Allocator = NULL;
						bRet = FALSE ;
					}
				}
				else
				{
					bRet = FALSE ;
					CPingProvider::s_Allocator = NULL;
				}

			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
		/*
		 *	Use the global process heap for this particular boot operation
		 */
			}
			break;

			case DLL_PROCESS_DETACH:
			{
			 // Perform any necessary cleanup.
				if (CPingProvider::s_Allocator)
				{
					WmiAllocator t_Allocator ;
					t_Allocator.Delete ( ( void * ) CPingProvider::s_Allocator	) ;
				}

				DeleteCriticalSection(& CPingProvider::s_CS);
			}
			break;
		}
	}
    catch(Structured_Exception e_SE)
    {
        bRet = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        bRet = FALSE;
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet ;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\pingget.cpp ===
/******************************************************************

   pingget.CPP



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>


CPingGetAsync::CPingGetAsync (

	CPingProvider *a_Provider , 
	wchar_t *a_ObjectPath , 
	ULONG a_Flag , 
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx
): 	m_ObjectPath(NULL),
	m_ParsedObjectPath (NULL),
	CPingTaskObject (a_Provider, a_NotificationHandler, a_Ctx)
{
	if (a_ObjectPath != NULL)
	{
		int t_len = wcslen(a_ObjectPath);

		if (t_len > 0)
		{
			m_ObjectPath = new WCHAR[t_len+1];
			m_ObjectPath[t_len] = L'\0';
			wcsncpy(m_ObjectPath, a_ObjectPath, t_len);
		}
	}
}

CPingGetAsync::~CPingGetAsync ()
{
	if (m_ObjectPath)
	{
		delete [] m_ObjectPath ;
	}

	if (m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath ;
	}
}

BOOL CPingGetAsync::GetObject ()
{
	InterlockedIncrement(&m_PingCount);
	BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		BOOL bClass = TRUE;

		if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , PROVIDER_NAME_CPINGPROVIDER) == 0 )
		{
			IWbemClassObject *t_Cls = NULL;
			t_Status = GetClassObject ( &t_Cls ) ;

			if ( t_Status )
			{
				t_Status = 	PerformGet() ;
				t_Cls->Release();
			}
			else
			{
				t_Status = FALSE ;
				SetErrorInfo(IDS_CLASS_DEFN,
								WBEM_E_FAILED ) ;
			}
		}
		else
		{
			t_Status = FALSE ;
			SetErrorInfo(IDS_INVALID_CLASS ,
								WBEM_E_FAILED ) ;
		}
	}
	else
	{
		t_Status = FALSE ;
		SetErrorInfo(IDS_OBJ_PATH ,
								WBEM_E_FAILED ) ;
	}

	DecrementPingCount();
	return t_Status ;
}

BOOL CPingGetAsync::PerformGet ()
{
	if (m_ParsedObjectPath->m_dwNumKeys != PING_KEY_PROPERTY_COUNT)
	{
		SetErrorInfo(IDS_OBJ_PATH_KEYS  ,
								 WBEM_E_FAILED ) ;
		return FALSE;
	}

	BOOL t_Status = TRUE;
	UCHAR t_bits[PING_KEY_PROPERTY_COUNT] = {0};
	ULONG t_Address = 0 ;
	ULONG t_TimeToLive = 0 ;
	ULONG t_Timeout = 0 ;
	ULONG t_SendSize = 0 ;
	BOOL t_NoFragmentation = FALSE ;
	ULONG t_TypeofService = 0 ;
	ULONG t_RecordRoute = 0 ;
	ULONG t_TimestampRoute = 0 ;
	ULONG t_SourceRouteType = 0 ;
	LPCWSTR t_SourceRoute = NULL ;
	BOOL t_ResolveAddress = FALSE;
	ULONG t_AddressKey = 0;
	ULONG t_ResolveErr = 0;

	for (int x = 0; ((x < PING_KEY_PROPERTY_COUNT) && t_Status); x++)
	{
		if (m_ParsedObjectPath->m_paKeys [ x ])
		{
			CKeyEntry t_key(m_ParsedObjectPath->m_paKeys [ x ]->m_pName) ;
			ULONG t_PropertyIndex = 0xFF; //out of scope

			if ( (CPingProvider::s_HashTable->Find(t_key, t_PropertyIndex) == e_StatusCode_Success)
				&& (t_PropertyIndex < PING_KEY_PROPERTY_COUNT) )
			{
				if (t_bits[t_PropertyIndex] == 1)
				{
					t_Status = FALSE;
					SetErrorInfo(IDS_OBJ_PATH_DUP_KEYS  ,
									WBEM_E_FAILED ) ;

				}
				else
				{
					t_bits[t_PropertyIndex] = 1;
					
					switch (t_PropertyIndex)
					{
						case PING_ADDRESS_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_BSTR )
							{
								if (FAILED (Icmp_ResolveAddress ( m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.bstrVal , t_Address, &t_ResolveErr ))
									&& (t_ResolveErr == 0) )
								{
									t_ResolveErr = WSAHOST_NOT_FOUND;
								}

								t_AddressKey = x;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_ADDR_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TIMEOUT_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								t_Timeout = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TO_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TIMETOLIVE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_TimeToLive = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TTL_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_BUFFERSIZE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_SendSize = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_BUFF_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_NOFRAGMENTATION_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_NoFragmentation = (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal != 0);
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_NOFRAG_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TYPEOFSERVICE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_TypeofService = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TOS_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_RECORDROUTE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_RecordRoute = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_RR_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TIMESTAMPROUTE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_TimestampRoute = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TS_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_SOURCEROUTETYPE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_SourceRouteType = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_SRT_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_SOURCEROUTE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_BSTR )
							{
								t_SourceRoute = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.bstrVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_SR_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_RESOLVEADDRESSNAMES_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								t_ResolveAddress = (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal != 0);
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_RA_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						default :
						{
								t_Status = FALSE;
								SetErrorInfo(IDS_UNK_PROP,
									WBEM_E_FAILED ) ;
						}
					}
				}
			}
			else
			{
				t_Status = FALSE;
				SetErrorInfo(IDS_UNK_KEY,
								 WBEM_E_FAILED ) ;
			}
		}
		else
		{
			t_Status = FALSE;
			SetErrorInfo(IDS_NO_KEYS,
								 WBEM_E_FAILED ) ;
		}
	}

	if (t_Status)
	{
		InterlockedIncrement(&m_PingCount);
		HRESULT t_Result = Icmp_RequestResponse ( 

								m_ParsedObjectPath->m_paKeys [ t_AddressKey ]->m_vValue.bstrVal ,
								t_Address ,
								t_TimeToLive ,
								t_Timeout ,
								t_SendSize ,
								t_NoFragmentation ,
								t_TypeofService ,
								t_RecordRoute ,
								t_TimestampRoute ,
								t_SourceRouteType ,
								t_SourceRoute,
								t_ResolveAddress,
								t_ResolveErr
							) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			SetErrorInfo(0, WBEM_E_NOT_FOUND ) ;
		}
		else
		{
			DecrementPingCount();
			t_Status = FALSE;
		}
	}

	return t_Status ;
}

HRESULT CPingGetAsync::GetDefaultTTL ( DWORD &a_TimeToLive )
{
	HRESULT t_Result = S_OK ;

    a_TimeToLive = DEFAULT_TTL ;

    HKEY t_Registry ;

    ULONG t_Status = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
        0,
        KEY_QUERY_VALUE,
        &t_Registry
	) ;

	if ( t_Status == ERROR_SUCCESS )
	{
		ULONG t_Type = 0 ;
		ULONG t_Size = sizeof ( ULONG ) ;

        t_Status = RegQueryValueEx (

			t_Registry,
            L"DefaultTTL",
            0,
            & t_Type,
            ( unsigned char * ) & a_TimeToLive ,
            & t_Size
		);

        RegCloseKey ( t_Registry ) ;
    } 

    return t_Result ;
}

void CPingGetAsync::HandleResponse (CPingCallBackObject *a_reply)
{
	try
	{
		if (FAILED(Icmp_DecodeAndIndicate (a_reply)) )	
		{
			SetErrorInfo(IDS_DECODE_GET,
								 WBEM_E_FAILED, TRUE ) ;
		}
		else
		{
			SetErrorInfo(NULL, S_OK, TRUE);
		}
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}

void CPingGetAsync::HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes)
{
	try
	{
		SetErrorInfo(a_ErrMsgID , a_HRes, TRUE) ;
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\pingfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <provexpt.h>
#include <pingfac.h>

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <pingprov.h>

LONG CPingProviderClassFactory :: s_ObjectsInProgress = 0 ;
LONG CPingProviderClassFactory :: s_LocksInProgress = 0 ;

//***************************************************************************
//
// CPingProviderClassFactory::CPingProviderClassFactory
// CPingProviderClassFactory::~CPingProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CPingProviderClassFactory :: CPingProviderClassFactory () : m_ReferenceCount(0)
{
	InterlockedIncrement ( & s_ObjectsInProgress ) ;
}

CPingProviderClassFactory::~CPingProviderClassFactory ()
{
	InterlockedDecrement ( & s_ObjectsInProgress ) ;
}

//***************************************************************************
//
// CPingProviderClassFactory::QueryInterface
// CPingProviderClassFactory::AddRef
// CPingProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CPingProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
    SetStructuredExceptionHandler seh;

    try
    {
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			(*iplpv) = (IClassFactory*) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			(*iplpv) = (IClassFactory*) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}


STDMETHODIMP_( ULONG ) CPingProviderClassFactory :: AddRef ()
{
    SetStructuredExceptionHandler seh;

    try
    {
		return InterlockedIncrement ( & m_ReferenceCount ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP_(ULONG) CPingProviderClassFactory :: Release ()
{
    SetStructuredExceptionHandler seh;

    try
    {
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

//***************************************************************************
//
// CPingProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CPingProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION ;
		}
		else
		{
			IWbemServices *lpunk = ( IWbemServices * ) new CPingProvider ;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
				else
				{
				}
			}			
		}
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

	return status ;
}

//***************************************************************************
//
// CPingProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CPingProviderClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

    SetStructuredExceptionHandler seh;

    try
    {
		if ( fLock )
		{
			InterlockedIncrement ( & s_LocksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & s_LocksInProgress ) ;
		}

		return S_OK	;
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\pingcallback.cpp ===
/******************************************************************

   pingcallback.cpp



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/



#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>

VOID static NTAPI ApcRoutine(                                    // This is called when ping completes
    IN PVOID            Context,               // The above structure
    IN PIO_STATUS_BLOCK Ignored1,              // Unused param
    IN ULONG            Ignored2               // Unused param
)
{
    CPingCallBackObject *t_request = (CPingCallBackObject *)Context;
	t_request->HandleResponse();
	t_request->Release();
}

CPingCallBackObject::CPingCallBackObject(CPingTaskObject *a_ParentTask,
						LPCWSTR a_AddressString,
						ULONG a_Address,
						ULONG a_TimeToLive,
						ULONG a_Timeout,
						ULONG a_SendSize,
						BOOL a_NoFragmentation,
						ULONG a_TypeofService,
						ULONG a_RecordRoute,
						ULONG a_TimestampRoute,
						ULONG a_SourceRouteType,
						LPCWSTR a_SourceRoute,
						BOOL a_ResolveAddress,
						ULONG a_ResolveError)
						:
						WmiTask < ULONG > ( *CPingProvider :: s_Allocator ) ,
						m_ParentTask(NULL),
						m_ReplyBuffer(NULL),
						m_SendBuffer(NULL),
						m_ReplySize(0),
						m_SourceRouteCount(0),
						m_IcmpHandle(INVALID_HANDLE_VALUE),
						m_ResolveError(a_ResolveError)
{
	InterlockedIncrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;

	m_ParentTask = a_ParentTask;
	m_Address = a_Address;
	m_TimeToLive = a_TimeToLive;
	m_Timeout = a_Timeout;
	m_SendSize = a_SendSize;
	m_NoFragmentation = a_NoFragmentation;
	m_TypeofService = a_TypeofService;
	m_RecordRoute = a_RecordRoute;
	m_TimestampRoute = a_TimestampRoute;
	m_SourceRouteType = a_SourceRouteType;
	m_ResolveAddress = a_ResolveAddress;
	
	if (a_SourceRoute != NULL)
	{
		m_SourceRoute = a_SourceRoute;
	}

	if (a_AddressString != NULL)
	{
		m_AddressString = a_AddressString;
	}
}

CPingCallBackObject::~CPingCallBackObject()
{
	if (m_ParentTask != NULL)
	{
		SendError(IDS_CALLBACK_PREMATURE, WBEM_E_FAILED);
	}

	if (m_ReplyBuffer != NULL)
	{
		delete [] m_ReplyBuffer;
		m_ReplyBuffer = NULL;
	}

	if (m_SendBuffer != NULL)
	{
		delete [] m_SendBuffer;
		m_SendBuffer = NULL;
	}

	if (INVALID_HANDLE_VALUE != m_IcmpHandle)
	{
		IcmpCloseHandle ( m_IcmpHandle );
	}

	InterlockedDecrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;
}

BOOL CPingCallBackObject::GetIcmpHandle()
{
	if (m_IcmpHandle == INVALID_HANDLE_VALUE)
	{
		m_IcmpHandle = IcmpCreateFile () ;
	}

	return (m_IcmpHandle != INVALID_HANDLE_VALUE); 
}

void CPingCallBackObject :: SendError(DWORD a_ErrMsgID, HRESULT a_HRes)
{
	if (m_ParentTask != NULL)
	{
		m_ParentTask->HandleErrorResponse(a_ErrMsgID, a_HRes);
		Disconnect();
	}
}

void CPingCallBackObject :: HandleResponse()
{
	if (m_ParentTask != NULL)
	{
		m_ParentTask->HandleResponse(this);
		m_ParentTask->SetThreadToken(TRUE);

		Disconnect();
	}
}


WmiStatusCode CPingCallBackObject :: Process ( WmiThread <ULONG> &a_Thread )
{
	SendEcho () ;

	return e_StatusCode_Success ;
}

BOOL CPingCallBackObject::ParseSourceRoute()
{
	BOOL t_RetVal = TRUE;
	CStringW t_Src(m_SourceRoute);
	t_Src.TrimLeft();
	t_Src.TrimRight();
	
	if (!t_Src.IsEmpty())
	{
		int t_Index = 0;

		while (t_Index != -1)
		{
			t_Index = t_Src.Find(L',');

			if (t_Index == 0)
			{
				t_RetVal = FALSE;
				break;
			}

			CStringW t_AddrStr;

			if (t_Index == -1)
			{
				t_AddrStr = t_Src;
			}
			else
			{
				t_AddrStr = t_Src.Left(t_Index);
				int t_len = t_Src.GetLength() - t_Index - 1;

				if (t_len == 0)
				{
					t_RetVal = FALSE;
					break;
				}
				else
				{
					t_Src = t_Src.Right(t_len);
				}
			}

			t_AddrStr.TrimLeft();
			t_AddrStr.TrimRight();

			if (!t_AddrStr.IsEmpty())
			{
				if ( SUCCEEDED ( CPingTaskObject::Icmp_ResolveAddress ( t_AddrStr , m_SourceRouteArray[m_SourceRouteCount] ) ) )
				{
					m_SourceRouteCount++;

					if ((m_SourceRouteCount == PING_MAX_IPS) && (t_Index != -1))
					{
						t_RetVal = FALSE;
						break;
					}
				}
				else
				{
					t_RetVal = FALSE;
					break;
				}
			}
			else
			{
				t_RetVal = FALSE;
				break;
			}
		}
	}

	return t_RetVal;
}

void CPingCallBackObject::SendEcho()
{
	if (m_ParentTask != NULL)
	{
		if (m_ParentTask->SetThreadToken(FALSE))
		{
			HRESULT t_Result = GetIcmpHandle() ? S_OK : WBEM_E_FAILED;
			BOOL t_SourceRouting = FALSE ;

			uchar t_SendOptions [ MAX_OPT_SIZE ] ;
			uint t_OptionLength = 0;
			int t_OptionIndex = 0 ;
			int t_SourceRouteIndex = -1 ;

			uchar t_Flags = m_NoFragmentation ? IP_FLAG_DF : 0 ;

			if (FAILED(t_Result))
			{
				SendError (IDS_ICMPCREATEFILE_FAIL, WBEM_E_FAILED);
			}
			else
			{
				if ( m_RecordRoute )
				{
					if ( ( t_OptionIndex + 3 ) <= MAX_OPT_SIZE )
					{
						ULONG t_RouteRecordCount = ( m_RecordRoute * sizeof ( ULONG ) ) + 3 ;

						if ( ( t_RouteRecordCount + t_OptionIndex ) <= MAX_OPT_SIZE) 
						{
							uchar *t_Options = t_SendOptions ;

							t_Options [ t_OptionIndex ] = IP_OPT_RR ;
							t_Options [ t_OptionIndex + 1 ] = t_RouteRecordCount ;
							t_Options [ t_OptionIndex + 2 ] = 4;  // Set initial pointer value

							t_OptionLength += t_RouteRecordCount;
							t_OptionIndex += t_RouteRecordCount ;

							t_SourceRouting = TRUE;
						}
						else
						{	
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_RR_MAX, WBEM_E_FAILED);
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
						SendError (IDS_RR_MAX_INDEX, WBEM_E_FAILED);
					}
				}
			}

			if (SUCCEEDED (t_Result))
			{
				if ( m_TimestampRoute )
				{
					if ( ( t_OptionIndex + 4 ) <= MAX_OPT_SIZE )
					{
						ULONG t_TimestampRecordCount = ( m_TimestampRoute * sizeof ( ULONG ) * 2 ) + 4 ;

						if ( ( t_TimestampRecordCount + t_OptionIndex ) <= MAX_OPT_SIZE) 
						{
							uchar *t_Options = t_SendOptions ;

							t_Options [ t_OptionIndex ] = IP_OPT_TS ;
							t_Options [ t_OptionIndex + 1 ] = t_TimestampRecordCount ;
							t_Options [ t_OptionIndex + 2 ] = 5;  // Set initial pointer value
							t_Options [ t_OptionIndex + 3 ] = 1 ;

							t_OptionLength += t_TimestampRecordCount ;
							t_OptionIndex += t_TimestampRecordCount ;

							t_SourceRouting = TRUE;
						}
						else
						{	
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_TS_MAX, WBEM_E_FAILED);
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
						SendError (IDS_TS_MAX_INDEX, WBEM_E_FAILED);
					}
				}
			}

			if (SUCCEEDED (t_Result))
			{
				switch ( m_SourceRouteType )
				{
					case 1:
					{
						if ( ParseSourceRoute() )
						{
							if ( ( t_OptionIndex + 3 ) <= MAX_OPT_SIZE )
							{
								if ( ( t_OptionIndex + 3 + ( ( m_SourceRouteCount + 1 ) * 4 ) ) <= MAX_OPT_SIZE )
								{
									uchar *t_Options = t_SendOptions ;

									t_Options [ t_OptionIndex ] = IP_OPT_LSRR ;
									t_Options [ t_OptionIndex + 1 ] = 3;  
									t_Options [ t_OptionIndex + 2 ] = 4;  

									t_OptionLength += 3 ;

									for ( ULONG t_SourceIndex = 0 ; t_SourceIndex < m_SourceRouteCount ; t_SourceIndex ++ )
									{
										ULONG t_RouteIndex = t_Options [ t_OptionIndex + 1 ] ;

										//* ( ULONG * ) &t_Options [ t_RouteIndex + t_OptionIndex ] = m_SourceRouteArray [ t_SourceIndex ] ;
										memcpy ( &t_Options [ t_RouteIndex + t_OptionIndex ], &m_SourceRouteArray [ t_SourceIndex ], sizeof ( ULONG ) );

										t_Options [ t_OptionIndex + 1 ] += 4 ;
										t_OptionLength += 4 ;
									}

									t_SourceRouteIndex = t_Options [ t_OptionIndex + 1 ] + t_OptionIndex ;

									t_Options [ t_OptionIndex + 1 ] += 4 ;   // Save space for dest. addr
									t_OptionIndex += t_Options [ t_OptionIndex + 1 ] ;
									t_OptionLength += 4 ;

									t_SourceRouting = TRUE;
								}
								else
								{	
									t_Result = WBEM_E_FAILED ;
									SendError (IDS_SR_MAX, WBEM_E_FAILED);
								}
							}
							else
							{
								t_Result = WBEM_E_FAILED ;
								SendError (IDS_SR_MAX_INDEX, WBEM_E_FAILED);
							}
						}
						else
						{
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_SR_PARSE, WBEM_E_FAILED);
						}
					}
					break ;

					case 2:
					{
						if ( ParseSourceRoute() )
						{
							if ( ( t_OptionIndex + 3 ) <= MAX_OPT_SIZE )
							{
								if ( ( t_OptionIndex + 3 + ( ( m_SourceRouteCount + 1 ) * 4 ) ) <= MAX_OPT_SIZE )
								{
									uchar *t_Options = t_SendOptions ;

									t_Options [ t_OptionIndex ] = IP_OPT_SSRR ;
									t_Options [ t_OptionIndex + 1 ] = 3;  
									t_Options [ t_OptionIndex + 2 ] = 4;  

									t_OptionLength += 3 ;

									for ( ULONG t_SourceIndex = 0 ; t_SourceIndex < m_SourceRouteCount ; t_SourceIndex ++ )
									{
										ULONG t_RouteIndex = t_Options [ t_OptionIndex + 1 ] ;

										//* ( ULONG * ) &t_Options [ t_RouteIndex + t_OptionIndex ] = m_SourceRouteArray [ t_SourceIndex ] ;
										memcpy ( &t_Options [ t_RouteIndex + t_OptionIndex ], &m_SourceRouteArray [ t_SourceIndex ], sizeof ( ULONG ) );

										t_Options [ t_OptionIndex + 1 ] += 4 ;
										t_OptionLength += 4 ;
									}

									t_SourceRouteIndex = t_Options [ t_OptionIndex + 1 ] + t_OptionIndex ;

									t_Options [ t_OptionIndex + 1 ] += 4 ;   // Save space for dest. addr
									t_OptionIndex += t_Options [ t_OptionIndex + 1 ] ;
									t_OptionLength += 4 ;

									t_SourceRouting = TRUE;
								}
								else
								{	
									t_Result = WBEM_E_FAILED ;
									SendError (IDS_SR_MAX, WBEM_E_FAILED);
								}
							}
							else
							{
								t_Result = WBEM_E_FAILED ;
								SendError (IDS_SR_MAX_INDEX, WBEM_E_FAILED);
							}
						}
						else
						{
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_SR_PARSE, WBEM_E_FAILED);
						}
      				}
					break ;

					case 0:
					default:
					{
					}
					break ;
				}
			}

			if (SUCCEEDED (t_Result))
			{
				if ( t_SourceRouteIndex != -1 )
				{
					//* ( ULONG *) & t_SendOptions [ t_SourceRouteIndex ] = m_Address ;
					memcpy ( & t_SendOptions [ t_SourceRouteIndex ], &m_Address, sizeof ( ULONG ) );
				}

				m_SendBuffer = new UCHAR[m_SendSize] ;

				//
				// Calculate receive buffer size and try to allocate it.
				//

				if ( m_SendSize <= DEFAULT_SEND_SIZE )
				{
					m_ReplySize = DEFAULT_BUFFER_SIZE ;
				}
				else 
				{
					m_ReplySize = MAX_BUFFER_SIZE ;
				}

				m_ReplyBuffer = new UCHAR[m_ReplySize] ;

				//
				// Initialize the send buffer pattern.
				//
				for ( ULONG t_Index = 0; t_Index < m_SendSize; t_Index ++)
				{
					m_SendBuffer [ t_Index ] = 'a' + ( t_Index % 23 ) ;
				}

				//
				// Initialize the send options
				//

				IP_OPTION_INFORMATION t_SendOptionInformation ;

				t_SendOptionInformation.OptionsData = t_SendOptions ;
				t_SendOptionInformation.OptionsSize = (uchar) t_OptionLength ;

				t_SendOptionInformation.Ttl = m_TimeToLive ;
				t_SendOptionInformation.Tos = m_TypeofService ;
				t_SendOptionInformation.Flags = t_Flags ;
			
				//will always return 0 in async case!
				ULONG t_ReplyStatus = IcmpSendEcho2 (

						m_IcmpHandle,
						0,
						ApcRoutine,
						(PVOID)this ,
						m_Address,
						m_SendBuffer ,
						(unsigned short) m_SendSize ,
						& t_SendOptionInformation ,
						m_ReplyBuffer,
						m_ReplySize,
						m_Timeout
				);

				//we're async get the return val elsewhere
				t_ReplyStatus = GetLastError();

				if( (ERROR_SUCCESS != t_ReplyStatus) && (ERROR_IO_PENDING != t_ReplyStatus) )
				{
					SendError (IDS_ICMPSENDECHO2, WBEM_E_FAILED);
				}
			}

			m_ParentTask->SetThreadToken(TRUE);

			if (FAILED(t_Result))
			{
				Release();
			}
		}
		else
		{
			SendError(IDS_IMPERSONATE_SEND, WBEM_E_ACCESS_DENIED);
			Release();
		}
	}
	else
	{
		Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\pingquery.cpp ===
/******************************************************************

   pingquery.CPP



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>

CPingQueryAsync::CPingQueryAsync (CPingProvider *a_Provider , 
								  BSTR a_QueryFormat , 
								  BSTR a_Query , 
								  ULONG a_Flag , 
								  IWbemObjectSink *a_NotificationHandler ,
								  IWbemContext *a_Ctx
								  ) : m_QueryFormat(NULL),
									  m_Query(NULL),
									  CPingTaskObject (a_Provider, a_NotificationHandler, a_Ctx)
{
	if (a_QueryFormat != NULL)
	{
		int t_len = wcslen(a_QueryFormat);

		if (t_len > 0)
		{
			m_QueryFormat = new WCHAR[t_len+1];
			m_QueryFormat[t_len] = L'\0';
			wcsncpy(m_QueryFormat, a_QueryFormat, t_len);
		}
	}

	if (a_Query != NULL)
	{
		int t_len = wcslen(a_Query);

		if (t_len > 0)
		{
			m_Query = new WCHAR[t_len+1];
			m_Query[t_len] = L'\0';
			wcsncpy(m_Query, a_Query, t_len);
		}
	}
}

CPingQueryAsync::~CPingQueryAsync ()
{
	if (m_Query != NULL)
	{
		delete [] m_Query ;
	}

	if (m_QueryFormat != NULL)
	{
		delete [] m_QueryFormat ;
	}
}

QueryPreprocessor :: QuadState CPingQueryAsync :: Compare ( 

	LONG a_Operand1 , 
	LONG a_Operand2 , 
	ULONG a_Operand1Func ,
	ULONG a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: Compare ( 

	wchar_t *a_Operand1 , 
	wchar_t *a_Operand2 , 
	ULONG a_Operand1Func ,
	ULONG a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	wchar_t *a_Operand1AfterFunc = NULL ;
	wchar_t *a_Operand2AfterFunc = NULL ; 

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand1 ) ;
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towupper ( a_Operand1 [ index ] ) ;
			}
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand1 ) ;
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towlower ( a_Operand1 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand2 ) ;
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towupper ( a_Operand2 [ index ] ) ;
			}
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand2 ) ;
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towlower ( a_Operand2 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1 ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2 ;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc ;
	delete [] a_Operand2AfterFunc ;

	return t_Status ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: CompareString ( 

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_StringNode->GetValue () ,
			t_Variant.bstrVal ,
			t_StringNode->GetPropertyFunction () ,
			t_StringNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: CompareInteger ( 

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_IntegerNode->GetValue () ,
			t_Variant.lVal ,
			t_IntegerNode->GetPropertyFunction () ,
			t_IntegerNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

WmiTreeNode *CPingQueryAsync :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName , 
				a_Variant.lVal , 
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName , 
				a_Variant.lVal , 
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		IWbemClassObject *t_Object = NULL ;
		HRESULT t_Result = GetClassObject ( &t_Object ) ? WBEM_S_NO_ERROR : WBEM_E_FAILED ;

		if ( SUCCEEDED ( t_Result ) )
		{
			CIMTYPE t_VarType ;
			long t_Flavour ;
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			t_Result = t_Object->Get (

				a_PropertyName ,
				0 ,
				& t_Variant ,
				& t_VarType ,
				& t_Flavour
			);

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_VarType & CIM_FLAG_ARRAY )
				{
				}
				else
				{
					switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
					{
						case CIM_BOOLEAN:
						{
							if(V_VT(&a_Variant) == VT_I4)
                            {
                                t_Node = new WmiSignedIntegerNode ( 

								    a_PropertyName , 
								    a_Variant.lVal , 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_BOOL)
							{
                                t_Node = new WmiSignedIntegerNode ( 

								    a_PropertyName , 
									(a_Variant.lVal == VARIANT_FALSE) ? 0 : 1, 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
							}
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_SINT8:
						case CIM_SINT16:
						case CIM_CHAR16:
						case CIM_SINT32:
						{
							if(V_VT(&a_Variant) == VT_I4)
                            {
                                t_Node = new WmiSignedIntegerNode ( 

								    a_PropertyName , 
								    a_Variant.lVal , 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_UINT8:
						case CIM_UINT16:
						case CIM_UINT32:
						{
							if(V_VT(&a_Variant) == VT_I4)
                            {
                                t_Node = new WmiUnsignedIntegerNode ( 

								    a_PropertyName , 
								    a_Variant.lVal , 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_SINT64:
						case CIM_UINT64:
						{
							if(V_VT(&a_Variant) == VT_BSTR)
                            {
                                t_Node = new WmiStringNode ( 

								    a_PropertyName , 
								    a_Variant.bstrVal , 
								    a_PropertyFunction ,
								    a_ConstantFunction ,
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if(V_VT(&a_Variant) == VT_I4)
							{
								_variant_t t_uintBuff (&a_Variant);

                                t_Node = new WmiStringNode ( 

								    a_PropertyName , 
								    (BSTR)((_bstr_t) t_uintBuff), 
								    a_PropertyFunction ,
								    a_ConstantFunction ,
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
							}
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_STRING:
						case CIM_DATETIME:
						case CIM_REFERENCE:
						{
							if(V_VT(&a_Variant) == VT_BSTR)
                            {
                                t_Node = new WmiStringNode ( 

								    a_PropertyName , 
								    a_Variant.bstrVal , 
								    a_PropertyFunction ,
								    a_ConstantFunction ,
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_REAL32:
						case CIM_REAL64:
						{
						}
						break ;

						case CIM_OBJECT:
						case CIM_EMPTY:
						{
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
			}

			t_Object->Release () ;

			VariantClear ( & t_Variant ) ;
		}

	}

	return t_Node ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: InvariantEvaluate ( 

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Error ;

	IWbemClassObject *t_Object = NULL ;
	HRESULT t_Result = GetClassObject ( &t_Object ) ? WBEM_S_NO_ERROR : WBEM_E_FAILED ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand ;
		BSTR t_PropertyName = t_Node->GetPropertyName () ;

		if ( t_PropertyName != NULL )
		{
			if ( *t_PropertyName == L'_' )
			{
				// System property, must check values

				if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_CLASS ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_SUPERCLASS ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
				{
					t_State = CompareInteger ( 

						t_Object ,
						SYSTEM_PROPERTY_GENUS ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_SERVER ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_NAMESPACE ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
				{
					t_State = CompareInteger ( 

						t_Object ,
						SYSTEM_PROPERTY_PROPERTY_COUNT ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_DYNASTY ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_RELPATH ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_PATH ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}

			}
			else
			{
				if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
	#if 0
				else if ( typeid ( *a_Operand ) == typeid ( WmiStringNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operand ) == typeid ( WmiUnsignedIntegerNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operand ) == typeid ( WmiSignedIntegerNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}

				if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLikeNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotLikeNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
	#endif
			}
		}
		else
		{
			t_State = QueryPreprocessor :: QuadState :: State_Undefined;
		}

		t_Object->Release () ;
	}

	return t_State ;
}

WmiRangeNode *CPingQueryAsync :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName 
)
{
	WmiRangeNode *t_RangeNode = NULL ;

	IWbemClassObject *t_Object = NULL ;
	HRESULT t_Result = GetClassObject ( &t_Object ) ? WBEM_S_NO_ERROR : WBEM_E_FAILED ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CIMTYPE t_VarType ;
		long t_Flavour ;
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT t_Result = t_Object->Get (

			a_PropertyName ,
			0 ,
			& t_Variant ,
			& t_VarType ,
			& t_Flavour
		);

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_VarType & CIM_FLAG_ARRAY )
			{
			}
			else
			{
				switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
				{
					case CIM_BOOLEAN:
					case CIM_SINT8:
					case CIM_SINT16:
					case CIM_CHAR16:
					case CIM_SINT32:
					{
						t_RangeNode = new WmiSignedIntegerRangeNode ( 

							a_PropertyName , 
							0xFFFFFFFF , 
							TRUE ,
							TRUE ,
							FALSE ,
							FALSE ,
							0 ,
							0 ,
							NULL , 
							NULL 
						) ;
					}
					break ;

					case CIM_UINT8:
					case CIM_UINT16:
					case CIM_UINT32:
					{
						t_RangeNode = new WmiUnsignedIntegerRangeNode ( 

							a_PropertyName , 
							0xFFFFFFFF , 
							TRUE ,
							TRUE ,
							FALSE ,
							FALSE ,
							0 ,
							0 ,
							NULL , 
							NULL 
						) ;
					}
					break ;

					case CIM_SINT64:
					case CIM_UINT64:
					case CIM_STRING:
					case CIM_DATETIME:
					case CIM_REFERENCE:
					{
						t_RangeNode = new WmiStringRangeNode ( 

							a_PropertyName , 
							0x0 , 
							TRUE ,
							TRUE ,
							FALSE ,
							FALSE ,
							NULL ,
							NULL ,
							NULL , 
							NULL 
						) ;
					}
					break ;

					case CIM_REAL32:
					case CIM_REAL64:
					{
					}
					break ;

					case CIM_OBJECT:
					case CIM_EMPTY:
					{
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

		}

		t_Object->Release () ;
		VariantClear ( & t_Variant ) ;
	}

	return t_RangeNode ;
}

ULONG CPingQueryAsync :: GetPriority ( BSTR a_PropertyName )
{
	if ( _wcsicmp ( a_PropertyName , Ping_Address ) == 0 )
	{
		return 0 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_Timeout ) == 0 )
	{
		return 1 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_TimeToLive ) == 0 )
	{
		return 2 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_BufferSize ) == 0 )
	{
		return 3 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_NoFragmentation ) == 0 )
	{
		return 4 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_TypeofService ) == 0 )
	{
		return 5 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_RecordRoute ) == 0 )
	{
		return 6 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_TimestampRoute ) == 0 )
	{
		return 7 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_SourceRouteType ) == 0 )
	{
		return 8 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_SourceRoute ) == 0 )
	{
		return 9 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_ResolveAddressNames  ) == 0 )
	{
		return 10 ;
	}

	return 0xFFFFFFFF ;
}

HRESULT CPingQueryAsync :: RecurseAddress (

	void *pMethodContext, 
	PartitionSet *a_PartitionSet
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	if (t_PartitionCount == 0)
	{
		t_Result = S_OK ;
	}

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( wcscmp ( t_Node->LowerBound () , t_Node->UpperBound () ) == 0 ) ;

		if ( ! t_Unique )
		{
			SetErrorInfo(IDS_QUERY_ADDR,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			ULONG t_Address = 0 ;
			ULONG t_ResolveErr = 0 ;
			
			if ( FAILED ( Icmp_ResolveAddress ( t_Node->LowerBound () , t_Address , &t_ResolveErr ) ) && (t_ResolveErr == 0))
			{
				t_ResolveErr = WSAHOST_NOT_FOUND;
			}

			//if even one call succeeds return success
			if (SUCCEEDED( RecurseTimeOut (pMethodContext , 
							t_Node->LowerBound () ,
							t_Address, 
							t_PropertyPartition,
							t_ResolveErr)
				&& FAILED (t_Result) ) )
			{
				t_Result = S_OK;
			}
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTimeOut (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	PartitionSet *a_PartitionSet ,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TO,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseTimeToLive (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				t_UnSpecified ? DEFAULT_TIMEOUT : t_Node->LowerBound () , 
				t_PropertyPartition  ,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTimeToLive (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TTL,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseBufferSize (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				t_UnSpecified ? DEFAULT_TTL : t_Node->LowerBound () , 
				t_PropertyPartition ,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseBufferSize (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive ,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_BUF,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			if ( t_UnSpecified == FALSE && ( t_Node->LowerBound () > 65500 ) )
			{
				SetErrorInfo(IDS_BUFFSIZE_VALUE,WBEM_E_PROVIDER_NOT_CAPABLE ) ;
				break ;
			}

			t_Result = RecurseNoFragmentation (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				t_UnSpecified ? DEFAULT_SEND_SIZE : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseNoFragmentation (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_NOFRAG,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseTypeOfService (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				t_UnSpecified ? FALSE : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTypeOfService (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TOS,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseRecordRoute (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseRecordRoute (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_RR,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseTimestampRoute (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService ,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTimestampRoute (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TS,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseSourceRouteType (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService,
				a_RecordRoute,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}


HRESULT CPingQueryAsync :: RecurseSourceRouteType (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	ULONG a_TimestampRoute,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_SRT,
							WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseSourceRoute (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService,
				a_RecordRoute,
				a_TimestampRoute,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseSourceRoute (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	ULONG a_TimestampRoute,
	ULONG a_SourceRouteType,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( wcscmp ( t_Node->LowerBound () , t_Node->UpperBound () ) == 0 )  ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_SR,
							WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseResolveAddressNames (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService,
				a_RecordRoute,
				a_TimestampRoute,
				a_SourceRouteType,
				t_UnSpecified ? NULL : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseResolveAddressNames (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	ULONG a_TimestampRoute,
	ULONG a_SourceRouteType,
	LPCWSTR a_SourceRoute,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_RA,
							WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
			{
				PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;
				WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

				InterlockedIncrement(&m_PingCount);
				t_Result = Icmp_RequestResponse ( 

					a_AddressString ,
					a_Address ,
					a_TimeToLive,
					a_TimeOut ,
					a_SendSize,
					a_NoFragmentation ,
					a_TypeOfService,
					a_RecordRoute,
					a_TimestampRoute,
					a_SourceRouteType,
					a_SourceRoute ,
					t_UnSpecified ? FALSE : t_Node->LowerBound (),
					a_ResolveError
				) ;

				if ( FAILED ( t_Result ) )
				{
					DecrementPingCount();
				}
			}
		}
	}

	return t_Result ;
}

BOOL CPingQueryAsync::ExecQuery ()
{
	BOOL t_Result = FALSE ;
	InterlockedIncrement(&m_PingCount);
	SQL_LEVEL_1_RPN_EXPRESSION *t_RpnExpression = NULL ;
	QueryPreprocessor :: QuadState t_State =  Query ( 
		
		m_Query , 
		t_RpnExpression
	) ;

	if ( t_State == QueryPreprocessor :: QuadState :: State_True )
	{
		WmiTreeNode *t_Root = NULL ;

		t_State = PreProcess (

			NULL ,
			t_RpnExpression ,
			t_Root
		) ;

		PartitionSet *t_PartitionSet = NULL ;

		try
		{
			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{
					BSTR t_PropertyContainer [ PING_KEY_PROPERTY_COUNT ] ;
					memset (t_PropertyContainer , 0 , sizeof(BSTR) * PING_KEY_PROPERTY_COUNT );

					try
					{
						t_PropertyContainer [ 0 ] = SysAllocString ( Ping_Address ) ;
						t_PropertyContainer [ 1 ] = SysAllocString ( Ping_Timeout ) ; 
						t_PropertyContainer [ 2 ] = SysAllocString ( Ping_TimeToLive ) ; 
						t_PropertyContainer [ 3 ] = SysAllocString ( Ping_BufferSize ) ; 
						t_PropertyContainer [ 4 ] = SysAllocString ( Ping_NoFragmentation ) ; 
						t_PropertyContainer [ 5 ] = SysAllocString ( Ping_TypeofService ) ; 
						t_PropertyContainer [ 6 ] = SysAllocString ( Ping_RecordRoute ) ; 
						t_PropertyContainer [ 7 ] = SysAllocString ( Ping_TimestampRoute ) ; 
						t_PropertyContainer [ 8 ] = SysAllocString ( Ping_SourceRouteType ) ; 
						t_PropertyContainer [ 9 ] = SysAllocString ( Ping_SourceRoute ) ; 
						t_PropertyContainer [ 10 ] = SysAllocString ( Ping_ResolveAddressNames ) ; 

						if (	!t_PropertyContainer [ 0 ] ||
								!t_PropertyContainer [ 1 ] ||
								!t_PropertyContainer [ 2 ] ||
								!t_PropertyContainer [ 3 ] ||
								!t_PropertyContainer [ 4 ] ||
								!t_PropertyContainer [ 5 ] ||
								!t_PropertyContainer [ 6 ] ||
								!t_PropertyContainer [ 7 ] ||
								!t_PropertyContainer [ 8 ] ||
								!t_PropertyContainer [ 9 ] ||
								!t_PropertyContainer [ 10 ]
						   )
						{
							throw CHeap_Exception (  CHeap_Exception :: E_ALLOCATION_ERROR );
						}

						t_State = PreProcess (	

							NULL ,
							t_RpnExpression ,
							t_Root ,
							PING_KEY_PROPERTY_COUNT , 
							t_PropertyContainer ,
							t_PartitionSet
						) ;

						for ( ULONG index = 0; index < PING_KEY_PROPERTY_COUNT; index++ )
						{
							if ( t_PropertyContainer [ index ] )
							{
								SysFreeString ( t_PropertyContainer [ index ] ) ;
								t_PropertyContainer [ index ] = NULL;
							}
						}

					}
					catch ( ... )
					{
						for ( ULONG index = 0; index < PING_KEY_PROPERTY_COUNT; index++ )
						{
							if ( t_PropertyContainer [ index ] )
							{
								SysFreeString ( t_PropertyContainer [ index ] ) ;
								t_PropertyContainer [ index ] = NULL;
							}
						}

						throw;
					}

					switch ( t_State )
					{
						case QueryPreprocessor :: QuadState :: State_True :	
						{
							SetErrorInfo(IDS_QUERY_BROAD,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_False :
						{
		/*
		* Empty set
		*/
							SetErrorInfo(IDS_QUERY_NARROW,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;

						}
						break ;

						case QueryPreprocessor :: QuadState :: State_Undefined :
						{
							t_Result = SUCCEEDED(RecurseAddress ( NULL , t_PartitionSet ) );
							delete t_PartitionSet ;
							t_PartitionSet = NULL;
						}
						break ;

						default:
						{
							SetErrorInfo(IDS_QUERY_UNUSABLE,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
						}
						break ;
					}

					delete t_Root ;
					t_Root = NULL ;
				}
				break ;
			
				default:
				{
					SetErrorInfo(IDS_QUERY_ANALYZE,
									 WBEM_E_FAILED ) ;
				}
				break ;
			}

			delete t_RpnExpression ;
			t_RpnExpression = NULL ;
		}
		catch (...)
		{
			if ( t_PartitionSet )
			{
				delete t_PartitionSet;
				t_PartitionSet = NULL;
			}

			if ( t_Root )
			{
				delete t_Root;
				t_Root = NULL;
			}

			if ( t_RpnExpression )
			{
				delete t_RpnExpression ;
				t_RpnExpression = NULL ;
			}

			DecrementPingCount();
			throw;
		}
	}
	else
	{
		SetErrorInfo(IDS_QUERY_PARSE,
						WBEM_E_FAILED ) ;
	}

	DecrementPingCount();
	return t_Result ;
}

void CPingQueryAsync::HandleResponse (CPingCallBackObject *a_reply)
{
	try
	{
		if (FAILED(Icmp_DecodeAndIndicate (a_reply)) )	
		{
			SetErrorInfo(IDS_DECODE_QUERY,
								 WBEM_E_FAILED ) ;
		}
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}

void CPingQueryAsync::HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes)
{
	try
	{
		SetErrorInfo(a_ErrMsgID , a_HRes) ;
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\pingprov.cpp ===
//***************************************************************************
//
//  PINGPROV.CPP
//
//  Module: WMI PING PROVIDER 
//
//  Purpose: Implementation for the CPingProvider class. 
//
// Copyright (c) 2000-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************


#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <pingprov.h>
#include <pingfac.h>
#include <pingtask.h>

#include <scopeguard.h>

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CPingProvider ::CPingProvider
// CPingProvider ::~CPingProvider
//
//***************************************************************************

CRITICAL_SECTION CPingProvider::s_CS;
CPingThread *CPingProvider::s_PingThread = NULL;
WmiAllocator *CPingProvider::s_Allocator = NULL;
WmiHashTable <CKeyEntry, ULONG, 12> *CPingProvider::s_HashTable = NULL;

LPCWSTR CPingProvider::s_KeyTable[PING_KEY_PROPERTY_COUNT] = {
										Ping_Address,
										Ping_Timeout,
										Ping_TimeToLive,
										Ping_BufferSize,
										Ping_NoFragmentation,
										Ping_TypeofService,
										Ping_RecordRoute,
										Ping_TimestampRoute,
										Ping_SourceRouteType,
										Ping_SourceRoute,
										Ping_ResolveAddressNames
										};

LONG CompareElement ( const CKeyEntry &a_Arg1 , const CKeyEntry & a_Arg2 )
{
	LPCWSTR t_a1 = a_Arg1.Get();
	LPCWSTR t_a2 = a_Arg2.Get();

	if (t_a1 == t_a2)
	{
		return 0;
	}
	else if ((t_a1 == NULL) && (t_a1 != NULL))
	{
		return 1;
	}
	else if ((t_a1 == NULL) && (t_a1 != NULL))
	{
		return -1;
	}
	else
	{
		return (_wcsicmp(t_a1, t_a2));
	}
}

BOOL operator== ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 )
{
	return (CompareElement(a_Arg1, a_Arg2) == 0);
}

BOOL operator< ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 )
{
	return (CompareElement(a_Arg1, a_Arg2) == -1);
}

ULONG Hash ( const CKeyEntry & a_Arg )
{
	LPCWSTR t_a = a_Arg.Get();
	ULONG t_RetVal = 0;

	if (t_a != NULL)
	{
		switch (*t_a)
		{
			case L'A':
			case L'a':
			{
				t_RetVal = 1;
			}
			break;

			case L'B':
			case L'b':
			{
				t_RetVal = 2;
			}
			break;

			case L'N':
			case L'n':
			{
				t_RetVal = 3;
			}
			break;

			case L'R':
			case L'r':
			{
				switch (wcslen(t_a))
				{
					case 11 : //wcslen(RecordRoute)
					{
						t_RetVal = 4;
					}
					break;

					case 19 : //wcslen(ResolveAddressNames)
					{
						t_RetVal = 5;
					}
					break;

					default:
					{
					}
				}
			}
			break;

			case L'S':
			case L's':
			{
				switch (wcslen(t_a))
				{
					case 11 : //wcslen(SourceRoute)
					{
						t_RetVal = 6;
					}
					break;

					case 15 : //wcslen(SourceRouteType)
					{
						t_RetVal = 7;
					}
					break;

					default:
					{
					}
				}
			}
			break;

			case L'T':
			case L't':
			{
				switch (wcslen(t_a))
				{
					case 7 : //wcslen(TimeOut)
					{
						t_RetVal = 8;
					}
					break;

					case 10 : //wcslen(TimeToLive)
					{
						t_RetVal = 9;
					}
					break;

					case 13 : //wcslen(TypeOfService)
					{
						t_RetVal = 10;
					}
					break;

					case 14 : //wcslen(TimeStampRoute)
					{
						t_RetVal = 11;
					}
					break;

					default:
					{
					}
				}
			}
			break;

			default:
			{
			}
		}
	}

	return t_RetVal ;
}


CPingThread::CPingThread (WmiAllocator & a_Allocator)
:	WmiThread < ULONG > ( a_Allocator , L"PingProviderThread") ,
	m_Allocator ( a_Allocator ), m_Init(FALSE)
{
}

CPingThread::~CPingThread ()
{
}

WmiStatusCode CPingThread :: Initialize_Callback ()
{
	WmiStatusCode t_RetVal = e_StatusCode_NotInitialized;

	if (SUCCEEDED( CoInitializeEx ( NULL , COINIT_MULTITHREADED )) )
	{
		WSADATA t_WsaData ;
		
		if (0 == WSAStartup (0x0101, & t_WsaData))
		{
			t_RetVal = e_StatusCode_Success ;
			m_Init = TRUE;
		}
		else
		{
			CoUninitialize () ;
		}
	}

	return t_RetVal ;
}


WmiStatusCode CPingThread :: UnInitialize_Callback () 
{
	if (m_Init)
	{
		WSACleanup () ;
		CoUninitialize () ;
	}

	return e_StatusCode_Success ;
}

CPingProvider ::CPingProvider () : m_referenceCount(0),
									m_server(NULL),
									m_notificationClassObject(NULL),
									m_ClassObject(NULL),
									m_bInitial(FALSE)
{	 
    InterlockedIncrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;
}

CPingProvider ::~CPingProvider()
{
	if ( m_server != NULL )
	{
		m_server->Release () ;
	}

	if ( m_ClassObject != NULL )
	{
		m_ClassObject->Release () ;
	}

	if ( m_notificationClassObject != NULL )
	{
		m_notificationClassObject->Release () ;
	}

	InterlockedDecrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;
}

HRESULT CPingProvider :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( s_Allocator)
	{
		if (  !s_PingThread )
		{
			WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;

			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_FAILED;
			}
			else
			{
				try
				{
					s_HashTable = ::new WmiHashTable <CKeyEntry, ULONG, 12> ( *s_Allocator ) ;
					t_StatusCode = s_HashTable->Initialize () ;
					
					if ( t_StatusCode != e_StatusCode_Success )
					{
						Global_Shutdown();
						t_Result = WBEM_E_FAILED;
					}
					else
					{
						for (int x = 0; x < PING_KEY_PROPERTY_COUNT; x++)
						{
							CKeyEntry t_KeyEntry(s_KeyTable[x]);
							t_StatusCode = s_HashTable->Insert ( t_KeyEntry , x ) ;

							if ( t_StatusCode != e_StatusCode_Success )
							{
								Global_Shutdown();
								t_Result = WBEM_E_FAILED;
								break;
							}

						}

						if (SUCCEEDED(t_Result))
						{
							s_PingThread = ::new CPingThread( *s_Allocator ) ;
							s_PingThread->AddRef();
							t_StatusCode = s_PingThread->Initialize () ;

							if ( t_StatusCode != e_StatusCode_Success )
							{
								Global_Shutdown();
								t_Result = WBEM_E_FAILED;
							}
						}
					}
				}
				catch(...)
				{
					Global_Shutdown();
					throw;
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED;
	}

	return t_Result ;
}

HRESULT CPingProvider :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	if (s_Allocator && s_PingThread )
	{
		try
		{
			if (s_PingThread != NULL)
			{
				if (s_PingThread->GetHandle ())
				{
					HANDLE t_ThreadHandle = NULL ;

					BOOL t_Status = DuplicateHandle ( 

						GetCurrentProcess () ,
						s_PingThread->GetHandle () ,
						GetCurrentProcess () ,
						& t_ThreadHandle, 
						0 , 
						FALSE , 
						DUPLICATE_SAME_ACCESS
					) ;

					s_PingThread->Release();
					WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

					CloseHandle ( t_ThreadHandle ) ;
				}
				else
				{
					s_PingThread->Release();
				}
			}

			WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;
		}
		catch(...)
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		s_PingThread = NULL;

		try
		{
			if (s_HashTable)
			{
				for (int x = 0; x < PING_KEY_PROPERTY_COUNT; x++)
				{
					CKeyEntry t_KeyEntry(s_KeyTable[x]);
					s_HashTable->Delete ( t_KeyEntry ) ;
				}

				s_HashTable->UnInitialize () ;
				::delete s_HashTable;
			}
		}
		catch(...)
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		s_HashTable = NULL;
	}

	return t_Result ;
}

//***************************************************************************
//
// CPingProvider ::QueryInterface
// CPingProvider ::AddRef
// CPingProvider ::Release
//
// Purpose: IUnknown members for CPingProvider object.
//***************************************************************************

STDMETHODIMP CPingProvider ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	HRESULT t_hr = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;
		}
		else
		{
			t_hr = E_NOINTERFACE ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_hr = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_hr = E_OUTOFMEMORY;
    }
    catch(...)
    {
        t_hr = E_UNEXPECTED;
    }

	return t_hr;
}

STDMETHODIMP_(ULONG) CPingProvider ::AddRef(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
		return InterlockedIncrement ( & m_referenceCount ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP_(ULONG) CPingProvider ::Release(void)
{
	LONG t_Ref  = 0;
    SetStructuredExceptionHandler seh;

    try
    {
		if ( ( t_Ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return t_Ref ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

BOOL CPingProvider :: GetNotificationObject ( IWbemContext *a_Ctx , IWbemClassObject **a_ppObj ) 
{
	*a_ppObj = NULL;

	if ( m_notificationClassObject == NULL )
	{
		CreateNotificationObject ( a_Ctx ) ;
	}

	if ( m_notificationClassObject != NULL )
	{
		if ( FAILED (m_notificationClassObject->SpawnInstance(0, a_ppObj)) )
		{
			*a_ppObj = NULL;
		}
	}

	return (*a_ppObj != NULL)  ; 
}

BOOL CPingProvider :: ImpersonateClient ( )
{
	return SUCCEEDED(WbemCoImpersonateClient());
}

BOOL CPingProvider::GetClassObject (IWbemClassObject **a_ppClass )
{
	BOOL t_RetVal = TRUE;

	if ((a_ppClass == NULL) || (m_ClassObject == NULL))
	{
		t_RetVal = FALSE;
	}
	else
	{
		*a_ppClass = m_ClassObject;
		(*a_ppClass)->AddRef();
	}

	return t_RetVal;
}

BOOL CPingProvider :: CreateNotificationObject ( 

	IWbemContext *a_Ctx 
)
{
	BOOL t_Status = TRUE ;

	HRESULT t_Result = m_server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx,
		& m_notificationClassObject ,
		NULL
	) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CPingProvider ::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppHandler
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {	
		if (ImpersonateClient())
		{
			//
			// auto CoRevertToSelf
			//
			ScopeGuard AutoCoRevertToSelf = MakeGuard ( CoRevertToSelf ) ;

			/*
			* Create Asynchronous GetObjectByPath object
			*/
			WSADATA t_WsaData ;
			
			if (0 == WSAStartup (0x0101, & t_WsaData))
			{
				//
				// auto WSA cleanup
				//
				ON_BLOCK_EXIT ( WSACleanup ) ;

				CPingGetAsync *t_AsyncEvent = new CPingGetAsync ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

				if (t_AsyncEvent->GetThreadToken())
                {
                    t_AsyncEvent->GetObject();
                }
                else
				{
                    // Note that ExecQuery will delete this for us.
					delete t_AsyncEvent;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED;
			}

			#ifdef	_DBG
			//
			// test return value in checked build
			//

			AutoCoRevertToSelf.Dismiss () ;
			ASSERT ( S_OK == CoRevertToSelf() ) ;
			#endif	_DBG
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_Result = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Result = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Result = E_UNEXPECTED;
    }

	return t_Result ;
}

HRESULT CPingProvider :: PutClass ( 
		
	IWbemClassObject FAR* pClass , 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: PutClassAsync ( 
		
	IWbemClassObject FAR* pClass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
 	 return WBEM_E_NOT_SUPPORTED ;
}

 HRESULT CPingProvider :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{

	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

SCODE CPingProvider :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: PutInstance (

    IWbemClassObject FAR *pInstance,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInstance, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_SUPPORTED ;
}
        
HRESULT CPingProvider :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
		if (ImpersonateClient())
		{
			//
			// auto CoRevertToSelf
			//
			ScopeGuard AutoCoRevertToSelf = MakeGuard ( CoRevertToSelf ) ;

			/*
			* Create Synchronous Query Instance object
			*/
			WSADATA t_WsaData ;
			
			if (0 == WSAStartup (0x0101, & t_WsaData))
			{
				//
				// auto WSA cleanup
				//
				ON_BLOCK_EXIT ( WSACleanup ) ;

				CPingQueryAsync *t_AsyncEvent = new CPingQueryAsync ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;
				
				if (t_AsyncEvent->GetThreadToken())
                {
                    t_AsyncEvent->ExecQuery();
                }
                else
				{
                    // Note that ExecQuery will delete this for us.
					delete t_AsyncEvent;
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED;
			}

			#ifdef	_DBG
			//
			// test return value in checked build
			//

			AutoCoRevertToSelf.Dismiss () ;
			ASSERT ( S_OK == CoRevertToSelf() ) ;
			#endif	_DBG
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_Result = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Result = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Result = WBEM_E_UNEXPECTED;
    }

	return t_Result ;
}

HRESULT CPingProvider :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_SUPPORTED ;
}
        
HRESULT CPingProvider :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_SUPPORTED ;
}       

HRESULT STDMETHODCALLTYPE CPingProvider :: ExecMethod ( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT STDMETHODCALLTYPE CPingProvider :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{

	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	HRESULT t_result = S_OK;
    SetStructuredExceptionHandler seh;

    try
    {
		if ((pCIMOM == NULL) || (pCtx == NULL) || (pInitSink == NULL))
		{
			t_result = WBEM_E_FAILED;
		}

		if (SUCCEEDED(t_result))
		{
			CCritSecAutoUnlock t_lock( &s_CS ) ;

			try
			{
				t_result = Global_Startup ();

				if (SUCCEEDED(t_result))
				{
					if (!m_bInitial)
					{
						m_bInitial = TRUE;
						m_server = pCIMOM ;
						m_server->AddRef();
						IWbemClassObject *t_Object = NULL;
						
						if ( GetNotificationObject ( pCtx, &t_Object ) ) 
						{
							t_Object->Release () ;

							t_result = m_server->GetObject (

								PROVIDER_NAME_CPINGPROVIDER ,
								0 ,
								pCtx,
								& m_ClassObject ,
								NULL 
							) ;

							if ( FAILED(t_result))
							{
								m_ClassObject = NULL ;
								t_result = WBEM_E_FAILED ;
							}

						}
						else
						{
							t_result = WBEM_E_FAILED ;
						}
					}
				}
			}
			catch (...)
			{
				t_result = WBEM_E_FAILED;
			}

			try
			{
				pInitSink->SetStatus ( SUCCEEDED(t_result) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;
				t_result = S_OK;
			}
			catch(...)
			{
				t_result = WBEM_E_FAILED;
			}
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_result = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_result = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_result = WBEM_E_UNEXPECTED;
    }

	return t_result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\pingtask.cpp ===
/******************************************************************

   CPingProvider.CPP -- WMI provider class implementation



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>

extern HMODULE ghModule ;

// Property names
//===============	

const WCHAR *Ping_Address = L"Address" ;
const WCHAR *Ping_Timeout = L"Timeout" ;
const WCHAR *Ping_TimeToLive = L"TimeToLive" ;
const WCHAR *Ping_BufferSize = L"BufferSize" ;
const WCHAR *Ping_NoFragmentation = L"NoFragmentation" ;
const WCHAR *Ping_TypeofService = L"TypeofService" ;
const WCHAR *Ping_RecordRoute = L"RecordRoute" ;
const WCHAR *Ping_TimestampRoute = L"TimestampRoute" ;
const WCHAR *Ping_SourceRouteType = L"SourceRouteType" ;
const WCHAR *Ping_SourceRoute = L"SourceRoute" ;
const WCHAR *Ping_ResolveAddressNames = L"ResolveAddressNames" ;

const static WCHAR *Ping_StatusCode = L"StatusCode" ;
const static WCHAR *Ping_ResponseTime = L"ResponseTime" ;
const static WCHAR *Ping_RouteRecord = L"RouteRecord" ;
const static WCHAR *Ping_ReplySize = L"ReplySize" ;
const static WCHAR *Ping_ReplyInconsistency = L"ReplyInconsistency" ;
const static WCHAR *Ping_ResponseTimeToLive = L"ResponseTimeToLive" ;
const static WCHAR *Ping_ProtocolAddress = L"ProtocolAddress" ;
const static WCHAR *Ping_TimeStampRecord = L"TimeStampRecord" ;
const static WCHAR *Ping_TimeStampRecordAddress = L"TimeStampRecordAddress" ;
const static WCHAR *Ping_TimeStampRecordAddressResolved = L"TimeStampRecordAddressResolved" ;
const static WCHAR *Ping_RouteRecordResolved = L"RouteRecordResolved" ;
const static WCHAR *Ping_ProtocolAddressResolved = L"ProtocolAddressResolved" ;
const static WCHAR *Ping_ResolveError = L"PrimaryAddressResolutionStatus" ;

CPingTaskObject::CPingErrorObject::~CPingErrorObject()
{
	if (m_Description != NULL)
	{
		delete [] m_Description;
	}
}

void CPingTaskObject::CPingErrorObject::SetInfo(LPCWSTR a_description, HRESULT a_status)
{
	m_Status = a_status;

	if (m_Description != NULL)
	{
		delete [] m_Description;
		m_Description = NULL;
	}

	if (a_description != NULL)
	{
		int t_len = wcslen(a_description);

		if (t_len > 0)
		{
			m_Description = new WCHAR[t_len+1];
			m_Description[t_len] = L'\0';
			wcsncpy(m_Description, a_description, t_len);
		}
	}
}

CPingTaskObject::CPingTaskObject (CPingProvider *a_Provider ,
									IWbemObjectSink *a_NotificationHandler ,
									IWbemContext *a_Ctx
									): m_NotificationHandler(NULL),
									m_Ctx(NULL),
									m_Provider(NULL),
									m_PingCount(0),
									m_ThreadToken(NULL)
{
	InitializeCriticalSection(&m_CS);

	if (a_NotificationHandler != NULL)
	{
		m_NotificationHandler = a_NotificationHandler;
		m_NotificationHandler->AddRef();
	}

	if (a_Ctx != NULL)
	{
		m_Ctx = a_Ctx;
		m_Ctx->AddRef();
	}

	if (a_Provider != NULL)
	{
		m_Provider = a_Provider;
		m_Provider->AddRef();
	}
}

CPingTaskObject::~CPingTaskObject ()
{
	if (m_NotificationHandler != NULL)
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = TRUE;
    
		if ( FAILED(m_ErrorObject.GetStatus ()) )
		{
			t_Status = GetStatusObject ( &t_NotifyStatus ) ;
		}

		if ( t_Status )
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetStatus () , 0 , t_NotifyStatus ) ;
        
			if (t_NotifyStatus)
			{
				t_NotifyStatus->Release () ;
			}
		}
		else
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetStatus () , 0 , NULL ) ;
		}

		m_NotificationHandler->Release();
		m_NotificationHandler = NULL;
	}

	if (m_Ctx != NULL)
	{
		m_Ctx->Release();
		m_Ctx = NULL;
	}

	if (m_Provider != NULL)
	{
		m_Provider->Release();
		m_Provider = NULL;
	}

	if (m_ThreadToken != NULL)
	{
		CloseHandle(m_ThreadToken);
		m_ThreadToken = NULL;
	}

	DeleteCriticalSection(&m_CS);
}

void CPingTaskObject::DecrementPingCount()
{
	if (0 == InterlockedDecrement(&m_PingCount))
	{
		delete this;
	}
}

BOOL CPingTaskObject :: GetThreadToken()
{
	BOOL t_RetVal = OpenThreadToken(
							  GetCurrentThread(),									// handle to thread
							  TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,	// access to process
							  TRUE,												// use thread security
							  &m_ThreadToken										// pointer to token handle
							);

	if (!t_RetVal)
	{
			SetErrorInfo(IDS_DUP_THRDTOKEN  ,
						WBEM_E_ACCESS_DENIED ) ;
	}

	return t_RetVal;
}

BOOL CPingTaskObject :: SetThreadToken(BOOL a_Reset)
{
	BOOL t_RetVal = ::SetThreadToken(NULL, a_Reset ? NULL : m_ThreadToken);

	return t_RetVal;
}

BOOL CPingTaskObject :: GetStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( m_Provider->GetNotificationObject ( m_Ctx, a_NotifyObject ) )
    {
		_variant_t t_Variant((long) m_ErrorObject.GetStatus (), VT_I4) ;
		t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			LPCWSTR t_descr = m_ErrorObject.GetDescription ();

			if ( t_descr != NULL ) 
			{
				t_Variant = t_descr ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;

				if ( ! SUCCEEDED ( t_Result ) )
				{
					(*a_NotifyObject)->Release () ;
					*a_NotifyObject = NULL;
				}
			}
		}
		else
		{
			(*a_NotifyObject)->Release () ;
			*a_NotifyObject = NULL ;
		}
	}

	return (SUCCEEDED (t_Result)) ;
}


BOOL CPingTaskObject::GetClassObject ( IWbemClassObject **a_ppClass )
{
	BOOL t_bRetVal = FALSE;

	if ((a_ppClass != NULL) && (m_Provider != NULL))
	{
		*a_ppClass = NULL;

		if (m_Provider->GetClassObject(a_ppClass) && ((*a_ppClass) != NULL))
		{
			t_bRetVal = TRUE;
		}
	}

	return t_bRetVal;
}

HRESULT CPingTaskObject::Icmp_ResolveAddress ( LPCWSTR a_Path , ULONG &a_IpAddress, DWORD *a_pdwErr )
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

	if (a_pdwErr)
	{
		*a_pdwErr = 0 ;
	}

	ProvIpAddressType t_IpAddress ( a_Path ) ;

	if ( ! t_IpAddress.IsValid () ) 
	{
		char *t_AnsiAddress = UnicodeToDbcsString ( a_Path ) ;

		if ( t_AnsiAddress )
		{
			struct hostent *t_HostEntry = gethostbyname ( t_AnsiAddress  ) ;

			if ( t_HostEntry )
			{
				/*
				 * If we find a host entry, set up the internet address
				 */
				t_IpAddress = ProvIpAddressType ( ntohl ( * ( long * ) t_HostEntry->h_addr ) ) ;
			}
			else
			{
				DWORD dwErr = WSAGetLastError();

				if (a_pdwErr)
				{
					*a_pdwErr = dwErr ;
				}
			}

			delete [] t_AnsiAddress ;
		}
	}
	
	if (  t_IpAddress.IsValid () ) 
	{
		a_IpAddress = htonl ( t_IpAddress.GetValue () ) ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

HRESULT CPingTaskObject::SetInstanceKeys(IWbemClassObject *a_Inst , CPingCallBackObject *a_Reply)
{
	if ((a_Inst == NULL) || (a_Reply == NULL))
	{
		return WBEM_E_FAILED;
	}

	//set all 11 keys!

	HRESULT t_RetVal = SetUint32Property( a_Inst, Ping_Timeout, a_Reply->GetTimeout() ) ;

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_TimeToLive, a_Reply->GetTimeToLive() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_BufferSize, a_Reply->GetSendSize() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_TypeofService, a_Reply->GetTypeofService() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_RecordRoute, a_Reply->GetRecordRoute() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_TimestampRoute, a_Reply->GetTimestampRoute() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_SourceRouteType, a_Reply->GetSourceRouteType() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetBOOLProperty( a_Inst, Ping_NoFragmentation, a_Reply->GetNoFragmentation() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetBOOLProperty( a_Inst, Ping_ResolveAddressNames, a_Reply->GetResolveAddress() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetStringProperty( a_Inst, Ping_SourceRoute, a_Reply->GetSourceRoute() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetStringProperty( a_Inst, Ping_Address, a_Reply->GetAddressString()) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		//not a key so we don't report if this fails...
		SetUint32Property( a_Inst, Ping_ResolveError, a_Reply->GetResolveError() ) ;
	}

	return t_RetVal;
}

HRESULT CPingTaskObject::SetUint32Property(

	IWbemClassObject *a_Inst,
	LPCWSTR a_Name,
	ULONG a_Val
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var((long)a_Val);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

HRESULT CPingTaskObject::SetUint32ArrayProperty(
												
	IWbemClassObject *a_Inst ,
	LPCWSTR a_Name ,
	ULONG* a_Vals ,
	ULONG a_Count
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

    SAFEARRAYBOUND t_rgsabound[1];
    SAFEARRAY* t_psa = NULL;
    t_rgsabound[0].lLbound = 0;
    t_rgsabound[0].cElements = a_Count;
    t_psa = SafeArrayCreate(VT_I4, 1, t_rgsabound);
	HRESULT t_RetVal = S_OK;

	if (NULL != t_psa)
	{
		try
		{
			LONG *t_pdata = NULL;

			if (SUCCEEDED(SafeArrayAccessData(t_psa, (void **)&t_pdata)))
			{
				try
				{
					memcpy((void *)t_pdata, (void *)a_Vals, a_Count*sizeof(ULONG));
					SafeArrayUnaccessData(t_psa);
				}
				catch (...)
				{
					SafeArrayUnaccessData(t_psa);
					throw;
				}

				VARIANT t_var;
				VariantInit(&t_var);
				t_var.vt = VT_ARRAY|VT_I4;
				t_var.parray = t_psa;
				t_psa = NULL;

				try
				{
					t_RetVal = a_Inst->Put(a_Name, 0, &t_var, 0);
				}
				catch (...)
				{
					VariantClear(&t_var);
					throw;
				}
				
				VariantClear(&t_var);
			}
		}
		catch(...)
		{
			if (t_psa != NULL)
			{
				SafeArrayDestroy(t_psa);
			}

			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return t_RetVal;
}


HRESULT CPingTaskObject::SetStringProperty(

	IWbemClassObject *a_Inst,
	LPCWSTR a_Name,
	LPCWSTR a_Val
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var(a_Val);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

HRESULT CPingTaskObject::SetBOOLProperty(

	IWbemClassObject *a_Inst,
	LPCWSTR a_Name,
	BOOL a_Val
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var(a_Val ? true : false);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

void CPingTaskObject::IPAddressToString(_variant_t &a_var, ULONG a_Val, BOOL a_Resolve)
{
	if (!a_Resolve)
	{
		ProvIpAddressType t_ProtocolAddress ( ntohl(a_Val) ) ;
		wchar_t *t_AddressString = t_ProtocolAddress.GetStringValue () ;
		a_var = t_AddressString;
		delete [] t_AddressString ;
	}
	else
	{
		struct in_addr t_Address;
		t_Address.S_un.S_addr = a_Val; //assumes in param in network order when resolving
		struct hostent *t_hostent = gethostbyaddr((char *) &t_Address, sizeof(t_Address), AF_INET);

		if (t_hostent != NULL)
		{
			a_var = t_hostent->h_name;
		}
		else
		{
			ProvIpAddressType t_ProtocolAddress ( ntohl(a_Val) ) ;
			wchar_t *t_AddressString = t_ProtocolAddress.GetStringValue () ;
			a_var = t_AddressString;
			delete [] t_AddressString ;
		}
	}
}

HRESULT CPingTaskObject::SetIPProperty(

	IWbemClassObject *a_Inst ,
	LPCWSTR a_Name ,
	ULONG a_Val ,
	BOOL a_Resolve
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var;
	IPAddressToString(t_var, a_Val, a_Resolve);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

HRESULT CPingTaskObject::SetIPArrayProperty(
											
	IWbemClassObject *a_Inst ,
	LPCWSTR a_Name ,
	ULONG* a_Vals ,
	ULONG a_Count ,
	BOOL a_Resolve
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

    SAFEARRAYBOUND t_rgsabound[1];
    SAFEARRAY* t_psa = NULL;
    t_rgsabound[0].lLbound = 0;
    t_rgsabound[0].cElements = a_Count;
    t_psa = SafeArrayCreate(VT_BSTR, 1, t_rgsabound);
	HRESULT t_RetVal = S_OK;

	if (NULL != t_psa)
	{
		try
		{
			BSTR *t_pdata = NULL;

			if (SUCCEEDED(SafeArrayAccessData(t_psa, (void **)&t_pdata)))
			{
				try
				{
					for (int i = 0; i < a_Count; i++)
					{
						_variant_t t_var;
						IPAddressToString(t_var, a_Vals[i], a_Resolve);
						VARIANT t_NoDelVar = t_var.Detach() ;
						t_pdata[i] = t_NoDelVar.bstrVal;
					}

					SafeArrayUnaccessData(t_psa);
				}
				catch (...)
				{
					SafeArrayUnaccessData(t_psa);
					throw;
				}
				
				VARIANT t_var;
				VariantInit(&t_var);
				t_var.vt = VT_ARRAY|VT_BSTR;
				t_var.parray = t_psa;
				t_psa = NULL;

				try
				{
					t_RetVal = a_Inst->Put(a_Name, 0, &t_var, 0);
				}
				catch (...)
				{
					VariantClear(&t_var);
					throw;
				}
				
				VariantClear(&t_var);
			}
		}
		catch(...)
		{
			if (t_psa != NULL)
			{
				SafeArrayDestroy(t_psa);
			}

			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return t_RetVal;
}

HRESULT CPingTaskObject::Icmp_IndicateResolveError (CPingCallBackObject *a_Reply)
{
	HRESULT t_RetVal = S_OK;
	IWbemClassObjectPtr t_Cls;
	IWbemClassObjectPtr t_Inst;
	
	if (a_Reply != NULL)
	{
		if (GetClassObject ( &t_Cls ) )
		{
			t_RetVal = t_Cls->SpawnInstance(0, &t_Inst);

			if (SUCCEEDED (t_RetVal))
			{
				//put the keys...
				t_RetVal = SetInstanceKeys(t_Inst , a_Reply);

				if (SUCCEEDED(t_RetVal))
				{
					//Indicate!
					IWbemClassObject *t_pTmp = (IWbemClassObject*) t_Inst;
					m_NotificationHandler->Indicate(1, &t_pTmp);
				}
			}
		}
	}
	else
	{
		//should not be NULL!!
		t_RetVal = WBEM_E_FAILED;
	}

	return t_RetVal;
}

HRESULT CPingTaskObject::Icmp_DecodeAndIndicate (CPingCallBackObject *a_Reply)
{
	HRESULT t_RetVal = S_OK;
	PICMP_ECHO_REPLY t_Reply = ( PICMP_ECHO_REPLY ) a_Reply->GetReplyBuffer() ;
	IWbemClassObjectPtr t_Cls;
	IWbemClassObjectPtr t_Inst;
	
	if (t_Reply != NULL)
	{

		if (GetClassObject ( &t_Cls ) )
		{
			t_RetVal = t_Cls->SpawnInstance(0, &t_Inst);

			if (SUCCEEDED (t_RetVal))
			{
				//put the keys...
				t_RetVal = SetInstanceKeys(t_Inst , a_Reply);
			}

			if (SUCCEEDED (t_RetVal))
			{
				ULONG t_StatusCode = 0;

				if ( ( 0 != IcmpParseReplies(t_Reply, a_Reply->GetSendSize()) ) &&
					( t_Reply->Status == IP_SUCCESS ) )
				{
					ProvIpAddressType t_IpAddress((ULONG)ntohl(t_Reply->Address ));
					SetIPProperty(t_Inst , Ping_ProtocolAddress, t_Reply->Address , FALSE);
					
					if (a_Reply->GetResolveAddress())
					{
						SetIPProperty(t_Inst , Ping_ProtocolAddressResolved, t_Reply->Address , TRUE);
					}

					SetUint32Property( t_Inst, Ping_ResponseTime, t_Reply->RoundTripTime ) ;
					SetUint32Property( t_Inst, Ping_ResponseTimeToLive, t_Reply->Options.Ttl ) ;
					SetUint32Property( t_Inst, Ping_ReplySize, t_Reply->DataSize ) ;
					
					BOOL t_ReplyInconsistency = FALSE;

					if ( t_Reply->DataSize == a_Reply->GetSendSize() ) 
					{
						try
						{
							UCHAR *t_SendPtr = & ( a_Reply->GetSendBuffer() [ 0 ] );
							UCHAR *t_ReplyPtr = (UCHAR*) t_Reply->Data ;

							for (ULONG t_Index = 0; t_Index < t_Reply->DataSize; t_Index ++ )
							{
								if ( *t_SendPtr ++ != *t_ReplyPtr ++ ) 
								{
									t_ReplyInconsistency = TRUE ;
									break;
								}
							}
						}
						catch(...)
						{
							t_ReplyInconsistency = TRUE ;
						}
					}
					else
					{
						t_ReplyInconsistency = TRUE ;
					}

					SetBOOLProperty( t_Inst, Ping_ReplyInconsistency, t_ReplyInconsistency ) ;

					if ( t_Reply->Options.OptionsSize )
					{
						ULONG t_RouteSourceCount = 0;
						ULONG *t_RouteSource = NULL;
						ULONG t_TimestampCount = 0;
						ULONG *t_Timestamp = NULL;
						ULONG *t_TimestampRoute = NULL;

						HRESULT t_Result = Icmp_DecodeResponse (

							t_Reply ,
							t_RouteSourceCount ,
							t_RouteSource ,
							t_TimestampCount ,
							t_TimestampRoute ,
							t_Timestamp
						) ;

						if (SUCCEEDED (t_Result))
						{
							if (t_RouteSource != NULL)
							{
								SetIPArrayProperty(
												
									t_Inst ,
									Ping_RouteRecord ,
									t_RouteSource ,
									t_RouteSourceCount ,
									FALSE
								);
							}

							if (t_TimestampRoute != NULL)
							{
								SetIPArrayProperty(
												
									t_Inst ,
									Ping_TimeStampRecordAddress ,
									t_TimestampRoute ,
									t_TimestampCount ,
									FALSE
								);
							}

							if (t_Timestamp != NULL)
							{
								SetUint32ArrayProperty(
																				
									t_Inst ,
									Ping_TimeStampRecord ,
									t_Timestamp ,
									t_TimestampCount
								);
							}

							if (a_Reply->GetResolveAddress())
							{
								if (t_RouteSource != NULL)
								{
									SetIPArrayProperty(
													
										t_Inst ,
										Ping_RouteRecordResolved ,
										t_RouteSource ,
										t_RouteSourceCount ,
										TRUE
									);
								}

								if (t_TimestampRoute != NULL)
								{
									SetIPArrayProperty(
													
										t_Inst ,
										Ping_TimeStampRecordAddressResolved ,
										t_TimestampRoute ,
										t_TimestampCount ,
										TRUE
									);
								}
							}

							delete [] t_RouteSource;
							delete [] t_TimestampRoute;
							delete [] t_Timestamp;
						}
					}
				}
				else 
				{
					t_StatusCode = 	t_Reply->Status ;
				}

				SetUint32Property( t_Inst, Ping_StatusCode, t_StatusCode ) ;
			}

			if (SUCCEEDED(t_RetVal))
			{
				//Indicate!
				IWbemClassObject *t_pTmp = (IWbemClassObject*) t_Inst;
				m_NotificationHandler->Indicate(1, &t_pTmp);
			}
		}
		else
		{
			t_RetVal = WBEM_E_FAILED;
		}
	}
	else
	{
		//should not be NULL!!
		t_RetVal = WBEM_E_FAILED;
	}

	return t_RetVal;
}

void CPingTaskObject::SetErrorInfo(DWORD a_ErrMsgID, HRESULT a_HRes, BOOL a_Force)
{
	CCritSecAutoUnlock t_AutoLockUnlock(&m_CS);

	if (a_Force || SUCCEEDED(m_ErrorObject.GetStatus()) )
	{
		//convert id to string...
		WCHAR t_ErrMsgBuff[255];
		WCHAR *t_ErrMsg = t_ErrMsgBuff;
		int t_buffSz = 255;
		int t_copied = LoadString(ghModule, a_ErrMsgID, t_ErrMsg, t_buffSz);

		//try expanding a couple of times
		//if it is still too big, too bad it'll be truncated
		//not even localized strings should be this big (1500chars = 3k)
		for (int i = 2; (i < 4) && (t_copied == t_buffSz); i++)
		{
			t_ErrMsg = new WCHAR[t_buffSz * i];
			t_buffSz = t_buffSz * i;
			t_copied = LoadString(ghModule, a_ErrMsgID, t_ErrMsg, t_buffSz);
		}

		m_ErrorObject.SetInfo(t_ErrMsg, a_HRes);

		if (t_ErrMsg != t_ErrMsgBuff)
		{
			delete [] t_ErrMsg;
		}
	}
}

HRESULT CPingTaskObject::Icmp_DecodeResponse (PICMP_ECHO_REPLY a_Reply ,
											  ULONG &a_RouteSourceCount ,
											  ULONG *&a_RouteSource ,
											  ULONG &a_TimestampCount ,
											  ULONG *&a_TimestampRoute ,
											  ULONG *&a_Timestamp)
{
	HRESULT t_Result = S_OK ;

    uchar *t_OptionPtr = a_Reply->Options.OptionsData ;
    uchar *t_EndPtr = t_OptionPtr + a_Reply->Options.OptionsSize ;
	BOOL t_Done = FALSE ;

	try
	{
		while ( ( t_OptionPtr < t_EndPtr ) && ! t_Done ) 
		{
			// Get the option type

			switch ( t_OptionPtr [ 0 ] )
			{
				case IP_OPT_EOL:
				{
					t_Done = TRUE;
				}
				break;

				case IP_OPT_NOP:
				{
					t_OptionPtr ++ ;
				}
				break ;

				case IP_OPT_SECURITY:
				{
					t_OptionPtr += 11 ;
				}
				break ;

				case IP_OPT_SID:
				{
					t_OptionPtr += 4;
				}
				break;

				case IP_OPT_RR:
				case IP_OPT_LSRR:
				case IP_OPT_SSRR:
				{
					if ( ( t_OptionPtr + 3 ) <= t_EndPtr ) 
					{
						ULONG t_OptionLength = t_OptionPtr [ 1 ] ;

						if ( ( ( t_OptionPtr + t_OptionLength ) > t_EndPtr ) || ( t_OptionLength < 3 ) )
						{
							// INVALID_RR_OPTION

							t_Done = TRUE ;
							t_Result = WBEM_E_FAILED ;
						}
						else
						{
							ULONG t_RouteTableEndOffset = t_OptionPtr [ 2 ] ;

							if ( t_RouteTableEndOffset < 4 )
							{
								// Advance because the entry is a bad encoding, require 4 bytes for atleast one address

								t_OptionPtr += t_OptionLength ;
							}
							else
							{
								if ( t_RouteTableEndOffset > ( t_OptionLength + 1 ) ) 
								{
									// The actual route table end index is larger than the option itself, therefore decode as much as possible

									t_RouteTableEndOffset = t_OptionLength + 1 ;
								}

								// Count the entries

								ULONG t_RouteEntryOffset = 4 ;
								a_RouteSourceCount = 0;

								while ( ( t_RouteEntryOffset + 3 ) < t_RouteTableEndOffset ) 
								{
									a_RouteSourceCount ++ ;
									t_RouteEntryOffset += 4 ;
								}

								// Extract the routes
								
								if (a_RouteSourceCount > 0)
								{
									a_RouteSource = new ULONG[a_RouteSourceCount];
									a_RouteSourceCount = 0;
									t_RouteEntryOffset = 4 ;

									while ( ( t_RouteEntryOffset + 3 ) < t_RouteTableEndOffset ) 
									{
//										a_RouteSource[a_RouteSourceCount++] = * ( ( IPAddr * ) ( t_OptionPtr + t_RouteEntryOffset - 1 ) ) ;
										memcpy ( &a_RouteSource[a_RouteSourceCount++], t_OptionPtr + t_RouteEntryOffset - 1, sizeof ( IPAddr ) );
										t_RouteEntryOffset += 4 ;
									}
								}
								// Advance to the next option

								t_OptionPtr += t_OptionLength ;
							}
						}
					}
					else
					{
						// INVALID_RR_OPTION

						t_Done = TRUE ;
						t_Result = WBEM_E_FAILED ;
					}
				}
				break;

				case IP_OPT_TS:
				{
					if ( ( t_OptionPtr + 4 ) <= t_EndPtr ) 
					{
						ULONG t_OptionLength = t_OptionPtr [ 1 ] ;
						ULONG t_TimestampTableEndOffset = t_OptionPtr [ 2 ] ;

						if ( t_TimestampTableEndOffset >= 5 )
						{
							if ( t_TimestampTableEndOffset > ( t_OptionLength + 1 ) ) 
							{
								// The actual timestamp table end index is larger than the option itself, therefore decode as much as possible

								t_TimestampTableEndOffset = t_OptionLength + 1 ;
							}

							ULONG t_AddressMode = t_OptionPtr [ 3 ] & 1 ;

							// Count the entries

							ULONG t_TimestampEntryOffset = 5 ;

							while ( ( t_TimestampEntryOffset + 3 ) < t_TimestampTableEndOffset )
							{
								if ( t_AddressMode )
								{
									if ( ( t_TimestampEntryOffset + 8 ) <= t_TimestampTableEndOffset )
									{
										t_TimestampEntryOffset += 8 ;
									}
									else
									{
										break;
									}
								}
								else
								{
									t_TimestampEntryOffset += 4 ;
								}

								a_TimestampCount++ ;
							}

							// Extract the entries
							if (a_TimestampCount > 0)
							{
								a_TimestampRoute = new ULONG[a_TimestampCount];
								a_Timestamp = new ULONG[a_TimestampCount];
								a_TimestampCount = 0;
								t_TimestampEntryOffset = 5 ;

								while ( ( t_TimestampEntryOffset + 3 ) < t_TimestampTableEndOffset )
								{
									if (( t_AddressMode ) && ( ( t_TimestampEntryOffset + 8 ) <= t_TimestampTableEndOffset ))
									{
//										a_TimestampRoute[a_TimestampCount] = * ( ( IPAddr * ) ( t_OptionPtr + t_TimestampEntryOffset - 1 ) ) ;
										memcpy ( &a_TimestampRoute[a_TimestampCount], t_OptionPtr + t_TimestampEntryOffset - 1, sizeof ( IPAddr ) );
										t_TimestampEntryOffset += 4 ;
									}
									else
									{
										a_TimestampRoute[a_TimestampCount] = 0;
									}

//									a_Timestamp[a_TimestampCount++] = * ( ( ULONG * ) ( t_OptionPtr + t_TimestampEntryOffset - 1 ) ) ;
									memcpy ( &a_Timestamp[a_TimestampCount++], t_OptionPtr + t_TimestampEntryOffset - 1, sizeof ( ULONG ) );
									t_TimestampEntryOffset += 4 ;
								}
							}

							t_OptionPtr += t_OptionLength ;
						}
						else
						{
							// INVALID_RR_OPTION

							t_Done = TRUE ;
							t_Result = WBEM_E_FAILED ;
						}
					}
					else
					{
						// INVALID_TS_OPTION

						t_Done = TRUE ;
						t_Result = WBEM_E_FAILED ;
					}
				}
				break;

				default:
				{
					if ( ( t_OptionPtr + 2 ) > t_EndPtr ) 
					{
						t_Done = TRUE ;
					}
					else
					{
						t_OptionPtr += t_OptionPtr [ 1 ] ;
					}
				}
				break;
			}
		}
	}
	catch (...)
	{
		if (a_RouteSource != NULL)
		{
			delete [] a_RouteSource;
			a_RouteSource = NULL;
		}

		if (a_TimestampRoute != NULL)
		{
			delete [] a_TimestampRoute;
			a_TimestampRoute = NULL;
		}

		if (a_Timestamp != NULL)
		{
			delete [] a_Timestamp;
			a_Timestamp = NULL;
		}

		throw;
	}

	if (FAILED(t_Result))
	{
		if (a_RouteSource != NULL)
		{
			delete [] a_RouteSource;
			a_RouteSource = NULL;
		}

		if (a_TimestampRoute != NULL)
		{
			delete [] a_TimestampRoute;
			a_TimestampRoute = NULL;
		}

		if (a_Timestamp != NULL)
		{
			delete [] a_Timestamp;
			a_Timestamp = NULL;
		}
	}

	return t_Result ;
}

HRESULT CPingTaskObject::Icmp_RequestResponse (

   LPCWSTR a_AddressString ,
   ULONG a_Address ,
   ULONG a_TimeToLive ,
   ULONG a_Timeout ,
   ULONG a_SendSize ,
   BOOL a_NoFragmentation ,
   ULONG a_TypeofService ,
   ULONG a_RecordRoute ,
   ULONG a_TimestampRoute ,
   ULONG a_SourceRouteType ,
   LPCWSTR a_SourceRoute,
   BOOL a_ResolveAddress,
   ULONG a_ResolveError
)
{
	HRESULT t_Result = S_OK ;

	CPingCallBackObject *t_Ctxt = new CPingCallBackObject(
			
											this,
											a_AddressString,
											a_Address,
											a_TimeToLive,
											a_Timeout,
											a_SendSize,
											a_NoFragmentation,
											a_TypeofService,
											a_RecordRoute,
											a_TimestampRoute,
											a_SourceRouteType,
											a_SourceRoute,
											a_ResolveAddress,
											a_ResolveError
										);
	t_Ctxt->AddRef();

	try
	{
		if (a_ResolveError == 0)
		{
			//attach t_Ctxt to thread and make the thread do a
			//t_Ctxt->SendEcho();
			BOOL t_Sent = FALSE;
			WmiStatusCode t_StatusCode = t_Ctxt->Initialize () ;

			if (t_StatusCode == e_StatusCode_Success )
			{
				t_StatusCode = CPingProvider :: s_PingThread->EnQueue (0 , *t_Ctxt) ;

				if (t_StatusCode == e_StatusCode_Success )
				{
					t_Sent = TRUE;
				}
			}
			
			if (!t_Sent)
			{
				t_Result = WBEM_E_FAILED ;
				SetErrorInfo(IDS_ICMPECHO ,
										 WBEM_E_FAILED ) ;
				try
				{
					t_Ctxt->Release();
				}
				catch(...)
				{
					t_Ctxt = NULL;
					throw;
				}
			}
		}
		else
		{
			t_Result = Icmp_IndicateResolveError(t_Ctxt);
			t_Ctxt->Disconnect();
			t_Ctxt->Release();
			t_Ctxt = NULL;

			if (SUCCEEDED(t_Result))
			{
				DecrementPingCount();
			}
		}
	}
	catch (...)
	{
		t_Ctxt->Release();
		throw;
	}

    return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\stdafx.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntstatus.h>
}

#include <objbase.h>
#include <initguid.h>
#include <fwcommon.h>
#include <cominit.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\inc\pingfac.h ===
// (C) 1999 Microsoft Corporation 

#ifndef _PingProvClassFactory_H
#define _PingProvClassFactory_H

class CPingProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;


    CPingProviderClassFactory () ;
    ~CPingProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#endif // _PingProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMIPRECOMP=1

TARGETNAME=WMIPICMP
TARGETPATH=obj
TARGETTYPE=DYNLINK

USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
USE_STL=1

C_DEFINES=$(C_DEFINES) /D_WINDLL /D_WIN32_DCOM

DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\IcmpEcho.def

LINKLIBS= \
	$(FRAMEWORK_MFC_LIB)

TARGETLIBS=\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(NET_LIB_PATH)\icmp.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\rpcutil.lib \
	$(SDK_LIB_PATH)\wbemuuid.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\wsock32.lib \
	$(UTILLIB_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(CIMWIN32_LIB) \
 	$(FRAMEWORK_THRD_LIB) \
	$(FRAMEWORK_EXPT_LIB) \
	$(CONTAINER_LIB) \
	$(WBEMCOMN_STATIC_LIB)


INCLUDES=\
	$(INCLUDES); \
	..\..\inc ; \
	.. ; \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(FRAMEWORK_EXPT_INC); \
 	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_MFC_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(WMIIDL_INC); \
	$(CIMWIN32_LIB_INC); \
	$(NET_INC_PATH); \
        $(WBEMCOMN_INC)



SOURCES=\
	IcmpEcho.rc  \
	MainDll.cpp \
	pingfac.cpp \
	pingprov.cpp \
	pingtask.cpp \
	pingget.cpp \
	pingquery.cpp \
	pingcallback.cpp \
	globals.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\dll\res_str.h ===
/******************************************************************

   CPingProvider.CPP -- WMI provider class implementation



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  
   
******************************************************************/


#define IDS_CALLBACK_PREMATURE          1
#define IDS_IMPERSONATE_RECEIVE         2
#define IDS_ICMPCREATEFILE_FAIL         3
#define IDS_RR_MAX                      4
#define IDS_RR_MAX_INDEX                5
#define IDS_TS_MAX                      6
#define IDS_TS_MAX_INDEX                7
#define IDS_SR_MAX                      8
#define IDS_SR_MAX_INDEX                9
#define IDS_SR_PARSE                    10
#define IDS_ICMPSENDECHO2               11
#define IDS_IMPERSONATE_SEND            12
#define IDS_DUP_THRDTOKEN               13
#define IDS_ICMPECHO                    14
#define IDS_CLASS_DEFN                  15
#define IDS_INVALID_CLASS               16
#define IDS_OBJ_PATH                    17
#define IDS_OBJ_PATH_KEYS               18
#define IDS_OBJ_PATH_DUP_KEYS           19
#define IDS_OBJ_PATH_ADDR               20
#define IDS_ADDR_TYPE                   21
#define IDS_TO_TYPE                     22
#define IDS_TTL_TYPE                    23
#define IDS_BUFF_TYPE                   24
#define IDS_NOFRAG_TYPE                 25
#define IDS_TOS_TYPE                    26
#define IDS_RR_TYPE                     27
#define IDS_TS_TYPE                     28
#define IDS_SRT_TYPE                    29
#define IDS_SR_TYPE                     30
#define IDS_RA_TYPE                     31
#define IDS_UNK_PROP                    32
#define IDS_UNK_KEY                     33
#define IDS_NO_KEYS                     34
#define IDS_DECODE_GET                  35
#define IDS_QUERY_ADDR                  36
#define IDS_QUERY_ADDR_INVALID          37
#define IDS_QUERY_TO                    38
#define IDS_QUERY_TTL                   39
#define IDS_QUERY_BUF                   40
#define IDS_QUERY_NOFRAG                41
#define IDS_QUERY_TOS                   42
#define IDS_QUERY_RR                    43
#define IDS_QUERY_TS                    44
#define IDS_QUERY_SRT                   45
#define IDS_QUERY_SR                    46
#define IDS_QUERY_RA                    47
#define IDS_QUERY_BROAD                 48
#define IDS_QUERY_NARROW                49
#define IDS_QUERY_UNUSABLE              50
#define IDS_QUERY_ANALYZE               51
#define IDS_QUERY_PARSE                 52
#define IDS_DECODE_QUERY                53
#define IDS_BUFFSIZE_VALUE				54
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\inc\pingprov.h ===
/******************************************************************

   CPingProvider.H -- WMI provider class definition

 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _CPingProvider_H_
#define _CPingProvider_H_

#define PROVIDER_NAME_CPINGPROVIDER L"Win32_PingStatus"

// Property name externs -- defined in CPingProvider.cpp
//=================================================

#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 128
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             1000L
#define MIN_INTERVAL                1000L

#define WBEM_CLASS_EXTENDEDSTATUS			L"__ExtendedStatus"
#define WBEM_PROPERTY_STATUSCODE			L"StatusCode"
#define WBEM_PROPERTY_PROVSTATUSMESSAGE		L"Description"

#define PING_KEY_PROPERTY_COUNT		11


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

class CCritSecAutoUnlock
{
private:

	CRITICAL_SECTION *m_CritSec;
	BOOL m_bLocked;

public:

	CCritSecAutoUnlock(CRITICAL_SECTION *a_CritSec) : m_CritSec(NULL), m_bLocked(FALSE)
	{
		EnterCriticalSection(a_CritSec);
		m_CritSec = a_CritSec;
		m_bLocked = TRUE;
	}

	~CCritSecAutoUnlock()
	{
		LeaveEarly();
	}

	void LeaveEarly()
	{
		if ((m_bLocked) && (m_CritSec != NULL))
		{
			LeaveCriticalSection(m_CritSec);
			m_CritSec = NULL;
			m_bLocked = FALSE;
		}
	}

};

class CKeyEntry
{
public:

	LPCWSTR m_key ;
	
public:

	CKeyEntry ( CKeyEntry & a_key )
	{
		m_key = a_key.Get();
	}

	CKeyEntry ( LPCWSTR a_key )
	{
		m_key = a_key;
	}

	CKeyEntry (void)
	{
		m_key = NULL;
	}

	~CKeyEntry ()
	{
		m_key = NULL ;
	}

	LPCWSTR Get ( ) const
	{
		return m_key ;
	}

	void *operator new ( size_t a_Size , CKeyEntry *a_key )
	{
		return a_key ;
	}

	void operator delete ( void *a_Ptr , CKeyEntry *a_key )
	{
	}

} ;

extern LONG CompareElement ( const CKeyEntry &a_Arg1 , const CKeyEntry & a_Arg2 );
extern BOOL operator== ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 );
extern BOOL operator< ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 );
extern ULONG Hash ( const CKeyEntry & a_Arg );

class CPingThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;
	BOOL m_Init;

protected:

public:	/* Internal */

    CPingThread (WmiAllocator & a_Allocator) ;

    ~CPingThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;
};

class CPingProvider : public IWbemServices, public IWbemProviderInit
{
private:
	LONG m_referenceCount ;         //Object reference count
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_ClassObject ;
	IWbemServices *m_server ;
	BOOL m_bInitial ;

protected:

	BOOL CreateNotificationObject ( IWbemContext *a_Ctx ) ;
	BOOL ImpersonateClient();

public:

	static CRITICAL_SECTION s_CS;
	static CPingThread *s_PingThread ;
	static WmiAllocator *s_Allocator ;
	static WmiHashTable <CKeyEntry, ULONG, 12> *s_HashTable; // one more bucket than we have keys.

	static HRESULT Global_Startup();
	static HRESULT Global_Shutdown();
	static LPCWSTR s_KeyTable[PING_KEY_PROPERTY_COUNT];

        // Constructor/destructor
        //=======================

        CPingProvider ();
        ~CPingProvider () ;

		BOOL GetClassObject ( IWbemClassObject **a_ppClass ) ;
		BOOL GetNotificationObject ( IWbemContext *a_Ctx , IWbemClassObject **a_ppObj );


	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize(

			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
			);        

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\ping\inc\pingtask.h ===
/******************************************************************



   PingTask.H -- Task object definitions



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved


   Description: 
   

*******************************************************************/

#ifndef _CPingTask_H_
#define _CPingTask_H_

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define PING_MAX_IPS ( MAX_OPT_SIZE / 4 /*sizeof(ULONG)*/ )

extern const WCHAR *Ping_Address;
extern const WCHAR *Ping_Timeout;
extern const WCHAR *Ping_TimeToLive;
extern const WCHAR *Ping_BufferSize;
extern const WCHAR *Ping_NoFragmentation;
extern const WCHAR *Ping_TypeofService;
extern const WCHAR *Ping_RecordRoute;
extern const WCHAR *Ping_TimestampRoute;
extern const WCHAR *Ping_SourceRouteType;
extern const WCHAR *Ping_SourceRoute;
extern const WCHAR *Ping_ResolveAddressNames;

#define PING_ADDRESS_INDEX				0
#define PING_TIMEOUT_INDEX				1
#define PING_TIMETOLIVE_INDEX			2
#define PING_BUFFERSIZE_INDEX			3
#define PING_NOFRAGMENTATION_INDEX		4
#define PING_TYPEOFSERVICE_INDEX		5
#define PING_RECORDROUTE_INDEX			6
#define PING_TIMESTAMPROUTE_INDEX		7
#define PING_SOURCEROUTETYPE_INDEX		8
#define PING_SOURCEROUTE_INDEX			9
#define PING_RESOLVEADDRESSNAMES_INDEX	10

class CPingTaskObject;

class CPingCallBackObject : public WmiTask < ULONG > 
{
private:
	
	CPingTaskObject *m_ParentTask;
	UCHAR *m_ReplyBuffer;
	UCHAR *m_SendBuffer;
	ULONG m_Address;
	ULONG m_TimeToLive;
	ULONG m_Timeout;
	ULONG m_SendSize;
	ULONG m_ReplySize;
	BOOL m_NoFragmentation;
	ULONG m_TypeofService;
	ULONG m_RecordRoute;
	ULONG m_TimestampRoute;
	ULONG m_SourceRouteType;
	CStringW m_AddressString;
	CStringW m_SourceRoute;
	ULONG m_SourceRouteArray[PING_MAX_IPS];
	ULONG m_SourceRouteCount;
	BOOL m_ResolveAddress;
	HANDLE m_IcmpHandle;
	ULONG m_ResolveError;

	BOOL ParseSourceRoute();
	void SendError(DWORD a_ErrMsgID, HRESULT a_HRes);
	BOOL GetIcmpHandle();

public:

	//Simple access methods
	UCHAR* GetReplyBuffer() { return m_ReplyBuffer ; }
	UCHAR* GetSendBuffer() { return m_SendBuffer ; }
	ULONG GetAddress() { return m_Address ; }
	LPCWSTR GetAddressString() { return m_AddressString ; }
	ULONG GetTimeToLive() { return m_TimeToLive ; }
	ULONG GetTimeout() { return m_Timeout ; }
	ULONG GetSendSize() { return m_SendSize ; }
	ULONG GetReplySize() { return m_ReplySize ; }
	BOOL GetNoFragmentation() { return m_NoFragmentation ; }
	ULONG GetTypeofService() { return m_TimeToLive ; }
	ULONG GetRecordRoute() { return m_RecordRoute ; }
	ULONG GetTimestampRoute() { return m_TimestampRoute ; }
	ULONG GetSourceRouteType() { return m_SourceRouteType ; }
	LPCWSTR GetSourceRoute() { return m_SourceRoute ; }
	ULONG* GetSourceRouteArray() { return m_SourceRouteArray ; }
	ULONG GetSourceRouteCount() { return m_SourceRouteCount ; }
	BOOL GetResolveAddress() { return m_ResolveAddress ; }
	ULONG GetResolveError() { return m_ResolveError ; }
	

	//Async call routines
	void HandleResponse();
	void SendEcho();

	CPingCallBackObject(
		CPingTaskObject *a_ParentTask,
		LPCWSTR a_AddressString,
		ULONG a_Address,
		ULONG a_TimeToLive,
		ULONG a_Timeout,
		ULONG a_SendSize,
		BOOL a_NoFragmentation,
		ULONG a_TypeofService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		ULONG a_SourceRouteType,
		LPCWSTR a_SourceRoute,
		BOOL a_ResolveAddress,
		ULONG a_ResolveError
	);

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
	void Disconnect() { m_ParentTask = NULL ; }

	~CPingCallBackObject();

};

class CPingTaskObject
{
private:

protected:

	class CPingErrorObject
	{
	private:
		LPWSTR	m_Description;
		HRESULT m_Status;

	public:
			CPingErrorObject(): m_Description(NULL), m_Status (S_OK) {}

		void	SetInfo(LPCWSTR a_description, HRESULT a_status);
		HRESULT	GetStatus() const { return m_Status; }
		LPCWSTR	GetDescription() const { return m_Description; }

			~CPingErrorObject();
	};

	CPingErrorObject m_ErrorObject ;
	IWbemObjectSink *m_NotificationHandler ;
	IWbemContext *m_Ctx ;
	CPingProvider *m_Provider ;
	HANDLE m_ThreadToken ;
	CRITICAL_SECTION m_CS;
	LONG m_PingCount;

	void SetErrorInfo(DWORD a_ErrMsgID, HRESULT a_HRes, BOOL a_Force = FALSE);
	HRESULT Icmp_DecodeAndIndicate (CPingCallBackObject *a_Reply);
	HRESULT Icmp_IndicateResolveError (CPingCallBackObject *a_Reply);
	void IPAddressToString(_variant_t &a_var, ULONG a_Val, BOOL a_Resolve);
	void DecrementPingCount();
	
	HRESULT SetInstanceKeys(IWbemClassObject *a_Inst , CPingCallBackObject *a_Reply);

	HRESULT SetStringProperty(

		IWbemClassObject *a_Inst,
		LPCWSTR a_name,
		LPCWSTR a_val
	) ;

	HRESULT SetBOOLProperty(

		IWbemClassObject *a_Inst,
		LPCWSTR a_name,
		BOOL a_val
	) ;

	HRESULT SetUint32Property(

		IWbemClassObject *a_Inst,
		LPCWSTR a_name,
		ULONG a_val
	) ;

	HRESULT SetUint32ArrayProperty(
												
		IWbemClassObject *a_Inst ,
		LPCWSTR a_Name ,
		ULONG* a_Vals ,
		ULONG a_Count
	) ;

	HRESULT SetIPProperty(

		IWbemClassObject *a_Inst ,
		LPCWSTR a_Name ,
		ULONG a_Val ,
		BOOL a_Resolve
	) ;

	HRESULT SetIPArrayProperty(
												
		IWbemClassObject *a_Inst ,
		LPCWSTR a_Name ,
		ULONG* a_Vals ,
		ULONG a_Count ,
		BOOL a_Resolve
	) ;

	HRESULT Icmp_DecodeResponse (

		PICMP_ECHO_REPLY a_Reply ,
		ULONG &a_RouteSourceCount ,
		ULONG *&a_RouteSource ,
		ULONG &a_TimestampCount ,
		ULONG *&a_TimestampRoute ,
		ULONG *&a_Timestamp
	) ;

	HRESULT Icmp_RequestResponse ( 

		LPCWSTR a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeToLive ,
		ULONG a_Timeout ,
		ULONG a_SendSize ,
		BOOL a_NoFragmentation ,
		ULONG a_TypeofService ,
		ULONG a_RecordRoute ,
		ULONG a_TimestampRoute ,
		ULONG a_SourceRouteType ,
		LPCWSTR a_SourceRoute,
		BOOL a_ResolveAddress,
		ULONG a_ResolveError
	) ;

	BOOL GetClassObject ( IWbemClassObject **a_ppClass ) ;
	BOOL SetProperties(CPingCallBackObject *a_Response) ;
	BOOL GetStatusObject ( IWbemClassObject **a_NotifyObject ) ;

public:

	CPingTaskObject (

		CPingProvider *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Ctx
	) ;

	virtual void HandleResponse (CPingCallBackObject *a_reply) = 0 ;
	virtual void HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes) = 0 ;
	BOOL GetThreadToken();
	BOOL SetThreadToken(BOOL a_Reset);
	static HRESULT Icmp_ResolveAddress ( LPCWSTR a_Path , ULONG &a_IpAddress , DWORD *a_pdwErr = NULL ) ;
	virtual ~CPingTaskObject () ;
} ;

class CPingGetAsync : public CPingTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

		HRESULT GetDefaultTTL ( DWORD &a_TimeToLive ) ;

public:

	~CPingGetAsync () ;
	CPingGetAsync (

		CPingProvider *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;
	
	BOOL GetObject () ;
	BOOL PerformGet () ;
	void HandleResponse (CPingCallBackObject *a_reply) ;
	void HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes) ;
} ;


class CPingQueryAsync : public CPingTaskObject, public QueryPreprocessor
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;

	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	HRESULT RecurseAddress (

		void *pMethodContext, 
		PartitionSet *a_PartitionSet
	) ;

	HRESULT RecurseTimeOut (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseTimeToLive (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseBufferSize (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseNoFragmentation (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseTypeOfService (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseRecordRoute (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseTimestampRoute (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseSourceRouteType (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseSourceRoute (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		ULONG a_SourceRouteType,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseResolveAddressNames (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		ULONG a_SourceRouteType,
		LPCWSTR a_SourceRoute,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	);

protected:

        // Reading Functions
        //============================

		WmiTreeNode *AllocTypeNode ( 

			void *a_Context ,
			BSTR a_PropertyName , 
			VARIANT &a_Variant , 
			WmiValueNode :: WmiValueFunction a_PropertyFunction ,
			WmiValueNode :: WmiValueFunction a_ConstantFunction ,
			WmiTreeNode *a_Parent 
		) ;

		QuadState InvariantEvaluate ( 

			void *a_Context ,
			WmiTreeNode *a_Operator ,
			WmiTreeNode *a_Operand 
		) ;

		WmiRangeNode *AllocInfiniteRangeNode (

			void *a_Context ,
			BSTR a_PropertyName 
		) ;

		virtual DWORD GetPriority ( BSTR a_PropertyName ) ;

public:

	CPingQueryAsync ( 

		CPingProvider *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CPingQueryAsync () ;

	BOOL ExecQuery () ;
	void HandleResponse (CPingCallBackObject *a_reply) ;
	void HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes) ;
} ;

#endif //_CPingTask_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\dummy.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: dummy.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "error.h"
#include "encdec.h"
#include "sec.h"
#include "vblist.h"
#include "pdu.h"
#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"
#include "session.h"

// over-rides the HandleEvent method provided by the
// WinSnmpSession. Alerts the owner of a sent frame event

LONG_PTR SessionWindow::HandleEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    LONG rc = 0;

    // check if the message needs to be handled

    if ( message == Window :: g_SentFrameEvent )
    {
        // inform the owner of a sent frame event

        owner.HandleSentFrame ( 

            ( SessionFrameId ) wParam ,
			( SnmpOperation * ) lParam 
        ) ;
    }
    else if ( message == Window :: g_DeleteSessionEvent )
    {
        // inform the owner of the event

        owner.HandleDeletionEvent () ;
    }
    else
    {
        return Window::HandleEvent(

            hWnd, 
            message, 
            wParam, 
            lParam
        );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\address.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: address.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "address.h"
#include <winsock.h>
#include <iomanip.h>

// this character separates the field values in a dot-notation representation
#define FIELD_SEPARATOR '.'
#define IPX_FIELD_SEPARATOR ':'


SnmpTransportIpAddress::SnmpTransportIpAddress ( IN  const UCHAR *address, IN const USHORT address_length ) 
{
    allocated = FALSE;
    is_valid = FALSE;

    if ( address_length != SNMP_IP_ADDR_LEN )
        return;

    is_valid = TRUE;

    for ( ULONG index = 0 ; index < SNMP_IP_ADDR_LEN ; index ++ )
    {
        field [ index ] = address [ index ] ;
    }
}


// sets the fields to the contents extracted from the dotted
// decimal address string in parameter
SnmpTransportIpAddress::SnmpTransportIpAddress ( IN const char *address , IN const ULONG addressResolution )
{
    allocated = FALSE;
    is_valid  = FALSE;

    if ( addressResolution & SNMP_ADDRESS_RESOLVE_VALUE )
    {
        is_valid = GetIpAddress ( address ) ;
        if ( is_valid == FALSE )
        {
// Try GetHostByName

            if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
            {
                hostent FAR *hostEntry = gethostbyname ( address ); 
                if ( hostEntry )
                {
                    is_valid = TRUE ;
                    field [ 0 ] = ( UCHAR ) hostEntry->h_addr [ 0 ] ;
                    field [ 1 ] = ( UCHAR ) hostEntry->h_addr [ 1 ] ;
                    field [ 2 ] = ( UCHAR ) hostEntry->h_addr [ 2 ] ;
                    field [ 3 ] = ( UCHAR ) hostEntry->h_addr [ 3 ] ;
                }
            }
        }   
    }
    else if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
    {
        hostent FAR *hostEntry = gethostbyname ( address ); 
        if ( hostEntry )
        {
            is_valid = TRUE ;
            field [ 0 ] = ( UCHAR ) hostEntry->h_addr [ 0 ] ;
            field [ 1 ] = ( UCHAR ) hostEntry->h_addr [ 1 ] ;
            field [ 2 ] = ( UCHAR ) hostEntry->h_addr [ 2 ] ;
            field [ 3 ] = ( UCHAR ) hostEntry->h_addr [ 3 ] ;
        }
    }
}

BOOL SnmpTransportIpAddress::ValidateAddress ( IN const char *address , IN const ULONG addressResolution )
{
    BOOL is_valid = FALSE ;

    if ( addressResolution & SNMP_ADDRESS_RESOLVE_VALUE )
    {

        // create a stream to read the fields from
        istrstream address_stream((char *)address);

        // contains the maximum value for a USHORT. used
        // for comparison with the field values read
        const UCHAR max_uchar = -1;

        // consecutive fields must be separated by a
        // FIELD_SEPARATOR
        char separator;

        // a field is first read into this for comparison
        // with max_uchar
        ULONG temp_field;

        // read the first three (USHORT,FIELD_SEPARATOR) pairs
        // check if the stream is good before each read
        for(int i=0; i < (SNMP_IP_ADDR_LEN-1); i++)
        {
            if ( !address_stream.good() )
                break;

            address_stream >> temp_field;
            if ( temp_field > max_uchar )
            {
                address_stream.clear ( ios :: badbit ) ;
                break;
            }

            if ( !address_stream.good() )
                break;

            address_stream >> separator;
            if ( separator != FIELD_SEPARATOR )
            {
                address_stream.clear ( ios :: badbit ) ;
                break;
            }
        }

        if ( address_stream.good() )
        {
            address_stream >> temp_field;
            if (temp_field <= max_uchar)
            {
            // make sure that there are is nothing more left in the
            // stream

                if ( address_stream.eof() )
                {
                    is_valid = TRUE;
                }
            }
        }

        if ( ! is_valid )
        {
            if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
            {
                hostent FAR *hostEntry = gethostbyname ( address ); 
                if ( hostEntry )
                {
                    is_valid = TRUE ;
                }
            }
        }
    }
    else
    {
        if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
        {
            hostent FAR *hostEntry = gethostbyname ( address ); 
            if ( hostEntry )
            {
                is_valid = TRUE ;
            }
        }
    }

    return is_valid ;
}

BOOL SnmpTransportIpAddress::GetIpAddress ( IN const char *address )
{
    // create a stream to read the fields from
    istrstream address_stream((char *)address);

    // contains the maximum value for a USHORT. used
    // for comparison with the field values read
    const UCHAR max_uchar = -1;

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
    char separator;

    // a field is first read into this for comparison
    // with max_uchar
    ULONG temp_field;

    is_valid = FALSE;

    // read the first three (USHORT,FIELD_SEPARATOR) pairs
    // check if the stream is good before each read
    for(int i=0; i < (SNMP_IP_ADDR_LEN-1); i++)
    {
        if ( !address_stream.good() )
            break;

        address_stream >> temp_field;
        if ( temp_field > max_uchar )
        {
            address_stream.clear ( ios :: badbit ) ;
            break;
        }


        field[i] = (UCHAR)temp_field;

        if ( !address_stream.good() )
            break;

        address_stream >> separator;
        if ( separator != FIELD_SEPARATOR )
        {
            address_stream.clear ( ios :: badbit ) ;
            break;
        }
    }

    if ( address_stream.good() )
    {
        address_stream >> temp_field;
        if (temp_field <= max_uchar)
        {
            field[SNMP_IP_ADDR_LEN-1] = (UCHAR)temp_field;

        // make sure that there are is nothing more left in the
        // stream

            if ( address_stream.eof() )
            {
                is_valid = TRUE;
            }
        }
    }

    return is_valid ;
}

// set the fields to the lower 32 bits in the ULONG parameter
// in general, sets the SNMP_IP_ADDR_LEN fields, each of size 8 bits

#pragma warning (disable:4244)

SnmpTransportIpAddress::SnmpTransportIpAddress( IN const ULONG address )
{
    allocated = FALSE;

    // flag starts with the last byte on

    ULONG hostOrder = ntohl ( address ) ;

    field [ 0 ] = ( hostOrder >> 24 ) & 0xff ;
    field [ 1 ] = ( hostOrder >> 16 ) & 0xff ;
    field [ 2 ] = ( hostOrder >> 8 ) & 0xff ;
    field [ 3 ] = hostOrder & 0xff ;

    is_valid = TRUE;
}

#pragma warning (default:4244)

// free the dotted notation string if it was allocated
SnmpTransportIpAddress::~SnmpTransportIpAddress()
{
    if ( allocated )
        delete[] dotted_notation;
}

// returns the number of fields copied
USHORT SnmpTransportIpAddress::GetAddress ( OUT UCHAR *address , IN const USHORT length ) const
{
    // if the stream is valid, copy the fields onto the
    // buffer pointed to by address.
    if ( is_valid )
    {
        // only these many fields need be copied
        USHORT len = MIN(length,SNMP_IP_ADDR_LEN);

        for(int i=0; i < len; i++)
            address[i] = field[i];

        return len;
    }
    else
        return 0;
}


// prepares a dot-notation representation of the address and points 
// the dotted_notation char ptr to the allocated string.
// Note: memory for the decimal notation string is allocated only when
// the char *GetAddress method is called (and the address is valid)
// this memory must be freed if required
char *SnmpTransportIpAddress::GetAddress() 
{
    // do all this only when the address is valid
    if ( is_valid )
    {
        // if already allocated, return the stored string
        if ( allocated )
            return dotted_notation;
        else
        {
            // create a temp. output stream to prepare the char string
            dotted_notation = new char[ MAX_ADDRESS_LEN ];
            allocated = TRUE;
            sprintf ( 

                dotted_notation, 
                "%d.%d.%d.%d" , 
                (ULONG)field[0],
                (ULONG)field[1],
                (ULONG)field[2],
                (ULONG)field[3]
            );

            return dotted_notation;
        }
    }
    else
        return NULL;
}


SnmpTransportAddress *SnmpTransportIpAddress::Copy () const
{
    SnmpTransportIpAddress *new_address = new SnmpTransportIpAddress();

    if ( is_valid )
        *new_address = field;

    return new_address;
}


// checks if the two instances represent equal addresses
BOOL SnmpTransportIpAddress::operator== ( IN const SnmpTransportIpAddress & address ) const
{
    // if both the instances are valid, then a field
    // by field comparison, starting with the most
    // significant field (index 0) yields the answer
    if ( (is_valid) && address.IsValid() )
    {
        UCHAR temp[SNMP_IP_ADDR_LEN];

        address.GetAddress(temp,SNMP_IP_ADDR_LEN);
    
        for(int i=0; i < SNMP_IP_ADDR_LEN; i++)
            if ( field[i] != temp[i] )
                return FALSE;

        return TRUE;
    }
    else    // if either of them is invalid, they
            // cannot be equal
        return FALSE;
}
        

// sets the internal address to the specified parameter
// and makes the instance valid
SnmpTransportIpAddress &SnmpTransportIpAddress::operator= ( IN const UCHAR *ipAddr )
{
    if ( ipAddr == NULL )
        return *this;

    const UCHAR max_uchar = -1;

    for(int i=0; i < SNMP_IP_ADDR_LEN; i++)
    {
        if ( ipAddr[i] > max_uchar )
            return *this;

        field[i] = ipAddr[i];
    }


    is_valid = TRUE;

    // if a dotted-notation char string was prepared for the previous address
    // free the allocated memory
    if ( allocated )
    {
        delete[] dotted_notation;
        allocated = FALSE;
    }
        
    return *this;
}


// copies the specified instance (parameter) onto itself
// if the parameter instance is found valid
SnmpTransportIpAddress &SnmpTransportIpAddress::operator= ( IN const SnmpTransportIpAddress &address )
{
    const UCHAR max_uchar = -1;

    // if valid, proceed
    if (address.IsValid())
    {
        // get address fields
        address.GetAddress(field,SNMP_IP_ADDR_LEN);

        // copy the obtained fields onto local fields
        for( int i=0; i < SNMP_IP_ADDR_LEN; i++ )
            if ( field[i] > max_uchar )
                return *this;

        is_valid = TRUE;

        // since the address changes, free the previously 
        // allocated dotted-notation char string
        if ( allocated )
        {
            delete[] dotted_notation;
            allocated = FALSE;
        }
    }

    return *this;
}


// returns the field requested by the parameter index
// if the index is illegal, an OutOfRange exception is
// raised
UCHAR SnmpTransportIpAddress::operator[] ( IN const USHORT index ) const
{
    // if valid and the index is legal, return the field
    if ( (is_valid) && (BETWEEN(index,0,SNMP_IP_ADDR_LEN)) )
        return field[index];

    // should never reach here if the caller checked the index
    return 0;
}

SnmpTransportIpxAddress::SnmpTransportIpxAddress ( IN  const UCHAR *address, IN const USHORT address_length )   
{
    allocated = FALSE;
    is_valid = FALSE;

    if ( address_length != SNMP_IPX_ADDR_LEN )
        return;

    is_valid = TRUE;

    for ( ULONG index = 0 ; index < SNMP_IPX_ADDR_LEN ; index ++ )
    {
        field [ index ] = address [ index ] ;
    }
}


// sets the fields to the contents extracted from the dotted
// decimal address string in parameter
SnmpTransportIpxAddress::SnmpTransportIpxAddress ( IN const char *address )
{
    allocated = FALSE;

    is_valid = GetIpxAddress ( address )    ;
}

UCHAR HexToDecInteger ( char token ) 
{
    if ( token >= '0' && token <= '9' )
    {
        return token - '0' ;
    }
    else if ( token >= 'a' && token <= 'f' )
    {
        return token - 'a' + 10 ;
    }
    else if ( token >= 'A' && token <= 'F' )
    {
        return token - 'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

#pragma warning (disable:4244)

BOOL SnmpTransportIpxAddress::ValidateAddress ( IN const char *address )
{
    BOOL is_valid = TRUE ;

    // create a stream to read the fields from
    istrstream address_stream((char *)address);

    address_stream.setf ( ios :: hex ) ;

    ULONG t_NetworkAddress ;
    address_stream >> t_NetworkAddress ;

    if ( address_stream.good() )
    {
    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
        char separator;

        address_stream >> separator;
        if ( separator == IPX_FIELD_SEPARATOR )
        {
            ULONG t_StationOctets = 0 ;
            while ( is_valid && t_StationOctets < 6 )
            {
                int t_OctetHigh = address_stream.get () ;
                int t_OctetLow = address_stream.get () ;

                if ( isxdigit ( t_OctetHigh ) && isxdigit ( t_OctetLow ) )
                {
                    t_StationOctets ++ ;
                }
                else
                {
                    is_valid = FALSE ;
                }
            }

            if ( t_StationOctets != 6 )
            {
                is_valid = FALSE ;
            }
        }

        if ( address_stream.eof() )
        {
            is_valid = TRUE;
        }
    }
    else
    {
        is_valid = FALSE ;
    }

    return is_valid ;

}

BOOL SnmpTransportIpxAddress::GetIpxAddress ( IN const char *address )
{
    // create a stream to read the fields from
    istrstream address_stream((char *)address);

    address_stream.setf ( ios :: hex ) ;

    is_valid = TRUE ;

    ULONG t_NetworkAddress ;
    address_stream >> t_NetworkAddress ;

    if ( address_stream.good() )
    {
        field [ 0 ] = ( t_NetworkAddress >> 24 ) & 0xff ;
        field [ 1 ] = ( t_NetworkAddress >> 16 ) & 0xff ;
        field [ 2 ] = ( t_NetworkAddress >> 8 ) & 0xff ;
        field [ 3 ] = t_NetworkAddress & 0xff ;

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
        char separator;

        address_stream >> separator;
        if ( separator == IPX_FIELD_SEPARATOR )
        {
            ULONG t_StationOctets = 0 ;
            while ( is_valid && t_StationOctets < 6 )
            {
                int t_OctetHigh = address_stream.get () ;
                int t_OctetLow = address_stream.get () ;

                if ( isxdigit ( t_OctetHigh ) && isxdigit ( t_OctetLow ) )
                {
                    UCHAR t_Octet = ( HexToDecInteger ( (char)t_OctetHigh ) << 4 ) + HexToDecInteger ( (char)t_OctetLow ) ;
                    field [ 4 + t_StationOctets ] = t_Octet ;
                    t_StationOctets ++ ;
                }
                else
                {
                    is_valid = FALSE ;
                }
            }

            if ( t_StationOctets != 6 )
            {
                is_valid = FALSE ;
            }
        }

        if ( address_stream.eof() )
        {
            is_valid = TRUE;
        }
    }
    else
    {
        is_valid = FALSE ;
    }

    return is_valid ;
}

#pragma warning (default:4244)

// free the dotted notation string if it was allocated
SnmpTransportIpxAddress::~SnmpTransportIpxAddress()
{
    if ( allocated )
        delete[] dotted_notation;
}

// returns the number of fields copied
USHORT SnmpTransportIpxAddress::GetAddress ( OUT UCHAR *address , IN const USHORT length ) const
{
    // if the stream is valid, copy the fields onto the
    // buffer pointed to by address.
    if ( is_valid )
    {
        // only these many fields need be copied
        USHORT len = MIN(length,SNMP_IPX_ADDR_LEN);

        for(int i=0; i < len; i++)
            address[i] = field[i];

        return len;
    }
    else
        return 0;
}


// prepares a dot-notation representation of the address and points 
// the dotted_notation char ptr to the allocated string.
// Note: memory for the decimal notation string is allocated only when
// the char *GetAddress method is called (and the address is valid)
// this memory must be freed if required
char *SnmpTransportIpxAddress::GetAddress() 
{
    // do all this only when the address is valid
    if ( is_valid )
    {
        // if already allocated, return the stored string
        if ( allocated )
            return dotted_notation;
        else
        {
            // create a temp. output stream to prepare the char string
            char temp[MAX_ADDRESS_LEN];
            ostrstream temp_stream(temp, MAX_ADDRESS_LEN);

            // if any problems with the stream return NULL
            if ( !temp_stream.good() )
                return NULL;

            temp_stream.setf ( ios :: hex ) ;
            temp_stream.width ( 8 ) ;
            temp_stream.fill ( '0' ) ;

            ULONG t_NetworkAddress = ( field [ 0 ] << 24 ) + 
                                     ( field [ 1 ] << 16 ) + 
                                     ( field [ 2 ] << 8  ) + 
                                     ( field [ 3 ] ) ;

            // output the fields separated by the FIELD_SEPARATOR onto the output stream
            temp_stream << t_NetworkAddress << IPX_FIELD_SEPARATOR ;
;
            for(int i=SNMP_IPX_NETWORK_LEN; (temp_stream.good()) && (i < SNMP_IPX_ADDR_LEN); i++)
            {
                temp_stream.width ( 2 ) ;
                temp_stream << (ULONG)field[i];
            }

            // if any problems with the stream return NULL
            if ( !temp_stream.good() )
                return NULL;

            // end of string
            temp_stream << (char)EOS;

            // allocate the required memory and copy the prepared string onto it
            int len = strlen(temp);
            dotted_notation = new char[len+1];
            allocated = TRUE;
            strcpy(dotted_notation, temp);

            return dotted_notation;
        }
    }
    else
        return NULL;
}


SnmpTransportAddress *SnmpTransportIpxAddress::Copy () const
{
    SnmpTransportIpxAddress *new_address = new SnmpTransportIpxAddress();

    if ( is_valid )
        *new_address = field;

    return new_address;
}


// checks if the two instances represent equal addresses
BOOL SnmpTransportIpxAddress::operator== ( IN const SnmpTransportIpxAddress & address ) const
{
    // if both the instances are valid, then a field
    // by field comparison, starting with the most
    // significant field (index 0) yields the answer
    if ( (is_valid) && address.IsValid() )
    {
        UCHAR temp[SNMP_IPX_ADDR_LEN];

        address.GetAddress(temp,SNMP_IPX_ADDR_LEN);
    
        for(int i=0; i < SNMP_IPX_ADDR_LEN; i++)
            if ( field[i] != temp[i] )
                return FALSE;

        return TRUE;
    }
    else    // if either of them is invalid, they
            // cannot be equal
        return FALSE;
}
        

// sets the internal address to the specified parameter
// and makes the instance valid
SnmpTransportIpxAddress &SnmpTransportIpxAddress::operator= ( IN const UCHAR *ipAddr )
{
    if ( ipAddr == NULL )
        return *this;

    const UCHAR max_uchar = -1;

    for(int i=0; i < SNMP_IPX_ADDR_LEN; i++)
    {
        if ( ipAddr[i] > max_uchar )
            return *this;

        field[i] = ipAddr[i];
    }


    is_valid = TRUE;

    // if a dotted-notation char string was prepared for the previous address
    // free the allocated memory
    if ( allocated )
    {
        delete[] dotted_notation;
        allocated = FALSE;
    }
        
    return *this;
}


// copies the specified instance (parameter) onto itself
// if the parameter instance is found valid
SnmpTransportIpxAddress &SnmpTransportIpxAddress::operator= ( IN const SnmpTransportIpxAddress &address )
{
    const UCHAR max_uchar = -1;

    // if valid, proceed
    if (address.IsValid())
    {
        // get address fields
        address.GetAddress(field,SNMP_IPX_ADDR_LEN);

        // copy the obtained fields onto local fields
        for( int i=0; i < SNMP_IPX_ADDR_LEN; i++ )
            if ( field[i] > max_uchar )
                return *this;

        is_valid = TRUE;

        // since the address changes, free the previously 
        // allocated dotted-notation char string
        if ( allocated )
        {
            delete[] dotted_notation;
            allocated = FALSE;
        }
    }

    return *this;
}


// returns the field requested by the parameter index
// if the index is illegal, an OutOfRange exception is
// raised
UCHAR SnmpTransportIpxAddress::operator[] ( IN const USHORT index ) const
{
    // if valid and the index is legal, return the field
    if ( (is_valid) && (BETWEEN(index,0,SNMP_IPX_ADDR_LEN)) )
        return field[index];

    // should never reach here if the caller checked the index
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\flow.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: flow.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "flow.h"
#include "frame.h"
#include "message.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "dummy.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"

// Add to the end of the queue.
void MessageStore::Enqueue( Message &new_message )
{
    AddTail(&new_message);
}


// Remove and return the first element in the Store
Message* MessageStore::Dequeue(void)
{
    if ( !IsEmpty() )
        return RemoveHead();

    return NULL;
}

// remove and return the message with the session_frame_id
// throws a GeneralException(Snmp_Error, Snmp_Local_Error) if not found
Message *MessageStore::DeleteMessage(SessionFrameId session_frame_id)
{
    POSITION current = GetHeadPosition();

    while ( current != NULL )
    {
        POSITION prev_current = current;
        Message *message = GetNext(current);

        // if a match is found
        if ( message->GetSessionFrameId() == session_frame_id )
        {
               RemoveAt(prev_current);
               return message;
        }
    }

    // if not found, throw an exception
    throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

    // should never reach here;
    return NULL;
}

// goes through the store and deletes all stored message ptrs
MessageStore::~MessageStore(void)
{
    POSITION current = GetHeadPosition();

    while ( current != NULL )
    {
        POSITION prev_current = current;
        Message *message = GetNext(current);

        delete message;
    }

    RemoveAll();
}

// obtains the session CriticalSection lock before calling TransmitMessage
void FlowControlMechanism::TransmitMessageUnderProtection(Message *message)
{
    CriticalSectionLock access_lock(session->session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

    TransmitMessage(message);

    // access_lock.UnLock();   The lock may be released at this point
}

// create a waiting message 
// register with the frame_registry and let it Transmit
void FlowControlMechanism::TransmitMessage(Message *message)
{
    // create a waiting message
    WaitingMessage *waiting_message = 
        new WaitingMessage(*session, *message);

    // register with the frame registry
    session->frame_registry.RegisterFrame(message->GetSessionFrameId(), 
                                            *waiting_message);

	// increment the number of outstanding messages before transmission
	// to avoid problems in case of callback due to a message receipt
	outstanding_messages++; 

	// let the message transmit
	waiting_message->Transmit();

	// if the window closes give a FlowControlOn callback
	// if an exception is raised in Transmit, this is never
	// called
	if ( outstanding_messages == window_size )
		session->SessionFlowControlOn();
}


// transmits a message(if present) for each empty slot in the
// window.
void FlowControlMechanism::ClearMessageStore(void)
{
    while (outstanding_messages < window_size)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L" checking message store\n" 
    ) ;
)
        // if any message is waiting in the queue, deque it
        Message *message = message_store.Dequeue();
    
        // if there is a message, create waiting message, register it and xmit
        // (since we are already within the system, no need to call
        //  TransmitMessageUnderProtection)
        if ( message != NULL )
        {
            // all the exception handling has already been
            // performed - nothing needs to be done here
            try
            {
                TransmitMessage(message);
            }
			catch ( Heap_Exception e_He ) {}
            catch(GeneralException exception) {}
        }
        else // no messages in queue
            return;
    }
}


// initializes the private variables
FlowControlMechanism::FlowControlMechanism(SnmpImpSession &session, 
                                           UINT window_size)
{
    FlowControlMechanism::session = &session;
    FlowControlMechanism::window_size = window_size;
    outstanding_messages = 0;
}


// sends message if within the flow control window
// else queues it up
void FlowControlMechanism::SendMessage(Message &message)
{
    // check to see if it may be transmitted immediately,
    // create a waiting message 
    // register with the frame_registry and let it Transmit
    if ( outstanding_messages < window_size )
        TransmitMessageUnderProtection(&message);
    else    // else Enqueue onto the message store
        message_store.Enqueue(message);
}


// It removes the frame from its message store and deletes it
void FlowControlMechanism::DeleteMessage(SessionFrameId session_frame_id)
{
    Message *message = message_store.DeleteMessage(session_frame_id);

    delete message;
}


// this is called by a waiting_message indicating arrival or
// a lack of it
void FlowControlMechanism::NotifyReceipt(WaitingMessage &waiting_message, 
                                         IN const SnmpPdu *snmp_pdu, 
                                         SnmpErrorReport &error_report)
{
    smiOCTETS msg_buffer = {0,NULL};

    // if this opens up the window, signal FlowControlOff
    outstanding_messages--; 
    if ( (outstanding_messages+1) == window_size )
        session->SessionFlowControlOff();

    SessionFrameId session_frame_id = waiting_message.GetMessage()->GetSessionFrameId();

    // in case of an error
    // Note: NotifyOperation either posts a SENT_FRAME event to be processed
    // later or sets the variables needed to inform the operation of the
    // reply when the control returns to the session
    if ( error_report.GetError() != Snmp_Success )
        session->NotifyOperation(session_frame_id, SnmpPdu(), error_report);        
    else // if a reply is succesfully received
    {
        // pass the message to session->NotifyOperation
        session->NotifyOperation(session_frame_id, *snmp_pdu, error_report);
    }

    // deregister the frame from the message registry
    session->frame_registry.DeregisterFrame(session_frame_id);

    // destroy waiting message
    delete &waiting_message;

    // transmits messages in message store as long as the
    // flow control window is open
    ClearMessageStore();
}


// this is called when, although the session does 
// not need to be informed, the flow control window
// must advance (such as frame cancellation)
// also destroys the waiting_message
void FlowControlMechanism::AdvanceWindow(WaitingMessage &waiting_message)
{
    // remove the session_frame_id from the frame_registry
    session->frame_registry.DeregisterFrame(
        waiting_message.GetMessage()->GetSessionFrameId());

    // if the flow control window opens up, signal FlowControlOff
    outstanding_messages--; 
    if ( (outstanding_messages+1) == window_size )
        session->SessionFlowControlOff();

    // transmits messages in message store as long as the
    // flow control window is open
    ClearMessageStore();

    // delete the waiting message
    delete &waiting_message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\fs_reg.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: fs_reg.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "fs_reg.h"
#include "sec.h"

FrameState::FrameState(IN SessionFrameId session_frame_id, IN VBList &vblist)
         : session_frame_id(session_frame_id),
           vblist(&vblist)
{}


FrameState::~FrameState(void)
{
    delete vblist;
}


FrameStateRegistry::~FrameStateRegistry()
{
    DestroySecurity();
}


FrameState *FrameStateRegistry::Get(IN SessionFrameId session_frame_id)
{
    FrameState *frame_state;
    BOOL found = mapping.Lookup(session_frame_id, frame_state);

    if ( found )
        return frame_state;
    else
        return NULL;
}


FrameState *FrameStateRegistry::Remove(IN SessionFrameId session_frame_id)
{
    FrameState *frame_state = Get(session_frame_id);

    if ( frame_state != NULL )
        mapping.RemoveKey(session_frame_id);

    return frame_state;
}


FrameState *FrameStateRegistry::GetNext(OUT SessionFrameId *session_frame_id)
{
    if ( current_pointer == NULL )
        return NULL;

    SessionFrameId local_session_frame_id;
    FrameState *frame_state;

    mapping.GetNextAssoc(current_pointer, local_session_frame_id, frame_state);

    if ( session_frame_id != NULL )
        *session_frame_id = local_session_frame_id;

    return frame_state;
}


void FrameStateRegistry::RegisterSecurity(IN SnmpSecurity *snmp_security)
{
    if ( snmp_security != NULL )
    {
        security = snmp_security->Copy();

        if ( !(*security)() )
            throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);
    }
    else
        security = NULL;
}

SnmpSecurity *FrameStateRegistry::GetSecurity() const
{
    return security;
}

void FrameStateRegistry::DestroySecurity()
{
    if ( security != NULL )
    {
        delete security;
        security = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\frame.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: frame.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "flow.h"
#include "frame.h"
#include "idmap.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "ssent.h"

#include "dummy.h"
#include "opreg.h"
#include "session.h"

SessionFrameId FrameRegistry::GenerateSessionFrameId(void)
{
    SessionFrameId session_frame_id = next_session_frame_id++;

    if ( next_session_frame_id == ILLEGAL_SESSION_FRAME_ID )
        next_session_frame_id++;

    return session_frame_id;
}


void FrameRegistry::RegisterFrame(IN const SessionFrameId session_frame_id, 
                                  IN WaitingMessage &waiting_message)
{
    mapping[session_frame_id] = &waiting_message;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"frame %d registered\n" ,session_frame_id
    ) ;
)

}

    
// returns NULL if no such waiting message
WaitingMessage *FrameRegistry::GetWaitingMessage(IN const SessionFrameId session_frame_id)
{
    WaitingMessage *waiting_message;
    BOOL found = mapping.Lookup(session_frame_id, waiting_message);

    if ( found )
        return waiting_message;
    else
        return NULL;
}


void FrameRegistry::DeregisterFrame(IN const SessionFrameId session_frame_id)
{
    if ( !mapping.RemoveKey(session_frame_id) )
        throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"frame %d removed\n" ,session_frame_id
    ) ;
)
}

// if the specified waiting message is found,
//  cancel the <TransportFrameId, SessionFrameId> association,
//  ensure that no sent message notifications shall be passed to the operation
//  remove any buffered responses for the waiting message
//  inform the flow control mechanism
// otherwise, the message is still in the flow control queue
//  inform the flow control mechanism
void FrameRegistry::CancelFrameNotification(IN const SessionFrameId session_frame_id)
{
    WaitingMessage *waiting_message;
    BOOL found = mapping.Lookup(session_frame_id, waiting_message);

    // obtain corresponding waiting_message
    if ( found )
    {
        // ensure that sent message notifications shall not
        // be passed on to the operation
        session->id_mapping.DisassociateSessionFrameId(session_frame_id);

        // remove any SnmpErrorReport for an attempt to send the message
        session->store.Remove(session_frame_id);

        // inform flow control mechanism
        // it advances window and destroys the waiting_message
        session->flow_control.AdvanceWindow(*waiting_message);
    }
    else // the frame must still be in the flow control message queue
        session->flow_control.DeleteMessage(session_frame_id);
}


// destroy each stored waiting message in the local store and
// remove all associations
FrameRegistry::~FrameRegistry(void)
{
    // get the first position
    POSITION current = mapping.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        SessionFrameId id;
        WaitingMessage *waiting_message;

        // get the next pair
        mapping.GetNextAssoc(current, id, waiting_message);

        // delete the ptr
        delete waiting_message;
    }

    // remove all the keys
    mapping.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\idmap.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: idmap.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "idmap.h"
#include "frame.h"

void IdMapping::Associate(IN TransportFrameId transport_frame_id,
                          IN SessionFrameId session_frame_id)
{
    forward_store[transport_frame_id] = session_frame_id;
    backward_store[session_frame_id] = transport_frame_id;
}

SessionFrameId IdMapping::DisassociateTransportFrameId(IN TransportFrameId transport_frame_id)
{
    SessionFrameId session_frame_id;
        
    if ( !forward_store.Lookup(transport_frame_id, session_frame_id) )
        return ILLEGAL_SESSION_FRAME_ID;

    forward_store.RemoveKey(transport_frame_id);
    backward_store.RemoveKey(session_frame_id);

    return session_frame_id;
}


TransportFrameId IdMapping::DisassociateSessionFrameId(IN SessionFrameId session_frame_id)
{
    TransportFrameId transport_frame_id;

    if ( !backward_store.Lookup(session_frame_id, transport_frame_id) )
        return ILLEGAL_TRANSPORT_FRAME_ID;

    backward_store.RemoveKey(session_frame_id);
    forward_store.RemoveKey(transport_frame_id);

    return transport_frame_id;
}


BOOL IdMapping::CheckIfAssociated(IN SessionFrameId session_frame_id)
{
    TransportFrameId transport_frame_id;

    return backward_store.Lookup(session_frame_id, transport_frame_id);
}

IdMapping::~IdMapping(void)
{
    forward_store.RemoveAll();
    backward_store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\encdec.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: encdec.cpp
Written By: S.Menzies
----------------------------------------------------------*/

#include "precomp.h"
#include <winsock2.h>
#include "common.h"
#include "sync.h"
#include "encap.h"
#include "value.h"
#include "vblist.h"
#include "vbl.h"
#include "fs_reg.h"
#include "error.h"
#include "encdec.h"
#include "sec.h"
#include "pdu.h"
#include "pseudo.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "ophelp.h"
#include "op.h"
#include "tsess.h"

const WinSnmpInteger winsnmp_pdu_type[] = {SNMP_PDU_GET, SNMP_PDU_GETNEXT, SNMP_PDU_SET};
const ULONG num_pdus = sizeof(winsnmp_pdu_type)/sizeof(WinSnmpInteger);

CriticalSection SnmpEncodeDecode :: s_CriticalSection;

void FreeDescriptor ( smiVALUE &a_Value )
{
    switch ( a_Value.syntax )
    {
        case SNMP_SYNTAX_OCTETS :
        case SNMP_SYNTAX_BITS :
        case SNMP_SYNTAX_OPAQUE :
        case SNMP_SYNTAX_IPADDR :
        case SNMP_SYNTAX_NSAPADDR :
        {
            SnmpFreeDescriptor ( 

                SNMP_SYNTAX_OCTETS ,
                & a_Value.value.string
            ) ;
        }
        break ;

        case SNMP_SYNTAX_OID :
        {
            SnmpFreeDescriptor (

                SNMP_SYNTAX_OID, 
                (smiOCTETS *)(&a_Value.value.oid)
            );
        }
        break ;

        default:
        {
        }
        break ;
    }
}


// returns an SnmpVarBind containing an SnmpObjectIdentifier and an
// SnmpValue created using the instance(OID) and the value(VALUE)
SnmpVarBind *GetVarBind (

    IN smiOID &instance,
    IN smiVALUE &value
)
{
    // create an SnmpObjectIdentifier using the instance value
    SnmpObjectIdentifier id(instance.ptr, instance.len);
    SnmpValue *snmp_value = NULL;

    // for each possible value for value.syntax, create the
    // corresponding SnmpValue

    switch(value.syntax)
    {
        case SNMP_SYNTAX_NULL:      // null value
        {
            snmp_value = new SnmpNull();
        }
        break;

        case SNMP_SYNTAX_INT:       // integer *(has same value as SNMP_SYNTAX_INT32)*
        {
            snmp_value = new SnmpInteger(value.value.sNumber);
        }
        break;

        case SNMP_SYNTAX_UINT32:        // integer *(has same value as SNMP_SYNTAX_GAUGE)*
        {
            snmp_value = new SnmpUInteger32(value.value.uNumber);
        }
        break;

        case SNMP_SYNTAX_CNTR32:    // counter32
        {
            snmp_value = new SnmpCounter (value.value.uNumber);
        }
        break;

        case SNMP_SYNTAX_GAUGE32:   // gauge
        {
            snmp_value = new SnmpGauge(value.value.uNumber);
        }
        break;
            
        case SNMP_SYNTAX_TIMETICKS: // time ticks
        {
            snmp_value = new SnmpTimeTicks(value.value.uNumber);
        }
        break;

        case SNMP_SYNTAX_OCTETS:    // octets
        {
            snmp_value = new SnmpOctetString(value.value.string.ptr,
                                             value.value.string.len);
        }
        break;

        case SNMP_SYNTAX_OPAQUE:    // opaque value
        {
            snmp_value = new SnmpOpaque(value.value.string.ptr,
                                        value.value.string.len);
        }
        break;

        case SNMP_SYNTAX_OID:       // object identifier
        {
            snmp_value = new SnmpObjectIdentifier(value.value.oid.ptr,
                                                  value.value.oid.len);
        }
        break;

        case SNMP_SYNTAX_IPADDR:    // ip address value
        {
            if ( value.value.string.ptr )
            {
                snmp_value = new SnmpIpAddress(ntohl(*((ULONG *)value.value.string.ptr)));
            }
            else
            {
                snmp_value = new SnmpNull();
            }
        }
        break;

        case SNMP_SYNTAX_CNTR64:    // counter64
        {
            snmp_value = new SnmpCounter64 (value.value.hNumber.lopart , value.value.hNumber.hipart );
        }
        break;

        case SNMP_SYNTAX_NOSUCHOBJECT:
        {
            snmp_value = new SnmpNoSuchObject ;
        }
        break ;

        case SNMP_SYNTAX_NOSUCHINSTANCE:
        {
            snmp_value = new SnmpNoSuchInstance ;
        }
        break ;

        case SNMP_SYNTAX_ENDOFMIBVIEW:
        {
            snmp_value = new SnmpEndOfMibView ;
        }
        break ;

        default:
        {
            // it must be an unsupported type 
            // return an SnmpNullValue by default
            snmp_value = new SnmpNull();
        
        }
        break;
    };

    SnmpVarBind *var_bind = NULL ;

    if ( snmp_value ) 
    {
        CProvDeleteMe<SnmpValue> sc(snmp_value);

        var_bind = new SnmpVarBind(id, *snmp_value);
    }

    return var_bind;
}

void GetOID(OUT smiOID &oid, IN SnmpObjectIdentifier &instance)
{
    // determine length
    oid.len = instance.GetValueLength();

    // allocate space
    oid.ptr = new smiUINT32[oid.len];

    // copy the identifier values
    ULONG *value = instance.GetValue();

    for(UINT i=0; i < oid.len; i++)
        oid.ptr[i] = value[i];
}

// returns a winsnmp VALUE in the value OUT parameter corresponding
// to the specified snmp_value. makes use of run-time type information
// for the purpose
void GetValue(OUT smiVALUE &value, IN SnmpValue &snmp_value)
{
    // for each SnmpValue type, check if it is a pointer
    // to the derived type. If so, fill in the smiValue
    // and return

    SnmpNull *null_value = dynamic_cast<SnmpNull *>(&snmp_value);

    if ( null_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_NULL;

        return;
    }

    SnmpInteger *integer_value = dynamic_cast<SnmpInteger *>(&snmp_value);

    if ( integer_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_INT;

        value.value.sNumber = integer_value->GetValue();

        return;
    }

    SnmpGauge *gauge_value = dynamic_cast<SnmpGauge *>(&snmp_value);

    if ( gauge_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_GAUGE32;

        value.value.uNumber = gauge_value->GetValue();

        return;
    }

    SnmpCounter *counter_value = dynamic_cast<SnmpCounter *>(&snmp_value);

    if ( counter_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_CNTR32;

        value.value.uNumber = counter_value->GetValue();

        return;
    }

    SnmpTimeTicks *timeTicks_value = dynamic_cast<SnmpTimeTicks *>(&snmp_value);

    if ( timeTicks_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_TIMETICKS;

        value.value.uNumber = timeTicks_value->GetValue();

        return;
    }

    SnmpOpaque *opaque_value = dynamic_cast<SnmpOpaque *>(&snmp_value);

    if ( opaque_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_OPAQUE;

        value.value.string.len = opaque_value->GetValueLength();
        value.value.string.ptr = new smiBYTE[value.value.string.len];

        UCHAR *source = opaque_value->GetValue();

        for(UINT i=0; i < value.value.string.len; i++)
            value.value.string.ptr[i] = source[i];

        return;
    }

    SnmpOctetString *string_value = dynamic_cast<SnmpOctetString *>(&snmp_value);

    if ( string_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_OCTETS;

        value.value.string.len = string_value->GetValueLength();
        value.value.string.ptr = new smiBYTE[value.value.string.len];

        UCHAR *source = string_value->GetValue();

        for(UINT i=0; i < value.value.string.len; i++)
            value.value.string.ptr[i] = source[i];

        return;
    }

    SnmpObjectIdentifier *oid_value = dynamic_cast<SnmpObjectIdentifier *>(&snmp_value);

    if ( oid_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_OID;

        GetOID(value.value.oid, *oid_value);

        return;
    }

    SnmpIpAddress *ip_address_value = dynamic_cast<SnmpIpAddress *>(&snmp_value);

    if ( ip_address_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_IPADDR;
        value.value.string.len = IP_ADDR_LEN;
        value.value.string.ptr = new smiBYTE[IP_ADDR_LEN];

        ULONG address = htonl ( ip_address_value->GetValue() ) ;
        UCHAR *t_Address = ( UCHAR * ) & address ;

        for(int i=IP_ADDR_LEN-1; i >= 0; i--)
        {
            value.value.string.ptr[i] = t_Address [ i ] ;
        }

        return;
    }

    SnmpUInteger32 *uinteger32_value = dynamic_cast<SnmpUInteger32 *>(&snmp_value);

    if ( uinteger32_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_UINT32;

        value.value.uNumber = uinteger32_value->GetValue();

        return;
    }

    SnmpCounter64 *counter64_value = dynamic_cast<SnmpCounter64 *>(&snmp_value);

    if ( counter64_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_CNTR64;

        value.value.hNumber.lopart = counter64_value->GetLowValue();
        value.value.hNumber.hipart = counter64_value->GetHighValue();

        return;
    }

    SnmpEndOfMibView *endofmibview_value = dynamic_cast<SnmpEndOfMibView *>(&snmp_value);

    if ( endofmibview_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_ENDOFMIBVIEW;

        return;
    }

    SnmpNoSuchObject *nosuchobject_value = dynamic_cast<SnmpNoSuchObject *>(&snmp_value);

    if ( nosuchobject_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_NOSUCHOBJECT;

        return;
    }

    SnmpNoSuchInstance *nosuchinstance_value = dynamic_cast<SnmpNoSuchInstance *>(&snmp_value);

    if ( nosuchinstance_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_NOSUCHINSTANCE;

        return;
    }

    // we should not have come here 
    // did we check all supported types?
    throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);
}

void LocalFreeVb(IN smiOID &oid, IN smiVALUE &value)
{
    if ( oid.len > 0 )
        delete[] oid.ptr;

    switch( value.syntax )
    {
        case SNMP_SYNTAX_OCTETS:    // octets
        case SNMP_SYNTAX_OPAQUE:    // opaque value
        case SNMP_SYNTAX_IPADDR:    // ip address value
            {
                delete[] value.value.string.ptr;
                break;
            }

        case SNMP_SYNTAX_OID:       // object identifier
            {
                delete[] value.value.oid.ptr;
                break;
            }

        default:
            break;
    };
}

void SetWinSnmpVbl(SnmpVarBindList &var_bind_list, HSNMP_VBL vbl)
{
    // reset the list
    var_bind_list.Reset();

    // for each var_bind, create a pair <oid, value> and
    // insert it into the vbl 
    while( var_bind_list.Next() )
    {
        const SnmpVarBind *var_bind = var_bind_list.Get();

        smiOID instance;
        GetOID(instance, var_bind->GetInstance());

        smiVALUE value;
        GetValue(value, var_bind->GetValue());

        // insert a new var bind
        SnmpSetVb(vbl, 0, &instance, &value);

        LocalFreeVb(instance, value);
    }
}

BOOL DecodeVarBindList ( 

    HSNMP_VBL a_Vbl , 
    SnmpVarBindList &a_SnmpVarBindList 
)
{
    smiINT t_VblCount = SnmpCountVbl ( a_Vbl ) ;
    for ( smiINT t_Count = 1 ; t_Count <= t_VblCount ; t_Count ++ )
    {
        smiOID t_Instance;
        smiVALUE t_Value;

        SNMPAPI_STATUS t_Status = SnmpGetVb (

            a_Vbl, 
            t_Count, 
            & t_Instance, 
            & t_Value
        ) ;

        if ( t_Status == SNMPAPI_FAILURE )
        {
            return FALSE ;
        }

        SnmpVarBind *t_VarBind = GetVarBind ( t_Instance , t_Value ) ;
        if ( ! t_VarBind )
        {
            SnmpFreeDescriptor (

                SNMP_SYNTAX_OID,
                (smiOCTETS *) & t_Instance
            ) ;

            return FALSE ;          
        }

        a_SnmpVarBindList.AddNoReallocate ( *t_VarBind ) ;

        SnmpFreeDescriptor (

            SNMP_SYNTAX_OID,
            (smiOCTETS *) & t_Instance
        ) ;

        FreeDescriptor ( t_Value ) ;
    }

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DestroyStaticComponents ()
{
    return TRUE ;
}

BOOL SnmpEncodeDecode :: InitializeStaticComponents ()
{
    return TRUE ;
}

SnmpEncodeDecode :: SnmpEncodeDecode () : m_IsValid ( FALSE ) , m_Session ( NULL ) , m_Window ( NULL )
{
    Window *t_Window = new Window ;
    m_Window = t_Window ;
}

SnmpEncodeDecode :: ~SnmpEncodeDecode () 
{
    if ( m_IsValid )
    {
        HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;
        SnmpClose ( t_Session ) ;
    }

    Window *t_Window = ( Window * ) m_Window ;

    delete t_Window ;
}

BOOL SnmpEncodeDecode :: EncodeFrame (

    OUT SnmpPdu &a_SnmpPdu ,
    IN RequestId a_RequestId,
    IN PduType a_PduType,
    IN SnmpErrorReport &a_SnmpErrorReport ,
    IN SnmpVarBindList &a_SnmpVarBindList,
    IN SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecurity ,
    IN SnmpTransportAddress *&a_SrcTransportAddress ,
    IN SnmpTransportAddress *&a_DstTransportAddress
) 
{
    a_SnmpPdu.SetRequestId ( a_RequestId ) ;
    a_SnmpPdu.SetPduType ( a_PduType ) ;
    a_SnmpPdu.SetErrorReport ( a_SnmpErrorReport ) ;
    a_SnmpPdu.SetVarBindList ( a_SnmpVarBindList ) ;

    if ( a_SnmpCommunityBasedSecurity )
        a_SnmpPdu.SetCommunityName ( *a_SnmpCommunityBasedSecurity ) ;

    if ( a_SrcTransportAddress )
        a_SnmpPdu.SetSourceAddress ( *a_SrcTransportAddress ) ;

    if ( a_DstTransportAddress )
        a_SnmpPdu.SetDestinationAddress ( *a_DstTransportAddress ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DecodeFrame (

    IN SnmpPdu &a_SnmpPdu ,
    OUT RequestId a_RequestId,
    OUT PduType a_PduType ,
    OUT SnmpErrorReport &a_SnmpErrorReport ,
    OUT SnmpVarBindList *&a_SnmpVarBindList ,
    OUT SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecurity ,
    OUT SnmpTransportAddress *&a_SrcTransportAddress ,
    OUT SnmpTransportAddress *&a_DstTransportAddress 
) 
{
    a_SrcTransportAddress = & a_SnmpPdu.GetSourceAddress ();
    a_DstTransportAddress = & a_SnmpPdu.GetDestinationAddress () ;
    a_PduType = a_SnmpPdu.GetPduType () ;
    a_RequestId = a_SnmpPdu.GetRequestId () ;
    a_SnmpVarBindList = & a_SnmpPdu.GetVarbindList () ;
    a_SnmpCommunityBasedSecurity = & a_SnmpPdu.GetCommunityName () ;
    a_SnmpErrorReport = a_SnmpPdu.GetErrorReport () ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: EncodeFrame (

    IN SnmpPdu &a_SnmpPdu ,
    OUT void *a_ImplementationEncoding 
) 
{
    WinSnmpVariables *t_WinSnmpVariables = ( WinSnmpVariables * ) a_ImplementationEncoding ;

    RequestId t_SnmpRequestId = a_SnmpPdu.GetRequestId () ;
    PduType t_SnmpPduType = a_SnmpPdu.GetPduType () ;
    SnmpErrorReport &t_SnmpErrorReport = a_SnmpPdu.GetErrorReport () ;
    SnmpCommunityBasedSecurity &t_SnmpCommunityBasedSecurity = a_SnmpPdu.GetCommunityName () ;
    SnmpVarBindList &t_SnmpVarBindList = a_SnmpPdu.GetVarbindList () ;
    SnmpTransportAddress &t_SrcTransportAddress = a_SnmpPdu.GetSourceAddress () ;
    SnmpTransportAddress &t_DstTransportAddress = a_SnmpPdu.GetDestinationAddress () ;

    if ( ! m_IsValid )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;

    HSNMP_VBL t_Vbl = SnmpCreateVbl ( t_Session , NULL , NULL ) ;
    if ( t_Vbl == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ( ( HSNMP_SESSION ) m_Session ) 
        ) ;
    }

    SetWinSnmpVbl ( t_SnmpVarBindList , t_Vbl ) ;

    smiINT t_RequestId = t_SnmpRequestId ;
    smiINT t_PduType = winsnmp_pdu_type[t_SnmpPduType] ;
    smiINT t_ErrorStatus = t_SnmpErrorReport.GetStatus () ;
    smiINT t_ErrorIndex = t_SnmpErrorReport.GetIndex () ;

    HSNMP_PDU t_Pdu ;
    t_Pdu = SnmpCreatePdu ( 

        t_Session, 
        t_PduType, 
        t_RequestId, 
        t_ErrorStatus, 
        t_ErrorIndex , 
        t_Vbl
    );

    if ( t_Pdu == SNMPAPI_FAILURE )
    {
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ( ( HSNMP_SESSION ) m_Session ) 
        ) ;
    }

    CriticalSectionLock t_CriticalSectionLock ( s_CriticalSection ) ;

    SnmpOctetString t_OctetString ( NULL , 0 ) ;
    t_SnmpCommunityBasedSecurity.GetCommunityName ( t_OctetString ) ;

    smiOCTETS t_Name;
    t_Name.len = t_OctetString.GetValueLength () ;
    t_Name.ptr = t_OctetString.GetValue () ;

    HSNMP_CONTEXT t_Context ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_Context = SnmpStrToContext (

        t_Session,
        &t_Name
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_Context == SNMPAPI_FAILURE )
    {
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (t_Session) 
        );
    }

    t_WinSnmpVariables->m_RequestId = t_RequestId;
    t_WinSnmpVariables->m_Pdu = t_Pdu ;
    t_WinSnmpVariables->m_Vbl = t_Vbl ;
    t_WinSnmpVariables->m_SrcEntity = NULL ;
    t_WinSnmpVariables->m_DstEntity = NULL ;
    t_WinSnmpVariables->m_Context = t_Context ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DecodeFrame (

    IN void *a_ImplementationEncoding ,
    OUT SnmpPdu &a_SnmpPdu
) 
{
    WinSnmpVariables *t_WinSnmpVariables = ( WinSnmpVariables * ) a_ImplementationEncoding ;

    RequestId t_SnmpRequestId ;
    PduType t_SnmpPduType ;
    SnmpErrorReport t_SnmpErrorReport ;
    SnmpCommunityBasedSecurity *t_SnmpCommunityBasedSecurity ;
    SnmpVarBindList *t_SnmpVarBindList ;
    SnmpTransportAddress *t_SrcTransportAddress ;
    SnmpTransportAddress *t_DstTransportAddress ;

    if ( ! m_IsValid )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }


    HSNMP_ENTITY t_SrcEntity = t_WinSnmpVariables->m_SrcEntity ;
    HSNMP_ENTITY t_DstEntity = t_WinSnmpVariables->m_DstEntity ;
    HSNMP_CONTEXT t_Context = t_WinSnmpVariables->m_Context ;
    HSNMP_PDU t_Pdu = t_WinSnmpVariables->m_Pdu ;

    smiOCTETS t_Community ; 
    SNMPAPI_STATUS t_Status = SnmpContextToStr (

        t_Context , 
        &t_Community 
    );

    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    t_SnmpCommunityBasedSecurity = new SnmpCommunityBasedSecurity ;

    SnmpOctetString t_SnmpOctetString ( t_Community.ptr , t_Community.len ) ;

    SnmpFreeDescriptor ( SNMP_SYNTAX_OCTETS, &t_Community );

    t_SnmpCommunityBasedSecurity->SetCommunityName ( t_SnmpOctetString ) ;

    if ( t_SrcEntity )
    {
        char buff[MAX_ADDRESS_LEN];
        t_Status = SnmpEntityToStr(t_SrcEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
        if (SNMPAPI_FAILURE == t_Status)
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }

        SnmpTransportIpAddress *t_SrcIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

        if (t_SrcIpAddress->IsValid())
        {
            t_SrcTransportAddress = t_SrcIpAddress ;
        }
        else
        {
            delete t_SrcIpAddress ;

            SnmpTransportIpxAddress *t_SrcIpxAddress = new SnmpTransportIpxAddress (buff);

            if (t_SrcIpxAddress->IsValid())
            {
                t_SrcTransportAddress = t_SrcIpxAddress ;
            }   
            else
            {
                delete t_SrcIpxAddress ;

                throw GeneralException (

                    Snmp_Error, 
                    Snmp_Local_Error,
                    __FILE__,
                    __LINE__,
                    SnmpGetLastError (( HSNMP_SESSION)m_Session) 
                );
            }
        }
    }

    if ( t_DstEntity )
    {
        char buff[MAX_ADDRESS_LEN];
        t_Status = SnmpEntityToStr(t_DstEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
        if (SNMPAPI_FAILURE == t_Status)
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }

        SnmpTransportIpAddress *t_DstIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

        if (t_DstIpAddress->IsValid())
        {
            t_DstTransportAddress = t_DstIpAddress ;
        }
        else
        {
            delete t_DstIpAddress ;

            SnmpTransportIpxAddress *t_DstIpxAddress = new SnmpTransportIpxAddress (buff);

            if (t_DstIpxAddress->IsValid())
            {
                t_DstTransportAddress = t_DstIpxAddress ;
            }   
            else
            {
                delete t_DstIpxAddress ;

                throw GeneralException (

                    Snmp_Error, 
                    Snmp_Local_Error,
                    __FILE__,
                    __LINE__,
                    SnmpGetLastError (( HSNMP_SESSION)m_Session) 
                );
            }
        }
    }
    
    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    if ( t_PduType == SNMP_PDU_GET )
    {
        t_SnmpPduType = GET ;
    }
    else if ( t_PduType == SNMP_PDU_SET )
    {
        t_SnmpPduType = SET ;
    }
    else if ( t_PduType == SNMP_PDU_GETNEXT )
    {
        t_SnmpPduType = GETNEXT ;
    }
    else if ( t_PduType == SNMP_PDU_RESPONSE )
    {
        t_SnmpPduType = RESPONSE ;
    }
    else if (t_PduType == SNMP_PDU_GETBULK)
    {
        t_SnmpPduType = GETBULK;
    }
    else if (t_PduType == SNMP_PDU_TRAP)
    {
        t_SnmpPduType = TRAP;
    }
    else if (t_PduType == SNMP_PDU_V1TRAP)
    {
        t_SnmpPduType = V1TRAP;
    }
    else if (t_PduType == SNMP_PDU_INFORM)
    {
        t_SnmpPduType = INFORM ;
    }
    else
    {
        t_SnmpPduType = UNKNOWN;
    }

    a_SnmpPdu.SetPduType(t_SnmpPduType);

    t_SnmpRequestId = t_RequestId ;

    t_SnmpErrorReport.SetStatus ( ( SnmpStatus ) t_ErrorStatus ) ;
    t_SnmpErrorReport.SetIndex ( t_ErrorIndex ) ;
    t_SnmpErrorReport.SetError ( t_ErrorStatus == SNMP_ERROR_NOERROR ? Snmp_Success : Snmp_Error ) ;

    t_SnmpVarBindList = new SnmpVarBindList ;

    if ( ! DecodeVarBindList ( t_Vbl , *t_SnmpVarBindList ) )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    a_SnmpPdu.SetRequestId ( t_SnmpRequestId ) ;
    a_SnmpPdu.SetErrorReport ( t_SnmpErrorReport ) ;
    a_SnmpPdu.SetSourceAddress ( *t_SrcTransportAddress ) ;
    a_SnmpPdu.SetDestinationAddress ( *t_DstTransportAddress ) ;
    a_SnmpPdu.SetVarBindList ( *t_SnmpVarBindList ) ;
    a_SnmpPdu.SetCommunityName ( *t_SnmpCommunityBasedSecurity ) ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpEncodeDecode :: DecodeFrame- received frame_id (%d) \r\n\r\n" , t_RequestId
    ) ;

    smiOCTETS t_Octets ;

    if ( SnmpEncodeMsg (

        m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu ,
        & t_Octets 

    ) != SNMPAPI_FAILURE )
    {
        ULONG t_Len = t_Octets.len ;
        UCHAR *t_Ptr = t_Octets.ptr ;

        ULONG t_RowLength = t_Len / 16 ;
        ULONG t_Remainder = t_Len % 16 ;
        
        ULONG t_Index = 0 ;
        for ( ULONG t_RowIndex = 0 ; t_RowIndex < t_RowLength ; t_RowIndex ++ )
        {
            ULONG t_StoredIndex = t_Index ;

            for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

            for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                if ( ( t_Ptr [ t_StoredIndex ] >= 0x20 ) && ( t_Ptr [ t_StoredIndex ] <= 0x7f ) ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n" ) ;
        }       

        ULONG t_StoredIndex = t_Index ;
        for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }
            else
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write (  L"    " ) ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

        for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                if ( t_Ptr [ t_StoredIndex ] >= 0x20 && t_Ptr [ t_StoredIndex ] <= 0x7f ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n\r\n" ) ;

        SnmpFreeDescriptor ( 

            SNMP_SYNTAX_OCTETS ,
            & t_Octets
        ) ;
    }
    else
    {
        DWORD t_LastError = SnmpGetLastError ((HSNMP_SESSION) m_Session) ;
        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"Encode Failure\r\n\r\n" ) ;
    }
)

    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: SetRequestId (

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN RequestId a_RequestId

)
{
    return a_SnmpPdu.SetRequestId ( a_RequestId ) ;
}   

BOOL SnmpEncodeDecode :: SetVarBindList (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpVarBindList &a_SnmpVarBindList
)
{
    return a_SnmpPdu.SetVarBindList ( a_SnmpVarBindList ) ;
}


BOOL SnmpEncodeDecode :: SetCommunityName ( 

    IN SnmpPdu &a_SnmpPdu ,
    IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 

)
{
    return a_SnmpPdu.SetCommunityName ( a_SnmpCommunityBasedSecurity ) ;
}

BOOL SnmpEncodeDecode :: SetErrorReport (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpErrorReport &a_SnmpErrorReport

)
{
    return a_SnmpPdu.SetErrorReport ( a_SnmpErrorReport ) ;

}

BOOL SnmpEncodeDecode :: SetPduType (

    IN SnmpPdu &a_SnmpPdu ,
    OUT PduType a_PduType

)
{
    return a_SnmpPdu.SetPduType ( a_PduType ) ;
}

BOOL SnmpEncodeDecode :: SetSourceAddress ( 

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN SnmpTransportAddress &a_TransportAddress 

)
{
    return a_SnmpPdu.SetSourceAddress ( a_TransportAddress ) ;
}

BOOL SnmpEncodeDecode :: SetDestinationAddress ( 

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN SnmpTransportAddress &a_TransportAddress 

)
{
    return a_SnmpPdu.SetDestinationAddress ( a_TransportAddress ) ;
}

BOOL SnmpEncodeDecode :: GetSourceAddress ( 

    IN SnmpPdu &a_SnmpPdu ,
    SnmpTransportAddress *&a_TransportAddress
)
{
    a_TransportAddress = a_SnmpPdu.GetSourceAddress ().Copy ()  ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetDestinationAddress (

    IN SnmpPdu &a_SnmpPdu ,
    SnmpTransportAddress *&a_TransportAddress
)
{
    a_TransportAddress = a_SnmpPdu.GetDestinationAddress ().Copy ()  ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetPduType (

    IN SnmpPdu &a_SnmpPdu ,
    OUT PduType &a_PduType 

)
{
    a_PduType = a_SnmpPdu.GetPduType () ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetRequestId (

    IN SnmpPdu &a_SnmpPdu ,
    RequestId &a_RequestId 
)
{
    a_RequestId = a_SnmpPdu.GetRequestId () ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetErrorReport (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpErrorReport &a_SnmpErrorReport 

)
{
    a_SnmpErrorReport = a_SnmpPdu.GetErrorReport () ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetVarbindList (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpVarBindList &a_SnmpVarBindList

)
{
    a_SnmpVarBindList = a_SnmpPdu.GetVarbindList () ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetCommunityName ( 

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 

)
{
    a_SnmpCommunityBasedSecurity = a_SnmpPdu.GetCommunityName () ;

    return TRUE;    
}

SnmpV1EncodeDecode::SnmpV1EncodeDecode () 
{
    try 
    {
        InitializeVariables();
    }
	catch ( Heap_Exception e_He )
	{
	}
    catch(GeneralException exception)
    {
    }
}

SnmpV1EncodeDecode::~SnmpV1EncodeDecode(void)
{
}

void SnmpV1EncodeDecode::InitializeVariables()
{
    m_IsValid = FALSE;

    smiUINT32 t_MajorVersion = 1 ;
    smiUINT32 t_MinorVersion = 1 ;
    smiUINT32 t_Level = 2 ;
    smiUINT32 t_TranslateMode = SNMPAPI_UNTRANSLATED_V1 ;
    smiUINT32 t_RetransmitMode = SNMPAPI_OFF ;
    
    SNMPAPI_STATUS t_StartupStatus = SnmpStartup (

        &t_MajorVersion,
        &t_MinorVersion,
        &t_Level,
        &t_TranslateMode,
        &t_RetransmitMode
    );

    if ( t_StartupStatus == SNMPAPI_FAILURE )
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    HSNMP_SESSION t_Session ;

    t_Session = SnmpOpen (

        ( ( Window * ) m_Window ) ->GetWindowHandle (), 
        Window :: g_NullEventId 
    ) ;

    if ( t_Session == SNMPAPI_FAILURE )
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;

        throw GeneralException ( 

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    m_Session = ( void * ) t_Session ;

    m_IsValid = TRUE;
}

void SnmpV1EncodeDecode :: SetTranslateMode ()
{
    SnmpSetTranslateMode ( SNMPAPI_UNTRANSLATED_V1 ) ;
}

SnmpV2CEncodeDecode::SnmpV2CEncodeDecode () 
{
    InitializeVariables();
}

SnmpV2CEncodeDecode::~SnmpV2CEncodeDecode(void)
{
}

void SnmpV2CEncodeDecode::InitializeVariables()
{
    m_IsValid = FALSE;

    smiUINT32 t_MajorVersion = 1 ;
    smiUINT32 t_MinorVersion = 1 ;
    smiUINT32 t_Level = 2 ;
    smiUINT32 t_TranslateMode = SNMPAPI_UNTRANSLATED_V2 ;
    smiUINT32 t_RetransmitMode = SNMPAPI_OFF ;
    
    SNMPAPI_STATUS t_StartupStatus = SnmpStartup (

        &t_MajorVersion,
        &t_MinorVersion,
        &t_Level,
        &t_TranslateMode,
        &t_RetransmitMode
    );

    if ( t_StartupStatus == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    HSNMP_SESSION t_Session ;

    t_Session = SnmpOpen (

        ( ( Window * ) m_Window ) ->GetWindowHandle (), 
        Window :: g_NullEventId 
    ) ;

    if ( t_Session == SNMPAPI_FAILURE )
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;

        throw GeneralException ( 

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    m_Session = ( void * ) t_Session ;

    m_IsValid = TRUE;
}

void SnmpV2CEncodeDecode :: SetTranslateMode ()
{
    SnmpSetTranslateMode ( SNMPAPI_UNTRANSLATED_V2 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\message.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: message.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "message.h"
#include "idmap.h"
#include "dummy.h"
#include "flow.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "frame.h"
#include "opreg.h"
#include "ssent.h"

#include "session.h"

#define ILLEGAL_PDU_HANDLE 100000
#define ILLEGAL_VBL_HANDLE 100000

Message::Message(IN const SessionFrameId session_frame_id, IN SnmpPdu &snmp_pdu, 
                 SnmpOperation &snmp_operation
                 ) : snmp_pdu(&snmp_pdu), operation(snmp_operation)
{
    Message::session_frame_id = session_frame_id;
}
    
SessionFrameId Message::GetSessionFrameId(void) const
{
    return session_frame_id;
}

SnmpOperation &Message::GetOperation(void) const
{
    return operation;
}

SnmpPdu &Message::GetSnmpPdu(void) const
{
    return *snmp_pdu;
}

void Message::SetSnmpPdu(IN SnmpPdu &new_snmp_pdu)
{
    delete snmp_pdu;
    snmp_pdu = &new_snmp_pdu;
}

Message::~Message(void)
{
    delete snmp_pdu;
}


// deregisters the waiting message from the message registry
// for each request id stored in the RequestIdList
void WaitingMessage::DeregisterRequestIds()
{
    for( UINT request_ids_left = request_id_list.GetCount();
         request_ids_left > 0;
         request_id_list.RemoveHead(), request_ids_left--)
         {
             RequestId request_id = request_id_list.GetHead();
             session->message_registry.RemoveMessage(request_id);
         }
}

// an exit fn - prepares an error report and calls
// ReceiveReply to signal a non-receipt
void WaitingMessage::WrapUp(IN SnmpErrorReport &error_report)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: WrapUp () session_id(%d), frame_id(%d)\n" ,message->GetSessionFrameId(), last_transport_frame_id
    ) ;
)

    try // ignore any exceptions arising during the ReceiveReply
    {
        // no reply to receive
        ReceiveReply(NULL, error_report);
    }
	catch ( Heap_Exception e_He ) {}
    catch(GeneralException exception) {}
}


// initializes the private variables
WaitingMessage::WaitingMessage(IN SnmpImpSession &session, 
                               IN Message &message) : session ( NULL ) , message ( NULL ), reply_snmp_pdu ( NULL )
{
    WaitingMessage::session = &session;

    // the message ptr must be deleted by the waiting message
    WaitingMessage::message = &message;

    // sent message has not been processed yet
    sent_message_processed = FALSE;

    // set illegal values for last_transport_frame_id
    last_transport_frame_id = ILLEGAL_TRANSPORT_FRAME_ID;

    // these values are currently obtained from the
    // session, but may be specified per message later
    max_rexns = SnmpImpSession :: RetryCount ( session.GetRetryCount() ) ;
    rexns_left = max_rexns;
    strobes = 0 ;

    active = FALSE;
}


// sends the message. involves request_id generation,
// registering with the message_registry, decoding the
// message and updating the pdu and registering a timer
// event
void WaitingMessage::Transmit()
{
    try
    {
        // generate request_id and register with the registry
        RequestId request_id = 
            session->message_registry.GenerateRequestId(*this);
    
        // insert the request id into the message
        // if unsuccessful, the exception handler gets called
        session->m_EncodeDecode.SetRequestId(

            message->GetSnmpPdu(),
            request_id 
            
        );

        last_transport_frame_id = request_id ;

        // append the request id to the request id list
        request_id_list.AddTail(request_id);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: Transmit - About to transmit (session (%d), frame_id(%d))\n", message->GetSessionFrameId(), request_id
    ) ;
)

        // save the previous value of active and set the active
        // flag. This is needed to check on returning whether the 
        // waiting message needs to be destroyed
        BOOL prev_active_state = active;
        active = TRUE;
        strobes = GetTickCount () ;

        // send message

        session->transport.TransportSendFrame(last_transport_frame_id, message->GetSnmpPdu());

        session->id_mapping.Associate(last_transport_frame_id, message->GetSessionFrameId());

        // if asked to destroy self, well, do it (and return)
        if ( !active )
        {
            delete this;
            return;
        }

        // restore the previous value of "active"
        active = prev_active_state;

        // generate timer_event_id and register with the timer
        session->timer.SetMessageTimerEvent(*this);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: Transmit - Transmitted session_id(%d),frame_id(%d))\n",message->GetSessionFrameId(), request_id
    ) ;
)
    }
	catch ( Heap_Exception e_He )
	{
        WrapUp(GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__));

        throw;
	}
    catch(GeneralException exception)
    {
        WrapUp(exception);

        throw;
    }
}

// used by the timer to notify the waiting message of
// a timer event. if need, the message is retransmitted.
// when all rexns are exhausted, ReceiveReply is called
void WaitingMessage::TimerNotification()
{
    DWORD t_Ticks = GetTickCount () ;
    if ( strobes > t_Ticks ) 
    {
        strobes = t_Ticks ; // Take hit on clock overflow
        return ;
    }

    if ( ( t_Ticks - strobes ) >= SnmpImpSession :: RetryTimeout ( session->GetRetryTimeout () ) )
    {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - timed out after (%ld)" , ( t_Ticks - strobes ) 
    ) ;
)

        // if any rexns left, update rexns_left, send message
        if ( rexns_left > 0 )
        {
            // generate request_id and register with the registry
            RequestId request_id = session->message_registry.GenerateRequestId(*this);
        
            // insert the request id into the message
            // if unsuccessful, the exception handler gets called
            try
            {
                session->m_EncodeDecode.SetRequestId(

                    message->GetSnmpPdu() ,
                    request_id
                );
            }
			catch ( Heap_Exception e_He )
			{
				WrapUp(GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__));

				return ;
			}
            catch(GeneralException exception)
            {
                WrapUp(exception);
                return;
            }

            last_transport_frame_id = request_id ;

            // append the request id to the request id list
            request_id_list.AddTail(request_id);

            BOOL prev_active_state = active;
            active = TRUE;

            strobes = GetTickCount () ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - Resend %d.%d, req_id(%d), this(%d) at time (%d)\n",message->GetSessionFrameId(), rexns_left, request_id, this, strobes
    ) ;
)

            session->id_mapping.DisassociateTransportFrameId(last_transport_frame_id);

            // send message
            session->transport.TransportSendFrame(last_transport_frame_id, message->GetSnmpPdu());

            // associate the last transport frame id with the session frame id
            session->id_mapping.Associate(last_transport_frame_id, message->GetSessionFrameId());

            // if asked to destroy self, well, do it (and return)
            if ( !active )
            {
                delete this;
                return;
            }

            // restore the previous value of "active"
            active = prev_active_state;

            rexns_left--;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - Retransmitted session_id(%d),frame_id(%d))\n",message->GetSessionFrameId(), last_transport_frame_id
    ) ;
)

        }
        else
        {   
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - No response session_id(%d),frame_id(%d))\n",message->GetSessionFrameId(), last_transport_frame_id
    ) ;
)

            // else wrap up as no response has been received
            WrapUp(SnmpErrorReport(Snmp_Error, Snmp_No_Response));

            return; // since the waiting_message would have been destroyed
        }
    }
    else
    {
    }
}


// A call to this function signifies that state corresponding to the
// waiting_message need not be kept any further
// if required, it cancels the timer event and 
// deregisters with the message registry
// it notifies the flow control mechanism of the termination
// which destroys the waiting_message
void WaitingMessage::ReceiveReply(IN const SnmpPdu *snmp_pdu, IN SnmpErrorReport &error_report)
{   
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: ReceiveReply (this(%d), session_id(%d),frame_id(%d),error(%d), status(%d))\n",this, message->GetSessionFrameId(), last_transport_frame_id,error_report.GetError(), error_report.GetStatus()
    ) ;
)

    // cancels registrations with message registry
    DeregisterRequestIds();

    // cancels timer event
    session->timer.CancelMessageTimer(*this,session->timer_event_id);


    // if required (the corresponding SENT event has not been signaled
    // yet), cancel the association with the last transport frame id
    if ( last_transport_frame_id != ILLEGAL_TRANSPORT_FRAME_ID )
    {
        session->id_mapping.DisassociateTransportFrameId(last_transport_frame_id);
        last_transport_frame_id = ILLEGAL_TRANSPORT_FRAME_ID;
    }
    
    // call fc_mech.NotifyReceipt(this,pdu,error_report)
    // which should destroy the waiting message
    session->flow_control.NotifyReceipt(*this, snmp_pdu, error_report);
}


// buffers the snmp pdu received as a reply
void WaitingMessage::BufferReply(IN const SnmpPdu &reply_snmp_pdu)
{
    if ( WaitingMessage::reply_snmp_pdu == NULL )
    {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: Buffering reply %d, %d, this(%d)\n",message->GetSessionFrameId(), rexns_left, this
    ) ;
)
        WaitingMessage::reply_snmp_pdu = new SnmpPdu((SnmpPdu&)reply_snmp_pdu);
    }
}

// returns TRUE if a reply has been buffered
BOOL WaitingMessage::ReplyBuffered()
{
    return (reply_snmp_pdu != NULL);
}

// returns a ptr to the buffered reply pdu, if buffered
// otherwise a null ptr is returned
// IMPORTANT: it sets the reply_snmp_pdu to NULL, so that it may not
// be deleted when the waiting message is destroyed
SnmpPdu *WaitingMessage::GetBufferedReply()
{
    SnmpPdu *to_return = reply_snmp_pdu;
    reply_snmp_pdu = NULL;

    return to_return;
}

// informs the waiting message that a sent message has been
// processed 
void WaitingMessage::SetSentMessageProcessed()
{
    sent_message_processed = TRUE;
}

// if a sent message has been processed, it returns TRUE, else FALSE
BOOL WaitingMessage::GetSentMessageProcessed()
{
    return sent_message_processed;
}

void WaitingMessage::SelfDestruct(void)
{
    if ( !active )
    {
        delete this;
        return;
    }
    else // else, set the active flag to FALSE
         // when this is detected, it'll self destruct
        active = FALSE;
}

TimerEventId WaitingMessage::GetTimerEventId ()
{
    return m_TimerEventId ;
}

void WaitingMessage::SetTimerEventId ( TimerEventId a_TimerEventId )
{
    m_TimerEventId = a_TimerEventId ;
}

// if required, it cancels registration with the message_registry and
// the timer event with the timer.
WaitingMessage::~WaitingMessage(void)
{
    // if required, cancel registrations with message registry
    if ( !request_id_list.IsEmpty() )
        DeregisterRequestIds();

    session->timer.CancelMessageTimer(*this,session->timer_event_id);

    // if required (the corresponding SENT event has not been signaled
    // yet), cancel the association with the last transport frame id
    if ( last_transport_frame_id != ILLEGAL_TRANSPORT_FRAME_ID )
        session->id_mapping.DisassociateTransportFrameId(last_transport_frame_id);

    // if a reply pdu has been buffered, destroy it
    if ( reply_snmp_pdu != NULL )
    {
        delete &reply_snmp_pdu->GetVarbindList () ;
        delete reply_snmp_pdu;
    }

    // deletes the message ptr
    delete message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\ophelp.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: ophelp.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "value.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "vbl.h"
#include "fs_reg.h"
#include "pseudo.h"
#include "encap.h"
#include "error.h"
#include "ophelp.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "op.h"
#include <winsock.h>

// returns an SnmpTransportAddress created using the HSNMP_ENTITY
// this method returns the first transport address it can create
// using the string form of the HSNMP_ENTITY supplied
SnmpTransportAddress *OperationHelper::GetTransportAddress(IN HSNMP_ENTITY &haddr)
{
    char buff[MAX_ADDRESS_LEN];
    SNMPAPI_STATUS status = SnmpEntityToStr(haddr, MAX_ADDRESS_LEN, (LPSTR)buff);

    if (SNMPAPI_FAILURE == status)
    {
        return (SnmpTransportAddress *)NULL;
    }

    //first try ip...
    SnmpTransportIpAddress *retip = new SnmpTransportIpAddress(buff, SNMP_ADDRESS_RESOLVE_VALUE);

    if (retip->IsValid())
    {
        return (SnmpTransportAddress *)retip;
    }
    
    delete retip;

    //next try ipx...
    SnmpTransportIpxAddress *retipx = new SnmpTransportIpxAddress(buff);

    if (retipx->IsValid())
    {
        return (SnmpTransportAddress *)retipx;
    }
    
    delete retipx;

    //nothing worked...
    return (SnmpTransportAddress *)NULL;
}

// returns an SnmpSecurity created using the HSNMP_CONTEXT
// this method returns the first security context it can create
// using the string form of the HSNMP_CONTEXT supplied
SnmpSecurity *OperationHelper::GetSecurityContext(IN HSNMP_CONTEXT &hctxt)
{
    smiOCTETS buff; 
    SNMPAPI_STATUS status = SnmpContextToStr(hctxt, &buff);

    if (SNMPAPI_FAILURE == status)
    {
        return (SnmpSecurity *)NULL;
    }

    SnmpOctetString octstr( (UCHAR *)(buff.ptr), (ULONG)(buff.len) );
    SnmpCommunityBasedSecurity* retval = new SnmpCommunityBasedSecurity(octstr);
    SnmpFreeDescriptor (SNMP_SYNTAX_OCTETS, &buff);

    if (NULL != (*retval)())
    {
        return (SnmpSecurity *)retval;
    }
    
    delete retval;
    return (SnmpSecurity *)NULL;
}

// returns an SnmpVarBind containing an SnmpObjectIdentifier and an
// SnmpValue created using the instance(OID) and the value(VALUE)
SnmpVarBind *OperationHelper::GetVarBind(IN smiOID &instance,
                                         IN smiVALUE &value)
{
    SnmpVarBind *var_bind = NULL ;

    // create an SnmpObjectIdentifier using the instance value
    SnmpObjectIdentifier id(instance.ptr, instance.len);

    // for each possible value for value.syntax, create the
    // corresponding SnmpValue

    switch(value.syntax)
    {
        case SNMP_SYNTAX_NULL:      // null value
        {
            var_bind = new SnmpVarBind(id, SnmpNull () );
        }
        break;

        case SNMP_SYNTAX_INT:       // integer *(has same value as SNMP_SYNTAX_INT32)*
        {
            var_bind = new SnmpVarBind(id, SnmpInteger(value.value.sNumber) ) ;
        }
        break;

        case SNMP_SYNTAX_UINT32:        // integer *(has same value as SNMP_SYNTAX_GAUGE)*
        {
            var_bind = new SnmpVarBind(id, SnmpUInteger32(value.value.uNumber) ) ;
        }
        break;

        case SNMP_SYNTAX_CNTR32:    // counter32
        {
            var_bind = new SnmpVarBind(id, SnmpCounter (value.value.uNumber) ) ;
        }
        break;

        case SNMP_SYNTAX_GAUGE32:   // gauge
        {
            var_bind = new SnmpVarBind(id, SnmpGauge(value.value.uNumber) );
        }
        break;
            
        case SNMP_SYNTAX_TIMETICKS: // time ticks
        {
            var_bind = new SnmpVarBind(id, SnmpTimeTicks(value.value.uNumber) );
        }
        break;

        case SNMP_SYNTAX_OCTETS:    // octets
        {
            var_bind = new SnmpVarBind(id, SnmpOctetString(value.value.string.ptr,
                                             value.value.string.len) ) ;
        }
        break;

        case SNMP_SYNTAX_OPAQUE:    // opaque value
        {
            var_bind = new SnmpVarBind(id, SnmpOpaque(value.value.string.ptr,
                                        value.value.string.len) );
        }
        break;

        case SNMP_SYNTAX_OID:       // object identifier
        {
            var_bind = new SnmpVarBind(id, SnmpObjectIdentifier(value.value.oid.ptr,
                                                  value.value.oid.len) );
        }
        break;

        case SNMP_SYNTAX_IPADDR:    // ip address value
        {
            if ( value.value.string.ptr )
            {
                var_bind = new SnmpVarBind(id, SnmpIpAddress(ntohl(*((ULONG *)value.value.string.ptr))) );
            }
            else
            {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"OperationHelper::DecodeVarBind: Invalid encoding\n" 
    ) ;
)
                var_bind = NULL ;
            }
        }
        break;

        case SNMP_SYNTAX_CNTR64:    // counter64
        {
            var_bind = new SnmpVarBind(id, SnmpCounter64 (value.value.hNumber.lopart , value.value.hNumber.hipart ) );
        }
        break;

        case SNMP_SYNTAX_NOSUCHOBJECT:
        {
            var_bind = new SnmpVarBind(id, SnmpNoSuchObject () ) ;
        }
        break ;

        case SNMP_SYNTAX_NOSUCHINSTANCE:
        {
            var_bind = new SnmpVarBind(id, SnmpNoSuchInstance () ) ;
        }
        break ;

        case SNMP_SYNTAX_ENDOFMIBVIEW:
        {
            var_bind = new SnmpVarBind(id, SnmpEndOfMibView () ) ;
        }
        break ;

        default:
        {
            // it must be an unsupported type 
            // return an SnmpNullValue by default
            var_bind = new SnmpVarBind(id, SnmpNull() );
        
        }
        break;
    };

    return var_bind;
}

            
void OperationHelper::TransmitFrame (

    OUT SessionFrameId &session_frame_id, 
    VBList &vbl)
{
    SnmpSecurity *security = operation.frame_state_registry.GetSecurity();

    // encode a frame
    SnmpPdu *t_SnmpPdu = new SnmpPdu ;
    SnmpErrorReport t_SnmpErrorReport ;
    SnmpTransportAddress *t_SrcTransportAddress = NULL ;
    SnmpTransportAddress *t_DstTransportAddress = NULL ;
    SnmpCommunityBasedSecurity *t_SnmpcommunityBasedSecurity = NULL ;

    try 
    {
        operation.session.GetSnmpEncodeDecode ().EncodeFrame (

            *t_SnmpPdu ,
            session_frame_id ,
            operation.GetPduType () ,
            t_SnmpErrorReport ,
            vbl.GetVarBindList () ,
            t_SnmpcommunityBasedSecurity ,
            t_SrcTransportAddress ,
            t_DstTransportAddress
        );
    }
	catch ( Heap_Exception e_He )
	{
        delete t_SnmpPdu ;

        operation.m_OperationWindow.PostMessage (  

            Window :: g_SendErrorEvent , 
            (WPARAM)&vbl, 
            (LPARAM)(new GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__))
        );

		return ;
	}
    catch ( GeneralException exception )
    {
        delete t_SnmpPdu ;

        operation.m_OperationWindow.PostMessage (  

            Window :: g_SendErrorEvent , 
            (WPARAM)&vbl, 
            (LPARAM)(new GeneralException(exception))
        );

		return ;
    }

    if ( security != NULL )
    {
        operation.session.SessionSendFrame (

            operation, 
            session_frame_id, 
            *t_SnmpPdu,
            *security
        );
    }
    else
    {
        operation.session.SessionSendFrame (

            operation, 
            session_frame_id, 
            *t_SnmpPdu
        );
    }
}

void OperationHelper::ReceiveResponse (

    ULONG var_index ,
    SnmpVarBindList &sent_var_bind_list,
    SnmpVarBindList &received_var_bind_list,
    SnmpErrorReport &error_report
)
{
    
    // check if the var bind list has the same length

    if ( sent_var_bind_list.GetLength() != received_var_bind_list.GetLength () )
    {
        operation.is_valid = FALSE;
        return;
    }

    sent_var_bind_list.Reset();
    received_var_bind_list.Reset();

    ULONG t_Index = 0 ;
    while( sent_var_bind_list.Next() && received_var_bind_list.Next() )
    {
        const SnmpVarBind *sent_var_bind = sent_var_bind_list.Get();
        const SnmpVarBind *received_var_bind = received_var_bind_list.Get();

        operation.ReceiveVarBindResponse(

            var_index + t_Index ,
            *sent_var_bind, 
            *received_var_bind, 
            error_report
        );

        t_Index ++ ;
    }
}


// processes the response (successful or otherwise) for the specified
// frame. the frame may be retransmitted in case of a reply bearing
// an errored index
void OperationHelper::ProcessResponse (

    FrameState *frame_state,
    SnmpVarBindList &a_SnmpVarBindList ,
    SnmpErrorReport &a_SnmpErrorReport
)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"OperationHelper::ProcessResponse: eindex(%d), error(%d), status(%d)\n",a_SnmpErrorReport.GetIndex(), a_SnmpErrorReport.GetError(), a_SnmpErrorReport.GetStatus()
    ) ;
)

    // if there is an error in a particular var bind
    if ( (a_SnmpErrorReport.GetIndex () != 0) && (a_SnmpErrorReport.GetStatus () != SNMP_ERROR_NOERROR) )
    {
        if ( operation.GetPduType () != SnmpEncodeDecode :: PduType :: SET )
        {
            // delete the corresponding var bind from the VBList 
            // in the frame_state and announce the receipt of 
            // errored var bind by making a callback
            VBList *vblist = frame_state->GetVBList();
            SnmpVarBind *errored_vb;

            try
            {
                errored_vb = vblist->Get(a_SnmpErrorReport.GetIndex () );
            }
			catch ( Heap_Exception e_He )
			{
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__)
                );

                delete &frame_state;
                return;
			}
            catch(GeneralException exception)
            {
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    exception
                );

                delete &frame_state;
                return;
            }

            // *** (SnmpStatus) casting
            SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex () );

            operation.ReceiveErroredVarBindResponse(

                vblist->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                *errored_vb, 
                report
            );

            delete errored_vb;

            try
            {
                vblist->Remove (a_SnmpErrorReport.GetIndex () );
            }
			catch ( Heap_Exception e_He )
			{
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__)
                );

                delete &frame_state;
                return;
			}
            catch(GeneralException exception)
            {
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    exception
                );

                delete &frame_state;
                return;
            }

            // if the VarBindList becomes empty, corresp. frame state
            // may be deleted
            if ( vblist->GetVarBindList().Empty() )
                delete frame_state;
            else
            {
                // Split the frame in half

                SnmpVarBindList &vbl = vblist->GetVarBindList ();

                if ( a_SnmpErrorReport.GetIndex () > 1 )
                {
                    SnmpVarBindList *t_Car = vbl.Car ( a_SnmpErrorReport.GetIndex () - 1 ) ;
                    VBList *t_List = new VBList (

                        operation.session.GetSnmpEncodeDecode () ,
                        *t_Car,
                        vblist->GetIndex () 
                    ) ;
                        
                    operation.SendFrame(*t_List) ;
                }

                if ( a_SnmpErrorReport.GetIndex () < vbl.GetLength () )
                {
                    SnmpVarBindList *t_Cdr = vbl.Cdr ( a_SnmpErrorReport.GetIndex () - 1 ) ;

                    VBList *t_List = new VBList (

                        operation.session.GetSnmpEncodeDecode () ,
                        *t_Cdr,
                        vblist->GetIndex () + a_SnmpErrorReport.GetIndex () 
                    ) ;
                        
                    operation.SendFrame(*t_List) ;
                }

                // re-send the frame using the old frame_state

                delete frame_state ;
            }

            return;
        }
        else
        {
            VBList *vblist = frame_state->GetVBList();
            SnmpVarBind *errored_vb;

            try
            {
                errored_vb = vblist->Remove(a_SnmpErrorReport.GetIndex () );
            }
			catch ( Heap_Exception e_He )
			{
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__)
                );

                delete &frame_state;
                return;
			}
            catch(GeneralException exception)
            {
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    exception
                );

                delete &frame_state;
                return;
            }

            // *** (SnmpStatus) casting
            SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex () );

            operation.ReceiveErroredVarBindResponse(

                vblist->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                *errored_vb, 
                report
            );

            delete errored_vb;

            SnmpErrorReport t_SnmpErrorReport ;

            operation.ReceiveErroredResponse(

                vblist->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                frame_state->GetVBList()->GetVarBindList(), 
                t_SnmpErrorReport
            );

            // destroy the frame_state: since the only case when the
            // old frame_state is reused is when there is an error
            // in a particular index and we wouldn't have come here in that case
            delete frame_state;

            return ;
        }
    }

    // otherwise, check the error status
    switch(a_SnmpErrorReport.GetStatus () )
    {
        case SNMP_ERROR_NOERROR:
        {
            // call ReceiveResponse for each vb
            ReceiveResponse (
                frame_state->GetVBList()->GetIndex (),
                frame_state->GetVBList()->GetVarBindList(), 
                a_SnmpVarBindList , 
                a_SnmpErrorReport
            );
        }
        break;

        case SNMP_ERROR_TOOBIG:
        {
            if ( operation.GetPduType () != SnmpEncodeDecode :: PduType :: SET )
            {
                // callback FrameTooBig()
                operation.FrameTooBig();

                // check if the callback cancelled the operation
                if ( ! operation.in_progress )
                    return;

                // obtain the list, length
                SnmpVarBindList &list = frame_state->GetVBList()->GetVarBindList();
                UINT length = list.GetLength();

                // if the length is 1, call ReceiveErroredResponse
                if ( length == 1 )
                {
                        // *** casting Snmp_Status ***
                    SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex () );

                    operation.ReceiveErroredVarBindResponse(

                        frame_state->GetVBList()->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                        *(list[1]), 
                        report
                    );
                }
                else // split the list midway and send both fragments
                {
                    operation.SendVarBindList(

                        list, 
                        (length/2),
                        frame_state->GetVBList()->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 
                    );
                }
            }
            else
            {
                // *** casting Snmp_Status ***
                SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex ());

                // for each varbind in varbindlist
                // call ReceiveResponse for each vb
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex (), 
                    frame_state->GetVBList()->GetVarBindList(), 
                    report
                );
            }
        }
        break;

        default:
        {
            // *** casting Snmp_Status ***
            SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex ());

            // for each varbind in varbindlist
            // call ReceiveResponse for each vb
            operation.ReceiveErroredResponse(

                frame_state->GetVBList()->GetIndex (), 
                frame_state->GetVBList()->GetVarBindList(), 
                report
            );
        }
        break;
    }

    
    // destroy the frame_state: since the only case when the
    // old frame_state is reused is when there is an error
    // in a particular index and we wouldn't have come here in that case
    delete frame_state;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\op.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: op.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "encap.h"
#include "value.h"
#include "vblist.h"
#include "vbl.h"
#include "fs_reg.h"
#include "error.h"
#include "sec.h"
#include "pdu.h"
#include "pseudo.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "ophelp.h"
#include "op.h"
#include "encdec.h"


void SnmpOperation::ReceiveResponse()
{
}

// the operation uses window messaging encapsulated within the dummy session
// to make the callbacks to an operation user, asynchronous with respect
// to the user's call to SendRequest
// the events currently posted are SEND_ERROR and OPERATION_COMPLETION
LONG SnmpOperation::ProcessInternalEvent(

    HWND hWnd, 
    UINT user_msg_id,
    WPARAM wParam, 
    LPARAM lParam
)
{
    LONG rc = 0;

    CriticalSectionLock access_lock(exclusive_CriticalSection); // TRUE

    // obtain exclusive access into the system
    if ( !access_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return rc;
    }

    // return immediately, if the operation is not valid
    if ( !is_valid )
        return rc;

    // process the message

    if ( user_msg_id == Window :: g_SendErrorEvent )
    {
    // in case the attempt to send a frame failed
       VBList *vblist = (VBList *)wParam;
       GeneralException *exception = (GeneralException *)lParam;

       ReceiveErroredResponse(vblist->GetIndex (),vblist->GetVarBindList(), *exception);
       
       delete vblist;
       delete exception;
    }
    else if ( user_msg_id == Window :: g_OperationCompletedEvent )
    {
// signals completion of the operation

        frame_state_registry.DestroySecurity();
        in_progress = FALSE;
        ReceiveResponse();
    }
    else
    {
    // predefined window message
        DefWindowProc(hWnd, user_msg_id, wParam, lParam);
    }

    // give up exclusive access
    access_lock.UnLock();

    // since this is also a point of entry into the SnmpOperation
    // we must check for deletion of the operation
    CheckOperationDeletion();

    return rc;
}

// this method may be called to delete the Operation
// note: the operation is deleted when a public method
// returns. For this reason, if a public method calls another 
// public method, it must not access any per-class variables
// after that.
void SnmpOperation::DestroyOperation()
{
    delete_operation = TRUE;
}


// its mandatory for every public method to call this method
// before returning to the caller
// it checks if the call sequence included a call to DestroyOperation
// and if so, deletes "this" before returning
void SnmpOperation::CheckOperationDeletion()
{
    if ( delete_operation == TRUE )
        delete this;
}

#pragma warning (disable:4355)

// initializes variables and, if successful, registers itself with the session
SnmpOperation::SnmpOperation(

    SnmpSession &snmp_session

) : session(snmp_session),
    m_OperationWindow(*this),
    helper(*this)
{
    in_progress = FALSE;
    is_valid = FALSE;

    if ( !m_OperationWindow() )
        return;

    varbinds_per_pdu = SnmpImpSession :: VarbindsPerPdu ( session.GetVarbindsPerPdu() ) ;

    delete_operation = FALSE;

    session.RegisterOperation(*this);

    is_valid = TRUE;
}

#pragma warning (default:4355)

// on destruction, the operation cancels all outstanding frames,
// frees the allocated memory for variables and deregisters with the session
SnmpOperation::~SnmpOperation(void)
{
    // calls to public functions from this point should not
    // cause repeated deletion - so set the flag to FALSE
    delete_operation = FALSE;

    // cancel any outstanding frames
    CancelRequest();
    
    // deregister with session
    session.DeregisterOperation(*this);
}


// sends the varbinds in the var bind list packaged in several
// frames each carrying atmost varbinds_per_pdu varbinds
// if the security context is not NULL, same is used as the context
// for all the generated frames

void SnmpOperation::SendRequest(

    IN SnmpVarBindList &varBindList,
    IN SnmpSecurity *security
)
{
    // if not valid, return immediately
    if ( !is_valid )
        return;

    CriticalSectionLock access_lock(exclusive_CriticalSection); // TRUE

    // obtain exclusive access into the system
    if ( !access_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return;
    }

    // if already in progress, we cannot proceed
    if ( in_progress == TRUE )
        return;

    in_progress = TRUE;

    // if length of varBindList exceeds varbinds_per_pdu
    // call FrameOverRun()
    if ( varBindList.GetLength() > varbinds_per_pdu )
        FrameOverRun();

    // check if the send request has been cancelled in the
    // meantime. Proceed only if still in progress
    if ( !in_progress )
        return;

    // register the security for the duration of SendRequest
    // (until a reply for the last outstanding frame is received) 
    frame_state_registry.RegisterSecurity(security);

    // send the varbind list
    SendVarBindList(varBindList);

    // if no outstanding frames, post a message for the completion
    // of operation. This message, when processed, shall set the
    // in_progress status, destroy security and call ReceiveResponse
    if ( frame_state_registry.Empty() )
    {
        m_OperationWindow.PostMessage ( 

            Window :: g_OperationCompletedEvent , 
            0, 
            0
        );
    }

    // give up exclusive access
    // access_lock.UnLock();   The lock may be released at this point
}


void SnmpOperation::SendRequest(IN SnmpVarBindList &varBindList)
{
    SendRequest(varBindList, NULL);
    CheckOperationDeletion();
}

void SnmpOperation::SendRequest(

    IN SnmpVarBindList &varBindList,
    IN SnmpSecurity &security
)
{
    SendRequest(varBindList, &security);
    CheckOperationDeletion();
}


// sends the varbinds in the var bind list packaged in several
// frames each carrying atmost MIN(varbinds_per_pdu, max_size) varbinds
void SnmpOperation::SendVarBindList(IN SnmpVarBindList &varBindList,
                                    IN UINT max_size,
                                    IN ULONG var_index )
{
    UINT max_varbinds_per_pdu = MIN(varbinds_per_pdu, max_size);
    UINT list_length = varBindList.GetLength();

    // set list iterator to the start of the list, 
    // current_position <- 0
    varBindList.Reset();
    varBindList.Next();
    UINT current_position = 0;

    // chop up the varBindList into segments atmost max_varbinds_per_pdu
    // in size and send them in separate frames
    while ( current_position < list_length )
    {
        UINT segment_length = MIN((list_length-current_position), max_varbinds_per_pdu);

        // create copy of the varBindList from
        // current_position (of length segment_length)
        SnmpVarBindList *list_segment = varBindList.CopySegment(segment_length);

        // create a VBList and call SendFrame with it

        SendFrame ( 

            *(new VBList(session.GetSnmpEncodeDecode (),*list_segment,var_index + current_position + 1))
        );  

        // update current_position
        current_position += segment_length;
    }
}


// transmits a frame with the var binds in the vblist
// using the session and registers the frame state
void SnmpOperation::SendFrame(VBList &vblist)
{
    try
    {
        SessionFrameId session_frame_id = 0L;

        helper.TransmitFrame (

            session_frame_id, 
            vblist
        );

        FrameState *frame_state = new FrameState(session_frame_id,vblist);

        // insert a frame_state(session_frame_id, vblist)
        frame_state_registry.Insert(session_frame_id, *frame_state );
    }
    catch(GeneralException exception)
    {
        // post a message to signal the error in sending the frame
        // when processed, it shall call ReceiveErroredResponse and
        // delete the vblist
        m_OperationWindow.PostMessage (  

            Window :: g_SendErrorEvent , 
            (WPARAM)&vblist, 
            (LPARAM)(new GeneralException(exception))
        );
    }
}

// a sent frame notification from the session signifies one transmission
// of the frame. atmost one notification per session frame id can 
// signal an error in transmission
void SnmpOperation::SentFrame(

    IN const SessionFrameId session_frame_id,
    IN const SnmpErrorReport &error_report
)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Sent %d\n" ,session_frame_id
    ) ;
)

    // if there was an error in sending, let ReceiveFrame handle it
    // otherwise ignore it and wait for the reply
    if ( error_report.GetError() != Snmp_Success )
    {
        ReceiveFrame (

            session_frame_id, 
            SnmpPdu(), 
            error_report
        );
    }
    else
    {
        CheckOperationDeletion();
    }

    // since ReceiveFrame might have deleted the operation, we
    // must call CheckOperationDeletion only in the else 
}

// cancels all the frames whose frame states are currently present in
// the frame state registry
void SnmpOperation::CancelRequest()
{
    // if not valid, return immediately
    if ( !is_valid )
        return;

    CriticalSectionLock exclusive_lock(exclusive_CriticalSection);

    // obtain exclusive access
    if ( !exclusive_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return;
    }

    // if not in progress, there is nothing to be done
    if ( !in_progress )
        return;

    // reset the frame_state_registry to set
    // the iterator to the beginning
    frame_state_registry.ResetIterator();

    // cancel all outstanding frames
    while (1)
    {
        // for each registered frame_state

        // remove it from the frame_state_registry
        FrameState *frame_state = frame_state_registry.GetNext();

        // if no more frames, we are done
        if ( frame_state == NULL )
            break;

        // cancel the corresponding frame
        session.SessionCancelFrame(

            frame_state->GetSessionFrameId()
        );

        // destroy frame_state
        delete frame_state;
    }

    // remove all the associations
    frame_state_registry.RemoveAll();

    // destroy the security
    frame_state_registry.DestroySecurity();
    
    // in_progress <- FALSE
    in_progress = FALSE;

    m_OperationWindow.PostMessage ( 

        Window :: g_OperationCompletedEvent , 
        0, 
        0
    );

    // leave exclusive access
    exclusive_lock.UnLock();

    CheckOperationDeletion();
}


void SnmpOperation::ReceiveErroredResponse(

    ULONG var_index ,
    SnmpVarBindList &errored_list,
    const SnmpErrorReport &error_report
)
{
    ULONG t_Index = 0 ;
    errored_list.Reset();
    while( errored_list.Next() )
    {
        const SnmpVarBind *var_bind = errored_list.Get();

        ReceiveErroredVarBindResponse(

            var_index + t_Index ,
            *var_bind, 
            error_report
        );

        t_Index ++ ;
    }
}


// ReceiveFrame is called by the session when a reply is received for
// an outstanding frame or it has received no response for its
// retransmissions. It may also be called by the SnmpOperation::SentFrame
// when the error report shows an error during transmission
// It decodes the received snmp pdu and processes it or else, if no
// reply has been received, informs the user of the error report
// when all no outstanding frames remain, an OPERATION_COMPLETION event
// is posted to inform the user of the event asynchronously

void SnmpOperation::ReceiveFrame(

    IN const SessionFrameId session_frame_id,
    IN const SnmpPdu &snmpPdu,
    IN const SnmpErrorReport &errorReport
)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpOperation::ReceiveFrame: received(%d), error(%d), status(%d)\n",session_frame_id, errorReport.GetError(), errorReport.GetStatus()
    ) ;
)

    // if not valid, return immediately
    if ( !is_valid )
        return;

    CriticalSectionLock exclusive_lock(exclusive_CriticalSection);

    // obt. exclusive access
    if ( !exclusive_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return;
    }

    // if not in progress, nothing needs to be done
    // ignore the 
    if ( !in_progress )
        return;

    // get corresponding frame_state
    FrameState *frame_state = frame_state_registry.Remove(session_frame_id);

    // if no such frame_state return
    if ( frame_state == NULL )
        return;

    // decode the frame to extract 
    // vbl, error-index, error-status

    SnmpErrorReport t_SnmpErrorReport ;
    SnmpVarBindList *t_SnmpVarBindList ;
    SnmpCommunityBasedSecurity *t_SnmpCommunityBasedSecurity = NULL ;
    SnmpTransportAddress *t_SrcTransportAddress = NULL ;
    SnmpTransportAddress *t_DstTransportAddress = NULL ;
    SnmpEncodeDecode :: PduType t_PduType  = SnmpEncodeDecode :: PduType :: GET;
    RequestId t_RequestId = 0 ;
    
    try
    {
        session.GetSnmpEncodeDecode ().DecodeFrame (

            ( SnmpPdu& ) snmpPdu ,
            t_RequestId ,
            t_PduType ,
            t_SnmpErrorReport ,
            t_SnmpVarBindList ,
            t_SnmpCommunityBasedSecurity ,
            t_SrcTransportAddress ,
            t_DstTransportAddress
        );
    }
    catch(GeneralException exception)
    {
        CheckOperationDeletion();
        return;
    }

    t_SnmpErrorReport = errorReport ;

    helper.ProcessResponse (

        frame_state, 
        *t_SnmpVarBindList, 
        t_SnmpErrorReport
    );

    // if the registry is empty,
    // destroy security, set in_progress, release exclusive access
    // call ReceiveResponse() to signal completion finally
    if ( frame_state_registry.Empty() )
    {
        frame_state_registry.DestroySecurity();
        in_progress = FALSE;

        // leave exclusive access: so that the ReceiveResponse
        // call back may be able to make another SendRequest
        exclusive_lock.UnLock();

        // call the user to inform him of completion
        ReceiveResponse();
    }
    else
    {
        // leave exclusive access
        exclusive_lock.UnLock();
    }
        
    CheckOperationDeletion();
}


// The GetOperation sends the GET PDU
SnmpEncodeDecode :: PduType SnmpGetOperation::GetPduType(void)
{
    return SnmpEncodeDecode :: GET;
}


// The GetOperation sends the GETNEXT PDU
SnmpEncodeDecode ::PduType SnmpGetNextOperation::GetPduType(void)
{
    return SnmpEncodeDecode :: GETNEXT;
}


// The GetOperation sends the SET PDU
SnmpEncodeDecode :: PduType SnmpSetOperation::GetPduType(void)
{
    return SnmpEncodeDecode :: SET;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <ScopeGuard.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\opreg.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: opreg.cpp
Written By: B.Rajeev
----------------------------------------------------------*/
#include "precomp.h"
#include <provexpt.h>

#include "fs_reg.h"
#include "pseudo.h"
#include "ophelp.h"
#include "opreg.h"
#include "op.h"

OperationRegistry::OperationRegistry()
{
    num_registered = 0;
}

void OperationRegistry::Register(IN SnmpOperation &operation)
{
    // flagging the operation as registered
    store[&operation] = NULL;
    num_registered++;
}

void OperationRegistry::Deregister(IN SnmpOperation &operation)
{
    // flag the operation as unregistered
    if ( store.RemoveKey(&operation) )
	{
		num_registered--;
	}
}

OperationRegistry::~OperationRegistry()
{
   store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\pdu.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: pdu.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "address.h"
#include "pdu.h"

SnmpPdu::SnmpPdu():m_SourceAddress (NULL),m_DestinationAddress(NULL),m_SnmpCommunityName (NULL),length(0),ptr(NULL),m_SnmpVarBindList(NULL)
{
    is_valid = FALSE;
}


SnmpPdu::SnmpPdu(IN SnmpPdu &snmpPdu):m_SourceAddress (NULL),m_DestinationAddress(NULL),m_SnmpCommunityName (NULL),m_SnmpVarBindList(NULL)
{
    is_valid = FALSE;

    Initialize(snmpPdu.GetFrame(), snmpPdu.GetFrameLength());

    m_RequestId = snmpPdu.m_RequestId ;
    m_PduType = snmpPdu.m_PduType ;
    m_ErrorReport = snmpPdu.m_ErrorReport ;
    m_SnmpVarBindList = new SnmpVarBindList ( *snmpPdu.m_SnmpVarBindList ) ;
    m_SourceAddress = snmpPdu.m_SourceAddress ? snmpPdu.m_SourceAddress->Copy () : NULL ;
    m_DestinationAddress = snmpPdu.m_DestinationAddress ? snmpPdu.m_DestinationAddress->Copy () : NULL ;
    m_SnmpCommunityName = snmpPdu.m_SnmpCommunityName ? ( SnmpCommunityBasedSecurity * ) snmpPdu.m_SnmpCommunityName->Copy () : NULL ;

    is_valid = TRUE ;
}

SnmpPdu::SnmpPdu(IN const UCHAR *frame, IN const ULONG &frameLength) : m_SourceAddress (NULL),m_DestinationAddress(NULL),m_SnmpCommunityName (NULL),m_SnmpVarBindList(NULL)
{
    Initialize(frame, frameLength);
}

SnmpPdu::~SnmpPdu(void) 
{
    FreeFrame();
    FreePdu () ;
}

void SnmpPdu::FreeFrame(void)
{
    if ( is_valid )
    {
        delete[] ptr;
    }
}

void SnmpPdu::FreePdu ()
{
    delete m_SnmpCommunityName ;
    delete m_DestinationAddress ;
    delete m_SourceAddress ;
}

void SnmpPdu::Initialize(IN const UCHAR *frame, IN const ULONG &frameLength)
{
    if ( frame )
    {
        length = frameLength;
        ptr = new UCHAR[frameLength];
        memcpy(ptr, frame, length);
    }
    else
    {
        length = 0 ;
        ptr = NULL ;
    }

    is_valid = TRUE;
}

ULONG SnmpPdu::GetFrameLength() const
{
    return ( (is_valid)?length:0 );
}

UCHAR *SnmpPdu::GetFrame() const
{
    return ( (is_valid)?ptr:NULL );
}

void SnmpPdu::SetPdu ( IN SnmpPdu &a_SnmpPdu )
{
    FreeFrame();
    FreePdu () ;

    Initialize(a_SnmpPdu.GetFrame(), a_SnmpPdu.GetFrameLength());

    m_RequestId = a_SnmpPdu.m_RequestId ;
    m_PduType = a_SnmpPdu.m_PduType ;
    m_ErrorReport = a_SnmpPdu.m_ErrorReport ;
    m_SnmpVarBindList = new SnmpVarBindList ( *a_SnmpPdu.m_SnmpVarBindList ) ;
    m_SourceAddress = a_SnmpPdu.m_SourceAddress ? a_SnmpPdu.m_SourceAddress->Copy () : NULL ;
    m_DestinationAddress = a_SnmpPdu.m_DestinationAddress ? a_SnmpPdu.m_DestinationAddress->Copy () : NULL ;
    m_SnmpCommunityName = a_SnmpPdu.m_SnmpCommunityName ? ( SnmpCommunityBasedSecurity * ) a_SnmpPdu.m_SnmpCommunityName->Copy () : NULL ;

}

void SnmpPdu::SetPdu(IN const UCHAR *frame, IN const ULONG frameLength)
{
    FreeFrame();

    Initialize(frame, frameLength);
}

BOOL SnmpPdu :: SetRequestId ( IN RequestId a_RequestId )
{
    m_RequestId = a_RequestId ;

    return TRUE ;
}

BOOL SnmpPdu :: SetVarBindList ( OUT SnmpVarBindList &a_SnmpVarBindList )
{
    if ( m_SnmpVarBindList )
        delete m_SnmpVarBindList ;

    m_SnmpVarBindList = &a_SnmpVarBindList ;

    return TRUE ;
}

BOOL SnmpPdu :: SetCommunityName ( IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity )
{
    delete m_SnmpCommunityName ;
    m_SnmpCommunityName = &a_SnmpCommunityBasedSecurity ;

    return TRUE ;
}

BOOL SnmpPdu :: SetErrorReport ( OUT SnmpErrorReport &a_SnmpErrorReport )
{
    m_ErrorReport = a_SnmpErrorReport ;

    return TRUE ;
}

BOOL SnmpPdu :: SetPduType ( OUT SnmpEncodeDecode :: PduType a_PduType )
{
    m_PduType = a_PduType ;
    return TRUE ;
}

BOOL SnmpPdu :: SetSourceAddress ( IN SnmpTransportAddress &a_TransportAddress )
{
    delete m_SourceAddress ;
    m_SourceAddress = &a_TransportAddress ;

    return TRUE ;
}

BOOL SnmpPdu :: SetDestinationAddress ( IN SnmpTransportAddress &a_TransportAddress )
{
    delete m_DestinationAddress ;
    m_DestinationAddress = &a_TransportAddress ;

    return TRUE ;
}

SnmpTransportAddress &SnmpPdu :: GetSourceAddress ()
{
    return *m_SourceAddress ;
}

SnmpTransportAddress &SnmpPdu :: GetDestinationAddress ()
{
    return *m_DestinationAddress ;
}

SnmpEncodeDecode :: PduType &SnmpPdu :: GetPduType ()
{
    return m_PduType ;
}

RequestId &SnmpPdu :: GetRequestId ()
{
    return m_RequestId ;
}

SnmpErrorReport &SnmpPdu :: GetErrorReport ()
{
    return m_ErrorReport ;

}

SnmpVarBindList &SnmpPdu :: GetVarbindList ()
{
    return *m_SnmpVarBindList ;
}

SnmpCommunityBasedSecurity &SnmpPdu :: GetCommunityName ()
{
    return *m_SnmpCommunityName ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\pseudo.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: pseudo.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"

LONG_PTR OperationWindow::HandleEvent (

    HWND hWnd, 
    UINT user_msg_id, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    return owner.ProcessInternalEvent(

        hWnd, 
        user_msg_id, 
        wParam, 
        lParam
    );
}

OperationWindow::OperationWindow (

    IN SnmpOperation &owner 

) : owner(owner)
{
}

OperationWindow ::~OperationWindow ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\reg.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: reg.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "message.h"
#include "dummy.h"
#include "reg.h"
#include "idmap.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "ssent.h"
#include "opreg.h"

#include "session.h"

RequestId MessageRegistry::next_request_id = 1 ;

RequestId MessageRegistry::GenerateRequestId(
             IN WaitingMessage &waiting_message)
{
    RequestId request_id = next_request_id++;

    if (next_request_id == ILLEGAL_REQUEST_ID)
        next_request_id++;

    mapping[request_id] = &waiting_message;

    return request_id;
}



// used by the event handler to notify the message registry
// of a message receipt
// it must receive the message and notify the concerned 
// waiting message of the event
void MessageRegistry::MessageArrivalNotification(IN SnmpPdu &snmp_pdu)
{
    // determine the concerned waiting message and pass it the SnmpPdu
    RequestId request_id ;

    session->m_EncodeDecode.GetRequestId(snmp_pdu,request_id);

    // if failed, return, as there is no use going any further
    if ( request_id == ILLEGAL_REQUEST_ID ) 
        return;

    WaitingMessage *waiting_message;
    BOOL found = mapping.Lookup(request_id, waiting_message);

    // if no such waiting message, return
    if ( !found )
        return;

    // check if still waiting for the SentFrameEvent on
    // this waiting message
    SessionFrameId session_frame_id = waiting_message->GetMessage()->GetSessionFrameId();

    // if not waiting for the sent frame event
    //      let the waiting message receive the reply
    // else buffer the snmp pdu
    if ( waiting_message->GetSentMessageProcessed() == TRUE )
        waiting_message->ReceiveReply(&snmp_pdu);
    else
        waiting_message->BufferReply(snmp_pdu);
}


// delete (request_id, waiting_message) pair
void MessageRegistry::RemoveMessage(IN RequestId request_id)
{
    if ( !mapping.RemoveKey(request_id) )
        throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);
}


MessageRegistry::~MessageRegistry(void)
{
    mapping.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\snmpcont.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\session.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: session.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "dummy.h"
#include "flow.h"
#include "reg.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "tsent.h"

#include "transp.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"
#include <winsock.h>
#include "trap.h"

SnmpSession::SnmpSession (
        IN SnmpTransport &transportProtocol,
        IN SnmpSecurity &security,
        IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
        IN const ULONG retryCount,
        IN const ULONG retryTimeout,
        IN const ULONG varbindsPerPdu,
        IN const ULONG flowControlWindow 
    )
{
    retry_count = retryCount;
    retry_timeout = retryTimeout;
    varbinds_per_pdu = varbindsPerPdu;
    flow_control_window = flowControlWindow;
}

#pragma warning (disable:4355)

SnmpImpSession::SnmpImpSession ( 
        IN SnmpTransport &transportProtocol,
        IN SnmpSecurity &security,
        IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
        IN const ULONG retryCount,
        IN const ULONG retryTimeout,
        IN const ULONG varbindsPerPdu,
        IN const ULONG flowControlWindow)
        : SnmpSession(transportProtocol, security, a_SnmpEncodeDecode,
                      RetryCount(retryCount),
                      RetryTimeout(retryTimeout),
                      VarbindsPerPdu(varbindsPerPdu),
                      WindowSize(flowControlWindow)),
          m_SessionWindow(*this),
          transport(transportProtocol), 
          security(security),
          m_EncodeDecode(a_SnmpEncodeDecode) ,
          flow_control(*this, SnmpImpSession :: WindowSize ( GetFlowControlWindow() ) ),
          message_registry(*this), 
          frame_registry(*this),
          timer(*this)
{
    is_valid = FALSE;

    if ( !transport() || !security() || !m_SessionWindow() )
        return;

    received_session_frame_id = ILLEGAL_SESSION_FRAME_ID;
    destroy_self = FALSE;

    strobe_count = 1 ;

    // generate timer_event_id and register with the timer
    timer_event_id = timer.SetTimerEvent(MIN(100,retry_timeout/10));

    is_valid = TRUE;
}

#pragma warning (default:4355)

ULONG SnmpImpSession::RetryCount(IN const ULONG retry_count) 
{
    return retry_count ;
}


ULONG SnmpImpSession::RetryTimeout(IN const ULONG retry_timeout) 
{
    return ( (retry_timeout==0)? 
             DEF_RETRY_TIMEOUT: retry_timeout);
}


ULONG SnmpImpSession::VarbindsPerPdu(IN const ULONG varbinds_per_pdu) 
{
    return ( (varbinds_per_pdu==0)? 
             DEF_VARBINDS_PER_PDU: varbinds_per_pdu);
}


ULONG SnmpImpSession::WindowSize(IN const ULONG window_size) 
{
    return ( (window_size==0)? DEF_WINDOW_SIZE: window_size);
}


void SnmpImpSession::RegisterOperation(IN SnmpOperation &operation)
{
    CriticalSectionLock access_lock(session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        return;

    operation_registry.Register(operation);

    // access_lock.UnLock();   The lock may be released at this point
}

// updates the number of operations currently registered
// when the count goes to 0 and the destroy_self flag is set,
// it posts the WinSnmpSession :: g_DeleteSessionEvent message.
void SnmpImpSession::DeregisterOperation(IN SnmpOperation &operation)
{
    CriticalSectionLock access_lock(session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        return;

    operation_registry.Deregister(operation);

    if ( (destroy_self == TRUE) &&
         (operation_registry.GetNumRegistered() == 0) )
        m_SessionWindow.PostMessage(Window :: g_DeleteSessionEvent, 0, 0);

    // access_lock.UnLock();   The lock may be released at this point
}


// when the WinSnmpSession :: g_DeleteSessionEvent is received, the session deletes itself
// no locks are obtained since our assumption is that no other objects would be
// accessing the session at this time
void SnmpImpSession::HandleDeletionEvent()
{
    delete this;
}

// the session posts a message to destroy self if the number of registered
// sessions is 0. otherwise the session is flagged for the same action when
// the number of registered operations drops to 0.
BOOL SnmpImpSession::DestroySession()
{
    CriticalSectionLock access_lock(session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        return FALSE;

    if ( operation_registry.GetNumRegistered() == 0 )
    {
        m_SessionWindow.PostMessage(Window :: g_DeleteSessionEvent, 0, 0);
        return TRUE;
    }
    else
        destroy_self = TRUE;    // flag self for destruction

    access_lock.UnLock();

    return FALSE;
}

    
void SnmpImpSession::SessionSendFrame
(  
    IN SnmpOperation &operation,
    OUT SessionFrameId &session_frame_id,
    IN SnmpPdu &snmpPdu
)
{
    SessionSendFrame(operation, session_frame_id, snmpPdu, security);
}


void SnmpImpSession::SessionSendFrame
(  
    IN SnmpOperation &operation,
    OUT SessionFrameId &session_frame_id,
    IN SnmpPdu &snmpPdu,
    IN SnmpSecurity &snmp_security
)
{
    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return;

        if ( !is_valid )
            return;

        session_frame_id = frame_registry.GenerateSessionFrameId();

        SnmpErrorReport error_report = snmp_security.Secure ( 

            m_EncodeDecode,
            snmpPdu
        );

        // if already errored, register the error report in the sent state
        if ( error_report.GetError() != Snmp_Success )
        {   
            delete & snmpPdu;

			PostSentFrameEvent(

				session_frame_id, 
				operation, 
				SnmpErrorReport(Snmp_Error, Snmp_Local_Error)
			) ;

            return;
        }
		
        Message *message = new Message(session_frame_id, snmpPdu, operation);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"new message(id%d,op%d)\n",session_frame_id, &(message->GetOperation())
    ) ;
)
        flow_control.SendMessage(*message);
    }
	catch ( Heap_Exception e_He )
	{
		PostSentFrameEvent(

			session_frame_id, 
			operation, 
			SnmpErrorReport(Snmp_Error, Snmp_Local_Error)
		);

        return;
	}
    catch(GeneralException exception)
	{
		PostSentFrameEvent(

			session_frame_id, 
			operation, 
			SnmpErrorReport(exception.GetError(), exception.GetStatus())
		);

        return;
    }
}

void SnmpImpSession::PostSentFrameEvent (

	SessionFrameId session_frame_id ,
	SnmpOperation &operation, 
	SnmpErrorReport errorReport
)
{
	try 
	{
		store.Register ( 

			session_frame_id, 
			operation, 
			errorReport
		) ;
	}
	catch ( Heap_Exception e_He )
	{
	}
	catch ( GeneralException exception )
	{
	}

	m_SessionWindow.PostMessage ( Window :: g_SentFrameEvent, session_frame_id, (LPARAM)&operation);
}

void SnmpImpSession::HandleSentFrame (

    IN SessionFrameId  session_frame_id ,
	IN SnmpOperation *operation
)
{
    SnmpOperation *tmp_operation;
    SnmpErrorReport error_report = store.Remove(session_frame_id, tmp_operation);

	if ( tmp_operation == NULL )
	{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"HandleSentFrame could not locate sent message error in store(id%d,op%lx)\n",session_frame_id, operation
    ) ;
)
	}

    // ignore it if no corresponding operation
    if ( operation == NULL )
	{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"HandleSentFrame received null operation(id%d)\n",session_frame_id
    ) ;
)
        return;
	}

    operation->SentFrame(session_frame_id, error_report);
}

SnmpOperation *SnmpImpSession::GetOperation(IN const SessionFrameId session_frame_id)
{
    WaitingMessage *waiting_message = frame_registry.GetWaitingMessage(session_frame_id);

    if (waiting_message == NULL)
        return NULL;

    return &(waiting_message->GetMessage()->GetOperation());
}

void SnmpImpSession::SessionSentFrame 
(
    IN TransportFrameId  transport_frame_id,  
    IN SnmpErrorReport &errorReport
)
{
    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return;

        // obtain and remove the session frame id
        // obtain corresponding operation and inform it
        SessionFrameId session_frame_id = id_mapping.DisassociateTransportFrameId(transport_frame_id);

        // determine corresponding waiting message
        WaitingMessage *waiting_message = frame_registry.GetWaitingMessage(session_frame_id);

        // ignore if no such waiting message
        if (waiting_message == NULL)
            return;

        // if the error report shows an error during transport,
        // wrap up the waiting message and return
        if ( errorReport.GetError() != Snmp_Success )
        {
            waiting_message->WrapUp(SnmpErrorReport(errorReport));
            return;
        }

        // inform the waiting message of the sent message processing event
        waiting_message->SetSentMessageProcessed();

        // determine the corresponding operation 
        SnmpOperation *operation = &(waiting_message->GetMessage()->GetOperation());

        access_lock.UnLock();

        // call to the operation is made outside the lock
        operation->SentFrame(session_frame_id, errorReport);

        // obtain the lock again to process the corresponding buffered
        // waiting message, if any
        if ( !access_lock.GetLock(INFINITE) )
            return;

        // if no such buffered snmp pdu, return
        if ( !waiting_message->ReplyBuffered() )
            return;

        SnmpPdu *snmp_pdu = waiting_message->GetBufferedReply();

        // set the state information for processing the buffered message
        received_session_frame_id = ILLEGAL_SESSION_FRAME_ID;

        // proceed with processing the snmp_pdu
        waiting_message->ReceiveReply(snmp_pdu);

        // save the information needed to notify the targeted operation
        // before releasing the lock
        SessionFrameId target_session_frame_id = received_session_frame_id;
        SnmpOperation *target_operation = operation_to_notify;

        access_lock.UnLock();

        // inform the target operation of the frame receipt
        if ( target_session_frame_id != ILLEGAL_SESSION_FRAME_ID )
        {
            target_operation->ReceiveFrame(target_session_frame_id, *snmp_pdu, 
                                           SnmpErrorReport(Snmp_Success, Snmp_No_Error));
        }

        delete & snmp_pdu->GetVarbindList () ; 
        delete snmp_pdu;
    }
	catch ( Heap_Exception e_He )
	{
        return;
	}
    catch(GeneralException exception)
    {
        return;
    }
}
    
void SnmpImpSession::SessionReceiveFrame (

    IN SnmpPdu &snmpPdu,
    IN SnmpErrorReport &errorReport
)
{
    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return;

        // set the state information for processing the buffered message
        received_session_frame_id = ILLEGAL_SESSION_FRAME_ID;

        // proceed with processing the snmp_pdu
        message_registry.MessageArrivalNotification(snmpPdu);

        // save the information needed to notify the targeted operation
        // before releasing the lock
        SessionFrameId target_session_frame_id = received_session_frame_id;
        SnmpOperation *target_operation = operation_to_notify;

        access_lock.UnLock();

        // inform the target operation of the frame receipt
        if ( target_session_frame_id != ILLEGAL_SESSION_FRAME_ID )
            target_operation->ReceiveFrame(target_session_frame_id, snmpPdu, 
                                           errorReport);
    }
	catch ( Heap_Exception e_He )
	{
		return ;
	}
    catch(GeneralException exception)
    {
        return;
    }
}

void SnmpImpSession::NotifyOperation (

    IN const SessionFrameId session_frame_id,
    IN const SnmpPdu &snmp_pdu,
    IN const SnmpErrorReport &error_report
)
{
    // determine the corresponding operation and 
    // call its SessionReceiveFrame
    SnmpOperation *operation = GetOperation(session_frame_id);

    if ( error_report.GetError() != Snmp_Success )
    {
		PostSentFrameEvent(

			session_frame_id, 
			*operation, 
			error_report
		) ;
    }
    else
    {
        received_session_frame_id = session_frame_id;
        operation_to_notify = operation;
    }
}


SnmpErrorReport SnmpImpSession::SessionCancelFrame ( 

    IN const SessionFrameId session_frame_id 
)
{
    if ( !is_valid )
        return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);

    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);

        frame_registry.CancelFrameNotification(session_frame_id);

        access_lock.UnLock();
    }
	catch ( Heap_Exception e_He )
	{
		return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);
	}
    catch(GeneralException exception)
    {
        return exception;
    }

    // if we have reached this place, we must have succeeded
    return SnmpErrorReport(Snmp_Success, Snmp_No_Error);
}


SnmpImpSession::~SnmpImpSession(void)
{
    // if required, cancels timer event
    if ( timer_event_id != ILLEGAL_TIMER_EVENT_ID )
    {
        timer.CancelTimer(timer_event_id);
        timer_event_id = ILLEGAL_TIMER_EVENT_ID;
    }
}



void * SnmpV1OverIp::operator()(void) const
{
    if ( (SnmpUdpIpImp::operator()() == NULL) ||
        (SnmpV1EncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}

void * SnmpV1OverIpx::operator()(void) const
{
    if ( (SnmpIpxImp::operator()() == NULL) ||
        (SnmpV1EncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}

void * SnmpV2COverIp::operator()(void) const
{
    if ( (SnmpUdpIpImp::operator()() == NULL) ||
        (SnmpV2CEncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}

void * SnmpV2COverIpx::operator()(void) const
{
    if ( (SnmpIpxImp::operator()() == NULL) ||
        (SnmpV2CEncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\snmpauto.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <typeinfo.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey <SnmpObjectIdentifierType&> (SnmpObjectIdentifierType &key)
#else
UINT HashKey (SnmpObjectIdentifierType &key)
#endif
{
    SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) key.GetValueEncoding () ;
    UCHAR *value = ( UCHAR * ) objectIdentifier->GetValue () ;
    ULONG length = objectIdentifier->GetValueLength () * sizeof ( ULONG ) ;

#if 1
    ULONG t_Length = length >> 2 ;
    value += t_Length ;
    length = length - t_Length ;
#endif

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;
#if 0
        for (ULONG i = length >> 1; i--;)
        {
            even += *value++;
            odd += *value++;
        }
        if (length & 1)
        {
            even += *value;
        }
#else
        for (ULONG i = length >> 2; i--;)
        {
            even += *value++;
            even += *value++;
            even += *value++;
            odd += *value++;
        }
        if (length & 1)
        {
            even += *value;
        }
#endif
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

    return hash ;
}

#if _MSC_VER >= 1100
template<> BOOL AFXAPI CompareElements <SnmpObjectIdentifierType , SnmpObjectIdentifierType >( 

     const SnmpObjectIdentifierType* pElement1, 
     const SnmpObjectIdentifierType* pElement2 
)
#else
BOOL CompareElements ( 

     SnmpObjectIdentifierType* pElement1, 
     SnmpObjectIdentifierType* pElement2 
)

#endif
{
    return *( ( SnmpObjectIdentifier * ) pElement1->GetValueEncoding () ) == *( ( SnmpObjectIdentifier * )pElement2->GetValueEncoding () ) ;
}

VarBindObject :: VarBindObject ( 

    const SnmpObjectIdentifier &replyArg , 
    const SnmpValue &valueArg 

) : value ( NULL ) , 
    reply ( replyArg ) 
{
    value = valueArg.Copy () ;
}

VarBindObject :: ~VarBindObject ()
{
    delete value ;
}

SnmpObjectIdentifier &VarBindObject :: GetObjectIdentifier () 
{
    return reply ;
}

SnmpValue &VarBindObject :: GetValue () 
{
    return *value ;
}


VarBindQueue :: VarBindQueue ()
{
}

VarBindQueue :: ~VarBindQueue ()
{
    POSITION position = queue.GetHeadPosition () ;
    while ( position )
    {
        VarBindObject *varBindObject = queue.GetNext ( position ) ;
        delete varBindObject ;
    }

    queue.RemoveAll () ;
}

void VarBindQueue :: Add ( VarBindObject *varBindObject )
{
    queue.AddTail ( varBindObject ) ;
}

VarBindObject *VarBindQueue :: Get () 
{
    return queue.IsEmpty () ? NULL : queue.GetHead ()  ;
}

VarBindObject *VarBindQueue :: Delete () 
{
    VarBindObject *object = NULL ;

    if ( ! queue.IsEmpty () )
    {
        object = queue.GetHead ()  ;
        queue.RemoveHead () ;
    }
    
    return object ;
}

VarBindObjectRequest :: VarBindObjectRequest ( 

    const SnmpObjectIdentifierType &varBindArg 

) : varBind ( varBindArg ) , requested ( varBindArg ) , repeatRequest ( TRUE ) 
{
}

VarBindObjectRequest :: VarBindObjectRequest ( 

    const SnmpObjectIdentifierType &varBindArg ,
    const SnmpObjectIdentifierType &requestedVarBindArg 

) : varBind ( varBindArg ) , requested ( requestedVarBindArg ) , repeatRequest ( TRUE ) 
{
}

VarBindObjectRequest :: VarBindObjectRequest () : repeatRequest ( TRUE )
{
}

VarBindObjectRequest :: ~VarBindObjectRequest () 
{
}

const SnmpObjectIdentifierType &VarBindObjectRequest :: GetRequested () const 
{
    return requested ;
}

const SnmpObjectIdentifierType &VarBindObjectRequest :: GetVarBind () const 
{
    return varBind ;
}

void VarBindObjectRequest :: SetRequested ( const SnmpObjectIdentifierType &requestedArg ) 
{
    requested = requestedArg ;
}

void VarBindObjectRequest :: SetVarBind ( const SnmpObjectIdentifierType &varBindArg ) 
{
    varBind = varBindArg ;
}

void VarBindObjectRequest :: AddQueuedObject ( VarBindObject *object ) 
{
    varBindResponseQueue.Add ( object ) ;
}

VarBindObject *VarBindObjectRequest :: GetQueuedObject () 
{
    return varBindResponseQueue.Get () ;
}

VarBindObject *VarBindObjectRequest :: DeleteQueueudObject () 
{
    return varBindResponseQueue.Delete () ;
}

GetNextOperation :: GetNextOperation (

    IN SnmpSession &session ,
    SnmpAutoRetrieveOperation &autoRetrieveOperation 

) : SnmpGetNextOperation ( session ) , 
    operation ( NULL ) ,
    minimumInstance ( NULL , 0 ) ,
    cancelledRequest ( FALSE ) ,
    m_RequestContainerLength ( 0 ) ,
    m_RequestContainer ( NULL ) ,
    m_RequestIndexContainer ( NULL )
{
    operation = &autoRetrieveOperation ;
}

GetNextOperation :: ~GetNextOperation ()
{
    Cleanup () ;

    delete [] m_RequestContainer ;
    delete [] m_RequestIndexContainer ;
    delete operation ;
}

void GetNextOperation :: Cleanup ()
{
    if ( m_RequestContainer )
    {
        for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
        {
            VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
            m_RequestContainer [ t_Index ] = NULL ; 
            delete varBindObjectRequest ;
        }
    }
}
void GetNextOperation :: SendRequest ( 

    SnmpVarBindList &varBindList 
)
{
    cancelledRequest = FALSE ;

    ULONG t_Count = varBindList.GetLength () ;

    m_RequestContainerLength = t_Count ;

    m_RequestContainer = new VarBindObjectRequest * [ t_Count ] ;
    m_RequestIndexContainer = new ULONG [ t_Count ] ;

	ZeroMemory ( m_RequestContainer , sizeof ( VarBindObjectRequest * ) * t_Count ) ;
	ZeroMemory ( m_RequestIndexContainer , sizeof ( ULONG ) * t_Count ) ;

	ULONG t_Index = 0 ; 
    varBindList.Reset () ;
    while ( varBindList.Next () )
    {
        const SnmpVarBind *varBind = varBindList.Get () ;
        SnmpObjectIdentifierType requestObject ( varBind->GetInstance () ) ;
        VarBindObjectRequest *request = new VarBindObjectRequest ( requestObject ) ;
        m_RequestContainer  [ t_Index ] = request ;

        t_Index ++ ;
    }

    Send () ;
}

void GetNextOperation :: SendRequest ( 

    SnmpVarBindList &varBindList , 
    SnmpVarBindList &startVarBindList 
)
{
    cancelledRequest = FALSE ;

    ULONG t_Count = varBindList.GetLength () ;

    m_RequestContainerLength = t_Count ;

    m_RequestContainer = new VarBindObjectRequest * [ t_Count ] ;
    m_RequestIndexContainer = new ULONG [ t_Count ] ;

    ULONG t_Index = 0 ;
    varBindList.Reset () ;
    startVarBindList.Reset () ;
    while ( startVarBindList.Next () && varBindList.Next () )
    {
        const SnmpVarBind *varBind = varBindList.Get () ;
        const SnmpVarBind *startVarBind = startVarBindList.Get () ;
        SnmpObjectIdentifierType requestObject ( varBind->GetInstance () ) ;
        SnmpObjectIdentifierType startRequestObject ( startVarBind->GetInstance () ) ;
        VarBindObjectRequest *request = new VarBindObjectRequest ( requestObject , startRequestObject ) ;
        m_RequestContainer  [ t_Index ] = request ;

        t_Index ++ ;
    }

    Send () ;
}

void GetNextOperation :: DestroyOperation ()
{
    SnmpGetNextOperation :: DestroyOperation () ;
}

void GetNextOperation :: CancelRequest ()
{
    cancelledRequest = TRUE ;
    SnmpGetNextOperation :: CancelRequest () ;
}

void GetNextOperation :: Send ()
{
    BOOL t_Count = 0 ;
    SnmpVarBindList sendVarBindList ;
    for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
    {
        SnmpObjectIdentifierType objectIdentifierType ;
        VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;

        if ( varBindObjectRequest->GetRepeatRequest () )
        {
            SnmpNull snmpNull ;
            SnmpVarBind varBind ( 

                * ( SnmpObjectIdentifier * ) varBindObjectRequest->GetRequested ().GetValueEncoding () ,
                snmpNull 
            ) ;

            sendVarBindList.Add ( varBind ) ;

            m_RequestIndexContainer [ t_Count ] = t_Index ;
            t_Count ++ ;
        }
    }

    SnmpGetNextOperation :: SendRequest ( sendVarBindList ) ;
}

void GetNextOperation :: SentFrame (

    IN const SessionFrameId session_frame_id ,
    const SnmpErrorReport &errorReport 
) 
{
    switch ( errorReport.GetError () )
    {
        case Snmp_Success:
        {
        }
        break ;

        default:
        {
        }
        break ;
    }

    operation->SentFrame ( session_frame_id , errorReport ) ;
    SnmpGetNextOperation :: SentFrame ( session_frame_id , errorReport ) ;
}

void GetNextOperation :: ReceiveResponse () 
{
    BOOL receiveComplete = TRUE ;

    for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
    {
        VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
        if ( varBindObjectRequest->GetRepeatRequest () )
        {
            receiveComplete = FALSE ;
        }
    }

    if ( ! cancelledRequest )
    {
// Check to see if we have finished

        if ( ! receiveComplete )
        {
// Request next response

            Send () ;
        }

// Process received information

        while ( ProcessRow () ) ;
    }

    if ( receiveComplete )
    {
// We've finished

        operation->ReceiveResponse () ;

// Clear all resources

        Cleanup () ;
    }
}

BOOL GetNextOperation :: ProcessRow ()
{
// Process Row information


    BOOL initialised = FALSE ;
    BOOL objectHasNoValueAndIsRepeating = FALSE ;
    SnmpObjectIdentifier objectIdentifier ( NULL , 0 ) ;
    SnmpObjectIdentifier suffix ( NULL , 0 ) ;

// Determine minimum instance

    for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
    {
        VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
        VarBindObject *queuedObject = varBindObjectRequest->GetQueuedObject () ;
        if ( queuedObject )
        {
// Get row information associated with table property, i.e. instance of initial varbind requested.

            SnmpObjectIdentifierType varBindType = varBindObjectRequest->GetVarBind () ;
            SnmpObjectIdentifier *varBind = ( SnmpObjectIdentifier * ) varBindType.GetValueEncoding () ;
            if(varBind)
            {
                BOOL t_Status = queuedObject->GetObjectIdentifier ().Suffix ( varBind->GetValueLength () , suffix ) ;
                if ( t_Status )
                {
                    if ( initialised )
                    {
                        if ( suffix < objectIdentifier ) 
                        {
// Least instance so far

                            objectIdentifier = suffix ;
                        }
                        else
                        {
// Greater Than
                        }
                    }
                    else
                    {

// objectIdentifier hasn't been set to a legal instance yet.

                        objectIdentifier = suffix ;
                        initialised = TRUE ;
                    }       
                }
                else
                {
// No more rows as yet
                }
            }
        }
        else
        {
            if ( varBindObjectRequest->GetRepeatRequest () )
            {
                objectHasNoValueAndIsRepeating = TRUE ;
            }
        }
    }

    if ( initialised && ( ! objectHasNoValueAndIsRepeating ) )
    {
        minimumInstance = objectIdentifier ;

// Process all columns which contain row of least minimum

        for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
        {
            VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
            VarBindObject *queuedObject = varBindObjectRequest->GetQueuedObject () ;
            if ( queuedObject )
            {
                SnmpObjectIdentifierType varBindType = varBindObjectRequest->GetVarBind () ;
                SnmpObjectIdentifier *varBind = ( SnmpObjectIdentifier * ) varBindType.GetValueEncoding () ;

                if ( varBind && queuedObject->GetObjectIdentifier ().Suffix ( varBind->GetValueLength () , suffix ) )
                {
                    if ( suffix == minimumInstance ) 
                    {
// Row to be processed

                        SnmpNull snmpNull ;
                        SnmpErrorReport errorReport ( Snmp_Success , Snmp_No_Error )  ;
                        SnmpVarBind requestVarBind ( *varBind , snmpNull ) ;
                        SnmpVarBind replyVarBind ( minimumInstance , queuedObject->GetValue () ) ;
                
                        operation->ReceiveRowVarBindResponse ( t_Index + 1 , requestVarBind , replyVarBind , errorReport ) ;

// Check CancelRequest hasn't been called in callback

                        if ( cancelledRequest )
                        {
                            return FALSE ;
                        }

// Remove row 
                        VarBindObject *queuedObject = varBindObjectRequest->DeleteQueueudObject () ;
                        delete queuedObject ;
                    }
                    else
                    {
// Row is lexicographically greater than process row
                    }
                }
                else
                {
// Problem Here
                }
            }
        }

// Forward call to AutoRetrieveOperation
    
        operation->ReceiveRowResponse () ;
    }
    else
    {
// Zero rows to process
    }

    return initialised && ( ! objectHasNoValueAndIsRepeating ) ;
}

void GetNextOperation :: ReceiveVarBindResponse (

    IN const ULONG &var_bind_index,
    IN const SnmpVarBind &requestVarBind ,
    IN const SnmpVarBind &replyVarBind ,
    IN const SnmpErrorReport &error
) 
{
    ULONG t_Index = m_RequestIndexContainer [ var_bind_index - 1 ] ;
    VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
/*
 * check for v2c errored responses
 */

    if ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpEndOfMibView ) ) 
    {
// Stop further requests for this column

        varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
    }
    else
    {
    // Locate request object

// Check we haven't gone backwards lexicographically, which would result in an infinitely repeating request.

        if ( replyVarBind.GetInstance () > requestVarBind.GetInstance () )
        {
// Check we haven't reached end of table

            SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier *) varBindObjectRequest->GetVarBind ().GetValueEncoding () ;
            if ( objectIdentifier && replyVarBind.GetInstance().Equivalent ( *objectIdentifier , objectIdentifier->GetValueLength () ) )  
            {
// Add row information to column of table

                SnmpObjectIdentifier snmpObjectIdentifier ( 0 , NULL ) ;
                SnmpObjectIdentifier suffix ( 0 , NULL ) ;
                SnmpNull snmpNull ;

                BOOL t_Status = replyVarBind.GetInstance().Suffix ( objectIdentifier->GetValueLength () , suffix ) ;
                if ( t_Status )
                {
                    SnmpVarBind sendVarBind ( snmpObjectIdentifier , snmpNull ) ;
                    SnmpVarBind adjustedReplyVarBind ( suffix , replyVarBind.GetValue () ) ;

                    LONG t_Option = operation->EvaluateNextRequest (

                        var_bind_index,
                        requestVarBind ,
                        adjustedReplyVarBind ,
                        sendVarBind
                    ) ;

                    if ( t_Option == 0 )
                    {
                        VarBindObject *varBindObject = new VarBindObject ( replyVarBind.GetInstance () , replyVarBind.GetValue () ) ;
                        varBindObjectRequest->AddQueuedObject ( varBindObject ) ;

    // Update map to identify request next time around

                        SnmpObjectIdentifierType replyObject ( replyVarBind.GetInstance () ) ;
                        varBindObjectRequest->SetRequested ( replyObject ) ;
                    }
                    else if ( t_Option > 0 )
                    {
                        VarBindObject *varBindObject = new VarBindObject ( replyVarBind.GetInstance () , replyVarBind.GetValue () ) ;
                        varBindObjectRequest->AddQueuedObject ( varBindObject ) ;

    // Update map to identify request next time around

                        SnmpObjectIdentifierType replyObject ( *objectIdentifier + sendVarBind.GetInstance () ) ;
                        varBindObjectRequest->SetRequested ( replyObject ) ;

                    }
                    else 
                    {
                        VarBindObject *varBindObject = new VarBindObject ( replyVarBind.GetInstance () , replyVarBind.GetValue () ) ;
                        varBindObjectRequest->AddQueuedObject ( varBindObject ) ;

                        varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
                    }
                }
                else 
                {
                    varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
                }
            }
            else
            {
// instance received is not row of column, i.e End Of Table

                varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
            }
        }
        else
        {
// instance requested is greater than instance replied

            varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
        }
    }

    operation->ReceiveVarBindResponse ( var_bind_index,requestVarBind , replyVarBind , error ) ;
}

void GetNextOperation :: ReceiveErroredVarBindResponse(

    IN const ULONG &var_bind_index,
    IN const SnmpVarBind &requestVarBind  ,
    IN const SnmpErrorReport &error
) 
{
    ULONG t_Index = m_RequestIndexContainer [ var_bind_index - 1 ] ;
    VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;

    switch ( error.GetError () )
    {
        case Snmp_Success:
        {
/* 
 * Can't happen
 */
        }
        break ;

        default:
        {
// Stop further requests for this column

            varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
        }
        break ;
    }

    operation->ReceiveErroredVarBindResponse ( var_bind_index , requestVarBind , error ) ;
}

void GetNextOperation :: FrameTooBig () 
{
    operation->FrameTooBig () ;
}

void GetNextOperation :: FrameOverRun () 
{
    operation->FrameTooBig () ;
}

SnmpAutoRetrieveOperation :: SnmpAutoRetrieveOperation (IN SnmpSession &session) 
{
    operation = new GetNextOperation ( session , *this ) ;
}

SnmpAutoRetrieveOperation :: ~SnmpAutoRetrieveOperation ()
{
}

void SnmpAutoRetrieveOperation :: DestroyOperation ()
{
    operation->DestroyOperation () ;
}

void SnmpAutoRetrieveOperation :: CancelRequest () 
{
    operation->CancelRequest () ;
}

void SnmpAutoRetrieveOperation :: SendRequest ( SnmpVarBindList &varBindList )
{
    operation->SendRequest ( varBindList ) ;
}

void SnmpAutoRetrieveOperation :: SendRequest ( SnmpVarBindList &varBindList , SnmpVarBindList &startVarBindList )
{
    operation->SendRequest ( varBindList , startVarBindList ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\sec.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: sec.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "value.h"

const char *SnmpCommunityBasedSecurity::GetCommunityName() const
{
    return community_name;
}

void SnmpCommunityBasedSecurity::Initialize()
{
    is_valid = TRUE;
}


SnmpCommunityBasedSecurity::SnmpCommunityBasedSecurity(IN const SnmpCommunityBasedSecurity &security) : community_name ( NULL ) 
{
   const char *new_community_name = security.GetCommunityName();
   community_name = new char[strlen(new_community_name)+1];
   strcpy(community_name, new_community_name);

   Initialize();
}


SnmpCommunityBasedSecurity::SnmpCommunityBasedSecurity(IN const char *communityName) : community_name ( NULL) 
{
   community_name = new char[strlen(communityName)+1];
   strcpy(community_name, communityName);

   Initialize();
}

SnmpCommunityBasedSecurity::SnmpCommunityBasedSecurity(IN const SnmpOctetString &octetString) : community_name ( NULL ) 
{
    int length = octetString.GetValueLength();
    community_name = new char[length+1];

    strncpy(community_name, (char *)octetString.GetValue(), length);
    community_name[length] = EOS;

    Initialize();
}


SnmpCommunityBasedSecurity::~SnmpCommunityBasedSecurity()
{
    delete [] community_name;
}

SnmpErrorReport SnmpCommunityBasedSecurity::Secure (
                        
    IN SnmpEncodeDecode &a_SnmpEncodeDecode,
    IN OUT SnmpPdu &snmpPdu
) 
{
    SnmpCommunityBasedSecurity *t_Community = (SnmpCommunityBasedSecurity *)(this->Copy());
    if ( a_SnmpEncodeDecode.SetCommunityName (snmpPdu, *t_Community) == FALSE )
        return SnmpErrorReport(Snmp_Transport, Snmp_Local_Error);
    else
        return SnmpErrorReport(Snmp_Success, Snmp_No_Error);
}


SnmpSecurity *SnmpCommunityBasedSecurity::Copy() const
{
    return new SnmpCommunityBasedSecurity(community_name);
}

void SnmpCommunityBasedSecurity::SetCommunityName ( IN const SnmpOctetString &a_OctetString )
{
    delete [] community_name ;
    community_name = NULL;
    community_name = new char [ a_OctetString.GetValueLength () + 1 ] ;
    strncpy ( community_name , ( char * ) a_OctetString.GetValue () , a_OctetString.GetValueLength () ) ;
    community_name [ a_OctetString.GetValueLength () ] = 0 ;
}

void SnmpCommunityBasedSecurity:: SetCommunityName ( IN const char *a_CommunityName )
{
    delete [] community_name ;
    community_name = NULL;
    community_name = new char [ strlen ( a_CommunityName ) + 1 ] ;
    strcpy ( community_name , a_CommunityName ) ;
}

void SnmpCommunityBasedSecurity:: GetCommunityName ( SnmpOctetString &a_SnmpOctetString ) const 
{
    a_SnmpOctetString.SetValue ( ( UCHAR * ) community_name , strlen ( community_name ) ) ;
}

SnmpCommunityBasedSecurity &SnmpCommunityBasedSecurity :: operator=(IN const SnmpCommunityBasedSecurity &to_copy) 
{
    delete [] community_name ;
    community_name = NULL;
    community_name = new char [ strlen ( to_copy.community_name ) + 1 ] ;
    strcpy ( community_name , to_copy.community_name ) ;
    return *this ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\ssent.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: ssent.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "ssent.h"

void SessionSentStateStore::Register(IN SessionFrameId id, 
                                      IN SnmpOperation &operation,
                                      IN const SnmpErrorReport &error_report)
{
    store[id] = new ErrorInfo(operation, error_report);
}


SnmpErrorReport SessionSentStateStore::Remove(IN SessionFrameId id, OUT SnmpOperation *&operation) 
{
    ErrorInfo *error_info;

    BOOL found = store.Lookup(id, error_info);

    if ( !found )
    {
        operation = NULL;
        return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);
    }

    store.RemoveKey(id);

    SnmpErrorReport to_return(error_info->GetErrorReport());
    operation = error_info->GetOperation();

    delete error_info;

    return to_return;
}


void SessionSentStateStore::Remove(IN SessionFrameId id)
{
    SnmpOperation *operation;

    Remove(id, operation);
}

SessionSentStateStore::~SessionSentStateStore(void)
{
    // get the first position
    POSITION current = store.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        SessionFrameId id;
        ErrorInfo *error_info;

        // get the next pair
        store.GetNextAssoc(current, id, error_info);

        // delete the ptr
        delete error_info;
    }

    // remove all the keys
    store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\startup.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <provexpt.h>

#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <winsock.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "common.h"
#include "startup.h"
#include "sync.h"
#include "dummy.h"
#include "flow.h"
#include "reg.h"
#include "frame.h"
#include "timer.h"
#include "message.h"

#include "tsent.h"

#include "transp.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"
#include <winsock.h>
#include "trap.h"

CRITICAL_SECTION s_CriticalSection ;

LONG SnmpClassLibrary :: s_ReferenceCount = 0 ;

BOOL SnmpClassLibrary :: Startup ()
{
    EnterCriticalSection ( & s_CriticalSection ) ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClassLibrary :: Startup, s_ReferenceCount = %lx\n" , s_ReferenceCount
    ) ;
)

    BOOL status = TRUE ;

    s_ReferenceCount ++ ;

    if ( s_ReferenceCount == 1 )
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Creating library resources\n" 
    ) ;
)

        status = FALSE ;

        SnmpThreadObject :: Startup () ;
		try
		{
			SnmpDebugLog :: Startup () ;
		}
		catch ( ... )
		{
			// we do not want to left s_Reference count up
			SnmpThreadObject :: Closedown () ;
			s_ReferenceCount -- ;

			LeaveCriticalSection ( & s_CriticalSection ) ;

			throw;
		}

		try
		{
			Timer::g_timerThread = new SnmpClThreadObject ;
		}
		catch ( ... )
		{
			// we do not want to left s_Reference count up
            SnmpDebugLog :: Closedown () ;
			SnmpThreadObject :: Closedown () ;
			s_ReferenceCount -- ;

			LeaveCriticalSection ( & s_CriticalSection ) ;

			throw;
		}

        try
        {
			Timer::g_timerThread->BeginThread () ;
            Timer::g_timerThread->WaitForStartup () ;

            WORD wVersionRequested;  
            WSADATA wsaData; 

            wVersionRequested = MAKEWORD(1, 1); 
            status = ( WSAStartup ( wVersionRequested , &wsaData ) == 0 ) ;
            if ( status )
            {
                BOOL WindowStatus = FALSE ;
                BOOL TimerStatus = FALSE ;
                BOOL EncodeStatus = FALSE ;

                try
                {
                    WindowStatus = Window::InitializeStaticComponents () ;
                    TimerStatus = Timer::InitializeStaticComponents () ;
                    EncodeStatus = SnmpEncodeDecode :: InitializeStaticComponents () ;

                    status = WindowStatus & TimerStatus & EncodeStatus ;
                    if ( status )
                    {
                        SnmpTrapManager ::s_TrapMngrPtr = NULL ;

                        try
                        {
                            SnmpTrapManager ::s_TrapMngrPtr = new SnmpTrapManager();

                            status = SnmpTrapManager ::s_TrapMngrPtr ? TRUE : FALSE ;
                        }
                        catch ( ... )
                        {
                            delete SnmpTrapManager ::s_TrapMngrPtr ;
                            SnmpTrapManager ::s_TrapMngrPtr = NULL ;

                            status = FALSE ;
                        }
                    }
                }
                catch ( ... )
                {
                    status = FALSE ;
                }
                
                if ( ! status )
                {
                    if ( TimerStatus )
                    {
                        Timer::DestroyStaticComponents();
                    }

                    if ( WindowStatus )
                    {
                        Window::DestroyStaticComponents();
                    }

                    if ( EncodeStatus )
                    {
                        SnmpEncodeDecode :: DestroyStaticComponents() ;
                    }

                    WSACleanup () ;
                }
            }
		}
        catch ( ... )
        {
            status = FALSE ;
        }

        if ( ! status )
        {
            Timer::g_timerThread->SignalThreadShutdown () ;
            Timer::g_timerThread = NULL ;
        }

        if ( ! status )
        {
            SnmpDebugLog :: Closedown () ;
            SnmpThreadObject :: Closedown () ;

            s_ReferenceCount -- ;
        }
    }

    LeaveCriticalSection ( & s_CriticalSection ) ;

    return status ;
}

void SnmpClassLibrary :: Closedown () 
{
    EnterCriticalSection ( & s_CriticalSection ) ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClassLibrary :: Closedown, s_ReferenceCount = %lx\n" , s_ReferenceCount
    ) ;
)

    if ( InterlockedDecrement ( & s_ReferenceCount ) <= 0 )
    {
        if ( Timer::g_timerThread )
        {
            Timer::g_timerThread->SignalThreadShutdown () ;
            Timer::g_timerThread = NULL ;
        }

        if ( SnmpTrapManager ::s_TrapMngrPtr )
        {
            delete SnmpTrapManager ::s_TrapMngrPtr ;
            SnmpTrapManager ::s_TrapMngrPtr = NULL;
        }

        SnmpDebugLog :: Closedown () ;
        SnmpThreadObject :: Closedown () ;

        Timer::DestroyStaticComponents();
        Window::DestroyStaticComponents();
        SnmpEncodeDecode :: DestroyStaticComponents() ;

        SnmpCleanup();

        WSACleanup () ;
    }

    LeaveCriticalSection ( & s_CriticalSection ) ;
}

HINSTANCE g_hInst = NULL ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

    HINSTANCE hInstance, 
    ULONG ulReason , 
    LPVOID pvReserved
)
{
    g_hInst=hInstance;
    BOOL status = TRUE ;
    SetStructuredExceptionHandler seh;

    try
    {
        if ( DLL_PROCESS_DETACH == ulReason )
        {
            DeleteCriticalSection ( & s_CriticalSection ) ;
        }
        else if ( DLL_PROCESS_ATTACH == ulReason )
        {
            InitializeCriticalSection ( & s_CriticalSection ) ;
			DisableThreadLibraryCalls(hInstance);			// 158024 
        }
        else if ( DLL_THREAD_DETACH == ulReason )
        {
        }
        else if ( DLL_THREAD_ATTACH == ulReason )
        {
        }
    }
    catch(Structured_Exception e_SE)
    {
        status = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        status = FALSE;
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\snmptype.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <typeinfo.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <winsock.h>
#include <strstrea.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>


#if _MSC_VER >= 1100
template <> UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key )
#else
UINT HashKey ( wchar_t *key )
#endif
{
    UCHAR *value = ( UCHAR * ) key ;
    ULONG length = wcslen ( key ) * sizeof ( wchar_t ) ;

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;

        for (ULONG i = length >> 1; i--;)
        {
            even += towlower (*value++) ;
            odd += towlower (*value++) ;
        }
        if (length & 1)
        {
            even += towlower (*value);
        }
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

    return hash ;
}

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 )
#else
BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 )
#endif
{
    return _wcsicmp ( *pElement1 , *pElement2 ) == 0 ;
}

CBString::CBString(int nSize) : m_pString ( NULL )
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString) : m_pString ( NULL )
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) 
    {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString )
{
    size_t textLength = mbstowcs ( NULL , dbcsString , 0  ) ;
    wchar_t *unicodeString = new wchar_t [ textLength + 1 ] ;
    textLength = mbstowcs ( unicodeString , dbcsString , textLength + 1 ) ;
    if ( textLength == -1 )
    {
        delete [] unicodeString ;
        unicodeString = NULL ;
    }

    return unicodeString ;
}

DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString )
{
    size_t textLength = wcstombs ( NULL , unicodeString , 0 ) ;
    char *dbcsString = new char [ textLength + 1 ] ;
    textLength = wcstombs ( dbcsString , unicodeString , textLength + 1 ) ;
    if ( textLength == -1 )
    {
        delete [] dbcsString ;
        dbcsString = NULL ;
    }

    return dbcsString ;
}

DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
    if ( string )
    {
        int textLength = wcslen ( string ) ;

        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
        wcscpy ( textBuffer , string ) ;

        return textBuffer ;
    }
    else
    {
        return NULL ;
    }
}

DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
    int prefixTextLength = 0 ;
    if ( prefix )
    {
        prefixTextLength = wcslen ( prefix ) ;
    }

    int suffixTextLength = 0 ;
    if ( suffix )
    {
        suffixTextLength = wcslen ( suffix ) ;
    }

    if ( prefix || suffix )
    {
        int textLength = prefixTextLength + suffixTextLength ;
        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

        if ( prefix )
        {
            wcscpy ( textBuffer , prefix ) ;
        }

        if ( suffix )
        {
            wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
        }

        return textBuffer ;
    }   
    else
        return NULL ;
}

SnmpLexicon :: SnmpLexicon () : position ( 0 ) , tokenStream ( NULL ) , token ( INVALID_ID )
{
    value.token = NULL ;
}

SnmpLexicon :: ~SnmpLexicon ()
{
    switch ( token ) 
    {
        case TOKEN_ID:
        {
            delete [] value.token ;
        }
        break ;
    
        default:
        {
        } ;
    }
}

void SnmpLexicon :: SetToken ( SnmpLexicon :: LexiconToken a_Token )
{
    token = a_Token ;
}

SnmpLexicon :: LexiconToken SnmpLexicon :: GetToken ()
{
    return token ;
}

SnmpLexiconValue *SnmpLexicon :: GetValue ()
{
    return &value ;
}

SnmpAnalyser :: SnmpAnalyser ( const wchar_t *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
    if ( tokenStream )
    {
        stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
        wcscpy ( stream , tokenStream ) ;
    }
}

SnmpAnalyser :: ~SnmpAnalyser () 
{
    delete [] stream ;
}

void SnmpAnalyser :: Set ( const wchar_t *tokenStream ) 
{
    status = 0 ;
    position = NULL ;

    delete [] stream ;
    stream = NULL ;
    stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
    wcscpy ( stream , tokenStream ) ;
}

void SnmpAnalyser :: PutBack ( const SnmpLexicon *token ) 
{
    position = token->position ;
}

SnmpAnalyser :: operator void * () 
{
    return status ? this : NULL ;
}

SnmpLexicon *SnmpAnalyser :: Get ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace ) 
{
    SnmpLexicon *lexicon = NULL ;

    if ( stream )
    {
        lexicon = GetToken ( unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) ;
    }
    else
    {
        lexicon = CreateLexicon () ;
        lexicon->position = position ;
        lexicon->token = SnmpLexicon :: EOF_ID ;
    }

    return lexicon ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000
#define WHITESPACE_START 6000
#define ACCEPT_STATE ANALYSER_ACCEPT_STATE
#define REJECT_STATE ANALYSER_REJECT_STATE 

SnmpLexicon *SnmpAnalyser :: GetToken ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace )  
{
    SnmpLexicon *lexicon = CreateLexicon () ;
    lexicon->position = position ;

    Initialise () ;

    ULONG state = 0 ;

/* 
 * Integer Definitions
 */

    BOOL negative = FALSE ;
    BOOL positive = FALSE ;

    ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
    ULONG positiveMagicPosDigit = 5 ;
    ULONG positiveDatum = 0 ;   

    LONG negativeMagicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
    ULONG negativeMagicNegDigit = 8 ;
    ULONG negativeMagicPosDigit = 7 ;
    LONG negativeDatum = 0 ;    

/*
 * Token Definitions
 */

    ULONG token_start = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = stream [ position ] ;
        if ( Analyse ( lexicon , state , token , stream , position , unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) )
        {
        }
        else
        {
            switch ( state )
            {
                case 0:
                {
                    if ( IsAlpha ( token ) )
                    {
                        state = TOKEN_START ;
                        token_start = position ;
                    }
                    else if ( SnmpAnalyser :: IsLeadingDecimal ( token ) )
                    {
                        state = DEC_INTEGER_START + 1  ;
                        negativeDatum = ( token - 48 ) ;
                    }
                    else if ( token == L'+' )
                    {
                        if ( unSignedIntegersOnly ) 
                        {
                            state = ACCEPT_STATE ;
                            lexicon->token = SnmpLexicon :: PLUS_ID ;
                        }
                        else
                        {
                            state = DEC_INTEGER_START ;
                        }
                    }
                    else if ( token == L'-' ) 
                    {
                        if ( unSignedIntegersOnly )
                        {
                            state = ACCEPT_STATE ;
                            lexicon->token = SnmpLexicon :: MINUS_ID ;
                        }
                        else
                        {
                            negative = TRUE ;
                            state = DEC_INTEGER_START ;
                        }
                    }
                    else if ( token == L'0' )
                    {
                        if ( ! leadingIntegerZeros ) 
                        {
                            state = 1 ;
                        }
                        else
                        {
                            negativeDatum = 0 ;
                            state = DEC_INTEGER_START + 1 ;
                        }
                    }
                    else if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                    {
                        if ( eatSpace )
                        {
                            state = 0 ;
                        }
                        else
                        {
                            lexicon->token = SnmpLexicon :: WHITESPACE_ID ;
                            state = WHITESPACE_START ;
                        }
                    }
                    else if ( token == L'(' )
                    {
                        lexicon->token = SnmpLexicon :: OPEN_PAREN_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L')' )
                    {
                        lexicon->token = SnmpLexicon :: CLOSE_PAREN_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L',' )
                    {
                        lexicon->token = SnmpLexicon :: COMMA_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L':' )
                    {
                        lexicon->token = SnmpLexicon :: COLON_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L'.' )
                    {
                        state = 2;
                    }
                    else if ( IsEof ( token ) )
                    {
                        lexicon->token = SnmpLexicon :: EOF_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
                break ;

                case 1:
                {
                    if ( token == L'x' || token == L'X' )
                    {
                        state = HEX_INTEGER_START ;             
                    }
                    else if ( SnmpAnalyser :: IsOctal ( token ) )
                    {
                        state = OCT_INTEGER_START ;
                        positiveDatum = ( token - 48 ) ;
                    }
                    else
                    {
                        if ( unSignedIntegersOnly )
                        {
                            lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                            lexicon->value.unsignedInteger = 0 ;
                        }
                        else
                        {
                            lexicon->token = SnmpLexicon :: SIGNED_INTEGER_ID ;
                            lexicon->value.signedInteger = 0 ;
                        }

                        state = ACCEPT_STATE ;
                        position -- ;
                    }
                }
                break ;

                case 2:
                {
                    if ( token == L'.' )
                    {
                        lexicon->token = SnmpLexicon :: DOTDOT_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else
                    {
                        lexicon->token = SnmpLexicon :: DOT_ID ;
                        position -- ;
                        state = ACCEPT_STATE  ;
                    }
                }
                break ;

                case TOKEN_START:
                {
                    if ( IsAlphaNumeric ( token ) ) 
                    {
                        state = TOKEN_START ;
                    }
                    else 
                    {
                        state = ACCEPT_STATE ;
                        lexicon->token = SnmpLexicon :: TOKEN_ID ;
                        lexicon->value.token = new wchar_t [ position - token_start + 1 ] ;
                        wcsncpy ( 

                            lexicon->value.token , 
                            & stream [ token_start ] , 
                            position - token_start 
                        ) ;

                        lexicon->value.token [ position - token_start ] = 0 ;

                        position -- ;
                    }
                }
                break ;

                case WHITESPACE_START:
                {
                    if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                    {
                        state = WHITESPACE_START ;
                    }
                    else
                    {
                        state = ACCEPT_STATE ;
                        position -- ;
                    }
                }
                break;

                case HEX_INTEGER_START:
                {
                    if ( SnmpAnalyser :: IsHex ( token ) )
                    {
                        positiveDatum = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                        state = HEX_INTEGER_START + 1 ;
                    }
                    else
                    {
                        state = REJECT_STATE ;
                    }
                }
                break ;

                case HEX_INTEGER_START+1:
                {
                    if ( SnmpAnalyser :: IsHex ( token ) )
                    {
                        state = HEX_INTEGER_START + 1 ;

                        if ( positiveDatum > positiveMagicMult )
                        {
                            state = REJECT_STATE ;
                        }
                        else if ( positiveDatum == positiveMagicMult ) 
                        {
                            if ( SnmpAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }

                        positiveDatum = ( positiveDatum << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    }
                    else
                    {
                        lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                        lexicon->value.unsignedInteger = positiveDatum ;
                        state = ACCEPT_STATE ;

                        position -- ;
                    }
                }
                break ;

                case OCT_INTEGER_START:
                {
                    if ( SnmpAnalyser :: IsOctal ( token ) )
                    {
                        state = OCT_INTEGER_START ;

                        if ( positiveDatum > positiveMagicMult )
                        {
                            state = REJECT_STATE ;
                        }
                        else if ( positiveDatum == positiveMagicMult ) 
                        {
                            if ( SnmpAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }

                        positiveDatum = ( positiveDatum << 3 ) + SnmpAnalyser :: OctWCharToDecInteger ( token ) ;
                    }
                    else
                    {
                        lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                        lexicon->value.unsignedInteger = positiveDatum ;
                        state = ACCEPT_STATE ;

                        position -- ;
                    }
                }
                break ;

                case DEC_INTEGER_START:
                {
                    if ( SnmpAnalyser :: IsDecimal ( token ) )
                    {
                        negativeDatum = ( token - 48 ) ;
                        state = DEC_INTEGER_START + 1 ;
                    }
                    else 
                    if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                    {
                        state = DEC_INTEGER_START ;
                    }
                    else state = REJECT_STATE ;
                }   
                break ;

                case DEC_INTEGER_START+1:
                {
                    if ( SnmpAnalyser :: IsDecimal ( token ) )
                    {   
                        state = DEC_INTEGER_START + 1 ;

                        if ( positive )
                        {
                            if ( positiveDatum > positiveMagicMult )
                            {
                                state = REJECT_STATE ;
                            }
                            else if ( positiveDatum == positiveMagicMult ) 
                            {
                                if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
                                {
                                    state = REJECT_STATE ;
                                }
                            }
                        }
                        else
                        {
                            if ( negativeDatum > negativeMagicMult )
                            {
                                state = REJECT_STATE ;
                            }
                            else if ( negativeDatum == negativeMagicMult ) 
                            {
                                if ( negative ) 
                                {
                                    if ( ( ULONG ) ( token - 48 ) > negativeMagicNegDigit ) 
                                    {
                                        state = REJECT_STATE ;
                                    }
                                }
                                else
                                {
                                    if ( ( ULONG ) ( token - 48 ) > negativeMagicPosDigit ) 
                                    {
                                        positiveDatum = negativeDatum ;
                                        positive = TRUE ;
                                    }
                                }
                            }
                        }

                        if ( positive )
                        {
                            positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                        }
                        else
                        {
                            negativeDatum = negativeDatum * 10 + ( token - 48 ) ;
                        }
                    }
                    else
                    {
                        if ( negative )
                        {
                            if ( ! unSignedIntegersOnly )
                            {
                                lexicon->token = SnmpLexicon :: SIGNED_INTEGER_ID ;
                                lexicon->value.signedInteger = negativeDatum * -1 ;
                            }
                            else
                            {
                                state = REJECT_STATE ;
                            }
                        }
                        else if ( positive )
                        {
                            lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                            lexicon->value.unsignedInteger = positiveDatum ;
                        }
                        else
                        {
                            if ( unSignedIntegersOnly )
                            {
                                lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                                lexicon->value.signedInteger = negativeDatum ;
                            }
                            else
                            {
                                lexicon->token = SnmpLexicon :: SIGNED_INTEGER_ID ;
                                lexicon->value.signedInteger = negativeDatum ;
                            }
                        }

                        state = ACCEPT_STATE ;

                        position -- ;
                    }
                }   
                break ;

                case ACCEPT_STATE:
                case REJECT_STATE:
                default:
                {
                    state = REJECT_STATE ;
                } ;
                break ;
            }
        }

        position ++ ;
    }

    status = ( state != REJECT_STATE ) ;

    return lexicon ;
}

BOOL SnmpAnalyser :: IsLeadingDecimal ( wchar_t token )
{
    return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL SnmpAnalyser :: IsDecimal ( wchar_t token )
{
    return iswdigit ( token ) ;
}

BOOL SnmpAnalyser :: IsHex ( wchar_t token )
{
    return iswxdigit ( token ) ;
}
    
BOOL SnmpAnalyser :: IsWhitespace ( wchar_t token )
{
    return iswspace ( token ) ;
}

BOOL SnmpAnalyser :: IsOctal ( wchar_t token )
{
    return ( token >= L'0' && token <= L'7' ) ;
}

BOOL SnmpAnalyser :: IsAlpha ( wchar_t token )
{
    return iswalpha ( token ) ;
}

BOOL SnmpAnalyser :: IsAlphaNumeric ( wchar_t token )
{
    return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL SnmpAnalyser :: IsEof ( wchar_t token )
{
    return token == 0 ;
}

ULONG SnmpAnalyser :: OctWCharToDecInteger ( wchar_t token ) 
{
    return token - L'0' ;
}

ULONG SnmpAnalyser :: HexWCharToDecInteger ( wchar_t token ) 
{
    if ( token >= L'0' && token <= L'9' )
    {
        return token - L'0' ;
    }
    else if ( token >= L'a' && token <= L'f' )
    {
        return token - L'a' + 10 ;
    }
    else if ( token >= L'A' && token <= L'F' )
    {
        return token - L'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

ULONG SnmpAnalyser :: DecWCharToDecInteger ( wchar_t token ) 
{
    if ( token >= L'0' && token <= L'9' )
    {
        return token - L'0' ;
    }
    else
    {
        return 0 ;
    }
}

wchar_t SnmpAnalyser :: DecIntegerToOctWChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 7 )
    {
        return L'0' + integer ;
    }
    else
    {
        return L'0' ;
    }
}

wchar_t SnmpAnalyser :: DecIntegerToDecWChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return L'0' + integer ;
    }
    else
    {
        return L'0' ;
    }
}

wchar_t SnmpAnalyser :: DecIntegerToHexWChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return L'0' + integer ;
    }
    else if ( integer >= 10 && integer <= 15 )
    {
        return L'a' + ( integer - 10 ) ;
    }
    else
    {
        return L'0' ;
    }
}

ULONG SnmpAnalyser :: OctCharToDecInteger ( char token ) 
{
    return token - '0' ;
}

ULONG SnmpAnalyser :: HexCharToDecInteger ( char token ) 
{
    if ( token >= '0' && token <= '9' )
    {
        return token - '0' ;
    }
    else if ( token >= 'a' && token <= 'f' )
    {
        return token - 'a' + 10 ;
    }
    else if ( token >= 'A' && token <= 'F' )
    {
        return token - 'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

ULONG SnmpAnalyser :: DecCharToDecInteger ( char token ) 
{
    if ( token >= '0' && token <= '9' )
    {
        return token - '0' ;
    }
    else
    {
        return 0 ;
    }
}

char SnmpAnalyser :: DecIntegerToOctChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 7 )
    {
        return '0' + integer ;
    }
    else
    {
        return '0' ;
    }
}

char SnmpAnalyser :: DecIntegerToDecChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return '0' + integer ;
    }
    else
    {
        return '0' ;
    }
}

char SnmpAnalyser :: DecIntegerToHexChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return '0' + integer ;
    }
    else if ( integer >= 10 && integer <= 15 )
    {
        return 'a' + ( integer - 10 ) ;
    }
    else
    {
        return '0' ;
    }
}

SnmpNegativeRangedType :: SnmpNegativeRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    if ( rangeValues ) 
    {
        status = Parse ( rangeValues ) ;
    }
}

SnmpNegativeRangedType :: SnmpNegativeRangedType ( const SnmpNegativeRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.rangedValues.GetHeadPosition () ;
    while ( position )
    {
        SnmpNegativeRangeType rangeType = copy.rangedValues.GetNext ( position ) ; 
        rangedValues.AddTail ( rangeType ) ;
    }
}

SnmpNegativeRangedType :: ~SnmpNegativeRangedType ()
{
    delete pushBack ;
    rangedValues.RemoveAll () ;
}


void SnmpNegativeRangedType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpNegativeRangedType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get () ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpNegativeRangedType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL SnmpNegativeRangedType :: Check ( const LONG &value )
{
    POSITION position = rangedValues.GetHeadPosition () ;
    if ( position )
    {
        while ( position )
        {
            SnmpNegativeRangeType rangeType = rangedValues.GetNext ( position ) ;
            if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
            {
                return TRUE ;
            }
        }

        return FALSE ;
    }

    return TRUE ; 

}

BOOL SnmpNegativeRangedType :: Parse ( const wchar_t *rangeValues )
{
    BOOL status = TRUE ;

    analyser.Set ( rangeValues ) ;

    return RangeDef () && RecursiveDef () ;
}

BOOL SnmpNegativeRangedType :: RangeDef ()
{
    BOOL status = TRUE ;

    LONG lowerRange = 0 ;
    LONG upperRange = 0 ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: SIGNED_INTEGER_ID:
        {
            lowerRange = lookAhead->GetValue()->signedInteger ;

            SnmpLexicon *lookAhead = Get () ;
            switch ( lookAhead->GetToken () ) 
            {
                case SnmpLexicon :: DOTDOT_ID:
                {
                    SnmpLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case SnmpLexicon :: SIGNED_INTEGER_ID:
                        {
                            upperRange = lookAhead->GetValue()->signedInteger ;
                            SnmpNegativeRangeType rangeType ( lowerRange , upperRange ) ;
                            rangedValues.AddTail ( rangeType ) ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                        break ;
                    }
                }
                break ;

                case SnmpLexicon :: EOF_ID:
                case SnmpLexicon :: COMMA_ID:
                {
                    lowerRange = lookAhead->GetValue()->signedInteger ;
                    SnmpNegativeRangeType rangeType ( lowerRange , lowerRange ) ;
                    rangedValues.AddTail ( rangeType ) ;

                    PushBack () ;
                } 
                break ;

                default:
                {
                    status = FALSE ;
                }
                break ;
            }
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpNegativeRangedType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            RangeDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

SnmpPositiveRangedType :: SnmpPositiveRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    if ( rangeValues ) 
    {
        status = Parse ( rangeValues ) ;
    }
}

SnmpPositiveRangedType :: SnmpPositiveRangedType ( const SnmpPositiveRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.rangedValues.GetHeadPosition () ;
    while ( position )
    {
        SnmpPositiveRangeType rangeType = copy.rangedValues.GetNext ( position ) ;
        rangedValues.AddTail ( rangeType ) ;
    }
}

SnmpPositiveRangedType :: ~SnmpPositiveRangedType ()
{
    delete pushBack ;
    rangedValues.RemoveAll () ;
}

void SnmpPositiveRangedType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpPositiveRangedType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpPositiveRangedType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL SnmpPositiveRangedType :: Check ( const ULONG &value )
{
    POSITION position = rangedValues.GetHeadPosition () ;
    if ( position )
    {
        while ( position )
        {
            SnmpPositiveRangeType rangeType = rangedValues.GetNext ( position ) ;
            if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
            {
                return TRUE ;
            }
        }

        return FALSE ;
    }   

    return TRUE ;
}

BOOL SnmpPositiveRangedType :: Parse ( const wchar_t *rangeValues )
{
    BOOL status = TRUE ;

    analyser.Set ( rangeValues ) ;

    return RangeDef () && RecursiveDef () ;
}

BOOL SnmpPositiveRangedType :: RangeDef ()
{
    BOOL status = TRUE ;

    ULONG lowerRange = 0 ;
    ULONG upperRange = 0 ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            lowerRange = lookAhead->GetValue()->unsignedInteger ;

            SnmpLexicon *lookAhead = Get () ;
            switch ( lookAhead->GetToken () ) 
            {
                case SnmpLexicon :: DOTDOT_ID:
                {
                    SnmpLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                        {
                            upperRange = lookAhead->GetValue()->unsignedInteger ;
                            SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                            rangedValues.AddTail ( rangeType ) ;
                        }
                        break ;

                        case SnmpLexicon :: SIGNED_INTEGER_ID:
                        {
                            if ( lookAhead->GetValue()->signedInteger >= 0 )
                            {
                                upperRange = lookAhead->GetValue()->unsignedInteger ;
                                SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                                rangedValues.AddTail ( rangeType ) ;
                            }
                            else
                            {
                                status = FALSE ;
                            }
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                        break ;
                    }
                }
                break ;

                case SnmpLexicon :: EOF_ID:
                case SnmpLexicon :: COMMA_ID:
                {
                    SnmpPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
                    rangedValues.AddTail ( rangeType ) ;

                    PushBack () ;
                } 
                break ;

                default:
                {
                    status = FALSE ;
                }
                break ;
            }
        }
        break ;

        case SnmpLexicon :: SIGNED_INTEGER_ID:
        {
            lowerRange = lookAhead->GetValue()->signedInteger ;
            if ( lowerRange > 0 )
            {
                SnmpLexicon *lookAhead = Get () ;
                switch ( lookAhead->GetToken () ) 
                {
                    case SnmpLexicon :: DOTDOT_ID:
                    {
                        SnmpLexicon *lookAhead = Get () ;
                        switch ( lookAhead->GetToken () ) 
                        {
                            case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                            {
                                upperRange = lookAhead->GetValue()->unsignedInteger ;
                                SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                                rangedValues.AddTail ( rangeType ) ;
                            }
                            break ;

                            case SnmpLexicon :: SIGNED_INTEGER_ID:
                            {
                                if ( lookAhead->GetValue()->signedInteger >= 0 )
                                {
                                    upperRange = lookAhead->GetValue()->signedInteger ;
                                    SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                                    rangedValues.AddTail ( rangeType ) ;
                                }
                                else
                                {
                                    status = 0 ;
                                }
                            }
                            break ;

                            default:
                            {
                                status = FALSE ;
                            }
                            break ;
                        }
                    }
                    break ;

                    case SnmpLexicon :: EOF_ID:
                    case SnmpLexicon :: COMMA_ID:
                    {
                        SnmpPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
                        rangedValues.AddTail ( rangeType ) ;

                        PushBack () ;
                    } 
                    break ;

                    default:
                    {
                        status = FALSE ;
                    }
                    break ;
                }
            }
            else
            {
                status = FALSE ;
            }
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpPositiveRangedType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            RangeDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpInstanceType :: IsValid () const
{
    return status ;
}

BOOL SnmpInstanceType :: IsNull () const
{
    return m_IsNull ;
}

SnmpInstanceType :: operator void *() 
{ 
    return status ? this : NULL ; 
} 

SnmpNullType :: SnmpNullType ( const SnmpNull &nullArg )
{
}

SnmpNullType :: SnmpNullType ( const SnmpNullType &nullArg )
{
}

SnmpNullType :: SnmpNullType ()
{
}

SnmpNullType :: ~SnmpNullType ()
{
}

BOOL SnmpNullType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}


SnmpInstanceType *SnmpNullType :: Copy () const 
{
    return new SnmpNullType ( *this ) ;
}

SnmpObjectIdentifier SnmpNullType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    SnmpObjectIdentifier returnValue ( objectIdentifier ) ;
    return returnValue ;
}

SnmpObjectIdentifier SnmpNullType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    SnmpInstanceType :: SetNull ( FALSE ) ;
    SnmpObjectIdentifier returnValue ( objectIdentifier ) ;
    return returnValue ;
}

const SnmpValue *SnmpNullType :: GetValueEncoding () const
{
    return & null ;
}

wchar_t *SnmpNullType :: GetStringValue () const 
{
    wchar_t *returnValue = new wchar_t [ 1 ] ;
    returnValue [ 0 ] = 0L ;
    return returnValue ;
}

SnmpIntegerType :: SnmpIntegerType ( 

    const SnmpIntegerType &integerArg 

) : SnmpInstanceType ( integerArg ) , SnmpNegativeRangedType ( integerArg ) , integer ( integerArg.integer ) 
{
}

SnmpIntegerType :: SnmpIntegerType ( 

    const SnmpInteger &integerArg ,
    const wchar_t *rangeValues

) : SnmpNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: IsValid () ) ;
}

SnmpIntegerType :: SnmpIntegerType ( 

    const wchar_t *integerArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpNegativeRangedType ( rangeValues ) , integer ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( integerArg ) && SnmpNegativeRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: Check ( integer.GetValue () ) ) ;
    }
}

SnmpIntegerType :: SnmpIntegerType ( 

    const LONG integerArg ,
    const wchar_t *rangeValues 

) :  SnmpNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: Check ( integer.GetValue () ) ) ;
    }
}

SnmpIntegerType :: SnmpIntegerType ( const wchar_t *rangeValues ) : SnmpNegativeRangedType ( rangeValues ) , 
                                                                    SnmpInstanceType ( TRUE , TRUE ) , 
                                                                    integer ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: IsValid () ) ;
}

SnmpIntegerType :: ~SnmpIntegerType () 
{
}

BOOL SnmpIntegerType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = integer.GetValue() == ((const SnmpIntegerType&)value).integer.GetValue();
    }

    return bResult;
}


SnmpInstanceType *SnmpIntegerType :: Copy () const 
{
    return new SnmpIntegerType ( *this ) ;
}

BOOL SnmpIntegerType :: Parse ( const wchar_t *integerArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( integerArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: SIGNED_INTEGER_ID:
        {
            integer.SetValue ( lookAhead->GetValue ()->signedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpIntegerType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG integerValue = integer.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & integerValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpIntegerType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        integer.SetValue ( objectIdentifier [ 0 ] ) ;

        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }

}

const SnmpValue *SnmpIntegerType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? &integer : NULL ;
}

wchar_t *SnmpIntegerType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        wchar_t stringValue [ 40 ] ;
        _ltow ( integer.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

LONG SnmpIntegerType :: GetValue () const
{
    return integer.GetValue () ;
}

SnmpGaugeType :: SnmpGaugeType ( 

    const SnmpGauge &gaugeArg ,
    const wchar_t *rangeValues
    
) : SnmpPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
    }
}

SnmpGaugeType :: SnmpGaugeType ( 

    const SnmpGaugeType &gaugeArg 

) :  SnmpInstanceType ( gaugeArg ) , SnmpPositiveRangedType ( gaugeArg ) , gauge ( gaugeArg.gauge ) 
{
}

SnmpGaugeType :: SnmpGaugeType ( 

    const wchar_t *gaugeArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , gauge ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( gaugeArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
    }
}

SnmpGaugeType :: SnmpGaugeType ( 

    const ULONG gaugeArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
    }
}

SnmpGaugeType :: SnmpGaugeType ( const wchar_t *rangeValues ) : SnmpPositiveRangedType ( rangeValues ) , 
                                                                SnmpInstanceType ( TRUE , TRUE ) , 
                                                                gauge ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpGaugeType :: ~SnmpGaugeType () 
{
}

BOOL SnmpGaugeType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = gauge.GetValue() == ((const SnmpGaugeType&)value).gauge.GetValue();
    }

    return bResult;
}

SnmpInstanceType *SnmpGaugeType :: Copy () const 
{
    return new SnmpGaugeType ( *this ) ;
}

BOOL SnmpGaugeType :: Parse ( const wchar_t *gaugeArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( gaugeArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            gauge.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpGaugeType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG gaugeValue = gauge.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & gaugeValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpGaugeType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        gauge.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpGaugeType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & gauge : NULL ;
}

wchar_t *SnmpGaugeType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull ()  )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( gauge.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpGaugeType :: GetValue () const
{
    return gauge.GetValue () ;
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const SnmpTimeTicks &timeTicksArg 

) : timeTicks ( timeTicksArg ) 
{
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const SnmpTimeTicksType &timeTicksArg 

) : SnmpInstanceType ( timeTicksArg ) , timeTicks ( timeTicksArg.timeTicks ) 
{
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const wchar_t *timeTicksArg

) : SnmpInstanceType ( FALSE ) , timeTicks ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( timeTicksArg ) ) ;
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const ULONG timeTicksArg

) : timeTicks ( timeTicksArg ) 
{
}

SnmpTimeTicksType :: SnmpTimeTicksType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                            timeTicks ( 0 ) 
{
}

SnmpTimeTicksType :: ~SnmpTimeTicksType () 
{
}

BOOL SnmpTimeTicksType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = timeTicks.GetValue() == ((const SnmpTimeTicksType&)value).timeTicks.GetValue();
    }

    return bResult;
}

SnmpInstanceType *SnmpTimeTicksType :: Copy () const 
{
    return new SnmpTimeTicksType ( *this ) ;
}

BOOL SnmpTimeTicksType :: Parse ( const wchar_t *timeTicksArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( timeTicksArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            timeTicks.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpTimeTicksType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG timeTicksValue = timeTicks.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & timeTicksValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpTimeTicksType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        timeTicks.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpTimeTicksType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & timeTicks : NULL ;
}

wchar_t *SnmpTimeTicksType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull ()  )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( timeTicks.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpTimeTicksType :: GetValue () const
{
    return timeTicks.GetValue () ;
}

SnmpCounterType :: SnmpCounterType ( const SnmpCounter &counterArg ) : counter ( counterArg ) 
{
}

SnmpCounterType :: SnmpCounterType ( const SnmpCounterType &counterArg ) : SnmpInstanceType ( counterArg ) , counter ( counterArg.counter ) 
{
}

SnmpInstanceType *SnmpCounterType :: Copy () const 
{
    return new SnmpCounterType ( *this ) ;
}

SnmpCounterType :: SnmpCounterType ( const wchar_t *counterArg ) :  SnmpInstanceType ( FALSE ) , 
                                                                counter ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL SnmpCounterType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = counter.GetValue() == ((const SnmpCounterType&)value).counter.GetValue();
    }

    return bResult;
}

BOOL SnmpCounterType :: Parse ( const wchar_t *counterArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( counterArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            counter.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpCounterType :: SnmpCounterType ( const ULONG counterArg ) : counter ( counterArg ) 
{
}

SnmpCounterType :: SnmpCounterType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                        counter ( 0 ) 
{
}

SnmpCounterType :: ~SnmpCounterType () 
{
}

SnmpObjectIdentifier SnmpCounterType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG counterValue = counter.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & counterValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpCounterType :: Decode ( const SnmpObjectIdentifier &objectIdentifier )
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        counter.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpCounterType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & counter : NULL ;
}

wchar_t *SnmpCounterType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( counter.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpCounterType :: GetValue () const
{
    return counter.GetValue () ;
}

SnmpCounter64Type :: SnmpCounter64Type ( const SnmpCounter64Type &counterArg ) : SnmpInstanceType ( counterArg ) , counter64 ( counterArg.counter64 )
{
}
SnmpCounter64Type :: SnmpCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) : counter64 ( counterLowArg ,  counterHighArg ) 
{
}

SnmpCounter64Type :: SnmpCounter64Type ( const SnmpCounter64 &counterArg ) : counter64 ( counterArg )
{
}

SnmpCounter64Type :: SnmpCounter64Type () : SnmpInstanceType ( TRUE , TRUE ) , counter64 ( 0 , 0 )
{
}

SnmpCounter64Type :: ~SnmpCounter64Type () 
{
}

SnmpInstanceType *SnmpCounter64Type :: Copy () const 
{
    return new SnmpCounter64Type ( *this ) ;
}

SnmpCounter64Type :: SnmpCounter64Type ( const wchar_t *counterArg ) :  SnmpInstanceType ( FALSE ) , counter64 ( 0 , 0 )
{
    SnmpInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL SnmpCounter64Type :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = counter64.Equivalent( ((const SnmpCounter64Type&)value).counter64 );
    }

    return bResult;
}

BOOL SnmpCounter64Type :: Parse ( const wchar_t *counterArg ) 
{
    BOOL status = TRUE ;

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000

    ULONG state = 0 ;

    ULONG position = 0 ;
/* 
 * Integer Definitions
 */

    BOOL negative = FALSE ;
    BOOL positive = FALSE ;

    DWORDLONG positiveMagicMult = ( DWORDLONG ) ( ( ( DWORDLONG ) -1 ) / 10L ) ; 
    DWORDLONG positiveMagicPosDigit = 5 ;
    DWORDLONG positiveDatum = 0 ;   
    DWORDLONG unsignedInteger = 0 ;
/*
 * Token Definitions
 */

    ULONG token_start = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = counterArg [ position ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsLeadingDecimal ( token ) )
                {
                    state = DEC_INTEGER_START + 1  ;
                    positiveDatum = ( token - 48 ) ;
                }
                else if ( token == L'+' )
                {
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'-' ) 
                {
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'0' )
                {
                    state = 1 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                {
                    state = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( token == L'x' || token == L'X' )
                {
                    state = HEX_INTEGER_START ;             
                }
                else if ( SnmpAnalyser :: IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;
                    positiveDatum = ( token - 48 ) ;
                }
                else
                {
                    unsignedInteger = 0 ;

                    state = ACCEPT_STATE ;
                    position -- ;
                }
            }
            break ;

            case HEX_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    positiveDatum = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = HEX_INTEGER_START + 1 ;
                }
                else
                {
                    state = REJECT_STATE ;
                }
            }
            break ;

            case HEX_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    state = HEX_INTEGER_START + 1 ;

                    if ( positiveDatum > positiveMagicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( positiveDatum == positiveMagicMult ) 
                    {
                        if ( SnmpAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    positiveDatum = ( positiveDatum << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                }
                else
                {
                    unsignedInteger = positiveDatum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case OCT_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;

                    if ( positiveDatum > positiveMagicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( positiveDatum == positiveMagicMult ) 
                    {
                        if ( SnmpAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    positiveDatum = ( positiveDatum << 3 ) + SnmpAnalyser :: OctWCharToDecInteger ( token ) ;
                }
                else
                {
                    unsignedInteger = positiveDatum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case DEC_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    positiveDatum = ( token - 48 ) ;
                    state = DEC_INTEGER_START + 1 ;
                }
                else 
                if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                {
                    state = DEC_INTEGER_START ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case DEC_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = DEC_INTEGER_START + 1 ;

                    if ( positiveDatum > positiveMagicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( positiveDatum == positiveMagicMult ) 
                    {
                        if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                }
                else
                {
                    unsignedInteger = positiveDatum ;

                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }   
            break ;

            case ACCEPT_STATE:
            case REJECT_STATE:
            default:
            {
                state = REJECT_STATE ;
            } ;
            break ;
        }

        position ++ ;
    }

    status = ( state != REJECT_STATE ) ;
    if ( status )
    {
        counter64.SetValue(( ULONG ) ( unsignedInteger & 0xFFFFFFFF ), ( ULONG ) ( unsignedInteger >> 32 )) ;
    }

    return status ;
}

SnmpObjectIdentifier SnmpCounter64Type :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    SnmpObjectIdentifier returnValue = objectIdentifier ;
    return returnValue ;
}

SnmpObjectIdentifier SnmpCounter64Type :: Decode ( const SnmpObjectIdentifier &objectIdentifier )
{
    return objectIdentifier ;
}

const SnmpValue *SnmpCounter64Type :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? (const SnmpValue *) & counter64 : (const SnmpValue * ) NULL ;
}

wchar_t *SnmpCounter64Type :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        wchar_t stringValue [ 40 ] ;
        DWORDLONG t_Integer =  (DWORDLONG)counter64.GetHighValue () ;
		t_Integer = (t_Integer << 32 ) + counter64.GetLowValue () ;
        _ui64tow ( t_Integer , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

void SnmpCounter64Type :: GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const
{
    counterHighArg = counter64.GetHighValue () ;
    counterLowArg = counter64.GetLowValue () ;
}

SnmpIpAddressType :: SnmpIpAddressType ( const SnmpIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpIpAddressType :: SnmpIpAddressType ( const SnmpIpAddressType &ipAddressArg ) : SnmpInstanceType ( ipAddressArg ) , ipAddress ( ipAddressArg.ipAddress ) 
{
}

SnmpInstanceType *SnmpIpAddressType :: Copy () const 
{
    return new SnmpIpAddressType ( *this ) ;
}

SnmpIpAddressType :: SnmpIpAddressType ( const wchar_t *ipAddressArg ) : SnmpInstanceType ( FALSE ) , 
                                                                            ipAddress ( ( ULONG ) 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( ipAddressArg ) ) ;
}

BOOL SnmpIpAddressType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = ipAddress.GetValue() == ((const SnmpIpAddressType&)value).ipAddress.GetValue();
    }

    return bResult;
}


BOOL SnmpIpAddressType :: Parse ( const wchar_t *ipAddressArg ) 
{
    BOOL status = TRUE ;
/*
 *  Datum fields.
 */

    ULONG datumA = 0 ;
    ULONG datumB = 0 ;
    ULONG datumC = 0 ;
    ULONG datumD = 0 ;

/*
 *  Parse input for dotted decimal IP Address.
 */

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = ipAddressArg [ position ++ ] ;

        switch ( state ) 
        {
/*
 *  Parse first field 'A'.
 */

            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = ( token - 48 ) ;
                    state = 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 2 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 3 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'B'.
 */
            case 4:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'C'.
 */
            case 8:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *  Parse first field 'D'.
 */
            case 12:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            default:
            {
                state = REJECT_STATE ;
            }
            break ;
        }
    }


/*
 *  Check boundaries for IP fields.
 */

    status = ( state != REJECT_STATE ) ;

    if ( state == ACCEPT_STATE )
    {
        status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
    }

    ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
    ipAddress.SetValue ( data ) ;

    return status ; 

}

SnmpIpAddressType :: SnmpIpAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpIpAddressType :: SnmpIpAddressType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                            ipAddress ( ( ULONG ) 0 ) 
{
}

SnmpIpAddressType :: ~SnmpIpAddressType () 
{
}

SnmpObjectIdentifier SnmpIpAddressType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG ipAddressValue = ipAddress.GetValue () ;
    ULONG ipAddressArray [ 4 ] ;

    ipAddressArray [ 0 ] = ( ipAddressValue >> 24 ) & 0xFF  ;
    ipAddressArray [ 1 ] = ( ipAddressValue >> 16 ) & 0xFF ;
    ipAddressArray [ 2 ] = ( ipAddressValue >> 8 ) & 0xFF ;
    ipAddressArray [ 3 ] = ipAddressValue & 0xFF ;

    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( ipAddressArray , 4 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpIpAddressType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if( objectIdentifier.GetValueLength () >= 4 )
    {
        ULONG byteA = objectIdentifier [ 0 ] ;
        ULONG byteB = objectIdentifier [ 1 ] ;
        ULONG byteC = objectIdentifier [ 2 ] ;
        ULONG byteD = objectIdentifier [ 3 ] ;
        ULONG value = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

        ipAddress.SetValue ( value ) ;

        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 4 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpIpAddressType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & ipAddress : NULL ;
}

wchar_t *SnmpIpAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG ipAddressValue = ipAddress.GetValue () ;

        wchar_t stringAValue [ 40 ] ;
        _itow ( ipAddressValue >> 24 , stringAValue , 10 );

        wchar_t stringBValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

        wchar_t stringCValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

        wchar_t stringDValue [ 40 ] ;
        _itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

        ULONG totalLength = wcslen ( stringAValue ) +
                            wcslen ( stringBValue ) +
                            wcslen ( stringCValue ) +
                            wcslen ( stringDValue ) ;

        returnValue = new wchar_t [ totalLength + 4 + 1 ] ;
        wcscpy ( returnValue , stringAValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringBValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringCValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringDValue ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"0.0.0.0" ) ;
    }

    return returnValue ;
}

ULONG SnmpIpAddressType :: GetValue () const
{
    return ipAddress.GetValue () ;
}

SnmpNetworkAddressType :: SnmpNetworkAddressType ( const SnmpIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpNetworkAddressType :: SnmpNetworkAddressType ( const SnmpNetworkAddressType &networkAddressArg ) : SnmpInstanceType ( networkAddressArg ) , ipAddress ( networkAddressArg.ipAddress ) 
{
}

SnmpInstanceType *SnmpNetworkAddressType :: Copy () const 
{
    return new SnmpNetworkAddressType ( *this ) ;
}

SnmpNetworkAddressType :: SnmpNetworkAddressType ( const wchar_t *networkAddressArg ) : SnmpInstanceType ( FALSE ) , 
                                                                                        ipAddress ( ( ULONG ) 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( networkAddressArg ) ) ;
}

BOOL SnmpNetworkAddressType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = ipAddress.GetValue() == ((const SnmpNetworkAddressType&)value).ipAddress.GetValue();
    }

    return bResult;
}

BOOL SnmpNetworkAddressType :: Parse ( const wchar_t *networkAddressArg ) 
{
    BOOL status = TRUE ;

/*
 *  Datum fields.
 */

    ULONG datumA = 0 ;
    ULONG datumB = 0 ;
    ULONG datumC = 0 ;
    ULONG datumD = 0 ;

/*
 *  Parse input for dotted decimal IP Address.
 */

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = networkAddressArg [ position ++ ] ;

        switch ( state ) 
        {
/*
 *  Parse first field 'A'.
 */

            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = ( token - 48 ) ;
                    state = 1 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 0 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 2 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 3 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'B'.
 */
            case 4:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'C'.
 */
            case 8:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *  Parse first field 'D'.
 */
            case 12:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ; 
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            default:
            {
                state = REJECT_STATE ;
            }
            break ;
        }
    }


/*
 *  Check boundaries for IP fields.
 */

    status = ( state != REJECT_STATE ) ;

    if ( state == ACCEPT_STATE )
    {
        status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
    }

    ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
    ipAddress.SetValue ( data ) ;

    return status ; 
}


SnmpNetworkAddressType :: SnmpNetworkAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpNetworkAddressType :: SnmpNetworkAddressType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                                        ipAddress ( ( ULONG ) 0 ) 
{
}

SnmpNetworkAddressType :: ~SnmpNetworkAddressType () 
{
}

SnmpObjectIdentifier SnmpNetworkAddressType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG ipAddressValue = ipAddress.GetValue () ;
    ULONG networkAddressArray [ 5 ] ;

    networkAddressArray [ 0 ] = 1 ;
    networkAddressArray [ 1 ] = ( ipAddressValue >> 24 ) & 0xFF  ;
    networkAddressArray [ 2 ] = ( ipAddressValue >> 16 ) & 0xFF ;
    networkAddressArray [ 3 ] = ( ipAddressValue >> 8 ) & 0xFF ;
    networkAddressArray [ 4 ] = ipAddressValue & 0xFF ;

    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( networkAddressArray , 5 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpNetworkAddressType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () )
    {
        if ( objectIdentifier [ 0 ] == 1 )
        {
            if( objectIdentifier.GetValueLength () >= 5 )
            {
                ULONG byteA = objectIdentifier [ 1 ] ;
                ULONG byteB = objectIdentifier [ 2 ] ;
                ULONG byteC = objectIdentifier [ 3 ] ;
                ULONG byteD = objectIdentifier [ 4 ] ;
                ULONG value = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

                ipAddress.SetValue ( value ) ;

                SnmpInstanceType :: SetNull ( FALSE ) ;
                SnmpInstanceType :: SetStatus ( TRUE ) ;

                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifier.Suffix ( 5 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }

            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifier ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifier ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpNetworkAddressType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & ipAddress : NULL ;
}

wchar_t *SnmpNetworkAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG ipAddressValue = ipAddress.GetValue () ;

        wchar_t stringAValue [ 40 ] ;
        _itow ( ipAddressValue >> 24 , stringAValue , 10 );

        wchar_t stringBValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

        wchar_t stringCValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

        wchar_t stringDValue [ 40 ] ;
        _itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

        ULONG totalLength = wcslen ( stringAValue ) +
                            wcslen ( stringBValue ) +
                            wcslen ( stringCValue ) +
                            wcslen ( stringDValue ) ;

        returnValue = new wchar_t [ totalLength + 4 + 1 ] ;
        wcscpy ( returnValue , stringAValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringBValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringCValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringDValue ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"0.0.0.0" ) ;
    }

    return returnValue ;
}

ULONG SnmpNetworkAddressType :: GetValue () const
{
    return ipAddress.GetValue () ;
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const SnmpObjectIdentifier &objectIdentifierArg ) : objectIdentifier ( objectIdentifierArg ) 
{
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const SnmpObjectIdentifierType &objectIdentifierArg ) : SnmpInstanceType ( objectIdentifierArg ) , objectIdentifier ( objectIdentifierArg.objectIdentifier ) 
{
}

SnmpInstanceType *SnmpObjectIdentifierType :: Copy () const 
{
    return new SnmpObjectIdentifierType ( *this ) ;
}

SnmpObjectIdentifierType &SnmpObjectIdentifierType :: operator=(const SnmpObjectIdentifierType &to_copy )
{
    m_IsNull = to_copy.m_IsNull ;
    status = to_copy.status ;
    objectIdentifier = to_copy.objectIdentifier;

    return *this;
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const wchar_t *objectIdentifierArg ) :   SnmpInstanceType ( FALSE ) , 
                                                                objectIdentifier ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( objectIdentifierArg ) ) ;
}

BOOL SnmpObjectIdentifierType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = objectIdentifier == ((const SnmpObjectIdentifierType&)value).objectIdentifier;
    }

    return bResult;
}

BOOL SnmpObjectIdentifierType :: Parse ( const wchar_t *objectIdentifierArg ) 
{
#define AVERAGE_OID_LENGTH 20

    BOOL status = TRUE ;

    ULONG reallocLength = AVERAGE_OID_LENGTH ;
    ULONG *reallocArray = ( ULONG * ) malloc ( sizeof ( ULONG ) * reallocLength ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }
    
    ULONG magicMult = ( ( ULONG ) - 1 ) / 10 ; 
    ULONG magicDigit = 5 ;
    ULONG datum = 0 ;   
    ULONG length = 0 ;

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = objectIdentifierArg [ position ++ ] ;

        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = 1 ;
                    datum = ( token - 48 ) ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                {
                    state = 0 ;
                }
                else if ( token == 0 ) 
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = 1 ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( ( ULONG ) ( token - 48 ) > magicDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    datum = datum * 10 + ( token - 48 ) ;
                }
                else
                if ( token == L'.' ) 
                {
                    reallocArray [ length ] = datum ;
                    length ++ ;
                    if ( length >= reallocLength )
                    {
                        reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                        realloc_throw ( &reallocArray , sizeof ( ULONG ) * reallocLength ) ;
                    }

                    state = 2 ;
                }
                else if ( token == 0 ) 
                {
                    reallocArray [ length ] = datum ;

                    length ++ ;
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = 1 ;
                    datum = ( token - 48 ) ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    objectIdentifier.SetValue ( reallocArray , length ) ;

    free ( reallocArray ) ;

    if ( length < 2 ) 
    {
        status = FALSE ;
    }

    return status ;
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const ULONG *value , const ULONG valueLength ) : objectIdentifier ( value , valueLength ) 
{
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                        objectIdentifier ( NULL , 0 ) 
{
}

SnmpObjectIdentifierType :: ~SnmpObjectIdentifierType () 
{
}

SnmpObjectIdentifier SnmpObjectIdentifierType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG objectIdentifierLength = objectIdentifier.GetValueLength () ;
    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & objectIdentifierLength , 1 ) + objectIdentifier ;
    
    return returnValue ;
}

SnmpObjectIdentifier SnmpObjectIdentifierType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () )
    {
        ULONG objectIdentifierLength = objectIdentifierArg [ 0 ] ;
        if ( objectIdentifierArg.GetValueLength () >= objectIdentifierLength )
        {
            objectIdentifier.SetValue ( & objectIdentifierArg [ 1 ] , objectIdentifierLength ) ;
            SnmpInstanceType :: SetNull ( FALSE ) ;
            SnmpInstanceType :: SetStatus ( TRUE ) ;

            ULONG objectIdentifierLength = objectIdentifierArg [ 0 ] ;
            if ( objectIdentifierLength < objectIdentifierArg.GetValueLength () )
            {
                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifierArg.Suffix ( objectIdentifierLength + 1 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }
            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifier ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifier ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }

}

const SnmpValue *SnmpObjectIdentifierType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & objectIdentifier : NULL ;
}

wchar_t *SnmpObjectIdentifierType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OID_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG objectIdentifierLength = objectIdentifier.GetValueLength () ;     
        ULONG index = 0 ;
        while ( index < objectIdentifierLength ) 
        {
            wchar_t stringValue [ 40 ] ;
            _ultow ( objectIdentifier [ index ] , stringValue , 10 );
            ULONG stringLength = wcslen ( stringValue ) ;

            if ( ( totalLength + stringLength + 1 ) >= reallocLength )
            {
                ULONG t_Max = max( stringLength + 1 , AVERAGE_OID_LENGTH ) ;
                reallocLength = reallocLength + t_Max ;
                realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + stringLength ;

            index ++ ;
            if ( index < objectIdentifierLength )
            {
                if ( ( totalLength + 1 + 1 ) >= reallocLength )
                {
                    reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                    realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
                }

                wcscpy ( & reallocArray [ totalLength ] , L"." ) ;
                totalLength ++ ;
            }
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( objectIdentifierLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"0.0" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"0.0" ) ;
    }

    return returnValue ;
}

ULONG *SnmpObjectIdentifierType :: GetValue () const
{
    return objectIdentifier.GetValue () ;
}

ULONG SnmpObjectIdentifierType :: GetValueLength () const
{
    return objectIdentifier.GetValueLength () ;
}

#define AVERAGE_OCTET_LENGTH 256 

SnmpOpaqueType :: SnmpOpaqueType ( 

    const SnmpOpaque &opaqueArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , opaque ( opaqueArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
    }
}

SnmpOpaqueType :: SnmpOpaqueType ( 

    const SnmpOpaqueType &opaqueArg 

) : SnmpInstanceType ( opaqueArg ) , SnmpPositiveRangedType ( opaqueArg ) , opaque ( opaqueArg.opaque ) 
{
}

SnmpOpaqueType :: SnmpOpaqueType ( 

    const wchar_t *opaqueArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , opaque ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( opaqueArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
    }
}

SnmpOpaqueType :: SnmpOpaqueType ( 

    const UCHAR *value , 
    const ULONG valueLength ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , opaque ( value , valueLength ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
    }
}

SnmpOpaqueType :: SnmpOpaqueType ( const wchar_t *rangeValues ) :   SnmpInstanceType ( TRUE , TRUE ) , 
                                                                    SnmpPositiveRangedType ( rangeValues ) ,
                                                                    opaque ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpOpaqueType :: ~SnmpOpaqueType () 
{
}

BOOL SnmpOpaqueType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = opaque.Equivalent( ((const SnmpOpaqueType&)value).opaque );
    }

    return bResult;
}

SnmpInstanceType *SnmpOpaqueType :: Copy () const 
{
    return new SnmpOpaqueType ( *this ) ;
}

BOOL SnmpOpaqueType :: Parse ( const wchar_t *opaqueArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * Oqaque Definitions
 */

    BOOL even = FALSE ;
    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = opaqueArg [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 1 ;
                    length ++ ;
                    byte = 0 ;
                    even = TRUE ;
                }
                else if ( token == 0 )
                {
                    state = REJECT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length )
    {
        opaque.SetValue ( reallocArray , length ) ;
    }
    else
    {
        opaque.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

SnmpObjectIdentifier SnmpOpaqueType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG opaqueLength = opaque.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ opaqueLength ] ;
    UCHAR *opaqueArray = opaque.GetValue () ;
    for ( ULONG index = 0 ; index < opaqueLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) opaqueArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & opaqueLength , 1 ) + SnmpObjectIdentifier ( objectIdentifier , opaqueLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpOpaqueType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () )
    {
        ULONG opaqueLength = objectIdentifierArg [ 0 ] ;
        if ( objectIdentifierArg.GetValueLength () >= opaqueLength + 1 )
        {
            UCHAR *opaqueArray = new UCHAR [ opaqueLength ] ;
            for ( ULONG index = 0 ; index < opaqueLength ; index ++ )
            {
                opaqueArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
            }

            opaque.SetValue ( opaqueArray , opaqueLength ) ;

            delete [] opaqueArray ;

            SnmpInstanceType :: SetStatus ( TRUE ) ;
            SnmpInstanceType :: SetNull ( FALSE ) ;

            ULONG opaqueLength = objectIdentifierArg [ 0 ] ;
            if ( opaqueLength < objectIdentifierArg.GetValueLength () )
            {
                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifierArg.Suffix ( opaqueLength + 1 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }
            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifierArg ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifierArg ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

const SnmpValue *SnmpOpaqueType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & opaque : NULL ;
}

wchar_t *SnmpOpaqueType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG opaqueLength = opaque.GetValueLength () ;     
        UCHAR *opaqueArray = opaque.GetValue () ;

        ULONG index = 0 ;
        while ( index < opaqueLength ) 
        {
            wchar_t hexValue [ 40 ] ;
            _ultow ( opaqueArray [ index ] , hexValue , 16 );
            ULONG hexLength = wcslen ( hexValue ) ;

            wchar_t stringValue [ 3 ] ;
            ULONG stringLength = 2 ;

            if ( hexLength == 1 )
            {
                stringValue [ 0 ] = L'0' ;
                stringValue [ 1 ] = hexValue [ 0 ] ;
                stringValue [ 2 ] = 0 ;
            }
            else
            {
                stringValue [ 0 ] = hexValue [ 0 ] ;
                stringValue [ 1 ] = hexValue [ 1 ] ;
                stringValue [ 2 ] = 0 ;
            }

            if ( ( totalLength + stringLength + 1 ) >= reallocLength )
            {
                ULONG t_Max = max( stringLength + 1 , AVERAGE_OID_LENGTH ) ;
	            reallocLength = reallocLength + t_Max ;
                realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + stringLength ;

            index ++ ;
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( opaqueLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

UCHAR *SnmpOpaqueType :: GetValue () const
{
    return opaque.GetValue () ;
}

ULONG SnmpOpaqueType :: GetValueLength () const
{
    return opaque.GetValueLength () ;
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const ULONG &fixedLengthArg , 
    const SnmpOpaque &opaqueArg 

) : SnmpOpaqueType ( opaqueArg , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const SnmpFixedLengthOpaqueType &opaqueArg 

) : SnmpOpaqueType ( opaqueArg ) ,
    SnmpFixedType ( opaqueArg )
{
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpInstanceType *SnmpFixedLengthOpaqueType :: Copy () const 
{
    return new SnmpFixedLengthOpaqueType ( *this ) ;
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *opaqueArg 

) : SnmpOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetStatus ( Parse ( opaqueArg ) ) ;
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const ULONG &fixedLengthArg ,
    const UCHAR *value , 
    const ULONG valueLength 

) : SnmpOpaqueType ( value , valueLength , NULL ) ,
    SnmpFixedType ( fixedLengthArg ) 
{
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType (

    const ULONG &fixedLengthArg

) : SnmpOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpFixedLengthOpaqueType :: ~SnmpFixedLengthOpaqueType () 
{
}

SnmpObjectIdentifier SnmpFixedLengthOpaqueType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG opaqueLength = opaque.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ opaqueLength ] ;
    UCHAR *opaqueArray = opaque.GetValue () ;
    for ( ULONG index = 0 ; index < opaqueLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) opaqueArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & opaqueLength , 1 ) + SnmpObjectIdentifier ( objectIdentifier , opaqueLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpFixedLengthOpaqueType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () >= fixedLength )
    {
        UCHAR *opaqueArray = new UCHAR [ fixedLength ] ;
        for ( ULONG index = 0 ; index < fixedLength ; index ++ )
        {
            opaqueArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
        }

        opaque.SetValue ( opaqueArray , fixedLength ) ;

        delete [] opaqueArray ;

        SnmpInstanceType :: SetStatus ( TRUE ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifierArg.Suffix ( fixedLength , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const SnmpOctetString &octetStringArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , octetString ( octetStringArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const SnmpOctetStringType &octetStringArg 

) : SnmpInstanceType ( octetStringArg ) , SnmpPositiveRangedType ( octetStringArg ) , octetString ( octetStringArg.octetString ) 
{
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const wchar_t *octetStringArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , octetString ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( octetStringArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const UCHAR *value , 
    const ULONG valueLength ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , octetString ( value , valueLength ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( const wchar_t *rangeValues ) : SnmpPositiveRangedType ( rangeValues ) ,
                                                                            SnmpInstanceType ( TRUE , TRUE ) , 
                                                                            octetString ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpOctetStringType :: ~SnmpOctetStringType () 
{
}

BOOL SnmpOctetStringType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = octetString.Equivalent( ((const SnmpOctetStringType&)value).octetString );
    }

    return bResult;
}

SnmpInstanceType *SnmpOctetStringType :: Copy () const 
{
    return new SnmpOctetStringType ( *this ) ;
}

BOOL SnmpOctetStringType :: Parse ( const wchar_t *octetStringArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * OctetString Definitions
 */

    BOOL even = FALSE ;
    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = octetStringArg [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 1 ;
                    length ++ ;
                    byte = 0 ;
                    even = TRUE ;
                }
                else if ( token == 0 )
                {
                    state = REJECT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length )
    {
        octetString.SetValue ( reallocArray , length ) ;
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

SnmpObjectIdentifier SnmpOctetStringType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG octetStringLength = octetString.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ octetStringLength ] ;
    UCHAR *octetStringArray = octetString.GetValue () ;
    for ( ULONG index = 0 ; index < octetStringLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) octetStringArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & octetStringLength , 1 ) + SnmpObjectIdentifier ( objectIdentifier , octetStringLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpOctetStringType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () )
    {
        ULONG octetStringLength = objectIdentifierArg [ 0 ] ;
        if ( objectIdentifierArg.GetValueLength () >= octetStringLength + 1 )
        {
            UCHAR *octetStringArray = new UCHAR [ octetStringLength ] ;
            for ( ULONG index = 0 ; index < octetStringLength ; index ++ )
            {
                octetStringArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
            }

            octetString.SetValue ( octetStringArray , octetStringLength ) ;

            delete [] octetStringArray ;

            SnmpInstanceType :: SetStatus ( TRUE ) ;
            SnmpInstanceType :: SetNull ( FALSE ) ;

            ULONG octetStringLength = objectIdentifierArg [ 0 ] ;

            if ( octetStringLength < objectIdentifierArg.GetValueLength () )
            {
                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifierArg.Suffix ( octetStringLength + 1 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }
            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifierArg ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifierArg ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

const SnmpValue *SnmpOctetStringType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & octetString : NULL ;
}

wchar_t *SnmpOctetStringType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        ULONG totalLength = 0 ;
        ULONG octetStringLength = octetString.GetValueLength () ;       
        UCHAR *octetStringArray = octetString.GetValue () ;

        returnValue = new wchar_t [ octetStringLength * 2 + 1 ] ;

        ULONG index = 0 ;
        while ( index < octetStringLength ) 
        {
            wchar_t stringValue [ 3 ] ;

            stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
            stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
            stringValue [ 2 ] = 0 ;

            wcscpy ( & returnValue [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 2 ;

            index ++ ;
        }

        returnValue [ octetStringLength * 2 ] = 0 ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

UCHAR *SnmpOctetStringType :: GetValue () const
{
    return octetString.GetValue () ;
}

ULONG SnmpOctetStringType :: GetValueLength () const
{
    return octetString.GetValueLength () ;
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const ULONG &fixedLengthArg , 
    const SnmpOctetString &octetStringArg 

) : SnmpOctetStringType ( octetStringArg , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const SnmpFixedLengthOctetStringType &octetStringArg 

) : SnmpOctetStringType ( octetStringArg ) ,
    SnmpFixedType ( octetStringArg )
{
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpInstanceType *SnmpFixedLengthOctetStringType :: Copy () const 
{
    return new SnmpFixedLengthOctetStringType ( *this ) ;
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *octetStringArg 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetStatus ( Parse ( octetStringArg ) ) ;
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const ULONG &fixedLengthArg ,
    const UCHAR *value 

) : SnmpOctetStringType ( value , fixedLengthArg , NULL ) ,
    SnmpFixedType ( fixedLengthArg ) 
{
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType (

    const ULONG &fixedLengthArg

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpFixedLengthOctetStringType :: ~SnmpFixedLengthOctetStringType () 
{
}

SnmpObjectIdentifier SnmpFixedLengthOctetStringType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG octetStringLength = octetString.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ octetStringLength ] ;
    UCHAR *octetStringArray = octetString.GetValue () ;
    for ( ULONG index = 0 ; index < octetStringLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) octetStringArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( objectIdentifier , octetStringLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpFixedLengthOctetStringType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () >= fixedLength )
    {
        UCHAR *octetStringArray = new UCHAR [ fixedLength ] ;
        for ( ULONG index = 0 ; index < fixedLength ; index ++ )
        {
            octetStringArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
        }

        octetString.SetValue ( octetStringArray , fixedLength ) ;

        delete [] octetStringArray ;

        SnmpInstanceType :: SetStatus ( TRUE ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifierArg.Suffix ( fixedLength , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

SnmpMacAddressType :: SnmpMacAddressType ( const SnmpOctetString &macAddressArg ) : SnmpFixedLengthOctetStringType ( 6 , macAddressArg ) 
{
}

SnmpMacAddressType :: SnmpMacAddressType ( const SnmpMacAddressType &macAddressArg ) : SnmpFixedLengthOctetStringType ( macAddressArg ) 
{
}

SnmpInstanceType *SnmpMacAddressType :: Copy () const 
{
    return new SnmpMacAddressType ( *this ) ;
}

SnmpMacAddressType :: SnmpMacAddressType ( const wchar_t *macAddressArg ) : SnmpFixedLengthOctetStringType ( 6 )  
{
    SnmpInstanceType :: SetStatus ( Parse ( macAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpMacAddressType :: Parse ( const wchar_t *macAddressArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    UCHAR macAddress [ 6 ] ;

/* 
 * MacAddress Definitions
 */

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = macAddressArg [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( length >= 6 ) state = REJECT_STATE ;
                else if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    macAddress [ length ] = ( UCHAR ) byte ;
                    state = 2 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( token == L':' ) state = 0 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( status )
    {
        octetString.SetValue ( macAddress , 6 ) ;
    }

    return status ;
}

SnmpMacAddressType :: SnmpMacAddressType ( const UCHAR *value ) : SnmpFixedLengthOctetStringType ( 6 , value ) 
{
}

SnmpMacAddressType :: SnmpMacAddressType () : SnmpFixedLengthOctetStringType ( 6 ) 
{
}

SnmpMacAddressType :: ~SnmpMacAddressType () 
{
}

wchar_t *SnmpMacAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        if ( valueLength == 6 )
		{
			returnValue = new wchar_t [ 18 ] ;

			returnValue [ 2 ] = L':' ;
			returnValue [ 5 ] = L':' ;
			returnValue [ 8 ] = L':' ;
			returnValue [ 11 ] = L':' ;
			returnValue [ 14 ] = L':' ;
			returnValue [ 17 ] = 0 ;

			returnValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 0 ] >> 4 ) ;
			returnValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 0 ] & 0xf ) ;

			returnValue [ 3 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 1 ] >> 4 ) ;
			returnValue [ 4 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 1 ] & 0xf ) ;

			returnValue [ 6 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 2 ] >> 4 ) ;
			returnValue [ 7 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 2 ] & 0xf ) ;

			returnValue [ 9 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 3 ] >> 4 ) ;
			returnValue [ 10 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 3 ] & 0xf ) ;

			returnValue [ 12 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 4 ] >> 4 ) ;
			returnValue [ 13 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 4 ] & 0xf ) ;

			returnValue [ 15 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 5 ] >> 4 ) ;
			returnValue [ 16 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 5 ] & 0xf ) ;
		}
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpPhysAddressType :: SnmpPhysAddressType ( 

    const SnmpOctetString &physAddressArg , 
    const wchar_t *rangedValues 

) : SnmpOctetStringType ( physAddressArg , rangedValues ) 
{
}

SnmpPhysAddressType :: SnmpPhysAddressType ( 

    const SnmpPhysAddressType &physAddressArg 

) : SnmpOctetStringType ( physAddressArg ) 
{
}

SnmpInstanceType *SnmpPhysAddressType :: Copy () const 
{
    return new SnmpPhysAddressType ( *this ) ;
}

SnmpPhysAddressType :: SnmpPhysAddressType ( 

    const wchar_t *physAddressArg ,
    const wchar_t *rangedValues

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )  
{
    SnmpInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * PhyAddress Definitions
 */

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = physAddress [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 3 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L':' )
                {
                    state = 1 ;
                }
                else if ( token == 0 )
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length )
    {
        octetString.SetValue ( reallocArray , length ) ;
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

SnmpPhysAddressType :: SnmpPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) : SnmpOctetStringType ( value , valueLength , rangedValues ) 
{
}

SnmpPhysAddressType :: SnmpPhysAddressType (

    const wchar_t *rangedValues 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues ) 
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpPhysAddressType :: ~SnmpPhysAddressType () 
{
}

wchar_t *SnmpPhysAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG physAddressLength = octetString.GetValueLength () ;       
        UCHAR *physAddressArray = octetString.GetValue () ;

        ULONG index = 0 ;
        while ( index < physAddressLength ) 
        {
            wchar_t stringValue [ 3 ] ;

            stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
            stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
            stringValue [ 2 ] = 0 ;

            if ( ( totalLength + 2 + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 2 ;

            index ++ ;
            if ( index < physAddressLength )
            {
                if ( ( totalLength + 1 + 1 ) >= reallocLength )
                {
                    reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                    realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
                }

                wcscpy ( & reallocArray [ totalLength ] , L":" ) ;
                totalLength ++ ;
            }
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( physAddressLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType ( 

    const ULONG &fixedLengthArg ,
    const SnmpOctetString &physAddressArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg , physAddressArg ) 
{
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType ( 

    const SnmpFixedLengthPhysAddressType &physAddressArg 

) : SnmpFixedLengthOctetStringType ( physAddressArg ) 
{
}

SnmpInstanceType *SnmpFixedLengthPhysAddressType :: Copy () const 
{
    return new SnmpFixedLengthPhysAddressType ( *this ) ;
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *physAddressArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
    SnmpInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType (

    const ULONG &fixedLengthArg

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpFixedLengthPhysAddressType :: ~SnmpFixedLengthPhysAddressType () 
{
}

BOOL SnmpFixedLengthPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * PhyAddress Definitions
 */

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = physAddress [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        realloc_throw ( &reallocArray , reallocLength * sizeof ( UCHAR ) ) ;
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 3 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L':' )
                {
                    state = 1 ;
                }
                else if ( token == 0 )
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length == fixedLength )
    {
        octetString.SetValue ( reallocArray , length ) ;
    }
    else
    {
        status = FALSE ;
        octetString.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

wchar_t *SnmpFixedLengthPhysAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
        
        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG physAddressLength = octetString.GetValueLength () ;       
        UCHAR *physAddressArray = octetString.GetValue () ;

        ULONG index = 0 ;
        while ( index < physAddressLength ) 
        {
            wchar_t stringValue [ 3 ] ;

            stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
            stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
            stringValue [ 2 ] = 0 ;

            if ( ( totalLength + 2 + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 2 ;

            index ++ ;
            if ( index < physAddressLength )
            {
                if ( ( totalLength + 1 + 1 ) >= reallocLength )
                {
                    reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                    realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
                }

                wcscpy ( & reallocArray [ totalLength ] , L":" ) ;
                totalLength ++ ;
            }
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( physAddressLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpDisplayStringType :: SnmpDisplayStringType ( 

    const SnmpOctetString &displayStringArg ,
    const wchar_t *rangeValues

) : SnmpOctetStringType ( displayStringArg , rangeValues ) 
{
}

SnmpDisplayStringType :: SnmpDisplayStringType ( 

    const SnmpDisplayStringType &displayStringArg 

) : SnmpOctetStringType ( displayStringArg ) 
{
}

SnmpInstanceType *SnmpDisplayStringType :: Copy () const 
{
    return new SnmpDisplayStringType ( *this ) ;
}

SnmpDisplayStringType :: SnmpDisplayStringType ( 

    const wchar_t *displayStringArg ,
    const wchar_t *rangeValues

) : SnmpOctetStringType ( NULL , 0 , rangeValues )
{
    char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
    if ( textBuffer )
    {
        ULONG textLength = strlen ( textBuffer ) ;

        octetString.SetValue ( ( UCHAR * ) textBuffer , textLength ) ;

        delete [] textBuffer ;

        SnmpInstanceType :: SetStatus ( TRUE ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpDisplayStringType :: SnmpDisplayStringType (

    const wchar_t *rangedValues 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpDisplayStringType :: ~SnmpDisplayStringType () 
{
}

wchar_t *SnmpDisplayStringType :: GetValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
            memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
            textBuffer [ octetString.GetValueLength () ] = 0 ;

            wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

            delete [] textBuffer ;

            return unicodeString ;
        }
        else
        {
            return SnmpOctetStringType :: GetStringValue () ;
        }
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }
}

wchar_t *SnmpDisplayStringType :: GetStringValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
            memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
            textBuffer [ octetString.GetValueLength () ] = 0 ;

            wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

            delete [] textBuffer ;

            return unicodeString ;
        }
        else
        {
            return SnmpOctetStringType :: GetStringValue () ;
        }
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }

}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType ( 

    const ULONG &fixedLengthArg ,
    const SnmpOctetString &displayStringArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg , displayStringArg ) 
{
}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType ( 

    const SnmpFixedLengthDisplayStringType &displayStringArg 

) : SnmpFixedLengthOctetStringType ( displayStringArg ) 
{
}

SnmpInstanceType *SnmpFixedLengthDisplayStringType :: Copy () const 
{
    return new SnmpFixedLengthDisplayStringType ( *this ) ;
}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *displayStringArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
    char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
    if ( textBuffer )
    {
        ULONG textLength = strlen ( textBuffer ) ;

        octetString.SetValue ( ( UCHAR * ) textBuffer , textLength + 1 ) ;

        delete [] textBuffer ;
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType (

    const ULONG &fixedLengthArg

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
}

SnmpFixedLengthDisplayStringType :: ~SnmpFixedLengthDisplayStringType () 
{
}

wchar_t *SnmpFixedLengthDisplayStringType :: GetValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
        memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
        textBuffer [ octetString.GetValueLength () ] = 0 ;

        wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

        delete [] textBuffer ;

        return unicodeString ;
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }
}

wchar_t *SnmpFixedLengthDisplayStringType :: GetStringValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
        memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
        textBuffer [ octetString.GetValueLength () ] = 0 ;

        wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

        delete [] textBuffer ;

        return unicodeString ;
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const wchar_t *enumeratedValues , 
    const LONG &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

    wchar_t *enumeratedStringValue ;
    if ( integerMap.Lookup ( ( LONG ) enumeratedValue , enumeratedStringValue ) )
    {
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }

    integer.SetValue ( enumeratedValue ) ;

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const wchar_t *enumeratedValues , 
    const SnmpInteger &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

    wchar_t *enumeratedStringValue ;
    if ( integerMap.Lookup ( ( LONG ) enumeratedValue.GetValue () , enumeratedStringValue ) )
    {
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }

    integer.SetValue ( enumeratedValue.GetValue () ) ;

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const wchar_t *enumeratedValues , 
    const wchar_t *enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
    LONG enumeratedIntegerValue ;
    if ( stringMap.Lookup ( ( wchar_t * ) enumeratedValue , enumeratedIntegerValue ) )
    {
        integer.SetValue ( enumeratedIntegerValue ) ;
    }
    else
    {
        SnmpAnalyser analyser ;
        analyser.Set ( enumeratedValue ) ;
        SnmpLexicon *lookAhead = analyser.Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case SnmpLexicon :: UNSIGNED_INTEGER_ID:
            {
                LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
                integer.SetValue ( enumerationInteger ) ;
            }   
            break ;

            default:
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
            }
            break ;
        }

        delete lookAhead ;
    }

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const SnmpEnumeratedType &copy

) : SnmpIntegerType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.integerMap.GetStartPosition () ;
    while ( position )
    {
        LONG enumeratedIntegerValue ;
        wchar_t *enumeratedStringValue ;
        copy.integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

        wchar_t *stringCopy = new wchar_t [ wcslen ( enumeratedStringValue ) + 1 ] ;
        wcscpy ( stringCopy , enumeratedStringValue ) ;

        integerMap [ enumeratedIntegerValue ] = stringCopy ;
        stringMap [ stringCopy ] = enumeratedIntegerValue ;
    }
}

SnmpEnumeratedType :: SnmpEnumeratedType (

    const wchar_t *enumeratedValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
}

SnmpEnumeratedType :: ~SnmpEnumeratedType ()
{
    POSITION position = integerMap.GetStartPosition () ;
    while ( position )
    {
        LONG enumeratedIntegerValue ;
        wchar_t *enumeratedStringValue ;
        integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

        delete [] enumeratedStringValue ;
    }

    integerMap.RemoveAll () ;
    stringMap.RemoveAll () ;

    delete pushBack ;
}

wchar_t *SnmpEnumeratedType :: GetStringValue () const
{
    wchar_t *stringValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            wchar_t *enumeratedValue ;
            if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
            {
                stringValue = new wchar_t [ wcslen ( enumeratedValue ) + 1 ] ;
                wcscpy ( stringValue , enumeratedValue ) ;
            }
            else
            {
                stringValue = SnmpIntegerType :: GetStringValue () ;
            }
        }
        else
        {
            stringValue = SnmpIntegerType :: GetStringValue () ;
        }
    }
    else
    {
        stringValue = SnmpIntegerType :: GetStringValue () ;
    }

    return stringValue ;
}

wchar_t *SnmpEnumeratedType :: GetValue () const
{
    wchar_t *stringValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            wchar_t *enumeratedValue ;
            if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
            {
                stringValue = new wchar_t [ wcslen ( enumeratedValue ) + 1 ] ;
                wcscpy ( stringValue , enumeratedValue ) ;
            }
            else
            {
                stringValue = SnmpIntegerType :: GetStringValue () ;
            }
        }
        else
        {
            stringValue = SnmpIntegerType :: GetStringValue () ;
        }
    }
    else
    {
        stringValue = SnmpIntegerType :: GetStringValue () ;
    }

    return stringValue ;
}

SnmpInstanceType *SnmpEnumeratedType :: Copy () const
{
    return new SnmpEnumeratedType ( *this ) ;
}

BOOL SnmpEnumeratedType :: Parse ( const wchar_t *enumeratedValues )
{
    BOOL status = TRUE ;

    analyser.Set ( enumeratedValues ) ;

    return EnumerationDef () && RecursiveDef () ;
}

BOOL SnmpEnumeratedType :: EnumerationDef ()
{
    BOOL status = TRUE ;

    wchar_t *enumerationString = NULL ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: TOKEN_ID:
        {
            wchar_t *tokenString = lookAhead->GetValue()->token ;
            enumerationString = new wchar_t [ wcslen ( tokenString ) + 1 ] ;

			try
			{
				wcscpy ( enumerationString , tokenString ) ;

				SnmpLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case SnmpLexicon :: OPEN_PAREN_ID:
					{
						SnmpLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case SnmpLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ enumerationInteger ] = enumerationString ;
								stringMap [ enumerationString ] = enumerationInteger ;
								enumerationString = NULL ;

								Match ( SnmpLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch(...)
			{
				if ( enumerationString )
				{
					delete [] enumerationString ;
				}

				throw;
			}

			if ( enumerationString )
			{
				delete [] enumerationString ;
			}
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpEnumeratedType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            EnumerationDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

void SnmpEnumeratedType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpEnumeratedType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpEnumeratedType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    SnmpInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
    return SnmpInstanceType :: IsValid () ? lexicon : NULL ;
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const LONG &rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const wchar_t *rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const SnmpInteger &rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const SnmpRowStatusEnum &rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , ( LONG ) rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( const SnmpRowStatusType &rowStatusValue ) : SnmpEnumeratedType ( rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType () : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" )
{
}

SnmpRowStatusType :: ~SnmpRowStatusType () 
{
}

wchar_t *SnmpRowStatusType :: GetStringValue () const 
{
    return SnmpEnumeratedType :: GetStringValue () ;
}

wchar_t *SnmpRowStatusType :: GetValue () const 
{
    return SnmpEnumeratedType :: GetValue () ;
}

SnmpRowStatusType :: SnmpRowStatusEnum SnmpRowStatusType :: GetRowStatus () const 
{
    return ( SnmpRowStatusType :: SnmpRowStatusEnum ) integer.GetValue () ;
} ;

SnmpInstanceType *SnmpRowStatusType :: Copy () const
{
    return new SnmpRowStatusType ( *this ) ;
}

SnmpBitStringType :: SnmpBitStringType ( 

    const wchar_t *bitStringValues , 
    const SnmpOctetString &bitStringValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

    BOOL valueStatus = TRUE ;

    ULONG bitCounter = 0 ;
    UCHAR *value = bitStringValue.GetValue () ;
    ULONG valueLength = bitStringValue.GetValueLength () ;
    ULONG valueIndex = 0 ;

    while ( valueIndex < valueLength ) 
    {
        for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
        {
            ULONG bitValue = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
            bitValue = value [ valueIndex ] & bitValue ;
            if ( bitValue )                 
            {
                bitValue = bit + ( valueIndex * 8 ) ;
                wchar_t *bitStringStringValue ;
                if ( integerMap.Lookup ( bitValue , bitStringStringValue ) )
                {
                }
                else
                {
                    valueStatus = FALSE ;
                }
            }
        }

        valueIndex ++ ;
    }

    octetString.SetValue ( bitStringValue.GetValue () , bitStringValue.GetValueLength () ) ;

    SnmpInstanceType :: SetStatus ( valueStatus ) ;

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpBitStringType :: SnmpBitStringType ( 

    const wchar_t *bitStringValues , 
    const wchar_t **bitStringValueArray , 
    const ULONG &bitStringValueLength 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

    BOOL valueStatus = TRUE ;

    if ( bitStringValueLength )
    {
        ULONG maximumValue = 0 ;
        for ( ULONG index = 0 ; index < bitStringValueLength ; index ++ )
        {
            ULONG bitStringIntegerValue ;
            const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
            if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
            {
                maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
            }
            else
            {
                SnmpAnalyser analyser ;
                analyser.Set ( bitStringValue ) ;
                SnmpLexicon *lookAhead = analyser.Get () ;
                switch ( lookAhead->GetToken () ) 
                {
                    case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                    {
                        ULONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
                        maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
                    }   
                    break ;

                    default:
                    {
                        valueStatus = FALSE ;
                    }
                    break ;
                }

                delete lookAhead ;
            }
        }

        if ( valueStatus )
        {
            ULONG valueLength = ( maximumValue >> 3 ) + 1 ;
            UCHAR *value = new UCHAR [ valueLength ] ;
            memset ( value , 0 , sizeof ( UCHAR ) ) ;
            
            for ( ULONG index = 0 ; ( index < bitStringValueLength ) && valueStatus ; index ++ )
            {
                ULONG bitStringIntegerValue ;
                const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
                if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
                {
                    ULONG byte = bitStringIntegerValue >> 3 ;
                    UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
                    bit = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                    value [ byte ] = value [ byte ] | bit ;
                }
                else
                {
                    SnmpAnalyser analyser ;
                    analyser.Set ( bitStringValue ) ;
                    SnmpLexicon *lookAhead = analyser.Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                        {
                            LONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
                            ULONG byte = bitStringIntegerValue >> 3 ;
                            UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
                            bit = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                            value [ byte ] = value [ byte ] | bit ;
                        }   
                        break ;

                        default:
                        {
                        }
                        break ;
                    }

                    delete lookAhead ;

                    valueStatus = FALSE ;
                }
            }

            octetString.SetValue ( value , valueLength ) ;
            delete [] value ;
        }
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    SnmpInstanceType :: SetStatus ( valueStatus ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpBitStringType :: SnmpBitStringType ( 

    const SnmpBitStringType &copy

) : SnmpOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.integerMap.GetStartPosition () ;
    while ( position )
    {
        ULONG bitStringIntegerValue ;
        wchar_t *bitStringStringValue ;
        copy.integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

        wchar_t *stringCopy = new wchar_t [ wcslen ( bitStringStringValue ) + 1 ] ;
        wcscpy ( stringCopy , bitStringStringValue ) ;

        integerMap [ bitStringIntegerValue ] = stringCopy ;
        stringMap [ stringCopy ] = bitStringIntegerValue ;
    }
}

SnmpBitStringType :: SnmpBitStringType (

    const wchar_t *bitStringValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;
}

SnmpBitStringType :: ~SnmpBitStringType ()
{
    POSITION position = integerMap.GetStartPosition () ;
    while ( position )
    {
        ULONG bitStringIntegerValue ;
        wchar_t *bitStringStringValue ;
        integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

        delete [] bitStringStringValue ;
    }

    integerMap.RemoveAll () ;
    stringMap.RemoveAll () ;

    delete pushBack ;
}

ULONG SnmpBitStringType :: GetValue ( wchar_t **&stringValue ) const
{
    ULONG stringValueLength = 0 ;
    stringValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        ULONG valueIndex = 0 ;

        BOOL valueStatus = TRUE ;

        while ( ( valueIndex < valueLength ) && valueStatus )
        {
            for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
            {
                ULONG bitValue = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                bitValue = value [ valueIndex ] & bitValue ;
                if ( bitValue )                 
                {
                    stringValueLength ++ ;
                }
            }

            valueIndex ++ ;
        }

        if ( stringValueLength )
        {
            stringValue = new wchar_t * [ stringValueLength ] ;

            ULONG stringValueIndex = 0 ;
            valueIndex = 0 ;
            while ( valueIndex < valueLength ) 
            {
                for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
                {
                    ULONG bitValue = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                    bitValue = value [ valueIndex ] & bitValue ;
                    if ( bitValue )                 
                    {
                        bitValue = bit + ( valueIndex << 3 ) ;
                        wchar_t *bitStringStringValue ;
                        if ( integerMap.Lookup ( ( LONG ) bitValue , bitStringStringValue ) )
                        {
                            stringValue [ stringValueIndex ++ ] = UnicodeStringDuplicate ( bitStringStringValue ) ;
                        }
                        else
                        {
                            wchar_t stringValueBuffer [ 40 ] ;
                            _ultow ( bitValue , stringValueBuffer , 10 );
                            wchar_t *returnValue = new wchar_t [ wcslen ( stringValueBuffer ) + 1 ] ;
                            wcscpy ( returnValue , stringValueBuffer ) ;
                            stringValue [ stringValueIndex ++ ] = returnValue ;

                            valueStatus = FALSE ;
                        }
                    }
                }

                valueIndex ++ ;
            }
        }
    }

    return stringValueLength ;
}

wchar_t *SnmpBitStringType :: GetStringValue () const
{
    return SnmpOctetStringType :: GetStringValue () ;
}

SnmpInstanceType *SnmpBitStringType :: Copy () const
{
    return new SnmpBitStringType ( *this ) ;
}

BOOL SnmpBitStringType :: Parse ( const wchar_t *bitStringValues )
{
    BOOL status = TRUE ;

    analyser.Set ( bitStringValues ) ;

    return BitStringDef () && RecursiveDef () ;
}

BOOL SnmpBitStringType :: BitStringDef ()
{
    BOOL status = TRUE ;

    wchar_t *bitStringString = NULL ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: TOKEN_ID:
        {
            wchar_t *tokenString = lookAhead->GetValue()->token ;
            bitStringString = new wchar_t [ wcslen ( tokenString ) + 1 ] ;
			try
			{
				wcscpy ( bitStringString , tokenString ) ;

				SnmpLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case SnmpLexicon :: OPEN_PAREN_ID:
					{
						SnmpLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case SnmpLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG bitStringInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ bitStringInteger ] = bitStringString ;
								stringMap [ bitStringString ] = bitStringInteger ;
								bitStringString = NULL;

								Match ( SnmpLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch(...)
			{
				if ( bitStringString )
				{
					delete [] bitStringString ;
				}

				throw;
			}

			if ( bitStringString )
			{
				delete [] bitStringString ;
			}
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpBitStringType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            BitStringDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

void SnmpBitStringType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpBitStringType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpBitStringType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    SnmpInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
    return SnmpInstanceType :: IsValid () ? lexicon : NULL ;
}

SnmpDateTimeType :: SnmpDateTimeType ( 

    const SnmpOctetString &dateTimeValue 

) : SnmpOctetStringType ( dateTimeValue , NULL ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    ULONG valueLength = dateTimeValue.GetValueLength () ;
    if ( valueLength != 8 && valueLength != 11 )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpDateTimeType :: SnmpDateTimeType ( 

    const wchar_t *dateTimeValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( dateTimeValue ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpDateTimeType :: SnmpDateTimeType ( 

    const SnmpDateTimeType &copy

) : SnmpOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

SnmpDateTimeType :: SnmpDateTimeType () : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

SnmpDateTimeType :: ~SnmpDateTimeType ()
{
}

wchar_t *SnmpDateTimeType :: GetValue () const
{
    wchar_t *stringValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG valueLength = octetString.GetValueLength () ;
        
        if (valueLength == 8 || valueLength == 11)
        {
            UCHAR *value = octetString.GetValue () ;

            USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
            UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
            UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
            UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
            UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
            UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
            UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

            char dateTime [ 80 ] ;
            ostrstream oStrStream(dateTime, 80) ;

            oStrStream << ( ULONG ) ( ntohs ( *yearPtr ) ) ;
            oStrStream << "-" ;
            oStrStream << ( ULONG ) ( *monthPtr ) ;
            oStrStream << "-" ;
            oStrStream << ( ULONG ) ( *dayPtr ) ;
            oStrStream << "," ;
            oStrStream << ( ULONG ) ( *hourPtr ) ;
            oStrStream << ":" ;
            oStrStream << ( ULONG ) ( *minutesPtr ) ;
            oStrStream << ":" ;
            oStrStream << ( ULONG ) ( *secondsPtr ) ;
            oStrStream << "." ;
            oStrStream << ( ULONG ) ( *deciSecondsPtr ) ;

            if ( valueLength == 11 )
            {
                UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
                UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
                UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

                oStrStream << "," ;
        
                if ( *UTC_directionPtr == '+' )
                {
                    oStrStream << "+" ;
                }
                else
                {
                    oStrStream << "-" ;
                }

                oStrStream << ( ULONG ) ( *UTC_hoursPtr ) ;
                oStrStream << ":" ;
                oStrStream << ( ULONG ) ( *UTC_minutesPtr ) ;
            }

            oStrStream << ends ;

            stringValue = DbcsToUnicodeString ( dateTime ) ;
        }
    }

    if (!stringValue)
    {
        stringValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return stringValue ;
}

wchar_t *SnmpDateTimeType :: GetStringValue () const
{
    wchar_t *stringValue = GetValue () ;
    return stringValue ;
}

SnmpInstanceType *SnmpDateTimeType :: Copy () const
{
    return new SnmpDateTimeType ( *this ) ;
}

BOOL SnmpDateTimeType :: Parse ( const wchar_t *dateTimeValues )
{
    BOOL status = TRUE ;

    analyser.Set ( dateTimeValues ) ;

    return DateTimeDef () ;
}

BOOL SnmpDateTimeType :: DateTimeDef ()
{
    BOOL status = TRUE ;

    ULONG year = 0 ;
    ULONG month = 0 ;
    ULONG day = 0 ;
    ULONG hour = 0 ;
    ULONG minutes = 0 ;
    ULONG seconds = 0 ;
    ULONG deciSeconds = 0 ;
    ULONG UTC_present = FALSE ;
    ULONG UTC_direction = 0 ;
    ULONG UTC_hours = 0 ;
    ULONG UTC_minutes = 0 ;

    SnmpLexicon *lookAhead = NULL ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    year = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: MINUS_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    month = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: MINUS_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    day = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: COMMA_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    hour = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    minutes = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    seconds = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: DOT_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    deciSeconds = lookAhead->GetValue()->unsignedInteger ;

    lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            lookAhead = Get () ;
            switch ( lookAhead->GetToken () ) 
            {
                case SnmpLexicon :: PLUS_ID:
                {
                    UTC_present = TRUE ;
                    UTC_direction = '+' ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_hours = lookAhead->GetValue()->unsignedInteger ;

                    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
                }
                break ;

                case SnmpLexicon :: MINUS_ID:
                {
                    UTC_present = TRUE ;
                    UTC_direction = '-' ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_hours = lookAhead->GetValue()->unsignedInteger ;

                    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
                }
                break ;

                default:
                {
                    status = FALSE ;
                }
                break ;
            }
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
        }
        break ;
    
        default:
        {
            status = FALSE ;
        }
        break ; 
    }

    if ( status ) 
    {
        status = FALSE ;

        if ( year <= 65535 )
        if ( month >= 1 && month <= 12 )
        if ( day >= 1 && day <= 31 )
        if ( hour <= 23 )
        if ( minutes <= 59 )
        if ( seconds <= 60 )
        if ( UTC_present )
        {
            if ( UTC_hours <= 11 )
            if ( UTC_minutes <= 59 )
            {
                status = TRUE ;
            }
        }
        else
        {
            status = TRUE ;
        }

        if ( status )
        {

// Encode here

            Encode ( 

                year ,
                month ,
                day ,
                hour ,
                minutes ,
                seconds ,
                deciSeconds ,
                UTC_present ,
                UTC_direction ,
                UTC_hours ,
                UTC_minutes
            ) ;
        }
    }

    return status ;
}

void SnmpDateTimeType :: Encode (

    const ULONG &year ,
    const ULONG &month ,
    const ULONG &day ,
    const ULONG &hour ,
    const ULONG &minutes ,
    const ULONG &seconds ,
    const ULONG &deciSeconds ,
    const ULONG &UTC_present ,
    const ULONG &UTC_direction ,
    const ULONG &UTC_hours ,
    const ULONG &UTC_minutes
) 
{
    UCHAR *value = NULL ;
    ULONG valueLength = 0 ;

    if ( UTC_present )
    {
        valueLength = 11 ;
    }
    else
    {   
        valueLength = 8 ;
    }

    value = new UCHAR [ valueLength ] ;

    USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
    UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
    UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
    UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
    UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
    UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
    UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

    *yearPtr = htons ( ( USHORT ) year ) ;
    *monthPtr = ( UCHAR ) month ;
    *dayPtr = ( UCHAR ) day ;
    *hourPtr = ( UCHAR ) hour ;
    *minutesPtr = ( UCHAR ) minutes ;
    *secondsPtr = ( UCHAR ) seconds ;
    *deciSecondsPtr = ( UCHAR ) deciSeconds ;

    if ( UTC_present )
    {
        UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
        UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
        UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

        *UTC_directionPtr = ( UCHAR ) UTC_direction ;
        *UTC_hoursPtr = ( UCHAR ) UTC_hours ;
        *UTC_minutesPtr = ( UCHAR ) UTC_minutes ;
    }

    octetString.SetValue ( value , valueLength ) ;

    delete [] value ;
}

void SnmpDateTimeType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpDateTimeType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE , TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpDateTimeType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    SnmpInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
    return SnmpInstanceType :: IsValid () ? lexicon : NULL ;
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const SnmpOctetString &osiAddressArg 

) : SnmpOctetStringType ( osiAddressArg , NULL ) 
{
    if ( osiAddressArg.GetValueLength () > 1 )
    {
        UCHAR *value = osiAddressArg.GetValue () ;
        ULONG NSAPLength = value [ 0 ] ;

        if ( ! ( NSAPLength < osiAddressArg.GetValueLength () ) )
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const SnmpOSIAddressType &osiAddressArg 

) : SnmpOctetStringType ( osiAddressArg ) 
{
}

SnmpInstanceType *SnmpOSIAddressType :: Copy () const 
{
    return new SnmpOSIAddressType ( *this ) ;
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const wchar_t *osiAddressArg 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL )  
{
    SnmpInstanceType :: SetStatus ( Parse ( osiAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpOSIAddressType :: Parse ( const wchar_t *osiAddress ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;


/* 
 * OSIAddress Definitions
 */

/*
         -- for a SnmpOSIAddress of length m:
          --
          -- octets   contents            encoding
          --    1     length of NSAP      "n" as an unsigned-integer
          --                                (either 0 or from 3 to 20)
          -- 2..(n+1) NSAP                concrete binary representation
          -- (n+2)..m TSEL                string of (up to 64) octets
          --
          SnmpOSIAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "*1x:/1x:"
              STATUS       current
              DESCRIPTION
                      "Represents an OSI transport-address."
              SYNTAX       OCTET STRING (SIZE (1 | 4..85))
*/

    UCHAR *OSIValue = new UCHAR [ 1 + 20 + 64 ] ;

    UCHAR NSAPLength = 0 ;
    ULONG TSELLength = 0 ;

    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = osiAddress [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                {
                    if ( token == L'/' ) 
                        state = 4 ;
                    else 
                        state = REJECT_STATE ;  
                }
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    OSIValue [ 1 + NSAPLength ] = ( UCHAR ) byte ;
                    state = 3 ;
                    NSAPLength ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L':' )
                {
                    if ( NSAPLength < 20 ) 
                    {
                        state = 1 ;
                    }
                    else 
                        state = REJECT_STATE ;
                }
                else 
                {
                    if ( token == L'/' )
                    {
                        if ( NSAPLength >= 2 ) 
                        {
                            OSIValue [ 0 ] = NSAPLength ;
                            state = 4 ;
                        }
                        else state = REJECT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            case 4:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 5 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 5:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    OSIValue [ 1 + NSAPLength + TSELLength ] = ( UCHAR ) byte ;
                    state = 6 ;
                    TSELLength ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 6:
            {
                if ( token == L':' )
                {
                    if ( TSELLength < 64 ) 
                    {
                        state = 4 ;
                    }
                    else state = REJECT_STATE ;
                }
                else 
                {
                    if ( token == 0 )
                    {
                        state = ACCEPT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( status )
    {
        octetString.SetValue ( OSIValue , 1 + NSAPLength + TSELLength ) ;
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    delete [] OSIValue ;

    return status ;
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const UCHAR *value , 
    const ULONG valueLength 

) : SnmpOctetStringType ( value , valueLength , NULL ) 
{
    if ( valueLength > 1 )
    {
        ULONG NSAPLength = value [ 0 ] ;

        if ( ! ( NSAPLength < valueLength ) )
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpOSIAddressType :: SnmpOSIAddressType () : SnmpOctetStringType ( NULL ) 
{
}

SnmpOSIAddressType :: ~SnmpOSIAddressType () 
{
}

wchar_t *SnmpOSIAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG octetStringLength = octetString.GetValueLength () ;       
        UCHAR *octetStringArray = octetString.GetValue () ;

        if ( octetStringLength >= 1 )
		{
			ULONG NSAPLength = octetStringArray [ 0 ] ;

			if ( NSAPLength < octetStringLength )
			{
				ULONG totalLength = 0 ;
				ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
				wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
    
				if (reallocArray == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}

				ULONG index = 1 ;
				while ( index <= NSAPLength ) 
				{
					wchar_t stringValue [ 4 ] ;

					if ( index != NSAPLength )
					{
						stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
						stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
						stringValue [ 2 ] = L':' ;
						stringValue [ 3 ] = 0 ;

						if ( ( totalLength + 3 + 1 ) >= reallocLength )
						{
							reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
							realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
						}

						wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
						totalLength = totalLength + 3 ;
					}
					else
					{
						stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
						stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
						stringValue [ 2 ] = 0 ;

						if ( ( totalLength + 2 + 1 ) >= reallocLength )
						{
							reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
							realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
						}

						wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
						totalLength = totalLength + 2 ;
					}


					index ++ ;
				}

				wchar_t stringValue [ 2 ] ;

				stringValue [ 0 ] = L'/' ;
				stringValue [ 1 ] = 0 ;

				if ( ( totalLength + 1 + 1 ) >= reallocLength )
				{
					reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
					realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
				}

				wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
				totalLength = totalLength + 1 ;

				while ( index < octetStringLength )
				{
					wchar_t stringValue [ 4 ] ;

					if ( index != ( octetStringLength - 1 ) )
					{
						stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
						stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
						stringValue [ 2 ] = L':' ;
						stringValue [ 3 ] = 0 ;

						if ( ( totalLength + 3 + 1 ) >= reallocLength )
						{
							reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
							realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
						}

						wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
						totalLength = totalLength + 3 ;
					}
					else
					{
						stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
						stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
						stringValue [ 2 ] = 0 ;

						if ( ( totalLength + 2 + 1 ) >= reallocLength )
						{
							reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
							realloc_throw ( &reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
						}

						wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
						totalLength = totalLength + 2 ;
					}


					index ++ ;
				}

				returnValue = new wchar_t [ totalLength + 1 ] ;
				wcscpy ( returnValue , reallocArray ) ;

				free ( reallocArray ) ;
			}
		}
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpUDPAddressType :: SnmpUDPAddressType ( 

    const SnmpOctetString &udpAddressArg 

) : SnmpFixedLengthOctetStringType ( 6 , udpAddressArg ) 
{
}

SnmpUDPAddressType :: SnmpUDPAddressType ( 

    const SnmpUDPAddressType &udpAddressArg 

) : SnmpFixedLengthOctetStringType ( udpAddressArg ) 
{
}

SnmpInstanceType *SnmpUDPAddressType :: Copy () const 
{
    return new SnmpUDPAddressType ( *this ) ;
}

SnmpUDPAddressType :: SnmpUDPAddressType ( 

    const wchar_t *udpAddressArg 

) : SnmpFixedLengthOctetStringType ( 6 )  
{
    SnmpInstanceType :: SetStatus ( Parse ( udpAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpUDPAddressType :: Parse ( const wchar_t *udpAddressArg ) 
{
    BOOL status = TRUE ;
/*
 *  Datum fields.
 */
    UCHAR udpAddress [ 6 ] ;

    ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
    ULONG positiveMagicPosDigit = 5 ;
    ULONG positiveDatum = 0 ;   

    ULONG datumA = 0 ;
    ULONG datumB = 0 ;
    ULONG datumC = 0 ;
    ULONG datumD = 0 ;

/*
 *  Parse input for dotted decimal IP Address.
 */

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = udpAddressArg [ position ++ ] ;

        switch ( state ) 
        {
/*
 *  Parse first field 'A'.
 */

            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = ( token - 48 ) ;
                    state = 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 2 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 3 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'B'.
 */
            case 4:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'C'.
 */
            case 8:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *  Parse first field 'D'.
 */
            case 12:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 16:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = 17 ;
                    positiveDatum = ( token - 48 ) ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case 17:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = 17 ;

                    if ( positiveDatum > 65535 ) state = REJECT_STATE ;
    
                    positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                }
                else if ( token == 0 )
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }   
            break ;
 
            default:
            {
                state = REJECT_STATE ;
            }
            break ;
        }
    }


/*
 *  Check boundaries for IP fields.
 */

    status = ( state != REJECT_STATE ) ;

    if ( state == ACCEPT_STATE )
    {
        status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
    }

    udpAddress [ 0 ] = ( UCHAR ) datumA ;
    udpAddress [ 1 ] = ( UCHAR ) datumB ;
    udpAddress [ 2 ] = ( UCHAR ) datumC ;
    udpAddress [ 3 ] = ( UCHAR ) datumD ;

    USHORT *portPtr = ( USHORT * ) & udpAddress [ 4 ] ;
    *portPtr = htons ( ( USHORT ) positiveDatum ) ;

    octetString.SetValue ( udpAddress , 6 ) ;

    return status ; 
}

SnmpUDPAddressType :: SnmpUDPAddressType ( const UCHAR *value ) : SnmpFixedLengthOctetStringType ( 6 , value ) 
{
}

SnmpUDPAddressType :: SnmpUDPAddressType () : SnmpFixedLengthOctetStringType ( 6 ) 
{
}

SnmpUDPAddressType :: ~SnmpUDPAddressType () 
{
}

wchar_t *SnmpUDPAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        if ( valueLength == 6 )
		{
			char ipxAddress [ 40 ] ;
			ostrstream oStrStream ( ipxAddress , 40 ) ;

			oStrStream << ( ( ULONG ) value [ 0 ] ) ;
			oStrStream << "." ;
			oStrStream << ( ( ULONG ) value [ 1 ] ) ;
			oStrStream << "." ;
			oStrStream << ( ( ULONG ) value [ 2 ] ) ;
			oStrStream << "." ;
			oStrStream << ( ( ULONG ) value [ 3 ] ) ;

			oStrStream << "/" ;
    
			ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 4 ] ) ) ;

			oStrStream << portNumber ;

			oStrStream << ends ;

			returnValue = DbcsToUnicodeString ( ipxAddress ) ;
		}
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const SnmpOctetString &ipxAddressArg ) : SnmpFixedLengthOctetStringType ( 12 , ipxAddressArg ) 
{
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const SnmpIPXAddressType &ipxAddressArg ) : SnmpFixedLengthOctetStringType ( ipxAddressArg ) 
{
}

SnmpInstanceType *SnmpIPXAddressType :: Copy () const 
{
    return new SnmpIPXAddressType ( *this ) ;
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const wchar_t *ipxAddressArg ) : SnmpFixedLengthOctetStringType ( 12 )  
{
    SnmpInstanceType :: SetStatus ( Parse ( ipxAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpIPXAddressType :: Parse ( const wchar_t *ipxAddressArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    UCHAR ipxAddress [ 12 ] ;

/*
          SnmpIPXAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "4x.1x:1x:1x:1x:1x:1x.2d"
              STATUS       current
              DESCRIPTION
                      "Represents an IPX address."
              SYNTAX       OCTET STRING (SIZE (12))
 */

/* 
 * IPXAddress Definitions
 */

    ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
    ULONG positiveMagicPosDigit = 5 ;
    ULONG positiveDatum = 0 ;   

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

#define NETWORK_HEX_INTEGER_START 0
#define STATION_HEX_INTEGER_START 100
#define PORT_DEC_INTEGER_START 200

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = ipxAddressArg [ position ++ ] ;
        switch ( state )
        {
            case NETWORK_HEX_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = NETWORK_HEX_INTEGER_START + 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case NETWORK_HEX_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    ipxAddress [ length ] = ( UCHAR ) byte ;
                    state = NETWORK_HEX_INTEGER_START + 2 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case NETWORK_HEX_INTEGER_START+2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = NETWORK_HEX_INTEGER_START + 1 ;
                }
                else
                {
                    if ( token == L'.' ) 
                    {
                        if ( length ==4 )
                        {
                            state = STATION_HEX_INTEGER_START ;
                        }
                        else
                            state = REJECT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            case STATION_HEX_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = STATION_HEX_INTEGER_START + 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case STATION_HEX_INTEGER_START + 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    ipxAddress [ length ] = ( UCHAR ) byte ;
                    state = STATION_HEX_INTEGER_START + 2 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case STATION_HEX_INTEGER_START + 2 :
            {
                if ( token == L':' )
                {
                    state = STATION_HEX_INTEGER_START ;
                }
                else 
                {
                    if ( token == L'.' )
                    {
                        if ( length == 10 ) 
                        {
                            state = PORT_DEC_INTEGER_START ;
                        }
                        else state = REJECT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            case PORT_DEC_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = PORT_DEC_INTEGER_START + 1 ;
                    positiveDatum = ( token - 48 ) ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case PORT_DEC_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = PORT_DEC_INTEGER_START + 1 ;

                    if ( positiveDatum > 65535 ) state = REJECT_STATE ;
    
                    positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                }
                else 
                {
                    if ( token == 0 )
                    {
                        USHORT *portPtr = ( USHORT * ) & ipxAddress [ 10 ] ;
                        *portPtr = htons ( ( USHORT ) positiveDatum ) ;

                        state = ACCEPT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }   
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( status )
    {
        octetString.SetValue ( ipxAddress , 12 ) ;
    }

    return status ;
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const UCHAR *value ) : SnmpFixedLengthOctetStringType ( 12 , value ) 
{
}

SnmpIPXAddressType :: SnmpIPXAddressType () : SnmpFixedLengthOctetStringType ( 12 ) 
{
}

SnmpIPXAddressType :: ~SnmpIPXAddressType () 
{
}

wchar_t *SnmpIPXAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;

        if ( valueLength == 12 )
		{
			char ipxAddress [ 80 ] ;
			ostrstream oStrStream ( ipxAddress , 80) ;

			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 0 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 0 ] & 0xf ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 1 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 1 ] & 0xf ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 2 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 2 ] & 0xf ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 3 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 3 ] & 0xf ) ;

			oStrStream << "." ;
    
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 4 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 4 ] & 0xf ) ;
			oStrStream << ":" ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 5 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 5 ] & 0xf ) ;
			oStrStream << ":" ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 6 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 6 ] & 0xf ) ;
			oStrStream << ":" ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 7 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 7 ] & 0xf ) ;
			oStrStream << ":" ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 8 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 8 ] & 0xf ) ;
			oStrStream << ":" ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 9 ] >> 4 ) ;
			oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 9 ] & 0xf ) ;

			oStrStream << "." ;

			ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 10 ] ) ) ;

			oStrStream << portNumber ;

			oStrStream << ends ;

			returnValue = DbcsToUnicodeString ( ipxAddress ) ;
		}
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}


SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const SnmpUInteger32 &ui_integerArg ,
    const wchar_t *rangeValues
    
) : SnmpPositiveRangedType ( rangeValues ) , ui_integer32 ( ui_integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( ui_integer32.GetValue () ) ) ;
    }
}

SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const SnmpUInteger32Type &ui_integerArg 

) :  SnmpInstanceType ( ui_integerArg ) , SnmpPositiveRangedType ( ui_integerArg ) , ui_integer32 ( ui_integerArg.ui_integer32 ) 
{
}

SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const wchar_t *ui_integerArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , ui_integer32 ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( ui_integerArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( ui_integer32.GetValue () ) ) ;
    }
}

SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const ULONG ui_integerArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , ui_integer32 ( ui_integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( ui_integer32.GetValue () ) ) ;
    }
}

SnmpUInteger32Type :: SnmpUInteger32Type ( const wchar_t *rangeValues ) : SnmpPositiveRangedType ( rangeValues ) , 
                                                                SnmpInstanceType ( TRUE , TRUE ) , 
                                                                ui_integer32 ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpUInteger32Type :: ~SnmpUInteger32Type () 
{
}

BOOL SnmpUInteger32Type :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = ui_integer32.GetValue() == ((const SnmpUInteger32Type&)value).ui_integer32.GetValue();
    }

    return bResult;
}

SnmpInstanceType *SnmpUInteger32Type :: Copy () const 
{
    return new SnmpUInteger32Type ( *this ) ;
}

BOOL SnmpUInteger32Type :: Parse ( const wchar_t *ui_integerArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( ui_integerArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            ui_integer32.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpUInteger32Type :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG ui_integer32Value = ui_integer32.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & ui_integer32Value , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpUInteger32Type :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        ui_integer32.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpUInteger32Type :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & ui_integer32 : NULL ;
}

wchar_t *SnmpUInteger32Type :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull ()  )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( ui_integer32.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpUInteger32Type :: GetValue () const
{
    return ui_integer32.GetValue () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\transp.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: transp.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "address.h"
#include "tsess.h"
#include "tsent.h"
#include "idmap.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "opreg.h"

#include "session.h"
#include "transp.h"

/*------------------------------------------------------------
Purpose: The SnmpTransport class provides the implementation 
of the transport protocol layer for use by the SnmpSession class. 
The SnmpImpTransport provides a UDP implementation of the 
transport layer.
-------------------------------------------------------------*/

TransportFrameId SnmpImpTransport::next_transport_frame_id = ILLEGAL_TRANSPORT_FRAME_ID ;

SnmpTransport::SnmpTransport (

    IN SnmpSession &session,
    IN const SnmpTransportAddress &transportAddress

) :transport_address(transportAddress.Copy())
{
}
    
SnmpTransportAddress &SnmpTransport::GetTransportAddress() 
{
    return *transport_address;
}

SnmpTransport::~SnmpTransport()
{
    delete transport_address;
}

SnmpImpTransport::SnmpImpTransport (

    IN SnmpSession &session,
    IN const SnmpTransportAddress &address

) :     SnmpTransport(session, address),
        session(session)
{
    is_valid = FALSE;
    transport_created = FALSE;

    if ( !GetTransportAddress()() )
        return;

    try {

        transport = new TransportWindow(*this);
    }
	catch ( Heap_Exception e_He )
	{
		return ;
	}
    catch ( GeneralException exception ) 
    {
        return ; 
    }

    transport_created = TRUE;

    if ( !(*transport)() )
        return;

    is_valid = TRUE;
}


SnmpImpTransport::~SnmpImpTransport(void)
{
    if ( transport_created )
        delete transport;
}


void SnmpImpTransport::TransportSendFrame(

    OUT TransportFrameId &transport_frame_id, 
    IN SnmpPdu &snmpPdu
)
{
    if ( next_transport_frame_id == ILLEGAL_TRANSPORT_FRAME_ID )
        next_transport_frame_id++;

    store.Register(transport_frame_id, SnmpErrorReport(Snmp_Success, Snmp_No_Error) );

    transport->PostMessage(Window :: g_SentFrameEvent,
                           transport_frame_id, 0);


DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"posted: transport_frame_id = %d\n", transport_frame_id
    ) ;
)

    try 
    {
        if ( transport->SendPdu(snmpPdu) == FALSE )
            store.Modify(transport_frame_id, SnmpErrorReport(Snmp_Error, Snmp_Local_Error));
    }
	catch ( Heap_Exception e_He )
	{
        store.Modify(transport_frame_id, SnmpErrorReport(Snmp_Error, Snmp_Local_Error));
	}
    catch ( GeneralException exception )
    {
        store.Modify(transport_frame_id, SnmpErrorReport(Snmp_Error, Snmp_Local_Error));
    }
}

void SnmpImpTransport::HandleSentFrame(IN TransportFrameId transport_frame_id)
{
    TransportSentFrame(transport_frame_id, store.Remove(transport_frame_id));
}

void SnmpImpTransport::TransportSentFrame(IN TransportFrameId transport_frame_id, 
                                            IN SnmpErrorReport &errorReport)
{
    session.SessionSentFrame(transport_frame_id, errorReport);
}

void SnmpImpTransport::TransportReceiveFrame (

    IN SnmpPdu &snmpPdu ,
    IN SnmpErrorReport &errorReport 
)
{
    session.SessionReceiveFrame(snmpPdu, errorReport);
}

SnmpUdpIpTransport :: SnmpUdpIpTransport (

    IN SnmpSession &session,
    IN const SnmpTransportIpAddress &ipAddress

) : SnmpImpTransport ( session , ipAddress ) 
{
}

void * SnmpUdpIpImp::operator()(void) const
{
    if ( ( SnmpTransportIpAddress::operator()() == NULL ) ||
        ( SnmpImpTransport::operator()() == NULL ) )
        return NULL;
    else
        return (void *)this;
}

SnmpIpxTransport :: SnmpIpxTransport (

    IN SnmpSession &session,
    IN const SnmpTransportIpxAddress &ipxAddress

) : SnmpImpTransport ( session , ipxAddress ) 
{
}

void * SnmpIpxImp::operator()(void) const
{
    if ( ( SnmpTransportIpxAddress::operator()() == NULL ) ||
        ( SnmpImpTransport::operator()() == NULL ) )
        return NULL;
    else
        return (void *)this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\timer.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: timer.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "timer.h"
#include "message.h"
#include "dummy.h"

#include "flow.h"
#include "frame.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"

SnmpClThreadObject *Timer :: g_timerThread = NULL ;
UINT Timer :: g_SnmpWmTimer = SNMP_WM_TIMER ;

// static CriticalSection and CMap
CriticalSection Timer::timer_CriticalSection;
TimerMapping Timer::timer_mapping;

TimerEventId Timer :: next_timer_event_id = ILLEGAL_TIMER_EVENT_ID+1 ;
Window *SnmpTimerObject :: window = NULL ;
CMap <UINT_PTR,UINT_PTR,SnmpTimerObject *,SnmpTimerObject *> SnmpTimerObject :: timerMap ;

SnmpClThreadObject :: SnmpClThreadObject () : SnmpThreadObject ( "SnmpCl" ) 
{
}

void SnmpClThreadObject :: Initialise ()
{
}
 
void SnmpClThreadObject :: Uninitialise ()
{
    delete SnmpTimerObject :: window ;
    SnmpTimerObject :: window = NULL ;
    delete this ;
}

SnmpClTrapThreadObject :: SnmpClTrapThreadObject () : SnmpThreadObject ( "SnmpClTrapThread" ) 
{
}

void SnmpClTrapThreadObject :: Initialise ()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClTrapThreadObject::Initialise: Initialised!!\n"

    ) ;
)
}
 
void SnmpClTrapThreadObject :: Uninitialise ()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClTrapThreadObject::Uninitialise: About to destroy trap thread\n"

    ) ;
)
    delete this ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClTrapThreadObject::Uninitialise: Trap thread destroyed!!\n"

    ) ;
)
}


Timer::Timer(SnmpImpSession &session)
{
    Timer::session = &session;
}

BOOL Timer::CreateCriticalSection()
{
    return TRUE;
}

void Timer::DestroyCriticalSection()
{
}

BOOL Timer::InitializeStaticComponents()
{
    return CreateCriticalSection();
}

void Timer::DestroyStaticComponents()
{
    DestroyCriticalSection();
}

// generates and returns a new event id
// associates the pair (event_id, waiting_message)
// creates the timer event
TimerEventId Timer::SetTimerEvent(UINT timeout_value)
{
    TimerEventId suggested_event_id = next_timer_event_id++;
    if ( suggested_event_id == ILLEGAL_TIMER_EVENT_ID )
       suggested_event_id = next_timer_event_id++;

    // let the dummy session receive the window messages for timer events
    TimerEventId event_id = 
        SnmpSetTimer( session->m_SessionWindow.GetWindowHandle(), suggested_event_id, 
                  timeout_value, NULL );

    if ( (event_id == ILLEGAL_TIMER_EVENT_ID) ||
         (event_id != suggested_event_id) )
         throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

    return event_id;
}

// generates and returns a new event id
// associates the pair (event_id, waiting_message)
// creates the timer event
void Timer::SetMessageTimerEvent(WaitingMessage &waiting_message)
{
    CriticalSectionLock session_lock(session->session_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        return; // no use throwing exception

    TimerEventId event_id = session->timer_event_id;
    // register the timer event in both the instance CMap and the global CMap
    waiting_message_mapping.AddTail ( &waiting_message ) ;

    session_lock.UnLock();   

    CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

    if ( !timer_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    timer_mapping[event_id] = this;

    timer_lock.UnLock();   

}

// Removes the association (event_id, waiting_message)
// and also kills the registered timer event
void Timer::CancelMessageTimer(WaitingMessage &waiting_message,TimerEventId event_id)
{
    CriticalSectionLock session_lock(session->session_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        return; // no use throwing exception

    // remove the timer event from the instance CMap

    POSITION t_Position = waiting_message_mapping.GetHeadPosition () ;
    while ( t_Position )
    {
        POSITION t_OldPosition = t_Position ;
        WaitingMessage *t_Message = waiting_message_mapping.GetNext ( t_Position ) ;
        if ( t_Message == & waiting_message )
        {
            waiting_message_mapping.RemoveAt(t_OldPosition);
            break ;
        }
    }

    session_lock.UnLock();   

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Cancelled Message TimerEvent %d\n", event_id
    ) ;
)

}


// Removes the association (event_id, waiting_message)
// and also kills the registered timer event
void Timer::CancelTimer(TimerEventId event_id)
{
    CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

    if ( !timer_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    // remove the timer event from the global CMap
    timer_mapping.RemoveKey(event_id);

    timer_lock.UnLock();   

    SnmpKillTimer(NULL, event_id);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Cancelled TimerEvent %d\n", event_id
    ) ;
)
}

// it determines the corresponding Timer and calls 
// its TimerEventNotification with the appropriate parameters
void CALLBACK Timer::HandleGlobalEvent(HWND hWnd ,UINT message,
                                       UINT_PTR idEvent, DWORD dwTime)
{
    CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

    if ( !timer_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    Timer *timer;
    TimerEventId event_id = idEvent;
    BOOL found = timer_mapping.Lookup(event_id, timer);

    timer_lock.UnLock();   

    // if no such timer event, return
    if ( !found )
        return;

    // let the timer handle the event
    timer->TimerEventNotification(event_id);

    return;
}


// used by the event handler to notify the timer event.
// it must notify the corresponding waiting message
void Timer::TimerEventNotification(TimerEventId event_id)
{
    CriticalSectionLock session_lock(session->session_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        return; // no use throwing exception

    WaitingMessage *waiting_message;

    // identify the waiting message corresponding to
    // the event_id. if no such event, ignore it

    POSITION t_Position = waiting_message_mapping.GetHeadPosition () ;
    while ( t_Position )
    {
        waiting_message = waiting_message_mapping.GetNext ( t_Position ) ;
        // notify the waiting message of the event
        waiting_message->TimerNotification();
    }

    // session_lock.UnLock();   The lock may be released at this point
}

// remove all the (timer_event_id, timer) associations
// from the static mapping data structure
Timer::~Timer(void)
{
    WaitingMessage *waiting_message;

    POSITION current = waiting_message_mapping.GetHeadPosition();

    while ( current != NULL )
    {
        waiting_message = waiting_message_mapping.GetNext(current);

        TimerEventId event_id = waiting_message->GetTimerEventId () ;

        CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

        if ( !timer_lock.GetLock(INFINITE) )
            throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

        timer_mapping.RemoveKey ( event_id  );

        timer_lock.UnLock(); 

        SnmpKillTimer(NULL, event_id );
    }

    waiting_message_mapping.RemoveAll();
}

SnmpTimerObject :: SnmpTimerObject (

    HWND hWndArg,               // handle of window for timer messages
    UINT_PTR timerIdArg,            // timer identifier
    UINT elapsedArg,            // time-out value
    TIMERPROC lpTimerFuncArg    // address of timer procedure

) : hWnd ( hWndArg ) ,
    timerId ( timerIdArg ) ,
    lpTimerFunc ( lpTimerFuncArg ) 
{
    if ( ! window )
        window = new Window ;

    timerId = SetTimer ( 

        window->GetWindowHandle(), 
        timerId , 
        elapsedArg , 
        lpTimerFunc 
    ) ;

    CriticalSectionLock session_lock(Timer::timer_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    if ( timerId ) 
    {
        timerMap [ timerId ] = this ;
    }
    else
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;
}

SnmpTimerObject :: ~SnmpTimerObject ()
{
    CriticalSectionLock session_lock(Timer::timer_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    timerMap.RemoveKey ( timerId );

    if (window)
    {
        KillTimer ( window->GetWindowHandle () , timerId ) ;
    }
}

void SnmpTimerObject :: TimerNotification ( HWND hWnd , UINT timerId )
{
    :: WaitPostMessage ( hWnd , Timer :: g_SnmpWmTimer , timerId , 0 ) ;
}

SnmpSetTimerObject :: SnmpSetTimerObject (

    HWND hWndArg,               // handle of window for timer messages
    UINT_PTR nIDEventArg,           // timer identifier
    UINT uElapseArg,            // time-out value
    TIMERPROC lpTimerFuncArg    // address of timer procedure

) : hWnd ( hWndArg ) ,
    timerId ( nIDEventArg ) ,
    elapsedTime ( uElapseArg ) ,
    lpTimerFunc ( lpTimerFuncArg ) 
{
}

SnmpSetTimerObject :: ~SnmpSetTimerObject ()
{
}

void SnmpSetTimerObject :: Process ()
{
    SnmpTimerObject *object = new SnmpTimerObject ( 

        hWnd ,
        timerId ,
        elapsedTime ,
        lpTimerFunc 
    ) ;

    Complete () ;
}

SnmpKillTimerObject :: SnmpKillTimerObject (

    HWND hWndArg ,              // handle of window that installed timer
    UINT_PTR uIDEventArg            // timer identifier

) : hWnd ( hWndArg ) ,
    timerId ( uIDEventArg ) , 
    status ( TRUE )
{
}

void SnmpKillTimerObject :: Process ()
{
    CriticalSectionLock session_lock(Timer::timer_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    SnmpTimerObject *object ;
    if ( SnmpTimerObject :: timerMap.Lookup ( timerId , object ) )
    {
        delete object ;
    }
    else
    {
        status = FALSE ;
    }

    Complete () ;   
}

UINT_PTR SnmpSetTimer (

    HWND hWnd,              // handle of window for timer messages
    UINT_PTR nIDEvent,          // timer identifier
    UINT uElapse,           // time-out value,
    TIMERPROC lpTimerFunc   // address of timer procedure
)
{
    SnmpSetTimerObject object ( hWnd , nIDEvent , uElapse , lpTimerFunc ) ;
    Timer :: g_timerThread->ScheduleTask ( object ) ;
    object.Exec () ;
    if ( object.Wait () )
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return object.GetTimerId () ;
    }
    else
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return FALSE ;
    }
}

BOOL SnmpKillTimer (

    HWND hWnd,      // handle of window that installed timer
    UINT_PTR uIDEvent   // timer identifier
)
{
    SnmpKillTimerObject object ( hWnd , uIDEvent ) ;

    Timer :: g_timerThread->ScheduleTask ( object ) ;

    object.Exec () ;
    if ( object.Wait () )
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return object.GetStatus () ;
    }
    else
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return FALSE ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\tsent.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: tsent.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "tsent.h"

void TransportSentStateStore::Register(IN TransportFrameId id, 
                              IN const SnmpErrorReport &error_report)
{
    store[id] = new SnmpErrorReport(error_report);
}

void TransportSentStateStore::Modify(IN TransportFrameId id, 
                            IN const SnmpErrorReport &error_report)
{
    SnmpErrorReport *old_error_report = NULL ;

    store.Lookup(id, old_error_report);

    if ( old_error_report )
    {
        old_error_report->SetError(error_report.GetError());
        old_error_report->SetStatus(error_report.GetStatus());
    }
}

SnmpErrorReport TransportSentStateStore::Remove(IN TransportFrameId id) 
{
    SnmpErrorReport *error_report = NULL ;

    store.Lookup(id, error_report);

    store.RemoveKey(id);

    SnmpErrorReport to_return ;

    if ( error_report )
    {
        to_return = (*error_report);
        delete error_report;
    }

    return to_return;
}

TransportSentStateStore::~TransportSentStateStore(void)
{
    // get the first position
    POSITION current = store.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        TransportFrameId id;
        SnmpErrorReport *error_report = NULL ;

        // get the next pair
        store.GetNextAssoc(current, id, error_report);

        // delete the ptr
        delete error_report;
    }

    // remove all the keys
    store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\trap.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "common.h"
#include "address.h"
#include "timer.h"
#include "sec.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "vblist.h"
#include "ophelp.h"
#include "window.h"
#include "trap.h"
#include "trapsess.h"

SnmpTrapManager *SnmpTrapManager ::s_TrapMngrPtr = NULL ;

SnmpTrapTaskObject::SnmpTrapTaskObject(SnmpTrapManager* managerPtr,
                                       SnmpWinSnmpTrapSession** pptrapsess)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::SnmpTrapTaskObject: Creating a new trap task object\n" 

    ) ;
)
    m_mptr = managerPtr;
    m_pptrapsess = pptrapsess;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::SnmpTrapTaskObject: Created a new trap task object\n" 

    ) ;
)
}


void SnmpTrapTaskObject::Process ()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::Process: Entering...\n" 

    ) ;
)

	try
	{
		*m_pptrapsess = new SnmpWinSnmpTrapSession(m_mptr);
		if (NULL == (**m_pptrapsess)())
		{
			(*m_pptrapsess)->DestroySession();
			*m_pptrapsess = NULL;
		}
	}
	catch ( Heap_Exception e_HE )
	{
		*m_pptrapsess = NULL;
	}

    Complete();

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::Process: Exiting\n" 

    ) ;
)
}


SnmpTrapManager::SnmpTrapManager() : m_trapThread ( NULL ), m_trapSession ( NULL )
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::SnmpTrapManager: Entering...\n" 

    ) ;
)
    m_bListening = FALSE;
    m_trapThread = new SnmpClTrapThreadObject;
	m_trapThread->BeginThread();

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::SnmpTrapManager: Exiting\n" 

    ) ;
)
}

SnmpTrapManager::~SnmpTrapManager()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Entering...\n" 

    ) ;
)

    if (NULL != m_trapSession)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Destroy the session\n" 

    ) ;
)
        m_trapSession->DestroySession();
    }
    
    if ( NULL != m_trapThread )
    {
DebugMacro4( 

 